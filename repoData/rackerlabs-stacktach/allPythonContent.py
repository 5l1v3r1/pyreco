__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# StackTach documentation build configuration file, created by
# sphinx-quickstart on Tue Jan 14 14:34:29 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ['sphinxcontrib.httpdomain']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'StackTach'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'StackTachdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'StackTach.tex', u'StackTach Documentation',
   u'Sandy Walsh', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'stacktach', u'StackTach Documentation',
     [u'Sandy Walsh'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'StackTach', u'StackTach Documentation',
   u'Sandy Walsh', 'StackTach', 'Usage, monitoring and billing for OpenStack.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = sample_local_settings
import os
STACKTACH_DB_ENGINE = 'django.db.backends.mysql'
STACKTACH_DB_NAME = 'stacktach'
STACKTACH_DB_HOST = 'localhost'
STACKTACH_DB_USERNAME = 'stacktach'
STACKTACH_DB_PASSWORD = ''
STACKTACH_DB_PORT = '3306'
STACKTACH_INSTALL_DIR = os.environ.get('STACKTACH_INSTALL_DIR', '')
STACKTACH_DEPLOYMENTS_FILE = os.environ.get('STACKTACH_DEPLOYMENTS_FILE', '')

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os, sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "stacktach.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = 003_populate_task_and_image
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import json
import sys

sys.path.append("/stacktach")

from stacktach import datetime_to_decimal as dt
from stacktach import image_type
from stacktach import models


if __name__ != '__main__':
    sys.exit(1)

states = {}


def fix_chunk(hours, length):
    now = datetime.datetime.utcnow()
    start = now - datetime.timedelta(hours=hours+length)
    end = now - datetime.timedelta(hours=hours)
    dstart = dt.dt_to_decimal(start)
    dend = dt.dt_to_decimal(end)

    done = 0
    updated = 0
    block = 0
    print "Hours ago (%d to %d) %d - %d" % (hours + length, hours, dstart, dend)
    updates = models.RawData.objects.filter(event='compute.instance.update',
                                            when__gt=dstart, when__lte=dend)\
                                    .only('task', 'image_type', 'json')

    for raw in updates:
        queue, body = json.loads(raw.json)
        payload = body.get('payload', {})
        task = payload.get('new_task_state', None)

        if task != None and task != 'None':
            states[task] = states.get(task, 0) + 1
            raw.task = task

        raw.image_type = image_type.get_numeric_code(payload, raw.image_type)
        updated += 1
        raw.save()

        done += 1
        if done >= 10000:
            block += 1
            done = 0
            print "# 10k blocks processed: %d (events %d)" % \
                                        (block, updated)
            updated = 0

    for kv in states.iteritems():
        print "%s = %d" % kv

for day in xrange(0, 90):
    hours = day * 24
    steps = 12
    chunk = 24 / steps
    for x in xrange(steps):
        fix_chunk(hours, chunk)
        hours += chunk

########NEW FILE########
__FILENAME__ = 006_populate_rebuilds_from_rawdata
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import os
import sys

try:
    import ujson as json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        import json

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import models
from stacktach import views

if __name__ != '__main__':
    sys.exit(1)

REBUILD_START = 'compute.instance.rebuild.start'
REBUILD_END = 'compute.instance.rebuild.end'


def add_past_usage(raws):

    count = raws.count()
    processed = 0
    print "%s events to be processed" % count
    last_update = datetime.datetime.utcnow()
    for raw in raws:
        json_dict = json.loads(raw.json)
        views.aggregate_usage(raw, json_dict[1])
        processed += 1
        if processed % 50 == 0:
            next_update = last_update + datetime.timedelta(seconds=30)
            if datetime.datetime.utcnow() > next_update:
                m = (processed, count - processed,
                     (float(processed) / count)*100)
                print "%s processed, %s to go, %.2f percent done" % m
                last_update = datetime.datetime.utcnow()
    print "completed processing %s events" % count


start_raws = models.RawData.objects.filter(event=REBUILD_START)
add_past_usage(start_raws)
end_raws = models.RawData.objects.filter(event=REBUILD_END)
add_past_usage(end_raws)

########NEW FILE########
__FILENAME__ = 006_populate_usage_from_rawdata
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import os
import sys

try:
    import ujson as json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        import json

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from django.core.exceptions import MultipleObjectsReturned

from stacktach import datetime_to_decimal as dt
from stacktach import models
from stacktach import views

if __name__ != '__main__':
    sys.exit(1)

events = ['compute.instance.create.start',
          'compute.instance.create.end',
          'compute.instance.rebuild.start',
          'compute.instance.rebuild.end',
          'compute.instance.resize.prep.start',
          'compute.instance.resize.prep.end',
          'compute.instance.finish_resize.end',
          'compute.instance.resize.revert.start',
          'compute.instance.resize.revert.end',
          'compute.instance.delete.end']


def usage_already_exists(raw):
    if raw.event == 'compute.instance.delete.end':
        # Since deletes only have one event, they either exist or they don't
        try:
            models.InstanceDeletes.objects.get(raw=raw)
        except models.InstanceDeletes.DoesNotExist:
            return False
        except MultipleObjectsReturned:
            return True
        return True
    else:
        # All other usage has multiple events, thus they can exist but be
        # incomplete.
        return False


def populate_usage(raw, body):
    if not usage_already_exists(raw):
        views.aggregate_usage(raw, body)


def print_status(event, completed, errored, total):
    out = (event, completed, errored, total - (completed + errored))
    print "%s: %s completed, %s errored, %s remaining" % out


def find_start_decimal():
    usage = models.InstanceUsage.objects.all().order_by('id')[0]
    usage_raw = models.RawData.objects.filter(request_id=usage.request_id)\
                                      .order_by('when')[0]
    delete = models.InstanceDeletes.objects.all().order_by('id')[0]
    # Start a day after receiving the first usage, just to be safe
    return min(usage_raw.when, delete.raw.when) + (60 * 60 * 24)

start_decimal = find_start_decimal()

print "Starting from date %s" % dt.dt_from_decimal(start_decimal)

for event in events:
    start = datetime.datetime.utcnow()

    raws = models.RawData.objects.filter(event=event, when__lte=start_decimal)
    total = raws.count()
    completed = 0
    errored = 0
    loc = 0

    print_status(event, completed, errored, total)
    update_interval = datetime.timedelta(seconds=30)
    next_update = start + update_interval
    while loc < total:
        new_loc = loc + 500
        for raw in raws[loc:new_loc]:
            try:
                json_dict = json.loads(raw.json)
                populate_usage(raw, json_dict[1])
                completed += 1
            except Exception:
                errored += 1
                print "Error with raw: %s" % raw.id

            if datetime.datetime.utcnow() > next_update:
                print_status(event, completed, errored, total)
                next_update = datetime.datetime.utcnow() + update_interval
        loc = new_loc

    end = datetime.datetime.utcnow()
    print_status(event, completed, errored, total)
    print "%s took %s" % (event, end - start)

########NEW FILE########
__FILENAME__ = 008_exists_audit_period
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import os
import sys

try:
    import ujson as json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        import json

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import models
from stacktach import utils


if __name__ != '__main__':
    sys.exit(1)


def print_update(total, completed, errored):
    to_go = total - (completed + errored)
    print "%s populated, %s to go, %s errored" % (completed, to_go, errored)

filters = {
    'audit_period_beginning__exact': None,
    'audit_period_ending__exact': None
}
exists = models.InstanceExists.objects.filter(**filters)

count = exists.count()
start = datetime.datetime.utcnow()
print "%s records to populate" % count

update_interval = datetime.timedelta(seconds=30)
next_update = start + update_interval

completed = 0
errored = 0
for exist in exists:
    try:
        notif = json.loads(exist.raw.json)
        payload = notif[1]['payload']
        beginning = utils.str_time_to_unix(payload['audit_period_beginning'])
        exist.audit_period_beginning = beginning
        ending = utils.str_time_to_unix(payload['audit_period_ending'])
        exist.audit_period_ending = ending
        exist.save()
        completed += 1
    except:
        print "Error with raw %s" % exist.id
        errored += 1

    if datetime.datetime.utcnow() > next_update:
        print_update(count, completed, errored)
        next_update = datetime.datetime.utcnow() + update_interval

########NEW FILE########
__FILENAME__ = 009_populate_past_launches
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import os
import sys

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from django.db.models import Min

from stacktach import models


if __name__ != '__main__':
    sys.exit(1)


def add_past_exists(start, end):
    exists = models.InstanceExists.objects.select_related()\
                                  .filter(audit_period_beginning=start,
                                          audit_period_ending=end)
    i = 0
    for exist in exists:
        i += 1
        print i
        if models.InstanceUsage.objects\
                 .filter(instance=exist.instance).count() == 0:
            # We got an exist record that we don't have any launches for
            values = {'instance': exist.instance,
                      'launched_at': exist.launched_at,
                      'instance_type_id': exist.instance_type_id,
                      'request_id': 'req-fake'}
            print values
            models.InstanceUsage(**values).save()


def find_earliest_daily_audit_period_beginning():
    where = 'audit_period_ending = audit_period_beginning + (60*60*24)'
    query = models.InstanceExists.objects.extra(where=[where])\
                                 .aggregate(Min('audit_period_beginning'))

    return query['audit_period_beginning__min']


start = find_earliest_daily_audit_period_beginning()
end = start + (60 * 60 * 24)

add_past_exists(start, end)

########NEW FILE########
__FILENAME__ = 010_populate_past_deletes
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import os
import sys

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from django.db.models import Min

from stacktach import models


if __name__ != '__main__':
    sys.exit(1)


def add_past_deletes(start, end):
    exists = models.InstanceExists.objects.select_related()\
                                  .filter(audit_period_beginning=start,
                                          audit_period_ending=end,
                                          deleted_at__isnull=False)
    i = 0
    for exist in exists:
        i += 1
        if models.InstanceDeletes.objects\
                 .filter(instance=exist.instance).count() == 0:
            # No deletes found for an instance that was deleted.
            values = {'instance': exist.instance,
                      'launched_at': exist.launched_at,
                      'deleted_at': exist.deleted_at}
            print values
            models.InstanceDeletes(**values).save()


def find_earliest_daily_audit_period_beginning():
    where = 'audit_period_ending = audit_period_beginning + (60*60*24)'
    query = models.InstanceExists.objects.extra(where=[where])\
                                 .aggregate(Min('audit_period_beginning'))

    return query['audit_period_beginning__min']


start = find_earliest_daily_audit_period_beginning()
end = start + (60 * 60 * 24)

add_past_deletes(start, end)

########NEW FILE########
__FILENAME__ = 011_populate_tenant_id_in_instanceexists_from_rawdata
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import os
import sys

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import models

if __name__ != '__main__':
    sys.exit(1)


def add_past_exists(instance_tenant_id_maps):
    update_count = 0
    for map in instance_tenant_id_maps:
        update_count += models.InstanceExists.objects.filter(instance=map['instance']).update(tenant=map['tenant'])
    print "updated %s rows" % update_count

distinct_exists_instances = models.InstanceExists.objects.all().values('instance').distinct()
instance_tenant_id_maps = models.RawData.objects.filter(instance__in=distinct_exists_instances).distinct().values('instance', 'tenant')
add_past_exists(instance_tenant_id_maps)

########NEW FILE########
__FILENAME__ = 011_populate_tenant_id_in_instanceusage_from_rawdata
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import os
import sys

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import models

if __name__ != '__main__':
    sys.exit(1)


def add_past_usages(instance_tenant_id_maps):
    update_count = 0
    for map in instance_tenant_id_maps:
        update_count += models.InstanceUsage.objects.filter(instance=map['instance']).update(tenant=map['tenant'])
    print "updated %s rows" % update_count

distinct_usage_instances = models.InstanceUsage.objects.all().values('instance').distinct()
instance_tenant_id_maps = models.RawData.objects.filter(instance__in=distinct_usage_instances).distinct().values('instance', 'tenant')
add_past_usages(instance_tenant_id_maps)

########NEW FILE########
__FILENAME__ = batch
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# This is a one-time utility script for backfilling reports.
# Be sure to set up your DJANGO_SETTINGS_MODULE env var first.

import datetime
import subprocess

start_date =  datetime.date(2013, 2, 17)

today = datetime.datetime.now().date()
target = today - datetime.timedelta(days=30)

done = today - start_date
days = done.days

while start_date != target:
    for region in ["dfw", "lon", "ord"]:
        cmd = "python pretty.py --utcdate %s --region %s  --store --percentile 97" % (start_date, region)
        print cmd
        subprocess.call(cmd, shell=True)

    start_date = start_date - datetime.timedelta(days=1)

########NEW FILE########
__FILENAME__ = error_details
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import json
import sys
import time
import os
import re

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))
from stacktach import datetime_to_decimal as dt
from stacktach import image_type
from stacktach import models


if __name__ != '__main__':
    sys.exit(1)


# To mask unique identifiers for categorizing notifications
def mask_msg(text):
    # Needs order because of how precedent effects masking.
    #
    # Example: REQ_ID has a UUID in it, but the meaning is different
    # in this context, so best to grab those first.
    #
    # LG_NUM usually represents a memory size; with the number of flavors
    # this can create a lot of noise.
    #
    # The intent is to remove noise from unimportant subtleties

    masking_regex = (
        (1, 'REQ_ID',
         r"req-[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"
         ),
        (2, 'UUID',
         r"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"
         ),
        (3, 'HOST_ADDRESS',
         r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b"
         ),
        (4, 'LG_NUM',
         r"\b\d{3}\d+\b"
         )
    )
    masked = str(text)
    for config in masking_regex:
        masked = re.sub(config[2], "$%s" % str(config[1]), masked)
    return masked


# Assemble message from exception object
def build_exc_msg(exc=None, separator=", "):

    """
    White-list exception components we're aware of, and leave a catch all;
    because of freeform exception objects from notifications.
    """

    if exc is None:
        return exc

    message = []
    if exc.get('kwargs', False):
        kwargs = exc['kwargs']
        if kwargs.get('value', False):
            value = kwargs['value']
            trcbk_index = value.rfind("Traceback")
            if trcbk_index > 0:
                value = str(value[:trcbk_index]) + "$TRACEBACK"
            message.append("value: %s" % value)

        # kwargs: generic message components that don't require more filter
        misc_list = ['reason', 'method', 'topic', 'exc_type',
                     'actual', 'code']
        for key in misc_list:
            if kwargs.get(key, False):
                message.append("%s: %s" % (key, kwargs[key]))
        # END generic message components in kwargs

        if kwargs.get('expected', False):
            message.append("expected: %s" % kwargs['expected'][0])

    if exc.get('details', False):
        details = exc['details']
        if type(details) is list:
            for item in details:
                message.append(str(item))
        elif type(details) is dict:
            for k, v in details.iteritems():
                message.append("%s: %s" % (k, v))
        elif type(details) is str:
            message.append(details)

    # exc: generic messages that don't require more filter
    misc_list = ['message', 'cmd', 'stderr', 'exit_code',
                 'code', 'description']
    for key in misc_list:
        if exc.get(key, False):
            message.append("%s: %s" % (key, exc[key]))

    if exc.get('stdout', False):
        if exc['stdout'] != "":
            message.append("stdout: %s" % exc['stdout'])
    #END generic message components in exc

    if len(message) == 0:
        for k, v in exc.iteritems():
            message.append("%s: %s" % (k, v))
    return separator.join(message)

if __name__ == '__main__':

    # Start report
    yesterday = datetime.datetime.utcnow().date() - datetime.timedelta(days=1)
    if len(sys.argv) == 2:
        try:
            t = time.strptime(sys.argv[1], "%Y-%m-%d")
            yesterday = datetime.datetime(*t[:6])
        except Exception, e:
            print e
            print "Usage: python error_details.py YYYY-MM-DD (the end date)"
            sys.exit(1)

    hours = 0
    length = 24

    start = datetime.datetime(year=yesterday.year, month=yesterday.month,
                              day=yesterday.day)
    end = start + datetime.timedelta(hours=length-1, minutes=59, seconds=59)

    deployments = {}

    instance_map = {}  # { uuid : [request_id, request_id, ...] }
    exception_counts = {}  # { exception_message : count }
    event_counts = {}  # { event_name : count }
    tenant_issues = {}
    codes = {}
    metadata = {
        'report_format': 'json',
        'instances': instance_map,
        'exception_counts': exception_counts,
        'event_counts': event_counts,
        'tenant_issues': tenant_issues,
        'codes': codes,
    }

    # Tell Stacky to format as JSON and set placeholders for various summaries
    report = [metadata]

    dstart = dt.dt_to_decimal(start)
    dend = dt.dt_to_decimal(end)

    for deploy in models.Deployment.objects.all():
        deployments[deploy.id] = deploy.name

    # Get all the instances that have changed in the last N hours ...
    updates = models.RawData.objects.filter(event='compute.instance.update',
                                            when__gt=dstart, when__lte=dend)\
                                    .values('instance').distinct()

    expiry = 60 * 60  # 1 hour
    cmds = ['create', 'rebuild', 'rescue', 'resize', 'snapshot']

    requests = models.RawData.objects.filter(when__gt=dstart, when__lte=dend)\
                                     .exclude(instance=None,
                                              event='compute.instance.exists')\
                                     .values('request_id', 'instance')\
                                     .distinct()
    inst_recs = {}
    for request in requests:
        uuid = request['instance']
        request_id = request['request_id']
        value = inst_recs.get(uuid, [])
        value.append(request_id)
        inst_recs[uuid] = value

    for uuid_dict in updates:
        uuid = uuid_dict['instance']

        req_list = []
        for req in inst_recs.get(uuid, []):
            raws = list(models.RawData.objects.filter(request_id=req)
                        .exclude(event='compute.instance.exists')
                        .values("id", "when", "routing_key", "old_state",
                                "state", "tenant", "event", "image_type",
                                "deployment")
                        .order_by('when'))

            _start = None
            _when = None

            err_id = None
            failure_type = None
            operation = "n/a"
            platform = 0
            tenant = 0
            cell = "n/a"
            image_type_num = 0

            for raw in raws:
                _when = raw['when']
                _routing_key = raw['routing_key']
                _old_state = raw['old_state']
                _state = raw['state']
                _tenant = raw['tenant']
                _event = raw['event']
                _image_type = raw['image_type']
                _name = raw['deployment']
                _id = raw['id']

                if not _start:
                    _start = _when

                if 'error' in _routing_key:
                    err_id = _id
                    failure_type = 'http'

                if failure_type != 'state' and _old_state != 'error' and\
                                                             _state == 'error':
                    failure_type = 'state'
                    err_id = _id

                if _old_state == 'error' and \
                        (not _state in ['deleted', 'error']):
                    failure_type = None
                    err_id = None

                if _tenant:
                    tenant = _tenant

                for cmd in cmds:
                    if cmd in _event:
                        operation = cmd
                        cell = deployments.get(_name, "n/a")
                        break

                if _image_type:
                    image_type_num |= _image_type

            if not _start:
                continue

            _end = _when
            diff = _end - _start

            if diff > 1800 and failure_type is None:
                failure_type = ">30"

            if failure_type:
                key = (operation, image_type_num, cell)
                failed_request = {}
                message = []  # For exception message masking
                req_list.append(req)
                instance_map[uuid] = req_list
                failed_request['req'] = req
                failed_request['uuid'] = uuid
                failed_request['tenant'] = tenant
                failed_request['duration'] = "%.2f minutes" % (diff/60)
                failed_request['operation'] = operation
                failed_request['platform'] = image_type.readable(image_type_num)
                tenant_issues[tenant] = tenant_issues.get(tenant, 0) + 1

                if err_id:
                    err = models.RawData.objects.get(id=err_id)
                    queue, body = json.loads(err.json)
                    payload = body['payload']

                    # Add error information to failed request report
                    failed_request['event_id'] = err.id
                    failed_request['tenant'] = err.tenant
                    failed_request['service'] = err.service
                    failed_request['host'] = err.host
                    failed_request['deployment'] = err.deployment.name
                    failed_request['event'] = err.event
                    failed_request['when'] = str(dt.dt_from_decimal(err.when))

                    # Track failed event counts
                    event_counts[err.event] = event_counts.get(err.event, 0) + 1

                    exc = payload.get('exception')
                    if exc:
                        # group the messages ...
                        failed_request['exception'] = exc

                        # assemble message from exception and generalize
                        message_str = mask_msg(build_exc_msg(exc))
                        # count exception messages
                        exception_counts[message_str] = exception_counts.get(
                            message_str, 0) + 1

                        # extract the code, if any ...
                        code = exc.get('kwargs', {}).get('code')
                        if code:
                            codes[code] = codes.get(code, 0) + 1
                            failure_type = code
                    failed_request['failure_type'] = failure_type

                    raws = models.RawData.objects.filter(request_id=req)\
                                         .exclude(event='compute.instance.exists')\
                                         .order_by('when')

                    failed_request['details'] = []
                    for raw in raws:
                        failure_detail = {}
                        failure_detail['host'] = raw.host
                        failure_detail['event'] = raw.event
                        failure_detail['old_state'] = raw.old_state
                        failure_detail['state'] = raw.state
                        failure_detail['old_task'] = raw.old_task
                        failure_detail['task'] = raw.task

                        failed_request['details'].append(failure_detail)

                    report.append(failed_request)

    # Assign values to store in DB
    values = {'json': json.dumps(report),
              'created': dt.dt_to_decimal(datetime.datetime.utcnow()),
              'period_start': start,
              'period_end': end,
              'version': 1,
              'name': 'Error detail report'}
    json_report = models.JsonReport(**values)
    json_report.save()

########NEW FILE########
__FILENAME__ = glance_usage_audit
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import argparse
import datetime
import json
import os
import sys

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))
from django.db.models import F
from reports import usage_audit
from stacktach import models
from stacktach import datetime_to_decimal as dt

OLD_IMAGES_QUERY = """
select * from stacktach_imageusage left join stacktach_imagedeletes
on (stacktach_imageusage.uuid = stacktach_imagedeletes.uuid and
 deleted_at < %s)
 where stacktach_imagedeletes.id IS NULL
 and created_at is not null and created_at < %s;"""


def audit_usages_to_exists(exists, usages):
    # checks if all exists correspond to the given usages
    fails = []
    for (uuid, images) in usages.items():
        if uuid not in exists:
            msg = "No exists for usage (%s)" % uuid
            fails.append(['Usage', images[0]['id'], msg])
    return fails


def _get_new_images(beginning, ending):
    filters = {
        'created_at__gte': beginning,
        'created_at__lte': ending,
    }
    return models.ImageUsage.objects.filter(**filters)


def _get_exists(beginning, ending):
    filters = {
        'audit_period_beginning': beginning,
        'audit_period_ending__gte': beginning,
        'audit_period_ending__lte': ending,
    }
    return models.ImageExists.objects.filter(**filters)


def valid_datetime(d):
    try:
        t = datetime.datetime.strptime(d, "%Y-%m-%d %H:%M:%S")
        return t
    except Exception, e:
        raise argparse.ArgumentTypeError(
            "'%s' is not in YYYY-MM-DD HH:MM:SS format." % d)


def audit_for_period(beginning, ending):
    beginning_decimal = dt.dt_to_decimal(beginning)
    ending_decimal = dt.dt_to_decimal(ending)

    (verify_summary,
     verify_detail) = _verifier_audit_for_day(beginning_decimal,
                                                          ending_decimal,
                                                          models.ImageExists)
    detail, new_count, old_count = _image_audit_for_period(beginning_decimal,
                                                            ending_decimal)

    summary = {
        'verifier': verify_summary,
        'image_summary': {
            'new_images': new_count,
            'old_images': old_count,
            'failures': len(detail)
        },
    }

    details = {
        'exist_fails': verify_detail,
        'image_fails': detail,
    }

    return summary, details


def _verifier_audit_for_day(beginning, ending, exists_model):
    summary = {}
    period = 60*60*24-0.000001
    if args.period_length == 'hour':
        period = 60*60-0.000001
    filters = {
        'raw__when__gte': beginning,
        'raw__when__lte': ending,
        'audit_period_ending': F('audit_period_beginning') + period

    }
    exists = exists_model.objects.filter(**filters)
    summary['exists'] = _audit_for_exists(exists)

    filters = {
        'raw__when__gte': beginning,
        'raw__when__lte': ending,
        'status': exists_model.FAILED
    }
    failed = exists_model.objects.filter(**filters)
    detail = []
    for exist in failed:
        detail.append(['Exist', exist.id, exist.fail_reason])
    return summary, detail


def _audit_for_exists(exists_query):
    (verified, reconciled,
     fail, pending, verifying) = usage_audit._status_queries(exists_query)

    (success, unsent, redirect,
     client_error, server_error) = usage_audit._send_status_queries(verified)

    report = {
        'count': exists_query.count(),
        'verified': verified.count(),
        'failed': fail.count(),
        'pending': pending.count(),
        'verifying': verifying.count(),
        'send_status': {
            'success': success.count(),
            'unsent': unsent.count(),
            'redirect': redirect.count(),
            'client_error': client_error.count(),
            'server_error': server_error.count(),
        }
    }
    return report


def _image_audit_for_period(beginning, ending):
    images_dict = {}
    new_images = _get_new_images(beginning, ending)
    for image in new_images:
        uuid = image.uuid
        l = {'id': image.id, 'created_at': image.created_at}
        if uuid in images_dict:
            images_dict[uuid].append(l)
        else:
            images_dict[uuid] = [l, ]
    # Django's safe substitution doesn't allow dict substitution...
    # Thus, we send it 'beginning' two times...
    old_images = models.ImageUsage.objects\
                         .raw(OLD_IMAGES_QUERY,
                              [beginning, beginning])

    old_images_dict = {}
    for image in old_images:
        uuid = image.uuid
        l = {'id': image.id, 'created_at': image.created_at}
        old_images_dict[uuid] = l

    exists_dict = {}
    exists = _get_exists(beginning, ending)
    for exist in exists:
        uuid = exist.uuid
        e = {'id': exist.id,
             'created_at': exist.created_at,
             'deleted_at': exist.deleted_at}
        if uuid in exists_dict:
            exists_dict[uuid].append(e)
        else:
            exists_dict[uuid] = [e, ]

    image_to_exists_fails = audit_usages_to_exists(exists_dict,images_dict)
    return image_to_exists_fails, new_images.count(), len(old_images_dict)


def store_results(start, end, summary, details):
    values = {
        'json': make_json_report(summary, details),
        'created': dt.dt_to_decimal(datetime.datetime.utcnow()),
        'period_start': start,
        'period_end': end,
        'version': 6,
        'name': 'glance usage audit'
    }

    report = models.JsonReport(**values)
    report.save()


def make_json_report(summary, details):
    report = [{'summary': summary},
              ['Object', 'ID', 'Error Description']]
    report.extend(details['exist_fails'])
    report.extend(details['image_fails'])
    return json.dumps(report)



if __name__ == '__main__':
    parser = argparse.ArgumentParser('StackTach Nova Usage Audit Report')
    parser.add_argument('--period_length',
                        choices=['hour', 'day'], default='day')
    parser.add_argument('--utcdatetime',
                        help="Override the end time used to generate report.",
                        type=valid_datetime, default=None)
    parser.add_argument('--store',
                        help="If set to true, report will be stored. "
                             "Otherwise, it will just be printed",
                        type=bool, default=False)
    args = parser.parse_args()

    if args.utcdatetime is not None:
        time = args.utcdatetime
    else:
        time = datetime.datetime.utcnow()

    start, end = usage_audit.get_previous_period(time, args.period_length)

    summary, details = audit_for_period(start, end)

    if not args.store:
        print make_json_report(summary, details)
    else:
        store_results(start, end, summary, details)

########NEW FILE########
__FILENAME__ = image_events_audit
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import argparse
import datetime
import json
import sys
import os

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

from stacktach import datetime_to_decimal as dt
from stacktach import models


def __get_image_activate_count(beginning, ending):
    upload_filters = {
        'when__gte': beginning,
        'when__lte': ending,
        'event': 'image.upload'
    }
    image_upload = models.GlanceRawData.objects.filter(**upload_filters).count()

    activate_filters = {
        'last_raw__when__gte': beginning,
        'last_raw__when__lte': ending
    }
    image_activate = models.ImageUsage.objects.filter(**activate_filters).count()

    delete_exists_filters = {
        'raw__when__gte': beginning,
        'raw__when__lte': ending
    }
    image_delete = models.ImageDeletes.objects.filter(**delete_exists_filters).count()
    image_exists = models.ImageExists.objects.filter(**delete_exists_filters).count()

    exists_verified_filters = {
        'raw__when__gte': beginning,
        'raw__when__lte': ending,
        'status': models.ImageExists.VERIFIED,
        'send_status__gte': 200,
        'send_status__lt': 300
    }
    image_exists_verified = models.ImageExists.objects.filter(**exists_verified_filters).count()

    return {
        'image.upload': image_upload,
        'image.activate': image_activate,
        'image.delete': image_delete,
        'image.exists': image_exists,
        'image.exists.verified': image_exists_verified
    }


def audit_for_period(beginning, ending):
    beginning_decimal = dt.dt_to_decimal(beginning)
    ending_decimal = dt.dt_to_decimal(ending)

    image_event_counts = __get_image_activate_count(beginning_decimal,
                                              ending_decimal)

    return image_event_counts


def get_previous_period(time, period_length):
    if period_length == 'day':
        last_period = time - datetime.timedelta(days=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day)
        end = datetime.datetime(year=time.year,
                                month=time.month,
                                day=time.day)
        return start, end
    elif period_length == 'hour':
        last_period = time - datetime.timedelta(hours=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day,
                                  hour=last_period.hour)
        end = datetime.datetime(year=time.year,
                                month=time.month,
                                day=time.day,
                                hour=time.hour)
        return start, end


def __make_json_report(report):
    return json.dumps(report)


def __store_results(start, end, report):
    values = {
        'json': __make_json_report(report),
        'created': dt.dt_to_decimal(datetime.datetime.utcnow()),
        'period_start': start,
        'period_end': end,
        'version': 1,
        'name': 'image events audit'
    }

    report = models.JsonReport(**values)
    report.save()


def valid_datetime(d):
    try:
        t = datetime.datetime.strptime(d, "%Y-%m-%d %H:%M:%S")
        return t
    except Exception, e:
        raise argparse.ArgumentTypeError(
            "'%s' is not in YYYY-MM-DD HH:MM:SS format." % d)


if __name__ == '__main__':
    parser = argparse.ArgumentParser('StackTach Image Events Audit Report')
    parser.add_argument('--period_length',
                        choices=['hour', 'day'], default='day')
    parser.add_argument('--utcdatetime',
                        help="Override the end time used to generate report.",
                        type=valid_datetime, default=None)
    parser.add_argument('--store',
                        help="If set to true, report will be stored. "
                             "Otherwise, it will just be printed",
                        type=bool, default=False)
    args = parser.parse_args()

    if args.utcdatetime is not None:
        time = args.utcdatetime
    else:
        time = datetime.datetime.utcnow()

    start, end = get_previous_period(time, args.period_length)

    event_counts = audit_for_period(start, end)

    if not args.store:
        print event_counts
    else:
        __store_results(start, end, event_counts)

########NEW FILE########
__FILENAME__ = instance_hours
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import argparse
import datetime
import json
import math
import sys
import operator
import os

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

import usage_audit

from stacktach import datetime_to_decimal as dt
from stacktach import models
from stacktach import stacklog


class TenantManager(object):
    def __init__(self):
        self._types = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        return False

    @property
    def type_names(self):
        if self._types is None:
            self._types = set()
            for t in models.TenantType.objects.all():
                self._types.add(t.name)
        return self._types

    def get_tenant_info(self, tenant_id):
        try:
            tenant = models.TenantInfo.objects\
                                      .get(tenant=tenant_id)
            tenant_info = dict(
                     tenant=tenant_id, 
                     account_name=tenant.name)
            ttypes = dict()
            for t in tenant.types.all():
                ttypes[t.name] = t.value
        except models.TenantInfo.DoesNotExist:
            tenant_info = dict(
                     tenant=tenant_id, 
                     account_name='unknown account')
            ttypes = dict()
            for t in self.type_names:
                ttypes[t] = 'unknown'
        tenant_info['types'] = ttypes
        return tenant_info


class InstanceHoursReport(object):

    FLAVOR_CLASS_WEIGHTS = dict(standard=1.0)

    def __init__(self, tenant_manager, time=None, period_length='day'):
        if time is None:
            time = datetime.datetime.utcnow()
        self.start, self.end = usage_audit.get_previous_period(time, period_length)
        self.tenant_manager = tenant_manager
        self.flavor_cache = dict()
        self.clear()

    def clear(self):
        self.count = 0 
        self.unit_hours = 0.0
        self.by_flavor = dict()
        self.by_flavor_class = dict()
        self.by_tenant = dict()
        self.by_type = dict()
        for name in self.tenant_manager.type_names:
            self.by_tenant[name] = dict()
            self.by_type[name] = dict()

    def _get_verified_exists(self):
        start = dt.dt_to_decimal(self.start)
        end = dt.dt_to_decimal(self.end)
        return models.InstanceExists.objects.filter(
            status=models.InstanceExists.VERIFIED,
            audit_period_beginning__gte=start,
            audit_period_beginning__lte=end,
            audit_period_ending__gte=start,
            audit_period_ending__lte=end)

    def _get_instance_hours(self, exist):
        if (exist.deleted_at is None) or (exist.deleted_at > exist.audit_period_ending):
            end = exist.audit_period_ending
        else:
            end = exist.deleted_at
        if exist.launched_at > exist.audit_period_beginning:
            start = exist.launched_at
        else:
            start = exist.audit_period_beginning
        return math.ceil((end - start)/3600)

    def _get_flavor_info(self, exist):
        flavor = exist.instance_flavor_id
        if flavor not in self.flavor_cache:
            if '-' in flavor:
                flavor_class, n = flavor.split('-', 1)
            else:
                flavor_class = 'standard'
            try:
                payload = json.loads(exist.raw.json)[1]['payload']
            except Exception:
                print "Error loading raw notification data for %s" % exist.id
                raise
            flavor_name = payload['instance_type']
            flavor_size = payload['memory_mb']
            weight = self.FLAVOR_CLASS_WEIGHTS.get(flavor_class, 1.0)
            flavor_units = (flavor_size/256.0) * weight
            self.flavor_cache[flavor] = (flavor, flavor_name, flavor_class, flavor_units)
        return self.flavor_cache[flavor]

    def add_type_hours(self, type_name, type_value, unit_hours):
        if type_value not in self.by_type[type_name]:
            self.by_type[type_name][type_value] = dict(count=0, unit_hours=0.0)
        cts = self.by_type[type_name][type_value]
        cts['count'] += 1
        cts['unit_hours'] += unit_hours
        cts['percent_count'] = (float(cts['count'])/self.count) * 100
        cts['percent_unit_hours'] = (cts['unit_hours']/self.unit_hours) * 100

    def add_flavor_class_hours(self, flavor_class, unit_hours):
        if flavor_class not in self.by_flavor_class:
            self.by_flavor_class[flavor_class] = dict(count=0, unit_hours=0.0)
        cts = self.by_flavor_class[flavor_class]
        cts['count'] += 1
        cts['unit_hours'] += unit_hours
        cts['percent_count'] = (float(cts['count'])/self.count) * 100
        cts['percent_unit_hours'] = (cts['unit_hours']/self.unit_hours) * 100

    def add_flavor_hours(self, flavor, flavor_name, unit_hours):
        if flavor not in self.by_flavor:
            self.by_flavor[flavor] = dict(count=0, unit_hours=0.0)
        cts = self.by_flavor[flavor]
        cts['count'] += 1
        cts['unit_hours'] += unit_hours
        cts['percent_count'] = (float(cts['count'])/self.count) * 100
        cts['percent_unit_hours'] = (cts['unit_hours']/self.unit_hours) * 100
        cts['flavor_name'] = flavor_name

    def add_tenant_hours(self, tenant_info, unit_hours):
        tenant = tenant_info['tenant']
        cts = dict(count=0, unit_hours=0.0)
        for tname, tvalue in tenant_info['types'].items():
            if tvalue not in self.by_tenant[tname]:
                self.by_tenant[tname][tvalue] = dict()
            if tenant not in self.by_tenant[tname][tvalue]:
                self.by_tenant[tname][tvalue][tenant] = cts
            cts = self.by_tenant[tname][tvalue][tenant]
            cts[tname] = tvalue
        cts['count'] += 1
        cts['unit_hours'] += unit_hours
        cts['percent_count'] = (float(cts['count'])/self.count) * 100
        cts['percent_unit_hours'] = (cts['unit_hours']/self.unit_hours) * 100
        cts['tenant'] = tenant
        cts['account_name'] = tenant_info['account_name']

    def compile_hours(self):
        exists = self._get_verified_exists()
        self.count = exists.count()
        with self.tenant_manager as tenant_manager:
            for exist in exists:
                hours = self._get_instance_hours(exist)
                flavor, flavor_name, flavor_class, flavor_units = self._get_flavor_info(exist)
                tenant_info = tenant_manager.get_tenant_info(exist.tenant)
                unit_hours = hours * flavor_units
                self.unit_hours += unit_hours
                self.add_flavor_hours(flavor, flavor_name, unit_hours)
                self.add_flavor_class_hours(flavor_class, unit_hours)
                for tname, tvalue in tenant_info['types'].items():
                    self.add_type_hours(tname, tvalue, unit_hours)
                self.add_tenant_hours(tenant_info, unit_hours)

    def top_hundred(self, key):
        def th(d):
            top = dict()
            for t, customers in d.iteritems():
                top[t] = sorted(customers.values(), key=operator.itemgetter(key), reverse=True)[:100]
            return top
        top_hundred = dict()
        for type_name, tenants in self.by_tenant.iteritems():
            top_hundred[type_name] = th(tenants)
        return top_hundred

    def generate_json(self):
        report = dict(total_instance_count=self.count,
                      total_unit_hours=self.unit_hours,
                      flavor=self.by_flavor,
                      flavor_class=self.by_flavor_class,
                      top_hundred_by_count=self.top_hundred('count'),
                      top_hundred_by_unit_hours=self.top_hundred('unit_hours'))
        for ttype, stats in self.by_type.iteritems():
            report[ttype] = stats
        return json.dumps(report)

    def store(self, json_report):
        report = models.JsonReport(
                    json=json_report,
                    created=dt.dt_to_decimal(datetime.datetime.utcnow()),
                    period_start=self.start,
                    period_end=self.end,
                    version=1,
                    name='instance hours')
        report.save()


def valid_datetime(d):
    try:
        t = datetime.datetime.strptime(d, "%Y-%m-%d %H:%M:%S")
        return t
    except Exception, e:
        raise argparse.ArgumentTypeError(
            "'%s' is not in YYYY-MM-DD HH:MM:SS format." % d)


if __name__ == '__main__':
    parser = argparse.ArgumentParser('StackTach Instance Hours Report')
    parser.add_argument('--period_length',
                        choices=['hour', 'day'], default='day')
    parser.add_argument('--utcdatetime',
                        help="Override the end time used to generate report.",
                        type=valid_datetime, default=None)
    parser.add_argument('--store',
                        help="If set to true, report will be stored. "
                             "Otherwise, it will just be printed",
                        default=False, action="store_true")
    args = parser.parse_args()

    stacklog.set_default_logger_name('instance_hours')
    parent_logger = stacklog.get_logger('instance_hours', is_parent=True)
    log_listener = stacklog.LogListener(parent_logger)
    log_listener.start()

    tenant_manager = TenantManager()
    report = InstanceHoursReport(
                tenant_manager,
                time=args.utcdatetime,
                period_length=args.period_length)

    report.compile_hours()
    json = report.generate_json()

    if not args.store:
        print json
    else:
        report.store(json)

########NEW FILE########
__FILENAME__ = nova_usage_audit
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import argparse
import datetime
import functools
import json
import sys
import os

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

import usage_audit

from stacktach.models import InstanceUsage
from stacktach import datetime_to_decimal as dt
from stacktach import models
from stacktach.reconciler import Reconciler
from stacktach import stacklog

OLD_LAUNCHES_QUERY = """
select stacktach_instanceusage.id,
       stacktach_instanceusage.instance,
       stacktach_instanceusage.launched_at from stacktach_instanceusage
    left outer join stacktach_instancedeletes on
        stacktach_instanceusage.instance = stacktach_instancedeletes.instance
    left outer join stacktach_instancereconcile on
        stacktach_instanceusage.instance = stacktach_instancereconcile.instance
        where (
            stacktach_instancereconcile.deleted_at is null and (
                stacktach_instancedeletes.deleted_at is null or
                stacktach_instancedeletes.deleted_at > %s
            )
            or (stacktach_instancereconcile.deleted_at is not null and
                stacktach_instancereconcile.deleted_at > %s)
        ) and stacktach_instanceusage.launched_at < %s;"""

OLD_RECONCILES_QUERY = """
select stacktach_instancereconcile.id,
       stacktach_instancereconcile.instance,
       stacktach_instancereconcile.launched_at from stacktach_instancereconcile
    left outer join stacktach_instancedeletes on
        stacktach_instancereconcile.instance = stacktach_instancedeletes.instance
        where (
            stacktach_instancereconcile.deleted_at is null and (
                stacktach_instancedeletes.deleted_at is null or
                stacktach_instancedeletes.deleted_at > %s
            )
            or (stacktach_instancereconcile.deleted_at is not null and
                stacktach_instancereconcile.deleted_at > %s)
        ) and stacktach_instancereconcile.launched_at < %s;"""

DEFAULT_UMS_OFFSET = 4 * 60 * 60  # 4 Hours

reconciler = None


def _get_new_launches(beginning, ending):
    filters = {
        'launched_at__gte': beginning,
        'launched_at__lte': ending,
    }
    return models.InstanceUsage.objects.filter(**filters)


def _get_deletes(beginning, ending):
    filters = {
        'deleted_at__gte': beginning,
        'deleted_at__lte': ending,
    }
    return models.InstanceDeletes.objects.filter(**filters)


def _get_exists(beginning, ending):
    filters = {
        'audit_period_beginning': beginning,
        'audit_period_ending__gte': beginning,
        'audit_period_ending__lte': ending,
    }
    return models.InstanceExists.objects.filter(**filters)


def cell_and_compute(instance, launched_at):
    usage = InstanceUsage.find(instance, launched_at)[0]
    deployment = usage.latest_deployment_for_request_id()
    cell = (deployment and deployment.name) or '-'
    compute = usage.host() or '-'
    return cell, compute


def _audit_launches_to_exists(launches, exists, beginning):
    fails = []
    for (instance, launches) in launches.items():
        if instance in exists:
            for expected in launches:
                found = False
                for actual in exists[instance]:
                    if int(expected['launched_at']) == \
                            int(actual['launched_at']):
                    # HACK (apmelton): Truncate the decimal because we may not
                    #    have the milliseconds.
                        found = True

                if not found:
                    rec = False
                    if reconciler:
                        args = (expected['id'], beginning)
                        rec = reconciler.missing_exists_for_instance(*args)
                    launched_at = dt.dt_from_decimal(expected['launched_at'])
                    msg = "Couldn't find exists for launch (%s, %s)"
                    msg = msg % (instance, launched_at)
                    cell, compute = cell_and_compute(instance, launched_at)
                    fails.append(['Launch', expected['id'], msg,
                                  'Y' if rec else 'N', cell, compute])
        else:
            rec = False
            if reconciler:
                args = (launches[0]['id'], beginning)
                rec = reconciler.missing_exists_for_instance(*args)
            msg = "No exists for instance (%s)" % instance
            launched_at = dt.dt_from_decimal(launches[0]['launched_at'])
            cell, compute = cell_and_compute(instance, launched_at)
            fails.append(['-', msg, 'Y' if rec else 'N',
                          cell, compute])
    return fails


def _launch_audit_for_period(beginning, ending):
    launches_dict = {}
    new_launches = _get_new_launches(beginning, ending)
    for launch in new_launches:
        instance = launch.instance
        l = {'id': launch.id, 'launched_at': launch.launched_at}
        if instance in launches_dict:
            launches_dict[instance].append(l)
        else:
            launches_dict[instance] = [l, ]

    # NOTE (apmelton)
    # Django's safe substitution doesn't allow dict substitution...
    # Thus, we send it 'beginning' three times...
    old_launches = models.InstanceUsage.objects\
                         .raw(OLD_LAUNCHES_QUERY,
                              [beginning, beginning, beginning])

    old_launches_dict = {}
    for launch in old_launches:
        instance = launch.instance
        l = {'id': launch.id, 'launched_at': launch.launched_at}
        if instance not in old_launches_dict or \
                (old_launches_dict[instance]['launched_at'] <
                 launch.launched_at):
            old_launches_dict[instance] = l

    # NOTE (apmelton)
    # Django's safe substitution doesn't allow dict substitution...
    # Thus, we send it 'beginning' three times...
    old_recs = models.InstanceReconcile.objects\
                     .raw(OLD_RECONCILES_QUERY,
                          [beginning, beginning, beginning])

    for rec in old_recs:
        instance = rec.instance
        l = {'id': rec.id, 'launched_at': rec.launched_at}
        if instance not in old_launches_dict or \
                (old_launches_dict[instance]['launched_at'] <
                 rec.launched_at):
            old_launches_dict[instance] = l

    for instance, launch in old_launches_dict.items():
        if instance in launches_dict:
            launches_dict[instance].append(launch)
        else:
            launches_dict[instance] = [launch, ]

    exists_dict = {}
    exists = _get_exists(beginning, ending)
    for exist in exists:
        instance = exist.instance
        e = {'id': exist.id,
             'launched_at': exist.launched_at,
             'deleted_at': exist.deleted_at}
        if instance in exists_dict:
            exists_dict[instance].append(e)
        else:
            exists_dict[instance] = [e, ]

    launch_to_exists_fails = _audit_launches_to_exists(launches_dict,
                                                       exists_dict,
                                                       beginning)
    return launch_to_exists_fails, new_launches.count(), len(old_launches_dict)


def audit_for_period(beginning, ending, ums=False, ums_offset=0):
    beginning_decimal = dt.dt_to_decimal(beginning)
    ending_decimal = dt.dt_to_decimal(ending)

    if ums:
        verifier_audit_func = functools.partial(
            usage_audit._verifier_audit_for_day_ums, ums_offset=ums_offset
        )
    else:
        verifier_audit_func = usage_audit._verifier_audit_for_day

    (verify_summary,
     verify_detail) = verifier_audit_func(beginning_decimal, ending_decimal,
                                          models.InstanceExists)
    detail, new_count, old_count = _launch_audit_for_period(beginning_decimal,
                                                            ending_decimal)

    summary = {
        'verifier': verify_summary,
        'launch_summary': {
            'new_launches': new_count,
            'old_launches': old_count,
            'failures': len(detail)
        },
    }

    details = {
        'exist_fails': verify_detail,
        'launch_fails': detail,
    }

    return summary, details


def store_results(start, end, summary, details):
    values = {
        'json': make_json_report(summary, details),
        'created': dt.dt_to_decimal(datetime.datetime.utcnow()),
        'period_start': start,
        'period_end': end,
        'version': 7,
        'name': 'nova usage audit'
    }

    report = models.JsonReport(**values)
    report.save()


def make_json_report(summary, details):
    report = {
        'summary': summary,
        'exist_fail_headers': ['Exists Row ID', 'Error Description', 'Cell',
                               'Compute'],
        'exist_fails': details['exist_fails'],
        'launch_fail_headers': ['Launch Row ID', 'Error Description',
                                'Reconciled?', 'Cell', 'Compute'],
        'launch_fails': details['launch_fails']
    }
    return json.dumps(report)


def valid_datetime(d):
    try:
        t = datetime.datetime.strptime(d, "%Y-%m-%d %H:%M:%S")
        return t
    except Exception, e:
        raise argparse.ArgumentTypeError(
            "'%s' is not in YYYY-MM-DD HH:MM:SS format." % d)


if __name__ == '__main__':
    parser = argparse.ArgumentParser('StackTach Nova Usage Audit Report')
    parser.add_argument('--period_length',
                        choices=['hour', 'day'], default='day')
    parser.add_argument('--utcdatetime',
                        help="Override the end time used to generate report.",
                        type=valid_datetime, default=None)
    parser.add_argument('--store',
                        help="If set to true, report will be stored. "
                             "Otherwise, it will just be printed",
                        type=bool, default=False)
    parser.add_argument('--reconcile',
                        help="Enabled reconciliation",
                        type=bool, default=False)
    parser.add_argument('--reconciler_config',
                        help="Location of the reconciler config file",
                        type=str,
                        default='/etc/stacktach/reconciler-config.json')
    parser.add_argument('--ums',
                        help="Use query to match UMS, "
                             "period length of 'day' required.",
                        action='store_true')
    parser.add_argument('--ums-offset',
                        help="UMS' fencepost offset in seconds. Default: 4 days",
                        type=int,
                        default=DEFAULT_UMS_OFFSET)
    args = parser.parse_args()

    if args.ums and args.period_length != 'day':
        print "UMS query can only be used with period_length of 'day'."
        sys.exit(0)

    stacklog.set_default_logger_name('nova_usage_audit')
    parent_logger = stacklog.get_logger('nova_usage_audit', is_parent=True)
    log_listener = stacklog.LogListener(parent_logger)
    log_listener.start()

    if args.reconcile:
        with open(args.reconciler_config) as f:
            reconciler_config = json.load(f)
            reconciler = Reconciler(reconciler_config)

    if args.utcdatetime is not None:
        time = args.utcdatetime
    else:
        time = datetime.datetime.utcnow()

    start, end = usage_audit.get_previous_period(time, args.period_length)

    summary, details = audit_for_period(start, end, ums=args.ums,
                                        ums_offset=args.ums_offset)

    if not args.store:
        print make_json_report(summary, details)
    else:
        store_results(start, end, summary, details)

########NEW FILE########
__FILENAME__ = pretty
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import argparse
import datetime
import json
import sys
import time
import os
import prettytable

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

from stacktach import datetime_to_decimal as dt
from stacktach import image_type
from stacktach import models


def make_report(yesterday=None, start_hour=0, hours=24, percentile=97,
                store=False, region=None, too_long=1800):
    if not yesterday:
        yesterday = datetime.datetime.utcnow().date() -\
            datetime.timedelta(days=1)

    rstart = datetime.datetime(year=yesterday.year, month=yesterday.month,
                               day=yesterday.day, hour=start_hour)
    rend = rstart + datetime.timedelta(hours=hours-1, minutes=59, seconds=59)

    dstart = dt.dt_to_decimal(rstart)
    dend = dt.dt_to_decimal(rend)

    too_long_col = '> %d' % (too_long / 60)

    cells = []
    regions = []
    if region:
        region = region.upper()
    deployments = models.Deployment.objects.all()
    for deployment in deployments:
        name = deployment.name.upper()
        if not region or region in name:
            regions.append(deployment.id)
            cells.append(deployment.name)

    if not len(regions):
        print "No regions found for '%s'" % region
        sys.exit(1)

    # Get all the instances that have changed in the last N hours ...
    updates = models.RawData.objects.filter(event='compute.instance.update',
                                            when__gt=dstart, when__lte=dend,
                                            deployment__in=regions)\
                                    .values('instance').distinct()

    expiry = 60 * 60  # 1 hour
    cmds = ['create', 'rebuild', 'rescue', 'resize', 'snapshot']

    requests = models.RawData.objects.filter(when__gt=dstart, when__lte=dend)\
                                     .exclude(instance=None,
                                              event='compute.instance.exists')\
                                     .values('request_id', 'instance')\
                                     .distinct()
    inst_recs = {}
    for request in requests:
        uuid = request['instance']
        request_id = request['request_id']
        value = inst_recs.get(uuid, [])
        value.append(request_id)
        inst_recs[uuid] = value

    failures = {}  # { key : {failure_type: count} }
    durations = {}
    attempts = {}

    for uuid_dict in updates:
        uuid = uuid_dict['instance']

        for req in inst_recs.get(uuid, []):
            raws = models.RawData.objects.filter(request_id=req)\
                                      .exclude(event='compute.instance.exists')\
                                      .order_by('when')

            start = None
            err = None
            failure_type = None

            operation = "aux"
            image_type_num = 0

            for raw in raws:
                if not start:
                    start = raw.when

                if 'error' in raw.routing_key:
                    err = raw
                    failure_type = 'http'

                if failure_type != 'state' and raw.old_state != 'error'\
                        and raw.state == 'error':
                    failure_type = 'state'

                if raw.old_state == 'error' and \
                        (not raw.state in ['deleted', 'error']):
                    failure_type = None

                for cmd in cmds:
                    if cmd in raw.event:
                        operation = cmd
                        break

                if raw.image_type:
                    image_type_num |= raw.image_type

            # Get image (base or snapshot) from image_type bit field
            image = "?"
            if image_type.isset(image_type_num, image_type.BASE_IMAGE):
                image = "base"
            if image_type.isset(image_type_num, image_type.SNAPSHOT_IMAGE):
                image = "snap"

            #Get os_type from image_type bit field
            os_type = "?"
            if image_type.isset(image_type_num, image_type.LINUX_IMAGE):
                os_type = "linux"
            if image_type.isset(image_type_num, image_type.WINDOWS_IMAGE):
                os_type = "windows"

            if not start:
                continue

            end = raw.when
            diff = end - start

            if diff > too_long and failure_type is None:
                failure_type = too_long_col

            key = (operation, image, os_type)

            # Track durations for all attempts, good and bad ...
            _durations = durations.get(key, [])
            _durations.append(diff)
            durations[key] = _durations

            attempts[key] = attempts.get(key, 0) + 1

            if failure_type:
                if err:
                    queue, body = json.loads(err.json)
                    payload = body['payload']
                    exc = payload.get('exception')
                    if exc:
                        code = int(exc.get('kwargs', {}).get('code', 0))
                        if code >= 400 and code < 500:
                            failure_type = "4xx"
                        if code >= 500 and code < 600:
                            failure_type = "5xx"
                breakdown = failures.get(key, {})
                breakdown[failure_type] = breakdown.get(failure_type, 0) + 1
                failures[key] = breakdown

    # Summarize the results ...
    report = []
    pct = (float(100 - percentile) / 2.0) / 100.0
    details = {'percentile': percentile, 'pct': pct, 'hours': hours,
               'start': float(dstart), 'end': float(dend), 'region': region,
               'cells': cells}
    report.append(details)

    failure_types = ["4xx", "5xx", too_long_col, "state"]
    cols = ["Operation", "Image", "OS Type", "Min", "Max", "Med", "%d%%" % percentile,
            "Requests"]
    for failure_type in failure_types:
        cols.append("%s" % failure_type)
        cols.append("%% %s" % failure_type)
    report.append(cols)

    total = 0
    failure_totals = {}
    for key, count in attempts.iteritems():
        total += count
        operation, image, os_type = key

        breakdown = failures.get(key, {})
        this_failure_pair = []
        for failure_type in failure_types:
            # Failure counts for this attempt.
            # Sum for grand totals.
            failure_count = breakdown.get(failure_type, 0)
            failure_totals[failure_type] = \
                failure_totals.get(failure_type, 0) + failure_count

            # Failure percentage for this attempt.
            percentage = float(failure_count) / float(count)
            this_failure_pair.append((failure_count, percentage))

        # N-th % of durations ...
        _values = durations[key]
        _values.sort()
        _min = 99999999
        _max = 0
        _total = 0.0
        for value in _values:
            _min = min(_min, value)
            _max = max(_max, value)
            _total += float(value)
        _num = len(_values)
        _avg = float(_total) / float(_num)
        half = _num / 2
        _median = _values[half]
        _percentile_index = int((float(percentile) / 100.0) * float(_num))
        _percentile = _values[_percentile_index]

        _fmin = dt.sec_to_str(_min)
        _fmax = dt.sec_to_str(_max)
        _favg = dt.sec_to_str(_avg)
        _fmedian = dt.sec_to_str(_median)
        _fpercentile = dt.sec_to_str(_percentile)

        row = [operation, image, os_type, _fmin, _fmax, _fmedian, _fpercentile, count]
        for failure_count, failure_percentage in this_failure_pair:
            row.append(failure_count)
            row.append(failure_percentage)
        report.append(row)

    details['total'] = total
    failure_grand_total = 0
    for failure_type in failure_types:
        failure_total = failure_totals.get(failure_type, 0)
        failure_grand_total += failure_total
        details["%s failure count" % failure_type] = failure_total
        failure_percentage = (float(failure_total)/float(total)) * 100.0
        details["%s failure percentage" % failure_type] = failure_percentage

    details['failure_grand_total'] = failure_grand_total
    details['failure_grand_rate'] = (float(failure_grand_total)/float(total)) * 100.0
    return (rstart, rend, report)


def valid_date(date):
    try:
        t = time.strptime(date, "%Y-%m-%d")
        return datetime.datetime(*t[:6])
    except Exception:
        raise argparse.ArgumentTypeError(
            "'%s' is not in YYYY-MM-DD format." % date)


if __name__ == '__main__':
    parser = argparse.ArgumentParser('StackTach Nova Usage Summary Report')
    parser.add_argument('--utcdate',
            help='Report start date YYYY-MM-DD. Default yesterday midnight.',
            type=valid_date, default=None)
    parser.add_argument('--region',
            help='Report Region. Default is all regions.', default=None)
    parser.add_argument('--hours',
            help='Report span in hours. Default: 24', default=24,
            type=int)
    parser.add_argument('--days_back',
            help='Report start date. N days back from now. Default: 0', default=0,
            type=int)
    parser.add_argument('--hours_back',
            help='Report start date. N hours back from now. Default: 0', default=0,
            type=int)
    parser.add_argument('--start_hour',
            help='Starting hour 0-23. Default: 0', default=0,
            type=int)
    parser.add_argument('--percentile',
            help='Percentile for timings. Default: 97', default=97,
            type=int)
    parser.add_argument('--too_long',
            help='Seconds for an operation to fail. Default: 1800 (30min)', default=1800,
            type=int)
    parser.add_argument('--store',
            help='Store report in database. Default: False',
            default=False, action="store_true")
    parser.add_argument('--silent',
            help="Do not show summary report. Default: False",
            default=False, action="store_true")
    args = parser.parse_args()

    yesterday = args.utcdate
    days_back = args.days_back
    hours_back = args.hours_back
    percentile = args.percentile
    hours = args.hours
    start_hour = args.start_hour
    store_report = args.store
    region = args.region
    too_long = args.too_long

    if (not yesterday) and days_back > 0:
        yesterday = datetime.datetime.utcnow().date() - \
                    datetime.timedelta(days=days_back)
    if (not yesterday) and hours_back > 0:
        yesterday = datetime.datetime.utcnow() - \
                    datetime.timedelta(hours=hours_back)
        yesterday = yesterday.replace(minute=0, second=0, microsecond=0)
        start_hour = yesterday.hour

    start, end, raw_report = make_report(yesterday, start_hour, hours,
                                         percentile, store_report, region,
                                         too_long)
    details = raw_report[0]
    pct = details['pct']

    region_name = "all"
    if region:
        region_name = region

    if store_report:
        values = {'json': json.dumps(raw_report),
                  'created': dt.dt_to_decimal(datetime.datetime.utcnow()),
                  'period_start': start,
                  'period_end': end,
                  'version': 4,
                  'name': 'summary for region: %s' % region_name}
        report = models.JsonReport(**values)
        report.save()
        print "Report stored (id=%d)" % report.id

    if args.silent:
        sys.exit(1)

    print "'%s' Report for %s to %s" % (region_name, start, end)

    cols = raw_report[1]

    # Print the results ...
    p = prettytable.PrettyTable(cols)
    for c in cols[2:]:
        p.align[c] = 'r'
    p.sortby = cols[0]

    for row in raw_report[2:]:
        frow = row[:]
        for col in [9, 11, 13, 15]:
            frow[col] = "%.1f%%" % (row[col] * 100.0)
        p.add_row(frow)
    print p

    total = details['total']
    failure_total = details['failure_grand_total']
    failure_rate = details['failure_grand_rate']
    print "Total: %d, Failures: %d, Failure Rate: %.1f%%" % \
                    (total, failure_total, failure_rate)

########NEW FILE########
__FILENAME__ = public_outbound_bandwidth
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import json
import logging
import os
import sys

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

from stacktach import datetime_to_decimal as dt
from stacktach import models

logging.basicConfig()
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

def __get_previous_period(time):
    last_period = time - datetime.timedelta(days=1)
    start = datetime.datetime(year=last_period.year,
                              month=last_period.month,
                              day=last_period.day)
    end = datetime.datetime(year=time.year,
                            month=time.month,
                            day=time.day)
    return start, end


def __get_instance_exists(beginning, ending):
    filters = {
        'audit_period_beginning__gte': beginning,
        'audit_period_ending__lte': ending,
    }
    return models.InstanceExists.objects.filter(**filters)


def __audit_for_instance_exists(beginning, ending):
    beginning_decimal = dt.dt_to_decimal(beginning)
    ending_decimal = dt.dt_to_decimal(ending)
    instance_exists = __get_instance_exists(beginning_decimal, ending_decimal)
    total_bw = reduce(lambda x, y: x + y.bandwidth_public_out, instance_exists,
                      0)
    report = {
        'total_public_outbound_bandwidth': total_bw,
    }

    return report


def __store_report_in_db(start, end, report):
    values = {
        'json': __make_json_report(report),
        'created': dt.dt_to_decimal(datetime.datetime.utcnow()),
        'period_start': start,
        'period_end': end,
        'version': 1,
        'name': 'public outbound bandwidth'
    }

    report = models.JsonReport(**values)
    report.save()


def __make_json_report(report):
    return json.dumps(report)


if __name__ == '__main__':
    start, end = __get_previous_period(datetime.datetime.utcnow())
    logger.debug("Aggregating bw usage for period: %s to %s" % (start, end))
    report = __audit_for_instance_exists(start, end)
    __store_report_in_db(start, end, report)


########NEW FILE########
__FILENAME__ = usage_audit
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
from django.db.models import F
from django.db.models import Q
from stacktach import models


def _status_queries(exists_query):
    verified = exists_query.filter(status=models.InstanceExists.VERIFIED)
    reconciled = exists_query.filter(status=models.InstanceExists.RECONCILED)
    fail = exists_query.filter(status=models.InstanceExists.FAILED)
    pending = exists_query.filter(status=models.InstanceExists.PENDING)
    verifying = exists_query.filter(status=models.InstanceExists.VERIFYING)
    sent_unverified = exists_query.filter(status=models.InstanceExists.SENT_UNVERIFIED)
    sent_failed = exists_query.filter(status=models.InstanceExists.SENT_FAILED)
    sent_verifying = exists_query.filter(status=models.InstanceExists.SENT_VERIFYING)
    return verified, reconciled, fail, pending, verifying, sent_unverified, \
        sent_failed, sent_verifying


def _send_status_queries(exists_query):
    unsent = exists_query.filter(send_status=0)
    success = exists_query.filter(send_status__gte=200,
                                  send_status__lt=300)
    redirect = exists_query.filter(send_status__gte=300,
                                   send_status__lt=400)
    client_error = exists_query.filter(send_status__gte=400,
                                       send_status__lt=500)
    server_error = exists_query.filter(send_status__gte=500,
                                       send_status__lt=600)
    return success, unsent, redirect, client_error, server_error


def _audit_for_exists(exists_query):
    (verified, reconciled,
     fail, pending, verifying, sent_unverified,
     sent_failed, sent_verifying) = _status_queries(exists_query)

    (success, unsent, redirect,
     client_error, server_error) = _send_status_queries(verified)

    (success_rec, unsent_rec, redirect_rec,
     client_error_rec, server_error_rec) = _send_status_queries(reconciled)

    report = {
        'count': exists_query.count(),
        'verified': verified.count(),
        'reconciled': reconciled.count(),
        'failed': fail.count(),
        'pending': pending.count(),
        'verifying': verifying.count(),
        'sent_unverified': sent_unverified.count(),
        'sent_failed': sent_failed.count(),
        'sent_verifying': sent_verifying.count(),
        'send_status': {
            'success': success.count(),
            'unsent': unsent.count(),
            'redirect': redirect.count(),
            'client_error': client_error.count(),
            'server_error': server_error.count(),
        },
        'send_status_rec': {
            'success': success_rec.count(),
            'unsent': unsent_rec.count(),
            'redirect': redirect_rec.count(),
            'client_error': client_error_rec.count(),
            'server_error': server_error_rec.count(),
        }
    }

    return report


def _verified_audit_base(base_query, exists_model):
    summary = {}

    periodic_range = Q(audit_period_ending=(F('audit_period_beginning') +
                                            (60*60*24)))
    periodic_exists = exists_model.objects.filter(base_query & periodic_range)
    summary['periodic'] = _audit_for_exists(periodic_exists)

    instant_range = Q(audit_period_ending__lt=(F('audit_period_beginning') +
                                               (60*60*24)))
    instant_exists = exists_model.objects.filter(base_query & instant_range)
    summary['instantaneous'] = _audit_for_exists(instant_exists)

    failed_query = Q(status=exists_model.FAILED)
    failed = exists_model.objects.filter(base_query & failed_query)
    detail = []
    for e in failed:
        try:
            detail.append([e.id, e.fail_reason, e.raw.deployment.name,
                           e.raw.host])
        except Exception:
            detail.append([e.id, e.fail_reason, "-", "-"])
    return summary, detail


def _verifier_audit_for_day(beginning, ending, exists_model):
    base_query = Q(raw__when__gte=beginning, raw__when__lte=ending)
    return _verified_audit_base(base_query, exists_model)


def _verifier_audit_for_day_ums(beginning, ending, exists_model, ums_offset=0):
    # NOTE(apmelton):
    # This is the UMS query we're trying to match.
    # where (
    #     (created_date between sysdate-1||'12.00.00.000000000 AM' and
    #                           sysdate-1||'04.00.00.000000000 AM' and
    #      audit_period_begin_timestamp >= sysdate-1||'12.00.00.000000000 AM')
    # OR (created_date > sysdate-1||'04.00.00.000000000 AM' and
    #     audit_period_begin_timestamp < sysdate||'12.00.00.000000000 AM' ))
    ums = (Q(raw__when__gte=beginning, raw__when__lte=beginning + ums_offset,
             audit_period_beginning__gte=beginning) |
           Q(raw__when__gt=beginning + ums_offset,
             audit_period_beginning__lt=ending))

    return _verified_audit_base(ums, exists_model)


def get_previous_period(time, period_length):
    if period_length == 'day':
        last_period = time - datetime.timedelta(days=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day)
        end = datetime.datetime(year=time.year,
                                month=time.month,
                                day=time.day)
        return start, end
    elif period_length == 'hour':
        last_period = time - datetime.timedelta(hours=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day,
                                  hour=last_period.hour)
        end = datetime.datetime(year=time.year,
                                month=time.month,
                                day=time.day,
                                hour=time.hour)
        return start, end

########NEW FILE########
__FILENAME__ = migrate_instance_flavor_id
#!/usr/bin/python
import os
import sys

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

import csv
from stacktach import models


def migrate_forwards(csv_file_path):
    with open(csv_file_path, "r") as f:
        for old_flavor, new_flavor in csv.reader(f):
            models.InstanceUsage.objects.filter(
                instance_type_id=old_flavor, instance_flavor_id=None)\
                .update(instance_flavor_id=new_flavor)
            models.InstanceExists.objects.filter(
                instance_type_id=old_flavor, instance_flavor_id=None)\
                .update(instance_flavor_id=new_flavor)
            models.InstanceReconcile.objects.filter(
                instance_type_id=old_flavor, instance_flavor_id=None)\
                .update(instance_flavor_id=new_flavor)


def migrate_backwards(csv_file_path):
    with open(csv_file_path, "r") as f:
        for old_flavor, new_flavor in csv.reader(f):
            models.InstanceUsage.objects.filter(instance_flavor_id=new_flavor)\
                .update(instance_flavor_id=None)
            models.InstanceExists.objects.filter(instance_flavor_id=new_flavor)\
                .update(instance_flavor_id=None)
            models.InstanceReconcile.objects.filter(
                instance_flavor_id=new_flavor)\
                .update(instance_flavor_id=None)

if __name__ == '__main__':
    try:
        csv_file_path = sys.argv[1]
        action = sys.argv[2]
    except Exception:
        print ("""usage: migrate_flavor_id.py <csv_file_absolute_path>"""
                """ <forwards | backwards>"""
                """\n\nThe input file for this script can be generated"""
                """ using the following SQL query:"""
                """\nSELECT id, flavorid"""
                """\nINTO OUTFILE '/tmp/flavors.csv'"""
                """\nFIELDS TERMINATED BY ','"""
                """\nENCLOSED BY '"'"""
                """\nLINES TERMINATED BY '\\n'"""
                """\nFROM instance_types;""")
        sys.exit(2)

    if action == "forwards":
        migrate_forwards(csv_file_path)
    elif action == "backwards":
        migrate_backwards(csv_file_path)

########NEW FILE########
__FILENAME__ = notification_scrubber
import argparse
import json
import os
import sys
import time

sys.path.append(os.environ.get('STACKTACH_INSTALL_DIR', '/stacktach'))

from stacktach import message_service as msg
from stacktach import utils

import scrubbers


def scrub(args, send_notif=lambda x: None):
    print "Starting scrub."
    start = utils.str_time_to_unix(args.start)
    end = utils.str_time_to_unix(args.end)

    if hasattr(scrubbers, args.scrubber):
        Scrubber = getattr(scrubbers, args.scrubber)
        scrubber = Scrubber(start, end)

        count = 0
        for raw in scrubber.raws():
            matches, body = scrubber.filter(raw)
            if matches and not body:
                body = json.loads(raw['json'])[1]
            if matches and body:
                scrubbed = scrubber.scrub(body)
                count += 1
                send_notif(scrubbed)
        return count
    else:
        print "No scrubber class %s." % args.scrubber
        return 0


def scrub_with_notifications(args):
    print "!!!!!! WARNING: SENDING TO RABBIT !!!!!!"
    print "!!!!!!  Sleeping for 30 seconds   !!!!!!"
    print "!!!!!!     before proceeding      !!!!!!"
    time.sleep(30)
    with open(args.rabbit_config) as fp:
        rabbit_config = json.load(fp)
        exchange = msg.create_exchange(rabbit_config['exchange'],
                                       'topic',
                                       durable=rabbit_config['durable_queue'])
        conn_conf = (rabbit_config['host'], rabbit_config['port'],
                     rabbit_config['userid'], rabbit_config['password'],
                     'librabbitmq', rabbit_config['virtual_host'])

        with msg.create_connection(*conn_conf) as conn:
            def send_notif(notif):
                msg.send_notification(notif, rabbit_config['routing_key'],
                                      conn, exchange)
            count = scrub(args, send_notif=send_notif)
    return count


if __name__ == '__main__':
    parser = argparse.ArgumentParser('Stacktach Notification Scrubber')
    parser.add_argument('--rabbit', action='store_true')
    parser.add_argument('--rabbit_config', default='rabbit_config.json')
    parser.add_argument('--scrubber', required=True)
    parser.add_argument('--start', required=True)
    parser.add_argument('--end', required=True)
    args = parser.parse_args()

    if args.rabbit:
        print "%s Events Scrubbed" % scrub_with_notifications(args)
    else:
        print "%s Events Scrubbed" % scrub(args)



########NEW FILE########
__FILENAME__ = scrubbers
import json
import uuid

from django.db.models import F

from stacktach import models


class ScrubberBase(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def raws(self):
        """ Returns an iterable of Raws to scrub
        """
        return [].__iter__()

    def filter(self, raw_data):
        """ Returns whether or not the provided RawData needs to be scrubbed.
            If the implementing function parses the json body to determine
            if it needs to be scrubbed, it should be returned as the second
            return value. This is done so that it will not need to be parsed
            a second time for scrubbing. Negative matches need not return
            parsed json bodies

        @raw_data: a RawData dictionary
        """
        return True, None

    def scrub(self, body):
        """ Returns the scrubbed json body of the RawData.

        @body: Dictionary version of the RawData's json.
        """
        return body


class ExistsCreatedAt(ScrubberBase):

    def raws(self):
        filters = {
            'raw__when__gte': self.start,
            'raw__when__lte': self.end,
            'audit_period_ending__lt': F('audit_period_beginning') + (60*60*24)
        }
        exists = models.InstanceExists.objects.filter(**filters)
        exists = exists.select_related('raw')
        for exist in exists.iterator():
            rawdata = exist.raw
            yield {'json': rawdata.json}

    def filter(self, raw_data):
        if '+00:00' in raw_data['json']:
            body = json.loads(raw_data['json'])[1]
            created_at = body.get('payload', {}).get('created_at')
            if created_at and '+00:00' in created_at:
                return True, body
            else:
                return False, None
        else:
            return False, None

    def scrub(self, body):
        created_at = body['payload']['created_at']
        scrubbed_created_at = created_at.replace('+00:00', '')
        body['payload']['created_at'] = scrubbed_created_at
        body['message_id'] = str(uuid.uuid4())
        return body


########NEW FILE########
__FILENAME__ = settings
# Django settings for StackTach project.
import os

try:
    from local_settings import *

    db_engine = STACKTACH_DB_ENGINE
    db_name = STACKTACH_DB_NAME
    db_host = STACKTACH_DB_HOST
    db_username = STACKTACH_DB_USERNAME
    db_password = STACKTACH_DB_PASSWORD
    db_port = STACKTACH_DB_PORT
    install_dir = os.path.expanduser(STACKTACH_INSTALL_DIR)
except ImportError:
    db_engine = os.environ.get('STACKTACH_DB_ENGINE',
                               'django.db.backends.mysql')
    db_name = os.environ['STACKTACH_DB_NAME']
    db_host = os.environ.get('STACKTACH_DB_HOST', "")
    db_username = os.environ['STACKTACH_DB_USERNAME']
    db_password = os.environ['STACKTACH_DB_PASSWORD']
    db_port = os.environ.get('STACKTACH_DB_PORT', "")
    install_dir = os.environ['STACKTACH_INSTALL_DIR']

DEBUG = False
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': db_engine,
        'NAME': db_name,
        'USER': db_username,
        'PASSWORD': db_password,
        'HOST': db_host,    # Set to empty string for localhost.
        'PORT': db_port,    # Set to empty string for default.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = None

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
#ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    [install_dir + "static",]
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'x=rgdy5@(*!$e5ou0j!q104+m5mt1d%ud9ujyykhklss7*um3t'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'stacktach.urls'
TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    install_dir + "templates"
)
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'stacktach',
    'south'
)

SOUTH_TESTS_MIGRATE = False

ALLOWED_HOSTS = ['*']

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler',
            'filters': []
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

# Force use of the pickle serializer as a workaound for django-1.6. See:
# https://docs.djangoproject.com/en/dev/releases/1.6/#default-session-serialization-switched-to-json
SESSION_SERIALIZER='django.contrib.sessions.serializers.PickleSerializer'

########NEW FILE########
__FILENAME__ = datetime_to_decimal
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import calendar
import datetime
import decimal


def dt_to_decimal(utc):
    decimal.getcontext().prec = 30
    return decimal.Decimal(str(calendar.timegm(utc.utctimetuple()))) + \
           (decimal.Decimal(str(utc.microsecond)) /
           decimal.Decimal("1000000.0"))


def dt_from_decimal(dec):
    if dec == None:
        return "n/a"
    integer = int(dec)
    micro = (dec - decimal.Decimal(integer)) * decimal.Decimal(1000000)

    daittyme = datetime.datetime.utcfromtimestamp(integer)
    return daittyme.replace(microsecond=micro)


def sec_to_str(sec):
    sec = int(sec)
    if sec < 60:
        return "%ds" % sec
    minutes = sec / 60
    sec = sec % 60
    if minutes < 60:
        return "%d:%02ds" % (minutes, sec)
    hours = minutes / 60
    minutes = minutes % 60
    return "%02d:%02d:%02d" % (hours, minutes, sec)

########NEW FILE########
__FILENAME__ = db
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from stacktach import stacklog
from stacktach import models


def _safe_get(Model, **kwargs):
    object = None
    query = Model.objects.filter(**kwargs)
    count = query.count()
    if count > 1:
        stacklog.warn('Multiple records found for %s get.' % Model.__name__)
        object = query[0]
    elif count < 1:
        stacklog.warn('No records found for %s get.' % Model.__name__)
    else:
        object = query[0]
    return object


def get_deployment(id):
    return _safe_get(models.Deployment, id=id)


def get_or_create_deployment(name):
    return models.Deployment.objects.get_or_create(name=name)


def create_nova_rawdata(**kwargs):
    imagemeta_fields = ['os_architecture', 'os_version',
                        'os_distro', 'rax_options']
    imagemeta_kwargs = \
        dict((k, v) for k, v in kwargs.iteritems() if k in imagemeta_fields)
    rawdata_kwargs = \
        dict((k, v) for k, v in kwargs.iteritems() if k not in imagemeta_fields)
    rawdata = models.RawData(**rawdata_kwargs)
    rawdata.save()

    imagemeta_kwargs.update({'raw_id': rawdata.id})
    save(models.RawDataImageMeta(**imagemeta_kwargs))

    return rawdata


def create_lifecycle(**kwargs):
    return models.Lifecycle(**kwargs)


def find_lifecycles(**kwargs):
    return models.Lifecycle.objects.select_related().filter(**kwargs)


def create_timing(**kwargs):
    return models.Timing(**kwargs)


def find_timings(**kwargs):
    return models.Timing.objects.select_related().filter(**kwargs)


def create_request_tracker(**kwargs):
    return models.RequestTracker(**kwargs)


def find_request_trackers(**kwargs):
    return models.RequestTracker.objects.filter(**kwargs)


def create_instance_usage(**kwargs):
    return models.InstanceUsage(**kwargs)


def get_or_create_instance_usage(**kwargs):
    return models.InstanceUsage.objects.get_or_create(**kwargs)


def get_or_create_instance_delete(**kwargs):
    return models.InstanceDeletes.objects.get_or_create(**kwargs)


def get_instance_usage(**kwargs):
    return _safe_get(models.InstanceUsage, **kwargs)


def create_instance_delete(**kwargs):
    return models.InstanceDeletes(**kwargs)


def get_instance_delete(**kwargs):
    return _safe_get(models.InstanceDeletes, **kwargs)


def create_instance_exists(**kwargs):
    return models.InstanceExists(**kwargs)


def save(obj):
    obj.save()


def create_glance_rawdata(**kwargs):
    rawdata = models.GlanceRawData(**kwargs)
    rawdata.save()

    return rawdata


def create_generic_rawdata(**kwargs):
    rawdata = models.GenericRawData(**kwargs)
    rawdata.save()

    return rawdata


def create_image_usage(**kwargs):
    usage = models.ImageUsage(**kwargs)
    usage.save()

    return usage


def create_image_delete(**kwargs):
    delete = models.ImageDeletes(**kwargs)
    delete.save()

    return delete


def create_image_exists(**kwargs):
    exists = models.ImageExists(**kwargs)
    exists.save()

    return exists


def get_image_delete(**kwargs):
    return _safe_get(models.ImageDeletes, **kwargs)


def get_image_usage(**kwargs):
    return _safe_get(models.ImageUsage, **kwargs)

########NEW FILE########
__FILENAME__ = dbapi
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import decimal
import datetime
import functools
import json
from datetime import datetime

from django.db import transaction
from django.db.models import Count
from django.db.models import FieldDoesNotExist
from django.forms.models import model_to_dict
from django.http import HttpResponse
from django.http import HttpResponseBadRequest
from django.http import HttpResponseNotFound
from django.http import HttpResponseServerError
from django.shortcuts import get_object_or_404

from stacktach import datetime_to_decimal as dt
from stacktach import models
from stacktach import stacklog
from stacktach import utils

DEFAULT_LIMIT = 50
HARD_LIMIT = 1000
HARD_WHEN_RANGE_LIMIT = 7 * 24 * 60 * 60  # 7 Days


class APIException(Exception):
    def __init__(self, message="Internal Server Error"):
        self.status = 500
        self.message = message

    def to_dict(self):
        return {'message': self.message,
                'status': self.status}


class BadRequestException(APIException):
    def __init__(self, message="Bad Request"):
        self.status = 400
        self.message = message


class NotFoundException(APIException):
    def __init__(self, message="Not Found"):
        self.status = 404
        self.message = message


def rsp(data):
    if data is None:
        return HttpResponse(content_type="application/json")
    return HttpResponse(json.dumps(data), content_type="application/json")


def _log_api_exception(cls, ex, request):
    line1 = "Exception: %s - %s - %s" % (cls.__name__, ex.status, ex.message)
    line2 = "Request: %s - %s" % (request.method, request.path)
    line3 = "Body: %s" % request.body
    msg = "%s\n%s\n%s" % (line1, line2, line3)
    if 400 <= ex.status < 500:
        stacklog.warn(msg)
    else:
        stacklog.error(msg)


def api_call(func):

    @functools.wraps(func)
    def handled(*args, **kwargs):
        try:
            return rsp(func(*args, **kwargs))
        except NotFoundException, e:
            _log_api_exception(NotFoundException, e, args[0])
            return HttpResponseNotFound(json.dumps(e.to_dict()),
                                        content_type="application/json")
        except BadRequestException, e:
            _log_api_exception(BadRequestException, e, args[0])
            return HttpResponseBadRequest(json.dumps(e.to_dict()),
                                          content_type="application/json")
        except APIException, e:
            _log_api_exception(APIException, e, args[0])
            return HttpResponseServerError(json.dumps(e.to_dict()),
                                           content_type="application/json")

    return handled


def _usage_model_factory(service):
    if service == 'nova':
        return {'klass': models.InstanceUsage, 'order_by': 'launched_at'}
    if service == 'glance':
        return {'klass': models.ImageUsage, 'order_by': 'created_at'}


def _exists_model_factory(service):
    if service == 'nova':
        return {'klass': models.InstanceExists, 'order_by': 'id'}
    if service == 'glance':
        return {'klass': models.ImageExists, 'order_by': 'id'}


def _deletes_model_factory(service):
    if service == 'nova':
        return {'klass': models.InstanceDeletes, 'order_by': 'launched_at'}
    if service == 'glance':
        return {'klass': models.ImageDeletes, 'order_by': 'deleted_at'}

@api_call
def list_usage_launches(request):
    return {'launches': list_usage_launches_with_service(request, 'nova')}

@api_call
def list_usage_images(request):
    return { 'images': list_usage_launches_with_service(request, 'glance')}


def list_usage_launches_with_service(request, service):
    model = _usage_model_factory(service)
    objects = get_db_objects(model['klass'], request,
                             model['order_by'])
    dicts = _convert_model_list(objects)
    return dicts


def get_usage_launch_with_service(launch_id, service):
    model = _usage_model_factory(service)
    return {'launch': _get_model_by_id(model['klass'], launch_id)}

@api_call
def get_usage_launch(request, launch_id):
    return get_usage_launch_with_service(launch_id, 'nova')


@api_call
def get_usage_image(request, image_id):
    return get_usage_launch_with_service(image_id, 'glance')


@api_call
def list_usage_deletes(request):
    return list_usage_deletes_with_service(request, 'nova')


@api_call
def list_usage_deletes_glance(request):
    return list_usage_deletes_with_service(request, 'glance')


def list_usage_deletes_with_service(request, service):
    model = _deletes_model_factory(service)
    objects = get_db_objects(model['klass'], request,
                             model['order_by'])
    dicts = _convert_model_list(objects)
    return {'deletes': dicts}


@api_call
def get_usage_delete(request, delete_id):
    model = _deletes_model_factory('nova')
    return {'delete': _get_model_by_id(model['klass'], delete_id)}


@api_call
def get_usage_delete_glance(request, delete_id):
    model = _deletes_model_factory('glance')
    return {'delete': _get_model_by_id(model['klass'], delete_id)}


def _exists_extra_values(exist):
    values = {'received': str(dt.dt_from_decimal(exist.raw.when))}
    return values


@api_call
def list_usage_exists(request):
    return list_usage_exists_with_service(request, 'nova')


@api_call
def list_usage_exists_glance(request):
    return list_usage_exists_with_service(request, 'glance')


def list_usage_exists_with_service(request, service):
    model = _exists_model_factory(service)
    custom_filters = _get_exists_filter_args(request)
    objects = get_db_objects(model['klass'], request, 'id',
                             custom_filters=custom_filters)
    dicts = _convert_model_list(objects, _exists_extra_values)
    return {'exists': dicts}


@api_call
def get_usage_exist(request, exist_id):
    return {'exist': _get_model_by_id(models.InstanceExists, exist_id,
                                      _exists_extra_values)}

@api_call
def get_usage_exist_glance(request, exist_id):
    return {'exist': _get_model_by_id(models.ImageExists, exist_id,
                                      _exists_extra_values)}


@api_call
def get_usage_exist_stats(request):
    return {'stats': _get_exist_stats(request, 'nova')}


@api_call
def get_usage_exist_stats_glance(request):
    return {'stats': _get_exist_stats(request, 'glance')}


def _get_exist_stats(request, service):
    klass = _exists_model_factory(service)['klass']
    exists_filters = _get_exists_filter_args(request)
    filters = _get_filter_args(klass, request,
                               custom_filters=exists_filters)
    for value in exists_filters.values():
        filters.update(value)
    query = klass.objects.filter(**filters)
    values = query.values('status', 'send_status')
    stats = values.annotate(event_count=Count('send_status'))
    return list(stats)

def _undecorated_exists_send_status(request, message_id):
    # No decorator for testing purposes.
    if request.method not in ['PUT', 'POST']:
        raise BadRequestException(message="Invalid method")

    if request.body is None or request.body == '':
        raise BadRequestException(message="Request body required")

    if message_id == 'batch':
        _exists_send_status_batch(request)
    else:
        body = json.loads(request.body)
        if body.get('send_status') is not None:
            send_status = body['send_status']
            try:
                exist = models.InstanceExists.objects\
                                             .select_for_update()\
                                             .get(message_id=message_id)
                exist.send_status = send_status
                exist.save()
            except models.InstanceExists.DoesNotExist:
                msg = "Could not find Exists record with message_id = '%s'"
                msg = msg % message_id
                raise NotFoundException(message=msg)
            except models.InstanceExists.MultipleObjectsReturned:
                msg = "Multiple Exists records with message_id = '%s'"
                msg = msg % message_id
                raise APIException(message=msg)
        else:
            msg = "'send_status' missing from request body"
            raise BadRequestException(message=msg)


@api_call
def exists_send_status(request, message_id):
    _undecorated_exists_send_status(request, message_id)


def _find_exists_with_message_id(msg_id, exists_model, service):
    if service == 'glance':
        return exists_model.objects.select_for_update().filter(
            message_id=msg_id)
    elif service == 'nova':
        return [models.InstanceExists.objects.select_for_update()
                .get(message_id=msg_id)]


def _ping_processing_with_service(pings, service, version=1):
    exists_model = _exists_model_factory(service)['klass']
    with transaction.commit_on_success():
            for msg_id, status_info in pings.items():
                try:
                    exists = _find_exists_with_message_id(msg_id, exists_model,
                                                          service)
                    for exists in exists:
                        if version == 1:
                            exists.send_status = status_info
                        elif version == 2:
                            exists.send_status = status_info.get("status", 0)
                            exists.event_id = status_info.get("event_id", "")
                        exists.save()
                except exists_model.DoesNotExist:
                    msg = "Could not find Exists record with message_id = '%s' for %s"
                    msg = msg % (msg_id, service)
                    raise NotFoundException(message=msg)
                except exists_model.MultipleObjectsReturned:
                    msg = "Multiple Exists records with message_id = '%s' for %s"
                    msg = msg % (msg_id, service)
                    print msg
                    raise APIException(message=msg)


def _exists_send_status_batch(request):
    body = json.loads(request.body)
    if body.get('messages') is not None:
        messages = body['messages']
        version = body.get('version', 0)
        if version == 0:
            service = 'nova'
            nova_pings = messages
            if nova_pings:
                _ping_processing_with_service(nova_pings, service)
        if version == 1 or version == 2:
            nova_pings = messages.get('nova', {})
            glance_pings = messages.get('glance', {})
            if nova_pings:
                _ping_processing_with_service(nova_pings, 'nova', version)
            if glance_pings:
                _ping_processing_with_service(glance_pings, 'glance', version)
    else:
        msg = "'messages' missing from request body"
        raise BadRequestException(message=msg)


def _get_model_by_id(klass, model_id, extra_values_func=None):
    model = get_object_or_404(klass, id=model_id)
    model_dict = _convert_model(model, extra_values_func)
    return model_dict


def _check_has_field(klass, field_name):
    try:
        klass._meta.get_field_by_name(field_name)
    except FieldDoesNotExist:
        msg = "No such field '%s'." % field_name
        raise BadRequestException(msg)


def _get_exists_filter_args(request):
    try:
        custom_filters = {}
        if 'received_min' in request.GET:
            received_min = request.GET['received_min']
            custom_filters['received_min'] = {}
            custom_filters['received_min']['raw__when__gte'] = \
                utils.str_time_to_unix(received_min)
        if 'received_max' in request.GET:
            received_max = request.GET['received_max']
            custom_filters['received_max'] = {}
            custom_filters['received_max']['raw__when__lte'] = \
                utils.str_time_to_unix(received_max)
    except AttributeError:
        msg = "Range filters must be dates."
        raise BadRequestException(message=msg)
    return custom_filters


def _get_filter_args(klass, request, custom_filters=None):
    filter_args = {}
    if 'instance' in request.GET:
        uuid = request.GET['instance']
        filter_args['instance'] = uuid
        if not utils.is_uuid_like(uuid):
            msg = "%s is not uuid-like" % uuid
            raise BadRequestException(msg)

    for (key, value) in request.GET.items():
            if not custom_filters or key not in custom_filters:
                if key.endswith('_min'):
                    k = key[0:-4]
                    _check_has_field(klass, k)
                    try:
                        filter_args['%s__gte' % k] = \
                            utils.str_time_to_unix(value)
                    except AttributeError:
                        msg = "Range filters must be dates."
                        raise BadRequestException(message=msg)
                elif key.endswith('_max'):
                    k = key[0:-4]
                    _check_has_field(klass, k)
                    try:
                        filter_args['%s__lte' % k] = \
                            utils.str_time_to_unix(value)
                    except AttributeError:
                        msg = "Range filters must be dates."
                        raise BadRequestException(message=msg)

    return filter_args


def get_db_objects(klass, request, default_order_by, direction='desc',
                   custom_filters=None):
    filter_args = _get_filter_args(klass, request,
                                   custom_filters=custom_filters)
    if custom_filters:
        for key in custom_filters:
            filter_args.update(custom_filters[key])

    if len(filter_args) > 0:
        objects = klass.objects.filter(**filter_args)
    else:
        objects = klass.objects.all()

    order_by = request.GET.get('order_by', default_order_by)
    _check_has_field(klass, order_by)

    direction = request.GET.get('direction', direction)
    if direction == 'desc':
        order_by = '-%s' % order_by
    else:
        order_by = '%s' % order_by

    offset = request.GET.get('offset')
    limit = request.GET.get('limit', DEFAULT_LIMIT)

    if limit:
        limit = int(limit)

    if limit > HARD_LIMIT:
        limit = HARD_LIMIT
    if offset:
        start = int(offset)
    else:
        start = None
        offset = 0
    end = int(offset) + int(limit)
    return objects.order_by(order_by)[start:end]


def _convert_model(model, extra_values_func=None):
    model_dict = model_to_dict(model)
    for key in model_dict:
        if isinstance(model_dict[key], decimal.Decimal):
            model_dict[key] = str(dt.dt_from_decimal(model_dict[key]))
    if extra_values_func:
        model_dict.update(extra_values_func(model))
    return model_dict


def _convert_model_list(model_list, extra_values_func=None):
    converted = []
    for item in model_list:
        converted.append(_convert_model(item, extra_values_func))

    return converted


def _rawdata_factory(service):
    if service == "nova":
        rawdata = models.RawData.objects
    elif service == "glance":
        rawdata = models.GlanceRawData.objects
    else:
        raise BadRequestException(message="Invalid service")
    return rawdata


@api_call
def get_event_stats(request):
    try:
        filters = {}

        if 'when_min' in request.GET or 'when_max' in request.GET:
            if not ('when_min' in request.GET and 'when_max' in request.GET):
                msg = "When providing date range filters, " \
                      "a min and max are required."
                raise BadRequestException(message=msg)

            when_min = utils.str_time_to_unix(request.GET['when_min'])
            when_max = utils.str_time_to_unix(request.GET['when_max'])

            if when_max - when_min > HARD_WHEN_RANGE_LIMIT:
                msg = "Date ranges may be no larger than %s seconds"
                raise BadRequestException(message=msg % HARD_WHEN_RANGE_LIMIT)

            filters['when__lte'] = when_max
            filters['when__gte'] = when_min

        service = request.GET.get("service", "nova")
        rawdata = _rawdata_factory(service)
        if filters:
            rawdata = rawdata.filter(**filters)
        events = rawdata.values('event').annotate(event_count=Count('event'))
        events = list(events)

        if 'event' in request.GET:
            event = request.GET['event']
            default = {'event': event, 'event_count': 0}
            events = [x for x in events if x['event'] == event] or [default, ]

        return {'stats': events}
    except (KeyError, TypeError):
        raise BadRequestException(message="Invalid/absent query parameter")
    except (ValueError, AttributeError):
        raise BadRequestException(message="Invalid format for date (Correct "
                                          "format should be %Y-%m-%d %H:%M:%S)")


def repair_stacktach_down(request):
    post_dict = dict((request.POST._iterlists()))
    message_ids = post_dict.get('message_ids')
    service = post_dict.get('service', ['nova'])
    klass = _exists_model_factory(service[0])['klass']
    absent_exists, exists_not_pending = \
        klass.mark_exists_as_sent_unverified(message_ids)
    response_data = {'absent_exists': absent_exists,
                     'exists_not_pending': exists_not_pending}
    response = HttpResponse(json.dumps(response_data),
                            content_type="application/json")
    return response


def _update_tenant_info_cache(tenant_info):
    tenant_id = tenant_info['tenant']
    try:
        tenant = models.TenantInfo.objects\
                                  .select_for_update()\
                                  .get(tenant=tenant_id)
    except models.TenantInfo.DoesNotExist:
        tenant = models.TenantInfo(tenant=tenant_id)
    tenant.name = tenant_info['name']
    tenant.last_updated = datetime.utcnow()
    tenant.save()

    types = set()
    for type_name, type_value in tenant_info['types'].items():
        try:
            tenant_type = models.TenantType.objects\
                                           .get(name=type_name,
                                                value=type_value)
        except models.TenantType.DoesNotExist:
            tenant_type = models.TenantType(name=type_name,
                                            value=type_value)
            tenant_type.save()
        types.add(tenant_type)
    tenant.types = list(types)
    tenant.save()

def _batch_update_tenant_info(info_list):
    tenant_info = dict((str(info['tenant']), info) for info in info_list)
    tenant_ids = set(tenant_info)
    old_tenants = set(t['tenant'] for t in
                      models.TenantInfo.objects
                               .filter(tenant__in=list(tenant_ids))
                               .values('tenant'))
    new_tenants = []
    now = datetime.utcnow()
    for tenant in (tenant_ids - old_tenants):
        new_tenants.append(models.TenantInfo(tenant=tenant,
                                             name=tenant_info[tenant]['name'],
                                             last_updated=now))
    if new_tenants:
        models.TenantInfo.objects.bulk_create(new_tenants)
    tenants = models.TenantInfo.objects.filter(tenant__in=list(tenant_ids))
    tenants.update(last_updated=now)

    types = dict(((tt.name, tt.value), tt)
                        for tt in models.TenantType.objects.all())
    TypeXref = models.TenantInfo.types.through

    changed_tenant_dbids = []
    new_type_xrefs = []
    for tenant in tenants:
        info = tenant_info[tenant.tenant]
        new_types = set()
        for type_name, type_value in info['types'].items():
            ttype = types.get((type_name, type_value))
            if ttype is None:
                ttype = models.TenantType(name=type_name,
                                                value=type_value)
                ttype.save()
                types[(type_name,type_value)] = ttype
            new_types.add(ttype)
        cur_types = set(tenant.types.all())
        if new_types != cur_types:
            if cur_types:
                changed_tenant_dbids.append(tenant.id)
            for ttype in new_types:
                new_type_xrefs.append(TypeXref(tenantinfo_id=tenant.id, tenanttype_id=ttype.id))
    TypeXref.objects.filter(tenantinfo_id__in=changed_tenant_dbids).delete()
    TypeXref.objects.bulk_create(new_type_xrefs)


@api_call
def batch_update_tenant_info(request):
    if request.method not in ['PUT', 'POST']:
        raise BadRequestException(message="Invalid method")

    if request.body is None or request.body == '':
        raise BadRequestException(message="Request body required")

    body = json.loads(request.body)
    if body.get('tenants') is not None:
        tenants = body['tenants']
        _batch_update_tenant_info(tenants)
    else:
        msg = "'tenants' missing from request body"
        raise BadRequestException(message=msg)

@api_call
def update_tenant_info(request, tenant_id):
    if request.method not in ['PUT', 'POST']:
        raise BadRequestException(message="Invalid method")

    if request.body is None or request.body == '':
        raise BadRequestException(message="Request body required")

    body = json.loads(request.body)
    if body['tenant'] != tenant_id:
        raise BadRequestException(message="Invalid tenant: %s != %s" % (body['tenant'], tenant_id))
    _update_tenant_info_cache(body)

########NEW FILE########
__FILENAME__ = image_type
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from operator import itemgetter


BASE_IMAGE = 0x1
SNAPSHOT_IMAGE = 0x2
IMPORT_IMAGE = 0x3

LINUX_IMAGE = 0x10
WINDOWS_IMAGE = 0x20
FREEBSD_IMAGE = 0x40

OS_UBUNTU = 0x100
OS_DEBIAN = 0x200
OS_CENTOS = 0x400
OS_RHEL = 0x800


def isset(num, flag):
    if not num:
        return False
    return num & flag > 0


flags = {'base' : BASE_IMAGE,
         'snapshot' : SNAPSHOT_IMAGE,
         'linux' : LINUX_IMAGE,
         'windows': WINDOWS_IMAGE,
         'freebsd': FREEBSD_IMAGE,
         'ubuntu' : OS_UBUNTU,
         'debian' : OS_DEBIAN,
         'centos' : OS_CENTOS,
         'rhel' : OS_RHEL}


def readable(num):
    result = []
    for k, v in sorted(flags.iteritems(), key=itemgetter(1)):
        if isset(num, v):
            result.append(k)
    return result


def get_numeric_code(payload, default=0):
    meta = payload.get('image_meta', {})
    num = default

    image_type = meta.get('image_type', '')
    if image_type == 'base':
        num |= BASE_IMAGE
    if image_type == 'snapshot':
        num |= SNAPSHOT_IMAGE
    if image_type == 'import':
        num |= IMPORT_IMAGE
    os_type = meta.get('os_type', payload.get('os_type', ''))
    if os_type == 'linux':
        num |= LINUX_IMAGE
    if os_type == 'windows':
        num |= WINDOWS_IMAGE
    if os_type == 'freebsd':
        num |= FREEBSD_IMAGE

    os_distro = meta.get('os_distro', '')
    if os_distro == 'ubuntu':
        num |= OS_UBUNTU
    if os_distro == 'debian':
        num |= OS_DEBIAN
    if os_distro == 'centos':
        num |= OS_CENTOS
    if os_distro == 'rhel':
        num |= OS_RHEL

    return num

########NEW FILE########
__FILENAME__ = message_service
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import kombu
import kombu.entity
import kombu.pools
import kombu.connection
import kombu.common

def send_notification(message, routing_key, connection, exchange):
    with kombu.pools.producers[connection].acquire(block=True) as producer:
        kombu.common.maybe_declare(exchange, producer.channel)
        producer.publish(message, routing_key)


def create_exchange(name, exchange_type, exclusive=False, auto_delete=False,
                    durable=True):
    return kombu.entity.Exchange(name, type=exchange_type, exclusive=exclusive,
                                 auto_delete=auto_delete, durable=durable)


def create_connection(hostname, port, userid, password, transport,
                      virtual_host):
    return kombu.connection.BrokerConnection(
        hostname=hostname, port=port, userid=userid, password=password,
        transport=transport, virtual_host=virtual_host)


def create_queue(name, exchange, routing_key, exclusive=False,
                 auto_delete=False, queue_arguments=None, durable=True):
    return kombu.Queue(name, exchange, durable=durable,
                       auto_delete=auto_delete, exclusive=exclusive,
                       queue_arguments=queue_arguments,
                       routing_key=routing_key)

########NEW FILE########
__FILENAME__ = 0001_initial
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Deployment'
        db.create_table(u'stacktach_deployment', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50)),
        ))
        db.send_create_signal(u'stacktach', ['Deployment'])

        # Adding model 'RawData'
        db.create_table(u'stacktach_rawdata', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('deployment', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.Deployment'])),
            ('tenant', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('json', self.gf('django.db.models.fields.TextField')()),
            ('routing_key', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('state', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=20, null=True, blank=True)),
            ('old_state', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=20, null=True, blank=True)),
            ('old_task', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=30, null=True, blank=True)),
            ('task', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=30, null=True, blank=True)),
            ('image_type', self.gf('django.db.models.fields.IntegerField')(default=0, null=True, db_index=True)),
            ('when', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('publisher', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('event', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('service', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('host', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('request_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
        ))
        db.send_create_signal(u'stacktach', ['RawData'])

        # Adding model 'Lifecycle'
        db.create_table(u'stacktach_lifecycle', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('last_state', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('last_task_state', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('last_raw', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.RawData'], null=True)),
        ))
        db.send_create_signal(u'stacktach', ['Lifecycle'])

        # Adding model 'InstanceUsage'
        db.create_table(u'stacktach_instanceusage', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('launched_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('request_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('instance_type_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('tenant', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
        ))
        db.send_create_signal(u'stacktach', ['InstanceUsage'])

        # Adding model 'InstanceDeletes'
        db.create_table(u'stacktach_instancedeletes', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('launched_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('deleted_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('raw', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.RawData'], null=True)),
        ))
        db.send_create_signal(u'stacktach', ['InstanceDeletes'])

        # Adding model 'InstanceExists'
        db.create_table(u'stacktach_instanceexists', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('launched_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('deleted_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('audit_period_beginning', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('audit_period_ending', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('message_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('instance_type_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('status', self.gf('django.db.models.fields.CharField')(default='pending', max_length=50, db_index=True)),
            ('fail_reason', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=300, null=True, blank=True)),
            ('raw', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.RawData'])),
            ('usage', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.InstanceUsage'])),
            ('delete', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.InstanceDeletes'])),
            ('send_status', self.gf('django.db.models.fields.IntegerField')(default=0, null=True, db_index=True)),
            ('tenant', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
        ))
        db.send_create_signal(u'stacktach', ['InstanceExists'])

        # Adding model 'Timing'
        db.create_table(u'stacktach_timing', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('lifecycle', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.Lifecycle'])),
            ('start_raw', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.RawData'])),
            ('end_raw', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.RawData'])),
            ('start_when', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6)),
            ('end_when', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6)),
            ('diff', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
        ))
        db.send_create_signal(u'stacktach', ['Timing'])

        # Adding model 'RequestTracker'
        db.create_table(u'stacktach_requesttracker', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('request_id', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('lifecycle', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.Lifecycle'])),
            ('last_timing', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.Timing'], null=True)),
            ('start', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('duration', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('completed', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
        ))
        db.send_create_signal(u'stacktach', ['RequestTracker'])

        # Adding model 'JsonReport'
        db.create_table(u'stacktach_jsonreport', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('period_start', self.gf('django.db.models.fields.DateTimeField')(db_index=True)),
            ('period_end', self.gf('django.db.models.fields.DateTimeField')(db_index=True)),
            ('created', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('version', self.gf('django.db.models.fields.IntegerField')(default=1)),
            ('json', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'stacktach', ['JsonReport'])


    def backwards(self, orm):
        # Deleting model 'Deployment'
        db.delete_table(u'stacktach_deployment')

        # Deleting model 'RawData'
        db.delete_table(u'stacktach_rawdata')

        # Deleting model 'Lifecycle'
        db.delete_table(u'stacktach_lifecycle')

        # Deleting model 'InstanceUsage'
        db.delete_table(u'stacktach_instanceusage')

        # Deleting model 'InstanceDeletes'
        db.delete_table(u'stacktach_instancedeletes')

        # Deleting model 'InstanceExists'
        db.delete_table(u'stacktach_instanceexists')

        # Deleting model 'Timing'
        db.delete_table(u'stacktach_timing')

        # Deleting model 'RequestTracker'
        db.delete_table(u'stacktach_requesttracker')

        # Deleting model 'JsonReport'
        db.delete_table(u'stacktach_jsonreport')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0002_create_rawdataimagemeta_and_add_usage_related_fields_to_instanceexists_and_instanceusages
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'RawDataImageMeta'
        db.create_table(u'stacktach_rawdataimagemeta', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('raw', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.RawData'])),
            ('os_architecture', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('os_distro', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('os_version', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('rax_options', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal(u'stacktach', ['RawDataImageMeta'])

        # Adding field 'InstanceExists.os_architecture'
        db.add_column(u'stacktach_instanceexists', 'os_architecture',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceExists.os_distro'
        db.add_column(u'stacktach_instanceexists', 'os_distro',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceExists.os_version'
        db.add_column(u'stacktach_instanceexists', 'os_version',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceExists.rax_options'
        db.add_column(u'stacktach_instanceexists', 'rax_options',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceUsage.os_architecture'
        db.add_column(u'stacktach_instanceusage', 'os_architecture',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceUsage.os_distro'
        db.add_column(u'stacktach_instanceusage', 'os_distro',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceUsage.os_version'
        db.add_column(u'stacktach_instanceusage', 'os_version',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceUsage.rax_options'
        db.add_column(u'stacktach_instanceusage', 'rax_options',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting model 'RawDataImageMeta'
        db.delete_table(u'stacktach_rawdataimagemeta')

        # Deleting field 'InstanceExists.os_architecture'
        db.delete_column(u'stacktach_instanceexists', 'os_architecture')

        # Deleting field 'InstanceExists.os_distro'
        db.delete_column(u'stacktach_instanceexists', 'os_distro')

        # Deleting field 'InstanceExists.os_version'
        db.delete_column(u'stacktach_instanceexists', 'os_version')

        # Deleting field 'InstanceExists.rax_options'
        db.delete_column(u'stacktach_instanceexists', 'rax_options')

        # Deleting field 'InstanceUsage.os_architecture'
        db.delete_column(u'stacktach_instanceusage', 'os_architecture')

        # Deleting field 'InstanceUsage.os_distro'
        db.delete_column(u'stacktach_instanceusage', 'os_distro')

        # Deleting field 'InstanceUsage.os_version'
        db.delete_column(u'stacktach_instanceusage', 'os_version')

        # Deleting field 'InstanceUsage.rax_options'
        db.delete_column(u'stacktach_instanceusage', 'rax_options')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0003_populate_usage_related_fields_in_rawdataimagemeta_instanceexists_and_instanceusages_from_rawdata
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import copy
import gc
from south.v2 import DataMigration
from stacktach.notification import notification_factory

try:
    import ujson as json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        import json

USAGE_EVENTS = [
    'compute.instance.create.start',
    'compute.instance.create.end',
    'compute.instance.rebuild.start',
    'compute.instance.rebuild.end',
    'compute.instance.resize.prep.start',
    'compute.instance.resize.prep.end',
    'compute.instance.resize.revert.start',
    'compute.instance.resize.revert.end',
    'compute.instance.finish_resize.end',
    'compute.instance.delete.end',
    'compute.instance.exists']

USAGE_EVENTS_EXCEPT_EXISTS = copy.deepcopy(USAGE_EVENTS)
USAGE_EVENTS_EXCEPT_EXISTS.remove('compute.instance.exists')


def queryset_iterator(queryset, chunksize=1000):
    '''''
    Iterate over a Django Queryset ordered by the primary key

    This method loads a maximum of chunksize (default: 1000) rows in it's
    memory at the same time while django normally would load all rows in it's
    memory. Using the iterator() method only causes it to not preload all the
    classes.

    Note that the implementation of the iterator does not support ordered query sets.
    '''
    id = 0
    if queryset.order_by('-id').count() > 0:
        last_pk = queryset.order_by('-id')[0]['id']
        queryset = queryset.order_by('id')
        while id < last_pk:
            for row in queryset.filter(id__gt=id)[:chunksize]:
                id = row['id']
                yield row
            gc.collect()


class Migration(DataMigration):

    def _find_latest_usage_related_raw_id_for_request_id(self, orm, request_id):
        rawdata = orm.RawData.objects.filter(
            request_id=request_id,
            event__in=USAGE_EVENTS_EXCEPT_EXISTS).order_by('id')[:1].values('id')
        if rawdata.count() > 0:
            return rawdata[0]['id']
        return None

    def _notification(self, json_message):
        json_dict = json.loads(json_message)
        routing_key = json_dict[0]
        body = json_dict[1]
        return notification_factory(body, None, routing_key, json_message,
                                    'nova')

    def forwards(self, orm):
        # Note: Don't use "from appname.models import ModelName".
        # Use orm.ModelName to refer to models in this application,
        # and orm['appname.ModelName'] for models in other applications.
        print "Started inserting records in RawDataImageMeta"
        rawdata_all = orm.RawData.objects.filter(event__in=USAGE_EVENTS).values('json', 'id')
        for rawdata in queryset_iterator(rawdata_all):
            notification = self._notification(rawdata['json'])
            orm.RawDataImageMeta.objects.create(
                raw_id=rawdata['id'],
                os_architecture=notification.os_architecture,
                os_distro=notification.os_distro,
                os_version=notification.os_version,
                rax_options=notification.rax_options)
        print "Inserted %s records in RawDataImageMeta" % rawdata_all.count()

        print "\nStarted updating records in InstanceExists"
        exists = orm.InstanceExists.objects.values('raw_id')
        exists_update_count = 0
        for exist in exists:
            image_metadata = orm.RawDataImageMeta.objects.filter(raw_id=exist['raw_id'])
            if image_metadata.count() == 0:
                print "RawDataImageMeta not found for InstanceExists with raw_id %s" % exist['raw_id']
                continue
            orm.InstanceExists.objects.filter(
                raw_id=exist['raw_id']).update(
                    os_architecture=image_metadata[0].os_architecture,
                    os_distro=image_metadata[0].os_distro,
                    os_version=image_metadata[0].os_version,
                    rax_options=image_metadata[0].rax_options)
            exists_update_count += 1
        print "Updated %s records in InstanceExists" % exists_update_count

        print "\nStarted updating records in InstanceUsages"
        usages = orm.InstanceUsage.objects.all().values('request_id')
        usages_update_count = 0
        for usage in usages:
            raw_id = self._find_latest_usage_related_raw_id_for_request_id(orm, usage['request_id'])
            if not raw_id:
                print "No Rawdata entry found for a usage related event with request_id %s" % usage['request_id']
                continue
            image_metadata = orm.RawDataImageMeta.objects.filter(raw_id=raw_id)[0]
            orm.InstanceUsage.objects.filter(
                request_id=usage['request_id']).update(
                    os_architecture=image_metadata.os_architecture,
                    os_distro=image_metadata.os_distro,
                    os_version=image_metadata.os_version,
                    rax_options=image_metadata.rax_options)
            usages_update_count += 1
        print "Updated %s records in InstanceUsages" % usages_update_count

    def backwards(self, orm):
        raise RuntimeError("Cannot reverse this migration.")


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0004_create_instancereconcile
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'InstanceReconcile'
        db.create_table(u'stacktach_instancereconcile', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('row_created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('row_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('launched_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('deleted_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('instance_type_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('source', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=150, null=True, blank=True)),
        ))
        db.send_create_signal(u'stacktach', ['InstanceReconcile'])


    def backwards(self, orm):
        # Deleting model 'InstanceReconcile'
        db.delete_table(u'stacktach_instancereconcile')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0005_tenant_and_image_meta_on_instance_reconcile
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'InstanceReconcile.tenant'
        db.add_column(u'stacktach_instancereconcile', 'tenant',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceReconcile.os_architecture'
        db.add_column(u'stacktach_instancereconcile', 'os_architecture',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceReconcile.os_distro'
        db.add_column(u'stacktach_instancereconcile', 'os_distro',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceReconcile.os_version'
        db.add_column(u'stacktach_instancereconcile', 'os_version',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceReconcile.rax_options'
        db.add_column(u'stacktach_instancereconcile', 'rax_options',
                      self.gf('django.db.models.fields.TextField')(null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'InstanceReconcile.tenant'
        db.delete_column(u'stacktach_instancereconcile', 'tenant')

        # Deleting field 'InstanceReconcile.os_architecture'
        db.delete_column(u'stacktach_instancereconcile', 'os_architecture')

        # Deleting field 'InstanceReconcile.os_distro'
        db.delete_column(u'stacktach_instancereconcile', 'os_distro')

        # Deleting field 'InstanceReconcile.os_version'
        db.delete_column(u'stacktach_instancereconcile', 'os_version')

        # Deleting field 'InstanceReconcile.rax_options'
        db.delete_column(u'stacktach_instancereconcile', 'rax_options')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0006_create_glance_usage_verification_tables
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'ImageDeletes'
        db.create_table(u'stacktach_imagedeletes', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('uuid', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('deleted_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('raw', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.GlanceRawData'], null=True)),
        ))
        db.send_create_signal(u'stacktach', ['ImageDeletes'])

        # Adding model 'GlanceRawData'
        db.create_table(u'stacktach_glancerawdata', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('deployment', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.Deployment'])),
            ('owner', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=255, null=True, blank=True)),
            ('json', self.gf('django.db.models.fields.TextField')()),
            ('routing_key', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('when', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('publisher', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('event', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('service', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('host', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('request_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('uuid', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=36, null=True, blank=True)),
            ('status', self.gf('django.db.models.fields.CharField')(max_length=30, null=True, db_index=True)),
            ('image_type', self.gf('django.db.models.fields.IntegerField')(default=0, null=True, db_index=True)),
        ))
        db.send_create_signal(u'stacktach', ['GlanceRawData'])

        # Adding model 'ImageUsage'
        db.create_table(u'stacktach_imageusage', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('uuid', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('created_at', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('owner', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('size', self.gf('django.db.models.fields.BigIntegerField')(max_length=20)),
            ('last_raw', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.GlanceRawData'], null=True)),
        ))
        db.send_create_signal(u'stacktach', ['ImageUsage'])

        # Adding model 'GenericRawData'
        db.create_table(u'stacktach_genericrawdata', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('deployment', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['stacktach.Deployment'])),
            ('tenant', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('json', self.gf('django.db.models.fields.TextField')()),
            ('routing_key', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('when', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('publisher', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('event', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('service', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('host', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('instance', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('request_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
            ('message_id', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True)),
        ))
        db.send_create_signal(u'stacktach', ['GenericRawData'])

        # Adding model 'ImageExists'
        db.create_table(u'stacktach_imageexists', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('uuid', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('created_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('deleted_at', self.gf('django.db.models.fields.DecimalField')(null=True, max_digits=20, decimal_places=6, db_index=True)),
            ('audit_period_beginning', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('audit_period_ending', self.gf('django.db.models.fields.DecimalField')(max_digits=20, decimal_places=6, db_index=True)),
            ('status', self.gf('django.db.models.fields.CharField')(default='pending', max_length=50, db_index=True)),
            ('fail_reason', self.gf('django.db.models.fields.CharField')(max_length=300, null=True)),
            ('raw', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', to=orm['stacktach.GlanceRawData'])),
            ('usage', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.ImageUsage'])),
            ('delete', self.gf('django.db.models.fields.related.ForeignKey')(related_name='+', null=True, to=orm['stacktach.ImageDeletes'])),
            ('send_status', self.gf('django.db.models.fields.IntegerField')(default=0, db_index=True)),
            ('owner', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('size', self.gf('django.db.models.fields.BigIntegerField')(max_length=20)),
        ))
        db.send_create_signal(u'stacktach', ['ImageExists'])


    def backwards(self, orm):
        # Deleting model 'ImageDeletes'
        db.delete_table(u'stacktach_imagedeletes')

        # Deleting model 'GlanceRawData'
        db.delete_table(u'stacktach_glancerawdata')

        # Deleting model 'ImageUsage'
        db.delete_table(u'stacktach_imageusage')

        # Deleting model 'GenericRawData'
        db.delete_table(u'stacktach_genericrawdata')

        # Deleting model 'ImageExists'
        db.delete_table(u'stacktach_imageexists')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0007_update_owner_to_nullable_in_imageusage_and_imageexists
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'ImageUsage.owner'
        db.alter_column(u'stacktach_imageusage', 'owner', self.gf('django.db.models.fields.CharField')(max_length=50, null=True))

        # Changing field 'ImageExists.owner'
        db.alter_column(u'stacktach_imageexists', 'owner', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

    def backwards(self, orm):

        # User chose to not deal with backwards NULL issues for 'ImageUsage.owner'
        raise RuntimeError("Cannot reverse this migration. 'ImageUsage.owner' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'ImageExists.owner'
        raise RuntimeError("Cannot reverse this migration. 'ImageExists.owner' and its values cannot be restored.")

    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0008_auto__add_field_instanceexists_bandwidth_public_out__chg_field_imageex
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'InstanceExists.bandwidth_public_out'
        db.add_column(u'stacktach_instanceexists', 'bandwidth_public_out',
                      self.gf('django.db.models.fields.BigIntegerField')(null=True),
                      keep_default=False)


        # Changing field 'ImageExists.uuid'
        db.alter_column(u'stacktach_imageexists', 'uuid', self.gf('django.db.models.fields.CharField')(max_length=50, null=True))

    def backwards(self, orm):
        # Deleting field 'InstanceExists.bandwidth_public_out'
        db.delete_column(u'stacktach_instanceexists', 'bandwidth_public_out')


        # Changing field 'ImageExists.uuid'
        db.alter_column(u'stacktach_imageexists', 'uuid', self.gf('django.db.models.fields.CharField')(default='blank_uuid', max_length=50))

    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'bandwidth_public_out': ('django.db.models.fields.BigIntegerField', [], {'null': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0009_auto__chg_field_instanceexists_bandwidth_public_out
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'InstanceExists.bandwidth_public_out'
        db.alter_column(u'stacktach_instanceexists', 'bandwidth_public_out', self.gf('django.db.models.fields.BigIntegerField')())

    def backwards(self, orm):

        # Changing field 'InstanceExists.bandwidth_public_out'
        db.alter_column(u'stacktach_instanceexists', 'bandwidth_public_out', self.gf('django.db.models.fields.BigIntegerField')(null=True))

    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'bandwidth_public_out': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0010_add_instance_flavor_id_to_instancereconcile_instanceexists_and_instanceusage
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'InstanceReconcile.instance_flavor_id'
        db.add_column(u'stacktach_instancereconcile', 'instance_flavor_id',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceExists.instance_flavor_id'
        db.add_column(u'stacktach_instanceexists', 'instance_flavor_id',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True),
                      keep_default=False)

        # Adding field 'InstanceUsage.instance_flavor_id'
        db.add_column(u'stacktach_instanceusage', 'instance_flavor_id',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'InstanceReconcile.instance_flavor_id'
        db.delete_column(u'stacktach_instancereconcile', 'instance_flavor_id')

        # Deleting field 'InstanceExists.instance_flavor_id'
        db.delete_column(u'stacktach_instanceexists', 'instance_flavor_id')

        # Deleting field 'InstanceUsage.instance_flavor_id'
        db.delete_column(u'stacktach_instanceusage', 'instance_flavor_id')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'bandwidth_public_out': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0011_auto__add_field_imageexists_message_id
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'ImageExists.message_id'
        db.add_column(u'stacktach_imageexists', 'message_id',
                      self.gf('django.db.models.fields.CharField')(db_index=True, max_length=50, null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'ImageExists.message_id'
        db.delete_column(u'stacktach_imageexists', 'message_id')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'bandwidth_public_out': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0012_auto__add_field_instanceexists_event_id__add_field_imageexists_event_i
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'InstanceExists.event_id'
        db.add_column(u'stacktach_instanceexists', 'event_id',
                      self.gf('django.db.models.fields.CharField')(max_length=50, null=True, blank=True),
                      keep_default=False)

        # Adding field 'ImageExists.event_id'
        db.add_column(u'stacktach_imageexists', 'event_id',
                      self.gf('django.db.models.fields.CharField')(max_length=50, null=True, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'InstanceExists.event_id'
        db.delete_column(u'stacktach_instanceexists', 'event_id')

        # Deleting field 'ImageExists.event_id'
        db.delete_column(u'stacktach_imageexists', 'event_id')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'event_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'bandwidth_public_out': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'event_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = 0013_auto__add_tenantinfo__add_tenanttype
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'TenantInfo'
        db.create_table(u'stacktach_tenantinfo', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('tenant', self.gf('django.db.models.fields.CharField')(unique=True, max_length=50, db_index=True)),
            ('name', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=100, null=True, blank=True)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(db_index=True)),
        ))
        db.send_create_signal(u'stacktach', ['TenantInfo'])

        # Adding M2M table for field types on 'TenantInfo'
        m2m_table_name = db.shorten_name(u'stacktach_tenantinfo_types')
        db.create_table(m2m_table_name, (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('tenantinfo', models.ForeignKey(orm[u'stacktach.tenantinfo'], null=False)),
            ('tenanttype', models.ForeignKey(orm[u'stacktach.tenanttype'], null=False))
        ))
        db.create_unique(m2m_table_name, ['tenantinfo_id', 'tenanttype_id'])

        # Adding model 'TenantType'
        db.create_table(u'stacktach_tenanttype', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=50, db_index=True)),
        ))
        db.send_create_signal(u'stacktach', ['TenantType'])


    def backwards(self, orm):
        # Deleting model 'TenantInfo'
        db.delete_table(u'stacktach_tenantinfo')

        # Removing M2M table for field types on 'TenantInfo'
        db.delete_table(db.shorten_name(u'stacktach_tenantinfo_types'))

        # Deleting model 'TenantType'
        db.delete_table(u'stacktach_tenanttype')


    models = {
        u'stacktach.deployment': {
            'Meta': {'object_name': 'Deployment'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'stacktach.genericrawdata': {
            'Meta': {'object_name': 'GenericRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.glancerawdata': {
            'Meta': {'object_name': 'GlanceRawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'owner': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '30', 'null': 'True', 'db_index': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '36', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.imagedeletes': {
            'Meta': {'object_name': 'ImageDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.imageexists': {
            'Meta': {'object_name': 'ImageExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'created_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'max_length': '300', 'null': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'to': u"orm['stacktach.GlanceRawData']"}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.ImageUsage']"}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'})
        },
        u'stacktach.imageusage': {
            'Meta': {'object_name': 'ImageUsage'},
            'created_at': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.GlanceRawData']", 'null': 'True'}),
            'owner': ('django.db.models.fields.CharField', [], {'max_length': '50', 'null': 'True', 'db_index': 'True'}),
            'size': ('django.db.models.fields.BigIntegerField', [], {'max_length': '20'}),
            'uuid': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.instancedeletes': {
            'Meta': {'object_name': 'InstanceDeletes'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'})
        },
        u'stacktach.instanceexists': {
            'Meta': {'object_name': 'InstanceExists'},
            'audit_period_beginning': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'audit_period_ending': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'bandwidth_public_out': ('django.db.models.fields.BigIntegerField', [], {'default': '0'}),
            'delete': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceDeletes']"}),
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'fail_reason': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '300', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'message_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'send_status': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'pending'", 'max_length': '50', 'db_index': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'usage': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.InstanceUsage']"})
        },
        u'stacktach.instancereconcile': {
            'Meta': {'object_name': 'InstanceReconcile'},
            'deleted_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'row_created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'row_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.instanceusage': {
            'Meta': {'object_name': 'InstanceUsage'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'instance_flavor_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'instance_type_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'launched_at': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.jsonreport': {
            'Meta': {'object_name': 'JsonReport'},
            'created': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'period_end': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'period_start': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'version': ('django.db.models.fields.IntegerField', [], {'default': '1'})
        },
        u'stacktach.lifecycle': {
            'Meta': {'object_name': 'Lifecycle'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']", 'null': 'True'}),
            'last_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'last_task_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'})
        },
        u'stacktach.rawdata': {
            'Meta': {'object_name': 'RawData'},
            'deployment': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Deployment']"}),
            'event': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'host': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image_type': ('django.db.models.fields.IntegerField', [], {'default': '0', 'null': 'True', 'db_index': 'True'}),
            'instance': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'json': ('django.db.models.fields.TextField', [], {}),
            'old_state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'old_task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'publisher': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'request_id': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'routing_key': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'service': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '20', 'null': 'True', 'blank': 'True'}),
            'task': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '30', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '50', 'null': 'True', 'blank': 'True'}),
            'when': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.rawdataimagemeta': {
            'Meta': {'object_name': 'RawDataImageMeta'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'os_architecture': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_distro': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'os_version': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'raw': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.RawData']"}),
            'rax_options': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'})
        },
        u'stacktach.requesttracker': {
            'Meta': {'object_name': 'RequestTracker'},
            'completed': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'duration': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_timing': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Timing']", 'null': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'request_id': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start': ('django.db.models.fields.DecimalField', [], {'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'})
        },
        u'stacktach.tenantinfo': {
            'Meta': {'object_name': 'TenantInfo'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'tenant': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['stacktach.TenantType']", 'symmetrical': 'False'})
        },
        u'stacktach.tenanttype': {
            'Meta': {'object_name': 'TenantType'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'})
        },
        u'stacktach.timing': {
            'Meta': {'object_name': 'Timing'},
            'diff': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6', 'db_index': 'True'}),
            'end_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'end_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lifecycle': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['stacktach.Lifecycle']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50', 'db_index': 'True'}),
            'start_raw': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'+'", 'null': 'True', 'to': u"orm['stacktach.RawData']"}),
            'start_when': ('django.db.models.fields.DecimalField', [], {'null': 'True', 'max_digits': '20', 'decimal_places': '6'})
        }
    }

    complete_apps = ['stacktach']

########NEW FILE########
__FILENAME__ = models
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import copy

from django.db import models
from django.db.models import Q

from stacktach import datetime_to_decimal as dt


def routing_key_type(key):
    if key.endswith('error'):
        return 'E'
    return ' '


class Deployment(models.Model):
    name = models.CharField(max_length=50)

    def __repr__(self):
        return self.name


class GenericRawData(models.Model):
    result_titles = [["#", "?", "When", "Deployment", "Event", "Host",
                      "Instance", "Request id"]]
    deployment = models.ForeignKey(Deployment)
    tenant = models.CharField(max_length=50, null=True, blank=True,
                              db_index=True)
    json = models.TextField()
    routing_key = models.CharField(max_length=50, null=True,
                                   blank=True, db_index=True)
    when = models.DecimalField(max_digits=20, decimal_places=6,
                                               db_index=True)
    publisher = models.CharField(max_length=100, null=True,
                                 blank=True, db_index=True)
    event = models.CharField(max_length=50, null=True,
                                 blank=True, db_index=True)
    service = models.CharField(max_length=50, null=True,
                                 blank=True, db_index=True)
    host = models.CharField(max_length=100, null=True,
                                 blank=True, db_index=True)
    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    request_id = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    message_id = models.CharField(max_length=50, null=True,
                                  blank=True, db_index=True)

    @staticmethod
    def get_name():
        return GenericRawData.__name__

    @property
    def uuid(self):
        return self.instance

    def search_results(self, results, when, routing_key_status):
        if not results:
            results = copy.deepcopy(self.result_titles)
        results.append([self.id, routing_key_status, str(when),
                        self.deployment.name, self.event, self.host,
                        self.instance, self.request_id])
        return results


class RawData(models.Model):
    result_titles = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"]]
    deployment = models.ForeignKey(Deployment)
    tenant = models.CharField(max_length=50, null=True, blank=True,
                              db_index=True)
    json = models.TextField()
    routing_key = models.CharField(max_length=50, null=True,
                                   blank=True, db_index=True)
    state = models.CharField(max_length=20, null=True,
                             blank=True, db_index=True)
    old_state = models.CharField(max_length=20, null=True,
                             blank=True, db_index=True)
    old_task = models.CharField(max_length=30, null=True,
                             blank=True, db_index=True)
    task = models.CharField(max_length=30, null=True,
                             blank=True, db_index=True)
    image_type = models.IntegerField(null=True, default=0, db_index=True)
    when = models.DecimalField(max_digits=20, decimal_places=6,
                                               db_index=True)
    publisher = models.CharField(max_length=100, null=True,
                                 blank=True, db_index=True)
    event = models.CharField(max_length=50, null=True,
                                 blank=True, db_index=True)
    service = models.CharField(max_length=50, null=True,
                                 blank=True, db_index=True)
    host = models.CharField(max_length=100, null=True,
                                 blank=True, db_index=True)
    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    request_id = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)

    def __repr__(self):
        return "%s %s %s" % (self.event, self.instance, self.state)

    @property
    def uuid(self):
        return self.instance

    @staticmethod
    def get_name():
        return RawData.__name__

    def search_results(self, results, when, routing_key_status):
        if not results:
            results = copy.deepcopy(self.result_titles)
        results.append([self.id, routing_key_status, str(when),
                        self.deployment.name, self.event, self.host, self.state,
                        self.old_state, self.old_task])
        return results


class RawDataImageMeta(models.Model):
    raw = models.ForeignKey(RawData, null=False)
    os_architecture = models.TextField(null=True, blank=True)
    os_distro = models.TextField(null=True, blank=True)
    os_version = models.TextField(null=True, blank=True)
    rax_options = models.TextField(null=True, blank=True)


class Lifecycle(models.Model):
    """The Lifecycle table is the Master for a group of
    Timing detail records. There is one Lifecycle row for
    each instance seen in the event stream. The Timings
    relate to the execution time for each .start/.end event
    pair for this instance. These pairs are over the entire
    lifespan of the instance, even across multiple api requests."""
    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    last_state = models.CharField(max_length=50, null=True,
                             blank=True, db_index=True)
    last_task_state = models.CharField(max_length=50, null=True,
                             blank=True, db_index=True)
    last_raw = models.ForeignKey(RawData, null=True)


class InstanceUsage(models.Model):
    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    launched_at = models.DecimalField(null=True, max_digits=20,
                                      decimal_places=6, db_index=True)
    request_id =  models.CharField(max_length=50, null=True,
                                   blank=True, db_index=True)
    instance_type_id =  models.CharField(max_length=50,
                                         null=True,
                                         blank=True,
                                         db_index=True)
    instance_flavor_id = models.CharField(max_length=100, null=True,
                                          blank=True, db_index=True)
    tenant = models.CharField(max_length=50, null=True, blank=True,
                              db_index=True)
    os_architecture = models.TextField(null=True, blank=True)
    os_distro = models.TextField(null=True, blank=True)
    os_version = models.TextField(null=True, blank=True)
    rax_options = models.TextField(null=True, blank=True)

    def deployment(self):
        raws = RawData.objects.filter(request_id=self.request_id)
        return raws and raws[0].deployment

    def latest_deployment_for_request_id(self):
        raw = self.latest_raw_for_request_id()
        return raw and raw.deployment

    def latest_raw_for_request_id(self):
        return self.request_id and RawData.objects.filter(
            request_id=self.request_id).order_by('-id')[0]

    def host(self):
        raw = self.latest_raw_for_request_id()
        return raw and raw.host

    @staticmethod
    def find(instance, launched_at):
        start = launched_at - datetime.timedelta(
            microseconds=launched_at.microsecond)
        end = start + datetime.timedelta(microseconds=999999)
        params = {'instance': instance,
                  'launched_at__gte': dt.dt_to_decimal(start),
                  'launched_at__lte': dt.dt_to_decimal(end)}
        return InstanceUsage.objects.filter(**params)


class InstanceDeletes(models.Model):
    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    launched_at = models.DecimalField(null=True, max_digits=20,
                                      decimal_places=6, db_index=True)
    deleted_at = models.DecimalField(null=True, max_digits=20,
                                     decimal_places=6, db_index=True)
    raw = models.ForeignKey(RawData, null=True)

    def deployment(self):
        return self.raw.deployment

    @staticmethod
    def find(instance, launched, deleted_max=None):
        start = launched - datetime.timedelta(microseconds=launched.microsecond)
        end = start + datetime.timedelta(microseconds=999999)
        params = {'instance': instance,
                  'launched_at__gte': dt.dt_to_decimal(start),
                  'launched_at__lte': dt.dt_to_decimal(end)}
        if deleted_max:
            params['deleted_at__lte'] = dt.dt_to_decimal(deleted_max)
        return InstanceDeletes.objects.filter(**params)


class InstanceReconcile(models.Model):
    row_created = models.DateTimeField(auto_now_add=True)
    row_updated = models.DateTimeField(auto_now=True)
    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    launched_at = models.DecimalField(null=True, max_digits=20,
                                      decimal_places=6, db_index=True)
    deleted_at = models.DecimalField(null=True, max_digits=20,
                                     decimal_places=6, db_index=True)
    instance_type_id = models.CharField(max_length=50,
                                        null=True,
                                        blank=True,
                                        db_index=True)
    instance_flavor_id = models.CharField(max_length=100, null=True,
                                          blank=True, db_index=True)
    tenant = models.CharField(max_length=50, null=True, blank=True,
                              db_index=True)
    os_architecture = models.TextField(null=True, blank=True)
    os_distro = models.TextField(null=True, blank=True)
    os_version = models.TextField(null=True, blank=True)
    rax_options = models.TextField(null=True, blank=True)
    source = models.CharField(max_length=150, null=True,
                              blank=True, db_index=True)

    @staticmethod
    def find(instance, launched):
        start = launched - datetime.timedelta(microseconds=launched.microsecond)
        end = start + datetime.timedelta(microseconds=999999)
        params = {'instance': instance,
                  'launched_at__gte': dt.dt_to_decimal(start),
                  'launched_at__lte': dt.dt_to_decimal(end)}
        return InstanceReconcile.objects.filter(**params)


class InstanceExists(models.Model):
    PENDING = 'pending'
    VERIFYING = 'verifying'
    VERIFIED = 'verified'
    RECONCILED = 'reconciled'
    FAILED = 'failed'
    SENT_UNVERIFIED = 'sent_unverified'
    SENT_FAILED = 'sent_failed'
    SENT_VERIFYING = 'sent_verifying'
    STATUS_CHOICES = [
        (PENDING, 'Pending Verification'),
        (VERIFYING, 'Currently Being Verified'),
        (VERIFIED, 'Passed Verification'),
        (RECONCILED, 'Passed Verification After Reconciliation'),
        (FAILED, 'Failed Verification'),
        (SENT_UNVERIFIED, 'Unverified but sent by Yagi'),
        (SENT_FAILED, 'Failed Verification but sent by Yagi'),
        (SENT_VERIFYING, 'Currently being verified but sent by Yagi')
    ]

    instance = models.CharField(max_length=50, null=True,
                                blank=True, db_index=True)
    launched_at = models.DecimalField(null=True, max_digits=20,
                                      decimal_places=6, db_index=True)
    deleted_at = models.DecimalField(null=True, max_digits=20,
                                     decimal_places=6, db_index=True)
    audit_period_beginning = models.DecimalField(null=True, max_digits=20,
                                                 decimal_places=6,
                                                 db_index=True)
    audit_period_ending = models.DecimalField(null=True, max_digits=20,
                                              decimal_places=6, db_index=True)
    message_id = models.CharField(max_length=50, null=True,
                                  blank=True, db_index=True)
    instance_type_id = models.CharField(max_length=50,
                                        null=True,
                                        blank=True,
                                        db_index=True)
    status = models.CharField(max_length=50, db_index=True,
                              choices=STATUS_CHOICES,
                              default=PENDING)
    fail_reason = models.CharField(max_length=300, null=True,
                                   blank=True, db_index=True)
    raw = models.ForeignKey(RawData, related_name='+', null=True)
    usage = models.ForeignKey(InstanceUsage, related_name='+', null=True)
    delete = models.ForeignKey(InstanceDeletes, related_name='+', null=True)
    send_status = models.IntegerField(null=True, default=0, db_index=True)
    tenant = models.CharField(max_length=50, null=True, blank=True,
                              db_index=True)
    os_architecture = models.TextField(null=True, blank=True)
    os_distro = models.TextField(null=True, blank=True)
    os_version = models.TextField(null=True, blank=True)
    rax_options = models.TextField(null=True, blank=True)
    bandwidth_public_out = models.BigIntegerField(default=0)
    instance_flavor_id = models.CharField(max_length=100, null=True,
                                          blank=True, db_index=True)
    event_id = models.CharField(max_length=50, null=True,blank=True)

    def deployment(self):
        return self.raw.deployment

    @staticmethod
    def find(ending_max, status):
        params = {'audit_period_ending__lte': dt.dt_to_decimal(ending_max),
                  'status': status}
        return InstanceExists.objects.select_related()\
            .filter(**params).order_by('id')

    def mark_verified(self, reconciled=False, reason=None):
        if not reconciled:
            self.status = InstanceExists.VERIFIED
        else:
            self.status = InstanceExists.RECONCILED
            if reason is not None:
                self.fail_reason = reason

        self.save()

    def mark_failed(self, reason=None):
        if self.status == InstanceExists.SENT_VERIFYING:
            self.status = InstanceExists.SENT_FAILED
        else:
            self.status = InstanceExists.FAILED
        if reason:
            self.fail_reason = reason
        self.save()

    def update_status(self, new_status):
        self.status = new_status

    def is_image_type_import(self):
        return (self.raw.image_type & 0xf) == 3

    @staticmethod
    def mark_exists_as_sent_unverified(message_ids):
        absent_exists = []
        exists_not_pending = []
        for message_id in message_ids:
            try:
                exists = InstanceExists.objects.get(message_id=message_id)
                if exists.status == InstanceExists.PENDING:
                    exists.status = InstanceExists.SENT_UNVERIFIED
                    exists.send_status = '201'
                    exists.save()
                else:
                    exists_not_pending.append(message_id)
            except Exception:
                absent_exists.append(message_id)
        return absent_exists, exists_not_pending




class Timing(models.Model):
    """Each Timing record corresponds to a .start/.end event pair
    for an instance. It tracks how long it took this operation
    to execute."""
    name = models.CharField(max_length=50, db_index=True)
    lifecycle = models.ForeignKey(Lifecycle)
    start_raw = models.ForeignKey(RawData, related_name='+', null=True)
    end_raw = models.ForeignKey(RawData, related_name='+', null=True)

    start_when = models.DecimalField(null=True, max_digits=20,
                                     decimal_places=6)
    end_when = models.DecimalField(null=True, max_digits=20, decimal_places=6)

    diff = models.DecimalField(null=True, max_digits=20, decimal_places=6,
                               db_index=True)


class RequestTracker(models.Model):
    """The RequestTracker table tracks the elapsed time of a user
    request from the time it hits the API node to the time of the
    final .end event (with the same Request ID)."""
    request_id = models.CharField(max_length=50, db_index=True)
    lifecycle = models.ForeignKey(Lifecycle)
    last_timing = models.ForeignKey(Timing, null=True, db_index=True)
    start = models.DecimalField(max_digits=20, decimal_places=6, db_index=True)
    duration = models.DecimalField(max_digits=20, decimal_places=6,
                                   db_index=True)

    # Not used ... but soon hopefully.
    completed = models.BooleanField(default=False, db_index=True)


class JsonReport(models.Model):
    """Stores cron-job reports in raw json format for extraction
       via stacky/rest. All DateTimes are UTC."""
    period_start = models.DateTimeField(db_index=True)
    period_end = models.DateTimeField(db_index=True)
    created = models.DecimalField(max_digits=20, decimal_places=6, db_index=True)
    name = models.CharField(max_length=50, db_index=True)
    version = models.IntegerField(default=1)
    json = models.TextField()


class TenantType(models.Model):
    name = models.CharField(max_length=50, db_index=True)
    value = models.CharField(max_length=50, db_index=True)


class TenantInfo(models.Model):
    """This contains tenant information synced from an external source.
    It's mostly used as a cache to put things like tenant name on reports
    without making alot of calls to an external system."""
    tenant = models.CharField(max_length=50, db_index=True, unique=True)
    name = models.CharField(max_length=100, null=True,
                            blank=True, db_index=True)
    types = models.ManyToManyField(TenantType)
    last_updated = models.DateTimeField(db_index=True)


class GlanceRawData(models.Model):
    result_titles = [["#", "?", "When", "Deployment", "Event", "Host",
                          "Status"]]
    ACTIVE = 'active'
    DELETED = 'deleted'
    KILLED = 'killed'
    PENDING_DELETE = 'pending_delete'
    QUEUED = 'queued'
    SAVING = 'saving'
    STATUS_CHOICES = [
        (ACTIVE, 'Active'),
        (DELETED, 'Deleted'),
        (KILLED, 'Killed'),
        (PENDING_DELETE, 'Pending delete'),
        (QUEUED, 'Queued'),
        (SAVING, 'Saving'),
    ]

    deployment = models.ForeignKey(Deployment)
    owner = models.CharField(max_length=255, null=True, blank=True,
                             db_index=True)
    json = models.TextField()
    routing_key = models.CharField(max_length=50, null=True, blank=True,
                                   db_index=True)
    when = models.DecimalField(max_digits=20, decimal_places=6, db_index=True)
    publisher = models.CharField(max_length=100, null=True,
                                 blank=True, db_index=True)
    event = models.CharField(max_length=50, null=True, blank=True,
                             db_index=True)
    service = models.CharField(max_length=50, null=True, blank=True,
                               db_index=True)
    host = models.CharField(max_length=100, null=True, blank=True,
                            db_index=True)
    instance = models.CharField(max_length=50, null=True, blank=True,
                                db_index=True)
    request_id = models.CharField(max_length=50, null=True, blank=True,
                                  db_index=True)
    uuid = models.CharField(max_length=36, null=True, blank=True,
                            db_index=True)
    status = models.CharField(max_length=30, db_index=True,
                              choices=STATUS_CHOICES, null=True)
    image_type = models.IntegerField(null=True, default=0, db_index=True)

    @staticmethod
    def get_name():
        return GlanceRawData.__name__

    def search_results(self, results, when, routing_key_status):
        if not results:
            results = copy.deepcopy(self.result_titles)
        results.append([self.id, routing_key_status, str(when),
                            self.deployment.name, self.event, self.host,
                            self.status])
        return results


class ImageUsage(models.Model):
    uuid = models.CharField(max_length=50, db_index=True)
    created_at = models.DecimalField(max_digits=20,
                                     decimal_places=6, db_index=True)
    owner = models.CharField(max_length=50, db_index=True, null=True)
    size = models.BigIntegerField(max_length=20)
    last_raw = models.ForeignKey(GlanceRawData, null=True)


class ImageDeletes(models.Model):
    uuid = models.CharField(max_length=50, db_index=True)
    deleted_at = models.DecimalField(max_digits=20,
                                     decimal_places=6, db_index=True,
                                     null=True)
    raw = models.ForeignKey(GlanceRawData, null=True)

    @staticmethod
    def find(uuid, deleted_max=None):
        params = {'uuid': uuid}
        if deleted_max:
            params['deleted_at__lte'] = dt.dt_to_decimal(deleted_max)
        return ImageDeletes.objects.filter(**params)


class ImageExists(models.Model):
    PENDING = 'pending'
    VERIFYING = 'verifying'
    VERIFIED = 'verified'
    FAILED = 'failed'
    SENT_UNVERIFIED = 'sent_unverified'
    SENT_FAILED = 'sent_failed'
    SENT_VERIFYING = 'sent_verifying'
    STATUS_CHOICES = [
        (PENDING, 'Pending Verification'),
        (VERIFYING, 'Currently Being Verified'),
        (VERIFIED, 'Passed Verification'),
        (FAILED, 'Failed Verification'),
        (SENT_UNVERIFIED, 'Unverified but sent by Yagi'),
        (SENT_FAILED, 'Failed Verification but sent by Yagi'),
        (SENT_VERIFYING, 'Currently being verified but sent by Yagi')
    ]

    uuid = models.CharField(max_length=50, db_index=True, null=True)
    created_at = models.DecimalField(max_digits=20,
                                     decimal_places=6, db_index=True,
                                     null=True)
    deleted_at = models.DecimalField(max_digits=20,
                                     decimal_places=6, db_index=True,
                                     null=True)
    audit_period_beginning = models.DecimalField(max_digits=20,
                                                 decimal_places=6,
                                                 db_index=True)
    audit_period_ending = models.DecimalField(max_digits=20,
                                              decimal_places=6, db_index=True)
    status = models.CharField(max_length=50, db_index=True,
                              choices=STATUS_CHOICES,
                              default=PENDING)
    fail_reason = models.CharField(max_length=300, null=True)
    raw = models.ForeignKey(GlanceRawData, related_name='+')
    usage = models.ForeignKey(ImageUsage, related_name='+', null=True)
    delete = models.ForeignKey(ImageDeletes, related_name='+', null=True)
    send_status = models.IntegerField(default=0, db_index=True)
    owner = models.CharField(max_length=255, db_index=True, null=True)
    size = models.BigIntegerField(max_length=20)
    message_id = models.CharField(max_length=50, null=True,
                                  blank=True, db_index=True)
    event_id = models.CharField(max_length=50, null=True,blank=True)


    def update_status(self, new_status):
        self.status = new_status

    @staticmethod
    def find_and_group_by_owner_and_raw_id(ending_max, status):
        params = {'audit_period_ending__lte': dt.dt_to_decimal(ending_max),
                  'status': status}
        ordered_exists = ImageExists.objects.select_related().\
            filter(**params).order_by('owner')
        result = {}
        for exist in ordered_exists:
            key = "%s-%s" % (exist.owner, exist.raw_id)
            if key in result:
                result[key].append(exist)
            else:
                result[key] = [exist]
        return result

    def mark_verified(self):
        self.status = InstanceExists.VERIFIED
        self.save()

    def mark_failed(self, reason=None):
        if self.status == ImageExists.SENT_VERIFYING:
            self.status = ImageExists.SENT_FAILED
        else:
            self.status = ImageExists.FAILED
        if reason:
            self.fail_reason = reason
        self.save()

    @staticmethod
    def mark_exists_as_sent_unverified(message_ids):
        absent_exists = []
        exists_not_pending = []
        for message_id in message_ids:
            exists_list = ImageExists.objects.filter(message_id=message_id)
            if exists_list:
                for exists in exists_list:
                    if exists.status == ImageExists.PENDING:
                        exists.status = ImageExists.SENT_UNVERIFIED
                        exists.send_status = '201'
                        exists.save()
                    else:
                        exists_not_pending.append(message_id)
            else :
                absent_exists.append(message_id)
        return absent_exists, exists_not_pending



def get_model_fields(model):
    return model._meta.fields

########NEW FILE########
__FILENAME__ = notification
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from stacktach import utils
from stacktach import stacklog
from stacktach import image_type
from stacktach import db


class Notification(object):
    def __init__(self, body, deployment, routing_key, json):
        self.body = body
        self.request_id = body.get('_context_request_id', "")
        self.deployment = deployment
        self.routing_key = routing_key
        self.json = json
        self.payload = body.get('payload', {})
        self.publisher = self.body['publisher_id']
        self.event = self.body['event_type']


    @property
    def when(self):
        when = self.body.get('timestamp', None)
        if not when:
            when = self.body['_context_timestamp']  # Old way of doing it
        when = utils.str_time_to_unix(when)
        return when

    @property
    def service(self):
        parts = self.publisher.split('.')
        return parts[0]

    @property
    def host(self):
        host = None
        parts = self.publisher.split('.')
        if len(parts) > 1:
            host = ".".join(parts[1:])
        return host

    @property
    def tenant(self):
        tenant = self.body.get('_context_project_id', None)
        tenant = self.payload.get('tenant_id', tenant)
        return tenant

    @property
    def instance(self):
        # instance UUID's seem to hide in a lot of odd places.
        instance = self.payload.get('instance_id', None)
        instance = self.payload.get('instance_uuid', instance)
        if not instance:
            instance = self.payload.get('exception', {}).get('kwargs', {}).get('uuid')
        if not instance:
            instance = self.payload.get('instance', {}).get('uuid')
        return instance

    @property
    def message_id(self):
        return self.body.get('message_id', None)

    def save(self):
        return db.create_generic_rawdata(deployment=self.deployment,
                                         routing_key=self.routing_key,
                                         tenant=self.tenant,
                                         json=self.json,
                                         when=self.when,
                                         publisher=self.publisher,
                                         event=self.event,
                                         service=self.service,
                                         host=self.host,
                                         instance=self.instance,
                                         request_id=self.request_id,
                                         message_id=self.message_id)


class GlanceNotification(Notification):
    def __init__(self, body, deployment, routing_key, json):
        super(GlanceNotification, self).__init__(body, deployment,
                                                 routing_key, json)
        if isinstance(self.payload, dict):
            self.properties = self.payload.get('properties', {})
            self.image_type = image_type.get_numeric_code(self.payload)
            self.status = self.payload.get('status', None)
            self.uuid = self.payload.get('id', None)
            self.size = self.payload.get('size', None)
            created_at = self.payload.get('created_at', None)
            self.created_at = created_at and utils.str_time_to_unix(created_at)
        else:
            self.properties = {}
            self.image_type = None
            self.status = None
            self.uuid = None
            self.size = None
            self.created_at = None

    @property
    def owner(self):
        if isinstance(self.payload, dict):
            return self.payload.get('owner', None)
        else:
            return None

    @property
    def instance(self):
        return self.properties.get('instance_uuid', None)

    @property
    def deleted_at(self):
        deleted_at = self.body.get('deleted_at', None)

        if isinstance(self.payload, dict):
            deleted_at = deleted_at or self.payload.get('deleted_at', None)

        return deleted_at and utils.str_time_to_unix(deleted_at)

    def save(self):
        return db.create_glance_rawdata(deployment=self.deployment,
                                        routing_key=self.routing_key,
                                        owner=self.owner,
                                        json=self.json,
                                        when=self.when,
                                        publisher=self.publisher,
                                        event=self.event,
                                        service=self.service,
                                        host=self.host,
                                        instance=self.instance,
                                        request_id=self.request_id,
                                        image_type=self.image_type,
                                        status=self.status,
                                        uuid=self.uuid)

    def save_exists(self, raw):
        if isinstance(self.payload, dict):
            audit_period_beginning = self.payload.get(
                'audit_period_beginning', None)
            audit_period_beginning = audit_period_beginning and\
                utils.str_time_to_unix(audit_period_beginning)
            audit_period_ending = self.payload.get(
                'audit_period_ending', None)
            audit_period_ending = audit_period_ending and \
                utils.str_time_to_unix(audit_period_ending)
            message_id = self.message_id
            images = self.payload.get('images', [])
        else:
            stacklog.warn("Received exists with invalid payload "
                          "GlanceRawData(%s)" % raw.id)
            audit_period_beginning = None
            audit_period_ending = None
            images = []

        for image in images:
            created_at = image['created_at']
            created_at = created_at and utils.str_time_to_unix(created_at)
            uuid = image['id']
            deleted_at = image['deleted_at']
            deleted_at = deleted_at and utils.str_time_to_unix(deleted_at)

            if created_at:
                values = {
                    'uuid': uuid,
                    'audit_period_beginning': audit_period_beginning,
                    'audit_period_ending': audit_period_ending,
                    'owner': self.owner,
                    'size': image['size'],
                    'raw': raw,
                    'message_id': message_id
                }
                usage = db.get_image_usage(uuid=uuid)
                values['usage'] = usage
                values['created_at'] = created_at
                if deleted_at:
                    delete = db.get_image_delete(uuid=uuid)
                    values['delete'] = delete
                    values['deleted_at'] = deleted_at

                db.create_image_exists(**values)
            else:
                stacklog.warn("Ignoring exists without created_at. GlanceRawData(%s)"
                              % raw.id)

    def save_usage(self, raw):
        values = {
            'uuid': self.uuid,
            'created_at': self.created_at,
            'owner': self.owner,
            'size': self.size,
            'last_raw': raw
        }
        db.create_image_usage(**values)

    def save_delete(self, raw):
        values = {
            'uuid': self.uuid,
            'raw': raw,
            'deleted_at': self.deleted_at
        }
        db.create_image_delete(**values)


class NovaNotification(Notification):
    def __init__(self, body, deployment, routing_key, json):
        super(NovaNotification, self).__init__(body, deployment, routing_key,
                                               json)
        self.state = self.payload.get('state', '')
        self.old_state = self.payload.get('old_state', '')
        self.old_task = self.payload.get('old_task_state', '')
        self.task = self.payload.get('new_task_state', '')
        self.image_type = image_type.get_numeric_code(self.payload)
        image_meta = self.payload.get('image_meta', {})
        self.os_architecture = \
            image_meta.get('org.openstack__1__architecture', '')
        self.os_distro = image_meta.get('org.openstack__1__os_distro', '')
        self.os_version = image_meta.get('org.openstack__1__os_version', '')
        self.rax_options = image_meta.get('com.rackspace__1__options', '')
        self.instance_type_id = self.payload.get('instance_type_id', None)
        self.instance_flavor_id = self.payload.get('instance_flavor_id', None)
        self.new_instance_type_id = \
            self.payload.get('new_instance_type_id', None)
        self.launched_at = self.payload.get('launched_at', None)
        self.deleted_at = self.payload.get('deleted_at', None)
        self.terminated_at = self.payload.get('terminated_at', None)
        self.audit_period_beginning = self.payload.get(
            'audit_period_beginning', None)
        self.audit_period_ending = self.payload.get(
            'audit_period_ending', None)
        self.message = self.payload.get('message', None)
        # (TMaddox) bandwidth could be None in the payload.
        bandwidth = self.payload.get('bandwidth', {}) or {}
        bandwidth_public = bandwidth.get('public', {})
        self.bandwidth_public_out = bandwidth_public.get('bw_out', 0)

    @property
    def host(self):
        host = None
        parts = self.publisher.split('.')
        if len(parts) > 1:
            host = ".".join(parts[1:])
        return host

    @property
    def service(self):
        parts = self.publisher.split('.')
        return parts[0]

    def save(self):
        return db.create_nova_rawdata(deployment=self.deployment,
                                      routing_key=self.routing_key,
                                      tenant=self.tenant,
                                      json=self.json,
                                      when=self.when,
                                      publisher=self.publisher,
                                      event=self.event,
                                      service=self.service,
                                      host=self.host,
                                      instance=self.instance,
                                      request_id=self.request_id,
                                      image_type=self.image_type,
                                      state=self.state,
                                      old_state=self.old_state,
                                      task=self.task,
                                      old_task=self.old_task,
                                      os_architecture=self.os_architecture,
                                      os_distro=self.os_distro,
                                      os_version=self.os_version,
                                      rax_options=self.rax_options)


def notification_factory(body, deployment, routing_key, json, exchange):
    if exchange == 'nova':
        return NovaNotification(body, deployment, routing_key, json)
    if exchange == "glance":
        return GlanceNotification(body, deployment, routing_key, json)
    return Notification(body, deployment, routing_key, json)

########NEW FILE########
__FILENAME__ = exceptions
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

class NotFound(Exception):
    def __init__(self, message="NotFound"):
        self.message = message

########NEW FILE########
__FILENAME__ = nova
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import requests

from stacktach import utils as stackutils
from stacktach.reconciler import exceptions
from stacktach.reconciler.utils import empty_reconciler_instance

GET_INSTANCE_QUERY = \
    "SELECT i.*, it.flavorid FROM instances i INNER JOIN " \
    "instance_types it on i.instance_type_id = it.id where i.uuid ='%s';"

METADATA_MAPPING = {
    'image_org.openstack__1__architecture': 'os_architecture',
    'image_org.openstack__1__os_distro': 'os_distro',
    'image_org.openstack__1__os_version': 'os_version',
    'image_com.rackspace__1__options': 'rax_options',
}
METADATA_FIELDS = ["'%s'" % x for x in METADATA_MAPPING.keys()]
METADATA_FIELDS = ','.join(METADATA_FIELDS)

GET_INSTANCE_SYSTEM_METADATA = """
SELECT * FROM instance_system_metadata
    WHERE instance_uuid = '%s' AND
    deleted = 0 AND `key` IN (%s);
"""
GET_INSTANCE_SYSTEM_METADATA %= ('%s', METADATA_FIELDS)


def _json(result):
    if callable(result.json):
        return result.json()
    else:
        return result.json


class JSONBridgeClient(object):
    src_str = 'json_bridge:nova_db'

    def __init__(self, config):
        self.config = config

    def _url_for_region(self, region):
        return self.config['url'] + self.config['databases'][region]

    def _do_query(self, region, query):
        data = {'sql': query}
        credentials = (self.config['username'], self.config['password'])
        return _json(requests.post(self._url_for_region(region), data,
                                   verify=False, auth=credentials))

    def _to_reconciler_instance(self, instance, metadata=None):
        r_instance = empty_reconciler_instance()
        r_instance.update({
            'id': instance['uuid'],
            'tenant': instance['project_id'],
            'instance_type_id': str(instance['instance_type_id']),
            'instance_flavor_id': str(instance['flavorid']),
        })

        if instance['launched_at'] is not None:
            launched_at = stackutils.str_time_to_unix(instance['launched_at'])
            r_instance['launched_at'] = launched_at

        if instance['terminated_at'] is not None:
            deleted_at = stackutils.str_time_to_unix(instance['terminated_at'])
            r_instance['deleted_at'] = deleted_at

        if instance['deleted'] != 0:
            r_instance['deleted'] = True

        if metadata is not None:
            r_instance.update(metadata)

        return r_instance

    def _get_instance_meta(self, region, uuid):
        results = self._do_query(region, GET_INSTANCE_SYSTEM_METADATA % uuid)
        metadata = {}
        for result in results['result']:
            key = result['key']
            if key in METADATA_MAPPING:
                metadata[METADATA_MAPPING[key]] = result['value']
        return metadata

    def get_instance(self, region, uuid, get_metadata=False):
        results = self._do_query(region, GET_INSTANCE_QUERY % uuid)['result']
        if len(results) > 0:
            metadata = None
            if get_metadata:
                metadata = self._get_instance_meta(region, uuid)
            return self._to_reconciler_instance(results[0], metadata=metadata)
        else:
            msg = "Couldn't find instance (%s) using JSON Bridge in region (%s)"
            raise exceptions.NotFound(msg % (uuid, region))

########NEW FILE########
__FILENAME__ = utils
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
def empty_reconciler_instance():
    r_instance = {
        'id': None,
        'tenant': None,
        'launched_at': None,
        'deleted': False,
        'deleted_at': None,
        'instance_type_id': None,
        'instance_flavor_id': None,
        'os_architecture': '',
        'os_distro': '',
        'os_version': '',
        'rax_options': '',
    }
    return r_instance

########NEW FILE########
__FILENAME__ = stacklog
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import logging
import logging.handlers
import multiprocessing
import os
import re
import threading
import traceback
import sys
import time

LOGGERS = {}
LOGGER_QUEUE_MAP = {}
default_logger_location = '/var/log/stacktach/%s.log'
default_logger_name = 'stacktach-default'


def set_default_logger_location(loc):
    global default_logger_location
    default_logger_location = loc


def set_default_logger_name(name):
    global default_logger_name
    default_logger_name = name


class ParentLoggerDoesNotExist(Exception):
    def __init__(self, parent_logger_name):
        self.reason = "Cannot create child logger as parent logger with the" \
                      "name %s does not exist." % parent_logger_name


def _create_parent_logger(parent_logger_name):
    if parent_logger_name not in LOGGERS:
        logger = _create_timed_rotating_logger(parent_logger_name)
        LOGGERS[parent_logger_name] = logger
        LOGGER_QUEUE_MAP[parent_logger_name] = multiprocessing.Queue(-1)

    return LOGGERS[parent_logger_name]


def _create_child_logger(parent_logger_name):
    child_logger_name = "child_%s" % parent_logger_name
    if child_logger_name in LOGGERS:
        return LOGGERS[child_logger_name]
    if parent_logger_name in LOGGERS:
        queue = LOGGER_QUEUE_MAP[parent_logger_name]
        logger = _create_queue_logger(child_logger_name, queue)
        LOGGERS[child_logger_name] = logger
    else:
        raise ParentLoggerDoesNotExist(parent_logger_name)

    return LOGGERS[child_logger_name]


def _logger_factory(parent_logger_name, is_parent):
    if parent_logger_name is None:
        parent_logger_name = default_logger_name
    if is_parent:
        return _create_parent_logger(parent_logger_name)
    else:
        return _create_child_logger(parent_logger_name)


def get_logger(name=None, is_parent=True):
    return _logger_factory(name, is_parent)


def warn(msg, name=None):
    if name is None:
        name = default_logger_name
    get_logger(name=name, is_parent=False).warn(msg)


def error(msg, name=None):
    if name is None:
        name = default_logger_name
    get_logger(name=name, is_parent=False).error(msg)


def info(msg, name=None):
    if name is None:
        name = default_logger_name
    get_logger(name=name, is_parent=False).info(msg)


def _create_timed_rotating_logger(name):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = TimedRotatingFileHandlerWithCurrentTimestamp(
        default_logger_location % name, when='midnight', interval=1,
        backupCount=6)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.handlers[0].doRollover()
    return logger


def _create_queue_logger(name, queue):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = QueueHandler(queue)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    return logger


class QueueHandler(logging.Handler):
    def __init__(self, queue):
        logging.Handler.__init__(self)
        self.queue = queue

    def emit(self, record):
        try:
            # ensure that exc_info and args
            # have been stringified.  Removes any chance of
            # unpickleable things inside and possibly reduces
            # message size sent over the pipe
            if record.exc_info:
                # just to get traceback text into record.exc_text
                self.format(record)
                # remove exception info as it's not needed any more
                record.exc_info = None
            if record.args:
                record.msg = record.msg % record.args
                record.args = None
            self.queue.put_nowait(record)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)


class LogListener:
    def __init__(self, logger):
        self.logger = logger
        self.queue = get_queue(logger.name)

    def start(self):
        self.thread = threading.Thread(target=self._receive)
        self.thread.daemon = True
        self.thread.start()

    def _receive(self):
        while True:
            try:
                record = self.queue.get()
                # None is sent as a sentinel to tell the listener to quit
                if record is None:
                    break
                self.logger.handle(record)
            except (KeyboardInterrupt, SystemExit):
                raise
            except EOFError:
                break
            except:
                traceback.print_exc(file=sys.stderr)

    def end(self):
        self.queue.put_nowait(None)
        self.thread.join()
        for handler in self.logger.handlers:
            handler.close()


def get_queue(logger_name):
    return LOGGER_QUEUE_MAP[logger_name]


class TimedRotatingFileHandlerWithCurrentTimestamp(
        logging.handlers.TimedRotatingFileHandler):

    def __init__(self, filename, when='h', interval=1, backupCount=0,
                 encoding=None, delay=False, utc=False):
        logging.handlers.TimedRotatingFileHandler.__init__(
            self, filename, when, interval, backupCount, encoding, delay, utc)
        self.suffix = "%Y-%m-%d_%H-%M-%S"
        self.extMatch = re.compile(r"^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$")

    def doRollover(self):
        """Exactly the same as TimedRotatingFileHandler's doRollover() except
        that the current date/time stamp is appended to the filename rather
        than the start date/time stamp, when the rollover happens."""
        currentTime = int(time.time())
        if self.stream:
            self.stream.close()
            self.stream = None
        if self.utc:
            timeTuple = time.gmtime(currentTime)
        else:
            timeTuple = time.localtime(currentTime)
        dfn = self.baseFilename + "." + time.strftime(self.suffix, timeTuple)
        if os.path.exists(dfn):
            os.remove(dfn)
        os.rename(self.baseFilename, dfn)
        if self.backupCount > 0:
            # find the oldest log file and delete it
            #s = glob.glob(self.baseFilename + ".20*")
            #if len(s) > self.backupCount:
            #    s.sort()
            #    os.remove(s[0])
            for s in self.getFilesToDelete():
                os.remove(s)
        #print "%s -> %s" % (self.baseFilename, dfn)
        self.mode = 'w'
        self.stream = self._open()
        newRolloverAt = self.computeRollover(currentTime)
        while newRolloverAt <= currentTime:
            newRolloverAt = newRolloverAt + self.interval
        #If DST changes and midnight or weekly rollover, adjust for this.
        if (self.when == 'MIDNIGHT' or self.when.startswith('W')) and not self.utc:
            dstNow = time.localtime(currentTime)[-1]
            dstAtRollover = time.localtime(newRolloverAt)[-1]
            if dstNow != dstAtRollover:
                if not dstNow:  # DST kicks in before next rollover, so we need to deduct an hour
                    newRolloverAt = newRolloverAt - 3600
                else:           # DST bows out before next rollover, so we need to add an hour
                    newRolloverAt = newRolloverAt + 3600
        self.rolloverAt = newRolloverAt

########NEW FILE########
__FILENAME__ = stacky_server
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from copy import deepcopy
import decimal
import datetime
import json

from django.db.models import Q
from django.http import HttpResponse
from django.shortcuts import get_object_or_404

import datetime_to_decimal as dt
import models
import utils
from django.core.exceptions import ObjectDoesNotExist, FieldError, ValidationError

SECS_PER_HOUR = 60 * 60
SECS_PER_DAY = SECS_PER_HOUR * 24

DEFAULT_LIMIT = 50
HARD_LIMIT = 1000

UTC_FORMAT = '%Y-%m-%d %H:%M:%S'


def _get_limit(request):
    limit = request.GET.get('limit', DEFAULT_LIMIT)
    if limit:
        limit = int(limit)
    if limit > HARD_LIMIT:
        limit = HARD_LIMIT
    return limit


def _get_query_range(request):
    limit = _get_limit(request)
    offset = request.GET.get('offset')

    start = None
    if offset:
        start = int(offset)
    else:
        offset = 0

    end = int(offset) + int(limit)
    return start, end


def model_search(request, model, filters,
                 related=False, order_by=None, excludes=None):

    query = model

    if related:
        query = query.select_related()

    if filters:
        query = query.filter(**filters)
    else:
        query = query.all()

    if excludes:
        for exclude in excludes:
            if isinstance(exclude, dict):
                query = query.exclude(**exclude)
            else:
                query = query.exclude(exclude)

    if order_by:
        query = query.order_by(order_by)

    start, end = _get_query_range(request)
    query = query[start:end]
    return query


def _add_when_filters(request, filters):
    when_max = request.GET.get('when_max')
    if when_max:
        filters['when__lte'] = decimal.Decimal(when_max)

    when_min = request.GET.get('when_min')
    if when_min:
        filters['when__gte'] = decimal.Decimal(when_min)


def get_event_names(service='nova'):
    return _model_factory(service).values('event').distinct()


def get_all_event_names():
    services = ['nova', 'glance', 'generic']
    events = []
    for service in services:
        events.extend(get_event_names(service))
    return events

def get_host_names(service):
    # TODO: We need to upgrade to Django 1.4 so we can get tenent id and
    # host and just do distinct on host name.
    # like: values('host', 'tenant_id').distinct('host')
    # This will be more meaningful. Host by itself isn't really.
    return _model_factory(service).values('host').distinct()


def routing_key_type(key):
    if key.endswith('error'):
        return 'E'
    return ' '


def get_deployments():
    return models.Deployment.objects.all().order_by('name')


def get_timings_for_uuid(request, uuid):
    model = models.Lifecycle.objects
    filters = {'instance': uuid}
    lifecycles = model_search(request, model, filters)

    results = [["?", "Event", "Time (secs)"]]
    for lc in lifecycles:
        timings = models.Timing.objects.filter(lifecycle=lc)
        if not timings:
            continue
        for t in timings:
            state = "?"
            show_time = 'n/a'
            if t.start_raw:
                state = 'S'
            if t.end_raw:
                state = 'E'
            if t.start_raw and t.end_raw:
                state = "."
                show_time = sec_to_time(t.diff)
            results.append([state, t.name, show_time])
    return results


def sec_to_time(diff):
    seconds = int(diff)
    usec = diff - seconds
    days = seconds / SECS_PER_DAY
    seconds -= (days * SECS_PER_DAY)
    hours = seconds / SECS_PER_HOUR
    seconds -= (hours * SECS_PER_HOUR)
    minutes = seconds / 60
    seconds -= (minutes * 60)
    usec = str(usec)[1:4]
    return "%dd %02d:%02d:%02d%s" % (days, hours, minutes, seconds, usec)


def rsp(data, status=200, content_type="application/json"):
    return HttpResponse(data, content_type=content_type, status=status)


def error_response(status, type, message):
    results = [["Error", "Message"], [type, message]]
    return rsp(json.dumps(results), status)


def do_deployments(request):
    deployments = get_deployments()
    results = [["#", "Name"]]
    for deployment in deployments:
        results.append([deployment.id, deployment.name])
    return rsp(json.dumps(results))


def do_events(request):
    service = str(request.GET.get('service', 'all'))
    if service == 'all':
        events = get_all_event_names()
    else:
        events = get_event_names(service=service)
    results = [["Event Name"]]
    for event in events:
        results.append([event['event']])
    return rsp(json.dumps(results))


def do_hosts(request):
    service = str(request.GET.get('service', 'nova'))
    hosts = get_host_names(service)
    results = [["Host Name"]]
    for host in hosts:
        results.append([host['host']])
    return rsp(json.dumps(results))


def do_uuid(request):
    uuid = str(request.GET['uuid'])
    service = str(request.GET.get('service', 'nova'))
    if not utils.is_uuid_like(uuid):
        msg = "%s is not uuid-like" % uuid
        return error_response(400, 'Bad Request', msg)
    model = _model_factory(service)
    result = []
    filters = {}

    if service == 'nova' or service == 'generic':
        filters = {'instance': uuid}
    if service == 'glance':
        filters = {'uuid': uuid}

    _add_when_filters(request, filters)

    related = model_search(request, model, filters,
                           related=True, order_by='when')
    for event in related:
        when = dt.dt_from_decimal(event.when)
        routing_key_status = routing_key_type(event.routing_key)
        result = event.search_results(result, when, routing_key_status)
    return rsp(json.dumps(result))


def do_timings_uuid(request):
    uuid = request.GET['uuid']
    if not utils.is_uuid_like(uuid):
        msg = "%s is not uuid-like" % uuid
        return error_response(400, 'Bad Request', msg)
    results = get_timings_for_uuid(request, uuid)
    return rsp(json.dumps(results))


def do_timings(request):
    name = request.GET['name']
    model = models.Timing.objects

    filters = {
        'name': name
    }

    if request.GET.get('end_when_min') is not None:
        min_when = decimal.Decimal(request.GET['end_when_min'])
        filters['end_when__gte'] = min_when

    if request.GET.get('end_when_max') is not None:
        max_when = decimal.Decimal(request.GET['end_when_max'])
        filters['end_when__lte'] = max_when

    excludes = [Q(start_raw=None) | Q(end_raw=None), ]
    timings = model_search(request, model, filters,
                           excludes=excludes, related=True,
                           order_by='diff')

    results = [[name, "Time"]]
    for t in timings:
        results.append([t.lifecycle.instance, sec_to_time(t.diff)])
    return rsp(json.dumps(results))


def do_summary(request):
    events = get_event_names()
    interesting = []
    for e in events:
        ev = e['event']
        if ev.endswith('.start'):
            interesting.append(ev[:-len('.start')])

    results = [["Event", "N", "Min", "Max", "Avg"]]

    for name in interesting:
        model = models.Timing.objects
        filters = {'name': name}
        excludes = [
            Q(start_raw=None) | Q(end_raw=None),
            {'diff__lt': 0}
        ]
        timings = model_search(request, model, filters,
                               excludes=excludes)
        if not timings:
            continue

        total, _min, _max = 0.0, None, None
        num = len(timings)
        for t in timings:
            seconds = float(t.diff)
            total += seconds
            if _min is None:
                _min = seconds
            if _max is None:
                _max = seconds
            _min = min(_min, seconds)
            _max = max(_max, seconds)

        results.append([name, int(num), sec_to_time(_min),
                        sec_to_time(_max), sec_to_time(int(total / num))])
    return rsp(json.dumps(results))


def do_request(request):
    request_id = request.GET['request_id']
    if not utils.is_request_id_like(request_id):
        msg = "%s is not request-id-like" % request_id
        return error_response(400, 'Bad Request', msg)

    model = models.RawData.objects
    filters = {'request_id': request_id}
    _add_when_filters(request, filters)
    events = model_search(request, model, filters, order_by='when')
    results = [["#", "?", "When", "Deployment", "Event", "Host",
                "State", "State'", "Task'"]]
    for e in events:
        when = dt.dt_from_decimal(e.when)
        results.append([e.id, routing_key_type(e.routing_key), str(when),
                        e.deployment.name, e.event, e.host, e.state,
                        e.old_state, e.old_task])
    return rsp(json.dumps(results))


def append_nova_raw_attributes(event, results):
    results.append(["Key", "Value"])
    results.append(["#", event.id])
    when = dt.dt_from_decimal(event.when)
    results.append(["When", str(when)])
    results.append(["Deployment", event.deployment.name])
    results.append(["Category", event.routing_key])
    results.append(["Publisher", event.publisher])
    results.append(["State", event.state])
    results.append(["Event", event.event])
    results.append(["Service", event.service])
    results.append(["Host", event.host])
    results.append(["UUID", event.instance])
    results.append(["Req ID", event.request_id])
    return results


def append_glance_raw_attributes(event, results):
    results.append(["Key", "Value"])
    results.append(["#", event.id])
    when = dt.dt_from_decimal(event.when)
    results.append(["When", str(when)])
    results.append(["Deployment", event.deployment.name])
    results.append(["Category", event.routing_key])
    results.append(["Publisher", event.publisher])
    results.append(["Status", event.status])
    results.append(["Event", event.event])
    results.append(["Service", event.service])
    results.append(["Host", event.host])
    results.append(["UUID", event.uuid])
    results.append(["Req ID", event.request_id])
    return results


def append_generic_raw_attributes(event, results):
    results.append(["Key", "Value"])
    results.append(["#", event.id])
    when = dt.dt_from_decimal(event.when)
    results.append(["When", str(when)])
    results.append(["Deployment", event.deployment.name])
    results.append(["Category", event.routing_key])
    results.append(["Publisher", event.publisher])
    results.append(["State", event.state])
    results.append(["Event", event.event])
    results.append(["Service", event.service])
    results.append(["Host", event.host])
    results.append(["UUID", event.instance])
    results.append(["Req ID", event.request_id])
    return results


def _append_raw_attributes(event, results, service):
    if service == 'nova':
        return append_nova_raw_attributes(event, results)
    if service == 'glance':
        return append_glance_raw_attributes(event, results)
    if service == 'generic':
        return append_generic_raw_attributes(event, results)


def do_show(request, event_id):
    service = str(request.GET.get('service', 'nova'))
    event_id = int(event_id)

    results = []
    model = _model_factory(service)
    try:
        event = model.get(id=event_id)
        results = _append_raw_attributes(event, results, service)
        final = [results, ]
        j = json.loads(event.json)
        final.append(json.dumps(j, indent=2))
        final.append(event.uuid)
        return rsp(json.dumps(final))
    except ObjectDoesNotExist:
        return rsp({})


def _model_factory(service):
    if service == 'glance':
        return models.GlanceRawData.objects
    elif service == 'nova':
        return models.RawData.objects
    elif service == 'generic':
        return models.GenericRawData.objects


def do_watch(request, deployment_id):
    service = str(request.GET.get('service', 'nova'))

    model = _model_factory(service)
    deployment_id = int(deployment_id)
    since = request.GET.get('since')
    event_name = request.GET.get('event_name')

    deployment_map = {}
    for d in get_deployments():
        deployment_map[d.id] = d
    events = get_event_names()
    max_event_width = max([len(event['event']) for event in events])

    base_events = model.order_by('when')
    if deployment_id > 0:
        base_events = base_events.filter(deployment=deployment_id)

    if event_name:
        base_events = base_events.filter(event=event_name)

    # Ok, this may seem a little wonky, but I'm clamping the
    # query time to the closest second. The implication is we
    # may not return the absolute latest data (which will have
    # to wait for the next query). The upside of doing this
    # is we can effectively cache the responses. So, with a
    # caching proxy server we can service a lot more clients
    # without having to worry about microsecond differences
    # causing cache misses.

    now = datetime.datetime.utcnow()
    now = now.replace(microsecond=0)  # clamp it down.
    dec_now = dt.dt_to_decimal(now)
    if since:
        since = decimal.Decimal(since)
    else:
        since = now - datetime.timedelta(seconds=2)
        since = dt.dt_to_decimal(since)
    base_events = base_events.filter(when__gt=since)
    events = base_events.filter(when__lte=dec_now)

    c = [10, 1, 15, 20, max_event_width, 36]

    results = []

    for raw in events:
        uuid = raw.uuid
        if not uuid:
            uuid = "-"
        typ = routing_key_type(raw.routing_key)
        when = dt.dt_from_decimal(raw.when)
        results.append([raw.id, typ,
                       str(when.date()), str(when.time()),
                       deployment_map[raw.deployment.id].name,
                       raw.event,
                       uuid])
    results_json = json.dumps([c, results, str(dec_now)])

    return rsp(results_json)


def do_kpi(request, tenant_id=None):
    if tenant_id:
        if models.RawData.objects.filter(tenant=tenant_id).count() == 0:
            message = "Could not find raws for tenant %s" % tenant_id
            return error_response(404, 'Not Found', message)

    yesterday = datetime.datetime.utcnow() - datetime.timedelta(days=1)
    yesterday = dt.dt_to_decimal(yesterday)
    trackers = models.RequestTracker.objects.select_related()\
                                    .exclude(last_timing=None)\
                                    .exclude(start__lt=yesterday)\
                                    .order_by('duration')

    results = [["Event", "Time", "UUID", "Deployment"]]
    for track in trackers:
        end_event = track.last_timing.end_raw
        event = end_event.event[:-len(".end")]
        uuid = track.lifecycle.instance
        if tenant_id is None or (tenant_id == end_event.tenant):
            results.append([event, sec_to_time(track.duration),
                            uuid, end_event.deployment.name])
    return rsp(json.dumps(results))


def do_jsonreports(request):
    yesterday = datetime.datetime.utcnow() - datetime.timedelta(days=1)
    now = datetime.datetime.utcnow()
    yesterday = dt.dt_to_decimal(yesterday)
    now = dt.dt_to_decimal(now)
    _from = request.GET.get('created_from', yesterday)
    _to = request.GET.get('created_to', now)
    model = models.JsonReport.objects
    filters = {
        'created__gte': _from,
        'created__lte': _to
    }
    reports = model_search(request, model, filters)
    results = [['Id', 'Start', 'End', 'Created', 'Name', 'Version']]
    for report in reports:
        results.append([report.id,
                        float(dt.dt_to_decimal(report.period_start)),
                        float(dt.dt_to_decimal(report.period_end)),
                        float(report.created),
                        report.name,
                        report.version])
    return rsp(json.dumps(results))


def do_jsonreport(request, report_id):
    report_id = int(report_id)
    report = get_object_or_404(models.JsonReport, pk=report_id)
    return rsp(report.json)


def search(request):
    service = str(request.GET.get('service', 'nova'))
    field = request.GET.get('field')
    value = request.GET.get('value')
    model = _model_factory(service)
    filters = {field: value}
    _add_when_filters(request, filters)
    results = []
    try:

        events = model_search(request, model, filters, order_by='-when')
        for event in events:
            when = dt.dt_from_decimal(event.when)
            routing_key_status = routing_key_type(event.routing_key)
            results = event.search_results(results, when, routing_key_status)
        return rsp(json.dumps(results))
    except ObjectDoesNotExist:
        return error_response(404, 'Not Found', ["The requested object does not exist"])
    except FieldError:
        return error_response(400, 'Bad Request', "The requested field '%s' does not exist for the corresponding object.\n"
                    "Note: The field names of database are case-sensitive." % field)


class BadRequestException(Exception):
    pass


def _parse_created(created):
    try:
        created_datetime = datetime.datetime.strptime(created, '%Y-%m-%d')
        return dt.dt_to_decimal(created_datetime)
    except ValueError:
        raise BadRequestException(
            "'%s' value has an invalid format. It must be in YYYY-MM-DD format."
            % created)


def _parse_id(id):
    try:
        return int(id)
    except ValueError:
        raise BadRequestException(
            "'%s' value has an invalid format. It must be in integer "
            "format." % id)


def _parse_fields_and_create_query_filters(request_filters):
    query_filters = {}

    for field, value in request_filters.iteritems():
        if field == 'created':
            decimal_created = _parse_created(value)
            query_filters['created__gt'] = decimal_created
            query_filters['created__lt'] = decimal_created + SECS_PER_DAY
        elif field == 'id':
            id = _parse_id(value)
            query_filters['id__exact'] = id
        else:
            query_filters[field + '__exact'] = value

    return query_filters


def _check_if_fields_searchable(request_filters):
    allowed_fields = ['id', 'name', 'created', 'period_start', 'period_end']
    invalid_fields = [field for field in request_filters.keys()
                      if field not in allowed_fields]
    if invalid_fields:
        raise BadRequestException(
            "The requested fields either do not exist for the corresponding "
            "object or are not searchable: %s. Note: The field names of "
            "database are case-sensitive." %
            ', '.join(sorted(invalid_fields)))


def _create_query_filters(request):
    request_filters = deepcopy(request.GET)
    request_filters.pop('limit', None)
    request_filters.pop('offset', None)

    _check_if_fields_searchable(request_filters)
    return _parse_fields_and_create_query_filters(request_filters)


def do_jsonreports_search(request):
    try:
        model = models.JsonReport
        filters = _create_query_filters(request)
        reports = model_search(request, model.objects, filters,
                               order_by='-id')
        results = [['Id', 'Start', 'End', 'Created', 'Name', 'Version']]
        for report in reports:
                results.append([report.id,
                                datetime.datetime.strftime(
                                    report.period_start, UTC_FORMAT),
                                datetime.datetime.strftime(
                                    report.period_end, UTC_FORMAT),
                                datetime.datetime.strftime(
                                    dt.dt_from_decimal(report.created),
                                    UTC_FORMAT),
                                report.name,
                                report.version])
    except BadRequestException as be:
        return error_response(400, 'Bad Request', str(be))
    except ValidationError as ve:
        return error_response(400, 'Bad Request', ve.messages[0])

    return rsp(json.dumps(results))

########NEW FILE########
__FILENAME__ = tests
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from datetime import datetime
from django.test import TransactionTestCase
import db
from stacktach.datetime_to_decimal import dt_to_decimal
from stacktach.models import RawDataImageMeta, ImageUsage, ImageDeletes
from stacktach.models import GenericRawData
from stacktach.models import GlanceRawData
from stacktach.models import RawData
from stacktach.models import get_model_fields
from stacktach import datetime_to_decimal as dt



class RawDataImageMetaDbTestCase(TransactionTestCase):
    def test_create_raw_data_should_populate_rawdata_and_rawdata_imagemeta(self):
        deployment = db.get_or_create_deployment('deployment1')[0]
        kwargs = {
            'deployment': deployment,
            'when': dt_to_decimal(datetime.utcnow()),
            'tenant': '1',
            'json': '{}',
            'routing_key': 'monitor.info',
            'state': 'verifying',
            'old_state': 'pending',
            'old_task': 'building',
            'task': 'saving',
            'image_type': 1,
            'publisher': 'publisher',
            'event': 'compute.instance.exists',
            'service': 'compute',
            'host': 'host',
            'instance': '1234-5678-9012-3456',
            'request_id': '1234',
            'os_architecture': 'x86',
            'os_version': '1',
            'os_distro': 'windows',
            'rax_options': '2'}

        rawdata = db.create_nova_rawdata(**kwargs)

        for field in get_model_fields(RawData):
            if field.name != 'id':
                self.assertEquals(getattr(rawdata, field.name),
                                  kwargs[field.name])

        raw_image_meta = RawDataImageMeta.objects.filter(raw_id=rawdata.id)[0]
        self.assertEquals(raw_image_meta.os_architecture,
                          kwargs['os_architecture'])
        self.assertEquals(raw_image_meta.os_version, kwargs['os_version'])
        self.assertEquals(raw_image_meta.os_distro, kwargs['os_distro'])
        self.assertEquals(raw_image_meta.rax_options, kwargs['rax_options'])


class GlanceTestCase(TransactionTestCase):
    def _create_glance_rawdata(self):
        deployment = db.get_or_create_deployment('deployment1')[0]
        kwargs = {
            'deployment': deployment,
            'when': dt_to_decimal(datetime.utcnow()),
            'owner': '1234567',
            'json': '{}',
            'routing_key': 'glance_monitor.info',
            'image_type': 1,
            'publisher': 'publisher',
            'event': 'event',
            'service': 'service',
            'host': 'host',
            'instance': '1234-5678-9012-3456',
            'request_id': '1234',
            'uuid': '1234-5678-0912-3456',
            'status': 'active',
        }
        db.create_glance_rawdata(**kwargs)
        rawdata = GlanceRawData.objects.all()[0]
        return kwargs, rawdata

    def test_create_rawdata_should_populate_glance_rawdata(self):
        kwargs, rawdata = self._create_glance_rawdata()

        for field in get_model_fields(GlanceRawData):
            if field.name != 'id':
                self.assertEquals(getattr(rawdata, field.name),
                                  kwargs[field.name])

    def test_create_glance_usage_should_populate_image_usage(self):
        _, rawdata = self._create_glance_rawdata()
        kwargs = {
            'uuid': '1',
            'created_at': dt_to_decimal(datetime.utcnow()),
            'owner': '1234567',
            'size': 12345,
            'last_raw': rawdata
        }
        db.create_image_usage(**kwargs)
        usage = ImageUsage.objects.all()[0]

        for field in get_model_fields(ImageUsage):
            if field.name != 'id':
                self.assertEquals(getattr(usage, field.name),
                                  kwargs[field.name])

    def test_create_image_delete_should_populate_image_delete(self):
        _, rawdata = self._create_glance_rawdata()
        kwargs = {
            'uuid': '1',
            'raw': rawdata,
            'deleted_at': dt_to_decimal(datetime.utcnow())
        }
        db.create_image_delete(**kwargs)
        image_delete = ImageDeletes.objects.all()[0]

        for field in get_model_fields(ImageDeletes):
            if field.name != 'id':
                self.assertEquals(getattr(image_delete, field.name),
                                  kwargs[field.name])


class GenericRawDataTestCase(TransactionTestCase):
    def test_create_generic_rawdata_should_populate_generic_rawdata(self):
        deployment = db.get_or_create_deployment('deployment1')[0]
        kwargs = {
            'deployment': deployment,
            'when': dt_to_decimal(datetime.utcnow()),
            'tenant': '1234567',
            'json': '{}',
            'routing_key': 'monitor.info',
            'publisher': 'publisher',
            'event': 'event',
            'service': 'service',
            'host': 'host',
            'instance': '1234-5678-9012-3456',
            'request_id': '1234',
            'message_id': 'message_id'}

        db.create_generic_rawdata(**kwargs)
        rawdata = GenericRawData.objects.all()[0]

        for field in get_model_fields(GenericRawData):
            if field.name != 'id':
                self.assertEquals(getattr(rawdata, field.name),
                                  kwargs[field.name])


class NovaRawDataSearchTestCase(TransactionTestCase):
    def test_search_results_for_nova(self):
        expected_result = [['#', '?', 'When', 'Deployment', 'Event', 'Host',
                            'State', "State'", "Task'"], [1L, ' ',
                            '2013-07-17 10:16:10.717219', 'depl', 'event',
                            'host', 'state', 'old_state', 'old_task']]
        depl = db.get_or_create_deployment('depl')[0]
        when = dt.dt_to_decimal(datetime.utcnow())
        raw = db.create_nova_rawdata(deployment=depl,
                      routing_key='routing_key',
                                      tenant='tenant',
                                      json='json',
                                      when=when,
                                      publisher='publisher',
                                      event='event',
                                      service='nova',
                                      host='host',
                                      instance='instance',
                                      request_id='req-1234',
                                      state='state',
                                      old_state='old_state',
                                      task='task',
                                      old_task='old_task',
                                      os_architecture='arch',
                                      os_distro='distro',
                                      os_version='version',
                                      rax_options=1)

        results = raw.search_results({}, "2013-07-17 10:16:10.717219", ' ')
        self.assertEqual(results,expected_result)

    def test_search_results_for_glance(self):
        expected_result = [['#', '?', 'When', 'Deployment', 'Event', 'Host',
                            'Status'], [1L, ' ',
                            '2013-07-17 10:16:10.717219', 'depl', 'event',
                            'host', 'status']]
        depl = db.get_or_create_deployment('depl')[0]
        when = dt.dt_to_decimal(datetime.utcnow())

        glance_raw = db.create_glance_rawdata(deployment=depl,
                                              routing_key='routing_key',
                                              json='json',
                                              when=when,
                                              publisher='publisher',
                                              event='event',
                                              service='glance',
                                              host='host',
                                              uuid='instance',
                                              request_id='req-1234',
                                              status='status',
                                              image_type=1)

        results = glance_raw.search_results({}, "2013-07-17 10:16:10.717219",
                                                ' ')
        self.assertEqual(results,expected_result)

    def test_search_results_for_generic(self):
        expected_result = [['#', '?', 'When', 'Deployment', 'Event', 'Host',
                            'Instance', 'Request id'], [1L, ' ',
                            '2013-07-17 10:16:10.717219', 'depl', 'event',
                            'host', 'instance', 'req-1234']]
        depl = db.get_or_create_deployment('depl')[0]
        when = dt.dt_to_decimal(datetime.utcnow())

        generic_raw = db.create_generic_rawdata(deployment=depl,
                                              routing_key='routing_key',
                                              json='json',
                                              when=when,
                                              publisher='publisher',
                                              event='event',
                                              service='glance',
                                              host='host',
                                              instance='instance',
                                              request_id='req-1234',
                                              tenant='tenant')

        results = generic_raw.search_results({}, "2013-07-17 10:16:10.717219",
                                                ' ')
        self.assertEqual(results,expected_result)

########NEW FILE########
__FILENAME__ = test_utils
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json
import views

from models import *

INSTANCE_ID_1 = 'testinstanceid1'
INSTANCE_ID_2 = 'testinstanceid2'

MESSAGE_ID_1 = 'testmessageid1'
MESSAGE_ID_2 = 'testmessageid2'

REQUEST_ID_1 = 'testrequestid1'
REQUEST_ID_2 = 'testrequestid2'
REQUEST_ID_3 = 'testrequestid3'


def create_raw(deployment, when, event, instance=INSTANCE_ID_1,
               request_id=REQUEST_ID_1, state='active', old_task='',
               host='compute', service='compute', json='',
               tenant='default_tenant_id'):
    raw_values  = {
        'deployment': deployment,
        'host': host,
        'service': service,
        'state': state,
        'old_task': old_task,
        'when': when,
        'event': event,
        'instance': instance,
        'request_id': request_id,
        'json': json,
        'tenant': tenant
    }
    raw = RawData(**raw_values)
    raw.save()
    return raw

########NEW FILE########
__FILENAME__ = urls
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
from django.conf.urls import patterns, url

from stacktach import stacklog

stacklog.set_default_logger_name('stacktach-web')
web_logger = stacklog.get_logger('stacktach-web')
web_logger_listener = stacklog.LogListener(web_logger)
web_logger_listener.start()

web_urls = (
    url(r'^$', 'stacktach.views.welcome', name='welcome'),
    url(r'^(?P<deployment_id>\d+)/$', 'stacktach.views.home', name='home'),
    url(r'^(?P<deployment_id>\d+)/details/(?P<column>\w+)/(?P<row_id>\d+)/$',
        'stacktach.views.details', name='details'),
    url(r'^(?P<deployment_id>\d+)/search/$',
        'stacktach.views.search', name='search'),
    url(r'^(?P<deployment_id>\d+)/expand/(?P<row_id>\d+)/$',
        'stacktach.views.expand', name='expand'),
    url(r'^(?P<deployment_id>\d+)/latest_raw/$',
        'stacktach.views.latest_raw', name='latest_raw'),
    url(r'^(?P<deployment_id>\d+)/instance_status/$',
        'stacktach.views.instance_status', name='instance_status'),
)

stacky_urls = (
    url(r'^stacky/deployments/$', 'stacktach.stacky_server.do_deployments'),
    url(r'^stacky/events/$', 'stacktach.stacky_server.do_events'),
    url(r'^stacky/hosts/$', 'stacktach.stacky_server.do_hosts'),
    url(r'^stacky/uuid/$', 'stacktach.stacky_server.do_uuid'),
    url(r'^stacky/timings/$', 'stacktach.stacky_server.do_timings'),
    url(r'^stacky/timings/uuid/$', 'stacktach.stacky_server.do_timings_uuid'),
    url(r'^stacky/summary/$', 'stacktach.stacky_server.do_summary'),
    url(r'^stacky/request/$', 'stacktach.stacky_server.do_request'),
    url(r'^stacky/reports/search/$',
        'stacktach.stacky_server.do_jsonreports_search'),
    url(r'^stacky/reports/$', 'stacktach.stacky_server.do_jsonreports'),
    url(r'^stacky/report/(?P<report_id>\d+)/$',
                            'stacktach.stacky_server.do_jsonreport'),
    url(r'^stacky/show/(?P<event_id>\d+)/$',
                                        'stacktach.stacky_server.do_show'),
    url(r'^stacky/watch/(?P<deployment_id>\d+)/$',
                                        'stacktach.stacky_server.do_watch'),
    url(r'^stacky/search/$', 'stacktach.stacky_server.search'),
    url(r'^stacky/kpi/$', 'stacktach.stacky_server.do_kpi'),
    url(r'^stacky/kpi/(?P<tenant_id>\w+)/$', 'stacktach.stacky_server.do_kpi'),
)

dbapi_urls = (
    url(r'^db/usage/launches/$',
        'stacktach.dbapi.list_usage_launches'),
    url(r'^db/usage/nova/launches/$',
        'stacktach.dbapi.list_usage_launches'),
    url(r'^db/usage/glance/images/$',
        'stacktach.dbapi.list_usage_images'),
    url(r'^db/usage/launches/(?P<launch_id>\d+)/$',
        'stacktach.dbapi.get_usage_launch'),
    url(r'^db/usage/nova/launches/(?P<launch_id>\d+)/$',
        'stacktach.dbapi.get_usage_launch'),
    url(r'^db/usage/glance/images/(?P<image_id>\d+)/$',
        'stacktach.dbapi.get_usage_image'),
    url(r'^db/usage/deletes/$',
        'stacktach.dbapi.list_usage_deletes'),
    url(r'^db/usage/nova/deletes/$',
        'stacktach.dbapi.list_usage_deletes'),
    url(r'^db/usage/glance/deletes/$',
        'stacktach.dbapi.list_usage_deletes_glance'),
    url(r'^db/usage/deletes/(?P<delete_id>\d+)/$',
        'stacktach.dbapi.get_usage_delete'),
    url(r'^db/usage/nova/deletes/(?P<delete_id>\d+)/$',
        'stacktach.dbapi.get_usage_delete'),
    url(r'^db/usage/glance/deletes/(?P<delete_id>\d+)/$',
        'stacktach.dbapi.get_usage_delete_glance'),
    url(r'^db/usage/exists/$', 'stacktach.dbapi.list_usage_exists'),
    url(r'^db/usage/nova/exists/$', 'stacktach.dbapi.list_usage_exists'),
    url(r'^db/usage/glance/exists/$', 'stacktach.dbapi.list_usage_exists_glance'),
    url(r'^db/usage/exists/(?P<exist_id>\d+)/$',
        'stacktach.dbapi.get_usage_exist'),
    url(r'^db/usage/nova/exists/(?P<exist_id>\d+)/$',
        'stacktach.dbapi.get_usage_exist'),
    url(r'^db/usage/glance/exists/(?P<exist_id>\d+)/$',
        'stacktach.dbapi.get_usage_exist_glance'),
    url(r'^db/confirm/usage/exists/(?P<message_id>[\w\-]+)/$',
        'stacktach.dbapi.exists_send_status'),
    url(r'^db/stats/nova/exists/$',
        'stacktach.dbapi.get_usage_exist_stats'),
    url(r'^db/stats/glance/exists/$',
        'stacktach.dbapi.get_usage_exist_stats_glance'),
    url(r'^db/stats/events/', 'stacktach.dbapi.get_event_stats'),
    url(r'^db/repair/', 'stacktach.dbapi.repair_stacktach_down'),
    url(r'db/tenant/info/(?P<tenant_id>\w+)/$',
        'stacktach.dbapi.update_tenant_info'),
    url(r'db/tenant/batch_info/$',
        'stacktach.dbapi.batch_update_tenant_info'),

)

urlpatterns = patterns('', *(web_urls + stacky_urls + dbapi_urls))

########NEW FILE########
__FILENAME__ = utils
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import uuid

from stacktach import datetime_to_decimal as dt


def str_time_to_unix(when):
    if 'Z' in when:
        when = _try_parse(when, ["%Y-%m-%dT%H:%M:%SZ", "%Y-%m-%dT%H:%M:%S.%fZ"])
    elif 'T' in when:
        when = _try_parse(when, ["%Y-%m-%dT%H:%M:%S.%f", "%Y-%m-%dT%H:%M:%S"])
    else:
        when = _try_parse(when, ["%Y-%m-%d %H:%M:%S.%f", "%Y-%m-%d %H:%M:%S"])

    return dt.dt_to_decimal(when)


def _try_parse(when, formats):
    last_exception = None
    for format in formats:
        try:
            when = datetime.datetime.strptime(when, format)
            parsed = True
        except Exception, e:
            parsed = False
            last_exception = e
        if parsed:
            return when
    print "Bad DATE ", last_exception


def is_uuid_like(val):
    try:
        converted = str(uuid.UUID(val))
        if '-' not in val:
            converted = converted.replace('-', '')
        return converted == val
    except (TypeError, ValueError, AttributeError):
        return False


def is_request_id_like(val):
    if val[0:4] == 'req-':
        val = val[4:]
    return is_uuid_like(val)

########NEW FILE########
__FILENAME__ = views
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import datetime
import json
import pprint

from django import db
from django.shortcuts import render_to_response

from stacktach import datetime_to_decimal as dt
from stacktach import db as stackdb
from stacktach import models
from stacktach import stacklog
from stacktach import utils
from stacktach import notification

STACKDB = stackdb


def log_warn(msg):
    global LOG
    if LOG is None:
        LOG = stacklog.get_logger()
    if LOG is not None:
        LOG.warn(msg)


def start_kpi_tracking(lifecycle, raw):
    """Start the clock for kpi timings when we see an instance.update
    coming in from an api node."""
    if raw.event != "compute.instance.update":
        return

    if "api" not in raw.service:
        return

    tracker = STACKDB.create_request_tracker(request_id=raw.request_id,
                                             start=raw.when,
                                             lifecycle=lifecycle,
                                             last_timing=None,
                                             duration=str(0.0))
    STACKDB.save(tracker)


def update_kpi(timing, raw):
    """Whenever we get a .end event, use the Timing object to
    compute our current end-to-end duration.

    Note: it may not be completely accurate if the operation is
    still in-process, but we have no way of knowing it's still
    in-process without mapping the original command with the
    expected .end event (that's a whole other thing)

    Until then, we'll take the lazy route and be aware of these
    potential fence-post issues."""
    trackers = STACKDB.find_request_trackers(request_id=raw.request_id)
    if len(trackers) == 0:
        return

    tracker = trackers[0]
    tracker.last_timing = timing
    tracker.duration = timing.end_when - tracker.start
    STACKDB.save(tracker)


def aggregate_lifecycle(raw):
    """Roll up the raw event into a Lifecycle object
    and a bunch of Timing objects.

    We can use this for summarized timing reports.

    Additionally, we can use this processing to give
    us end-to-end user request timings for kpi reports.
    """

    if not raw.instance:
        return

    # While we hope only one lifecycle ever exists it's quite
    # likely we get multiple due to the workers and threads.
    lifecycle = None
    lifecycles = STACKDB.find_lifecycles(instance=raw.instance)
    if len(lifecycles) > 0:
        lifecycle = lifecycles[0]
    if not lifecycle:
        lifecycle = STACKDB.create_lifecycle(instance=raw.instance)
    lifecycle.last_raw = raw
    lifecycle.last_state = raw.state
    lifecycle.last_task_state = raw.old_task
    STACKDB.save(lifecycle)

    event = raw.event
    parts = event.split('.')
    step = parts[-1]
    name = '.'.join(parts[:-1])

    if not step in ['start', 'end']:
        # Perhaps it's an operation initiated in the API?
        start_kpi_tracking(lifecycle, raw)
        return

    # We are going to try to track every event pair that comes
    # through, but that's not as easy as it seems since we don't
    # have a unique key for each request (request_id won't work
    # since the call could come multiple times via a retry loop).
    # So, we're just going to look for Timing objects that have
    # start_raw but no end_raw. This could give incorrect data
    # when/if we get two overlapping foo.start calls (which
    # *shouldn't* happen).
    start = step == 'start'
    timing = None
    timings = STACKDB.find_timings(name=name, lifecycle=lifecycle)
    if not start:
        for t in timings:
            try:
                if t.end_raw == None and t.start_raw != None:
                    timing = t
                    break
            except models.RawData.DoesNotExist:
                # Our raw data was removed.
                pass

    if timing is None:
        timing = STACKDB.create_timing(name=name, lifecycle=lifecycle)

    if start:
        timing.start_raw = raw
        timing.start_when = raw.when

        # Erase all the other fields which may have been set
        # the first time this operation was performed.
        # For example, a resize that was done 3 times:
        # We'll only record the last one, but track that 3 were done.
        timing.end_raw = None
        timing.end_when = None

        timing.diff_when = None
        timing.diff_ms = 0
    else:
        timing.end_raw = raw
        timing.end_when = raw.when

        # We could have missed start so watch out ...
        if timing.start_when:
            timing.diff = timing.end_when - timing.start_when
            # Looks like a valid pair ...
            update_kpi(timing, raw)
    STACKDB.save(timing)


INSTANCE_EVENT = {
    'create_start': 'compute.instance.create.start',
    'create_end': 'compute.instance.create.end',
    'rebuild_start': 'compute.instance.rebuild.start',
    'rebuild_end': 'compute.instance.rebuild.end',
    'resize_prep_start': 'compute.instance.resize.prep.start',
    'resize_revert_start': 'compute.instance.resize.revert.start',
    'resize_revert_end': 'compute.instance.resize.revert.end',
    'resize_finish_start': 'compute.instance.finish_resize.start',
    'resize_finish_end': 'compute.instance.finish_resize.end',
    'rescue_start': 'compute.instance.rescue.start',
    'rescue_end': 'compute.instance.rescue.end',
    'delete_end': 'compute.instance.delete.end',
    'exists': 'compute.instance.exists',
}


def _process_usage_for_new_launch(raw, notification):
    values = {}
    values['instance'] = notification.instance
    values['request_id'] = notification.request_id

    (usage, new) = STACKDB.get_or_create_instance_usage(**values)

    if raw.event in [INSTANCE_EVENT['create_start'],
                     INSTANCE_EVENT['rebuild_start'],
                     INSTANCE_EVENT['rescue_start']]:
        usage.instance_type_id = notification.instance_type_id
        usage.instance_flavor_id = notification.instance_flavor_id

    if raw.event in [INSTANCE_EVENT['rebuild_start'],
                     INSTANCE_EVENT['resize_prep_start'],
                     INSTANCE_EVENT['resize_revert_start'],
                     INSTANCE_EVENT['rescue_start']] and\
            usage.launched_at is None:
        # Grab the launched_at so if this action spans the audit period,
        #     we will have a launch record corresponding to the exists.
        #     We don't want to override a launched_at if it is already set
        #     though, because we may have already received the end event
        usage.launched_at = utils.str_time_to_unix(notification.launched_at)

    if raw.event in [INSTANCE_EVENT['resize_prep_start'],
                     INSTANCE_EVENT['resize_revert_start']] and\
            usage.instance_type_id is None and\
            usage.instance_flavor_id is None:
        # Grab the flavor details and populate them if they aren't
        #     already. This should happen just in case we get an exists
        #     mid resize/revert. That can happen if the action spans
        #     multiple audit periods, or if the compute node is restarted
        #     mid action and another resize is kicked off.
        usage.instance_type_id = notification.instance_type_id
        usage.instance_flavor_id = notification.instance_flavor_id

    usage.tenant = notification.tenant
    usage.rax_options = notification.rax_options
    usage.os_architecture = notification.os_architecture
    usage.os_version = notification.os_version
    usage.os_distro = notification.os_distro
    STACKDB.save(usage)


def _process_usage_for_updates(raw, notification):
    if raw.event == INSTANCE_EVENT['create_end']:
        if notification.message and notification.message != 'Success':
            return

    instance_id = notification.instance
    request_id = notification.request_id
    (usage, new) = STACKDB.get_or_create_instance_usage(instance=instance_id,
                                                        request_id=request_id)

    if raw.event in [INSTANCE_EVENT['create_end'],
                     INSTANCE_EVENT['rebuild_end'],
                     INSTANCE_EVENT['resize_finish_end'],
                     INSTANCE_EVENT['resize_revert_end'],
                     INSTANCE_EVENT['rescue_end']]:
        usage.launched_at = utils.str_time_to_unix(notification.launched_at)

    if raw.event in [INSTANCE_EVENT['resize_revert_end'],
                     INSTANCE_EVENT['resize_finish_start'],
                     INSTANCE_EVENT['resize_finish_end']]:
        usage.instance_type_id = notification.instance_type_id
        usage.instance_flavor_id = notification.instance_flavor_id

    usage.tenant = notification.tenant
    usage.rax_options = notification.rax_options
    usage.os_architecture = notification.os_architecture
    usage.os_version = notification.os_version
    usage.os_distro = notification.os_distro

    STACKDB.save(usage)


def _process_delete(raw, notification):
    if notification.launched_at and notification.launched_at != '':
        instance_id = notification.instance
        deleted_at = None
        if notification.deleted_at:
            deleted_at = utils.str_time_to_unix(notification.deleted_at)
        elif notification.terminated_at:
            deleted_at = utils.str_time_to_unix(notification.terminated_at)
        launched_at = utils.str_time_to_unix(notification.launched_at)
        values = {
            'instance': instance_id,
            'deleted_at': deleted_at,
            'launched_at': launched_at
        }
        (delete, new) = STACKDB.get_or_create_instance_delete(**values)
        delete.raw = raw

        STACKDB.save(delete)


def _process_exists(raw, notification):
    instance_id = notification.instance
    launched_at_str = notification.launched_at
    if launched_at_str is not None and launched_at_str != '':
        launched_at = utils.str_time_to_unix(notification.launched_at)
        launched_range = (launched_at, launched_at+1)
        usage = STACKDB.get_instance_usage(instance=instance_id,
                                           launched_at__range=launched_range)
        values = {}
        values['message_id'] = notification.message_id
        values['instance'] = instance_id
        values['launched_at'] = launched_at
        beginning = utils.str_time_to_unix(notification.audit_period_beginning)
        values['audit_period_beginning'] = beginning
        ending = utils.str_time_to_unix(notification.audit_period_ending)
        values['audit_period_ending'] = ending
        values['instance_type_id'] = notification.instance_type_id
        values['instance_flavor_id'] = notification.instance_flavor_id
        if usage:
            values['usage'] = usage
        values['raw'] = raw
        values['tenant'] = notification.tenant
        values['rax_options'] = notification.rax_options
        values['os_architecture'] = notification.os_architecture
        values['os_version'] = notification.os_version
        values['os_distro'] = notification.os_distro
        values['bandwidth_public_out'] = notification.bandwidth_public_out

        deleted_at = notification.deleted_at
        if deleted_at and deleted_at != '':
            # We only want to pre-populate the 'delete' if we know this is in
            #     fact an exist event for a deleted instance. Otherwise, there
            #     is a chance we may populate it for a previous period's exist.
            filter = {'instance': instance_id,
                      'launched_at__range': launched_range}
            delete = STACKDB.get_instance_delete(**filter)
            deleted_at = utils.str_time_to_unix(deleted_at)
            values['deleted_at'] = deleted_at
            if delete:
                values['delete'] = delete

        exists = STACKDB.create_instance_exists(**values)
        STACKDB.save(exists)
    else:
        stacklog.warn("Ignoring exists without launched_at. RawData(%s)" % raw.id)


def _process_glance_usage(raw, notification):
    notification.save_usage(raw)


def _process_glance_delete(raw, notification):
    notification.save_delete(raw)


def _process_glance_exists(raw, notification):
    notification.save_exists(raw)

USAGE_PROCESS_MAPPING = {
    INSTANCE_EVENT['create_start']: _process_usage_for_new_launch,
    INSTANCE_EVENT['rebuild_start']: _process_usage_for_new_launch,
    INSTANCE_EVENT['resize_prep_start']: _process_usage_for_new_launch,
    INSTANCE_EVENT['resize_revert_start']: _process_usage_for_new_launch,
    INSTANCE_EVENT['rescue_start']: _process_usage_for_new_launch,
    INSTANCE_EVENT['create_end']: _process_usage_for_updates,
    INSTANCE_EVENT['rebuild_end']: _process_usage_for_updates,
    INSTANCE_EVENT['resize_finish_start']: _process_usage_for_updates,
    INSTANCE_EVENT['resize_finish_end']: _process_usage_for_updates,
    INSTANCE_EVENT['resize_revert_end']: _process_usage_for_updates,
    INSTANCE_EVENT['rescue_end']: _process_usage_for_updates,
    INSTANCE_EVENT['delete_end']: _process_delete,
    INSTANCE_EVENT['exists']: _process_exists
}

GLANCE_USAGE_PROCESS_MAPPING = {
    'image.activate': _process_glance_usage,
    'image.delete': _process_glance_delete,
    'image.exists': _process_glance_exists
}


def aggregate_usage(raw, notification):
    if not raw.instance:
        return

    if raw.event in USAGE_PROCESS_MAPPING:
        USAGE_PROCESS_MAPPING[raw.event](raw, notification)


def aggregate_glance_usage(raw, body):
    if raw.event in GLANCE_USAGE_PROCESS_MAPPING.keys():
        GLANCE_USAGE_PROCESS_MAPPING[raw.event](raw, body)


def process_raw_data(deployment, args, json_args, exchange):
    """This is called directly by the worker to add the event to the db."""
    db.reset_queries()

    routing_key, body = args
    notif = notification.notification_factory(body, deployment, routing_key,
                                              json_args, exchange)
    raw = notif.save()
    return raw, notif


def post_process_rawdata(raw, notification):
    aggregate_lifecycle(raw)
    aggregate_usage(raw, notification)


def post_process_glancerawdata(raw, notification):
    aggregate_glance_usage(raw, notification)


def post_process_genericrawdata(raw, notification):
    pass


def _post_process_raw_data(rows, highlight=None):
    deployments = models.Deployment.objects.all()
    dep_dict = dict((dep.id, dep) for dep in deployments)
    for row in rows:
        if "error" in row.routing_key:
            row.is_error = True
        if highlight and row.id == int(highlight):
            row.highlight = True
        row.fwhen = dt.dt_from_decimal(row.when)
        row.deployment = dep_dict[row.deployment_id]


def _default_context(request, deployment_id=0):
    deployment = None
    if 'deployment' in request.session:
        d = request.session['deployment']
        if d.id == deployment_id:
            deployment = d

    if not deployment and deployment_id:
        try:
            deployment = models.Deployment.objects.get(id=deployment_id)
            request.session['deployment'] = deployment
        except models.Deployment.DoesNotExist:
            pass

    context = dict(utc=datetime.datetime.utcnow(),
                   deployment=deployment,
                   deployment_id=deployment_id)
    return context


def welcome(request):
    deployments = models.Deployment.objects.all().order_by('name')
    context = _default_context(request)
    context['deployments'] = deployments
    return render_to_response('welcome.html', context)


def home(request, deployment_id):
    context = _default_context(request, deployment_id)
    return render_to_response('index.html', context)


def details(request, deployment_id, column, row_id):
    deployment_id = int(deployment_id)
    c = _default_context(request, deployment_id)
    row = models.RawData.objects.get(pk=row_id)
    value = getattr(row, column)
    rows = models.RawData.objects
    if deployment_id:
        rows = rows.filter(deployment=deployment_id)
    if column != 'when':
        rows = rows.filter(**{column:value})
    else:
        when = dt.dt_from_decimal(value)
        from_time = when - datetime.timedelta(minutes=1)
        to_time = when + datetime.timedelta(minutes=1)
        from_time_dec = dt.dt_to_decimal(from_time)
        to_time_dec = dt.dt_to_decimal(to_time)
        rows = rows.filter(when__range=(from_time_dec, to_time_dec))

    rows = rows.order_by('-when')[:200]
    _post_process_raw_data(rows, highlight=row_id)
    c['rows'] = rows
    c['allow_expansion'] = True
    c['show_absolute_time'] = True
    return render_to_response('rows.html', c)


def expand(request, deployment_id, row_id):
    c = _default_context(request, deployment_id)
    row = models.RawData.objects.get(pk=row_id)
    payload = json.loads(row.json)
    pp = pprint.PrettyPrinter()
    c['payload'] = pp.pformat(payload)
    return render_to_response('expand.html', c)


def latest_raw(request, deployment_id):
    """This is the 2sec ticker that updates the Recent Activity box."""
    deployment_id = int(deployment_id)
    c = _default_context(request, deployment_id)
    then = datetime.datetime.utcnow() - datetime.timedelta(hours=1)
    thend = dt.dt_to_decimal(then)
    query = models.RawData.objects.filter(when__gt=thend)
    if deployment_id > 0:
        query = query.filter(deployment=deployment_id)
    rows = query.order_by('-when')[:20]
    _post_process_raw_data(rows)
    c['rows'] = rows
    return render_to_response('host_status.html', c)


def search(request, deployment_id):
    c = _default_context(request, deployment_id)
    column = request.POST.get('field', None)
    value = request.POST.get('value', None)
    updates = request.POST.get('updates', True)
    count = request.POST.get('count', 20)
    if updates and updates == 'true':
        updates = True
    elif updates and updates == 'false':
        updates = False
    rows = None
    if column != None and value != None:
        rows = models.RawData.objects
        if deployment_id and int(deployment_id) != 0:
            rows = rows.filter(deployment=deployment_id)
        rows = rows.filter(**{column: value})
        if not updates:
            rows = rows.exclude(event='compute.instance.update')
        rows = rows.order_by('-when')
        if count != 'All':
            rows = rows[:int(count)]
        _post_process_raw_data(rows)
    c['rows'] = rows
    c['allow_expansion'] = True
    c['show_absolute_time'] = True
    return render_to_response('rows.html', c)

########NEW FILE########
__FILENAME__ = settings
../../settings.py
########NEW FILE########
__FILENAME__ = test_base_verifier
import datetime
import time
from django.db import transaction
import mox
from stacktach import message_service
from stacktach import stacklog
from tests.unit import StacktachBaseTestCase
from tests.unit.utils import HOST, PORT, VIRTUAL_HOST, USERID, PASSWORD, TICK_TIME, SETTLE_TIME, SETTLE_UNITS
from tests.unit.utils import make_verifier_config
from verifier import base_verifier


class BaseVerifierTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        config = make_verifier_config(False)
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        self.verifier_with_reconciler = base_verifier.Verifier(config,
            pool=self.pool, reconciler=self.reconciler)
        self.verifier_without_notifications = self\
            ._verifier_with_notifications_disabled()
        self.verifier_with_notifications = self\
            ._verifier_with_notifications_enabled()

    def _verifier_with_notifications_disabled(self):
        config = make_verifier_config(False)
        reconciler = self.mox.CreateMockAnything()
        return base_verifier.Verifier(config,
                                      pool=self.pool,
                                      reconciler=reconciler)

    def _verifier_with_notifications_enabled(self):
        config = make_verifier_config(True)
        reconciler = self.mox.CreateMockAnything()
        return base_verifier.Verifier(config,
                                      pool=self.pool,
                                      reconciler=reconciler)

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_should_create_verifier_with_reconciler(self):
        config = make_verifier_config(False)
        rec = self.mox.CreateMockAnything()
        verifier = base_verifier.Verifier(config, pool=None, reconciler=rec)
        self.assertEqual(verifier.reconciler, rec)

    def test_clean_results_full(self):
        result_not_ready = self.mox.CreateMockAnything()
        result_not_ready.ready().AndReturn(False)
        result_unsuccessful = self.mox.CreateMockAnything()
        result_unsuccessful.ready().AndReturn(True)
        result_unsuccessful.successful().AndReturn(False)
        result_successful = self.mox.CreateMockAnything()
        result_successful.ready().AndReturn(True)
        result_successful.successful().AndReturn(True)
        result_successful.get().AndReturn((True, None))
        result_failed_verification = self.mox.CreateMockAnything()
        result_failed_verification.ready().AndReturn(True)
        result_failed_verification.successful().AndReturn(True)
        failed_exists = self.mox.CreateMockAnything()
        result_failed_verification.get().AndReturn((False, failed_exists))
        self.verifier_with_reconciler.results = [result_not_ready,
                                 result_unsuccessful,
                                 result_successful,
                                 result_failed_verification]
        self.mox.ReplayAll()
        (result_count, success_count, errored) = self.verifier_with_reconciler.clean_results()
        self.assertEqual(result_count, 1)
        self.assertEqual(success_count, 2)
        self.assertEqual(errored, 1)
        self.assertEqual(len(self.verifier_with_reconciler.results), 1)
        self.assertEqual(self.verifier_with_reconciler.results[0], result_not_ready)
        self.assertEqual(len(self.verifier_with_reconciler.failed), 1)
        self.assertEqual(self.verifier_with_reconciler.failed[0], result_failed_verification)
        self.mox.VerifyAll()

    def test_clean_results_pending(self):
        result_not_ready = self.mox.CreateMockAnything()
        result_not_ready.ready().AndReturn(False)
        self.verifier_with_reconciler.results = [result_not_ready]
        self.mox.ReplayAll()
        (result_count, success_count, errored) = self.verifier_with_reconciler.clean_results()
        self.assertEqual(result_count, 1)
        self.assertEqual(success_count, 0)
        self.assertEqual(errored, 0)
        self.assertEqual(len(self.verifier_with_reconciler.results), 1)
        self.assertEqual(self.verifier_with_reconciler.results[0], result_not_ready)
        self.assertEqual(len(self.verifier_with_reconciler.failed), 0)
        self.mox.VerifyAll()

    def test_clean_results_successful(self):
        self.verifier_with_reconciler.reconcile = True
        result_successful = self.mox.CreateMockAnything()
        result_successful.ready().AndReturn(True)
        result_successful.successful().AndReturn(True)
        result_successful.get().AndReturn((True, None))
        self.verifier_with_reconciler.results = [result_successful]
        self.mox.ReplayAll()
        (result_count, success_count, errored) = self.verifier_with_reconciler.clean_results()
        self.assertEqual(result_count, 0)
        self.assertEqual(success_count, 1)
        self.assertEqual(errored, 0)
        self.assertEqual(len(self.verifier_with_reconciler.results), 0)
        self.assertEqual(len(self.verifier_with_reconciler.failed), 0)
        self.mox.VerifyAll()

    def test_clean_results_unsuccessful(self):
        result_unsuccessful = self.mox.CreateMockAnything()
        result_unsuccessful.ready().AndReturn(True)
        result_unsuccessful.successful().AndReturn(False)
        self.verifier_with_reconciler.results = [result_unsuccessful]
        self.mox.ReplayAll()
        (result_count, success_count, errored) = \
            self.verifier_with_reconciler.clean_results()
        self.assertEqual(result_count, 0)
        self.assertEqual(success_count, 0)
        self.assertEqual(errored, 1)
        self.assertEqual(len(self.verifier_with_reconciler.results), 0)
        self.assertEqual(len(self.verifier_with_reconciler.failed), 0)
        self.mox.VerifyAll()

    def test_clean_results_fail_verification(self):
        result_failed_verification = self.mox.CreateMockAnything()
        result_failed_verification.ready().AndReturn(True)
        result_failed_verification.successful().AndReturn(True)
        failed_exists = self.mox.CreateMockAnything()
        result_failed_verification.get().AndReturn((False, failed_exists))
        self.verifier_with_reconciler.results = [result_failed_verification]
        self.mox.ReplayAll()
        (result_count, success_count, errored) = \
            self.verifier_with_reconciler.clean_results()
        self.assertEqual(result_count, 0)
        self.assertEqual(success_count, 1)
        self.assertEqual(errored, 0)
        self.assertEqual(len(self.verifier_with_reconciler.results), 0)
        self.assertEqual(len(self.verifier_with_reconciler.failed), 1)
        self.assertEqual(self.verifier_with_reconciler.failed[0], failed_exists)
        self.mox.VerifyAll()

    def test_run_notifications(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        self._mock_exchange_create_and_connect(self.verifier_with_notifications)
        self.mox.StubOutWithMock(self.verifier_with_notifications, '_run')
        self.verifier_with_notifications._run(callback=mox.Not(mox.Is(None)))
        self.mox.ReplayAll()
        self.verifier_with_notifications.run()
        self.mox.VerifyAll()

    def test_run_notifications_with_routing_keys(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        self._mock_exchange_create_and_connect(self.verifier_with_notifications)
        self.mox.StubOutWithMock(self.verifier_with_notifications, '_run')
        self.verifier_with_notifications._run(callback=mox.Not(mox.Is(None)))
        self.mox.ReplayAll()
        self.verifier_with_notifications.run()
        self.mox.VerifyAll()

    def test_run_no_notifications(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        self.mox.StubOutWithMock(self.verifier_without_notifications, '_run')
        self.verifier_without_notifications._run()
        self.mox.ReplayAll()
        self.verifier_without_notifications.run()
        self.mox.VerifyAll()

    def test_run_full_no_notifications(self):
        mock_logger = self._create_mock_logger()
        mock_logger.info('None: N: None, P: 0, S: 2, E: 0')
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)

        self.mox.StubOutWithMock(transaction, 'commit_on_success')
        tran = self.mox.CreateMockAnything()
        tran.__enter__().AndReturn(tran)
        tran.__exit__(mox.IgnoreArg(), mox.IgnoreArg(), mox.IgnoreArg())
        transaction.commit_on_success().AndReturn(tran)
        self.mox.StubOutWithMock(self.verifier_without_notifications, '_keep_running')
        self.verifier_without_notifications._keep_running().AndReturn(True)
        start = datetime.datetime.utcnow()
        self.mox.StubOutWithMock(self.verifier_without_notifications, '_utcnow')
        self.verifier_without_notifications._utcnow().AndReturn(start)
        settle_offset = {SETTLE_UNITS: SETTLE_TIME}
        ending_max = start - datetime.timedelta(**settle_offset)
        self.mox.StubOutWithMock(self.verifier_without_notifications, 'verify_for_range')
        self.verifier_without_notifications.verify_for_range(ending_max, callback=None)
        self.mox.StubOutWithMock(self.verifier_without_notifications, 'reconcile_failed')
        result1 = self.mox.CreateMockAnything()
        result2 = self.mox.CreateMockAnything()
        self.verifier_without_notifications.results = [result1, result2]
        result1.ready().AndReturn(True)
        result1.successful().AndReturn(True)
        result1.get().AndReturn((True, None))
        result2.ready().AndReturn(True)
        result2.successful().AndReturn(True)
        result2.get().AndReturn((True, None))
        self.verifier_without_notifications.reconcile_failed()
        self.mox.StubOutWithMock(time, 'sleep', use_mock_anything=True)
        time.sleep(TICK_TIME)
        self.verifier_without_notifications._keep_running().AndReturn(False)
        self.mox.ReplayAll()

        self.verifier_without_notifications.run()

        self.mox.VerifyAll()

    def _create_mock_logger(self):
        mock_logger = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacklog, 'get_logger')
        return mock_logger

    def test_run_full(self):
        mock_logger = self._create_mock_logger()
        mock_logger.info('exchange: N: None, P: 0, S: 2, E: 0')
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)

        self.mox.StubOutWithMock(transaction, 'commit_on_success')
        tran = self.mox.CreateMockAnything()
        tran.__enter__().AndReturn(tran)
        tran.__exit__(mox.IgnoreArg(), mox.IgnoreArg(), mox.IgnoreArg())
        transaction.commit_on_success().AndReturn(tran)
        self._mock_exchange_create_and_connect(self.verifier_with_notifications)
        self.verifier_with_notifications.exchange().AndReturn('exchange')
        self.mox.StubOutWithMock(self.verifier_with_notifications, '_keep_running')
        self.verifier_with_notifications._keep_running().AndReturn(True)
        start = datetime.datetime.utcnow()
        self.mox.StubOutWithMock(self.verifier_with_notifications, '_utcnow')
        self.verifier_with_notifications._utcnow().AndReturn(start)
        settle_offset = {SETTLE_UNITS: SETTLE_TIME}
        ending_max = start - datetime.timedelta(**settle_offset)
        self.mox.StubOutWithMock(self.verifier_with_notifications, 'verify_for_range')
        self.verifier_with_notifications.verify_for_range(ending_max,
                                             callback=mox.Not(mox.Is(None)))
        self.mox.StubOutWithMock(self.verifier_with_notifications, 'reconcile_failed')
        result1 = self.mox.CreateMockAnything()
        result2 = self.mox.CreateMockAnything()
        self.verifier_with_notifications.results = [result1, result2]
        result1.ready().AndReturn(True)
        result1.successful().AndReturn(True)
        result1.get().AndReturn((True, None))
        result2.ready().AndReturn(True)
        result2.successful().AndReturn(True)
        result2.get().AndReturn((True, None))
        self.verifier_with_notifications.reconcile_failed()
        self.mox.StubOutWithMock(time, 'sleep', use_mock_anything=True)
        time.sleep(TICK_TIME)
        self.verifier_with_notifications._keep_running().AndReturn(False)
        self.mox.ReplayAll()

        self.verifier_with_notifications.run()

        self.mox.VerifyAll()

    def _mock_exchange_create_and_connect(self, verifier):
        self.mox.StubOutWithMock(verifier, 'exchange')
        self.verifier_with_notifications.exchange().AndReturn('exchange')
        self.mox.StubOutWithMock(message_service, 'create_exchange')
        exchange = self.mox.CreateMockAnything()
        message_service.create_exchange('exchange', 'topic', durable=True) \
            .AndReturn(exchange)
        self.mox.StubOutWithMock(message_service, 'create_connection')
        conn = self.mox.CreateMockAnything()
        conn.__enter__().AndReturn(conn)
        conn.__exit__(None, None, None)
        message_service.create_connection(HOST, PORT, USERID,
                                          PASSWORD, "librabbitmq",
                                          VIRTUAL_HOST).AndReturn(conn)

########NEW FILE########
__FILENAME__ = test_datetime_to_decimal
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import decimal

from stacktach import datetime_to_decimal
from tests.unit import StacktachBaseTestCase

class DatetimeToDecimalTestCase(StacktachBaseTestCase):

    def test_datetime_to_decimal(self):
        expected_decimal = decimal.Decimal('1356093296.123')
        utc_datetime = datetime.datetime.utcfromtimestamp(expected_decimal)
        actual_decimal = datetime_to_decimal.dt_to_decimal(utc_datetime)
        self.assertEqual(actual_decimal, expected_decimal)

    def test_decimal_to_datetime(self):
        expected_decimal = decimal.Decimal('1356093296.123')
        expected_datetime = datetime.datetime.utcfromtimestamp(expected_decimal)
        actual_datetime = datetime_to_decimal.dt_from_decimal(expected_decimal)
        self.assertEqual(actual_datetime, expected_datetime)

########NEW FILE########
__FILENAME__ = test_dbapi
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import json
import unittest

from django.db.models import Count
from django.db.models import FieldDoesNotExist
from django.db import transaction
import mock
import mox

from stacktach import dbapi
from stacktach import models
from stacktach import utils as stacktach_utils
from tests.unit import StacktachBaseTestCase
import utils
from utils import INSTANCE_ID_1
from utils import MESSAGE_ID_1
from utils import MESSAGE_ID_2
from utils import MESSAGE_ID_3
from utils import MESSAGE_ID_4


class Length(mox.Comparator):
    def __init__(self, l):
        self._len = l

    def equals(self, rhs):
        return self._len == len(rhs)

    def __repr__(self):
        return "<sequence with len %s >" % self._len


class DBAPITestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        dne_exception = models.InstanceExists.DoesNotExist
        mor_exception = models.InstanceExists.MultipleObjectsReturned
        self.mox.StubOutWithMock(models, 'RawData',
                                 use_mock_anything=True)
        self.mox.StubOutWithMock(models, 'InstanceExists',
                                 use_mock_anything=True)
        self.mox.StubOutWithMock(models, 'ImageExists',
                                 use_mock_anything=True)
        models.RawData.objects = self.mox.CreateMockAnything()
        models.InstanceExists._meta = self.mox.CreateMockAnything()
        models.ImageExists._meta = self.mox.CreateMockAnything()
        models.InstanceExists.objects = self.mox.CreateMockAnything()
        models.ImageExists.objects = self.mox.CreateMockAnything()
        models.InstanceExists.DoesNotExist = dne_exception
        models.ImageExists.DoesNotExist = dne_exception
        models.InstanceExists.MultipleObjectsReturned = mor_exception
        models.ImageExists.MultipleObjectsReturned = mor_exception

    def tearDown(self):
        self.mox.UnsetStubs()

    def make_fake_model(self):
        fake_model = self.mox.CreateMockAnything()
        fake_meta = self.mox.CreateMockAnything()
        fake_model._meta = fake_meta
        fake_orm = self.mox.CreateMockAnything()
        fake_model.objects = fake_orm
        return fake_model

    def test_get_filter_args(self):
        start_time = datetime.datetime.utcnow()
        start_decimal = utils.decimal_utc(start_time)
        end_time = start_time + datetime.timedelta(days=1)
        end_decimal = utils.decimal_utc(end_time)
        fake_request = self.mox.CreateMockAnything()
        fake_model = self.make_fake_model()
        fake_model._meta.get_field_by_name('launched_at')
        fake_model._meta.get_field_by_name('launched_at')
        fake_request.GET = {'instance': INSTANCE_ID_1,
                            'launched_at_min': str(start_time),
                            'launched_at_max': str(end_time)}
        self.mox.ReplayAll()

        filter_args = dbapi._get_filter_args(fake_model, fake_request)

        self.mox.VerifyAll()
        self.assertEquals(filter_args['instance'], INSTANCE_ID_1)
        self.assertEquals(filter_args.get('launched_at__gte'),
                          start_decimal)
        self.assertEquals(filter_args.get('launched_at__lte'),
                          end_decimal)

    def test_get_filter_args_bad_uuid(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'instance': 'obviouslybaduuid'}
        self.mox.ReplayAll()

        self.assertRaises(dbapi.BadRequestException, dbapi._get_filter_args,
                          fake_model, fake_request)

        self.mox.VerifyAll()

    def test_get_filter_args_bad_min_value(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'launched_at_min': 'obviouslybaddatetime'}
        fake_model = self.make_fake_model()
        fake_model._meta.get_field_by_name('launched_at')
        self.mox.ReplayAll()

        self.assertRaises(dbapi.BadRequestException, dbapi._get_filter_args,
                          fake_model, fake_request)

        self.mox.VerifyAll()

    def test_get_filter_args_bad_max_value(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'launched_at_max': 'obviouslybaddatetime'}
        fake_model = self.make_fake_model()
        fake_model._meta.get_field_by_name('launched_at')
        self.mox.ReplayAll()

        self.assertRaises(dbapi.BadRequestException, dbapi._get_filter_args,
                          fake_model, fake_request)

        self.mox.VerifyAll()

    def test_get_filter_args_bad_range_key(self):
        start_time = datetime.datetime.utcnow()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'somebadfield_max': str(start_time)}
        fake_model = self.make_fake_model()
        fake_model._meta.get_field_by_name('somebadfield') \
            .AndRaise(FieldDoesNotExist())
        self.mox.ReplayAll()

        self.assertRaises(dbapi.BadRequestException, dbapi._get_filter_args,
                          fake_model, fake_request)

        self.mox.VerifyAll()

    def test_get_db_objects(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('-id').AndReturn(result)
        s = slice(None, dbapi.DEFAULT_LIMIT, None)
        result.__getitem__(s).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_desc(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'direction': 'desc'}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('-id').AndReturn(result)
        s = slice(None, dbapi.DEFAULT_LIMIT, None)
        result.__getitem__(s).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_asc(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'direction': 'asc'}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('id').AndReturn(result)
        s = slice(None, dbapi.DEFAULT_LIMIT, None)
        result.__getitem__(s).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_limit(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'limit': '1'}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('-id').AndReturn(result)
        result.__getitem__(slice(None, 1, None)).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_hard_limit(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'limit': str(dbapi.HARD_LIMIT + 1)}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('-id').AndReturn(result)
        s = slice(None, dbapi.HARD_LIMIT, None)
        result.__getitem__(s).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_offset(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'offset': '1'}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('-id').AndReturn(result)
        result.__getslice__(1, dbapi.DEFAULT_LIMIT + 1).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_offset_and_limit(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'offset': '2', 'limit': '2'}
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn({})
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.all().AndReturn(result)
        result.order_by('-id').AndReturn(result)
        result.__getslice__(2, 4).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_with_filter(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        filters = {'instance': INSTANCE_ID_1}
        fake_request.GET = filters
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=None).AndReturn(filters)
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        fake_model.objects.filter(**filters).AndReturn(result)
        result.order_by('-id').AndReturn(result)
        s = slice(None, dbapi.DEFAULT_LIMIT, None)
        result.__getitem__(s).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id')
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_get_db_objects_with_custom_filter(self):
        fake_model = self.make_fake_model()
        fake_request = self.mox.CreateMockAnything()
        filters = {'instance': INSTANCE_ID_1}
        custom_filters = {'raw': {'raw__id': 1}}
        fake_request.GET = filters
        self.mox.StubOutWithMock(dbapi, '_get_filter_args')
        dbapi._get_filter_args(fake_model, fake_request,
                               custom_filters=custom_filters).AndReturn(
            filters)
        self.mox.StubOutWithMock(dbapi, '_check_has_field')
        dbapi._check_has_field(fake_model, 'id')
        result = self.mox.CreateMockAnything()
        all_filters = {}
        all_filters.update(filters)
        all_filters.update(custom_filters['raw'])
        fake_model.objects.filter(**all_filters).AndReturn(result)
        result.order_by('-id').AndReturn(result)
        s = slice(None, dbapi.DEFAULT_LIMIT, None)
        result.__getitem__(s).AndReturn(result)
        self.mox.ReplayAll()

        query_result = dbapi.get_db_objects(fake_model, fake_request, 'id',
                                            custom_filters=custom_filters)
        self.assertEquals(query_result, result)

        self.mox.VerifyAll()

    def test_list_usage_exists_no_custom_filters_for_nova(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        objects = self.mox.CreateMockAnything()
        dbapi.get_db_objects(models.InstanceExists, fake_request, 'id',
                             custom_filters={}).AndReturn(objects)
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(objects, dbapi._exists_extra_values)
        self.mox.ReplayAll()
        resp = dbapi.list_usage_exists(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.mox.VerifyAll()

    def test_list_usage_exists_no_custom_filters_for_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        objects = self.mox.CreateMockAnything()
        dbapi.get_db_objects(models.ImageExists, fake_request, 'id',
                             custom_filters={}).AndReturn(objects)
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(objects, dbapi._exists_extra_values)
        self.mox.ReplayAll()
        resp = dbapi.list_usage_exists_glance(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.mox.VerifyAll()

    def test_list_usage_exists_with_received_min(self):
        fake_request = self.mox.CreateMockAnything()
        date = str(datetime.datetime.utcnow())
        fake_request.GET = {'received_min': date}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        unix_date = stacktach_utils.str_time_to_unix(date)
        custom_filters = {'received_min': {'raw__when__gte': unix_date}}
        objects = self.mox.CreateMockAnything()
        dbapi.get_db_objects(models.InstanceExists, fake_request, 'id',
                             custom_filters=custom_filters).AndReturn(objects)
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(objects, dbapi._exists_extra_values)
        self.mox.ReplayAll()
        resp = dbapi.list_usage_exists(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.mox.VerifyAll()

    def test_list_usage_exists_with_received_max(self):
        fake_request = self.mox.CreateMockAnything()
        date = str(datetime.datetime.utcnow())
        fake_request.GET = {'received_max': date}
        unix_date = stacktach_utils.str_time_to_unix(date)
        custom_filters = {'received_max': {'raw__when__lte': unix_date}}
        objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        dbapi.get_db_objects(models.InstanceExists, fake_request, 'id',
                             custom_filters=custom_filters).AndReturn(objects)
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(objects, dbapi._exists_extra_values)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_exists(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.mox.VerifyAll()

    def test_list_usage_exists_with_bad_received_min(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'received_min': 'obviouslybaddate'}
        self.mox.ReplayAll()
        resp = dbapi.list_usage_exists(fake_request)
        self.assertEqual(resp.status_code, 400)
        self.mox.VerifyAll()

    def test_list_usage_exists_with_bad_received_max(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'received_max': 'obviouslybaddate'}
        self.mox.ReplayAll()
        resp = dbapi.list_usage_exists(fake_request)
        self.assertEqual(resp.status_code, 400)
        self.mox.VerifyAll()

    def test_update_tenant_info(self):
        TEST_TENANT='test'

        models.TenantInfo.objects = self.mox.CreateMockAnything()
        models.TenantType.objects = self.mox.CreateMockAnything()

        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'PUT'
        body_dict = dict(tenant=TEST_TENANT,
                         name='test name',
                         types=dict(test_type='thingy'))
        body = json.dumps(body_dict)
        fake_request.body = body

        info = self.mox.CreateMockAnything()
        info_result = self.mox.CreateMockAnything()
        models.TenantInfo.objects.select_for_update().AndReturn(info_result)
        info_result.get(tenant=TEST_TENANT).AndReturn(info)
        info.save()

        ttype = self.mox.CreateMockAnything()
        models.TenantType.objects.get(name='test_type', value='thingy').AndReturn(ttype)
        ttype.__hash__().AndReturn(hash('test_type'))
        info.save()

        self.mox.ReplayAll()

        dbapi.update_tenant_info(fake_request, TEST_TENANT)

        self.assertEqual(info.name, 'test name')
        self.assertEqual(info.types, [ttype])
        self.mox.VerifyAll()

    def test_batch_update_tenant_info(self):
        TEST_DATE='test date time'

        mock_t1 = self.mox.CreateMock(models.TenantInfo)
        mock_t1.id = 1
        mock_t1.tenant = 'test_old'
        mock_t1.name = 'test old name'
        mock_t1.types = self.mox.CreateMockAnything()
        mock_t1.types.all().AndReturn([])
        mock_t1.last_updated = TEST_DATE

        mock_t2 = self.mox.CreateMock(models.TenantInfo)
        mock_t2.id = 2
        mock_t2.tenant = 'test_new'
        mock_t2.name = 'test new name'
        mock_t2.last_updated = TEST_DATE
        mock_t2.types = self.mox.CreateMockAnything()
        mock_t2.types.all().AndReturn([])
        TEST_OBJECTS = [mock_t1, mock_t2]

        mock_tt1 = self.mox.CreateMock(models.TenantType)
        mock_tt1.id = 1
        mock_tt1.name = 'test_type'
        mock_tt1.value = 'thingy'

        mock_tt2 = self.mox.CreateMock(models.TenantType)
        mock_tt2.id = 2
        mock_tt2.name = 'test_type'
        mock_tt2.value = 'whatzit'
        TEST_TYPES = [mock_tt1, mock_tt2]

        models.TenantInfo.objects = self.mox.CreateMockAnything()
        models.TenantType.objects = self.mox.CreateMockAnything()
        TypeXref = models.TenantInfo.types.through
        TypeXref.objects = self.mox.CreateMockAnything()

        self.mox.StubOutWithMock(dbapi, 'datetime')
        dbapi.datetime.utcnow().AndReturn(TEST_DATE)

        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'PUT'
        body_dict = dict(tenants=[dict(tenant='test_old',
                                       name='test old name',
                                       types=dict(test_type='thingy')),
                                  dict(tenant='test_new',
                                       name='test new name',
                                       types=dict(test_type='whatzit'))])
        body = json.dumps(body_dict)
        fake_request.body = body

        info_values = self.mox.CreateMockAnything()
        models.TenantInfo.objects.filter(tenant__in=mox.SameElementsAs(['test_old', 'test_new']))\
                .AndReturn(info_values)
        info_values.values('tenant').AndReturn([dict(tenant='test_old')])
        models.TenantInfo.objects.bulk_create(mox.And(
            Length(1), mox.IsA(list), mox.In(mox.And(
                     mox.IsA(models.TenantInfo),
                     mox.ContainsAttributeValue('tenant','test_new'),
                     mox.ContainsAttributeValue('name', 'test new name'),
                     mox.ContainsAttributeValue('last_updated', TEST_DATE)
                     ))))

        fake_tenants = self.mox.CreateMockAnything()
        models.TenantInfo.objects.filter(tenant__in=mox.SameElementsAs(['test_old', 'test_new']))\
                .AndReturn(fake_tenants)
        fake_tenants.update(last_updated=TEST_DATE)
        fake_tenants.__iter__().AndReturn(iter(TEST_OBJECTS))

        models.TenantType.objects.all().AndReturn(TEST_TYPES)

        mock_query = self.mox.CreateMockAnything()
        TypeXref.objects.filter(tenantinfo_id__in=[]).AndReturn(mock_query)
        mock_query.delete()

        TypeXref.objects.bulk_create(mox.And(
            Length(2), mox.IsA(list),
            mox.In(mox.And(
                     mox.IsA(TypeXref),
                     mox.ContainsAttributeValue('tenantinfo_id', 1),
                     mox.ContainsAttributeValue('tenanttype_id', 1))),
            mox.In(mox.And(
                     mox.IsA(TypeXref),
                     mox.ContainsAttributeValue('tenantinfo_id', 2),
                     mox.ContainsAttributeValue('tenanttype_id', 2))),
            ))

        self.mox.ReplayAll()
        dbapi.batch_update_tenant_info(fake_request)
        self.mox.VerifyAll()

    def test_list_usage_launches_without_service(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        mock_objects = self.mox.CreateMockAnything()
        launches = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(mock_objects).AndReturn(launches)
        dbapi.get_db_objects(models.InstanceUsage, fake_request,
                             'launched_at').AndReturn(mock_objects)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_launches(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'launches': launches})
        self.mox.VerifyAll()

    def test_list_usage_launches_for_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        mock_objects = self.mox.CreateMockAnything()
        launches = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(mock_objects).AndReturn(launches)
        dbapi.get_db_objects(models.ImageUsage, fake_request,
                             'created_at').AndReturn(mock_objects)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_images(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'images': launches})
        self.mox.VerifyAll()

    def test_list_usage_launches_for_nova(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        mock_objects = self.mox.CreateMockAnything()
        launches = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(mock_objects).AndReturn(launches)
        dbapi.get_db_objects(models.InstanceUsage, fake_request,
                             'launched_at').AndReturn(mock_objects)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_launches(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'launches': launches})
        self.mox.VerifyAll()

    def test_get_usage_launch_with_no_service(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        launch = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_get_model_by_id')
        dbapi._get_model_by_id(models.InstanceUsage, 1).AndReturn(launch)
        self.mox.ReplayAll()

        resp = dbapi.get_usage_launch(fake_request, 1)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'launch': {'a': 1}})
        self.mox.VerifyAll()

    def test_get_usage_launch_for_nova(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        launch = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_get_model_by_id')
        dbapi._get_model_by_id(models.InstanceUsage, 1).AndReturn(launch)
        self.mox.ReplayAll()

        resp = dbapi.get_usage_launch(fake_request, 1)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'launch': {'a': 1}})
        self.mox.VerifyAll()

    def test_get_usage_launch_for_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        launch = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_get_model_by_id')
        dbapi._get_model_by_id(models.ImageUsage, 1).AndReturn(launch)
        self.mox.ReplayAll()

        resp = dbapi.get_usage_image(fake_request, 1)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'launch': {'a': 1}})
        self.mox.VerifyAll()

    def test_get_usage_delete_for_nova(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        delete = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_get_model_by_id')
        dbapi._get_model_by_id(models.InstanceDeletes, 1).AndReturn(delete)
        self.mox.ReplayAll()

        resp = dbapi.get_usage_delete(fake_request, 1)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'delete': {'a': 1}})
        self.mox.VerifyAll()

    def test_get_usage_delete_for_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        delete = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_get_model_by_id')
        dbapi._get_model_by_id(models.ImageDeletes, 1).AndReturn(delete)
        self.mox.ReplayAll()

        resp = dbapi.get_usage_delete_glance(fake_request, 1)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'delete': {'a': 1}})
        self.mox.VerifyAll()

    def test_list_usage_deletes_with_no_service(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        mock_objects = self.mox.CreateMockAnything()
        deletes = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(mock_objects).AndReturn(deletes)
        dbapi.get_db_objects(models.InstanceDeletes, fake_request,
                             'launched_at').AndReturn(mock_objects)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_deletes(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'deletes': deletes})
        self.mox.VerifyAll()

    def test_list_usage_deletes_for_nova(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        mock_objects = self.mox.CreateMockAnything()
        deletes = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(mock_objects).AndReturn(deletes)
        dbapi.get_db_objects(models.InstanceDeletes, fake_request,
                             'launched_at').AndReturn(mock_objects)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_deletes(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'deletes': deletes})
        self.mox.VerifyAll()

    def test_list_usage_deletes_for_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        self.mox.StubOutWithMock(dbapi, 'get_db_objects')
        mock_objects = self.mox.CreateMockAnything()
        deletes = {'a': 1}
        self.mox.StubOutWithMock(dbapi, '_convert_model_list')
        dbapi._convert_model_list(mock_objects).AndReturn(deletes)
        dbapi.get_db_objects(models.ImageDeletes, fake_request,
                             'deleted_at').AndReturn(mock_objects)
        self.mox.ReplayAll()

        resp = dbapi.list_usage_deletes_glance(fake_request)
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(json.loads(resp.content), {'deletes': deletes})
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_nova(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        query = self.mox.CreateMockAnything()
        models.InstanceExists.objects.filter().AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_nova_received_min(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        now = datetime.datetime.utcnow()
        fake_request.GET = {'received_min': str(now)}
        query = self.mox.CreateMockAnything()
        filters = {'raw__when__gte': utils.decimal_utc(now)}
        models.InstanceExists.objects.filter(**filters).AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_nova_received_max(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        now = datetime.datetime.utcnow()
        fake_request.GET = {'received_max': str(now)}
        query = self.mox.CreateMockAnything()
        filters = {'raw__when__lte': utils.decimal_utc(now)}
        models.InstanceExists.objects.filter(**filters).AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_nova_class_field_filter(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        now = datetime.datetime.utcnow()
        fake_request.GET = {'audit_period_ending_min': str(now)}
        query = self.mox.CreateMockAnything()
        models.InstanceExists._meta.get_field_by_name('audit_period_ending')
        filters = {'audit_period_ending__gte': utils.decimal_utc(now)}
        models.InstanceExists.objects.filter(**filters).AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {}
        query = self.mox.CreateMockAnything()
        models.ImageExists.objects.filter().AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats_glance(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_glance_received_min(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        now = datetime.datetime.utcnow()
        fake_request.GET = {'received_min': str(now)}
        query = self.mox.CreateMockAnything()
        filters = {'raw__when__gte': utils.decimal_utc(now)}
        models.ImageExists.objects.filter(**filters).AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats_glance(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_glance_received_max(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        now = datetime.datetime.utcnow()
        fake_request.GET = {'received_max': str(now)}
        query = self.mox.CreateMockAnything()
        filters = {'raw__when__lte': utils.decimal_utc(now)}
        models.ImageExists.objects.filter(**filters).AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats_glance(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_usage_exist_stats_glance_class_field_filter(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        now = datetime.datetime.utcnow()
        fake_request.GET = {'audit_period_ending_min': str(now)}
        query = self.mox.CreateMockAnything()
        models.ImageExists._meta.get_field_by_name('audit_period_ending')
        filters = {'audit_period_ending__gte': utils.decimal_utc(now)}
        models.ImageExists.objects.filter(**filters).AndReturn(query)
        query.values('status', 'send_status').AndReturn(query)
        result = [
            {'status': 'verified', 'send_status': 201L, 'event_count': 2},
            {'status': 'failed', 'send_status': 0L, 'event_count': 1}
        ]
        query.annotate(event_count=mox.IsA(Count)).AndReturn(result)
        self.mox.ReplayAll()
        response = dbapi.get_usage_exist_stats_glance(fake_request)
        self.assertEqual(response.status_code, 200)
        expected_response = json.dumps({'stats': result})
        self.assertEqual(expected_response, response.content)
        self.mox.VerifyAll()

    def test_get_event_stats(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'service': "nova"}
        mock_query = self.mox.CreateMockAnything()
        models.RawData.objects.values('event').AndReturn(mock_query)
        events = [
            {'event': 'compute.instance.exists.verified', 'event_count': 100},
            {'event': 'compute.instance.exists', 'event_count': 100}
        ]
        mock_query.annotate(event_count=mox.IsA(Count)).AndReturn(events)
        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content,
                         json.dumps({'stats': events}))
        self.mox.VerifyAll()

    def test_get_event_stats_date_range(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        start = "2014-02-26 00:00:00"
        end = "2014-02-27 00:00:00"
        fake_request.GET = {'when_min': start,
                            'when_max': end,
                            'service': "nova"}
        mock_query = self.mox.CreateMockAnything()
        filters = {
            'when__gte': stacktach_utils.str_time_to_unix(start),
            'when__lte': stacktach_utils.str_time_to_unix(end)
        }
        models.RawData.objects.filter(**filters).AndReturn(mock_query)
        mock_query.values('event').AndReturn(mock_query)
        events = [
            {'event': 'compute.instance.exists.verified', 'event_count': 100},
            {'event': 'compute.instance.exists', 'event_count': 100}
        ]
        mock_query.annotate(event_count=mox.IsA(Count)).AndReturn(events)
        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content,
                         json.dumps({'stats': events}))
        self.mox.VerifyAll()

    def test_get_verified_count(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'service': "nova",
                            'event': 'compute.instance.exists.verified'}
        mock_query = self.mox.CreateMockAnything()
        models.RawData.objects.values('event').AndReturn(mock_query)
        events = [
            {'event': 'compute.instance.exists.verified', 'event_count': 100},
            {'event': 'compute.instance.exists', 'event_count': 100}
        ]
        mock_query.annotate(event_count=mox.IsA(Count)).AndReturn(events)
        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content,
                         json.dumps({'stats': [events[0]]}))
        self.mox.VerifyAll()

    def test_get_verified_count_default(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'service': "nova",
                            'event': 'compute.instance.exists.verified'}
        mock_query = self.mox.CreateMockAnything()
        models.RawData.objects.values('event').AndReturn(mock_query)
        events = [
            {'event': 'compute.instance.create.start', 'event_count': 100},
            {'event': 'compute.instance.exists', 'event_count': 100}
        ]
        mock_query.annotate(event_count=mox.IsA(Count)).AndReturn(events)
        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content,
                         json.dumps({'stats': [{'event': 'compute.instance.exists.verified', 'event_count': 0}]}))
        self.mox.VerifyAll()

    def test_get_verified_count_only_one_range_param_returns_400(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'when_min': "2014-020-26",
                            'service': "nova"}

        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(json.loads(response.content)['message'],
                         "When providing date range filters, "
                         "a min and max are required.")
        self.mox.VerifyAll()

    def test_get_verified_count_only_large_date_range_returns_400(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'when_min': "2014-2-26 00:00:00",
                            'when_max': "2014-3-5 00:00:01",  # > 7 days later
                            'service': "nova"}

        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(json.loads(response.content)['message'],
                         "Date ranges may be no larger than 604800 seconds")
        self.mox.VerifyAll()

    def test_get_verified_count_wrong_date_format_returns_400(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'when_min': "2014-020-26",
                            'when_max': "2014-020-26",
                            'service': "nova"}

        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(json.loads(response.content)['message'],
                         "Invalid format for date"
                         " (Correct format should be %Y-%m-%d %H:%M:%S)")
        self.mox.VerifyAll()

    def test_get_verified_count_wrong_service_returns_400(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.method = 'GET'
        fake_request.GET = {'when_min': "2014-02-26 00:00:00",
                            "when_max": "2014-02-27 00:00:00",
                            'service': "qonos"}

        self.mox.ReplayAll()

        response = dbapi.get_event_stats(fake_request)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(json.loads(response.content)['message'],
                         "Invalid service")
        self.mox.VerifyAll()


class StacktachRepairScenarioApi(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_change_nova_exists_status_for_all_exists(self):
        request = self.mox.CreateMockAnything()
        request.POST = self.mox.CreateMockAnything()
        message_ids = ["04fd94b5-64dd-4559-83b7-981d9d4f7a5a",
                       "14fd94b5-64dd-4559-83b7-981d9d4f7a5a",
                       "24fd94b5-64dd-4559-83b7-981d9d4f7a5a"]
        request.POST._iterlists().AndReturn([('service', ['nova']),
                                             ('message_ids', message_ids)])
        self.mox.StubOutWithMock(models.InstanceExists,
                                 'mark_exists_as_sent_unverified')
        models.InstanceExists.mark_exists_as_sent_unverified(message_ids).\
            AndReturn([[], []])
        self.mox.ReplayAll()

        response = dbapi.repair_stacktach_down(request)
        self.assertEqual(response.status_code, 200)
        response_data = json.loads(response.content)
        self.assertEqual(response_data['exists_not_pending'], [])
        self.assertEqual(response_data['absent_exists'], [])

        self.mox.VerifyAll()

    def test_change_glance_exists_status_for_all_exists(self):
        request = self.mox.CreateMockAnything()
        request.POST = self.mox.CreateMockAnything()
        message_ids = ['04fd94b5-64dd-4559-83b7-981d9d4f7a5a',
                       '14fd94b5-64dd-4559-83b7-981d9d4f7a5a',
                       '24fd94b5-64dd-4559-83b7-981d9d4f7a5a']
        request.POST._iterlists().AndReturn([('service', ['glance']),
                                             ('message_ids', message_ids)])
        self.mox.StubOutWithMock(models.ImageExists,
                                 'mark_exists_as_sent_unverified')
        models.ImageExists.mark_exists_as_sent_unverified(message_ids).\
            AndReturn([[], []])
        self.mox.ReplayAll()

        response = dbapi.repair_stacktach_down(request)
        self.assertEqual(response.status_code, 200)
        response_data = json.loads(response.content)
        self.assertEqual(response_data['exists_not_pending'], [])
        self.assertEqual(response_data['absent_exists'], [])

        self.mox.VerifyAll()


class TestExistsSendStatusBatch(unittest.TestCase):

    def test_no_messages(self):
       request = mock.MagicMock()
       request.body = "{}"

       self.assertRaises(dbapi.BadRequestException,
                         dbapi._exists_send_status_batch, request)

    def test_version_0_no_messages(self):
        request = mock.MagicMock()
        body = {'messages': {},
                'version': 0}
        request.body = json.dumps(body)

        with mock.patch.object(dbapi, "_ping_processing_with_service") as p:
            dbapi._exists_send_status_batch(request)
            self.assertFalse(p.called)

    def test_version_0_messages(self):
        request = mock.MagicMock()
        body = {'messages': "some messages",
                'version': 0}
        request.body = json.dumps(body)

        with mock.patch.object(dbapi, "_ping_processing_with_service") as p:
            dbapi._exists_send_status_batch(request)
            p.assert_called_once_with("some messages", "nova")

    def test_version_1_messages(self):
        request = mock.MagicMock()
        body = {'messages': {'nova': 'nova message',
                             'glance': 'glance message'},
                'version': 1}
        request.body = json.dumps(body)

        with mock.patch.object(dbapi, "_ping_processing_with_service") as p:
            dbapi._exists_send_status_batch(request)
            self.assertEqual(p.call_args_list, [
                mock.call("nova message", "nova", 1),
                mock.call("glance message", "glance", 1)])

    def test_version_2_messages(self):
        request = mock.MagicMock()
        body = {'messages': {'nova': 'nova message',
                             'glance': 'glance message'},
                'version': 2}
        request.body = json.dumps(body)

        with mock.patch.object(dbapi, "_ping_processing_with_service") as p:
            dbapi._exists_send_status_batch(request)
            self.assertEqual(p.call_args_list, [
                mock.call("nova message", "nova", 2),
                mock.call("glance message", "glance", 2)])

    def test_version_3_messages(self):
        request = mock.MagicMock()
        body = {'messages': {'nova': 'nova message',
                             'glance': 'glance message'},
                'version': 3}
        request.body = json.dumps(body)

        with mock.patch.object(dbapi, "_ping_processing_with_service") as p:
            dbapi._exists_send_status_batch(request)
            self.assertFalse(p.called)


class TestExistsSendStatus(unittest.TestCase):

    def test_not_put_post(self):
        request = mock.MagicMock()
        request.method = "Foo"
        self.assertRaises(dbapi.BadRequestException,
                          dbapi._undecorated_exists_send_status, request, None)

    def test_bad_body(self):
        request = mock.MagicMock()
        request.method = "PUT"
        request.body = None
        self.assertRaises(dbapi.BadRequestException,
                          dbapi._undecorated_exists_send_status, request, None)

        request.body = ""
        self.assertRaises(dbapi.BadRequestException,
                          dbapi._undecorated_exists_send_status, request, None)

    def test_batch(self):
        request = mock.MagicMock()
        request.method = "PUT"
        request.body = "body"

        with mock.patch.object(dbapi, "_exists_send_status_batch") as p:
            dbapi._undecorated_exists_send_status(request, "batch")
            self.assertTrue(p.called)

    def test_no_send_status(self):
        request = mock.MagicMock()
        request.method = "PUT"
        request.body = json.dumps({})

        self.assertRaises(dbapi.BadRequestException,
                          dbapi._undecorated_exists_send_status,
                          request, "not batch")

    def test_does_not_exist(self):
        request = mock.MagicMock()
        request.method = "PUT"
        request.body = json.dumps({"send_status": "foo"})

        with mock.patch("stacktach.models.InstanceExists.objects.select_for_update",
                        side_effect=models.InstanceExists.DoesNotExist) as p:
            self.assertRaises(dbapi.NotFoundException,
                              dbapi._undecorated_exists_send_status,
                              request, "not batch")

    def test_multiple_results(self):
        request = mock.MagicMock()
        request.method = "PUT"
        request.body = json.dumps({"send_status": "foo"})

        with mock.patch("stacktach.models.InstanceExists.objects.select_for_update",
                        side_effect=models.InstanceExists.MultipleObjectsReturned) as p:
            self.assertRaises(dbapi.APIException,
                              dbapi._undecorated_exists_send_status,
                              request, "not batch")

########NEW FILE########
__FILENAME__ = test_glance_verifier
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import decimal
import json
import uuid
import kombu

import mox
from tests.unit import utils

from stacktach import datetime_to_decimal as dt
from stacktach import stacklog
from stacktach import models
from tests.unit import StacktachBaseTestCase
from utils import IMAGE_UUID_1, SIZE_1, SIZE_2, CREATED_AT_1, CREATED_AT_2
from utils import IMAGE_OWNER_1, IMAGE_OWNER_2, DELETED_AT_1, DELETED_AT_2
from utils import GLANCE_VERIFIER_EVENT_TYPE
from utils import make_verifier_config
from verifier import glance_verifier
from verifier import NullFieldException
from verifier import WrongTypeException
from verifier import FieldMismatch
from verifier import NotFound
from verifier import VerificationException


class GlanceVerifierTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.mox.StubOutWithMock(models, 'ImageUsage', use_mock_anything=True)
        models.ImageUsage.objects = self.mox.CreateMockAnything()
        self.pool = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.glance_verifier = glance_verifier.GlanceVerifier(config,
                                                              pool=self.pool)
        self.mox.StubOutWithMock(models, 'ImageDeletes',
                                 use_mock_anything=True)
        models.ImageDeletes.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'ImageExists',
                                 use_mock_anything=True)
        models.ImageExists.objects = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()
        self.verifier = None

    def _setup_mock_logger(self):
        mock_logger = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacklog, 'get_logger')
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        return mock_logger

    def test_verify_usage_should_not_raise_exception_on_success(self):
        exist = self.mox.CreateMockAnything()
        exist.created_at = decimal.Decimal('1.1')
        exist.owner = 'owner'
        exist.size = 1234

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.created_at = decimal.Decimal('1.1')
        exist.usage.size = 1234
        exist.usage.owner = 'owner'
        self.mox.ReplayAll()

        glance_verifier._verify_for_usage(exist)

        self.mox.VerifyAll()

    def test_verify_usage_created_at_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-01 01:02:03')

        exist = self.mox.CreateMockAnything()
        exist.uuid = IMAGE_UUID_1
        exist.usage = self.mox.CreateMockAnything()
        exist.created_at = CREATED_AT_1
        exist.usage.created_at = CREATED_AT_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            glance_verifier._verify_for_usage(exist)

        exception = cm.exception
        entity_1 = {'name': 'exists', 'value': CREATED_AT_1}
        entity_2 = {'name': 'launches', 'value': CREATED_AT_2}
        self.assertEqual(exception.field_name, 'created_at')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_usage_owner_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-01 01:02:03')

        exist = self.mox.CreateMockAnything()
        exist.uuid = IMAGE_UUID_1
        exist.usage = self.mox.CreateMockAnything()
        exist.owner = IMAGE_OWNER_1
        exist.usage.owner = IMAGE_OWNER_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            glance_verifier._verify_for_usage(exist)

        exception = cm.exception
        entity_1 = {'name': 'exists', 'value': IMAGE_OWNER_1}
        entity_2 = {'name': 'launches', 'value': IMAGE_OWNER_2}
        self.assertEqual(exception.field_name, 'owner')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_usage_size_mismatch(self):
        exist = self.mox.CreateMockAnything()
        exist.uuid = IMAGE_UUID_1
        exist.size = SIZE_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.size = SIZE_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            glance_verifier._verify_for_usage(exist)
        exception = cm.exception
        entity_1 = {'name': 'exists', 'value': SIZE_1}
        entity_2 = {'name': 'launches', 'value': SIZE_2}
        self.assertEqual(exception.field_name, 'size')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_usage_for_late_usage(self):
        exist = self.mox.CreateMockAnything()
        exist.usage = None
        exist.uuid = IMAGE_UUID_1
        exist.created_at = decimal.Decimal('1.1')
        results = self.mox.CreateMockAnything()
        models.ImageUsage.objects.filter(uuid=IMAGE_UUID_1)\
                                    .AndReturn(results)
        results.count().AndReturn(1)
        usage = self.mox.CreateMockAnything()
        results.__getitem__(0).AndReturn(usage)
        usage.created_at = decimal.Decimal('1.1')
        self.mox.ReplayAll()

        glance_verifier._verify_for_usage(exist)
        self.mox.VerifyAll()

    def test_verify_usage_raises_not_found_for_no_usage(self):
        exist = self.mox.CreateMockAnything()
        exist.usage = None
        exist.uuid = IMAGE_UUID_1
        exist.created_at = decimal.Decimal('1.1')
        results = self.mox.CreateMockAnything()
        models.ImageUsage.objects.filter(uuid=IMAGE_UUID_1) \
            .AndReturn(results)
        results.count().AndReturn(0)
        self.mox.ReplayAll()

        with self.assertRaises(NotFound) as cm:
            glance_verifier._verify_for_usage(exist)
        exception = cm.exception
        self.assertEqual(exception.object_type, 'ImageUsage')
        self.assertEqual(exception.search_params, {'uuid': IMAGE_UUID_1})

        self.mox.VerifyAll()

    def test_verify_delete(self):
        exist = self.mox.CreateMockAnything()
        exist.delete = self.mox.CreateMockAnything()
        exist.deleted_at = decimal.Decimal('5.1')
        exist.delete.deleted_at = decimal.Decimal('5.1')
        self.mox.ReplayAll()

        glance_verifier._verify_for_delete(exist)
        self.mox.VerifyAll()

    def test_verify_delete_when_late_delete(self):
        exist = self.mox.CreateMockAnything()
        exist.uuid = IMAGE_UUID_1
        exist.delete = None
        exist.deleted_at = decimal.Decimal('5.1')
        results = self.mox.CreateMockAnything()
        models.ImageDeletes.find(uuid=IMAGE_UUID_1).AndReturn(results)
        results.count().AndReturn(1)
        delete = self.mox.CreateMockAnything()
        delete.deleted_at = decimal.Decimal('5.1')
        results.__getitem__(0).AndReturn(delete)

        self.mox.ReplayAll()

        glance_verifier._verify_for_delete(exist)
        self.mox.VerifyAll()

    def test_verify_delete_when_no_delete(self):
        exist = self.mox.CreateMockAnything()
        exist.delete = None
        exist.uuid = IMAGE_UUID_1
        exist.deleted_at = None
        audit_period_ending = decimal.Decimal('1.2')
        exist.audit_period_ending = audit_period_ending

        results = self.mox.CreateMockAnything()
        models.ImageDeletes.find(
            IMAGE_UUID_1, dt.dt_from_decimal(audit_period_ending)).AndReturn(
            results)
        results.count().AndReturn(0)

        self.mox.ReplayAll()

        glance_verifier._verify_for_delete(exist)
        self.mox.VerifyAll()

    def test_verify_delete_found_delete_when_exist_deleted_at_is_none(self):
        exist = self.mox.CreateMockAnything()
        exist.delete = None
        exist.uuid = IMAGE_UUID_1
        audit_period_ending = decimal.Decimal('1.3')
        exist.deleted_at = None
        exist.audit_period_ending = audit_period_ending
        results = self.mox.CreateMockAnything()
        models.ImageDeletes.find(
            IMAGE_UUID_1, dt.dt_from_decimal(audit_period_ending)).AndReturn(
            results)
        results.count().AndReturn(1)

        self.mox.ReplayAll()

        with self.assertRaises(VerificationException) as ve:
            glance_verifier._verify_for_delete(exist)
        exception = ve.exception
        self.assertEqual(exception.reason,
                         'Found ImageDeletes for non-delete exist')

        self.mox.VerifyAll()

    def test_verify_delete_deleted_at_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exist = self.mox.CreateMockAnything()
        exist.uuid = IMAGE_UUID_1
        exist.delete = self.mox.CreateMockAnything()
        exist.deleted_at = DELETED_AT_1
        exist.delete.deleted_at = DELETED_AT_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as fm:
            glance_verifier._verify_for_delete(exist)
        exception = fm.exception
        entity_1 = {'name': 'exists', 'value': DELETED_AT_1}
        entity_2 = {'name': 'deletes', 'value': DELETED_AT_2}
        self.assertEqual(exception.field_name, 'deleted_at')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_should_verify_that_image_size_in_exist_is_not_null(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = None
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = IMAGE_UUID_1
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except NullFieldException as nf:
            self.assertEqual(nf.field_name, 'image_size')
            self.assertEqual(
                nf.reason, "Failed at 2014-01-02 03:04:05 UTC for "
                "12345678-6352-4dbc-8271-96cc54bf14cd: image_size field was "
                "null for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_that_created_at_in_exist_is_not_null(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-01 01:02:03')

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 'size'
        exist.created_at = None
        exist.uuid = IMAGE_UUID_1
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nfe:
            glance_verifier._verify_validity(exist)
        exception = nfe.exception

        self.assertEqual(exception.field_name, 'created_at')
        self.assertEqual(exception.reason,
                         "Failed at 2014-01-01 01:02:03 UTC for "
                         "12345678-6352-4dbc-8271-96cc54bf14cd: created_at "
                         "field was null for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_that_uuid_in_exist_is_not_null(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-01 01:02:03')

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 'size'
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = None
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except NullFieldException as nf:
            self.assertEqual(nf.field_name, 'uuid')
            self.assertEqual(
                nf.reason, "Failed at 2014-01-01 01:02:03 UTC for None: "
                           "uuid field was null for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_that_owner_in_exist_is_not_null(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-01 01:02:03')

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 1234
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = IMAGE_UUID_1
        exist.owner = None
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except NullFieldException as nf:
            self.assertEqual(nf.field_name, 'owner')
            self.assertEqual(
                nf.reason,
                "Failed at 2014-01-01 01:02:03 UTC for "
                "12345678-6352-4dbc-8271-96cc54bf14cd: owner field was null "
                "for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_that_uuid_value_is_uuid_like(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 'size'
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = "asdfe-fgh"
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except WrongTypeException as wt:
            self.assertEqual(wt.field_name, 'uuid')
            self.assertEqual(
                wt.reason,
                "Failed at 2014-01-02 03:04:05 UTC for None: "
                "{uuid: asdfe-fgh} was of incorrect type for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_created_at_is_decimal(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 'size'
        exist.created_at = "123.a"
        exist.uuid = "58fb036d-5ef8-47a8-b503-7571276c400a"
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except WrongTypeException as wt:
            self.assertEqual(wt.field_name, 'created_at')
            self.assertEqual(
                wt.reason,
                "Failed at 2014-01-02 03:04:05 UTC for "
                "58fb036d-5ef8-47a8-b503-7571276c400a: {created_at: 123.a} was "
                "of incorrect type for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_image_size_is_of_type_decimal(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 'random'
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = "58fb036d-5ef8-47a8-b503-7571276c400a"
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except WrongTypeException as wt:
            self.assertEqual(wt.field_name, 'size')
            self.assertEqual(
                wt.reason,
                "Failed at 2014-01-02 03:04:05 UTC for "
                "58fb036d-5ef8-47a8-b503-7571276c400a: {size: random} was "
                "of incorrect type for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_owner_is_of_type_hex(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 1234L
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = "58fb036d-5ef8-47a8-b503-7571276c400a"
        exist.owner = "3762854cd6f6435998188d5120e4c271,kl"
        self.mox.ReplayAll()

        try:
            glance_verifier._verify_validity(exist)
            self.fail()
        except WrongTypeException as wt:
            self.assertEqual(wt.field_name, 'owner')
            self.assertEqual(
                wt.reason,
                "Failed at 2014-01-02 03:04:05 UTC for "
                "58fb036d-5ef8-47a8-b503-7571276c400a: "
                "{owner: 3762854cd6f6435998188d5120e4c271,kl} was of "
                "incorrect type for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_correctly_for_all_non_null_and_valid_types(self):
        exist = self.mox.CreateMockAnything()
        exist.id = 23
        exist.size = 983040L
        exist.created_at = decimal.Decimal('5.1')
        exist.uuid = "58fb036d-5ef8-47a8-b503-7571276c400a"
        exist.owner = "3762854cd6f6435998188d5120e4c271"
        self.mox.ReplayAll()

        glance_verifier._verify_validity(exist)
        self.mox.VerifyAll()

    def test_verify_should_verify_exists_for_usage_and_delete(self):
        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()

        self.mox.StubOutWithMock(glance_verifier, '_verify_for_usage')
        self.mox.StubOutWithMock(glance_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(glance_verifier, '_verify_validity')
        for exist in [exist1, exist2]:
            glance_verifier._verify_for_usage(exist)
            glance_verifier._verify_for_delete(exist)
            glance_verifier._verify_validity(exist)
            exist.mark_verified()
        self.mox.ReplayAll()

        verified, exist = glance_verifier._verify([exist1, exist2])

        self.mox.VerifyAll()
        self.assertTrue(verified)

    def test_verify_exist_marks_exist_failed_if_field_mismatch_exception(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()

        self.mox.StubOutWithMock(glance_verifier, '_verify_for_usage')
        self.mox.StubOutWithMock(glance_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(glance_verifier, '_verify_validity')
        entity_1 = {'name': 'exists', 'value': 'expected'}
        entity_2 = {'name': 'launches', 'value': 'actual'}
        field_mismatch_exc = FieldMismatch('field', entity_1, entity_2, 'uuid')
        glance_verifier._verify_for_usage(exist1).AndRaise(
            exception=field_mismatch_exc)
        exist1.mark_failed(
            reason="Failed at 2014-01-02 03:04:05 UTC for uuid: Data mismatch "
                   "for 'field' - 'exists' contains 'expected' but 'launches' "
                   "contains 'actual'")
        glance_verifier._verify_for_usage(exist2)
        glance_verifier._verify_for_delete(exist2)
        glance_verifier._verify_validity(exist2)
        exist2.mark_verified()
        self.mox.ReplayAll()

        verified, exist = glance_verifier._verify([exist1, exist2])
        self.mox.VerifyAll()
        self.assertFalse(verified)

    def test_verify_for_range_without_callback_for_sent_unverified(self):
        mock_logger = self._setup_mock_logger()
        self.mox.StubOutWithMock(mock_logger, 'info')
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.info('glance: Adding 2 per-owner exists to queue.')
        mock_logger.info('glance: Adding 2 per-owner exists to queue.')
        when_max = datetime.datetime.utcnow()
        models.ImageExists.VERIFYING = 'verifying'
        models.ImageExists.PENDING = 'pending'
        models.ImageExists.SENT_VERIFYING = 'sent_verifying'
        models.ImageExists.SENT_UNVERIFIED = 'sent_unverified'
        self.mox.StubOutWithMock(models.ImageExists, 'find')
        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()
        exist3 = self.mox.CreateMockAnything()
        exist4 = self.mox.CreateMockAnything()
        exist5 = self.mox.CreateMockAnything()
        results = {'owner1': [exist1, exist2], 'owner2': [exist3]}
        sent_results = {'owner1': [exist4], 'owner2': [exist5]}
        models.ImageExists.find_and_group_by_owner_and_raw_id(
            ending_max=when_max,
            status=models.ImageExists.SENT_UNVERIFIED).AndReturn(sent_results)
        models.ImageExists.find_and_group_by_owner_and_raw_id(
            ending_max=when_max,
            status=models.ImageExists.PENDING).AndReturn(results)
        exist1.save()
        exist2.save()
        exist3.save()
        exist4.save()
        exist5.save()
        self.pool.apply_async(glance_verifier._verify,
                              args=([exist4],), callback=None).InAnyOrder()
        self.pool.apply_async(glance_verifier._verify, args=([exist5],),
                              callback=None).InAnyOrder()
        self.pool.apply_async(glance_verifier._verify,
                              args=([exist1, exist2],), callback=None).InAnyOrder()
        self.pool.apply_async(glance_verifier._verify, args=([exist3],),
                              callback=None).InAnyOrder()
        self.mox.ReplayAll()

        self.glance_verifier.verify_for_range(when_max)
        self.assertEqual(exist1.status, 'verifying')
        self.assertEqual(exist2.status, 'verifying')
        self.assertEqual(exist3.status, 'verifying')
        self.assertEqual(exist4.status, 'sent_verifying')
        self.assertEqual(exist5.status, 'sent_verifying')
        self.mox.VerifyAll()

    def test_verify_for_range_with_callback(self):
        mock_logger = self._setup_mock_logger()
        self.mox.StubOutWithMock(mock_logger, 'info')
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.info('glance: Adding 0 per-owner exists to queue.')
        mock_logger.info('glance: Adding 2 per-owner exists to queue.')
        callback = self.mox.CreateMockAnything()
        when_max = datetime.datetime.utcnow()
        models.ImageExists.SENT_VERIFYING = 'sent_verifying'
        models.ImageExists.SENT_UNVERIFIED = 'sent_unverified'
        models.ImageExists.PENDING = 'pending'
        models.ImageExists.VERIFYING = 'verifying'
        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()
        exist3 = self.mox.CreateMockAnything()
        results = {'owner1': [exist1, exist2], 'owner2': [exist3]}
        models.ImageExists.find_and_group_by_owner_and_raw_id(
            ending_max=when_max,
            status=models.ImageExists.SENT_UNVERIFIED).AndReturn([])
        models.ImageExists.find_and_group_by_owner_and_raw_id(
            ending_max=when_max,
            status=models.ImageExists.PENDING).AndReturn(results)
        exist1.save()
        exist2.save()
        exist3.save()
        self.pool.apply_async(glance_verifier._verify, args=([exist3],),
                              callback=callback).InAnyOrder()
        self.pool.apply_async(glance_verifier._verify, args=([exist1, exist2],),
                              callback=callback).InAnyOrder()
        self.mox.ReplayAll()
        self.glance_verifier.verify_for_range(when_max, callback=callback)
        self.assertEqual(exist1.status, 'verifying')
        self.assertEqual(exist2.status, 'verifying')
        self.assertEqual(exist3.status, 'verifying')
        self.mox.VerifyAll()

    def test_send_verified_notification_routing_keys(self):
        connection = self.mox.CreateMockAnything()
        exchange = self.mox.CreateMockAnything()
        exist = self.mox.CreateMockAnything()
        exist.id = 1
        exist.raw = self.mox.CreateMockAnything()
        exist_dict = [
            'monitor.info',
            {
                'event_type': 'test',
                'message_id': 'some_uuid'
            }
        ]
        exist_str = json.dumps(exist_dict)
        exist.raw.json = exist_str
        exist.audit_period_beginning = datetime.datetime(2013, 10, 10)
        exist.audit_period_ending = datetime.datetime(2013, 10, 10, 23, 59, 59)
        exist.owner = "1"
        self.mox.StubOutWithMock(uuid, 'uuid4')
        uuid.uuid4().AndReturn('some_other_uuid')
        self.mox.StubOutWithMock(kombu.pools, 'producers')
        self.mox.StubOutWithMock(kombu.common, 'maybe_declare')
        models.ImageExists.objects.get(id=exist.id).AndReturn(exist)
        routing_keys = ['notifications.info', 'monitor.info']
        for key in routing_keys:
            producer = self.mox.CreateMockAnything()
            producer.channel = self.mox.CreateMockAnything()
            kombu.pools.producers[connection].AndReturn(producer)
            producer.acquire(block=True).AndReturn(producer)
            producer.__enter__().AndReturn(producer)
            kombu.common.maybe_declare(exchange, producer.channel)
            message = {'event_type': GLANCE_VERIFIER_EVENT_TYPE,
                       'message_id': 'some_other_uuid',
                       'original_message_id': 'some_uuid'}
            producer.publish(message, key)
            producer.__exit__(None, None, None)
        self.mox.ReplayAll()

        self.glance_verifier.send_verified_notification(
            exist, exchange, connection, routing_keys=routing_keys)
        self.mox.VerifyAll()

    def test_send_verified_notification_default_routing_key(self):
        connection = self.mox.CreateMockAnything()
        exchange = self.mox.CreateMockAnything()
        exist = self.mox.CreateMockAnything()
        exist.id = 1
        exist.raw = self.mox.CreateMockAnything()
        exist_dict = [
            'monitor.info',
            {
                'event_type': 'test',
                'message_id': 'some_uuid'
            }
        ]
        exist_str = json.dumps(exist_dict)
        exist.raw.json = exist_str
        exist.audit_period_beginning = datetime.datetime(2013, 10, 10)
        exist.audit_period_ending = datetime.datetime(2013, 10, 10, 23, 59, 59)
        exist.owner = "1"
        self.mox.StubOutWithMock(kombu.pools, 'producers')
        self.mox.StubOutWithMock(kombu.common, 'maybe_declare')
        models.ImageExists.objects.get(id=exist.id).AndReturn(exist)
        producer = self.mox.CreateMockAnything()
        producer.channel = self.mox.CreateMockAnything()
        kombu.pools.producers[connection].AndReturn(producer)
        producer.acquire(block=True).AndReturn(producer)
        producer.__enter__().AndReturn(producer)
        kombu.common.maybe_declare(exchange, producer.channel)
        self.mox.StubOutWithMock(uuid, 'uuid4')
        uuid.uuid4().AndReturn('some_other_uuid')
        message = {'event_type': GLANCE_VERIFIER_EVENT_TYPE,
                   'message_id': 'some_other_uuid',
                   'original_message_id': 'some_uuid'}
        producer.publish(message, exist_dict[0])
        producer.__exit__(None, None, None)
        self.mox.ReplayAll()

        self.glance_verifier.send_verified_notification(exist, exchange,
                                                        connection)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_image_type
# Copyright (c) 2012 - Rackspace Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

from stacktach import image_type
from tests.unit import StacktachBaseTestCase


class ImageTypeTestCase(StacktachBaseTestCase):

    # Abstractions
    def _test_get_numeric_code(self, image, os_type, os_distro, expected,
                               default=0):
        payload = {
            "image_meta": {
                "image_type": image,
                "os_type": os_type,
                "os_distro": os_distro
            }
        }

        result = image_type.get_numeric_code(payload, default)

        self.assertEqual(result, expected)

    def _test_readable_with_os_distro(self, value, image, os_type, os_distro):
        result = image_type.readable(value)

        self.assertEqual(result, [image, os_type, os_distro])

    def _test_readable_without_os_distro(self, value, image, os_type, os_distro):
        result = image_type.readable(value)

        self.assertEqual(result, [image, os_type])

    def _test_isset(self, code):
        value = 0
        value |= code

        self.assertTrue(image_type.isset(value, code))

    def _test_false_isset(self, code, false_code):
        value = 0
        value |= code

        self.assertFalse(image_type.isset(value, false_code))

    # Test get_numeric_code
    def test_empty_payload_in_get_numeric_code(self):
        result = image_type.get_numeric_code({})

        self.assertEqual(result, 0x0)

    def test_empty_meta_in_get_numeric_code(self):
        result = image_type.get_numeric_code({'image_meta': {}})

        self.assertEqual(result, 0x0)

    def test_empty_os_type_in_payload_not_meta(self):
        result = image_type.get_numeric_code({'image_meta': {}, 'os_type': ''})

        self.assertEqual(result, 0x0)

    def test_os_type_in_meta_with_empty_os_type_in_payload(self):
        payload = {
            "image_meta":   {
                "os_type": "windows"
            },
            "os_type": ''
        }

        result = image_type.get_numeric_code(payload)

        self.assertEqual(result, image_type.WINDOWS_IMAGE)

    def test_os_type_in_meta_has_precedent_over_one_in_payload(self):
        payload = {
            "image_meta": {
                "os_type": "linux"
            },
            "os_type": "windows"
        }

        result = image_type.get_numeric_code(payload)

        self.assertEqual(result, image_type.LINUX_IMAGE)

    def test_os_type_in_payload_not_meta(self):
        payload = {
            "image_meta": {},
            "os_type": "linux"
        }

        result = image_type.get_numeric_code(payload)

        self.assertEqual(result, image_type.LINUX_IMAGE)

    def test_get_numeric_code_base_linux_ubuntu(self):
        self._test_get_numeric_code('base', 'linux', 'ubuntu',
                                    expected=0x111)

    def test_get_numeric_code_base_linux_debian(self):
        self._test_get_numeric_code('base', 'linux', 'debian',
                                    expected=0x211)

    def test_get_numeric_code_base_linux_centos(self):
        self._test_get_numeric_code('base', 'linux', 'centos',
                                    expected=0x411)

    def test_get_numeric_code_base_linux_rhel(self):
        self._test_get_numeric_code('base', 'linux', 'rhel',
                                    expected=0x811)

    def test_get_numeric_code_snapshot_linux_ubuntu(self):
        self._test_get_numeric_code('snapshot', 'linux', 'ubuntu',
                                    expected=0x112)

    def test_get_numeric_code_snapshot_linux_debian(self):
        self._test_get_numeric_code('snapshot', 'linux', 'debian',
                                    expected=0x212)

    def test_get_numeric_code_snapshot_linux_centos(self):
        self._test_get_numeric_code('snapshot', 'linux', 'centos',
                                    expected=0x412)

    def test_get_numeric_code_snapshot_linux_rhel(self):
        self._test_get_numeric_code('snapshot', 'linux', 'rhel',
                                    expected=0x812)

    def test_get_numeric_code_base_windows(self):
        self._test_get_numeric_code('base', 'windows', None,
                                    expected=0x21)

    def test_get_numeric_code_snapshot_windows(self):
        self._test_get_numeric_code('snapshot', 'windows', None,
                                    expected=0x22)

    def test_get_numeric_code_base_freebsd(self):
        self._test_get_numeric_code('base', 'freebsd', None,
                                    expected=0x41)

    def test_get_numeric_code_snapshot_freebsd(self):
        self._test_get_numeric_code('snapshot', 'freebsd', None,
                                    expected=0x42)

    # Test readable with os_distro available
    def _test_readable_with_os_distro_base_linux_ubuntu(self):
        self._test_readable_with_os_distro(0x111, 'base', 'linux', 'ubuntu')

    def _test_readable_with_os_distro_base_linux_debian(self):
        self._test_readable_with_os_distro(0x211, 'base', 'linux', 'debian')

    def _test_readable_with_os_distro_base_linux_centos(self):
        self._test_readable_with_os_distro(0x411, 'base', 'linux', 'centos')

    def _test_readable_with_os_distro_base_linux_rhel(self):
        self._test_readable_with_os_distro(0x811, 'base', 'linux', 'rhel')

    def _test_readable_with_os_distro_snapshot_linux_ubuntu(self):
        self._test_readable_with_os_distro(0x112, 'snapshot', 'linux', 'ubuntu')

    def _test_readable_with_os_distro_snapshot_linux_debian(self):
        self._test_readable_with_os_distro(0x212, 'snapshot', 'linux', 'debian')

    def _test_readable_with_os_distro_snapshot_linux_centos(self):
        self._test_readable_with_os_distro(0x412, 'snapshot', 'linux', 'centos')

    def _test_readable_with_os_distro_snapshot_linux_rhel(self):
        self._test_readable_with_os_distro(0x812, 'snapshot', 'linux', 'rhel')

    # Test readable without os_distro available
    def test_readable_without_os_distro_base_windows_(self):
        self._test_readable_without_os_distro(0x21, 'base', 'windows', None)

    def test_readable_without_os_distro_snapshot_windows(self):
        self._test_readable_without_os_distro(0x22, 'snapshot', 'windows', None)

    def test_readable_without_distro_base_freebsd(self):
        self._test_readable_without_os_distro(0x41, 'base', 'freebsd', None)

    def test_readable__without_distro_snapshot_freebsd(self):
        self._test_readable_without_os_distro(0x42, 'snapshot', 'freebsd', None)

    # Test isset
    def test_isset_base_image(self):
        self._test_isset(image_type.BASE_IMAGE)

    def test_isset_snapshot_image(self):
        self._test_isset(image_type.SNAPSHOT_IMAGE)

    def test_isset_linux_image(self):
        self._test_isset(image_type.LINUX_IMAGE)

    def test_isset_windows_image(self):
        self._test_isset(image_type.WINDOWS_IMAGE)

    def test_isset_freebsd_image(self):
        self._test_isset(image_type.FREEBSD_IMAGE)

    def test_isset_os_debian(self):
        self._test_isset(image_type.OS_DEBIAN)

    def test_isset_os_ubuntu(self):
        self._test_isset(image_type.OS_UBUNTU)

    def test_isset_os_centos(self):
        self._test_isset(image_type.OS_CENTOS)

    def test_isset_os_rhel(self):
        self._test_isset(image_type.OS_RHEL)

    # Negative test isset
    def test_false_isset_base_image_from_payload(self):
        self._test_false_isset(image_type.SNAPSHOT_IMAGE, image_type.BASE_IMAGE)

    def test_false_isset_snapshot_image(self):
        self._test_false_isset(image_type.BASE_IMAGE, image_type.SNAPSHOT_IMAGE)

    def test_false_isset_linux_image(self):
        self._test_false_isset(image_type.WINDOWS_IMAGE, image_type.LINUX_IMAGE)

    def test_false_isset_windows_image(self):
        self._test_false_isset(image_type.LINUX_IMAGE, image_type.WINDOWS_IMAGE)

    def test_false_isset_freebsd_image(self):
        self._test_false_isset(image_type.LINUX_IMAGE, image_type.FREEBSD_IMAGE)

    def test_false_isset_os_debian_os_ubuntu(self):
        self._test_false_isset(image_type.OS_DEBIAN, image_type.OS_UBUNTU)

    def test_false_isset_os_centos_os_ubuntu(self):
        self._test_false_isset(image_type.OS_CENTOS, image_type.OS_UBUNTU)

    def test_false_isset_os_rhel_os_ubuntu(self):
        self._test_false_isset(image_type.OS_RHEL, image_type.OS_UBUNTU)

    def test_false_isset_os_ubuntu_os_debian(self):
        self._test_false_isset(image_type.OS_UBUNTU, image_type.OS_DEBIAN)

    def test_false_isset_os_centos_os_debian(self):
        self._test_false_isset(image_type.OS_CENTOS, image_type.OS_DEBIAN)

    def test_false_isset_os_rhel_os_debian(self):
        self._test_false_isset(image_type.OS_RHEL, image_type.OS_DEBIAN)

    def test_false_isset_os_debian_os_centos(self):
        self._test_false_isset(image_type.OS_DEBIAN, image_type.OS_CENTOS)

    def test_false_isset_os_ubuntu_os_centos(self):
        self._test_false_isset(image_type.OS_DEBIAN, image_type.OS_CENTOS)

    def test_false_isset_os_rhel_os_centos(self):
        self._test_false_isset(image_type.OS_RHEL, image_type.OS_CENTOS)

    def test_false_isset_os_debian_os_rhel(self):
        self._test_false_isset(image_type.OS_DEBIAN, image_type.OS_RHEL)

    def test_false_isset_os_centos_os_rhel(self):
        self._test_false_isset(image_type.OS_CENTOS, image_type.OS_RHEL)

    def test_false_isset_os_ubuntu_os_rhel(self):
        self._test_false_isset(image_type.OS_UBUNTU, image_type.OS_RHEL)

    # Test blank argument to isset
    def test_blank_argument_isset(self):
        self.assertFalse(image_type.isset(None, image_type.OS_CENTOS))

########NEW FILE########
__FILENAME__ = test_migrations_files
from os import listdir
import re

from stacktach import migrations

from tests.unit import StacktachBaseTestCase


class MigrationsTestCase(StacktachBaseTestCase):
    def test_no_duplicate_numbers(self):
        migrs = {}

        migrations_file = migrations.__file__
        migrations_dir = migrations_file[:-len('__init__.py')-1]

        migr_match = re.compile('^[0-9]{4}.*.py$')
        files = [f for f in listdir(migrations_dir)
                 if re.match(migr_match, f)]

        for f in files:
            migr_number = f[0:4]
            migr_list = migrs.get(migr_number, [])
            migr_list.append(f)
            migrs[migr_number] = migr_list
            if len(migr_list) > 1:
                msg = "Duplicate migrations found for number %s." % migr_number
                self.fail(msg)
########NEW FILE########
__FILENAME__ = test_models
# Copyright (c) 2013 - Rackspace Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
from datetime import datetime

import unittest
import mox
from stacktach.models import RawData, GlanceRawData, GenericRawData
from stacktach.models import ImageDeletes, InstanceExists, ImageExists
from tests.unit.utils import IMAGE_UUID_1
from stacktach import datetime_to_decimal as dt
from tests.unit import StacktachBaseTestCase


class ModelsTestCase(StacktachBaseTestCase):
    def test_get_name_for_rawdata(self):
        self.assertEquals(RawData.get_name(), 'RawData')

    def test_get_name_for_glancerawdata(self):
        self.assertEquals(GlanceRawData.get_name(), 'GlanceRawData')

    def test_get_name_for_genericrawdata(self):
        self.assertEquals(GenericRawData.get_name(), 'GenericRawData')


class ImageDeletesTestCase(unittest.TestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_find_delete_should_return_delete_issued_before_given_time(self):
        delete = self.mox.CreateMockAnything()
        deleted_max = datetime.utcnow()
        self.mox.StubOutWithMock(ImageDeletes.objects, 'filter')
        ImageDeletes.objects.filter(
            uuid=IMAGE_UUID_1,
            deleted_at__lte=dt.dt_to_decimal(deleted_max)).AndReturn(delete)
        self.mox.ReplayAll()

        self.assertEquals(ImageDeletes.find(
            IMAGE_UUID_1, deleted_max), delete)
        self.mox.VerifyAll()

    def test_find_delete_should_return_delete_with_the_given_uuid(self):
        delete = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(ImageDeletes.objects, 'filter')
        ImageDeletes.objects.filter(uuid=IMAGE_UUID_1).AndReturn(delete)
        self.mox.ReplayAll()

        self.assertEquals(ImageDeletes.find(IMAGE_UUID_1, None), delete)
        self.mox.VerifyAll()


class ImageExistsTestCase(unittest.TestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_group_exists_with_date_status_in_audit_period_by_owner_rawid(self):
        end_max = datetime.utcnow()
        status = 'pending'
        exist1 = self.mox.CreateMockAnything()
        exist1.owner = "owner1"
        exist1.raw_id = "1"
        exist2 = self.mox.CreateMockAnything()
        exist2.owner = "owner2"
        exist2.raw_id = "2"
        exist3 = self.mox.CreateMockAnything()
        exist3.owner = "owner1"
        exist3.raw_id = "1"
        exist4 = self.mox.CreateMockAnything()
        exist4.owner = "owner1"
        exist4.raw_id = "3"

        ordered_results = [exist1, exist3, exist4, exist2]
        unordered_results = self.mox.CreateMockAnything()
        related_results = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(ImageExists.objects, 'select_related')
        ImageExists.objects.select_related().AndReturn(related_results)
        related_results.filter(
            audit_period_ending__lte=dt.dt_to_decimal(end_max),
            status=status).AndReturn(unordered_results)
        unordered_results.order_by('owner').AndReturn(ordered_results)
        self.mox.ReplayAll()

        results = ImageExists.find_and_group_by_owner_and_raw_id(end_max,
                                                                 status)

        self.mox.VerifyAll()
        self.assertEqual(results, {'owner1-1': [exist1, exist3],
                                   'owner1-3': [exist4],
                                   'owner2-2': [exist2]})

    def test_mark_exists_as_sent_unverified(self):
        message_ids = ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b",
                       "9156b83e-f684-4ec3-8f94-7e41902f27aa"]

        exist1 = self.mox.CreateMockAnything()
        exist1.status = "pending"
        exist1.save()
        exist2 = self.mox.CreateMockAnything()
        exist2.status = "pending"
        exist2.save()
        exist3 = self.mox.CreateMockAnything()
        exist3.status = "pending"
        exist3.save()
        self.mox.StubOutWithMock(ImageExists.objects, 'filter')
        ImageExists.objects.filter(message_id=message_ids[0]).AndReturn(
            [exist1, exist2])
        ImageExists.objects.filter(message_id=message_ids[1]).AndReturn(
            [exist3])
        self.mox.ReplayAll()

        results = ImageExists.mark_exists_as_sent_unverified(message_ids)

        self.assertEqual(results, ([], []))
        self.assertEqual(exist1.send_status, '201')
        self.assertEqual(exist2.send_status, '201')
        self.assertEqual(exist3.send_status, '201')

        self.mox.VerifyAll()

    def test_mark_exists_as_sent_unverified_return_absent_exists(self):
        message_ids = ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b",
                       "9156b83e-f684-4ec3-8f94-7e41902f27aa"]

        exist1 = self.mox.CreateMockAnything()
        exist1.status = "pending"
        exist1.save()
        exist2 = self.mox.CreateMockAnything()
        exist2.status = "pending"
        exist2.save()
        self.mox.StubOutWithMock(ImageExists.objects, 'filter')
        ImageExists.objects.filter(message_id=message_ids[0]).AndReturn(
            [exist1, exist2])
        ImageExists.objects.filter(message_id=message_ids[1]).AndReturn([])
        self.mox.ReplayAll()

        results = ImageExists.mark_exists_as_sent_unverified(message_ids)

        self.assertEqual(results, (['9156b83e-f684-4ec3-8f94-7e41902f27aa'],
                                   []))
        self.assertEqual(exist1.send_status, '201')
        self.assertEqual(exist2.send_status, '201')

        self.mox.VerifyAll()

    def test_mark_exists_as_sent_unverified_and_return_exist_not_pending(self):
        message_ids = ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b",
                       "9156b83e-f684-4ec3-8f94-7e41902f27aa"]

        exist1 = self.mox.CreateMockAnything()
        exist1.status = "pending"
        exist1.save()
        exist2 = self.mox.CreateMockAnything()
        exist2.status = "verified"
        exist3 = self.mox.CreateMockAnything()
        exist3.status = "pending"
        exist3.save()
        self.mox.StubOutWithMock(ImageExists.objects, 'filter')
        ImageExists.objects.filter(message_id=message_ids[0]).AndReturn(
            [exist1, exist2])
        ImageExists.objects.filter(message_id=message_ids[1]).AndReturn(
            [exist3])
        self.mox.ReplayAll()

        results = ImageExists.mark_exists_as_sent_unverified(message_ids)

        self.assertEqual(results, ([],
                                   ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b"]))
        self.assertEqual(exist1.send_status, '201')
        self.assertEqual(exist3.send_status, '201')
        self.mox.VerifyAll()


class InstanceExistsTestCase(unittest.TestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_find_should_return_records_with_date_and_status_in_audit_period(self):
        end_max = datetime.utcnow()
        status = 'pending'
        unordered_results = self.mox.CreateMockAnything()
        expected_results = [1, 2]
        related_results = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(InstanceExists.objects, 'select_related')
        InstanceExists.objects.select_related().AndReturn(related_results)
        related_results.filter(audit_period_ending__lte=dt.dt_to_decimal(
            end_max), status=status).AndReturn(unordered_results)
        unordered_results.order_by('id').AndReturn(expected_results)
        self.mox.ReplayAll()

        results = InstanceExists.find(end_max, status)

        self.mox.VerifyAll()
        self.assertEqual(results, [1, 2])

    def test_mark_exists_as_sent_unverified(self):
        message_ids = ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b",
                       "9156b83e-f684-4ec3-8f94-7e41902f27aa"]

        exist1 = self.mox.CreateMockAnything()
        exist1.status = "pending"
        exist1.save()
        exist2 = self.mox.CreateMockAnything()
        exist2.status = "pending"
        exist2.save()
        self.mox.StubOutWithMock(InstanceExists.objects, 'get')
        InstanceExists.objects.get(message_id=message_ids[0]).AndReturn(exist1)
        InstanceExists.objects.get(message_id=message_ids[1]).AndReturn(exist2)
        self.mox.ReplayAll()

        results = InstanceExists.mark_exists_as_sent_unverified(message_ids)

        self.assertEqual(results, ([], []))
        self.assertEqual(exist1.send_status, '201')
        self.assertEqual(exist2.send_status, '201')
        self.mox.VerifyAll()

    def test_mark_exists_as_sent_unverified_return_absent_exists(self):
        message_ids = ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b",
                       "9156b83e-f684-4ec3-8f94-7e41902f27aa"]

        exist1 = self.mox.CreateMockAnything()
        exist1.status = "pending"
        exist1.save()
        self.mox.StubOutWithMock(InstanceExists.objects, 'get')
        InstanceExists.objects.get(message_id=message_ids[0]).AndReturn(exist1)
        InstanceExists.objects.get(message_id=message_ids[1]).AndRaise(
            Exception)
        self.mox.ReplayAll()

        results = InstanceExists.mark_exists_as_sent_unverified(message_ids)

        self.assertEqual(results, (['9156b83e-f684-4ec3-8f94-7e41902f27aa'],
                                   []))
        self.assertEqual(exist1.send_status, '201')
        self.mox.VerifyAll()

    def test_mark_exists_as_sent_unverified_and_return_exist_not_pending(self):
        message_ids = ["0708cb0b-6169-4d7c-9f58-3cf3d5bf694b",
                       "9156b83e-f684-4ec3-8f94-7e41902f27aa"]

        exist1 = self.mox.CreateMockAnything()
        exist1.status = "pending"
        exist1.save()
        exist2 = self.mox.CreateMockAnything()
        exist2.status = "verified"
        self.mox.StubOutWithMock(InstanceExists.objects, 'get')
        InstanceExists.objects.get(message_id=message_ids[0]).AndReturn(exist1)
        InstanceExists.objects.get(message_id=message_ids[1]).AndReturn(exist2)
        self.mox.ReplayAll()

        results = InstanceExists.mark_exists_as_sent_unverified(message_ids)

        self.assertEqual(results, ([],
                                   ["9156b83e-f684-4ec3-8f94-7e41902f27aa"]))
        self.assertEqual(exist1.send_status, '201')
        self.mox.VerifyAll()


########NEW FILE########
__FILENAME__ = test_notification
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json

import mox

from stacktach import notification, stacklog
from stacktach import utils

from stacktach.notification import Notification
from stacktach.notification import NovaNotification
from stacktach.notification import GlanceNotification
from stacktach import db
from stacktach import image_type
from tests.unit import StacktachBaseTestCase
from tests.unit.utils import BANDWIDTH_PUBLIC_OUTBOUND
from tests.unit.utils import REQUEST_ID_1
from tests.unit.utils import DECIMAL_DUMMY_TIME
from tests.unit.utils import DUMMY_TIME
from tests.unit.utils import TIMESTAMP_1
from tests.unit.utils import TENANT_ID_1
from tests.unit.utils import INSTANCE_ID_1
from tests.unit.utils import MESSAGE_ID_1


class NovaNotificationTestCase(StacktachBaseTestCase):

    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_factory_should_return_nova_notification_for_nova_exchange(
            self):
        body = {}
        deployment = "1"
        json = "{}"
        routing_key = "monitor.info"
        self.mox.StubOutWithMock(notification, 'NovaNotification')
        notification.NovaNotification(body, deployment, routing_key, json)

        self.mox.ReplayAll()
        notification.notification_factory(body, deployment, routing_key, json,
                                          'nova')
        self.mox.VerifyAll()

    def test_factory_should_return_glance_notification_for_glance_exchange(
            self):
        body = {}
        deployment = "1"
        json = "{}"
        routing_key = "monitor_glance.info"

        self.mox.StubOutWithMock(notification, 'GlanceNotification')
        notification.GlanceNotification(body, deployment, routing_key, json)

        self.mox.ReplayAll()
        notification.notification_factory(body, deployment, routing_key, json,
                                          'glance')
        self.mox.VerifyAll()

    def test_factory_should_return_notification_for_unknown_exchange(
            self):
        body = {}
        deployment = "1"
        json = "{}"
        routing_key = "unknown.info"

        self.mox.StubOutWithMock(notification, 'Notification')
        notification.Notification(body, deployment, routing_key, json)

        self.mox.ReplayAll()
        notification.notification_factory(body, deployment, routing_key, json,
                                          'unknown_exchange')
        self.mox.VerifyAll()

    def test_save_should_persist_nova_rawdata_to_database(self):
        body = {
            "event_type": "compute.instance.exists",
            '_context_request_id': REQUEST_ID_1,
            '_context_project_id': TENANT_ID_1,
            "timestamp": TIMESTAMP_1,
            "publisher_id": "compute.global.preprod-ord.ohthree.com",
            "payload": {
                'instance_id': INSTANCE_ID_1,
                "status": "saving",
                "container_format": "ovf",
                "properties": {
                    "image_type": "snapshot",
                },
                "tenant": "5877054",
                "old_state": 'old_state',
                "old_task_state": 'old_task',
                "image_meta": {
                    "org.openstack__1__architecture": 'os_arch',
                    "org.openstack__1__os_distro": 'os_distro',
                    "org.openstack__1__os_version": 'os_version',
                    "com.rackspace__1__options": 'rax_opt',
                },
                "state": 'state',
                "new_task_state": 'task',
                "bandwidth": {
                    "private": {"bw_in": 0, "bw_out": 264902},
                    "public": {"bw_in": 0, "bw_out": 1697240969}
                }
            }
        }
        deployment = "1"
        routing_key = "monitor.info"
        json_body = json.dumps([routing_key, body])
        raw = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(db, 'create_nova_rawdata')
        db.create_nova_rawdata(
            deployment="1",
            tenant=TENANT_ID_1,
            json=json_body,
            routing_key=routing_key,
            when=utils.str_time_to_unix(TIMESTAMP_1),
            publisher="compute.global.preprod-ord.ohthree.com",
            event="compute.instance.exists",
            service="compute",
            host="global.preprod-ord.ohthree.com",
            instance=INSTANCE_ID_1,
            request_id=REQUEST_ID_1,
            image_type=image_type.get_numeric_code(body['payload']),
            old_state='old_state',
            old_task='old_task',
            os_architecture='os_arch',
            os_distro='os_distro',
            os_version='os_version',
            rax_options='rax_opt',
            state='state',
            task='task').AndReturn(raw)

        self.mox.ReplayAll()

        notification = NovaNotification(body, deployment, routing_key, json_body)
        self.assertEquals(notification.save(), raw)
        self.mox.VerifyAll()

    def test_bandwidth_public_out_is_read_from_json(self):
        body = {
            "event_type": "compute.instance.exists",
            '_context_request_id': REQUEST_ID_1,
            '_context_project_id': TENANT_ID_1,
            "timestamp": TIMESTAMP_1,
            "publisher_id": "compute.global.preprod-ord.ohthree.com",
            "payload": {
                'instance_id': INSTANCE_ID_1,
                "status": "saving",
                "container_format": "ovf",
                "properties": {
                    "image_type": "snapshot",
                },
                "tenant": "5877054",
                "old_state": 'old_state',
                "old_task_state": 'old_task',
                "image_meta": {
                    "org.openstack__1__architecture": 'os_arch',
                    "org.openstack__1__os_distro": 'os_distro',
                    "org.openstack__1__os_version": 'os_version',
                    "com.rackspace__1__options": 'rax_opt',
                },
                "state": 'state',
                "new_task_state": 'task',
                "bandwidth": {
                    "private": {"bw_in": 0, "bw_out": 264902},
                    "public": {"bw_in": 0, "bw_out": BANDWIDTH_PUBLIC_OUTBOUND}
                }
            }
        }
        deployment = "1"
        routing_key = "monitor.info"
        json_body = json.dumps([routing_key, body])
        notification = NovaNotification(body, deployment, routing_key,
                                        json_body)
        self.assertEquals(notification.bandwidth_public_out,
                          BANDWIDTH_PUBLIC_OUTBOUND)

    def test_bandwidth_public_out_is_set_to_0_if_not_found_in_json(self):
        body = {
            "event_type": "compute.instance.exists",
            '_context_request_id': REQUEST_ID_1,
            '_context_project_id': TENANT_ID_1,
            "timestamp": TIMESTAMP_1,
            "publisher_id": "compute.global.preprod-ord.ohthree.com",
            "payload": {
                'instance_id': INSTANCE_ID_1,
                "status": "saving",
                "container_format": "ovf",
                "properties": {
                    "image_type": "snapshot",
                },
                "tenant": "5877054",
                "old_state": 'old_state',
                "old_task_state": 'old_task',
                "image_meta": {
                    "org.openstack__1__architecture": 'os_arch',
                    "org.openstack__1__os_distro": 'os_distro',
                    "org.openstack__1__os_version": 'os_version',
                    "com.rackspace__1__options": 'rax_opt',
                },
                "state": 'state',
                "new_task_state": 'task'
            }
        }
        deployment = "1"
        routing_key = "monitor.info"
        json_body = json.dumps([routing_key, body])
        notification = NovaNotification(body, deployment, routing_key,
                                        json_body)
        self.assertEquals(notification.bandwidth_public_out, 0)


    def test_bandwidth_public_out_is_set_to_blank_object_if_none_in_json(self):
        body = {
            "event_type": "compute.instance.exists",
            '_context_request_id': REQUEST_ID_1,
            '_context_project_id': TENANT_ID_1,
            "timestamp": TIMESTAMP_1,
            "publisher_id": "compute.global.preprod-ord.ohthree.com",
            "payload": {
                'instance_id': INSTANCE_ID_1,
                "status": "saving",
                "container_format": "ovf",
                "properties": {
                    "image_type": "snapshot",
                },
                "bandwidth": None,
                "tenant": "5877054",
                "old_state": 'old_state',
                "old_task_state": 'old_task',
                "image_meta": {
                    "org.openstack__1__architecture": 'os_arch',
                    "org.openstack__1__os_distro": 'os_distro',
                    "org.openstack__1__os_version": 'os_version',
                    "com.rackspace__1__options": 'rax_opt',
                },
                "state": 'state',
                "new_task_state": 'task'
            }
        }
        deployment = "1"
        routing_key = "monitor.info"
        json_body = json.dumps([routing_key, body])
        notification = NovaNotification(body, deployment, routing_key,
                                        json_body)
        self.assertEquals(notification.bandwidth_public_out, 0)


class GlanceNotificationTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_save_should_persist_glance_rawdata_to_database(self):
        body = {
            "event_type": "image.upload",
            "timestamp": "2013-06-20 17:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": {
                "status": "saving",
                "properties": {
                    "image_type": "snapshot",
                    "instance_uuid": INSTANCE_ID_1,
                },
                "owner": TENANT_ID_1,
                "id": "2df2ccf6-bc1b-4853-aab0-25fda346b3bb",
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])
        raw = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(db, 'create_glance_rawdata')
        db.create_glance_rawdata(
            deployment="1",
            owner=TENANT_ID_1,
            json=json_body,
            routing_key=routing_key,
            when=utils.str_time_to_unix("2013-06-20 17:31:57.939614"),
            publisher="glance-api01-r2961.global.preprod-ord.ohthree.com",
            event="image.upload",
            service="glance-api01-r2961",
            host="global.preprod-ord.ohthree.com",
            instance=INSTANCE_ID_1,
            request_id='',
            image_type=0,
            status="saving",
            uuid="2df2ccf6-bc1b-4853-aab0-25fda346b3bb").AndReturn(raw)

        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        self.assertEquals(notification.save(), raw)
        self.mox.VerifyAll()

    def test_save_should_persist_glance_rawdata_erro_payload_to_database(self):
        body = {
            "event_type": "image.upload",
            "timestamp": "2013-06-20 17:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": "error_message"
        }
        deployment = "1"
        routing_key = "glance_monitor.error"
        json_body = json.dumps([routing_key, body])
        raw = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(db, 'create_glance_rawdata')
        db.create_glance_rawdata(
            deployment="1",
            owner=None,
            json=json_body,
            routing_key=routing_key,
            when=utils.str_time_to_unix("2013-06-20 17:31:57.939614"),
            publisher="glance-api01-r2961.global.preprod-ord.ohthree.com",
            event="image.upload",
            service="glance-api01-r2961",
            host="global.preprod-ord.ohthree.com",
            instance=None,
            request_id='',
            image_type=None,
            status=None,
            uuid=None).AndReturn(raw)

        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        self.assertEquals(notification.save(), raw)
        self.mox.VerifyAll()

    def test_save_usage_should_persist_image_usage(self):
        raw = self.mox.CreateMockAnything()
        size = 123
        uuid = "2df2ccf6-bc1b-4853-aab0-25fda346b3bb"
        body = {
            "event_type": "image.upload",
            "timestamp": "2013-06-20 18:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": {
                "created_at": str(DUMMY_TIME),
                "size": size,
                "owner": TENANT_ID_1,
                "id": "2df2ccf6-bc1b-4853-aab0-25fda346b3bb",
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])

        self.mox.StubOutWithMock(db, 'create_image_usage')
        db.create_image_usage(
            created_at=utils.str_time_to_unix(str(DUMMY_TIME)),
            owner=TENANT_ID_1,
            last_raw=raw,
            size=size,
            uuid=uuid).AndReturn(raw)
        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save_usage(raw)
        self.mox.VerifyAll()

    def test_save_delete_should_persist_image_delete(self):
        raw = self.mox.CreateMockAnything()
        uuid = "2df2ccf6-bc1b-4853-aab0-25fda346b3bb"
        deleted_at = "2013-06-20 14:31:57.939614"
        body = {
            "event_type": "image.delete",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": {
                "id": "2df2ccf6-bc1b-4853-aab0-25fda346b3bb",
                "deleted_at": deleted_at
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])

        self.mox.StubOutWithMock(db, 'create_image_delete')
        db.create_image_delete(
            raw=raw,
            uuid=uuid,
            deleted_at=utils.str_time_to_unix(deleted_at)).AndReturn(raw)
        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save_delete(raw)
        self.mox.VerifyAll()


class NotificationTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_save_should_persist_generic_rawdata_to_database(self):
        body = {
            "event_type": "image.upload",
            '_context_request_id': REQUEST_ID_1,
            '_context_project_id': TENANT_ID_1,
            "timestamp": TIMESTAMP_1,
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "message_id": MESSAGE_ID_1,
            "payload": {
                'instance_id': INSTANCE_ID_1,
                "status": "saving",
                "container_format": "ovf",
                "tenant": "5877054"
            }
        }
        deployment = "1"
        routing_key = "generic_monitor.info"
        json_body = json.dumps([routing_key, body])
        raw = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(db, 'create_generic_rawdata')
        db.create_generic_rawdata(
            deployment="1",
            tenant=TENANT_ID_1,
            json=json_body,
            routing_key=routing_key,
            when=utils.str_time_to_unix(TIMESTAMP_1),
            publisher="glance-api01-r2961.global.preprod-ord.ohthree.com",
            event="image.upload",
            service="glance-api01-r2961",
            host="global.preprod-ord.ohthree.com",
            instance=INSTANCE_ID_1,
            request_id=REQUEST_ID_1,
            message_id=MESSAGE_ID_1).AndReturn(raw)

        self.mox.ReplayAll()

        notification = Notification(body, deployment, routing_key, json_body)
        self.assertEquals(notification.save(), raw)
        self.mox.VerifyAll()


class GlanceExistsNotificationTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_save_glancerawdata(self):
        raw = self.mox.CreateMockAnything()
        audit_period_beginning = "2013-05-20 17:31:57.939614"
        audit_period_ending = "2013-06-20 17:31:57.939614"
        created_at = "2013-05-20 19:31:57.939614"
        size = 123
        uuid = "2df2ccf6-bc1b-4853-aab0-25fda346b3bb"
        body = {
            "event_type": "image.exists",
            "timestamp": "2013-06-20 18:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": {
                "audit_period_beginning": audit_period_beginning,
                "audit_period_ending": audit_period_ending,
                "owner": TENANT_ID_1,
                "images":
                [
                    {
                        "created_at": created_at,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": None,
                    },
                    {
                        "created_at": str(DUMMY_TIME),
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": None,
                    }
                ]
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])

        self.mox.StubOutWithMock(db, 'create_glance_rawdata')

        db.create_glance_rawdata(
            deployment="1",
            owner="testtenantid1",
            json=json_body,
            routing_key=routing_key,
            when=utils.str_time_to_unix("2013-06-20 18:31:57.939614"),
            publisher="glance-api01-r2961.global.preprod-ord.ohthree.com",
            event="image.exists",
            service="glance-api01-r2961",
            host="global.preprod-ord.ohthree.com",
            instance=None,
            request_id='',
            image_type=0,
            status=None,
            uuid=None).AndReturn(raw)

        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save()
        self.mox.VerifyAll()

    def test_save_image_exists_with_created_at_but_deleted_at_none(self):
        raw = self.mox.CreateMockAnything()
        audit_period_beginning = "2013-05-20 17:31:57.939614"
        audit_period_ending = "2013-06-20 17:31:57.939614"
        created_at = "2013-05-20 19:31:57.939614"
        size = 123
        uuid = "2df2ccf6-bc1b-4853-aab0-25fda346b3bb"
        body = {
            "event_type": "image.exists",
            "timestamp": "2013-06-20 18:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "message_id": "d14cfa51-6a0e-4cf8-9130-804738be96d2",
            "payload": {
                "audit_period_beginning": audit_period_beginning,
                "audit_period_ending": audit_period_ending,
                "owner": TENANT_ID_1,
                "images":
                [
                    {
                        "created_at": created_at,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": None,
                    },
                    {
                        "created_at": created_at,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": None,
                    }
                ]
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])

        self.mox.StubOutWithMock(db, 'create_image_exists')
        self.mox.StubOutWithMock(db, 'get_image_usage')

        for i in range(0, 2):
            db.get_image_usage(uuid=uuid).AndReturn(None)
            db.create_image_exists(
                created_at=utils.str_time_to_unix(created_at),
                owner=TENANT_ID_1,
                raw=raw,
                audit_period_beginning=utils.str_time_to_unix(audit_period_beginning),
                audit_period_ending=utils.str_time_to_unix(audit_period_ending),
                size=size,
                uuid=uuid,
                usage=None,
                message_id="d14cfa51-6a0e-4cf8-9130-804738be96d2").AndReturn(raw)

        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save_exists(raw)
        self.mox.VerifyAll()

    def test_save_image_exists_with_created_at_and_deleted_at(self):
        raw = self.mox.CreateMockAnything()
        delete = self.mox.CreateMockAnything()
        audit_period_beginning = "2013-05-20 17:31:57.939614"
        audit_period_ending = "2013-06-20 17:31:57.939614"
        created_at = "2013-05-20 19:31:57.939614"
        deleted_at = "2013-05-20 21:31:57.939614"
        size = 123
        uuid = "2df2ccf6-bc1b-4853-aab0-25fda346b3bb"
        body = {
            "event_type": "image.exists",
            "timestamp": "2013-06-20 18:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "message_id": "d14cfa51-6a0e-4cf8-9130-804738be96d2",
            "payload": {
                "audit_period_beginning": audit_period_beginning,
                "audit_period_ending": audit_period_ending,
                "owner": TENANT_ID_1,
                "images":
                [
                    {
                        "created_at": created_at,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": deleted_at,
                    },
                    {
                        "created_at": created_at,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": deleted_at,
                    }
                ]
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])
        self.mox.StubOutWithMock(db, 'create_image_exists')
        self.mox.StubOutWithMock(db, 'get_image_usage')
        self.mox.StubOutWithMock(db, 'get_image_delete')

        for i in range(0, 2):
            db.get_image_usage(uuid=uuid).AndReturn(None)
            db.get_image_delete(uuid=uuid).AndReturn(delete)
            db.create_image_exists(
                created_at=utils.str_time_to_unix(created_at),
                owner=TENANT_ID_1,
                raw=raw,
                audit_period_beginning=utils.str_time_to_unix(audit_period_beginning),
                audit_period_ending=utils.str_time_to_unix(audit_period_ending),
                size=size,
                uuid=uuid,
                usage=None,
                delete=delete,
                deleted_at=utils.str_time_to_unix(deleted_at),
                message_id="d14cfa51-6a0e-4cf8-9130-804738be96d2").AndReturn(raw)

        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save_exists(raw)
        self.mox.VerifyAll()

    def test_save_image_exists_without_created_at(self):
        raw = self.mox.CreateMockAnything()
        raw.id = 1
        audit_period_beginning = "2013-05-20 17:31:57.939614"
        audit_period_ending = "2013-06-20 17:31:57.939614"
        size = 123
        uuid = "2df2ccf6-bc1b-4853-aab0-25fda346b3bb"
        body = {
            "event_type": "image.exists",
            "timestamp": "2013-06-20 18:31:57.939614",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": {
                "audit_period_beginning": audit_period_beginning,
                "audit_period_ending": audit_period_ending,
                "owner": TENANT_ID_1,
                "images":
                [
                    {
                        "created_at": None,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": None,
                    },
                    {
                        "created_at": None,
                        "id": uuid,
                        "size": size,
                        "status": "saving",
                        "properties": {"instance_uuid": INSTANCE_ID_1},
                        "deleted_at": None,
                    }
                ]
            }
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])
        self.mox.StubOutWithMock(stacklog, 'warn')
        stacklog.warn("Ignoring exists without created_at. GlanceRawData(1)")
        stacklog.warn("Ignoring exists without created_at. GlanceRawData(1)")
        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save_exists(raw)
        self.mox.VerifyAll()

    def test_save_exists_should_log_warning_when_payload_is_invalid(self):
        raw = self.mox.CreateMockAnything()
        raw.id = 1
        body = {
            "event_type": "image.exists",
            "publisher_id": "glance-api01-r2961.global.preprod-ord.ohthree.com",
            "payload": []
        }
        deployment = "1"
        routing_key = "glance_monitor.info"
        json_body = json.dumps([routing_key, body])
        self.mox.StubOutWithMock(stacklog, 'warn')
        stacklog.warn("Received exists with invalid payload GlanceRawData(1)")
        self.mox.ReplayAll()

        notification = GlanceNotification(body, deployment, routing_key,
                                          json_body)
        notification.save_exists(raw)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_nova_verifier
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import decimal
import json
import uuid

import kombu.common
import kombu.entity
import kombu.pools
import mox

from stacktach import datetime_to_decimal as dt
from stacktach import stacklog
from stacktach import models
from tests.unit import StacktachBaseTestCase
from tests.unit import utils
from utils import make_verifier_config, LAUNCHED_AT_1, INSTANCE_FLAVOR_ID_1
from utils import INSTANCE_FLAVOR_ID_2, FLAVOR_FIELD_NAME, DELETED_AT_1
from utils import LAUNCHED_AT_2, DELETED_AT_2
from utils import INSTANCE_ID_1
from utils import RAX_OPTIONS_1
from utils import RAX_OPTIONS_2
from utils import OS_DISTRO_1
from utils import OS_DISTRO_2
from utils import OS_ARCH_1
from utils import OS_ARCH_2
from utils import OS_VERSION_1
from utils import OS_VERSION_2
from utils import TENANT_ID_1
from utils import TENANT_ID_2
from utils import NOVA_VERIFIER_EVENT_TYPE
from verifier import nova_verifier
from verifier import config
from verifier import NullFieldException
from verifier import WrongTypeException
from verifier import AmbiguousResults
from verifier import FieldMismatch
from verifier import NotFound
from verifier import VerificationException


class NovaVerifierVerifyForLaunchTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.mox.StubOutWithMock(models, 'InstanceUsage',
                                 use_mock_anything=True)
        models.InstanceUsage.objects = self.mox.CreateMockAnything()

        self._setup_verifier()

    def _setup_verifier(self):
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.verifier = nova_verifier.NovaVerifier(config,
            pool=self.pool, reconciler=self.reconciler)

    def tearDown(self):
        self.mox.UnsetStubs()
        self.verifier = None
        self.pool = None
        self.verifier_notif = None

    def test_verify_for_launch(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")

        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        exist.dummy_flavor_field_name = 'dummy_flavor'
        exist.tenant = TENANT_ID_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.launched_at = decimal.Decimal('1.1')
        exist.usage.dummy_flavor_field_name = 'dummy_flavor'
        exist.usage.tenant = TENANT_ID_1
        self.mox.ReplayAll()

        nova_verifier._verify_for_launch(exist)

        self.mox.VerifyAll()

    def test_verify_for_launch_launched_at_in_range(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self.mox.CreateMockAnything()
        exist.usage = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.0')
        exist.dummy_flavor_field_name = 'dummy_flavor'
        exist.usage.launched_at = decimal.Decimal('1.4')
        exist.usage.dummy_flavor_field_name = 'dummy_flavor'
        self.mox.ReplayAll()

        result = nova_verifier._verify_for_launch(exist)
        self.assertIsNone(result)

        self.mox.VerifyAll()

    def test_verify_for_launch_launched_at_missmatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")

        exist = self.mox.CreateMockAnything()
        exist.instance = INSTANCE_ID_1
        exist.usage = self.mox.CreateMockAnything()
        exist.launched_at = LAUNCHED_AT_1
        exist.dummy_flavor_field_name = 'dummy_flavor'
        exist.usage.launched_at = LAUNCHED_AT_2
        exist.usage.dummy_flavor_field_name = 'dummy_flavor'
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as fm:
            nova_verifier._verify_for_launch(exist)
        exception = fm.exception

        entity_1 = {'name': 'exists', 'value': LAUNCHED_AT_1}
        entity_2 = {'name': 'launches', 'value': LAUNCHED_AT_2}
        self.assertEqual(exception.field_name, 'launched_at')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_for_launch_flavor_id_missmatch(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn(FLAVOR_FIELD_NAME)

        exist = self.mox.CreateMockAnything()
        exist.instance = INSTANCE_ID_1
        exist.usage = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal(LAUNCHED_AT_1)
        exist.flavor_field_name = INSTANCE_FLAVOR_ID_1
        exist.usage.launched_at = decimal.Decimal(LAUNCHED_AT_1)
        exist.usage.flavor_field_name = INSTANCE_FLAVOR_ID_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as fm:
            nova_verifier._verify_for_launch(exist)
        exception = fm.exception

        entity_1 = {'name': 'exists', 'value': INSTANCE_FLAVOR_ID_1}
        entity_2 = {'name': 'launches', 'value': INSTANCE_FLAVOR_ID_2}
        self.assertEqual(exception.field_name, 'flavor_field_name')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_for_launch_tenant_id_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn(FLAVOR_FIELD_NAME)

        exist = self.mox.CreateMockAnything()
        exist.tenant = TENANT_ID_1
        exist.instance = INSTANCE_ID_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.tenant = TENANT_ID_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            nova_verifier._verify_for_launch(exist)
        exception = cm.exception

        entity_1 = {'name': 'exists', 'value': TENANT_ID_1}
        entity_2 = {'name': 'launches', 'value': TENANT_ID_2}
        self.assertEqual(exception.field_name, 'tenant')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_for_launch_rax_options_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")
        exist = self.mox.CreateMockAnything()
        exist.rax_options = RAX_OPTIONS_1
        exist.instance = INSTANCE_ID_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.rax_options = RAX_OPTIONS_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            nova_verifier._verify_for_launch(exist)
        exception = cm.exception
        entity_1 = {'name': 'exists', 'value': RAX_OPTIONS_1}
        entity_2 = {'name': 'launches', 'value': RAX_OPTIONS_2}
        self.assertEqual(exception.field_name, 'rax_options')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)

        self.mox.VerifyAll()

    def test_verify_for_launch_os_distro_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")
        exist = self.mox.CreateMockAnything()
        exist.os_distro = OS_DISTRO_1
        exist.instance = INSTANCE_ID_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.os_distro = OS_DISTRO_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            nova_verifier._verify_for_launch(exist)
        exception = cm.exception

        entity_1 = {'name': 'exists', 'value': OS_DISTRO_1}
        entity_2 = {'name': 'launches', 'value': OS_DISTRO_2}
        self.assertEqual(exception.field_name, 'os_distro')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)

        self.mox.VerifyAll()

    def test_verify_for_launch_os_architecture_mismatch(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")

        exist = self.mox.CreateMockAnything()
        exist.instance = INSTANCE_ID_1
        exist.os_architecture = OS_ARCH_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.os_architecture = OS_ARCH_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            nova_verifier._verify_for_launch(exist)
        exception = cm.exception

        entity_1 = {'name': 'exists', 'value': OS_ARCH_1}
        entity_2 = {'name': 'launches', 'value': OS_ARCH_2}
        self.assertEqual(exception.field_name, 'os_architecture')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_for_launch_os_version_mismatch(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")

        exist = self.mox.CreateMockAnything()
        exist.os_version = OS_VERSION_1
        exist.instance = INSTANCE_ID_1

        exist.usage = self.mox.CreateMockAnything()
        exist.usage.os_version = OS_VERSION_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as cm:
            nova_verifier._verify_for_launch(exist)
        exception = cm.exception

        entity_1 = {'name': 'exists', 'value': OS_VERSION_1}
        entity_2 = {'name': 'launches', 'value': OS_VERSION_2}
        self.assertEqual(exception.field_name, 'os_version')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_for_launch_late_usage(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn("flavor_field_name")

        exist = self.mox.CreateMockAnything()
        exist.usage = None
        exist.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        exist.launched_at = launched_at
        exist.dummy_flavor_field_name = 'dummy_flavor'
        results = self.mox.CreateMockAnything()
        models.InstanceUsage.objects.filter(instance=INSTANCE_ID_1)\
            .AndReturn(results)
        results.count().AndReturn(2)
        models.InstanceUsage.find(INSTANCE_ID_1, dt.dt_from_decimal(
            launched_at)).AndReturn(results)
        results.count().AndReturn(1)
        usage = self.mox.CreateMockAnything()
        results.__getitem__(0).AndReturn(usage)
        usage.launched_at = decimal.Decimal('1.1')
        usage.dummy_flavor_field_name = 'dummy_flavor'
        self.mox.ReplayAll()

        nova_verifier._verify_for_launch(exist)
        self.mox.VerifyAll()

    def test_verify_for_launch_no_usage(self):
        exist = self.mox.CreateMockAnything()
        exist.usage = None
        exist.instance = INSTANCE_ID_1
        exist.launched_at = decimal.Decimal('1.1')
        exist.dummy_flavor_field_name = 'dummy_flavor'
        results = self.mox.CreateMockAnything()
        models.InstanceUsage.objects.filter(instance=INSTANCE_ID_1) \
            .AndReturn(results)
        results.count().AndReturn(0)
        self.mox.ReplayAll()

        with self.assertRaises(NotFound) as nf:
            nova_verifier._verify_for_launch(exist)
        exception = nf.exception
        self.assertEqual(exception.object_type, 'InstanceUsage')
        self.assertEqual(exception.search_params, {'instance': INSTANCE_ID_1})

        self.mox.VerifyAll()

    def test_verify_for_launch_late_ambiguous_usage(self):
        exist = self.mox.CreateMockAnything()
        exist.usage = None
        exist.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        exist.launched_at = launched_at
        exist.dummy_flavor_field_name = 'dummy_flavor'
        results = self.mox.CreateMockAnything()
        models.InstanceUsage.objects.filter(
            instance=INSTANCE_ID_1).AndReturn(results)
        results.count().AndReturn(1)
        models.InstanceUsage.find(
            INSTANCE_ID_1, dt.dt_from_decimal(launched_at)).AndReturn(results)
        results.count().AndReturn(2)
        self.mox.ReplayAll()

        with self.assertRaises(AmbiguousResults) as ar:
            nova_verifier._verify_for_launch(exist)
        exception = ar.exception
        self.assertEqual(exception.object_type, 'InstanceUsage')
        search_params = {'instance': INSTANCE_ID_1,
                         'launched_at': decimal.Decimal('1.1')}
        self.assertEqual(exception.search_params, search_params)

        self.mox.VerifyAll()


class NovaVerifierVerifyForDeleteTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self._setup_verifier()
        self.mox.StubOutWithMock(models, 'InstanceDeletes',
                                 use_mock_anything=True)
        models.InstanceDeletes.objects = self.mox.CreateMockAnything()
    def _setup_verifier(self):
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.verifier = nova_verifier.NovaVerifier(config,
            pool=self.pool, reconciler=self.reconciler)

    def tearDown(self):
        self.mox.UnsetStubs()
        self.verifier = None
        self.pool = None
        self.verifier_notif = None

    def test_verify_for_delete(self):
        exist = self.mox.CreateMockAnything()
        exist.delete = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        exist.deleted_at = decimal.Decimal('5.1')
        exist.delete.launched_at = decimal.Decimal('1.1')
        exist.delete.deleted_at = decimal.Decimal('5.1')
        self.mox.ReplayAll()

        nova_verifier._verify_for_delete(exist)
        self.mox.VerifyAll()

    def test_verify_for_delete_found_delete(self):
        exist = self.mox.CreateMockAnything()
        exist.delete = None
        exist.instance = INSTANCE_ID_1
        exist.launched_at = decimal.Decimal('1.1')
        exist.deleted_at = decimal.Decimal('5.1')
        launched_at = decimal.Decimal('1.1')
        results = self.mox.CreateMockAnything()
        models.InstanceDeletes.find(INSTANCE_ID_1, dt.dt_from_decimal(
                                    launched_at)).AndReturn(results)
        results.count().AndReturn(1)
        delete = self.mox.CreateMockAnything()
        delete.launched_at = decimal.Decimal('1.1')
        delete.deleted_at = decimal.Decimal('5.1')
        results.__getitem__(0).AndReturn(delete)

        self.mox.ReplayAll()

        nova_verifier._verify_for_delete(exist)
        self.mox.VerifyAll()

    def test_verify_for_delete_non_delete(self):
        launched_at = decimal.Decimal('1.1')
        deleted_at = decimal.Decimal('1.1')
        exist = self.mox.CreateMockAnything()
        exist.delete = None
        exist.instance = INSTANCE_ID_1
        exist.launched_at = launched_at
        exist.deleted_at = None
        exist.audit_period_ending = deleted_at
        results = self.mox.CreateMockAnything()
        models.InstanceDeletes.find(
            INSTANCE_ID_1, dt.dt_from_decimal(launched_at),
            dt.dt_from_decimal(deleted_at)).AndReturn(results)
        results.count().AndReturn(0)

        self.mox.ReplayAll()

        nova_verifier._verify_for_delete(exist)
        self.mox.VerifyAll()

    def test_verify_for_delete_non_delete_found_deletes(self):
        exist = self.mox.CreateMockAnything()
        exist.delete = None
        exist.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        deleted_at = decimal.Decimal('1.3')
        exist.launched_at = launched_at
        exist.deleted_at = None
        exist.audit_period_ending = deleted_at
        results = self.mox.CreateMockAnything()
        models.InstanceDeletes.find(
            INSTANCE_ID_1, dt.dt_from_decimal(launched_at),
            dt.dt_from_decimal(deleted_at)).AndReturn(results)
        results.count().AndReturn(1)

        self.mox.ReplayAll()

        with self.assertRaises(VerificationException) as ve:
            nova_verifier._verify_for_delete(exist)
        exception = ve.exception
        msg = 'Found InstanceDeletes for non-delete exist'
        self.assertEqual(exception.reason, msg)

        self.mox.VerifyAll()

    def test_verify_for_delete_launched_at_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exist = self.mox.CreateMockAnything()
        exist.instance = INSTANCE_ID_1
        exist.launched_at = LAUNCHED_AT_1
        exist.deleted_at = DELETED_AT_1
        exist.delete = self.mox.CreateMockAnything()
        exist.delete.launched_at = LAUNCHED_AT_2
        exist.delete.deleted_at = DELETED_AT_1
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as fm:
            nova_verifier._verify_for_delete(exist)
        exception = fm.exception

        entity_1 = {'name': 'exists', 'value': LAUNCHED_AT_1}
        entity_2 = {'name': 'deletes', 'value': LAUNCHED_AT_2}
        self.assertEqual(exception.field_name, 'launched_at')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()

    def test_verify_for_delete_deleted_at_mismatch(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exist = self.mox.CreateMockAnything()
        exist.instance = INSTANCE_ID_1
        exist.launched_at = LAUNCHED_AT_1
        exist.deleted_at = DELETED_AT_1
        exist.delete = self.mox.CreateMockAnything()
        exist.delete.launched_at = LAUNCHED_AT_1
        exist.delete.deleted_at = DELETED_AT_2
        self.mox.ReplayAll()

        with self.assertRaises(FieldMismatch) as fm:
            nova_verifier._verify_for_delete(exist)
        exception = fm.exception
        entity_1 = {'name': 'exists', 'value': DELETED_AT_1}
        entity_2 = {'name': 'deletes', 'value': DELETED_AT_2}
        self.assertEqual(exception.field_name, 'deleted_at')
        self.assertEqual(exception.entity_1, entity_1)
        self.assertEqual(exception.entity_2, entity_2)
        self.mox.VerifyAll()


class NovaVerifierReconcileTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.mox.StubOutWithMock(models, 'InstanceReconcile',
                                 use_mock_anything=True)
        models.InstanceReconcile.objects = self.mox.CreateMockAnything()
        self._setup_verifier()

    def _setup_verifier(self):
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.verifier = nova_verifier.NovaVerifier(config,
            pool=self.pool, reconciler=self.reconciler)

    def tearDown(self):
        self.mox.UnsetStubs()
        self.verifier = None
        self.pool = None
        self.verifier_notif = None

    def test_reconcile_failed(self):
        self.verifier.reconcile = True
        exists1 = self.mox.CreateMockAnything()
        exists2 = self.mox.CreateMockAnything()
        self.verifier.failed = [exists1, exists2]
        self.reconciler.failed_validation(exists1)
        self.reconciler.failed_validation(exists2)
        self.mox.ReplayAll()
        self.verifier.reconcile_failed()
        self.assertEqual(len(self.verifier.failed), 0)
        self.mox.VerifyAll()

    def test_verify_with_reconciled_data(self):
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        exists.launched_at = launched_at
        results = self.mox.CreateMockAnything()
        models.InstanceReconcile.objects.filter(instance=INSTANCE_ID_1)\
                                        .AndReturn(results)
        results.count().AndReturn(1)
        launched_at = dt.dt_from_decimal(decimal.Decimal('1.1'))
        recs = self.mox.CreateMockAnything()
        models.InstanceReconcile.find(INSTANCE_ID_1, launched_at).AndReturn(recs)
        recs.count().AndReturn(1)
        reconcile = self.mox.CreateMockAnything()
        reconcile.deleted_at = None
        recs[0].AndReturn(reconcile)
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        nova_verifier._verify_for_launch(exists, launch=reconcile,
                                      launch_type='InstanceReconcile')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        nova_verifier._verify_for_delete(exists, delete=None,
                                      delete_type='InstanceReconcile')
        self.mox.ReplayAll()
        nova_verifier._verify_with_reconciled_data(exists)
        self.mox.VerifyAll()

    def test_verify_with_reconciled_data_deleted(self):
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        deleted_at = decimal.Decimal('2.1')
        exists.launched_at = launched_at
        exists.deleted_at = deleted_at
        results = self.mox.CreateMockAnything()
        models.InstanceReconcile.objects.filter(instance=INSTANCE_ID_1)\
                                        .AndReturn(results)
        results.count().AndReturn(1)
        launched_at = dt.dt_from_decimal(decimal.Decimal('1.1'))
        recs = self.mox.CreateMockAnything()
        models.InstanceReconcile.find(INSTANCE_ID_1, launched_at).AndReturn(recs)
        recs.count().AndReturn(1)
        reconcile = self.mox.CreateMockAnything()
        reconcile.deleted_at = deleted_at
        recs[0].AndReturn(reconcile)
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        nova_verifier._verify_for_launch(exists, launch=reconcile,
                                      launch_type='InstanceReconcile')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        nova_verifier._verify_for_delete(exists, delete=reconcile,
                                      delete_type='InstanceReconcile')
        self.mox.ReplayAll()
        nova_verifier._verify_with_reconciled_data(exists)
        self.mox.VerifyAll()

    def test_verify_with_reconciled_data_not_launched(self):
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        exists.launched_at = None
        self.mox.ReplayAll()
        with self.assertRaises(VerificationException) as cm:
            nova_verifier._verify_with_reconciled_data(exists)
        exception = cm.exception
        self.assertEquals(exception.reason, 'Exists without a launched_at')
        self.mox.VerifyAll()

    def test_verify_with_reconciled_data_ambiguous_results(self):
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        deleted_at = decimal.Decimal('2.1')
        exists.launched_at = launched_at
        exists.deleted_at = deleted_at
        results = self.mox.CreateMockAnything()
        models.InstanceReconcile.objects.filter(instance=INSTANCE_ID_1)\
                                        .AndReturn(results)
        results.count().AndReturn(1)
        launched_at = dt.dt_from_decimal(decimal.Decimal('1.1'))
        recs = self.mox.CreateMockAnything()
        models.InstanceReconcile.find(INSTANCE_ID_1, launched_at).AndReturn(recs)
        recs.count().AndReturn(2)
        self.mox.ReplayAll()
        with self.assertRaises(AmbiguousResults) as cm:
            nova_verifier._verify_with_reconciled_data(exists)
        exception = cm.exception
        self.assertEquals(exception.object_type, 'InstanceReconcile')
        self.mox.VerifyAll()

    def test_verify_with_reconciled_data_instance_not_found(self):
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        deleted_at = decimal.Decimal('2.1')
        exists.launched_at = launched_at
        exists.deleted_at = deleted_at
        results = self.mox.CreateMockAnything()
        models.InstanceReconcile.objects.filter(instance=INSTANCE_ID_1)\
                                        .AndReturn(results)
        results.count().AndReturn(0)
        self.mox.ReplayAll()
        with self.assertRaises(NotFound) as cm:
            nova_verifier._verify_with_reconciled_data(exists)
        exception = cm.exception
        self.assertEquals(exception.object_type, 'InstanceReconcile')
        self.mox.VerifyAll()

    def test_verify_with_reconciled_data_reconcile_not_found(self):
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = decimal.Decimal('1.1')
        deleted_at = decimal.Decimal('2.1')
        exists.launched_at = launched_at
        exists.deleted_at = deleted_at
        results = self.mox.CreateMockAnything()
        models.InstanceReconcile.objects.filter(instance=INSTANCE_ID_1)\
                                        .AndReturn(results)
        results.count().AndReturn(1)
        launched_at = dt.dt_from_decimal(decimal.Decimal('1.1'))
        recs = self.mox.CreateMockAnything()
        models.InstanceReconcile.find(INSTANCE_ID_1, launched_at).AndReturn(recs)
        recs.count().AndReturn(0)
        self.mox.ReplayAll()
        with self.assertRaises(NotFound) as cm:
            nova_verifier._verify_with_reconciled_data(exists)
        exception = cm.exception
        self.assertEquals(exception.object_type, 'InstanceReconcile')
        self.mox.VerifyAll()


class NovaVerifierVerifyTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.mox.StubOutWithMock(models, 'InstanceExists',
                                 use_mock_anything=True)
        models.RawData.objects = self.mox.CreateMockAnything()
        self._setup_verifier()

    def _setup_verifier(self):
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.verifier = nova_verifier.NovaVerifier(config,
            pool=self.pool, reconciler=self.reconciler)

    def _create_mock_logger(self):
        mock_logger = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacklog, 'get_logger')
        return mock_logger

    def tearDown(self):
        self.mox.UnsetStubs()
        self.verifier = None
        self.pool = None
        self.verifier_notif = None

    def test_verify_pass(self):
        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(nova_verifier, '_verify_validity')
        self.mox.StubOutWithMock(exist, 'mark_verified')
        nova_verifier._verify_for_launch(exist)
        nova_verifier._verify_for_delete(exist)
        nova_verifier._verify_validity(exist, 'all')
        exist.mark_verified()
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'all')
        self.assertTrue(result)
        self.mox.VerifyAll()

    def test_verify_no_launched_at(self):
        exist = self.mox.CreateMockAnything()
        exist.launched_at = None
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        exist.mark_failed(reason="Exists without a launched_at")
        self.mox.StubOutWithMock(nova_verifier, '_verify_with_reconciled_data')
        nova_verifier._verify_with_reconciled_data(exist)\
                  .AndRaise(NotFound('InstanceReconcile', {}))
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'all')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_fails_reconciled_verify_uses_second_exception(self):
        exist = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        ex1 = VerificationException('test1')
        nova_verifier._verify_for_launch(exist).AndRaise(ex1)
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        self.mox.StubOutWithMock(nova_verifier, '_verify_with_reconciled_data')
        nova_verifier._verify_with_reconciled_data(exist)\
                  .AndRaise(VerificationException('test2'))
        exist.mark_failed(reason='test2')
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_launch_fail(self):
        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        verify_exception = VerificationException('test')
        nova_verifier._verify_for_launch(exist).AndRaise(verify_exception)
        self.mox.StubOutWithMock(nova_verifier, '_verify_with_reconciled_data')
        nova_verifier._verify_with_reconciled_data(exist)\
                  .AndRaise(NotFound('InstanceReconcile', {}))
        exist.mark_failed(reason='test')
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_fail_reconcile_success(self):
        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_verified')
        verify_exception = VerificationException('test')
        nova_verifier._verify_for_launch(exist).AndRaise(verify_exception)
        self.mox.StubOutWithMock(nova_verifier, '_verify_with_reconciled_data')
        nova_verifier._verify_with_reconciled_data(exist)
        exist.mark_verified(reconciled=True)
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertTrue(result)
        self.mox.VerifyAll()

    def test_verify_fail_with_reconciled_data_exception(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.exception("nova: message")

        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        verify_exception = VerificationException('test')
        nova_verifier._verify_for_launch(exist).AndRaise(verify_exception)
        self.mox.StubOutWithMock(nova_verifier, '_verify_with_reconciled_data')
        nova_verifier._verify_with_reconciled_data(exist)\
                  .AndRaise(Exception("message"))
        exist.mark_failed(reason='Exception')
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_delete_fail(self):
        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        verify_exception = VerificationException('test')
        nova_verifier._verify_for_launch(exist)
        nova_verifier._verify_for_delete(exist).AndRaise(verify_exception)
        self.mox.StubOutWithMock(nova_verifier, '_verify_with_reconciled_data')
        nova_verifier._verify_with_reconciled_data(exist)\
                  .AndRaise(NotFound('InstanceReconcile', {}))
        exist.mark_failed(reason='test')
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_exception_during_launch(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.exception("nova: message")

        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        nova_verifier._verify_for_launch(exist).AndRaise(Exception("message"))
        exist.mark_failed(reason='Exception')
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_exception_during_delete(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.exception("nova: message")

        exist = self.mox.CreateMockAnything()
        exist.launched_at = decimal.Decimal('1.1')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_launch')
        self.mox.StubOutWithMock(nova_verifier, '_verify_for_delete')
        self.mox.StubOutWithMock(exist, 'mark_failed')
        nova_verifier._verify_for_launch(exist)
        nova_verifier._verify_for_delete(exist).AndRaise(Exception("message"))
        exist.mark_failed(reason='Exception')
        self.mox.ReplayAll()
        result, exists = nova_verifier._verify(exist, 'none')
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_verify_for_range_without_callback(self):
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.info('nova: Adding 0 exists to queue.')
        mock_logger.info('nova: Adding 2 exists to queue.')
        when_max = datetime.datetime.utcnow()
        results = self.mox.CreateMockAnything()
        sent_results = self.mox.CreateMockAnything()
        models.InstanceExists.PENDING = 'pending'
        models.InstanceExists.VERIFYING = 'verifying'
        models.InstanceExists.SENT_UNVERIFIED = 'sent_unverified'
        models.InstanceExists.find(
            ending_max=when_max, status='sent_unverified').AndReturn(sent_results)
        models.InstanceExists.find(
            ending_max=when_max, status='pending').AndReturn(results)
        sent_results.count().AndReturn(0)
        results.count().AndReturn(2)
        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()
        results.__getslice__(0, 1000).AndReturn(results)
        results.__iter__().AndReturn([exist1, exist2].__iter__())
        exist1.update_status('verifying')
        exist2.update_status('verifying')
        exist1.save()
        exist2.save()
        self.pool.apply_async(nova_verifier._verify, args=(exist1, 'all'),
                              callback=None)
        self.pool.apply_async(nova_verifier._verify, args=(exist2, 'all'),
                              callback=None)
        self.mox.ReplayAll()
        self.verifier.verify_for_range(when_max)
        self.mox.VerifyAll()


    def test_verify_for_range_with_callback(self):
        callback = self.mox.CreateMockAnything()
        mock_logger = self._create_mock_logger()
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        stacklog.get_logger('verifier', is_parent=False).AndReturn(mock_logger)
        mock_logger.info('nova: Adding 0 exists to queue.')
        mock_logger.info('nova: Adding 2 exists to queue.')
        when_max = datetime.datetime.utcnow()
        results = self.mox.CreateMockAnything()
        sent_results = self.mox.CreateMockAnything()
        models.InstanceExists.PENDING = 'pending'
        models.InstanceExists.VERIFYING = 'verifying'
        models.InstanceExists.SENT_UNVERIFIED = 'sent_unverified'
        models.InstanceExists.find(
            ending_max=when_max, status='sent_unverified').AndReturn(sent_results)
        models.InstanceExists.find(
            ending_max=when_max, status='pending').AndReturn(results)
        sent_results.count().AndReturn(0)
        results.count().AndReturn(2)
        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()
        results.__getslice__(0, 1000).AndReturn(results)
        results.__iter__().AndReturn([exist1, exist2].__iter__())
        exist1.update_status('verifying')
        exist2.update_status('verifying')
        exist1.save()
        exist2.save()
        self.pool.apply_async(nova_verifier._verify, args=(exist1, 'all'),
                              callback=callback)
        self.pool.apply_async(nova_verifier._verify, args=(exist2, 'all'),
                              callback=callback)
        self.mox.ReplayAll()
        self.verifier.verify_for_range(when_max, callback=callback)
        self.mox.VerifyAll()


    def test_verify_for_range_when_found_sent_unverified_messages(self):
        callback = self.mox.CreateMockAnything()
        when_max = datetime.datetime.utcnow()
        results = self.mox.CreateMockAnything()
        sent_results = self.mox.CreateMockAnything()
        models.InstanceExists.PENDING = 'pending'
        models.InstanceExists.VERIFYING = 'verifying'
        models.InstanceExists.SENT_VERIFYING = 'sent_verifying'
        models.InstanceExists.SENT_UNVERIFIED = 'sent_unverified'
        models.InstanceExists.find(
            ending_max=when_max, status='sent_unverified').AndReturn(sent_results)
        models.InstanceExists.find(
            ending_max=when_max, status='pending').AndReturn(results)
        sent_results.count().AndReturn(2)
        results.count().AndReturn(0)
        exist1 = self.mox.CreateMockAnything()
        exist2 = self.mox.CreateMockAnything()
        sent_results.__getslice__(0, 1000).AndReturn(sent_results)
        sent_results.__iter__().AndReturn([exist1, exist2].__iter__())
        exist1.update_status('sent_verifying')
        exist2.update_status('sent_verifying')
        exist1.save()
        exist2.save()
        self.pool.apply_async(nova_verifier._verify, args=(exist1, 'all'),
                              callback=None)
        self.pool.apply_async(nova_verifier._verify, args=(exist2, 'all'),
                              callback=None)
        self.mox.ReplayAll()
        self.verifier.verify_for_range(when_max, callback=callback)
        self.mox.VerifyAll()

class NovaVerifierSendVerifiedNotificationTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self._setup_verifier()

    def _setup_verifier(self):
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.verifier = nova_verifier.NovaVerifier(config,
            pool=self.pool, reconciler=self.reconciler)
        self.mox.StubOutWithMock(models, 'InstanceExists',
                                 use_mock_anything=True)
        models.InstanceExists.objects = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()
        self.verifier = None
        self.pool = None
        self.verifier_notif = None

    def test_send_verified_notification_routing_keys(self):
        connection = self.mox.CreateMockAnything()
        exchange = self.mox.CreateMockAnything()
        exist = self.mox.CreateMockAnything()
        exist.id = 1
        exist.raw = self.mox.CreateMockAnything()
        exist_dict = [
            'monitor.info',
            {
                'event_type': 'test',
                'message_id': 'some_uuid'
            }
        ]
        exist_str = json.dumps(exist_dict)
        exist.raw.json = exist_str
        self.mox.StubOutWithMock(uuid, 'uuid4')
        uuid.uuid4().AndReturn('some_other_uuid')
        self.mox.StubOutWithMock(kombu.pools, 'producers')
        self.mox.StubOutWithMock(kombu.common, 'maybe_declare')
        models.InstanceExists.objects.get(id=exist.id).AndReturn(exist)
        routing_keys = ['notifications.info', 'monitor.info']
        for key in routing_keys:
            producer = self.mox.CreateMockAnything()
            producer.channel = self.mox.CreateMockAnything()
            kombu.pools.producers[connection].AndReturn(producer)
            producer.acquire(block=True).AndReturn(producer)
            producer.__enter__().AndReturn(producer)
            kombu.common.maybe_declare(exchange, producer.channel)
            message = {'event_type': NOVA_VERIFIER_EVENT_TYPE,
                       'message_id': 'some_other_uuid',
                       'original_message_id': 'some_uuid'}
            producer.publish(message, key)
            producer.__exit__(None, None, None)
        self.mox.ReplayAll()

        self.verifier.send_verified_notification(exist, exchange, connection,
                                              routing_keys=routing_keys)
        self.mox.VerifyAll()

    def test_send_verified_notification_default_routing_key(self):
        connection = self.mox.CreateMockAnything()
        exchange = self.mox.CreateMockAnything()
        exist = self.mox.CreateMockAnything()
        exist.id = 1
        exist.raw = self.mox.CreateMockAnything()
        exist_dict = [
            'monitor.info',
            {
                'event_type': 'test',
                'message_id': 'some_uuid'
            }
        ]
        exist_str = json.dumps(exist_dict)
        exist.raw.json = exist_str
        self.mox.StubOutWithMock(kombu.pools, 'producers')
        self.mox.StubOutWithMock(kombu.common, 'maybe_declare')
        models.InstanceExists.objects.get(id=exist.id).AndReturn(exist)
        producer = self.mox.CreateMockAnything()
        producer.channel = self.mox.CreateMockAnything()
        kombu.pools.producers[connection].AndReturn(producer)
        producer.acquire(block=True).AndReturn(producer)
        producer.__enter__().AndReturn(producer)
        kombu.common.maybe_declare(exchange, producer.channel)
        self.mox.StubOutWithMock(uuid, 'uuid4')
        uuid.uuid4().AndReturn('some_other_uuid')
        message = {'event_type': NOVA_VERIFIER_EVENT_TYPE,
                   'message_id': 'some_other_uuid',
                   'original_message_id': 'some_uuid'}
        producer.publish(message, exist_dict[0])
        producer.__exit__(None, None, None)
        self.mox.ReplayAll()

        self.verifier.send_verified_notification(exist, exchange, connection)
        self.mox.VerifyAll()


class NovaVerifierValidityTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self._setup_verifier()

    def _setup_verifier(self):
        self.pool = self.mox.CreateMockAnything()
        self.reconciler = self.mox.CreateMockAnything()
        config = make_verifier_config(False)
        self.verifier = nova_verifier.NovaVerifier(config,
            pool=self.pool, reconciler=self.reconciler)

    def tearDown(self):
        self.mox.UnsetStubs()

    def _create_mock_exist(self):
        exist = self.mox.CreateMockAnything()
        exist.instance = '58fb036d-5ef8-47a8-b503-7571276c400a'
        exist.tenant = '3762854cd6f6435998188d5120e4c271'
        exist.id = 23
        exist.launched_at = decimal.Decimal('1.1')
        exist.deleted_at = decimal.Decimal('5.1')
        exist.dummy_flavor_field_name = 'dummy_flavor'
        exist.rax_options = '1'
        exist.os_architecture = 'x64'
        exist.os_distro = 'com.microsoft.server'
        exist.os_version = '2008.2'

        return exist

    def test_should_verify_that_tenant_in_exist_is_not_null(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.tenant = None
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'tenant')
        self.assertEqual(
            exception.reason, "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: tenant field was null for "
            "exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_that_launched_at_in_exist_is_not_null(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.launched_at = None
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'launched_at')
        self.assertEqual(
            exception.reason, "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: launched_at field was null "
            "for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_that_instance_flavor_id_in_exist_is_not_null(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.dummy_flavor_field_name = None
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'dummy_flavor_field_name')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: dummy_flavor_field_name "
            "field was null for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_tenant_id_is_of_type_hex(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.tenant = 'invalid_tenant'
        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'tenant')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: {tenant: invalid_tenant} "
            "was of incorrect type for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_launched_at_is_of_type_decimal(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.launched_at = 111

        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'launched_at')
        self.assertEqual(
            exception.reason,
            'Failed at 2014-01-02 03:04:05 UTC for '
            '58fb036d-5ef8-47a8-b503-7571276c400a: {launched_at: 111} was of '
            'incorrect type for exist id 23')
        self.mox.VerifyAll()

    def test_should_verify_deleted_at_is_of_decimal_type_if_present(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.deleted_at = 20
        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'deleted_at')
        self.assertEqual(
            exception.reason,
            'Failed at 2014-01-02 03:04:05 UTC for '
            '58fb036d-5ef8-47a8-b503-7571276c400a: {deleted_at: 20} was of '
            'incorrect type for exist id 23')
        self.mox.VerifyAll()

    def test_should_verify_rax_options_should_be_of_integer_type(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.rax_options = 'a'
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'rax_options')
        self.assertEqual(
            exception.reason,
            'Failed at 2014-01-02 03:04:05 UTC for '
            '58fb036d-5ef8-47a8-b503-7571276c400a: {rax_options: a} was of '
            'incorrect type for exist id 23')
        self.mox.VerifyAll()

    def test_should_verify_rax_options_should_not_be_empty(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.rax_options = ''
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'rax_options')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: rax_options field was null "
            "for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_os_arch_should_be_alphanumeric(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_architecture = 'x64,'
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'os_architecture')
        self.assertEqual(
            exception.reason,
            'Failed at 2014-01-02 03:04:05 UTC for '
            '58fb036d-5ef8-47a8-b503-7571276c400a: {os_architecture: x64,} '
            'was of incorrect type for exist id 23')
        self.mox.VerifyAll()

    def test_should_verify_os_arch_should_not_be_empty(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_architecture = ''
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'os_architecture')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: os_architecture field was "
            "null for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_os_distro_should_be_alphanumeric(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_distro = 'com.microsoft.server,'
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'os_distro')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: "
            "{os_distro: com.microsoft.server,} was of incorrect type for "
            "exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_os_distro_should_not_be_empty(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_distro = ''
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'os_distro')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: os_distro field was null "
            "for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_os_version_should_be_alphanumeric(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_version = '2008.2,'
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(WrongTypeException) as wt:
            nova_verifier._verify_validity(exist, 'all')
        exception = wt.exception
        self.assertEqual(exception.field_name, 'os_version')
        self.assertEqual(
            exception.reason,
            'Failed at 2014-01-02 03:04:05 UTC for '
            '58fb036d-5ef8-47a8-b503-7571276c400a: {os_version: 2008.2,} was '
            'of incorrect type for exist id 23')
        self.mox.VerifyAll()

    def test_should_verify_os_version_should_not_be_empty(self):
        self.mox.StubOutWithMock(datetime, 'datetime')
        datetime.datetime.utcnow().AndReturn('2014-01-02 03:04:05')
        self.mox.ReplayAll()

        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_version = ''
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        with self.assertRaises(NullFieldException) as nf:
            nova_verifier._verify_validity(exist, 'all')
        exception = nf.exception
        self.assertEqual(exception.field_name, 'os_version')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for "
            "58fb036d-5ef8-47a8-b503-7571276c400a: os_version field was null "
            "for exist id 23")
        self.mox.VerifyAll()

    def test_should_verify_all_exist_fields_when_validity_check_value_all(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        nova_verifier._verify_validity(exist, 'all')
        self.mox.VerifyAll()

    def test_should_verify_only_basic_fields_when_validity_check_basic(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self.mox.CreateMockAnything()
        exist.tenant = '3762854cd6f6435998188d5120e4c271'
        exist.id = 23
        exist.launched_at = decimal.Decimal('1.1')
        exist.deleted_at = decimal.Decimal('5.1')
        exist.dummy_flavor_field_name = 'dummy_flavor'
        self.mox.ReplayAll()

        nova_verifier._verify_validity(exist, 'basic')
        self.mox.VerifyAll()

    def test_should_not_verify_any_fields_if_validity_check_value_is_none(self):
        exist = self.mox.CreateMockAnything()
        exist.id = 23
        self.mox.ReplayAll()

        nova_verifier._verify_validity(exist, 'none')
        self.mox.VerifyAll()

    def test_should_verify_exist_fields_even_if_deleted_at_is_none(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.deleted_at = None
        exist.is_image_type_import().AndReturn(False)
        self.mox.ReplayAll()

        nova_verifier._verify_validity(exist, 'all')
        self.mox.VerifyAll()

    def test_should_verify_in_spite_of_null_os_distro_and_os_version_if_image_type_is_import(self):
        self.mox.StubOutWithMock(config, 'flavor_field_name')
        config.flavor_field_name().AndReturn('dummy_flavor_field_name')

        exist = self._create_mock_exist()
        exist.os_distro = ""
        exist.os_version = ""
        exist.is_image_type_import().AndReturn(True)
        self.mox.ReplayAll()

        nova_verifier._verify_validity(exist, 'all')
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_reconciler
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime

import mox
import requests

from stacktach import models
from stacktach import reconciler
from stacktach import utils as stackutils
from stacktach.reconciler import exceptions
from stacktach.reconciler import nova
from stacktach.reconciler import utils as rec_utils
from tests.unit import StacktachBaseTestCase
from tests.unit import utils
from tests.unit.utils import INSTANCE_ID_1, INSTANCE_TYPE_ID_1
from tests.unit.utils import INSTANCE_FLAVOR_ID_1
from tests.unit.utils import TENANT_ID_1

region_mapping = {
    'RegionOne.prod.cell1': 'RegionOne',
    'RegionTwo.prod.cell1': 'RegionTwo',
}

DEFAULT_OS_ARCH = 'os_arch'
DEFAULT_OS_DISTRO = 'os_dist'
DEFAULT_OS_VERSION = "1.1"
DEFAULT_RAX_OPTIONS = "rax_ops"


class ReconcilerTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.client = self.mox.CreateMockAnything()
        self.client.src_str = 'mocked_client'
        self.reconciler = reconciler.Reconciler({},
                                                client=self.client,
                                                region_mapping=region_mapping)
        self.mox.StubOutWithMock(models, 'RawData', use_mock_anything=True)
        models.RawData.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Deployment', use_mock_anything=True)
        models.Deployment.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Lifecycle', use_mock_anything=True)
        models.Lifecycle.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Timing', use_mock_anything=True)
        models.Timing.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'RequestTracker',
                                 use_mock_anything=True)
        models.RequestTracker.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceUsage',
                                 use_mock_anything=True)
        models.InstanceUsage.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceReconcile',
                                 use_mock_anything=True)
        models.InstanceReconcile.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceDeletes',
                                 use_mock_anything=True)
        models.InstanceDeletes.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceExists',
                                 use_mock_anything=True)
        models.InstanceExists.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'JsonReport', use_mock_anything=True)
        models.JsonReport.objects = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()

    def _fake_usage(self, is_exists=False, is_deleted=False,
                    mock_deployment=False):
        usage = self.mox.CreateMockAnything()
        usage.id = 1
        beginning_d = utils.decimal_utc()
        usage.instance = INSTANCE_ID_1
        launched_at = beginning_d - (60*60)
        usage.launched_at = launched_at
        usage.instance_type_id = INSTANCE_TYPE_ID_1
        usage.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        usage.tenant = TENANT_ID_1
        usage.os_architecture = DEFAULT_OS_ARCH
        usage.os_distro = DEFAULT_OS_DISTRO
        usage.os_version = DEFAULT_OS_VERSION
        usage.rax_options = DEFAULT_RAX_OPTIONS
        if is_exists:
            usage.deleted_at = None
        if is_deleted:
            usage.deleted_at = beginning_d
        if mock_deployment:
            deployment = self.mox.CreateMockAnything()
            deployment.name = 'RegionOne.prod.cell1'
            usage.deployment().AndReturn(deployment)
        return usage

    def _fake_reconciler_instance(self, uuid=INSTANCE_ID_1, launched_at=None,
                                  deleted_at=None, deleted=False,
                                  instance_type_id=INSTANCE_TYPE_ID_1,
                                  instance_flavor_id=INSTANCE_FLAVOR_ID_1,
                                  tenant=TENANT_ID_1,
                                  os_arch=DEFAULT_OS_ARCH,
                                  os_distro=DEFAULT_OS_DISTRO,
                                  os_verison=DEFAULT_OS_VERSION,
                                  rax_options=DEFAULT_RAX_OPTIONS):
        instance = rec_utils.empty_reconciler_instance()
        instance.update({
            'id': uuid,
            'launched_at': launched_at,
            'deleted_at': deleted_at,
            'deleted': deleted,
            'instance_type_id': instance_type_id,
            'instance_flavor_id': instance_flavor_id,
            'tenant': tenant,
            'os_architecture': os_arch,
            'os_distro': os_distro,
            'os_version': os_verison,
            'rax_options': rax_options,
        })
        return instance

    def test_load_client_json_bridge(self):
        mock_config = self.mox.CreateMockAnything()
        config = {'client_class': 'JSONBridgeClient', 'client': mock_config}
        nova.JSONBridgeClient(mock_config)
        self.mox.ReplayAll()
        reconciler.Reconciler.load_client(config)
        self.mox.VerifyAll()

    def test_load_client_no_class_loads_default_class(self):
        mock_config = self.mox.CreateMockAnything()
        config = {'client': mock_config}
        nova.JSONBridgeClient(mock_config)
        self.mox.ReplayAll()
        reconciler.Reconciler.load_client(config)
        self.mox.VerifyAll()

    def test_load_client_incorrect_class_loads_default_class(self):
        mock_config = self.mox.CreateMockAnything()
        config = {'client_class': 'BadConfigValue', 'client': mock_config}
        nova.JSONBridgeClient(mock_config)
        self.mox.ReplayAll()
        reconciler.Reconciler.load_client(config)
        self.mox.VerifyAll()

    def test_region_for_launch(self):
        launch = self.mox.CreateMockAnything()
        deployment = self.mox.CreateMockAnything()
        deployment.name = 'RegionOne.prod.cell1'
        launch.deployment().AndReturn(deployment)
        self.mox.ReplayAll()
        region = self.reconciler._region_for_usage(launch)
        self.assertEqual('RegionOne', region)
        self.mox.VerifyAll()

    def test_region_for_launch_no_mapping(self):
        launch = self.mox.CreateMockAnything()
        deployment = self.mox.CreateMockAnything()
        deployment.name = 'RegionOne.prod.cell2'
        launch.deployment().AndReturn(deployment)
        self.mox.ReplayAll()
        region = self.reconciler._region_for_usage(launch)
        self.assertFalse(region)
        self.mox.VerifyAll()

    def test_region_for_launch_no_raws(self):
        launch = self.mox.CreateMockAnything()
        launch.deployment()
        self.mox.ReplayAll()
        region = self.reconciler._region_for_usage(launch)
        self.assertFalse(region)
        self.mox.VerifyAll()

    def test_missing_exists_for_instance(self):
        launch = self._fake_usage(mock_deployment=True)
        launched_at = launch.launched_at
        deleted_at = launched_at + (60*30)
        period_beginning = deleted_at + 1
        models.InstanceUsage.objects.get(id=launch.id).AndReturn(launch)
        rec_inst = self._fake_reconciler_instance(deleted=True,
                                                  deleted_at=deleted_at)
        self.client.get_instance('RegionOne', INSTANCE_ID_1).AndReturn(rec_inst)
        reconcile_vals = {
            'instance': launch.instance,
            'launched_at': launch.launched_at,
            'deleted_at': deleted_at,
            'instance_type_id': launch.instance_type_id,
            'instance_flavor_id': launch.instance_flavor_id,
            'source': 'reconciler:mocked_client',
            'tenant': TENANT_ID_1,
            'os_architecture': DEFAULT_OS_ARCH,
            'os_distro': DEFAULT_OS_DISTRO,
            'os_version': DEFAULT_OS_VERSION,
            'rax_options': DEFAULT_RAX_OPTIONS,
        }
        result = self.mox.CreateMockAnything()
        models.InstanceReconcile(**reconcile_vals).AndReturn(result)
        result.save()
        self.mox.ReplayAll()
        result = self.reconciler.missing_exists_for_instance(launch.id,
                                                             period_beginning)
        self.assertTrue(result)
        self.mox.VerifyAll()

    def test_missing_exists_for_instance_not_found(self):
        launch_id = 1
        beginning_d = utils.decimal_utc()
        launch = self.mox.CreateMockAnything()
        launch.instance = INSTANCE_ID_1
        launch.launched_at = beginning_d - (60*60)
        launch.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        models.InstanceUsage.objects.get(id=launch_id).AndReturn(launch)
        deployment = self.mox.CreateMockAnything()
        launch.deployment().AndReturn(deployment)
        deployment.name = 'RegionOne.prod.cell1'
        ex = exceptions.NotFound()
        self.client.get_instance('RegionOne', INSTANCE_ID_1).AndRaise(ex)
        self.mox.ReplayAll()
        result = self.reconciler.missing_exists_for_instance(launch_id,
                                                             beginning_d)
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_missing_exists_for_instance_region_not_found(self):
        launch_id = 1
        beginning_d = utils.decimal_utc()
        launch = self.mox.CreateMockAnything()
        launch.instance = INSTANCE_FLAVOR_ID_1
        launch.launched_at = beginning_d - (60*60)
        launch.instance_flavor_id = 1
        models.InstanceUsage.objects.get(id=launch_id).AndReturn(launch)
        launch.deployment().AndReturn(None)
        self.mox.ReplayAll()
        result = self.reconciler.missing_exists_for_instance(launch_id,
                                                             beginning_d)
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_failed_validation(self):
        exists = self._fake_usage(is_exists=True, mock_deployment=True)
        launched_at = exists.launched_at
        rec_inst = self._fake_reconciler_instance(launched_at=launched_at)
        self.client.get_instance('RegionOne', INSTANCE_ID_1,
                                 get_metadata=True).AndReturn(rec_inst)
        reconcile_vals = {
            'instance': exists.instance,
            'launched_at': exists.launched_at,
            'deleted_at': exists.deleted_at,
            'instance_type_id': exists.instance_type_id,
            'instance_flavor_id': exists.instance_flavor_id,
            'source': 'reconciler:mocked_client',
            'tenant': TENANT_ID_1,
            'os_architecture': DEFAULT_OS_ARCH,
            'os_distro': DEFAULT_OS_DISTRO,
            'os_version': DEFAULT_OS_VERSION,
            'rax_options': DEFAULT_RAX_OPTIONS,
        }
        result = self.mox.CreateMockAnything()
        models.InstanceReconcile(**reconcile_vals).AndReturn(result)
        result.save()
        self.mox.ReplayAll()
        result = self.reconciler.failed_validation(exists)
        self.assertTrue(result)
        self.mox.VerifyAll()

    def test_failed_validation_deleted(self):
        exists = self._fake_usage(is_exists=True, is_deleted=True,
                                  mock_deployment=True)
        launched_at = exists.launched_at
        deleted_at = exists.deleted_at
        rec_inst = self._fake_reconciler_instance(launched_at=launched_at,
                                                  deleted=True,
                                                  deleted_at=deleted_at)
        self.client.get_instance('RegionOne', INSTANCE_ID_1,
                                 get_metadata=True).AndReturn(rec_inst)
        reconcile_vals = {
            'instance': exists.instance,
            'launched_at': exists.launched_at,
            'deleted_at': exists.deleted_at,
            'instance_type_id': exists.instance_type_id,
            'instance_flavor_id': exists.instance_flavor_id,
            'source': 'reconciler:mocked_client',
            'tenant': TENANT_ID_1,
            'os_architecture': DEFAULT_OS_ARCH,
            'os_distro': DEFAULT_OS_DISTRO,
            'os_version': DEFAULT_OS_VERSION,
            'rax_options': DEFAULT_RAX_OPTIONS,
        }
        result = self.mox.CreateMockAnything()
        models.InstanceReconcile(**reconcile_vals).AndReturn(result)
        result.save()
        self.mox.ReplayAll()
        result = self.reconciler.failed_validation(exists)
        self.assertTrue(result)
        self.mox.VerifyAll()

    def test_failed_validation_deleted_not_matching(self):
        beginning_d = utils.decimal_utc()
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = beginning_d - (60*60)
        exists.launched_at = launched_at
        exists.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        exists.deleted_at = beginning_d
        deployment = self.mox.CreateMockAnything()
        exists.deployment().AndReturn(deployment)
        deployment.name = 'RegionOne.prod.cell1'
        rec_inst = self._fake_reconciler_instance(launched_at=launched_at,
                                                  deleted=True,
                                                  deleted_at=beginning_d+1)
        self.client.get_instance('RegionOne', INSTANCE_ID_1,
                                 get_metadata=True).AndReturn(rec_inst)
        self.mox.ReplayAll()
        result = self.reconciler.failed_validation(exists)
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_failed_validation_deleted_not_deleted_from_client(self):
        beginning_d = utils.decimal_utc()
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = beginning_d - (60*60)
        exists.launched_at = launched_at
        exists.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        exists.deleted_at = beginning_d
        deployment = self.mox.CreateMockAnything()
        exists.deployment().AndReturn(deployment)
        deployment.name = 'RegionOne.prod.cell1'
        rec_inst = self._fake_reconciler_instance(launched_at=launched_at)
        self.client.get_instance('RegionOne', INSTANCE_ID_1,
                                 get_metadata=True).AndReturn(rec_inst)
        self.mox.ReplayAll()
        result = self.reconciler.failed_validation(exists)
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_failed_validation_not_found(self):
        beginning_d = utils.decimal_utc()
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = beginning_d - (60*60)
        exists.launched_at = launched_at
        exists.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        exists.deleted_at = None
        deployment = self.mox.CreateMockAnything()
        exists.deployment().AndReturn(deployment)
        deployment.name = 'RegionOne.prod.cell1'
        ex = exceptions.NotFound()
        self.client.get_instance('RegionOne', INSTANCE_ID_1,
                                 get_metadata=True).AndRaise(ex)
        self.mox.ReplayAll()
        result = self.reconciler.failed_validation(exists)
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_failed_validation_region_not_found(self):
        beginning_d = utils.decimal_utc()
        exists = self.mox.CreateMockAnything()
        exists.instance = INSTANCE_ID_1
        launched_at = beginning_d - (60*60)
        exists.launched_at = launched_at
        exists.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        exists.deleted_at = None
        exists.deployment().AndReturn(None)
        ex = exceptions.NotFound()
        self.mox.ReplayAll()
        result = self.reconciler.failed_validation(exists)
        self.assertFalse(result)
        self.mox.VerifyAll()

    def test_fields_match(self):
        exists = self._fake_usage(is_exists=True)
        kwargs = {'launched_at': exists.launched_at}
        instance = self._fake_reconciler_instance(**kwargs)
        self.mox.ReplayAll()
        match_code = self.reconciler._fields_match(exists, instance)
        self.assertEqual(match_code, 0)
        self.mox.VerifyAll()

    def test_fields_match_field_with_deleted(self):
        exists = self._fake_usage(is_exists=True, is_deleted=True)
        kwargs = {'launched_at': exists.launched_at,
                  'deleted': True,
                  'deleted_at': exists.deleted_at}
        instance = self._fake_reconciler_instance(**kwargs)
        self.mox.ReplayAll()
        match_code = self.reconciler._fields_match(exists, instance)
        self.assertEqual(match_code, 0)
        self.mox.VerifyAll()

    def test_fields_match_field_miss_match(self):
        exists = self._fake_usage(is_exists=True)
        kwargs = {'launched_at': exists.launched_at + 1}
        instance = self._fake_reconciler_instance(**kwargs)
        self.mox.ReplayAll()
        match_code = self.reconciler._fields_match(exists, instance)
        self.assertEqual(match_code, 1)
        self.mox.VerifyAll()

    def test_fields_match_field_with_deleted_miss_match(self):
        exists = self._fake_usage(is_exists=True, is_deleted=True)
        kwargs = {'launched_at': exists.launched_at,
                  'deleted': True,
                  'deleted_at': exists.deleted_at+1}
        instance = self._fake_reconciler_instance(**kwargs)
        self.mox.ReplayAll()
        match_code = self.reconciler._fields_match(exists, instance)
        self.assertEqual(match_code, 2)
        self.mox.VerifyAll()

    def test_fields_match_field_not_deleted_in_nova(self):
        exists = self._fake_usage(is_exists=True, is_deleted=True)
        kwargs = {'launched_at': exists.launched_at}
        instance = self._fake_reconciler_instance(**kwargs)
        self.mox.ReplayAll()
        match_code = self.reconciler._fields_match(exists, instance)
        self.assertEqual(match_code, 3)
        self.mox.VerifyAll()

    def test_fields_match_field_not_deleted_in_exists(self):
        exists = self._fake_usage(is_exists=True)
        kwargs = {'launched_at': exists.launched_at,
                  'deleted': True,
                  'deleted_at': exists.launched_at + 1}
        instance = self._fake_reconciler_instance(**kwargs)
        self.mox.ReplayAll()
        match_code = self.reconciler._fields_match(exists, instance)
        self.assertEqual(match_code, 4)
        self.mox.VerifyAll()


json_bridge_config = {
    'url': 'http://json_bridge.example.com/query/',
    'username': 'user',
    'password': 'pass',
    'databases': {
        'RegionOne': 'nova',
    }
}


class NovaJSONBridgeClientTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.client = nova.JSONBridgeClient(json_bridge_config)
        self.mox.StubOutWithMock(requests, 'post')

    def tearDown(self):
        self.mox.UnsetStubs()

    def mock_for_query(self, database, query, results):
        url = json_bridge_config['url'] + database
        data = {'sql': query}
        auth = (json_bridge_config['username'], json_bridge_config['password'])
        result = {'result': results}
        response = self.mox.CreateMockAnything()
        requests.post(url, data, auth=auth, verify=False)\
                .AndReturn(response)
        response.json().AndReturn(result)

    def _fake_instance(self, uuid=INSTANCE_ID_1, launched_at=None,
                       terminated_at=None, deleted=0,
                       instance_type_id=INSTANCE_TYPE_ID_1,
                       instance_flavor_id=INSTANCE_FLAVOR_ID_1,
                       project_id=TENANT_ID_1):
        return {
            'uuid': uuid,
            'launched_at': launched_at,
            'terminated_at': terminated_at,
            'deleted': deleted,
            'instance_type_id': instance_type_id,
            'flavorid': instance_flavor_id,
            'project_id': project_id
        }

    def test_get_instance(self):
        launched_at = datetime.datetime.utcnow() - datetime.timedelta(minutes=5)
        launched_at = str(launched_at)
        terminated_at = str(datetime.datetime.utcnow())
        results = [self._fake_instance(launched_at=launched_at,
                                       terminated_at=terminated_at,
                                       deleted=True)]
        self.mock_for_query('nova', nova.GET_INSTANCE_QUERY % INSTANCE_ID_1,
                            results)
        self.mox.ReplayAll()
        instance = self.client.get_instance('RegionOne', INSTANCE_ID_1)
        self.assertIsNotNone(instance)
        self.assertEqual(instance['id'], INSTANCE_ID_1 )
        self.assertEqual(instance['instance_type_id'], INSTANCE_TYPE_ID_1)
        self.assertEqual(instance['instance_flavor_id'], INSTANCE_FLAVOR_ID_1)
        launched_at_dec = stackutils.str_time_to_unix(launched_at)
        self.assertEqual(instance['launched_at'], launched_at_dec)
        terminated_at_dec = stackutils.str_time_to_unix(terminated_at)
        self.assertEqual(instance['deleted_at'], terminated_at_dec)
        self.assertTrue(instance['deleted'])
        self.mox.VerifyAll()

    def _fake_metadata(self):
        metadata = [
            {'key': 'image_org.openstack__1__architecture',
             'value': DEFAULT_OS_ARCH},
            {'key': 'image_org.openstack__1__os_distro',
             'value': DEFAULT_OS_DISTRO},
            {'key': 'image_org.openstack__1__os_version',
             'value': DEFAULT_OS_VERSION},
            {'key': 'image_com.rackspace__1__options',
             'value': DEFAULT_RAX_OPTIONS},
        ]
        return metadata

    def test_get_instance_with_metadata(self):
        launched_at = datetime.datetime.utcnow() - datetime.timedelta(minutes=5)
        launched_at = str(launched_at)
        terminated_at = str(datetime.datetime.utcnow())
        results = [self._fake_instance(launched_at=launched_at,
                                       terminated_at=terminated_at,
                                       deleted=True)]
        metadata_results = self._fake_metadata()
        self.mock_for_query('nova', nova.GET_INSTANCE_QUERY % INSTANCE_ID_1,
                            results)
        self.mock_for_query('nova',
                            nova.GET_INSTANCE_SYSTEM_METADATA % INSTANCE_ID_1,
                            metadata_results)
        self.mox.ReplayAll()
        instance = self.client.get_instance('RegionOne', INSTANCE_ID_1,
                                            get_metadata=True)
        self.assertIsNotNone(instance)
        self.assertEqual(instance['id'], INSTANCE_ID_1)
        self.assertEqual(instance['instance_flavor_id'], INSTANCE_FLAVOR_ID_1)
        launched_at_dec = stackutils.str_time_to_unix(launched_at)
        self.assertEqual(instance['launched_at'], launched_at_dec)
        terminated_at_dec = stackutils.str_time_to_unix(terminated_at)
        self.assertEqual(instance['deleted_at'], terminated_at_dec)
        self.assertTrue(instance['deleted'])
        self.mox.VerifyAll()

    def test_get_instance_not_found(self):
        self.mock_for_query('nova', nova.GET_INSTANCE_QUERY % INSTANCE_ID_1,
                            [])
        self.mox.ReplayAll()
        self.assertRaises(exceptions.NotFound, self.client.get_instance,
                          'RegionOne', INSTANCE_ID_1)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_stacklog
import logging
import mox
from stacktach import stacklog
from tests.unit import StacktachBaseTestCase


class StacklogTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_get_logger_should_create_timed_rotating_logger_for_parent(self):
        logger_name = 'logger'
        logger = stacklog.get_logger(logger_name, is_parent=True)
        self.assertIsInstance(
            logger.handlers[0], logging.handlers.TimedRotatingFileHandler)
        self.assertEquals(logger.handlers[0].when, 'MIDNIGHT')
        self.assertEquals(logger.handlers[0].interval, 86400)
        self.assertEquals(logger.handlers[0].backupCount, 6)
        self.assertEqual(logger.name, 'logger')
        self.assertEquals(logger.level, logging.DEBUG)

    def test_get_logger_should_create_queue_logger_for_child(self):
        logger_name = 'logger'
        stacklog.get_logger(logger_name, is_parent=True)
        child_logger = stacklog.get_logger(logger_name, is_parent=False)
        self.assertIsInstance(
            child_logger.handlers[0], stacklog.QueueHandler)
        self.assertEqual(child_logger.name, 'child_logger')
        self.assertEquals(child_logger.level, logging.DEBUG)

    def test_get_logger_should_use_default_name_when_name_not_specified(self):
        logger = stacklog.get_logger(None, is_parent=True)
        self.assertEquals(logger.name, stacklog.default_logger_name)

        stacklog.set_default_logger_name('default')
        logger = stacklog.get_logger(None, is_parent=True)
        self.assertEquals(logger.name, 'default')

    def test_get_logger_raise_exception_when_child_created_before_parent(self):
        with self.assertRaises(stacklog.ParentLoggerDoesNotExist):
            stacklog.get_logger('logger', is_parent=False)

    def test_get_logger_should_return_existing_parent_logger_if_present(self):
        logger_1 = stacklog.get_logger('logger', is_parent=True)
        logger_2 = stacklog.get_logger('logger', is_parent=True)

        self.assertIs(logger_1, logger_2)

    def test_get_logger_should_return_existing_child_logger_if_present(self):
        stacklog.get_logger('logger', is_parent=True)
        child_logger_1 = stacklog.get_logger('logger', is_parent=False)
        child_logger_2 = stacklog.get_logger('logger', is_parent=False)

        self.assertIs(child_logger_1, child_logger_2)

########NEW FILE########
__FILENAME__ = test_stacktach
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import json

import mox

import utils
from utils import BANDWIDTH_PUBLIC_OUTBOUND
from utils import INSTANCE_FLAVOR_ID_1
from utils import INSTANCE_FLAVOR_ID_2
from utils import INSTANCE_ID_1
from utils import OS_VERSION_1
from utils import OS_ARCH_1
from utils import OS_DISTRO_1
from utils import RAX_OPTIONS_1
from utils import MESSAGE_ID_1
from utils import REQUEST_ID_1
from utils import TENANT_ID_1
from utils import INSTANCE_TYPE_ID_1
from utils import DUMMY_TIME
from utils import INSTANCE_TYPE_ID_2
from stacktach import stacklog, models
from stacktach import notification
from stacktach import views
from tests.unit import StacktachBaseTestCase


class StacktachRawParsingTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        views.STACKDB = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()

    def assertOnHandlerResponse(self, resp, **kwargs):
        for key in kwargs:
            self.assertTrue(key in resp, msg='%s not in response' % key)
            self.assertEqual(resp[key], kwargs[key])

    def test_process_raw_data(self):
        deployment = self.mox.CreateMockAnything()
        when = '2013-1-25 13:38:23.123'
        dict = {
            'timestamp': when,
        }
        routing_key = 'monitor.info'
        args = (routing_key, dict)
        json_args = json.dumps(args)
        mock_record = self.mox.CreateMockAnything()
        mock_notification = self.mox.CreateMockAnything()
        mock_notification.save().AndReturn(mock_record)
        self.mox.StubOutWithMock(notification, 'notification_factory')
        exchange = 'nova'
        notification.notification_factory(dict, deployment, routing_key,
                                          json_args, exchange).AndReturn(
            mock_notification)
        self.mox.ReplayAll()

        self.assertEquals(
            views.process_raw_data(deployment, args, json_args, exchange),
                                  (mock_record, mock_notification))
        self.mox.VerifyAll()

    def test_process_raw_data_old_timestamp(self):
        deployment = self.mox.CreateMockAnything()
        when = '2013-1-25T13:38:23.123'
        dict = {
            '_context_timestamp': when,
        }
        routing_key = 'monitor.info'
        args = ('monitor.info', dict)
        json_args = json.dumps(args[1])

        mock_notification = self.mox.CreateMockAnything()
        mock_notification.save()
        self.mox.StubOutWithMock(notification, 'notification_factory')
        exchange = 'nova'
        notification.notification_factory(dict, deployment, routing_key,
                                          json_args, exchange).AndReturn(mock_notification)
        self.mox.ReplayAll()

        views.process_raw_data(deployment, args, json_args, exchange)
        self.mox.VerifyAll()


class StacktachLifecycleTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        views.STACKDB = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_start_kpi_tracking_not_update(self):
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.create.start'
        self.mox.ReplayAll()
        views.start_kpi_tracking(None, raw)
        self.mox.VerifyAll()

    def test_start_kpi_tracking_not_from_api(self):
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.update'
        raw.service = 'compute'
        self.mox.ReplayAll()
        views.start_kpi_tracking(None, raw)
        self.mox.VerifyAll()

    def test_start_kpi_tracking(self):
        lifecycle = self.mox.CreateMockAnything()
        tracker = self.mox.CreateMockAnything()
        when = utils.decimal_utc()
        raw = utils.create_raw(self.mox, when, 'compute.instance.update',
                               host='nova.example.com', service='api')
        views.STACKDB.create_request_tracker(lifecycle=lifecycle,
                                             request_id=REQUEST_ID_1,
                                             start=when,
                                             last_timing=None,
                                             duration=str(0.0))\
                                             .AndReturn(tracker)
        views.STACKDB.save(tracker)
        self.mox.ReplayAll()
        views.start_kpi_tracking(lifecycle, raw)
        self.mox.VerifyAll()

    def test_start_kpi_tracking_not_using_host(self):
        lifecycle = self.mox.CreateMockAnything()
        tracker = self.mox.CreateMockAnything()
        when = utils.decimal_utc()
        raw = utils.create_raw(self.mox, when, 'compute.instance.update',
                               host='api.example.com', service='compute')
        self.mox.ReplayAll()
        views.start_kpi_tracking(lifecycle, raw)
        self.mox.VerifyAll()

    def test_update_kpi_no_trackers(self):
        raw = self.mox.CreateMockAnything()
        raw.request_id = REQUEST_ID_1
        views.STACKDB.find_request_trackers(request_id=REQUEST_ID_1)\
                     .AndReturn([])
        self.mox.ReplayAll()
        views.update_kpi(None, raw)
        self.mox.VerifyAll()

    def test_update_kpi(self):
        lifecycle = self.mox.CreateMockAnything()
        end = utils.decimal_utc()
        raw = self.mox.CreateMockAnything()
        raw.request_id = REQUEST_ID_1
        raw.when=end
        timing = utils.create_timing(self.mox, 'compute.instance.create',
                                     lifecycle, end_when=end)
        start = utils.decimal_utc()
        tracker = utils.create_tracker(self.mox, REQUEST_ID_1, lifecycle,
                                       start)
        views.STACKDB.find_request_trackers(request_id=REQUEST_ID_1)\
                      .AndReturn([tracker])
        views.STACKDB.save(tracker)
        self.mox.ReplayAll()
        views.update_kpi(timing, raw)
        self.assertEqual(tracker.request_id, REQUEST_ID_1)
        self.assertEqual(tracker.lifecycle, lifecycle)
        self.assertEqual(tracker.last_timing, timing)
        self.assertEqual(tracker.start, start)
        self.assertEqual(tracker.duration, end-start)
        self.mox.VerifyAll()

    def test_aggregate_lifecycle_no_instance(self):
        raw = self.mox.CreateMockAnything()
        raw.instance = None
        self.mox.ReplayAll()
        views.aggregate_lifecycle(raw)
        self.mox.VerifyAll()

    def test_aggregate_lifecycle_start(self):
        event_name = 'compute.instance.create'
        event = '%s.start' % event_name
        when = datetime.datetime.utcnow()
        raw = utils.create_raw(self.mox, when, event, state='building')

        views.STACKDB.find_lifecycles(instance=INSTANCE_ID_1).AndReturn([])
        lifecycle = self.mox.CreateMockAnything()
        lifecycle.instance = INSTANCE_ID_1
        views.STACKDB.create_lifecycle(instance=INSTANCE_ID_1)\
                     .AndReturn(lifecycle)
        views.STACKDB.save(lifecycle)

        views.STACKDB.find_timings(name=event_name, lifecycle=lifecycle)\
                     .AndReturn([])
        timing = utils.create_timing(self.mox, event_name, lifecycle)
        views.STACKDB.create_timing(lifecycle=lifecycle, name=event_name)\
                     .AndReturn(timing)
        views.STACKDB.save(timing)

        self.mox.ReplayAll()
        views.aggregate_lifecycle(raw)
        self.assertEqual(lifecycle.last_raw, raw)
        self.assertEqual(lifecycle.last_state, 'building')
        self.assertEqual(lifecycle.last_task_state, '')
        self.assertEqual(timing.name, event_name)
        self.assertEqual(timing.lifecycle, lifecycle)
        self.assertEqual(timing.start_raw, raw)
        self.assertEqual(timing.start_when, when)

        self.mox.VerifyAll()

    def test_aggregate_lifecycle_end(self):
        event_name = 'compute.instance.create'
        start_event = '%s.end' % event_name
        end_event = '%s.end' % event_name
        start_when = datetime.datetime.utcnow()
        end_when = datetime.datetime.utcnow()
        start_raw = utils.create_raw(self.mox, start_when, start_event,
                                          state='building')
        end_raw = utils.create_raw(self.mox, end_when, end_event,
                                        old_task='build')

        lifecycle = utils.create_lifecycle(self.mox, INSTANCE_ID_1,
                                                'active', '', start_raw)
        views.STACKDB.find_lifecycles(instance=INSTANCE_ID_1)\
                     .AndReturn([lifecycle])
        views.STACKDB.save(lifecycle)

        timing = utils.create_timing(self.mox, event_name, lifecycle,
                                     start_raw=start_raw,
                                     start_when=start_when)
        views.STACKDB.find_timings(name=event_name, lifecycle=lifecycle)\
                     .AndReturn([timing])

        self.mox.StubOutWithMock(views, "update_kpi")
        views.update_kpi(timing, end_raw)
        views.STACKDB.save(timing)

        self.mox.ReplayAll()
        views.aggregate_lifecycle(end_raw)
        self.assertEqual(lifecycle.last_raw, end_raw)
        self.assertEqual(lifecycle.last_state, 'active')
        self.assertEqual(lifecycle.last_task_state, 'build')
        self.assertEqual(timing.name, event_name)
        self.assertEqual(timing.lifecycle, lifecycle)
        self.assertEqual(timing.start_raw, start_raw)
        self.assertEqual(timing.start_when, start_when)
        self.assertEqual(timing.end_raw, end_raw)
        self.assertEqual(timing.end_when, end_when)
        self.assertEqual(timing.diff, end_when-start_when)

        self.mox.VerifyAll()

    def test_aggregate_lifecycle_update(self):
        event = 'compute.instance.update'
        when = datetime.datetime.utcnow()
        raw = utils.create_raw(self.mox, when, event, old_task='reboot')

        views.STACKDB.find_lifecycles(instance=INSTANCE_ID_1).AndReturn([])
        lifecycle = self.mox.CreateMockAnything()
        lifecycle.instance = INSTANCE_ID_1
        views.STACKDB.create_lifecycle(instance=INSTANCE_ID_1).AndReturn(lifecycle)
        views.STACKDB.save(lifecycle)

        self.mox.StubOutWithMock(views, "start_kpi_tracking")
        views.start_kpi_tracking(lifecycle, raw)

        self.mox.ReplayAll()
        views.aggregate_lifecycle(raw)
        self.assertEqual(lifecycle.last_raw, raw)
        self.assertEqual(lifecycle.last_state, 'active')
        self.assertEqual(lifecycle.last_task_state, 'reboot')

        self.mox.VerifyAll()


class StacktachUsageParsingTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        views.STACKDB = self.mox.CreateMockAnything()
        self.log = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacklog, 'get_logger')

    def tearDown(self):
        self.mox.UnsetStubs()

    def setup_mock_log(self, name=None):
        if name is None:
            stacklog.get_logger(name=mox.IgnoreArg(),
                                is_parent=False).AndReturn(self.log)
        else:
            stacklog.get_logger(name=name,
                                is_parent=False).AndReturn(self.log)

    def test_all_instance_events_have_mapping(self):
        for key, value in views.INSTANCE_EVENT.items():
            msg = "'%s' does not have a process function mapping." % value
            self.assertTrue(value in views.USAGE_PROCESS_MAPPING, msg)

    def _create_mock_notification(self):
        notification = self.mox.CreateMockAnything()
        notification.launched_at = str(DUMMY_TIME)
        notification.tenant = TENANT_ID_1
        notification.rax_options = RAX_OPTIONS_1
        notification.os_architecture = OS_ARCH_1
        notification.os_version = OS_VERSION_1
        notification.os_distro = OS_DISTRO_1
        notification.instance = INSTANCE_ID_1
        notification.request_id = REQUEST_ID_1
        notification.instance_type_id = INSTANCE_TYPE_ID_1
        notification.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        return notification

    def test_process_usage_for_new_launch_create_start(self):
        notification = self._create_mock_notification()
        notification.instance_flavor_id = INSTANCE_FLAVOR_ID_1

        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.create.start'

        usage = self.mox.CreateMockAnything()
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEquals(usage.instance_type_id, INSTANCE_TYPE_ID_1)
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)
        self.assertEquals(usage.instance_flavor_id, INSTANCE_FLAVOR_ID_1)

        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_rescue_start(self):
        notification = self._create_mock_notification()

        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.rescue.start'

        usage = self.mox.CreateMockAnything()
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEquals(usage.instance_type_id, INSTANCE_TYPE_ID_1)
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_rebuild_start(self):
        notification = self._create_mock_notification()
        notification.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.rebuild.start'
        usage = self.mox.CreateMockAnything()
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEquals(usage.instance_type_id, INSTANCE_TYPE_ID_1)
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)
        self.assertEquals(usage.instance_flavor_id, INSTANCE_FLAVOR_ID_1)
        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_rebuild_start_when_no_launched_at_in_db(self):
        notification = self._create_mock_notification()
        notification.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.rebuild.start'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)
        self.assertEquals(usage.instance_flavor_id, INSTANCE_FLAVOR_ID_1)

        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_resize_prep_start_when_no_launched_at_in_db(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.resize.prep.start'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        usage.launched_at = None

        views._process_usage_for_new_launch(raw, notification)

        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_resize_revert_start_when_no_launched_at_in_db(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.resize.revert.start'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_resize_prep_start_when_launched_at_in_db(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.resize.prep.start'

        orig_launched_at = utils.decimal_utc(DUMMY_TIME - datetime.timedelta(days=1))
        usage = self.mox.CreateMockAnything()
        usage.launched_at = orig_launched_at
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEqual(usage.launched_at, orig_launched_at)
        self.assertEqual(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_new_launch_rescue_start_when_launched_at_in_db(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.rescue.start'

        orig_launched_at = utils.decimal_utc(DUMMY_TIME - datetime.timedelta(days=1))
        usage = self.mox.CreateMockAnything()
        usage.launched_at = orig_launched_at
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_new_launch(raw, notification)

        self.assertEqual(usage.launched_at, orig_launched_at)
        self.assertEqual(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_create_end(self):
        notification = self._create_mock_notification()
        notification.message = 'Success'
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.create.end'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)

        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEqual(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_rescue_end(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.rescue.end'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)

        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEqual(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_create_end_success_message(self):
        notification = self._create_mock_notification()
        notification.message = 'Success'
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.create.end'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)
        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEqual(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_create_end_error_message(self):
        notification = self.mox.CreateMockAnything()
        notification.message = 'Error'

        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.create.end'
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_revert_end(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.resize.revert.end'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)

        self.assertEqual(usage.instance_type_id, INSTANCE_TYPE_ID_1)
        self.assertEqual(usage.launched_at, utils.decimal_utc(DUMMY_TIME))
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_finish_resize_start(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.finish_resize.start'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        usage.instance_type_id = INSTANCE_TYPE_ID_2
        usage.instance_flavor_id = INSTANCE_FLAVOR_ID_2
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)

        self.assertEqual(usage.instance_type_id, INSTANCE_TYPE_ID_1)
        self.assertEqual(usage.instance_flavor_id, INSTANCE_FLAVOR_ID_1)
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_usage_for_updates_finish_resize_end(self):
        notification = self._create_mock_notification()
        raw = self.mox.CreateMockAnything()
        raw.event = 'compute.instance.finish_resize.end'

        usage = self.mox.CreateMockAnything()
        usage.launched_at = None
        usage.instance_type_id = INSTANCE_TYPE_ID_2
        usage.instance_flavor_id = INSTANCE_FLAVOR_ID_2
        views.STACKDB.get_or_create_instance_usage(instance=INSTANCE_ID_1,
                                                   request_id=REQUEST_ID_1) \
            .AndReturn((usage, True))
        views.STACKDB.save(usage)
        self.mox.ReplayAll()

        views._process_usage_for_updates(raw, notification)

        self.assertEqual(usage.instance_type_id, INSTANCE_TYPE_ID_1)
        self.assertEqual(usage.instance_flavor_id, INSTANCE_FLAVOR_ID_1)
        self.assertEquals(usage.tenant, TENANT_ID_1)
        self.assertEquals(usage.os_architecture, OS_ARCH_1)
        self.assertEquals(usage.os_version, OS_VERSION_1)
        self.assertEquals(usage.os_distro, OS_DISTRO_1)
        self.assertEquals(usage.rax_options, RAX_OPTIONS_1)

        self.mox.VerifyAll()

    def test_process_delete(self):
        delete_time = datetime.datetime.utcnow()
        terminated_time = delete_time-datetime.timedelta(seconds=1)
        launch_time = delete_time-datetime.timedelta(days=1)
        launch_decimal = utils.decimal_utc(launch_time)
        delete_decimal = utils.decimal_utc(delete_time)
        notification = self.mox.CreateMockAnything()
        notification.instance = INSTANCE_ID_1
        notification.deleted_at = str(delete_time)
        notification.terminated_at = str(terminated_time)
        notification.launched_at = str(launch_time)

        raw = self.mox.CreateMockAnything()
        delete = self.mox.CreateMockAnything()
        delete.instance = INSTANCE_ID_1
        delete.launched_at = launch_decimal
        delete.deleted_at = delete_decimal
        views.STACKDB.get_or_create_instance_delete(
            instance=INSTANCE_ID_1, deleted_at=delete_decimal,
            launched_at=launch_decimal)\
            .AndReturn((delete, True))
        views.STACKDB.save(delete)
        self.mox.ReplayAll()

        views._process_delete(raw, notification)

        self.assertEqual(delete.instance, INSTANCE_ID_1)
        self.assertEqual(delete.launched_at, launch_decimal)
        self.assertEqual(delete.deleted_at, delete_decimal)
        self.mox.VerifyAll()

    def test_process_delete_with_only_terminated_at(self):
        delete_time = datetime.datetime.utcnow()
        launch_time = delete_time-datetime.timedelta(days=1)
        launch_decimal = utils.decimal_utc(launch_time)
        delete_decimal = utils.decimal_utc(delete_time)
        notification = self.mox.CreateMockAnything()
        notification.instance = INSTANCE_ID_1
        notification.deleted_at = ''
        notification.terminated_at = str(delete_time)
        notification.launched_at = str(launch_time)

        raw = self.mox.CreateMockAnything()
        delete = self.mox.CreateMockAnything()
        delete.instance = INSTANCE_ID_1
        delete.launched_at = launch_decimal
        delete.deleted_at = delete_decimal
        views.STACKDB.get_or_create_instance_delete(
            instance=INSTANCE_ID_1, deleted_at=delete_decimal,
            launched_at=launch_decimal)\
            .AndReturn((delete, True))
        views.STACKDB.save(delete)
        self.mox.ReplayAll()

        views._process_delete(raw, notification)

        self.assertEqual(delete.instance, INSTANCE_ID_1)
        self.assertEqual(delete.launched_at, launch_decimal)
        self.assertEqual(delete.deleted_at, delete_decimal)
        self.mox.VerifyAll()

    def test_process_delete_with_neither(self):
        delete_time = datetime.datetime.utcnow()
        launch_time = delete_time-datetime.timedelta(days=1)
        launch_decimal = utils.decimal_utc(launch_time)
        delete_decimal = utils.decimal_utc(delete_time)
        notification = self.mox.CreateMockAnything()
        notification.instance = INSTANCE_ID_1
        notification.deleted_at = ''
        notification.terminated_at = str(delete_time)
        notification.launched_at = str(launch_time)

        raw = self.mox.CreateMockAnything()
        delete = self.mox.CreateMockAnything()
        delete.instance = INSTANCE_ID_1
        delete.launched_at = launch_decimal
        delete.deleted_at = delete_decimal
        views.STACKDB.get_or_create_instance_delete(
            instance=INSTANCE_ID_1, deleted_at=delete_decimal,
            launched_at=launch_decimal)\
            .AndReturn((delete, True))
        views.STACKDB.save(delete)
        self.mox.ReplayAll()

        views._process_delete(raw, notification)

        self.assertEqual(delete.instance, INSTANCE_ID_1)
        self.assertEqual(delete.launched_at, launch_decimal)
        self.assertEqual(delete.deleted_at, delete_decimal)
        self.mox.VerifyAll()

    def test_process_delete_no_launch(self):
        delete_time = datetime.datetime.utcnow()
        notification = self.mox.CreateMockAnything()
        notification.instance = INSTANCE_ID_1
        notification.deleted_at = str(delete_time)
        notification.launched_at = ''

        raw = self.mox.CreateMockAnything()
        self.mox.ReplayAll()

        views._process_delete(raw, notification)

        self.mox.VerifyAll()

    def _create_exists_notification(self, audit_beginning, current_time,
                                    launch_time, deleted_time):
        notification = self.mox.CreateMockAnything()
        notification.launched_at = str(launch_time)
        notification.deleted_at = str(deleted_time)
        notification.audit_period_beginning = str(audit_beginning)
        notification.audit_period_ending = str(current_time)
        notification.tenant = TENANT_ID_1
        notification.os_architecture = OS_ARCH_1
        notification.os_version = OS_VERSION_1
        notification.os_distro = OS_DISTRO_1
        notification.rax_options = RAX_OPTIONS_1
        notification.instance = INSTANCE_ID_1
        notification.instance_type_id = INSTANCE_TYPE_ID_1
        notification.instance_flavor_id = INSTANCE_FLAVOR_ID_1
        notification.message_id = MESSAGE_ID_1
        notification.bandwidth_public_out = BANDWIDTH_PUBLIC_OUTBOUND
        return notification

    def test_process_exists(self):
        current_time = datetime.datetime.utcnow()
        launch_time = current_time - datetime.timedelta(hours=23)
        launch_decimal = utils.decimal_utc(launch_time)
        audit_beginning = current_time - datetime.timedelta(hours=20)
        audit_beginning_decimal = utils.decimal_utc(audit_beginning)
        audit_ending_decimal = utils.decimal_utc(current_time)
        notification = self._create_exists_notification(
            audit_beginning, current_time, launch_time, deleted_time='')
        raw = self.mox.CreateMockAnything()
        usage = self.mox.CreateMockAnything()
        launched_range = (launch_decimal, launch_decimal+1)
        views.STACKDB.get_instance_usage(
            instance=INSTANCE_ID_1,
            launched_at__range=launched_range).AndReturn(usage)
        exists_values = {
            'message_id': MESSAGE_ID_1,
            'instance': INSTANCE_ID_1,
            'launched_at': launch_decimal,
            'audit_period_beginning': audit_beginning_decimal,
            'audit_period_ending': audit_ending_decimal,
            'instance_type_id': INSTANCE_TYPE_ID_1,
            'instance_flavor_id': INSTANCE_FLAVOR_ID_1,
            'usage': usage,
            'raw': raw,
            'tenant': TENANT_ID_1,
            'rax_options': RAX_OPTIONS_1,
            'os_architecture': OS_ARCH_1,
            'os_version': OS_VERSION_1,
            'os_distro': OS_DISTRO_1,
            'bandwidth_public_out': BANDWIDTH_PUBLIC_OUTBOUND
        }
        exists = self.mox.CreateMockAnything()
        views.STACKDB.create_instance_exists(**exists_values).AndReturn(exists)
        views.STACKDB.save(exists)
        self.mox.ReplayAll()
        views._process_exists(raw, notification)
        self.mox.VerifyAll()

    def test_process_exists_no_launched_at(self):
        notification = self.mox.CreateMockAnything()
        notification.instance = INSTANCE_ID_1
        notification.launched_at = None
        raw = self.mox.CreateMockAnything()
        raw.id = '1'
        self.setup_mock_log()
        self.log.warn('Ignoring exists without launched_at. RawData(1)')
        self.mox.ReplayAll()
        views._process_exists(raw, notification)
        self.mox.VerifyAll()

    def test_process_exists_with_deleted_at(self):
        current_time = datetime.datetime.utcnow()
        launch_time = current_time - datetime.timedelta(hours=23)
        launch_decimal = utils.decimal_utc(launch_time)
        delete_time = datetime.datetime.utcnow()
        deleted_decimal = utils.decimal_utc(delete_time)
        audit_beginning = current_time - datetime.timedelta(hours=20)
        audit_beginning_decimal = utils.decimal_utc(audit_beginning)
        audit_ending_decimal = utils.decimal_utc(current_time)
        notification = self._create_exists_notification(
            audit_beginning, current_time, launch_time, delete_time)
        raw = self.mox.CreateMockAnything()
        usage = self.mox.CreateMockAnything()
        launched_range = (launch_decimal, launch_decimal+1)
        views.STACKDB.get_instance_usage(instance=INSTANCE_ID_1,
                                         launched_at__range=launched_range)\
                     .AndReturn(usage)
        delete = self.mox.CreateMockAnything()
        views.STACKDB.get_instance_delete(instance=INSTANCE_ID_1,
                                          launched_at__range=launched_range)\
             .AndReturn(delete)
        exists_values = {
            'message_id': MESSAGE_ID_1,
            'instance': INSTANCE_ID_1,
            'launched_at': launch_decimal,
            'deleted_at': deleted_decimal,
            'audit_period_beginning': audit_beginning_decimal,
            'audit_period_ending': audit_ending_decimal,
            'instance_type_id': INSTANCE_TYPE_ID_1,
            'instance_flavor_id': INSTANCE_FLAVOR_ID_1,
            'usage': usage,
            'delete': delete,
            'raw': raw,
            'tenant': TENANT_ID_1,
            'rax_options': RAX_OPTIONS_1,
            'os_architecture': OS_ARCH_1,
            'os_version': OS_VERSION_1,
            'os_distro': OS_DISTRO_1,
            'bandwidth_public_out': BANDWIDTH_PUBLIC_OUTBOUND
        }
        exists = self.mox.CreateMockAnything()
        views.STACKDB.create_instance_exists(**exists_values).AndReturn(exists)
        views.STACKDB.save(exists)
        self.mox.ReplayAll()
        views._process_exists(raw, notification)
        self.mox.VerifyAll()


class StacktachImageUsageParsingTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        views.STACKDB = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_save_image_usage(self):
        raw = self.mox.CreateMockAnything()
        notification = self.mox.CreateMockAnything()
        notification.save_usage(raw)
        self.mox.ReplayAll()

        views._process_glance_usage(raw, notification)
        self.mox.VerifyAll()

    def test_save_image_delete(self):
        raw = self.mox.CreateMockAnything()
        notification = self.mox.CreateMockAnything()
        notification.save_delete(raw)
        self.mox.ReplayAll()

        views._process_glance_delete(raw, notification)
        self.mox.VerifyAll()

    def test_save_image_exists(self):
        raw = self.mox.CreateMockAnything()
        notification = self.mox.CreateMockAnything()
        notification.save_exists(raw)
        self.mox.ReplayAll()

        views._process_glance_exists(raw, notification)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_stacktach_db
# Copyright (c) 2013 - Rackspace Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import mox

from stacktach import db
from stacktach import stacklog
from stacktach import models
from tests.unit import StacktachBaseTestCase


class StacktachDBTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.log = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacklog, 'get_logger')
        self.mox.StubOutWithMock(models, 'RawData', use_mock_anything=True)
        models.RawData.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Deployment', use_mock_anything=True)
        models.Deployment.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Lifecycle', use_mock_anything=True)
        models.Lifecycle.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Timing', use_mock_anything=True)
        models.Timing.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'RequestTracker',
                                 use_mock_anything=True)
        models.RequestTracker.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceUsage',
                                 use_mock_anything=True)
        models.InstanceUsage.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceDeletes',
                                 use_mock_anything=True)
        models.InstanceDeletes.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceExists',
                                 use_mock_anything=True)
        models.InstanceExists.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'JsonReport', use_mock_anything=True)
        models.JsonReport.objects = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()

    def setup_mock_log(self, name=None):
        if name is None:
            stacklog.get_logger(name=mox.IgnoreArg(),
                                is_parent=False).AndReturn(self.log)
        else:
            stacklog.get_logger(name=name, is_parent=False).AndReturn(self.log)

    def test_safe_get(self):
        Model = self.mox.CreateMockAnything()
        Model.objects = self.mox.CreateMockAnything()
        filters = {'field1': 'value1', 'field2': 'value2'}
        results = self.mox.CreateMockAnything()
        Model.objects.filter(**filters).AndReturn(results)
        results.count().AndReturn(1)
        object = self.mox.CreateMockAnything()
        results[0].AndReturn(object)
        self.mox.ReplayAll()
        returned = db._safe_get(Model, **filters)
        self.assertEqual(returned, object)
        self.mox.VerifyAll()

    def test_safe_get_no_results(self):
        Model = self.mox.CreateMockAnything()
        Model.__name__ = 'Model'
        Model.objects = self.mox.CreateMockAnything()
        filters = {'field1': 'value1', 'field2': 'value2'}
        results = self.mox.CreateMockAnything()
        Model.objects.filter(**filters).AndReturn(results)
        results.count().AndReturn(0)
        log = self.mox.CreateMockAnything()
        self.setup_mock_log()
        self.log.warn('No records found for Model get.')
        self.mox.ReplayAll()
        returned = db._safe_get(Model, **filters)
        self.assertEqual(returned, None)
        self.mox.VerifyAll()

    def test_safe_get_multiple_results(self):
        Model = self.mox.CreateMockAnything()
        Model.__name__ = 'Model'
        Model.objects = self.mox.CreateMockAnything()
        filters = {'field1': 'value1', 'field2': 'value2'}
        results = self.mox.CreateMockAnything()
        Model.objects.filter(**filters).AndReturn(results)
        results.count().AndReturn(2)
        self.setup_mock_log()
        self.log.warn('Multiple records found for Model get.')
        object = self.mox.CreateMockAnything()
        results[0].AndReturn(object)
        self.mox.ReplayAll()
        returned = db._safe_get(Model, **filters)
        self.assertEqual(returned, object)
        self.mox.VerifyAll()

    def test_get_or_create_deployment(self):
        deployment = self.mox.CreateMockAnything()
        models.Deployment.objects.get_or_create(name='test').AndReturn(deployment)
        self.mox.ReplayAll()
        returned = db.get_or_create_deployment('test')
        self.assertEqual(returned, deployment)
        self.mox.VerifyAll()

    def _test_db_create_func(self, Model, func):
        params = {'field1': 'value1', 'field2': 'value2'}
        object = self.mox.CreateMockAnything()
        Model(**params).AndReturn(object)
        self.mox.ReplayAll()
        returned = func(**params)
        self.assertEqual(returned, object)
        self.mox.VerifyAll()

    def test_create_lifecycle(self):
        self._test_db_create_func(models.Lifecycle, db.create_lifecycle)

    def test_create_timing(self):
        self._test_db_create_func(models.Timing, db.create_timing)

    def test_create_request_tracker(self):
        self._test_db_create_func(models.RequestTracker,
                                  db.create_request_tracker)

    def test_create_instance_usage(self):
        self._test_db_create_func(models.InstanceUsage,
                                  db.create_instance_usage)

    def test_create_instance_delete(self):
        self._test_db_create_func(models.InstanceDeletes,
                                  db.create_instance_delete)

    def test_create_instance_exists(self):
        self._test_db_create_func(models.InstanceExists,
                                  db.create_instance_exists)

    def _test_db_find_func(self, Model, func, select_related=True):
        params = {'field1': 'value1', 'field2': 'value2'}
        results = self.mox.CreateMockAnything()
        if select_related:
            Model.objects.select_related().AndReturn(results)
            results.filter(**params).AndReturn(results)
        else:
            Model.objects.filter(**params).AndReturn(results)
        self.mox.ReplayAll()
        returned = func(**params)
        self.assertEqual(returned, results)
        self.mox.VerifyAll()

    def test_find_lifecycles(self):
        self._test_db_find_func(models.Lifecycle, db.find_lifecycles)

    def test_find_timings(self):
        self._test_db_find_func(models.Timing, db.find_timings)

    def test_find_request_trackers(self):
        self._test_db_find_func(models.RequestTracker,
                                db.find_request_trackers,
                                select_related=False)

    def _test_db_get_or_create_func(self, Model, func):
        params = {'field1': 'value1', 'field2': 'value2'}
        object = self.mox.CreateMockAnything()
        Model.objects.get_or_create(**params).AndReturn(object)
        self.mox.ReplayAll()
        returned = func(**params)
        self.assertEqual(returned, object)
        self.mox.VerifyAll()

    def test_get_or_create_instance_usage(self):
        self._test_db_get_or_create_func(models.InstanceUsage,
                                         db.get_or_create_instance_usage)

    def test_get_or_create_instance_delete(self):
        self._test_db_get_or_create_func(models.InstanceDeletes,
                                         db.get_or_create_instance_delete)

    def test_get_instance_usage(self):
        filters = {'field1': 'value1', 'field2': 'value2'}
        results = self.mox.CreateMockAnything()
        models.InstanceUsage.objects.filter(**filters).AndReturn(results)
        results.count().AndReturn(1)
        usage = self.mox.CreateMockAnything()
        results[0].AndReturn(usage)
        self.mox.ReplayAll()
        returned = db.get_instance_usage(**filters)
        self.assertEqual(returned, usage)
        self.mox.VerifyAll()

    def test_get_instance_delete(self):
        filters = {'field1': 'value1', 'field2': 'value2'}
        results = self.mox.CreateMockAnything()
        models.InstanceDeletes.objects.filter(**filters).AndReturn(results)
        results.count().AndReturn(1)
        usage = self.mox.CreateMockAnything()
        results[0].AndReturn(usage)
        self.mox.ReplayAll()
        returned = db.get_instance_delete(**filters)
        self.assertEqual(returned, usage)
        self.mox.VerifyAll()

    def test_save(self):
        o = self.mox.CreateMockAnything()
        o.save()
        self.mox.ReplayAll()
        db.save(o)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_stacktach_utils
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import mox
import decimal

from stacktach import utils as stacktach_utils
from utils import INSTANCE_ID_1
from utils import MESSAGE_ID_1
from utils import REQUEST_ID_1
from tests.unit import StacktachBaseTestCase


class StacktachUtilsTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_is_uuid_like(self):
        uuid = INSTANCE_ID_1
        self.assertTrue(stacktach_utils.is_uuid_like(uuid))

    def test_is_uuid_like_no_dashes(self):
        uuid = "08f685d963524dbc827196cc54bf14cd"
        self.assertTrue(stacktach_utils.is_uuid_like(uuid))

    def test_is_uuid_like_invalid(self):
        uuid = "$-^&#$"
        self.assertFalse(stacktach_utils.is_uuid_like(uuid))

    def test_is_request_id_like_with_uuid(self):
        uuid = MESSAGE_ID_1
        self.assertTrue(stacktach_utils.is_request_id_like(uuid))

    def test_is_message_id_like_with_req_uuid(self):
        uuid = REQUEST_ID_1
        self.assertTrue(stacktach_utils.is_request_id_like(uuid))

    def test_is_message_id_like_invalid_req(self):
        uuid = "req-$-^&#$"
        self.assertFalse(stacktach_utils.is_request_id_like(uuid))

    def test_is_message_id_like_invalid(self):
        uuid = "$-^&#$"
        self.assertFalse(stacktach_utils.is_request_id_like(uuid))

    def test_str_time_to_unix(self):
        self.assertEqual(
            stacktach_utils.str_time_to_unix("2013-05-15T11:51:11Z"),
            decimal.Decimal('1368618671'))

        self.assertEqual(
            stacktach_utils.str_time_to_unix("2013-05-15T11:51:11.123Z"),
            decimal.Decimal('1368618671.123'))

        self.assertEqual(
            stacktach_utils.str_time_to_unix("2013-05-15T11:51:11"),
            decimal.Decimal('1368618671'))

        self.assertEqual(
            stacktach_utils.str_time_to_unix("2013-05-15T11:51:11.123"),
            decimal.Decimal('1368618671.123'))

        self.assertEqual(
            stacktach_utils.str_time_to_unix("2013-05-15 11:51:11"),
            decimal.Decimal('1368618671'))

        self.assertEqual(
            stacktach_utils.str_time_to_unix("2013-05-15 11:51:11.123"),
            decimal.Decimal('1368618671.123'))

        with self.assertRaises(Exception):
            stacktach_utils.str_time_to_unix("invalid date"),
            decimal.Decimal('1368618671')

########NEW FILE########
__FILENAME__ = test_stacky_server
# Copyright (c) 2012 - Rackspace Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
import ast

import datetime
import decimal
import json
from django.core.exceptions import FieldError

import mox

from stacktach import datetime_to_decimal as dt
from stacktach import models
from stacktach import stacky_server
import utils
from utils import INSTANCE_ID_1, INSTANCE_TYPE_ID_1
from utils import INSTANCE_FLAVOR_ID_1
from utils import INSTANCE_ID_2
from utils import REQUEST_ID_1

from tests.unit import StacktachBaseTestCase


class StackyServerTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.mox.StubOutWithMock(models, 'RawData', use_mock_anything=True)
        models.RawData.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Deployment', use_mock_anything=True)
        self.mox.StubOutWithMock(models, 'GlanceRawData',
                                 use_mock_anything=True)
        models.GlanceRawData.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'GenericRawData',
                                 use_mock_anything=True)
        models.GenericRawData.objects = self.mox.CreateMockAnything()
        models.Deployment.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Lifecycle', use_mock_anything=True)
        models.Lifecycle.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'Timing', use_mock_anything=True)
        models.Timing.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'RequestTracker',
                                 use_mock_anything=True)
        models.RequestTracker.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceUsage',
                                 use_mock_anything=True)
        models.InstanceUsage.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceDeletes',
                                 use_mock_anything=True)
        models.InstanceDeletes.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'InstanceExists',
                                 use_mock_anything=True)
        models.InstanceExists.objects = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(models, 'JsonReport', use_mock_anything=True)
        models.JsonReport.objects = self.mox.CreateMockAnything()

    def tearDown(self):
        self.mox.UnsetStubs()

    def _create_raw(self):
        raw = self.mox.CreateMockAnything()
        raw.when = utils.decimal_utc(datetime.datetime(2013, 7, 17, 10, 16,
                                                       10, 717219))
        raw.instance = INSTANCE_ID_1
        raw.id = 1
        raw.routing_key = 'monitor.info'
        raw.deployment = self.mox.CreateMockAnything()
        raw.deployment.id = 1
        raw.deployment.name = 'deployment'
        raw.event = 'test.start'
        raw.host = 'example.com'
        raw.state = 'active'
        raw.old_state = None
        raw.old_task = None
        raw.publisher = "api.example.com"
        raw.service = 'api'
        raw.host = 'example.com'
        raw.status = 'state'
        raw.request_id = REQUEST_ID_1
        raw.json = '{"key": "value"}'
        raw.uuid = 'uuid'
        raw.tenant = 'tenant'
        return raw

    def test_get_event_names(self):
        model = self.mox.CreateMockAnything()
        result = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacky_server, '_model_factory')
        stacky_server._model_factory('nova').AndReturn(model)
        model.values('event').AndReturn(result)
        result.distinct().AndReturn(result)
        self.mox.ReplayAll()

        event_names = stacky_server.get_event_names()
        self.assertEqual(event_names, result)

        self.mox.VerifyAll()

    def test_get_host_names_for_nova(self):
        result = self.mox.CreateMockAnything()
        models.RawData.objects.values('host').AndReturn(result)
        result.distinct().AndReturn(result)
        self.mox.ReplayAll()

        event_names = stacky_server.get_host_names('nova')
        self.assertEqual(event_names, result)

        self.mox.VerifyAll()

    def test_get_host_names_for_glance(self):
        result = self.mox.CreateMockAnything()
        models.GlanceRawData.objects.values('host').AndReturn(result)
        result.distinct().AndReturn(result)
        self.mox.ReplayAll()

        event_names = stacky_server.get_host_names('glance')
        self.assertEqual(event_names, result)

        self.mox.VerifyAll()

    def test_get_deployments(self):
        result = self.mox.CreateMockAnything()
        models.Deployment.objects.all().AndReturn(result)
        result.order_by('name').AndReturn(result)
        self.mox.ReplayAll()

        event_names = stacky_server.get_deployments()
        self.assertEqual(event_names, result)

        self.mox.VerifyAll()

    def test_get_timings_for_uuid_start_only(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        lc_result = self.mox.CreateMockAnything()
        lifecycle = self.mox.CreateMockAnything()
        models.Lifecycle.objects.filter(instance=INSTANCE_ID_1)\
                                .AndReturn(lc_result)
        lc_result[None:50].AndReturn(lc_result)
        lc_result.__iter__().AndReturn([lifecycle].__iter__())
        t_result = self.mox.CreateMockAnything()
        timing = self.mox.CreateMockAnything()
        models.Timing.objects.filter(lifecycle=lifecycle).AndReturn(t_result)
        t_result.__iter__().AndReturn([timing].__iter__())
        timing.name = 'name'
        timing.start_raw = self.mox.CreateMockAnything()
        timing.end_raw = None
        timing.diff = None
        self.mox.ReplayAll()

        event_names = stacky_server.get_timings_for_uuid(fake_request,
                                                         INSTANCE_ID_1)

        self.assertEqual(len(event_names), 2)
        self.assertEqual(event_names[0], ['?', 'Event', 'Time (secs)'])
        self.assertEqual(event_names[1], ['S', 'name', 'n/a'])
        self.mox.VerifyAll()

    def test_get_timings_for_uuid_end_only(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        lc_result = self.mox.CreateMockAnything()
        lifecycle = self.mox.CreateMockAnything()
        models.Lifecycle.objects.filter(instance=INSTANCE_ID_1) \
                                .AndReturn(lc_result)
        lc_result[None:50].AndReturn(lc_result)
        lc_result.__iter__().AndReturn([lifecycle].__iter__())
        t_result = self.mox.CreateMockAnything()
        timing = self.mox.CreateMockAnything()
        models.Timing.objects.filter(lifecycle=lifecycle).AndReturn(t_result)
        t_result.__iter__().AndReturn([timing].__iter__())
        timing.name = 'name'
        timing.start_raw = None
        timing.end_raw = self.mox.CreateMockAnything()
        timing.diff = None
        self.mox.ReplayAll()

        event_names = stacky_server.get_timings_for_uuid(fake_request,
                                                         INSTANCE_ID_1)

        self.assertEqual(len(event_names), 2)
        self.assertEqual(event_names[0], ['?', 'Event', 'Time (secs)'])
        self.assertEqual(event_names[1], ['E', 'name', 'n/a'])
        self.mox.VerifyAll()

    def test_get_timings_for_uuid(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        lc_result = self.mox.CreateMockAnything()
        lifecycle = self.mox.CreateMockAnything()
        models.Lifecycle.objects.filter(instance=INSTANCE_ID_1) \
            .AndReturn(lc_result)
        lc_result[None:50].AndReturn(lc_result)
        lc_result.__iter__().AndReturn([lifecycle].__iter__())
        t_result = self.mox.CreateMockAnything()
        timing = self.mox.CreateMockAnything()
        models.Timing.objects.filter(lifecycle=lifecycle).AndReturn(t_result)
        t_result.__iter__().AndReturn([timing].__iter__())
        timing.name = 'name'
        timing.start_raw = self.mox.CreateMockAnything()
        timing.end_raw = self.mox.CreateMockAnything()
        timing.diff = 20
        self.mox.ReplayAll()
        event_names = stacky_server.get_timings_for_uuid(fake_request,
                                                         INSTANCE_ID_1)

        self.assertEqual(len(event_names), 2)
        self.assertEqual(event_names[0], ['?', 'Event', 'Time (secs)'])
        self.assertEqual(event_names[1], ['.', 'name', '0d 00:00:20'])

        self.mox.VerifyAll()

    def test_do_deployments(self):
        fake_request = self.mox.CreateMockAnything()
        deployment1 = self.mox.CreateMockAnything()
        deployment1.id = 1
        deployment1.name = 'dep1'
        deployment2 = self.mox.CreateMockAnything()
        deployment2.id = 2
        deployment2.name = 'dep2'
        deployments = [deployment1, deployment2]
        self.mox.StubOutWithMock(stacky_server, 'get_deployments')
        stacky_server.get_deployments().AndReturn(deployments)
        self.mox.ReplayAll()

        resp = stacky_server.do_deployments(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], ['#', 'Name'])
        self.assertEqual(json_resp[1], [1, 'dep1'])
        self.assertEqual(json_resp[2], [2, 'dep2'])
        self.mox.VerifyAll()

    def test_do_events_of_a_single_service(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'service': 'nova'}
        event1 = {'event': 'some.event.1'}
        event2 = {'event': 'some.event.2'}
        events = [event1, event2]
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        stacky_server.get_event_names(service='nova').AndReturn(events)
        self.mox.ReplayAll()

        resp = stacky_server.do_events(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], ['Event Name'])
        self.assertEqual(json_resp[1], ['some.event.1'])
        self.assertEqual(json_resp[2], ['some.event.2'])
        self.mox.VerifyAll()

    def test_do_events_of_all_services(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'service': 'all'}
        event1 = {'event': 'some.event.1'}
        event2 = {'event': 'some.event.2'}
        events = [event1, event2]
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        stacky_server.get_event_names('nova').AndReturn(events)
        stacky_server.get_event_names('glance').AndReturn(events)
        stacky_server.get_event_names('generic').AndReturn(events)
        self.mox.ReplayAll()

        resp = stacky_server.do_events(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 7)
        self.assertEqual(json_resp[0], ['Event Name'])
        self.assertEqual(json_resp[1], ['some.event.1'])
        self.assertEqual(json_resp[2], ['some.event.2'])
        self.mox.VerifyAll()

    def test_do_hosts(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'service': 'service'}
        host1 = {'host': 'www.demo.com'}
        host2 = {'host': 'www.example.com'}
        hosts = [host1, host2]
        self.mox.StubOutWithMock(stacky_server, 'get_host_names')
        stacky_server.get_host_names('service').AndReturn(hosts)
        self.mox.ReplayAll()

        resp = stacky_server.do_hosts(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], ['Host Name'])
        self.assertEqual(json_resp[1], ['www.demo.com'])
        self.assertEqual(json_resp[2], ['www.example.com'])
        self.mox.VerifyAll()

    def test_do_uuid(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'uuid': INSTANCE_ID_1}
        result = self.mox.CreateMockAnything()
        models.RawData.objects.select_related().AndReturn(result)
        result.filter(instance=INSTANCE_ID_1).AndReturn(result)
        result.order_by('when').AndReturn(result)
        raw = self._create_raw()
        result[None:50].AndReturn(result)
        result.__iter__().AndReturn([raw].__iter__())
        raw.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        self.mox.ReplayAll()

        resp = stacky_server.do_uuid(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        header = ["#", "?", "When", "Deployment", "Event", "Host",
                  "State", "State'", "Task'"]
        self.assertEqual(json_resp[0], header)
        datetime = dt.dt_from_decimal(raw.when)
        body = [1, " ", str(datetime), "deployment", "test.start",
                "example.com", "active", None, None]
        self.assertEqual(json_resp[1], body)
        self.mox.VerifyAll()

    def test_do_uuid_when_filters(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'uuid': INSTANCE_ID_1,
                            'when_min': '1.1',
                            'when_max': '2.1'}
        result = self.mox.CreateMockAnything()
        models.RawData.objects.select_related().AndReturn(result)
        result.filter(instance=INSTANCE_ID_1,
                      when__gte=decimal.Decimal('1.1'),
                      when__lte=decimal.Decimal('2.1')).AndReturn(result)
        result.order_by('when').AndReturn(result)
        raw = self._create_raw()
        result[None:50].AndReturn(result)
        result.__iter__().AndReturn([raw].__iter__())
        raw.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        self.mox.ReplayAll()

        resp = stacky_server.do_uuid(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        header = ["#", "?", "When", "Deployment", "Event", "Host",
                  "State", "State'", "Task'"]
        self.assertEqual(json_resp[0], header)
        datetime = dt.dt_from_decimal(raw.when)
        body = [1, " ", str(datetime), "deployment", "test.start",
                "example.com", "active", None, None]
        self.assertEqual(json_resp[1], body)
        self.mox.VerifyAll()

    def test_do_uuid_for_glance(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "Status"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "state"]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'uuid': INSTANCE_ID_1, 'service': 'glance'}
        result = self.mox.CreateMockAnything()
        models.GlanceRawData.objects.select_related().AndReturn(result)
        result.filter(uuid=INSTANCE_ID_1).AndReturn(result)
        result.order_by('when').AndReturn(result)
        raw = self._create_raw()
        result[None:50].AndReturn(result)
        result.__iter__().AndReturn([raw].__iter__())
        raw.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        self.mox.ReplayAll()

        resp = stacky_server.do_uuid(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        header = ["#", "?", "When", "Deployment", "Event", "Host",
                  "Status"]
        self.assertEqual(json_resp[0], header)
        datetime = dt.dt_from_decimal(raw.when)
        body = [1, " ", str(datetime), "deployment", "test.start",
                "example.com", "state"]
        self.assertEqual(json_resp[1], body)
        self.mox.VerifyAll()

    def test_do_uuid_for_glance_when_filters(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "Status"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "state"]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'uuid': INSTANCE_ID_1,
                            'when_min': '1.1',
                            'when_max': '2.1',
                            'service': 'glance'}
        result = self.mox.CreateMockAnything()
        models.GlanceRawData.objects.select_related().AndReturn(result)
        result.filter(uuid=INSTANCE_ID_1,
                      when__gte=decimal.Decimal('1.1'),
                      when__lte=decimal.Decimal('2.1')).AndReturn(result)
        result.order_by('when').AndReturn(result)
        raw = self._create_raw()
        result[None:50].AndReturn(result)
        result.__iter__().AndReturn([raw].__iter__())
        raw.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        self.mox.ReplayAll()

        resp = stacky_server.do_uuid(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        header = ["#", "?", "When", "Deployment", "Event", "Host",
                  "Status"]
        self.assertEqual(json_resp[0], header)
        datetime = dt.dt_from_decimal(raw.when)
        body = [1, " ", str(datetime), "deployment", "test.start",
                "example.com", "state"]
        self.assertEqual(json_resp[1], body)
        self.mox.VerifyAll()

    def test_do_uuid_bad_uuid(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'uuid': "obviouslybaduuid"}
        self.mox.ReplayAll()

        resp = stacky_server.do_uuid(fake_request)

        self.assertEqual(resp.status_code, 400)
        resp_json = json.loads(resp.content)
        self.assertEqual(len(resp_json), 2)
        self.assertEqual(resp_json[0], ['Error', 'Message'])
        msg = 'obviouslybaduuid is not uuid-like'
        self.assertEqual(resp_json[1], ['Bad Request', msg])
        self.mox.VerifyAll()

    def test_do_timings_uuid_bad_uuid(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'uuid': "obviouslybaduuid"}
        self.mox.ReplayAll()

        resp = stacky_server.do_timings_uuid(fake_request)

        self.assertEqual(resp.status_code, 400)
        resp_json = json.loads(resp.content)
        self.assertEqual(len(resp_json), 2)
        self.assertEqual(resp_json[0], ['Error', 'Message'])
        msg = 'obviouslybaduuid is not uuid-like'
        self.assertEqual(resp_json[1], ['Bad Request', msg])
        self.mox.VerifyAll()

    def test_do_timings(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'name': 'test.event'}
        results = self.mox.CreateMockAnything()
        models.Timing.objects.select_related().AndReturn(results)
        results.filter(name='test.event').AndReturn(results)
        results.exclude(mox.IgnoreArg()).AndReturn(results)
        results.order_by('diff').AndReturn(results)
        timing1 = self.mox.CreateMockAnything()
        timing1.lifecycle = self.mox.CreateMockAnything()
        timing1.lifecycle.instance = INSTANCE_ID_1
        timing1.diff = 10
        timing2 = self.mox.CreateMockAnything()
        timing2.lifecycle = self.mox.CreateMockAnything()
        timing2.lifecycle.instance = INSTANCE_ID_2
        timing2.diff = 20
        results[None:50].AndReturn(results)
        results.__iter__().AndReturn([timing1, timing2].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_timings(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        header = ["test.event", "Time"]
        self.assertEqual(json_resp[0], header)
        self.assertEqual(json_resp[1], [INSTANCE_ID_1, '0d 00:00:10'])
        self.assertEqual(json_resp[2], [INSTANCE_ID_2, '0d 00:00:20'])
        self.mox.VerifyAll()

    def test_do_timings_end_when_min(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'name': 'test.event', 'end_when_min': '1.1'}
        results = self.mox.CreateMockAnything()
        models.Timing.objects.select_related().AndReturn(results)
        results.filter(name='test.event',
                       end_when__gte=decimal.Decimal('1.1')).AndReturn(results)
        results.exclude(mox.IgnoreArg()).AndReturn(results)
        results.order_by('diff').AndReturn(results)
        timing1 = self.mox.CreateMockAnything()
        timing1.lifecycle = self.mox.CreateMockAnything()
        timing1.lifecycle.instance = INSTANCE_ID_1
        timing1.diff = 10
        timing2 = self.mox.CreateMockAnything()
        timing2.lifecycle = self.mox.CreateMockAnything()
        timing2.lifecycle.instance = INSTANCE_ID_2
        timing2.diff = 20
        results[None:50].AndReturn(results)
        results.__iter__().AndReturn([timing1, timing2].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_timings(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        header = ["test.event", "Time"]
        self.assertEqual(json_resp[0], header)
        self.assertEqual(json_resp[1], [INSTANCE_ID_1, '0d 00:00:10'])
        self.assertEqual(json_resp[2], [INSTANCE_ID_2, '0d 00:00:20'])
        self.mox.VerifyAll()

    def test_do_timings_end_when_max(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'name': 'test.event', 'end_when_max': '1.1'}
        results = self.mox.CreateMockAnything()
        models.Timing.objects.select_related().AndReturn(results)
        results.filter(name='test.event',
                       end_when__lte=decimal.Decimal('1.1')).AndReturn(results)
        results.exclude(mox.IgnoreArg()).AndReturn(results)
        results.order_by('diff').AndReturn(results)
        timing1 = self.mox.CreateMockAnything()
        timing1.lifecycle = self.mox.CreateMockAnything()
        timing1.lifecycle.instance = INSTANCE_ID_1
        timing1.diff = 10
        timing2 = self.mox.CreateMockAnything()
        timing2.lifecycle = self.mox.CreateMockAnything()
        timing2.lifecycle.instance = INSTANCE_ID_2
        timing2.diff = 20
        results[None:50].AndReturn(results)
        results.__iter__().AndReturn([timing1, timing2].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_timings(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        header = ["test.event", "Time"]
        self.assertEqual(json_resp[0], header)
        self.assertEqual(json_resp[1], [INSTANCE_ID_1, '0d 00:00:10'])
        self.assertEqual(json_resp[2], [INSTANCE_ID_2, '0d 00:00:20'])
        self.mox.VerifyAll()

    def test_do_timings_end_when_max_when_min(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'name': 'test.event',
                            'end_when_min': '1.1',
                            'end_when_max': '2.1'}
        results = self.mox.CreateMockAnything()
        models.Timing.objects.select_related().AndReturn(results)
        results.filter(name='test.event',
                       end_when__gte=decimal.Decimal('1.1'),
                       end_when__lte=decimal.Decimal('2.1')).AndReturn(results)
        results.exclude(mox.IgnoreArg()).AndReturn(results)
        results.order_by('diff').AndReturn(results)
        timing1 = self.mox.CreateMockAnything()
        timing1.lifecycle = self.mox.CreateMockAnything()
        timing1.lifecycle.instance = INSTANCE_ID_1
        timing1.diff = 10
        timing2 = self.mox.CreateMockAnything()
        timing2.lifecycle = self.mox.CreateMockAnything()
        timing2.lifecycle.instance = INSTANCE_ID_2
        timing2.diff = 20
        results[None:50].AndReturn(results)
        results.__iter__().AndReturn([timing1, timing2].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_timings(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        header = ["test.event", "Time"]
        self.assertEqual(json_resp[0], header)
        self.assertEqual(json_resp[1], [INSTANCE_ID_1, '0d 00:00:10'])
        self.assertEqual(json_resp[2], [INSTANCE_ID_2, '0d 00:00:20'])
        self.mox.VerifyAll()

    def test_do_summary(self):
        fake_request = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        events = [{'event': 'test.start'}, {'event': 'test.end'}]
        stacky_server.get_event_names().AndReturn(events)
        fake_request.GET = {'name': 'test.event'}
        results = self.mox.CreateMockAnything()
        models.Timing.objects.filter(name='test').AndReturn(results)
        results.exclude(mox.IgnoreArg()).AndReturn(results)
        results.exclude(diff__lt=0).AndReturn(results)
        timing1 = self.mox.CreateMockAnything()
        timing1.lifecycle = self.mox.CreateMockAnything()
        timing1.lifecycle.instance = INSTANCE_ID_1
        timing1.diff = 10
        timing2 = self.mox.CreateMockAnything()
        timing2.lifecycle = self.mox.CreateMockAnything()
        timing2.lifecycle.instance = INSTANCE_ID_2
        timing2.diff = 20
        results[None:50].AndReturn(results)
        results.__len__().AndReturn(2)
        results.__iter__().AndReturn([timing1, timing2].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_summary(fake_request)
        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        self.assertEqual(json_resp[0], ["Event", "N", "Min", "Max", "Avg"])
        self.assertEqual(json_resp[1], [u'test', 2, u'0d 00:00:10.0',
                                        u'0d 00:00:20.0', u'0d 00:00:15'])

        self.mox.VerifyAll()

    def test_do_request(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'request_id': REQUEST_ID_1}
        raw = self._create_raw()
        results = self.mox.CreateMockAnything()
        models.RawData.objects.filter(request_id=REQUEST_ID_1).AndReturn(results)
        results.order_by('when').AndReturn(results)
        results[None:50].AndReturn(results)
        results.__iter__().AndReturn([raw].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_request(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        self.assertEqual(json_resp[0], ["#", "?", "When", "Deployment",
                                        "Event", "Host", "State", "State'",
                                        "Task'"])
        self.assertEqual(json_resp[1][0], 1)
        self.assertEqual(json_resp[1][1], u' ')
        self.assertEqual(json_resp[1][2], str(dt.dt_from_decimal(raw.when)))
        self.assertEqual(json_resp[1][3], u'deployment')
        self.assertEqual(json_resp[1][4], u'test.start')
        self.assertEqual(json_resp[1][5], u'example.com')
        self.assertEqual(json_resp[1][6], u'active')
        self.assertEqual(json_resp[1][7], None)
        self.assertEqual(json_resp[1][8], None)
        self.mox.VerifyAll()

    def test_do_request_when_filters(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'request_id': REQUEST_ID_1,
                            'when_min': '1.1',
                            'when_max': '2.1'}
        raw = self._create_raw()
        results = self.mox.CreateMockAnything()
        when_min = decimal.Decimal('1.1')
        when_max = decimal.Decimal('2.1')
        models.RawData.objects.filter(request_id=REQUEST_ID_1,
                                      when__gte=when_min,
                                      when__lte=when_max).AndReturn(results)
        results.order_by('when').AndReturn(results)
        results[None:50].AndReturn(results)
        results.__iter__().AndReturn([raw].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_request(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 2)
        self.assertEqual(json_resp[0], ["#", "?", "When", "Deployment",
                                        "Event", "Host", "State", "State'",
                                        "Task'"])
        self.assertEqual(json_resp[1][0], 1)
        self.assertEqual(json_resp[1][1], u' ')
        self.assertEqual(json_resp[1][2], str(dt.dt_from_decimal(raw.when)))
        self.assertEqual(json_resp[1][3], u'deployment')
        self.assertEqual(json_resp[1][4], u'test.start')
        self.assertEqual(json_resp[1][5], u'example.com')
        self.assertEqual(json_resp[1][6], u'active')
        self.assertEqual(json_resp[1][7], None)
        self.assertEqual(json_resp[1][8], None)
        self.mox.VerifyAll()

    def test_do_request_bad_request_id(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'request_id': "obviouslybaduuid"}
        self.mox.ReplayAll()

        resp = stacky_server.do_request(fake_request)

        self.assertEqual(resp.status_code, 400)
        resp_json = json.loads(resp.content)
        self.assertEqual(len(resp_json), 2)
        self.assertEqual(resp_json[0], ['Error', 'Message'])
        msg = 'obviouslybaduuid is not request-id-like'
        self.assertEqual(resp_json[1], ['Bad Request', msg])
        self.mox.VerifyAll()

    def _assert_on_show_nova(self, json_resp, raw):
        self.assertEqual(len(json_resp), 3)
        values = json_resp[0]
        self.assertEqual(len(values), 12)
        self.assertEqual(values[0], ["Key", "Value"])
        self.assertEqual(values[1], ["#", raw.id])
        self.assertEqual(values[2], ["When",
                                     str(dt.dt_from_decimal(raw.when))])
        self.assertEqual(values[3], ["Deployment", raw.deployment.name])
        self.assertEqual(values[4], ["Category", raw.routing_key])
        self.assertEqual(values[5], ["Publisher", raw.publisher])
        self.assertEqual(values[6], ["State", raw.state])
        self.assertEqual(values[7], ["Event", raw.event])
        self.assertEqual(values[8], ["Service", raw.service])
        self.assertEqual(values[9], ["Host", raw.host])
        self.assertEqual(values[10],["UUID", raw.instance])
        self.assertEqual(values[11], ["Req ID", raw.request_id])

    def _assert_on_show_glance(self, json_resp, raw):
        self.assertEqual(len(json_resp), 3)
        values = json_resp[0]
        self.assertEqual(len(values), 12)
        self.assertEqual(values[0], ["Key", "Value"])
        self.assertEqual(values[1], ["#", raw.id])
        self.assertEqual(values[2], ["When",
                                     str(dt.dt_from_decimal(raw.when))])
        self.assertEqual(values[3], ["Deployment", raw.deployment.name])
        self.assertEqual(values[4], ["Category", raw.routing_key])
        self.assertEqual(values[5], ["Publisher", raw.publisher])
        self.assertEqual(values[6], ["Status", raw.status])
        self.assertEqual(values[7], ["Event", raw.event])
        self.assertEqual(values[8], ["Service", raw.service])
        self.assertEqual(values[9], ["Host", raw.host])
        self.assertEqual(values[10],["UUID", raw.uuid])
        self.assertEqual(values[11], ["Req ID", raw.request_id])

    def test_do_show(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        raw = self._create_raw()
        models.RawData.objects.get(id=1).AndReturn(raw)
        self.mox.ReplayAll()

        resp = stacky_server.do_show(fake_request, 1)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self._assert_on_show_nova(json_resp, raw)
        self.mox.VerifyAll()

    def test_do_show_for_glance_rawdata(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'service':'glance'}
        raw = self._create_raw()
        models.GlanceRawData.objects.get(id=1).AndReturn(raw)
        self.mox.ReplayAll()

        resp = stacky_server.do_show(fake_request, 1)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self._assert_on_show_glance(json_resp, raw)
        self.mox.VerifyAll()

    def test_do_show_for_generic_rawdata(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'service':'generic'}
        raw = self._create_raw()
        models.GenericRawData.objects.get(id=1).AndReturn(raw)
        self.mox.ReplayAll()

        resp = stacky_server.do_show(fake_request, 1)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self._assert_on_show_nova(json_resp, raw)
        self.mox.VerifyAll()

    def test_do_show_should_return_empty_result_on_object_not_found_exception(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}

        raw = self._create_raw()
        models.RawData.objects.get(id=1).AndReturn(raw)
        self.mox.ReplayAll()

        resp = stacky_server.do_show(fake_request, 1)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self._assert_on_show_nova(json_resp, raw)
        self.mox.VerifyAll()

    def test_do_watch_for_glance(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'service': 'glance'}
        self.mox.StubOutWithMock(stacky_server, 'get_deployments')
        deployment1 = self.mox.CreateMockAnything()
        deployment1.id = 1
        deployment1.name = 'dep1'
        deployments = [deployment1]
        stacky_server.get_deployments().AndReturn(deployments)
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        events = [{'event': 'test.start'}, {'event': 'test.end'}]
        stacky_server.get_event_names().AndReturn(events)
        results = self.mox.CreateMockAnything()
        models.GlanceRawData.objects.order_by('when').AndReturn(results)
        results.filter(when__gt=mox.IgnoreArg()).AndReturn(results)
        results.filter(when__lte=mox.IgnoreArg()).AndReturn(results)
        results.__iter__().AndReturn([self._create_raw()].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_watch(fake_request, 0)
        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], [10, 1, 15, 20, 10, 36])
        self.assertEqual(json_resp[1][0][0], 1)
        self.assertEqual(json_resp[1][0][1], u' ')
        time_str = "%s %s" % (json_resp[1][0][2], json_resp[1][0][3])
        datetime.datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S.%f")
        self.assertEqual(json_resp[1][0][4], u'dep1')
        self.assertEqual(json_resp[1][0][5], u'test.start')
        self.assertEqual(json_resp[1][0][6], u'%s' % 'uuid')
        self.mox.VerifyAll()

    def test_do_watch(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        self.mox.StubOutWithMock(stacky_server, 'get_deployments')
        deployment1 = self.mox.CreateMockAnything()
        deployment1.id = 1
        deployment1.name = 'dep1'
        deployments = [deployment1]
        stacky_server.get_deployments().AndReturn(deployments)
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        events = [{'event': 'test.start'}, {'event': 'test.end'}]
        stacky_server.get_event_names().AndReturn(events)
        results = self.mox.CreateMockAnything()
        model = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacky_server, '_model_factory')
        stacky_server._model_factory('nova').AndReturn(model)
        model.order_by('when').AndReturn(results)
        results.filter(when__gt=mox.IgnoreArg()).AndReturn(results)
        results.filter(when__lte=mox.IgnoreArg()).AndReturn(results)
        results.__iter__().AndReturn([self._create_raw()].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_watch(fake_request, 0)
        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], [10, 1, 15, 20, 10, 36])
        self.assertEqual(json_resp[1][0][0], 1)
        self.assertEqual(json_resp[1][0][1], u' ')
        time_str = "%s %s" % (json_resp[1][0][2], json_resp[1][0][3])
        datetime.datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S.%f")
        self.assertEqual(json_resp[1][0][4], u'dep1')
        self.assertEqual(json_resp[1][0][5], u'test.start')
        self.assertEqual(json_resp[1][0][6], u'%s' % 'uuid')
        self.mox.VerifyAll()

    def test_do_watch_with_deployment(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'deployment': 1}
        self.mox.StubOutWithMock(stacky_server, 'get_deployments')
        deployment1 = self.mox.CreateMockAnything()
        deployment1.id = 1
        deployment1.name = 'dep1'
        deployments = [deployment1]
        stacky_server.get_deployments().AndReturn(deployments)
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        events = [{'event': 'test.start'}, {'event': 'test.end'}]
        stacky_server.get_event_names().AndReturn(events)
        results = self.mox.CreateMockAnything()
        model = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacky_server, '_model_factory')
        stacky_server._model_factory('nova').AndReturn(model)
        model.order_by('when').AndReturn(results)

        results.filter(deployment=1).AndReturn(results)
        results.filter(when__gt=mox.IgnoreArg()).AndReturn(results)
        results.filter(when__lte=mox.IgnoreArg()).AndReturn(results)
        results.__iter__().AndReturn([self._create_raw()].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_watch(fake_request, 1)
        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], [10, 1, 15, 20, 10, 36])
        self.assertEqual(json_resp[1][0][0], 1)
        self.assertEqual(json_resp[1][0][1], u' ')
        time_str = "%s %s" % (json_resp[1][0][2], json_resp[1][0][3])
        datetime.datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S.%f")
        self.assertEqual(json_resp[1][0][4], u'dep1')
        self.assertEqual(json_resp[1][0][5], u'test.start')
        self.assertEqual(json_resp[1][0][6], u'%s' % 'uuid')
        self.mox.VerifyAll()

    def test_do_watch_with_event_name(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'event_name': 'test.start','service': 'nova'}
        self.mox.StubOutWithMock(stacky_server, 'get_deployments')
        deployment1 = self.mox.CreateMockAnything()
        deployment1.id = 1
        deployment1.name = 'dep1'
        deployments = [deployment1]
        stacky_server.get_deployments().AndReturn(deployments)
        self.mox.StubOutWithMock(stacky_server, 'get_event_names')
        events = [{'event': 'test.start'}, {'event': 'test.end'}]
        stacky_server.get_event_names().AndReturn(events)
        results = self.mox.CreateMockAnything()
        models.RawData.objects.order_by('when').AndReturn(results)
        results.filter(event='test.start').AndReturn(results)
        results.filter(when__gt=mox.IgnoreArg()).AndReturn(results)
        results.filter(when__lte=mox.IgnoreArg()).AndReturn(results)
        results.__iter__().AndReturn([self._create_raw()].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_watch(fake_request, 0)
        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self.assertEqual(json_resp[0], [10, 1, 15, 20, 10, 36])
        self.assertEqual(json_resp[1][0][0], 1)
        self.assertEqual(json_resp[1][0][1], u' ')
        time_str = "%s %s" % (json_resp[1][0][2], json_resp[1][0][3])
        datetime.datetime.strptime(time_str, "%Y-%m-%d %H:%M:%S.%f")
        self.assertEqual(json_resp[1][0][4], u'dep1')
        self.assertEqual(json_resp[1][0][5], u'test.start')
        self.assertEqual(json_resp[1][0][6], u'%s' % 'uuid')
        self.mox.VerifyAll()

    def test_do_kpi(self):
        fake_request = self.mox.CreateMockAnything()
        results = self.mox.CreateMockAnything()
        models.RequestTracker.objects.select_related().AndReturn(results)
        results.exclude(last_timing=None).AndReturn(results)
        results.exclude(start__lt=mox.IgnoreArg()).AndReturn(results)
        results.order_by('duration').AndReturn(results)
        tracker = self.mox.CreateMockAnything()
        tracker.last_timing = self.mox.CreateMockAnything()
        tracker.last_timing.end_raw = self.mox.CreateMockAnything()
        tracker.last_timing.end_raw.event = 'test.end'
        deployment = self.mox.CreateMockAnything()
        deployment.name = 'dep1'
        tracker.last_timing.end_raw.deployment = deployment
        tracker.lifecycle = self.mox.CreateMockAnything()
        tracker.lifecycle.instance = INSTANCE_ID_1
        tracker.duration = 10
        results.__iter__().AndReturn([tracker].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_kpi(fake_request)
        self.assertEqual(resp.status_code, 200)
        body = resp.content
        body = json.loads(body)
        self.assertEqual(len(body), 2)
        self.assertEqual(body[0], ["Event", "Time", "UUID", "Deployment"])
        time = u'%s' % stacky_server.sec_to_time(10)
        self.assertEqual(body[1], [u'test', time, INSTANCE_ID_1, u'dep1'])

        self.mox.VerifyAll()

    def test_do_kpi_with_tenant(self):
        fake_request = self.mox.CreateMockAnything()
        objects = self.mox.CreateMockAnything()
        models.RawData.objects.filter(tenant='55555').AndReturn(objects)
        objects.count().AndReturn(1)
        results = self.mox.CreateMockAnything()
        models.RequestTracker.objects.select_related().AndReturn(results)
        results.exclude(last_timing=None).AndReturn(results)
        results.exclude(start__lt=mox.IgnoreArg()).AndReturn(results)
        results.order_by('duration').AndReturn(results)
        tracker = self.mox.CreateMockAnything()
        tracker.last_timing = self.mox.CreateMockAnything()
        tracker.last_timing.end_raw = self.mox.CreateMockAnything()
        tracker.last_timing.end_raw.event = 'test.end'
        tracker.last_timing.end_raw.tenant = '55555'
        deployment = self.mox.CreateMockAnything()
        deployment.name = 'dep1'
        tracker.last_timing.end_raw.deployment = deployment
        tracker.lifecycle = self.mox.CreateMockAnything()
        tracker.lifecycle.instance = INSTANCE_ID_1
        tracker.duration = 10
        results.__iter__().AndReturn([tracker].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_kpi(fake_request, '55555')
        self.assertEqual(resp.status_code, 200)
        body = resp.content
        body = json.loads(body)
        self.assertEqual(len(body), 2)
        self.assertEqual(body[0], ["Event", "Time", "UUID", "Deployment"])
        time = u'%s' % stacky_server.sec_to_time(10)
        self.assertEqual(body[1], [u'test', time, INSTANCE_ID_1, u'dep1'])

        self.mox.VerifyAll()

    def test_do_kpi_with_tenant_no_match(self):
        fake_request = self.mox.CreateMockAnything()
        objects = self.mox.CreateMockAnything()
        models.RawData.objects.filter(tenant='55555').AndReturn(objects)
        objects.count().AndReturn(1)
        results = self.mox.CreateMockAnything()
        models.RequestTracker.objects.select_related().AndReturn(results)
        results.exclude(last_timing=None).AndReturn(results)
        results.exclude(start__lt=mox.IgnoreArg()).AndReturn(results)
        results.order_by('duration').AndReturn(results)
        tracker = self.mox.CreateMockAnything()
        tracker.last_timing = self.mox.CreateMockAnything()
        tracker.last_timing.end_raw = self.mox.CreateMockAnything()
        tracker.last_timing.end_raw.event = 'test.end'
        tracker.last_timing.end_raw.tenant = '55556'
        deployment = self.mox.CreateMockAnything()
        deployment.name = 'dep1'
        tracker.last_timing.end_raw.deployment = deployment
        tracker.lifecycle = self.mox.CreateMockAnything()
        tracker.lifecycle.instance = INSTANCE_ID_1
        tracker.duration = 10
        results.__iter__().AndReturn([tracker].__iter__())
        self.mox.ReplayAll()

        resp = stacky_server.do_kpi(fake_request, '55555')
        self.assertEqual(resp.status_code, 200)
        body = resp.content
        body = json.loads(body)
        self.assertEqual(len(body), 1)

        self.mox.VerifyAll()

    def test_do_kpi_tenant_doesnt_exist(self):
        fake_request = self.mox.CreateMockAnything()
        objects = self.mox.CreateMockAnything()
        models.RawData.objects.filter(tenant='55555').AndReturn(objects)
        objects.count().AndReturn(0)
        self.mox.ReplayAll()

        resp = stacky_server.do_kpi(fake_request, '55555')
        self.assertEqual(resp.status_code, 404)
        body = resp.content
        body = json.loads(body)
        self.assertEqual(len(body), 2)
        self.assertEqual(body[0], ['Error', 'Message'])
        msg = 'Could not find raws for tenant 55555'
        self.assertEqual(body[1], ['Not Found', msg])

        self.mox.VerifyAll()

    def test_model_factory_for_nova(self):
        self.mox.UnsetStubs()
        nova_model = stacky_server._model_factory('nova')
        self.assertEqual(nova_model.model, models.RawData)

    def test_model_factory_for_nova(self):
        self.mox.UnsetStubs()
        nova_model = stacky_server._model_factory('glance')
        self.assertEqual(nova_model.model, models.GlanceRawData)

    def test_model_factory_for_nova(self):
        self.mox.UnsetStubs()
        nova_model = stacky_server._model_factory('generic')
        self.assertEqual(nova_model.model, models.GenericRawData)

    def _assert_on_search_nova(self, json_resp, raw):
        title = json_resp[0]
        values = json_resp[1]
        self.assertEqual(len(values), 9)
        self.assertEqual([title[0], values[0]],["#", raw.id] )
        self.assertEqual([title[1], values[1]], ['?', ' '])
        self.assertEqual([title[2], values[2]], ["When",
                                     str(dt.dt_from_decimal(raw.when))])
        self.assertEqual([title[3], values[3]], ["Deployment", raw.deployment.name])
        self.assertEqual([title[4], values[4]], ["Event", raw.event])
        self.assertEqual([title[5], values[5]], ["Host", raw.host])
        self.assertEqual([title[6], values[6]], ["State", raw.state])
        self.assertEqual([title[7], values[7]], ["State'", raw.old_state])

    def test_search_by_field_for_nova(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'field': 'tenant', 'value': 'tenant'}
        raw = self._create_raw()
        results = self.mox.CreateMockAnything()
        models.RawData.objects.filter(tenant='tenant').AndReturn(results)
        results.order_by('-when').AndReturn([raw])
        raw.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        self.mox.ReplayAll()

        resp = stacky_server.search(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self._assert_on_search_nova(json_resp, raw)
        self.mox.VerifyAll()

    def test_search_by_field_for_nova_when_filters(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'field': 'tenant', 'value': 'tenant',
                            'when_min': '1.1',
                            'when_max': '2.1'}
        raw = self._create_raw()
        results = self.mox.CreateMockAnything()
        models.RawData.objects.filter(tenant='tenant',
                                      when__gte=decimal.Decimal('1.1'),
                                      when__lte=decimal.Decimal('2.1')).AndReturn(results)
        results.order_by('-when').AndReturn([raw])
        raw.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        self.mox.ReplayAll()

        resp = stacky_server.search(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self._assert_on_search_nova(json_resp, raw)
        self.mox.VerifyAll()

    def test_search_by_field_for_nova_with_limit(self):
        search_result = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None]]
        search_result_2 = [["#", "?", "When", "Deployment", "Event", "Host",
                          "State", "State'", "Task'"], [1, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None],[2, " ",
                          "2013-07-17 10:16:10.717219", "deployment",
                          "test.start", "example.com", "active", None, None]]
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'field': 'tenant', 'value': 'tenant', 'limit': '2',
                            'service': 'nova'}
        raw1 = self._create_raw()
        raw2 = self._create_raw()
        raw3 = self._create_raw()
        raw2.id = 2
        raw3.id = 3
        results = self.mox.CreateMockAnything()
        models.RawData.objects.filter(tenant='tenant').AndReturn(results)
        results.order_by('-when').AndReturn([raw1, raw2, raw3])
        raw1.search_results([], mox.IgnoreArg(), ' ').AndReturn(search_result)
        raw2.search_results(search_result, mox.IgnoreArg(),' ').AndReturn(search_result_2)
        self.mox.ReplayAll()

        resp = stacky_server.search(fake_request)

        self.assertEqual(resp.status_code, 200)
        json_resp = json.loads(resp.content)
        self.assertEqual(len(json_resp), 3)
        self._assert_on_search_nova(json_resp, raw1)
        self.mox.VerifyAll()

    def test_search_with_wrong_field_value_returns_400_error_and_a_message(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'field': 'tenant', 'value': 'tenant'}
        models.RawData.objects.filter(tenant='tenant').AndRaise(FieldError)
        self.mox.ReplayAll()

        resp = stacky_server.search(fake_request)

        self.assertEqual(resp.status_code, 400)
        json_resp = json.loads(resp.content)
        self.assertEquals(json_resp[0],[u'Error', u'Message'])
        self.assertEquals(json_resp[1],
                          [u'Bad Request', u"The requested field"
        u" 'tenant' does not exist for the corresponding object.\nNote: "
        u"The field names of database are case-sensitive."])

        self.mox.VerifyAll()

    def test_model_search_default_limit(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        fake_model = self.mox.CreateMockAnything()
        filters = {'field': 'value'}
        results = self.mox.CreateMockAnything()
        fake_model.filter(**filters).AndReturn(results)
        results[None:50].AndReturn(results)
        self.mox.ReplayAll()
        actual_results = stacky_server.model_search(fake_request, fake_model,
                                                    filters)
        self.assertEqual(actual_results, results)
        self.mox.VerifyAll()

    def test_model_search_default_limit_with_offset(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'offset': '1'}
        fake_model = self.mox.CreateMockAnything()
        filters = {'field': 'value'}
        results = self.mox.CreateMockAnything()
        fake_model.filter(**filters).AndReturn(results)
        results[1:51].AndReturn(results)
        self.mox.ReplayAll()
        actual_results = stacky_server.model_search(fake_request, fake_model,
                                                    filters)
        self.assertEqual(actual_results, results)
        self.mox.VerifyAll()

    def test_model_search_default_with_limit(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'limit': '1'}
        fake_model = self.mox.CreateMockAnything()
        filters = {'field': 'value'}
        results = self.mox.CreateMockAnything()
        fake_model.filter(**filters).AndReturn(results)
        results[None:1].AndReturn(results)
        self.mox.ReplayAll()
        actual_results = stacky_server.model_search(fake_request, fake_model,
                                                    filters)
        self.assertEqual(actual_results, results)
        self.mox.VerifyAll()

    def test_model_search_default_with_limit_and_offset(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {'limit': '5',
                            'offset': '10'}
        fake_model = self.mox.CreateMockAnything()
        filters = {'field': 'value'}
        results = self.mox.CreateMockAnything()
        fake_model.filter(**filters).AndReturn(results)
        results[10:15].AndReturn(results)
        self.mox.ReplayAll()
        actual_results = stacky_server.model_search(fake_request, fake_model,
                                                    filters)
        self.assertEqual(actual_results, results)
        self.mox.VerifyAll()

    def test_model_search_related(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        fake_model = self.mox.CreateMockAnything()
        filters = {'field': 'value'}
        results = self.mox.CreateMockAnything()
        fake_model.select_related().AndReturn(results)
        results.filter(**filters).AndReturn(results)
        results[None:50].AndReturn(results)
        self.mox.ReplayAll()
        actual_results = stacky_server.model_search(fake_request, fake_model,
                                                    filters, related=True)
        self.assertEqual(actual_results, results)
        self.mox.VerifyAll()

    def test_model_order_by(self):
        fake_request = self.mox.CreateMockAnything()
        fake_request.GET = {}
        fake_model = self.mox.CreateMockAnything()
        filters = {'field': 'value'}
        results = self.mox.CreateMockAnything()
        fake_model.filter(**filters).AndReturn(results)
        results.order_by('when').AndReturn(results)
        results[None:50].AndReturn(results)
        self.mox.ReplayAll()
        actual_results = stacky_server.model_search(fake_request, fake_model,
                                                    filters, order_by='when')
        self.assertEqual(actual_results, results)
        self.mox.VerifyAll()


class JsonReportsSearchAPI(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()
        self.model = models.JsonReport.objects
        self.model_search_result = self.mox.CreateMockAnything()
        self.model_search_result.id = '5975'
        self.model_search_result.period_start = datetime.datetime(2014, 1, 18,)
        self.model_search_result.period_end = datetime.datetime(2014, 1, 19)
        self.model_search_result.created = 1388569200
        self.model_search_result.name = 'nova usage audit'
        self.model_search_result.version = 4

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_jsonreports_search_order_by_id(self):
        request = self.mox.CreateMockAnything()
        request.GET = {
            'id': 1,
            'name': 'nova_usage_audit',
            'period_start': '2014-01-01 00:00:00',
            'period_end': '2014-01-02 00:00:00',
            'created': '2014-01-01',
        }
        filters = {
            'id__exact': 1,
            'period_start__exact': '2014-01-01 00:00:00',
            'name__exact': 'nova_usage_audit',
            'period_end__exact': '2014-01-02 00:00:00',
            'created__lt': decimal.Decimal('1388620800'),
            'created__gt': decimal.Decimal('1388534400'),
        }
        self.mox.StubOutWithMock(stacky_server, 'model_search')
        stacky_server.model_search(request, self.model, filters,
                                   order_by='-id').AndReturn(
            [self.model_search_result])
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = [
            ['Id', 'Start', 'End', 'Created', 'Name', 'Version'],
            ['5975', '2014-01-18 00:00:00', '2014-01-19 00:00:00',
             '2014-01-01 09:40:00', 'nova usage audit', 4]
        ]

        self.assertEquals(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_with_limit_offset(self):
        request = self.mox.CreateMockAnything()
        request.GET = {
            'period_start': '2014-01-01 09:40:00',
            'name': 'nova_usage_audit',
            'limit': 10,
            'offset': 5
        }
        filters = {
            'period_start__exact': '2014-01-01 09:40:00',
            'name__exact': 'nova_usage_audit',
        }
        self.mox.StubOutWithMock(stacky_server, 'model_search')
        stacky_server.model_search(request, self.model, filters,
                                   order_by='-id').AndReturn(
            [self.model_search_result])
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = \
            [['Id', 'Start', 'End', 'Created', 'Name', 'Version'],
             ['5975', '2014-01-18 00:00:00', '2014-01-19 00:00:00',
              '2014-01-01 09:40:00', 'nova usage audit', 4]]

        self.assertEquals(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_with_invalid_fields(self):
        request = self.mox.CreateMockAnything()
        request.GET = {'invalid_column_1': 'value_1',
                       'invalid_column_2': 'value_2',
                       'version': 4,
                       'json': 'json',
                       'period_start': '2014-01-01 00:00:00'}
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = [
            ["Error", "Message"],
            ["Bad Request", "The requested fields either do not exist for the "
             "corresponding object or are not searchable: invalid_column_1, "
             "invalid_column_2, json, version. Note: The field names of "
             "database are case-sensitive."]
        ]
        self.assertEqual(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_with_invalid_period_start(self):
        request = self.mox.CreateMockAnything()
        request.GET = {'period_start': '1234'}
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = [
            ["Error", "Message"],
            ["Bad Request", "'1234' value has an invalid format. It must be in "
             "YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format."]
        ]
        self.assertEqual(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_with_invalid_period_end(self):
        request = self.mox.CreateMockAnything()
        request.GET = {'period_end': '1234'}
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = [
            ["Error", "Message"],
            ["Bad Request", "'1234' value has an invalid format. It must be in "
             "YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format."]
        ]
        self.assertEqual(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_with_invalid_id(self):
        request = self.mox.CreateMockAnything()
        request.GET = {'id': 'abcd'}
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = [
            ["Error", "Message"],
            ["Bad Request", "'abcd' value has an invalid format. It must be in "
             "integer format."]
        ]
        self.assertEqual(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_with_invalid_created_format(self):
        request = self.mox.CreateMockAnything()
        request.GET = {
            'created': '2014-01-01 00:00:00'
        }
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = [
            ["Error", "Message"],
            ["Bad Request", "'2014-01-01 00:00:00' value has an invalid format."
             " It must be in YYYY-MM-DD format."]
        ]

        self.assertEqual(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

    def test_jsonreports_search_by_invalid_created_400(self):
        request = self.mox.CreateMockAnything()
        request.GET = {
            'created': '1234'}
        self.mox.ReplayAll()

        actual_result = stacky_server.do_jsonreports_search(request).content
        expected_result = \
        [
            ["Error", "Message"],
            ["Bad Request", "'1234' value has an invalid format. It must be in "
             "YYYY-MM-DD format."]
        ]
        self.assertEquals(ast.literal_eval(actual_result), expected_result)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = test_verification_exception
import mox
from tests.unit import StacktachBaseTestCase, utils
from verifier import NotFound, AmbiguousResults, FieldMismatch
from verifier import NullFieldException, WrongTypeException


class VerificationExceptionTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def test_not_found_exception(self):
        exception = NotFound('object_type', 'search_params')

        self.assertEqual(exception.reason,
                         "Couldn't find object_type using search_params")

    def test_ambiguous_results_exception(self):
        exception = AmbiguousResults('object_type', 'search_params')

        self.assertEqual(
            exception.reason,
            "Ambiguous results for object_type using search_params")

    def test_field_mismatch_exception(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exception = FieldMismatch(
            'field_name',
            {'name': 'entity1', 'value': 'expected'},
            {'name': 'entity2', 'value': 'actual'},
            'uuid')

        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for uuid: Data mismatch for "
            "'field_name' - 'entity1' contains 'expected' but 'entity2' "
            "contains 'actual'")

    def test_null_field_exception(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exception = NullFieldException('field_name', 'exist_id', 'uuid')

        self.assertEqual(exception.field_name, 'field_name')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for uuid: field_name field was "
            "null for exist id exist_id")

    def test_wrong_type_exception(self):
        utils.mock_datetime_utcnow(self.mox, '2014-01-02 03:04:05')

        exception = WrongTypeException(
            'field_name', 'value', 'exist_id', 'uuid')
        self.assertEqual(exception.field_name, 'field_name')
        self.assertEqual(exception.value, 'value')
        self.assertEqual(exception.exist_id, 'exist_id')
        self.assertEqual(exception.uuid, 'uuid')
        self.assertEqual(
            exception.reason,
            "Failed at 2014-01-02 03:04:05 UTC for uuid: {field_name: value} "
            "was of incorrect type for exist id exist_id")

########NEW FILE########
__FILENAME__ = test_worker
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json

import kombu
import mox

from stacktach import db, stacklog
from stacktach import views
import worker.worker as worker
from tests.unit import StacktachBaseTestCase


class ConsumerTestCase(StacktachBaseTestCase):
    def setUp(self):
        self.mox = mox.Mox()

    def tearDown(self):
        self.mox.UnsetStubs()

    def _setup_mock_logger(self):
        mock_logger = self.mox.CreateMockAnything()
        self.mox.StubOutWithMock(stacklog, 'get_logger')
        stacklog.get_logger('worker', is_parent=False).AndReturn(mock_logger)
        return mock_logger

    def _test_topics(self):
        return [
            dict(queue="queue1", routing_key="monitor.info"),
            dict(queue="queue2", routing_key="monitor.error")
        ]

    def test_get_consumers(self):
        created_queues = []
        created_callbacks = []
        created_consumers = []
        def Consumer(queues=None, callbacks=None):
            created_queues.extend(queues)
            created_callbacks.extend(callbacks)
            consumer = self.mox.CreateMockAnything()
            created_consumers.append(consumer)
            return consumer
        self.mox.StubOutWithMock(worker.Consumer, '_create_exchange')
        self.mox.StubOutWithMock(worker.Consumer, '_create_queue')
        consumer = worker.Consumer('test', None, None, True, {}, "nova",
                                   self._test_topics())
        exchange = self.mox.CreateMockAnything()
        consumer._create_exchange('nova', 'topic').AndReturn(exchange)
        info_queue = self.mox.CreateMockAnything()
        error_queue = self.mox.CreateMockAnything()
        consumer._create_queue('queue1', exchange, 'monitor.info')\
                .AndReturn(info_queue)
        consumer._create_queue('queue2', exchange, 'monitor.error')\
                .AndReturn(error_queue)
        self.mox.ReplayAll()
        consumers = consumer.get_consumers(Consumer, None)
        self.assertEqual(len(consumers), 1)
        self.assertEqual(consumers[0], created_consumers[0])
        self.assertEqual(len(created_queues), 2)
        self.assertTrue(info_queue in created_queues)
        self.assertTrue(error_queue in created_queues)
        self.assertEqual(len(created_callbacks), 1)
        self.assertTrue(consumer.on_nova in created_callbacks)
        self.mox.VerifyAll()

    def test_create_exchange(self):
        args = {'key': 'value'}
        consumer = worker.Consumer('test', None, None, True, args, 'nova',
                                   self._test_topics())

        self.mox.StubOutClassWithMocks(kombu.entity, 'Exchange')
        exchange = kombu.entity.Exchange('nova', type='topic', exclusive=False,
                                         durable=True, auto_delete=False)
        self.mox.ReplayAll()
        actual_exchange = consumer._create_exchange('nova', 'topic')
        self.assertEqual(actual_exchange, exchange)
        self.mox.VerifyAll()

    def test_create_queue(self):
        self.mox.StubOutClassWithMocks(kombu, 'Queue')
        exchange = self.mox.CreateMockAnything()
        queue = kombu.Queue('name', exchange, auto_delete=False, durable=True,
                            exclusive=False, routing_key='routing.key',
                            queue_arguments={})
        consumer = worker.Consumer('test', None, None, True, {}, 'nova',
                                   self._test_topics())
        self.mox.ReplayAll()
        actual_queue = consumer._create_queue('name', exchange, 'routing.key',
                                              exclusive=False,
                                              auto_delete=False)
        self.assertEqual(actual_queue, queue)
        self.mox.VerifyAll()

    def test_create_queue_with_queue_args(self):
        self.mox.StubOutClassWithMocks(kombu, 'Queue')
        exchange = self.mox.CreateMockAnything()
        queue_args = {'key': 'value'}
        queue = kombu.Queue('name', exchange, auto_delete=False, durable=True,
                            exclusive=False, routing_key='routing.key',
                            queue_arguments=queue_args)
        consumer = worker.Consumer('test', None, None, True, queue_args,
                                   'nova', self._test_topics())
        self.mox.ReplayAll()
        actual_queue = consumer._create_queue('name', exchange, 'routing.key',
                                              exclusive=False,
                                              auto_delete=False)
        self.assertEqual(actual_queue, queue)
        self.mox.VerifyAll()

    def test_process(self):
        deployment = self.mox.CreateMockAnything()
        raw = self.mox.CreateMockAnything()
        raw.get_name().AndReturn('RawData')
        message = self.mox.CreateMockAnything()

        exchange = 'nova'
        consumer = worker.Consumer('test', None, deployment, True, {},
                                   exchange, self._test_topics())
        routing_key = 'monitor.info'
        message.delivery_info = {'routing_key': routing_key}
        body_dict = {u'key': u'value'}
        message.body = json.dumps(body_dict)

        mock_notification = self.mox.CreateMockAnything()
        mock_post_process_method = self.mox.CreateMockAnything()
        mock_post_process_method(raw, mock_notification)
        old_handler = worker.POST_PROCESS_METHODS
        worker.POST_PROCESS_METHODS["RawData"] = mock_post_process_method

        self.mox.StubOutWithMock(views, 'process_raw_data',
                                 use_mock_anything=True)
        args = (routing_key, body_dict)
        views.process_raw_data(deployment, args, json.dumps(args), exchange) \
            .AndReturn((raw, mock_notification))
        message.ack()

        self.mox.StubOutWithMock(consumer, '_check_memory',
                                 use_mock_anything=True)
        consumer._check_memory()
        self.mox.ReplayAll()
        consumer._process(message)
        self.assertEqual(consumer.processed, 1)
        self.mox.VerifyAll()
        worker.POST_PROCESS_METHODS["RawData"] = old_handler

    def test_run(self):
        mock_logger = self._setup_mock_logger()
        self.mox.StubOutWithMock(mock_logger, 'info')
        mock_logger.info('east_coast.prod.global: nova 10.0.0.1 5672 rabbit /')
        self.mox.StubOutWithMock(mock_logger, 'debug')
        mock_logger.debug("Processing on 'east_coast.prod.global nova'")
        mock_logger.debug("Completed processing on "
                          "'east_coast.prod.global nova'")
        mock_logger.info("Worker exiting.")

        config = {
            'name': 'east_coast.prod.global',
            'durable_queue': False,
            'rabbit_host': '10.0.0.1',
            'rabbit_port': 5672,
            'rabbit_userid': 'rabbit',
            'rabbit_password': 'rabbit',
            'rabbit_virtual_host': '/',
            "services": ["nova"],
            "topics": {"nova": self._test_topics()}
        }
        self.mox.StubOutWithMock(db, 'get_deployment')
        deployment = self.mox.CreateMockAnything()
        deployment.id = 1
        db.get_deployment(deployment.id).AndReturn(deployment)
        self.mox.StubOutWithMock(kombu.connection, 'BrokerConnection')
        params = dict(hostname=config['rabbit_host'],
                      port=config['rabbit_port'],
                      userid=config['rabbit_userid'],
                      password=config['rabbit_password'],
                      transport="librabbitmq",
                      virtual_host=config['rabbit_virtual_host'])
        self.mox.StubOutWithMock(worker, "continue_running")
        worker.continue_running().AndReturn(True)
        conn = self.mox.CreateMockAnything()
        kombu.connection.BrokerConnection(**params).AndReturn(conn)
        conn.__enter__().AndReturn(conn)
        conn.__exit__(None, None, None).AndReturn(None)
        self.mox.StubOutClassWithMocks(worker, 'Consumer')
        exchange = 'nova'
        consumer = worker.Consumer(config['name'], conn, deployment,
                                   config['durable_queue'], {}, exchange,
                                   self._test_topics())
        consumer.run()
        worker.continue_running().AndReturn(False)
        self.mox.ReplayAll()
        worker.run(config, deployment.id, exchange)
        self.mox.VerifyAll()

    def test_run_queue_args(self):
        mock_logger = self._setup_mock_logger()
        self.mox.StubOutWithMock(mock_logger, 'info')
        mock_logger.info("east_coast.prod.global: nova 10.0.0.1 5672 rabbit /")
        self.mox.StubOutWithMock(mock_logger, 'debug')
        mock_logger.debug("Processing on 'east_coast.prod.global nova'")
        mock_logger.debug("Completed processing on "
                          "'east_coast.prod.global nova'")
        mock_logger.info("Worker exiting.")

        config = {
            'name': 'east_coast.prod.global',
            'durable_queue': False,
            'rabbit_host': '10.0.0.1',
            'rabbit_port': 5672,
            'rabbit_userid': 'rabbit',
            'rabbit_password': 'rabbit',
            'rabbit_virtual_host': '/',
            'queue_arguments': {'x-ha-policy': 'all'},
            'queue_name_prefix': "test_name_",
            "services": ["nova"],
            "topics": {"nova": self._test_topics()}
        }
        self.mox.StubOutWithMock(db, 'get_deployment')
        deployment = self.mox.CreateMockAnything()
        deployment.id = 1
        db.get_deployment(deployment.id).AndReturn(deployment)
        self.mox.StubOutWithMock(kombu.connection, 'BrokerConnection')
        params = dict(hostname=config['rabbit_host'],
                      port=config['rabbit_port'],
                      userid=config['rabbit_userid'],
                      password=config['rabbit_password'],
                      transport="librabbitmq",
                      virtual_host=config['rabbit_virtual_host'])
        self.mox.StubOutWithMock(worker, "continue_running")
        worker.continue_running().AndReturn(True)
        conn = self.mox.CreateMockAnything()
        kombu.connection.BrokerConnection(**params).AndReturn(conn)
        conn.__enter__().AndReturn(conn)
        conn.__exit__(None, None, None).AndReturn(None)
        self.mox.StubOutClassWithMocks(worker, 'Consumer')
        exchange = 'nova'
        consumer = worker.Consumer(config['name'], conn, deployment,
                                   config['durable_queue'],
                                   config['queue_arguments'], exchange,
                                   self._test_topics())
        consumer.run()
        worker.continue_running().AndReturn(False)
        self.mox.ReplayAll()
        worker.run(config, deployment.id, exchange)
        self.mox.VerifyAll()

########NEW FILE########
__FILENAME__ = utils
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import decimal

TENANT_ID_1 = 'testtenantid1'
TENANT_ID_2 = 'testtenantid2'

from stacktach import datetime_to_decimal as dt

IMAGE_UUID_1 = "12345678-6352-4dbc-8271-96cc54bf14cd"

INSTANCE_ID_1 = "08f685d9-6352-4dbc-8271-96cc54bf14cd"
INSTANCE_ID_2 = "515adf96-41d3-b86d-5467-e584edc61dab"

INSTANCE_FLAVOR_ID_1 = "1"
INSTANCE_FLAVOR_ID_2 = "performance2-120"

INSTANCE_TYPE_ID_1 = "12345"
INSTANCE_TYPE_ID_2 = '54321'

DUMMY_TIME = datetime.datetime.utcnow()
DECIMAL_DUMMY_TIME = dt.dt_to_decimal(DUMMY_TIME)

MESSAGE_ID_1 = "7f28f81b-29a2-43f2-9ba1-ccb3e53ab6c8"
MESSAGE_ID_2 = "4d596126-0f04-4329-865f-7b9a7bd69bcf"
MESSAGE_ID_3 = "4d596126-0f04-4329-865f-797387adf45c"
MESSAGE_ID_4 = "4d596126-0f04-4329-865f-797387adf45e"

BANDWIDTH_PUBLIC_OUTBOUND = 1697240969

REQUEST_ID_1 = 'req-611a4d70-9e47-4b27-a95e-27996cc40c06'
REQUEST_ID_2 = 'req-a951dec0-52ee-425d-9f56-d68bd1ad00ac'
REQUEST_ID_3 = 'req-039a33f7-5849-4406-8166-4db8cd085f52'

RAX_OPTIONS_1 = '1'
RAX_OPTIONS_2 = '2'

OS_DISTRO_1 = "linux"
OS_DISTRO_2 = "selinux"

OS_ARCH_1 = "x86"
OS_ARCH_2 = "x64"

OS_VERSION_1 = "1"
OS_VERSION_2 = "2"

LAUNCHED_AT_1 = decimal.Decimal("1.1")
LAUNCHED_AT_2 = decimal.Decimal("2.1")

DELETED_AT_1 = decimal.Decimal("3.1")
DELETED_AT_2 = decimal.Decimal("4.1")

SIZE_1 = 1234
SIZE_2 = 4567

CREATED_AT_1 = decimal.Decimal("10.1")
CREATED_AT_2 = decimal.Decimal("11.1")

IMAGE_OWNER_1 = "owner_1"
IMAGE_OWNER_2 = "owner_2"

TIMESTAMP_1 = "2013-06-20 17:31:57.939614"
SETTLE_TIME = 5
SETTLE_UNITS = "minutes"
TICK_TIME = 10
HOST = '10.0.0.1'
PORT = '5672'
VIRTUAL_HOST = '/'
USERID = 'rabbit'
PASSWORD = 'password'
NOVA_VERIFIER_EVENT_TYPE = 'compute.instance.exists.verified.old'
GLANCE_VERIFIER_EVENT_TYPE = 'image.exists.verified.old'
FLAVOR_FIELD_NAME = 'flavor_field_name'

def decimal_utc(t = datetime.datetime.utcnow()):
    return dt.dt_to_decimal(t)


def create_nova_notif(request_id=None, instance=INSTANCE_ID_1, type_id='1',
                      launched=None, deleted=None, new_type_id=None,
                      message_id=MESSAGE_ID_1, audit_period_beginning=None,
                      audit_period_ending=None, tenant_id=None,
                      rax_options=None, os_architecture=None,
                      os_version=None, os_distro=None):
    notif = ['', {
        'message_id': message_id,
        'payload': {
            'image_meta': {},
            'instance_id': instance,
            'instance_type_id': type_id,
        }
    }]

    notif[1]['_context_request_id'] = request_id
    notif[1]['payload']['launched_at'] = launched
    notif[1]['payload']['deleted_at'] = deleted
    notif[1]['payload']['new_instance_type_id'] = new_type_id
    notif[1]['payload']['audit_period_beginning'] = audit_period_beginning
    notif[1]['payload']['audit_period_ending'] = audit_period_ending
    notif[1]['payload']['tenant_id'] = tenant_id
    notif[1]['payload']['image_meta']['com.rackspace__1__options'] = rax_options
    notif[1]['payload']['image_meta']['org.openstack__1__architecture'] = os_architecture
    notif[1]['payload']['image_meta']['org.openstack__1__os_distro'] = os_distro
    notif[1]['payload']['image_meta']['org.openstack__1__os_version'] = os_version

    return notif


def create_raw(mox, when, event, instance=INSTANCE_ID_1,
               request_id=REQUEST_ID_1, state='active', old_task='',
               host='c.example.com', service='compute', json_str=''):
    raw = mox.CreateMockAnything()
    raw.host = host
    raw.service = service
    raw.instance = instance
    raw.event = event
    raw.when = when
    raw.state = state
    raw.old_task = old_task
    raw.request_id = request_id
    raw.json = json_str
    return raw


def create_lifecycle(mox, instance, last_state, last_task_state, last_raw):
    lifecycle = mox.CreateMockAnything()
    lifecycle.instance = instance
    lifecycle.last_state = last_state
    lifecycle.last_task_state = last_task_state
    lifecycle.last_raw = last_raw
    return lifecycle


def create_timing(mox, name, lifecycle, start_raw=None, start_when=None,
                  end_raw=None, end_when=None, diff=None):
    timing = mox.CreateMockAnything()
    timing.name = name
    timing.lifecycle = lifecycle
    timing.start_raw = start_raw
    timing.start_when = start_when
    timing.end_raw = end_raw
    timing.end_when = end_when
    timing.diff = diff
    return timing


def create_tracker(mox, request_id, lifecycle, start, last_timing=None,
                   duration=str(0.0)):
    tracker = mox.CreateMockAnything()
    tracker.request_id=request_id
    tracker.lifecycle=lifecycle
    tracker.start=start
    tracker.last_timing=last_timing
    tracker.duration=duration
    return tracker


class FakeVerifierConfig(object):
    def __init__(self, host, port, virtual_host, userid, password, tick_time,
                 settle_time, settle_units, durable_queue, topics, notifs,
                 nova_event_type, glance_event_type, flavor_field_name):
        self.host = lambda: host
        self.port = lambda: port
        self.virtual_host = lambda: virtual_host
        self.userid = lambda: userid
        self.password = lambda: password
        self.pool_size = lambda: 5
        self.tick_time = lambda: tick_time
        self.settle_time = lambda: settle_time
        self.settle_units = lambda: settle_units
        self.durable_queue = lambda: durable_queue
        self.topics = lambda: topics
        self.enable_notifications = lambda: notifs
        self.validation_level = lambda: 'all'
        self.nova_event_type = lambda: nova_event_type
        self.glance_event_type = lambda: glance_event_type
        self.flavor_field_name = lambda: flavor_field_name


def make_verifier_config(notifs):
        topics = {'exchange': ['notifications.info']}
        config = FakeVerifierConfig(HOST, PORT, VIRTUAL_HOST, USERID,
                                    PASSWORD, TICK_TIME, SETTLE_TIME,
                                    SETTLE_UNITS, True, topics, notifs,
                                    NOVA_VERIFIER_EVENT_TYPE,
                                    GLANCE_VERIFIER_EVENT_TYPE,
                                    FLAVOR_FIELD_NAME)
        return config


def mock_datetime_utcnow(mox, time):
    mox.StubOutWithMock(datetime, 'datetime')
    datetime.datetime.utcnow().AndReturn(time)
    mox.ReplayAll()


########NEW FILE########
__FILENAME__ = urls
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

from django.conf.urls.defaults import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    url(r'^', include('stacktach.url')),
)

########NEW FILE########
__FILENAME__ = glance_usage_seed
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""
    Usage: python glance_usage_seed.py [period_length] [sql_connection]
    python glance_usage_seed.py hour mysql://user:password@nova-db.example
    .com/nova?charset=utf8

    The idea behind glance_usage seeding is to take the current state of all
    active, deleted and pending_delete images from glance and insert that
    data into Stacktach's image_usage and image_deletes tables.
"""

import __builtin__
setattr(__builtin__, '_', lambda x: x)
import datetime
import os
import sys
from oslo.config import cfg

CONF = cfg.CONF
if __name__ == '__main__':
    if len(sys.argv) != 3:
        print "Proper Usage: glance_usage_seed.py [period_length] [" \
              "sql_connection]"
        sys.exit(1)
    CONF.sql_connection = sys.argv[2]

import glance.context
import glance.db.sqlalchemy.api as db_api
from sqlalchemy import or_
from sqlalchemy import and_
import glance.db.sqlalchemy.api as db_api
from glance.db.sqlalchemy import models as glancemodels

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import datetime_to_decimal as dt
from stacktach import models


# start yanked from reports/nova_usage_audit.py
def get_period_start(time, period_length):
    if period_length == 'day':
        last_period = time - datetime.timedelta(days=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day)
        return start
    elif period_length == 'hour':
        last_period = time - datetime.timedelta(hours=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day,
                                  hour=last_period.hour)
        return start
# end yanked from reports/nova_usage_audit.py


def _usage_for_image(image):
    return {
        'uuid': image.id,
        'owner': image.owner,
        'created_at': dt.dt_to_decimal(image.created_at),
        'owner': image.owner,
        'size': image.size,
        'last_raw_id': None
    }


def _delete_for_image(image):
    return {
        'uuid': image.id,
        'deleted_at': dt.dt_to_decimal(image.deleted_at),
        'raw_id': None
    }


def _get_usages(start, session):
    usage_filter = (glancemodels.Image.status == 'active',
                    glancemodels.Image.deleted_at > start)
    query = session.query(glancemodels.Image)
    images = query.filter(or_(*usage_filter)).all()
    return [_usage_for_image(image) for image in images]


def _get_deletes(start, session):
    delete_filter = (glancemodels.Image.status == 'deleted',
                     glancemodels.Image.deleted_at > start)
    query = session.query(glancemodels.Image)
    images = query.filter(and_(*delete_filter)).all()
    return [_delete_for_image(image) for image in images]


def seed(period_length):
    start = get_period_start(datetime.datetime.utcnow(), period_length)
    db_api.setup_db_env()
    session = db_api._get_session()

    print "Populating active image usages"
    usages = _get_usages(start, session)

    if usages:
        print "Saving active image images"
        active_images = map(lambda x: models.ImageUsage(**x), usages)
        models.ImageUsage.objects.bulk_create(active_images, batch_size=100)

    print "Populating image deletes"
    deletes = _get_deletes(start, session)

    if deletes:
        print "Saving image deletes"
        deleted_images = map(lambda x: models.ImageDeletes(**x), deletes)
        models.ImageDeletes.objects.bulk_create(deleted_images, batch_size=100)

    print "Seeding completed"
    return len(usages), len(deletes)

if __name__ == '__main__':
    msg = ("Seeded system with: \n"
           "%s Active images \n"
           "%s Deleted images \n")
    period = sys.argv[1]
    print msg % seed(period)


########NEW FILE########
__FILENAME__ = seeded_usage_image_meta
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import os
import sys

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import models

if __name__ != '__main__':
    sys.exit(1)

seed_usage = models.InstanceUsage.objects.filter(request_id=None)
deleted_instances = models.InstanceDeletes.objects.values('instance').distinct()

deleted = set()
for instance in deleted_instances:
    deleted.add(instance['instance'])

fixed = 0

for usage in seed_usage:
    if usage.instance not in deleted and usage.launched_at is not None and \
            usage.launched_at is not '':
        filters = {
            'instance': usage.instance,
            'launched_at__gte': int(usage.launched_at),
            'launched_at__lt': int(usage.launched_at) + 1,
            'status': models.InstanceExists.VERIFIED
        }
        exists = models.InstanceExists.objects.filter(**filters)
        if exists.count() > 0:
            fixed += 1
            usage.os_architecture = exists[0].os_architecture
            usage.os_distro = exists[0].os_distro
            usage.os_version = exists[0].os_version
            usage.rax_options = exists[0].rax_options
            usage.save()
        else:
            print "Couldn't find verified exists for instance %s" % usage.instance

print "Populated %s usage records" % fixed

########NEW FILE########
__FILENAME__ = usage_seed
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""
    Usage: python usage_seed.py [period_length] [sql_connection]
    python usage_seed.py hour mysql://user:password@nova-db.example.com/nova?charset=utf8

    The idea behind usage seeding is to take the current state of all
    active instances on active compute hosts and insert that data into
    Stacktach's usage tables. This script should be run against the
    nova database in each cell which has active compute nodes. The
    reason for that is because the global cell does not have information
    on active compute hosts.
"""

import __builtin__
setattr(__builtin__, '_', lambda x: x)
import datetime
import os
import sys

from oslo.config import cfg
CONF = cfg.CONF

from nova.compute import task_states
from nova.context import RequestContext
from nova.db import api as novadb
from nova.db.sqlalchemy import api as sqlapi
from nova.db.sqlalchemy import models as novamodels

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import datetime_to_decimal as dt
from stacktach import models

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print "Proper Usage: usage_seed.py [period_length] [sql_connection]"
        sys.exit(1)
    CONF.set_override("connection", sys.argv[2], group='database')


# start yanked from reports/nova_usage_audit.py
def get_previous_period(time, period_length):
    if period_length == 'day':
        last_period = time - datetime.timedelta(days=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day)
        end = datetime.datetime(year=time.year,
                                month=time.month,
                                day=time.day)
        return start, end
    elif period_length == 'hour':
        last_period = time - datetime.timedelta(hours=1)
        start = datetime.datetime(year=last_period.year,
                                  month=last_period.month,
                                  day=last_period.day,
                                  hour=last_period.hour)
        end = datetime.datetime(year=time.year,
                                month=time.month,
                                day=time.day,
                                hour=time.hour)
        return start, end
# end yanked from reports/nova_usage_audit.py

inst_types = {}


def get_instance_type(type_id):
    global inst_types
    context = RequestContext('1', '1', is_admin=True)
    if type_id in inst_types:
        return inst_types[type_id]
    else:
        inst_type = sqlapi.model_query(context, novamodels.InstanceTypes)\
                          .filter_by(id=type_id).first()
        inst_types[type_id] = inst_type
        return inst_type


def get_metadata(instance_uuid):
    context = RequestContext('1', '1', is_admin=True)
    return sqlapi.instance_system_metadata_get(context, instance_uuid)


def _usage_for_instance(instance, task=None):
    usage = {
        'instance': instance['uuid'],
        'tenant': instance['project_id'],
        'instance_type_id': instance.get('instance_type_id'),
    }

    instance_type = get_instance_type(instance.get('instance_type_id'))
    usage['instance_flavor_id'] = instance_type['flavorid']

    metadata = get_metadata(instance['uuid'])
    usage['os_architecture'] = metadata.get('image_org.openstack__1__architecture')
    usage['os_distro'] = metadata.get('image_org.openstack__1__os_distro')
    usage['os_version'] = metadata.get('image_org.openstack__1__os_version')
    usage['rax_options'] = metadata.get('image_com.rackspace__1__options')

    launched_at = instance.get('launched_at')
    if launched_at is not None:
        usage['launched_at'] = dt.dt_to_decimal(launched_at)

    if task is not None:
        usage['task'] = task

    return usage


def _delete_for_instance(instance):
    delete = {
        'instance': instance['uuid'],
        'deleted_at': dt.dt_to_decimal(instance.get('deleted_at')),
    }

    launched_at = instance.get('launched_at')
    if launched_at is not None:
        delete['launched_at'] = dt.dt_to_decimal(launched_at)
    return delete


def get_computes():
    context = RequestContext('1', '1', is_admin=True)
    return sqlapi.model_query(context, novamodels.Service,
                              read_deleted='no')\
                 .filter_by(topic='compute').all()


def get_active_instances(period_length):
    start, end = get_previous_period(datetime.datetime.utcnow(), period_length)
    session = sqlapi.get_session()
    computes = get_computes()
    active_instances = []
    yesterday = datetime.datetime.utcnow() - datetime.timedelta(days=1)
    for compute in computes:
        if compute.updated_at > yesterday:
            query = session.query(novamodels.Instance)
            active_filter = (novamodels.Instance.terminated_at == None,
                             novamodels.Instance.terminated_at > start)
            query = query.filter(sqlapi.or_(*active_filter))
            query = query.filter_by(host=compute.host)

            for instance in query.all():
                active_instances.append(instance)
    return active_instances


def get_action_for_instance(context, instance_uuid, action_name):
    actions = novadb.actions_get(context, instance_uuid)
    for action in actions:
        if action['action'] == action_name:
            return action


rebuild_tasks = [task_states.REBUILDING,
                 task_states.REBUILD_BLOCK_DEVICE_MAPPING,
                 task_states.REBUILD_SPAWNING]

resize_tasks = [task_states.RESIZE_PREP,
                task_states.RESIZE_MIGRATING,
                task_states.RESIZE_MIGRATED,
                task_states.RESIZE_FINISH]

resize_revert_tasks = [task_states.RESIZE_REVERTING]

rescue_tasks = [task_states.RESCUING]

in_flight_tasks = (rebuild_tasks + resize_tasks +
                   resize_revert_tasks + rescue_tasks)


def seed(period_length):
    usages = []
    building_usages = []
    in_flight_usages = []
    deletes = []


    start, end = get_previous_period(datetime.datetime.utcnow(), period_length)

    context = RequestContext(1, 1, is_admin=True)

    print "Selecting all active instances"
    active_instances = get_active_instances(period_length)
    print "Selected all active instances"

    print "Populating active usages, preparing for in-flight"
    for instance in active_instances:
        vm_state = instance['vm_state']
        task_state = instance['task_state']

        if vm_state == 'building':
            if instance['deleted'] != 0 and instance['deleted_at'] >= start:
                building_usages.append(_usage_for_instance(instance))
                deletes.append(_delete_for_instance(instance))
            elif instance['deleted'] == 0:
                building_usages.append(_usage_for_instance(instance))
        else:
            if task_state in in_flight_tasks:
                if (instance['deleted'] != 0 and
                        instance['deleted_at'] is not None and
                        instance['deleted_at'] >= start):
                    # Just in case...
                    deletes.append(_delete_for_instance(instance))
                    in_flight_usages.append(_usage_for_instance(instance,
                                            task=task_state))
                elif instance['deleted'] == 0:
                    in_flight_usages.append(_usage_for_instance(instance,
                                            task=task_state))
            else:
                if (instance['deleted'] != 0 and
                        instance['deleted_at'] is not None and
                        instance['deleted_at'] >= start):
                    deletes.append(_delete_for_instance(instance))
                    usages.append(_usage_for_instance(instance))
                elif instance['deleted'] == 0:
                    usages.append(_usage_for_instance(instance))

    print "Populated active instances, processing building"
    for usage in building_usages:
        action = get_action_for_instance(context, usage['instance'], 'create')
        if action is not None:
            usage['request_id'] = action['request_id']

    print "Populated building, processing in-flight"
    for usage in in_flight_usages:
        instance = usage['instance']
        action = None
        if usage['task'] in rebuild_tasks:
            action = get_action_for_instance(context, instance, 'rebuild')
        elif usage['task'] in resize_tasks:
            action = get_action_for_instance(context, instance, 'resize')
        elif usage['task'] in resize_revert_tasks:
            action = get_action_for_instance(context, instance, 'resizeRevert')
        elif usage['task'] in rescue_tasks:
            action = get_action_for_instance(context, instance, 'rescue')

        if action is not None:
            usage['request_id'] = action['request_id']
        del usage['task']

    print "Done cataloging usage"


    print "Saving active instances"
    active_InstanceUsages = map(lambda x: models.InstanceUsage(**x),
                                usages)
    models.InstanceUsage.objects.bulk_create(active_InstanceUsages,
                                             batch_size=100)

    print "Saving building instances"
    building_InstanceUsages = map(lambda x: models.InstanceUsage(**x),
                                  building_usages)
    models.InstanceUsage.objects.bulk_create(building_InstanceUsages,
                                             batch_size=100)

    print "Saving in-flight instances"
    in_flight_InstanceUsages = map(lambda x: models.InstanceUsage(**x),
                                   in_flight_usages)
    models.InstanceUsage.objects.bulk_create(in_flight_InstanceUsages,
                                             batch_size=100)

    print "Saving deletes"
    all_InstanceDeletes = map(lambda x: models.InstanceDeletes(**x),
                              deletes)
    models.InstanceDeletes.objects.bulk_create(all_InstanceDeletes,
                                               batch_size=100)

    return (len(usages), len(building_usages),
            len(in_flight_usages), len(deletes))

if __name__ == '__main__':
    msg = ("Seeded system with: \n"
           "%s Active Instances \n"
           "%s Building Instances \n"
           "%s In Flight Instances \n"
           "%s Deleted Instances \n")
    print msg % seed(sys.argv[1])


########NEW FILE########
__FILENAME__ = base_verifier
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import decimal
import os
import re
import sys
import time
import multiprocessing

from django.db import transaction
from stacktach import message_service


POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from django.db import close_connection
from django.db import reset_queries
from django.core import exceptions

from verifier import WrongTypeException
from stacktach import stacklog

stacklog.set_default_logger_name('verifier')


def _get_child_logger():
    return stacklog.get_logger('verifier', is_parent=False)


def _has_field(d1, d2, field1, field2=None):
    if not field2:
        field2 = field1

    return d1.get(field1) is not None and d2.get(field2) is not None


def _verify_simple_field(d1, d2, field1, field2=None):
    if not field2:
        field2 = field1

    if not _has_field(d1, d2, field1, field2):
        return False
    else:
        if d1[field1] != d2[field2]:
            return False

    return True


def _verify_date_field(d1, d2, same_second=False):
    if d1 and d2:
        if d1 == d2:
            return True
        elif same_second and int(d1) == int(d2):
            return True
    return False


def _is_like_uuid(attr_name, attr_value, exist_id):
    if not re.match("[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$",
             attr_value):
        raise WrongTypeException(attr_name, attr_value, exist_id, None)


def _is_like_date(attr_name, attr_value, exist_id, instance_uuid):
    if not isinstance(attr_value, decimal.Decimal):
        raise WrongTypeException(attr_name, attr_value, exist_id, instance_uuid)


def _is_long(attr_name, attr_value, exist_id, instance_uuid):
    if not isinstance(attr_value, long):
        raise WrongTypeException(attr_name, attr_value, exist_id, instance_uuid)


def _is_int_in_char(attr_name, attr_value, exist_id, instance_uuid):
    try:
        int(attr_value)
    except ValueError:
        raise WrongTypeException(attr_name, attr_value, exist_id, instance_uuid)


def _is_hex_owner_id(attr_name, attr_value, exist_id, instance_uuid):
    if not re.match("^[0-9a-fA-F]+$", attr_value):
        raise WrongTypeException(attr_name, attr_value, exist_id, instance_uuid)


def _is_alphanumeric(attr_name, attr_value, exist_id, instance_uuid):
    if not re.match("[a-zA-Z0-9.]+$", attr_value):
        raise WrongTypeException(attr_name, attr_value, exist_id, instance_uuid)


class Verifier(object):
    def __init__(self, config, pool=None, reconciler=None):
        self.config = config
        self.pool = pool or multiprocessing.Pool(config.pool_size())
        self.enable_notifications = config.enable_notifications()
        self.reconciler = reconciler
        self.results = []
        self.failed = []

    def clean_results(self):
        pending = []
        finished = 0
        successful = 0

        for result in self.results:
            if result.ready():
                finished += 1
                if result.successful():
                    (verified, exists) = result.get()
                    if self.reconciler and not verified:
                        self.failed.append(exists)
                    successful += 1
            else:
                pending.append(result)

        self.results = pending
        errored = finished - successful
        return len(self.results), successful, errored

    def _keep_running(self):
        return True

    def _utcnow(self):
        return datetime.datetime.utcnow()

    def _run(self, callback=None):
        tick_time = self.config.tick_time()
        settle_units = self.config.settle_units()
        settle_time = self.config.settle_time()
        while self._keep_running():
            with transaction.commit_on_success():
                now = self._utcnow()
                kwargs = {settle_units: settle_time}
                ending_max = now - datetime.timedelta(**kwargs)
                new = self.verify_for_range(ending_max, callback=callback)
                values = ((self.exchange(), new,) + self.clean_results())
                if self.reconciler:
                    self.reconcile_failed()
                msg = "%s: N: %s, P: %s, S: %s, E: %s" % values
                _get_child_logger().info(msg)
            time.sleep(tick_time)

    def run(self):
        logger = _get_child_logger()
        if self.enable_notifications:
            exchange_name = self.exchange()
            exchange = message_service.create_exchange(
                exchange_name, 'topic',
                durable=self.config.durable_queue())
            routing_keys = self.config.topics()[exchange_name]

            with message_service.create_connection(
                self.config.host(), self.config.port(),
                self.config.userid(), self.config.password(),
                "librabbitmq", self.config.virtual_host()) as conn:
                def callback(result):
                    attempt = 0
                    while attempt < 2:
                        try:
                            (verified, exist) = result
                            if verified:
                                self.send_verified_notification(
                                    exist, conn, exchange,
                                    routing_keys=routing_keys)
                            break
                        except exceptions.ObjectDoesNotExist:
                            if attempt < 1:
                                logger.warn("ObjectDoesNotExist in callback, "
                                         "attempting to reconnect and try "
                                         "again.")
                                close_connection()
                                reset_queries()
                            else:
                                logger.error("ObjectDoesNotExist in callback "
                                          "again, giving up.")
                        except Exception, e:
                            msg = "ERROR in Callback %s: %s" % (exchange_name,
                                                                e)
                            logger.exception(msg)
                            break
                        attempt += 1
                try:
                    self._run(callback=callback)
                except Exception, e:
                    print e
                    raise e
        else:
            self._run()

    def verify_for_range(self, ending_max, callback=None):
        pass

    def reconcile_failed(self):
        pass

    def exchange(self):
        pass

########NEW FILE########
__FILENAME__ = config
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json
import os

config_filename = os.environ.get('STACKTACH_VERIFIER_CONFIG',
                                 'stacktach_verifier_config.json')
try:
    from local_settings import *
    config_filename = STACKTACH_VERIFIER_CONFIG
except ImportError:
    pass

config = None


def load():
    global config
    with open(config_filename, "r") as f:
        config = json.load(f)


def enable_notifications():
    return config['enable_notifications']


def topics():
    return config['rabbit']['topics']


def tick_time():
    return config['tick_time']


def settle_units():
    return config['settle_units']


def settle_time():
    return config['settle_time']


def reconcile():
    return config.get('reconcile', False)


def reconciler_config():
    return config.get(
        'reconciler_config', '/etc/stacktach/reconciler_config.json')

def pool_size():
    return config['pool_size']


def durable_queue():
    return config['rabbit']['durable_queue']


def host():
    return config['rabbit']['host']


def port():
    return config['rabbit']['port']


def userid():
    return config['rabbit']['userid']


def password():
    return config['rabbit']['password']


def virtual_host():
    return config['rabbit']['virtual_host']


def validation_level():
    return config['validation_level']


def nova_event_type():
    return config.get('nova_event_type', 'compute.instance.exists.verified')


def glance_event_type():
    return config.get('glance_event_type', 'image.exists.verified')


def flavor_field_name():
    return config['flavor_field_name']

########NEW FILE########
__FILENAME__ = glance_verifier
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json

import os
import sys
import uuid
from verifier.base_verifier import Verifier


POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import models
from verifier import FieldMismatch
from verifier import VerificationException
from verifier import base_verifier
from verifier import NullFieldException
from verifier import NotFound
from stacktach import datetime_to_decimal as dt
from stacktach import stacklog
from stacktach import message_service
import datetime

stacklog.set_default_logger_name('verifier')


def _get_child_logger():
    return stacklog.get_logger('verifier', is_parent=False)


def _verify_field_mismatch(exists, usage):
    if not base_verifier._verify_date_field(
            usage.created_at, exists.created_at, same_second=True):
        raise FieldMismatch(
            'created_at',
            {'name': 'exists', 'value': exists.created_at},
            {'name': 'launches', 'value': usage.created_at},
            exists.uuid)

    if usage.owner != exists.owner:
        raise FieldMismatch(
            'owner',
            {'name': 'exists', 'value': exists.owner},
            {'name': 'launches', 'value': usage.owner},
            exists.uuid)

    if usage.size != exists.size:
        raise FieldMismatch(
            'size',
            {'name': 'exists', 'value': exists.size},
            {'name': 'launches', 'value': usage.size},
            exists.uuid)


def _verify_validity(exist):
    fields = {exist.size: 'image_size', exist.created_at: 'created_at',
              exist.uuid: 'uuid', exist.owner: 'owner'}
    for (field_value, field_name) in fields.items():
        if field_value is None:
            raise NullFieldException(field_name, exist.id, exist.uuid)
    base_verifier._is_like_uuid('uuid', exist.uuid, exist.id)
    base_verifier._is_like_date('created_at', exist.created_at, exist.id,
                                exist.uuid)
    base_verifier._is_long('size', exist.size, exist.id, exist.uuid)
    base_verifier._is_hex_owner_id('owner', exist.owner, exist.id, exist.uuid)


def _verify_for_usage(exist, usage=None):
    usage_type = "ImageUsage"
    if not usage and exist.usage:
        usage = exist.usage
    elif not usage:
        usages = models.ImageUsage.objects.filter(uuid=exist.uuid)
        usage_count = usages.count()
        if usage_count == 0:
            query = {'uuid': exist.uuid}
            raise NotFound(usage_type, query)
        usage = usages[0]
    _verify_field_mismatch(exist, usage)


def _verify_for_delete(exist, delete=None):
    delete_type = "ImageDelete"
    if not delete and exist.delete:
        # We know we have a delete and we have it's id
        delete = exist.delete
    elif not delete:
        if exist.deleted_at:
            # We received this exists before the delete, go find it
            deletes = models.ImageDeletes.find(uuid=exist.uuid)
            if deletes.count() == 1:
                delete = deletes[0]
            else:
                query = {
                    'instance': exist.instance,
                    'launched_at': exist.launched_at
                }
                raise NotFound(delete_type, query)
        else:
            # We don't know if this is supposed to have a delete or not.
            # Thus, we need to check if we have a delete for this instance.
            # We need to be careful though, since we could be verifying an
            # exist event that we got before the delete. So, we restrict the
            # search to only deletes before this exist's audit period ended.
            # If we find any, we fail validation
            deleted_at_max = dt.dt_from_decimal(exist.audit_period_ending)
            deletes = models.ImageDeletes.find(
                exist.uuid, deleted_at_max)
            if deletes.count() > 0:
                reason = 'Found %ss for non-delete exist' % delete_type
                raise VerificationException(reason)

    if delete:
        if not base_verifier._verify_date_field(
                delete.deleted_at, exist.deleted_at, same_second=True):
            raise FieldMismatch(
                'deleted_at',
                {'name': 'exists', 'value': exist.deleted_at},
                {'name': 'deletes', 'value': delete.deleted_at},
                exist.uuid)


def _verify(exists):
    verified = True
    for exist in exists:
        try:
            _verify_for_usage(exist)
            _verify_for_delete(exist)
            _verify_validity(exist)

            exist.mark_verified()
        except VerificationException, e:
            verified = False
            exist.mark_failed(reason=str(e))
        except Exception, e:
            verified = False
            exist.mark_failed(reason=e.__class__.__name__)
            _get_child_logger().exception("glance: %s" % e)

    return verified, exists[0]


class GlanceVerifier(Verifier):
    def __init__(self, config, pool=None):
        super(GlanceVerifier, self).__init__(config, pool=pool)

    def verify_exists(self, grouped_exists, callback, verifying_status):
        count = len(grouped_exists)
        added = 0
        update_interval = datetime.timedelta(seconds=30)
        next_update = datetime.datetime.utcnow() + update_interval
        _get_child_logger().info("glance: Adding %s per-owner exists to queue." % count)
        while added < count:
            for exists in grouped_exists.values():
                for exist in exists:
                    exist.status = verifying_status
                    exist.save()
                result = self.pool.apply_async(_verify, args=(exists,),
                                               callback=callback)
                self.results.append(result)
                added += 1
                if datetime.datetime.utcnow() > next_update:
                    values = ((added,) + self.clean_results())
                    msg = "glance: N: %s, P: %s, S: %s, E: %s" % values
                    _get_child_logger().info(msg)
                    next_update = datetime.datetime.utcnow() + update_interval
        return count

    def verify_for_range(self, ending_max, callback=None):
        unsent_exists_grouped_by_owner_and_rawid = \
            models.ImageExists.find_and_group_by_owner_and_raw_id(
                ending_max=ending_max,
                status=models.ImageExists.SENT_UNVERIFIED)
        unsent_count = self.verify_exists(unsent_exists_grouped_by_owner_and_rawid,
                                        None, models.ImageExists.SENT_VERIFYING)
        exists_grouped_by_owner_and_rawid = \
            models.ImageExists.find_and_group_by_owner_and_raw_id(
                ending_max=ending_max,
                status=models.ImageExists.PENDING)
        count = self.verify_exists(exists_grouped_by_owner_and_rawid, callback,
                                 models.ImageExists.VERIFYING)

        return count+unsent_count

    def send_verified_notification(self, exist, connection, exchange,
                                   routing_keys=None):
        # NOTE (apmelton)
        # The exist we're provided from the callback may have cached queries
        # from before it was serialized. We don't want to use them as
        # they could have been lost somewhere in the process forking.
        # So, grab a new InstanceExists object from the database and use it.
        body = models.ImageExists.objects.get(id=exist.id).raw.json
        json_body = json.loads(body)
        json_body[1]['event_type'] = self.config.glance_event_type()
        json_body[1]['original_message_id'] = json_body[1]['message_id']
        json_body[1]['message_id'] = str(uuid.uuid4())
        if routing_keys is None:
            message_service.send_notification(json_body[1], json_body[0],
                                              connection, exchange)
        else:
            for key in routing_keys:
                message_service.send_notification(json_body[1], key,
                                                  connection, exchange)

    def exchange(self):
        return 'glance'

########NEW FILE########
__FILENAME__ = nova_verifier
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import datetime
import json
import os
import sys
import uuid


POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                                os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from verifier import base_verifier
from verifier import config
from verifier import NullFieldException
from stacktach import models
from stacktach import stacklog
from stacktach import datetime_to_decimal as dt
from verifier import FieldMismatch
from verifier import AmbiguousResults
from verifier import NotFound
from verifier import VerificationException
from stacktach import message_service

stacklog.set_default_logger_name('verifier')


def _get_child_logger():
    return stacklog.get_logger('verifier', is_parent=False)


def _verify_field_mismatch(exists, launch):
    flavor_field_name = config.flavor_field_name()
    if not base_verifier._verify_date_field(
            launch.launched_at, exists.launched_at, same_second=True):
        raise FieldMismatch(
            'launched_at',
            {'name': 'exists', 'value': exists.launched_at},
            {'name': 'launches', 'value': launch.launched_at},
            exists.instance)

    if getattr(launch, flavor_field_name) != \
            getattr(exists, flavor_field_name):
        raise FieldMismatch(
            flavor_field_name,
            {'name': 'exists', 'value': getattr(exists, flavor_field_name)},
            {'name': 'launches', 'value': getattr(launch, flavor_field_name)},
            exists.instance)

    if launch.tenant != exists.tenant:
        raise FieldMismatch(
            'tenant',
            {'name': 'exists', 'value': exists.tenant},
            {'name': 'launches', 'value': launch.tenant},
            exists.instance)

    if launch.rax_options != exists.rax_options:
        raise FieldMismatch(
            'rax_options',
            {'name': 'exists', 'value': exists.rax_options},
            {'name': 'launches', 'value': launch.rax_options},
            exists.instance)

    if launch.os_architecture != exists.os_architecture:
        raise FieldMismatch(
            'os_architecture',
            {'name': 'exists', 'value': exists.os_architecture},
            {'name': 'launches', 'value': launch.os_architecture},
            exists.instance)

    if launch.os_version != exists.os_version:
        raise FieldMismatch(
            'os_version',
            {'name': 'exists', 'value': exists.os_version},
            {'name': 'launches', 'value': launch.os_version},
            exists.instance)

    if launch.os_distro != exists.os_distro:
        raise FieldMismatch(
            'os_distro',
            {'name': 'exists', 'value': exists.os_distro},
            {'name': 'launches', 'value': launch.os_distro},
            exists.instance)


def _verify_for_launch(exist, launch=None,
                       launch_type="InstanceUsage"):

    if not launch and exist.usage:
        launch = exist.usage
    elif not launch:
        if models.InstanceUsage.objects\
                 .filter(instance=exist.instance).count() > 0:
            launches = models.InstanceUsage.find(
                exist.instance, dt.dt_from_decimal(exist.launched_at))
            count = launches.count()
            query = {
                'instance': exist.instance,
                'launched_at': exist.launched_at
            }
            if count > 1:
                raise AmbiguousResults(launch_type, query)
            elif count == 0:
                raise NotFound(launch_type, query)
            launch = launches[0]
        else:
            raise NotFound(launch_type, {'instance': exist.instance})

    _verify_field_mismatch(exist, launch)


def _verify_for_delete(exist, delete=None,
                       delete_type="InstanceDeletes"):

    if not delete and exist.delete:
        # We know we have a delete and we have it's id
        delete = exist.delete
    elif not delete:
        if exist.deleted_at:
            # We received this exists before the delete, go find it
            deletes = models.InstanceDeletes.find(
                exist.instance, dt.dt_from_decimal(exist.launched_at))
            if deletes.count() == 1:
                delete = deletes[0]
            else:
                query = {
                    'instance': exist.instance,
                    'launched_at': exist.launched_at
                }
                raise NotFound(delete_type, query)
        else:
            # We don't know if this is supposed to have a delete or not.
            # Thus, we need to check if we have a delete for this instance.
            # We need to be careful though, since we could be verifying an
            # exist event that we got before the delete. So, we restrict the
            # search to only deletes before this exist's audit period ended.
            # If we find any, we fail validation
            launched_at = dt.dt_from_decimal(exist.launched_at)
            deleted_at_max = dt.dt_from_decimal(exist.audit_period_ending)
            deletes = models.InstanceDeletes.find(exist.instance, launched_at,
                                                  deleted_at_max)
            if deletes.count() > 0:
                reason = 'Found %s for non-delete exist' % delete_type
                raise VerificationException(reason)

    if delete:
        if not base_verifier._verify_date_field(
                delete.launched_at, exist.launched_at, same_second=True):
            raise FieldMismatch(
                'launched_at',
                {'name': 'exists', 'value': exist.launched_at},
                {'name': 'deletes', 'value': delete.launched_at},
                exist.instance)

        if not base_verifier._verify_date_field(
                delete.deleted_at, exist.deleted_at, same_second=True):
            raise FieldMismatch(
                'deleted_at',
                {'name': 'exists', 'value': exist.deleted_at},
                {'name': 'deletes', 'value': delete.deleted_at},
                exist.instance)


def _verify_basic_validity(exist):
    flavor_field_name = config.flavor_field_name()
    fields = {
        'tenant': exist.tenant,
        'launched_at': exist.launched_at,
        flavor_field_name: getattr(exist, flavor_field_name)
    }
    for (field_name, field_value) in fields.items():
        if field_value is None:
            raise NullFieldException(field_name, exist.id, exist.instance)
    base_verifier._is_hex_owner_id(
        'tenant', exist.tenant, exist.id, exist.instance)
    base_verifier._is_like_date(
        'launched_at', exist.launched_at, exist.id, exist.instance)
    if exist.deleted_at is not None:
        base_verifier._is_like_date(
            'deleted_at', exist.deleted_at, exist.id, exist.instance)


def _verify_optional_validity(exist):
    is_image_type_import = exist.is_image_type_import()
    fields = {exist.rax_options: 'rax_options',
              exist.os_architecture: 'os_architecture'
              }
    if not is_image_type_import:
        fields.update({exist.os_distro: 'os_distro',
                       exist.os_version: 'os_version'})
    for (field_value, field_name) in fields.items():
        if field_value == '':
            raise NullFieldException(field_name, exist.id, exist.instance)
    base_verifier._is_int_in_char(
        'rax_options', exist.rax_options, exist.id, exist.instance)
    base_verifier._is_alphanumeric(
        'os_architecture', exist.os_architecture, exist.id, exist.instance)
    if not is_image_type_import:
        base_verifier._is_alphanumeric(
            'os_distro', exist.os_distro, exist.id, exist.instance)
        base_verifier._is_alphanumeric(
            'os_version', exist.os_version, exist.id, exist.instance)


def _verify_validity(exist, validation_level):
    if validation_level == 'none':
        return
    if validation_level == 'basic':
        _verify_basic_validity(exist)
    if validation_level == 'all':
        _verify_basic_validity(exist)
        _verify_optional_validity(exist)


def _verify_with_reconciled_data(exist):
    if not exist.launched_at:
        raise VerificationException("Exists without a launched_at")

    query = models.InstanceReconcile.objects.filter(instance=exist.instance)
    if query.count() > 0:
        recs = models.InstanceReconcile.find(exist.instance,
                                             dt.dt_from_decimal((
                                             exist.launched_at)))
        search_query = {'instance': exist.instance,
                        'launched_at': exist.launched_at}
        count = recs.count()
        if count > 1:
            raise AmbiguousResults('InstanceReconcile', search_query)
        elif count == 0:
            raise NotFound('InstanceReconcile', search_query)
        reconcile = recs[0]
    else:
        raise NotFound('InstanceReconcile', {'instance': exist.instance})

    _verify_for_launch(exist, launch=reconcile,
                       launch_type="InstanceReconcile")
    delete = None
    if reconcile.deleted_at is not None:
        delete = reconcile
    _verify_for_delete(exist, delete=delete, delete_type="InstanceReconcile")


def _attempt_reconciled_verify(exist, orig_e):
    verified = False
    try:
        # Attempt to verify against reconciled data
        _verify_with_reconciled_data(exist)
        verified = True
        exist.mark_verified(reconciled=True)
    except NotFound, rec_e:
        # No reconciled data, just mark it failed
        exist.mark_failed(reason=str(orig_e))
    except VerificationException, rec_e:
        # Verification failed against reconciled data, mark it failed
        #    using the second failure.
        exist.mark_failed(reason=str(rec_e))
    except Exception, rec_e:
        exist.mark_failed(reason=rec_e.__class__.__name__)
        _get_child_logger().exception("nova: %s" % rec_e)
    return verified


def _verify(exist, validation_level):
    verified = False
    try:
        if not exist.launched_at:
            raise VerificationException("Exists without a launched_at")
        _verify_validity(exist, validation_level)
        _verify_for_launch(exist)
        _verify_for_delete(exist)

        verified = True
        exist.mark_verified()
    except VerificationException, orig_e:
        # Something is wrong with the InstanceUsage record
        verified = _attempt_reconciled_verify(exist, orig_e)
    except Exception, e:
        exist.mark_failed(reason=e.__class__.__name__)
        _get_child_logger().exception("nova: %s" % e)

    return verified, exist


class NovaVerifier(base_verifier.Verifier):
    def __init__(self, config, pool=None, reconciler=None):
        super(NovaVerifier, self).__init__(config,
                                           pool=pool,
                                           reconciler=reconciler)

    def send_verified_notification(self, exist, connection, exchange,
                                   routing_keys=None):
        # NOTE (apmelton)
        # The exist we're provided from the callback may have cached queries
        # from before it was serialized. We don't want to use them as
        # they could have been lost somewhere in the process forking.
        # So, grab a new InstanceExists object from the database and use it.
        body = models.InstanceExists.objects.get(id=exist.id).raw.json
        json_body = json.loads(body)
        json_body[1]['event_type'] = self.config.nova_event_type()
        json_body[1]['original_message_id'] = json_body[1]['message_id']
        json_body[1]['message_id'] = str(uuid.uuid4())
        if routing_keys is None:
            message_service.send_notification(
                json_body[1], json_body[0], connection, exchange)
        else:
            for key in routing_keys:
                message_service.send_notification(
                    json_body[1], key, connection, exchange)

    def verify_exists(self, callback, exists, verifying_status):
        count = exists.count()
        added = 0
        update_interval = datetime.timedelta(seconds=30)
        next_update = datetime.datetime.utcnow() + update_interval
        _get_child_logger().info("nova: Adding %s exists to queue." % count)
        while added < count:
            for exist in exists[0:1000]:
                exist.update_status(verifying_status)
                exist.save()
                validation_level = self.config.validation_level()
                result = self.pool.apply_async(
                    _verify, args=(exist, validation_level),
                    callback=callback)
                self.results.append(result)
                added += 1
                if datetime.datetime.utcnow() > next_update:
                    values = ((added,) + self.clean_results())
                    msg = "nova: N: %s, P: %s, S: %s, E: %s" % values
                    _get_child_logger().info(msg)
                    next_update = datetime.datetime.utcnow() + update_interval
        return count

    def verify_for_range(self, ending_max, callback=None):
        sent_unverified_exists = models.InstanceExists.find(
            ending_max=ending_max, status=
            models.InstanceExists.SENT_UNVERIFIED)
        sent_unverified_count = self.verify_exists(None,
                                                   sent_unverified_exists,
                                                   models.InstanceExists.
                                                   SENT_VERIFYING)
        exists = models.InstanceExists.find(
            ending_max=ending_max, status=models.InstanceExists.PENDING)
        count = self.verify_exists(callback, exists,
                                   models.InstanceExists.VERIFYING)
        return count+sent_unverified_count

    def reconcile_failed(self):
        for failed_exist in self.failed:
            self.reconciler.failed_validation(failed_exist)
        self.failed = []

    def exchange(self):
        return 'nova'

########NEW FILE########
__FILENAME__ = start_verifier
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json

import os
import signal
import sys

from multiprocessing import Process

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                   os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)
from stacktach import stacklog
from stacktach import reconciler
from verifier import nova_verifier
from verifier import glance_verifier
import verifier.config as verifier_config

try:
    from local_settings import *
    config_filename = STACKTACH_VERIFIER_CONFIG
except ImportError:
    pass

process = None
log_listener = None
processes = []
stacklog.set_default_logger_name('verifier')

def _get_parent_logger():
    return stacklog.get_logger('verifier', is_parent=True)


def kill_time(signal, frame):
    log_listener.end()
    print "dying ..."
    for process in processes:
        process.terminate()
    print "rose"
    for process in processes:
        process.join()
    print "bud"
    sys.exit(0)


def _load_nova_reconciler():
    config_loc = verifier_config.reconciler_config()
    with open(config_loc, 'r') as rec_config_file:
        rec_config = json.load(rec_config_file)
        return reconciler.Reconciler(rec_config)

if __name__ == '__main__':
    def make_and_start_verifier(exchange):
        # Gotta create it and run it this way so things don't get
        # lost when the process is forked.
        verifier = None
        if exchange == "nova":
            reconcile = verifier_config.reconcile()
            reconciler = None
            if reconcile:
                reconciler = _load_nova_reconciler()
            verifier = nova_verifier.NovaVerifier(verifier_config,
                                                  reconciler=reconciler)
        elif exchange == "glance":
            verifier = glance_verifier.GlanceVerifier(verifier_config)

        verifier.run()

    verifier_config.load()
    log_listener = stacklog.LogListener(_get_parent_logger())
    log_listener.start()
    for exchange in verifier_config.topics().keys():
        process = Process(target=make_and_start_verifier, args=(exchange,))
        process.start()
        processes.append(process)

    if len(processes) > 0:
        # Only pause parent process if there are children running.
        # Otherwise just end...
        signal.signal(signal.SIGINT, kill_time)
        signal.signal(signal.SIGTERM, kill_time)
        signal.pause()

########NEW FILE########
__FILENAME__ = config
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.


import json
import os

config_filename = os.environ.get('STACKTACH_DEPLOYMENTS_FILE',
                                 'stacktach_worker_config.json')
try:
    from local_settings import *
    config_filename = STACKTACH_DEPLOYMENTS_FILE
except ImportError:
    pass

config = None
with open(config_filename, "r") as f:
    config = json.load(f)


def deployments():
    return config['deployments']


def topics():
    return config['topics']

########NEW FILE########
__FILENAME__ = start_workers
import os
import signal
import sys

from multiprocessing import Process

POSSIBLE_TOPDIR = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                   os.pardir, os.pardir))
if os.path.exists(os.path.join(POSSIBLE_TOPDIR, 'stacktach')):
    sys.path.insert(0, POSSIBLE_TOPDIR)

from stacktach import db, stacklog
from django.db import close_connection

import worker.worker as worker
from worker import config

processes = []
log_listener = None
stacklog.set_default_logger_name('worker')


def _get_parent_logger():
    return stacklog.get_logger('worker', is_parent=True)


def kill_time(signal, frame):
    print "dying ..."
    for process in processes:
        process.terminate()
    print "rose"
    for process in processes:
        process.join()
    log_listener.end()
    print "bud"
    sys.exit(0)


if __name__ == '__main__':
    log_listener = stacklog.LogListener(_get_parent_logger())
    log_listener.start()
    for deployment in config.deployments():
        if deployment.get('enabled', True):
            db_deployment, new = db.get_or_create_deployment(deployment['name'])
            # NOTE (apmelton)
            # Close the connection before spinning up the child process,
            # otherwise the child process will attempt to use the connection
            # the parent process opened up to get/create the deployment.
            close_connection()
            for exchange in deployment.get('topics').keys():
                process = Process(target=worker.run, args=(deployment,
                                                           db_deployment.id,
                                                           exchange,))
                process.daemon = True
                process.start()
                processes.append(process)
    signal.signal(signal.SIGINT, kill_time)
    signal.signal(signal.SIGTERM, kill_time)
    signal.pause()

########NEW FILE########
__FILENAME__ = worker
# Copyright 2012 - Dark Secret Software Inc.
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

# This is the worker you run in your OpenStack environment. You need
# to set TENANT_ID and URL to point to your StackTach web server.

import datetime
import sys
import time
import signal

import kombu
import kombu.mixins


try:
    import ujson as json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        import json

from pympler.process import ProcessMemoryInfo

from stacktach import db
from stacktach import message_service
from stacktach import stacklog
from stacktach import views

stacklog.set_default_logger_name('worker')
shutdown_soon = False


def _get_child_logger():
    return stacklog.get_logger('worker', is_parent=False)


class Consumer(kombu.mixins.ConsumerMixin):
    def __init__(self, name, connection, deployment, durable, queue_arguments,
                 exchange, topics, connect_max_retries=10):
        self.connect_max_retries = connect_max_retries
        self.retry_attempts = 0
        self.connection = connection
        self.deployment = deployment
        self.durable = durable
        self.queue_arguments = queue_arguments
        self.name = name
        self.last_time = None
        self.pmi = None
        self.processed = 0
        self.total_processed = 0
        self.topics = topics
        self.exchange = exchange
        signal.signal(signal.SIGTERM, self._shutdown)

    def _create_exchange(self, name, type, exclusive=False, auto_delete=False):
        return message_service.create_exchange(name, exchange_type=type,
                                               exclusive=exclusive,
                                               durable=self.durable,
                                               auto_delete=auto_delete)

    def _create_queue(self, name, nova_exchange, routing_key, exclusive=False,
                     auto_delete=False):
        return message_service.create_queue(
            name, nova_exchange, durable=self.durable, auto_delete=exclusive,
            exclusive=auto_delete, queue_arguments=self.queue_arguments,
            routing_key=routing_key)

    def get_consumers(self, Consumer, channel):
        exchange = self._create_exchange(self.exchange, "topic")

        queues = [self._create_queue(topic['queue'], exchange,
                                     topic['routing_key'])
                  for topic in self.topics]

        return [Consumer(queues=queues, callbacks=[self.on_nova])]

    def _process(self, message):
        routing_key = message.delivery_info['routing_key']

        body = str(message.body)
        args = (routing_key, json.loads(body))
        asJson = json.dumps(args)
        # save raw and ack the message
        raw, notif = views.process_raw_data(
            self.deployment, args, asJson, self.exchange)

        self.processed += 1
        message.ack()
        POST_PROCESS_METHODS[raw.get_name()](raw, notif)

        self._check_memory()

    def _check_memory(self):
        if not self.pmi:
            self.pmi = ProcessMemoryInfo()
            self.last_vsz = self.pmi.vsz
            self.initial_vsz = self.pmi.vsz

        utc = datetime.datetime.utcnow()
        check = self.last_time is None
        if self.last_time:
            diff = utc - self.last_time
            if diff.seconds > 30:
                check = True
        if check:
            self.last_time = utc
            self.pmi.update()
            diff = (self.pmi.vsz - self.last_vsz) / 1000
            idiff = (self.pmi.vsz - self.initial_vsz) / 1000
            self.total_processed += self.processed
            per_message = 0
            if self.total_processed:
                per_message = idiff / self.total_processed
            _get_child_logger().debug("%20s %20s %6dk/%6dk ram, "
                      "%3d/%4d msgs @ %6dk/msg" %
                      (self.name, self.exchange, diff, idiff, self.processed,
                      self.total_processed, per_message))
            self.last_vsz = self.pmi.vsz
            self.processed = 0

    def on_nova(self, body, message):
        try:
            self._process(message)
        except Exception, e:
            _get_child_logger().debug("Problem: %s\nFailed message body:\n%s" %
                      (e, json.loads(str(message.body))))
            raise

    def _shutdown(self, signal, stackframe = False):
        global shutdown_soon
        self.should_stop = True
        shutdown_soon = True

    def on_connection_revived(self):
        self.retry_attempts = 0
        _get_child_logger().debug("The connection to RabbitMQ was revived.")

    def on_connection_error(self, exc, interval):
        self.retry_attempts += 1
        msg = ("RabbitMQ Broker connection error: %r. "
               "Trying again in %s seconds.", exc, interval)
        if self.retry_attempts >= self.connect_max_retries:
            # If we're on the last retry
            _get_child_logger().error(*msg)
        else:
            _get_child_logger().warn(*msg)

    def on_decode_error(self, message, exc):
        _get_child_logger().exception("Decode Error: %s" % exc)
        # do NOT call message.ack(), otherwise the message will be lost


def continue_running():
    return not shutdown_soon


def exit_or_sleep(exit=False):
    if exit:
        sys.exit(1)
    time.sleep(5)


def run(deployment_config, deployment_id, exchange):
    name = deployment_config['name']
    host = deployment_config.get('rabbit_host', 'localhost')
    port = deployment_config.get('rabbit_port', 5672)
    user_id = deployment_config.get('rabbit_userid', 'rabbit')
    password = deployment_config.get('rabbit_password', 'rabbit')
    virtual_host = deployment_config.get('rabbit_virtual_host', '/')
    durable = deployment_config.get('durable_queue', True)
    queue_arguments = deployment_config.get('queue_arguments', {})
    exit_on_exception = deployment_config.get('exit_on_exception', False)
    topics = deployment_config.get('topics', {})
    logger = _get_child_logger()

    deployment = db.get_deployment(deployment_id)

    print "Starting worker for '%s %s'" % (name, exchange)
    logger.info("%s: %s %s %s %s %s" %
                (name, exchange, host, port, user_id, virtual_host))

    params = dict(hostname=host,
                  port=port,
                  userid=user_id,
                  password=password,
                  transport="librabbitmq",
                  virtual_host=virtual_host)

    # continue_running() is used for testing
    while continue_running():
        try:
            logger.debug("Processing on '%s %s'" % (name, exchange))
            with kombu.connection.BrokerConnection(**params) as conn:
                try:
                    consumer = Consumer(name, conn, deployment, durable,
                                        queue_arguments, exchange,
                                        topics[exchange])
                    consumer.run()
                except Exception as e:
                    logger.error("!!!!Exception!!!!")
                    logger.exception(
                        "name=%s, exchange=%s, exception=%s. "
                        "Reconnecting in 5s" % (name, exchange, e))
                    exit_or_sleep(exit_on_exception)
            logger.debug("Completed processing on '%s %s'" %
                                      (name, exchange))
        except Exception:
            logger.error("!!!!Exception!!!!")
            e = sys.exc_info()[0]
            msg = "Uncaught exception: deployment=%s, exchange=%s, " \
                  "exception=%s. Retrying in 5s"
            logger.exception(msg % (name, exchange, e))
            exit_or_sleep(exit_on_exception)
    logger.info("Worker exiting.")

signal.signal(signal.SIGINT, signal.SIG_IGN)
signal.signal(signal.SIGTERM, signal.SIG_IGN)

POST_PROCESS_METHODS = {
    'RawData': views.post_process_rawdata,
    'GlanceRawData': views.post_process_glancerawdata,
    'GenericRawData': views.post_process_genericrawdata
}

########NEW FILE########
