__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# PyQt by Examples documentation build configuration file, created by
# sphinx-quickstart on Thu Apr  2 17:41:41 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.ifconfig']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'PyQt by Examples'
copyright = u'2009, Roberto Alsina'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.5'
# The full version, including alpha/beta/rc tags.
release = '0.5'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'PyQtbyExamplesdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'PyQtbyExamples.tex', u'PyQt by Examples Documentation',
   u'Roberto Alsina', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = clock
# -*- coding: utf-8 -*-
"""The user interface for our app"""

import os,sys,time

# Import Qt modules
from PyQt4 import QtCore,QtGui, QtOpenGL

# Import the compiled UI module
from ui_clock import Ui_Form

from random import randint, shuffle

# Create a class for our main window
class Main(QtGui.QWidget):
    def __init__(self):
        QtGui.QWidget.__init__(self)

        # This is always the same
        self.ui=Ui_Form()
        self.ui.setupUi(self)

        self.scene=QtGui.QGraphicsScene()
        self.scene.setSceneRect(0,0,600,400)
        self.ui.view.setScene(self.scene)
        #self.ui.view.setViewport(QtOpenGL.QGLWidget())
        self.populate()
        self.setWindowState(QtCore.Qt.WindowMaximized)

        self.animator=QtCore.QTimer()
        self.animator.timeout.connect(self.animate)
        self.animate()

    def populate(self):
        self.digits=[]
        self.animations=[]
        font=QtGui.QFont('White Rabbit')
        font.setPointSize(120)

        self.dot1=QtGui.QGraphicsTextItem(':')
        self.dot1.setFont(font)
        self.dot1.setPos(140,0)
        self.scene.addItem(self.dot1)
        self.dot2=QtGui.QGraphicsTextItem(':')
        self.dot2.setFont(font)
        self.dot2.setPos(410,0)
        self.scene.addItem(self.dot2)

        for i in range(60):
            l = QtGui.QGraphicsTextItem(str(i%10))
            l.setFont(font)
            l.setZValue(-100)
            l.setPos(randint(0,500),randint(150,300))
            l.setOpacity(.3)
            #l.setDefaultTextColor(QtGui.QColor('lightgray'))
            self.scene.addItem(l)
            self.digits.append(l)

    def animate(self):
        self.animations=range(0,60)

        def animate_to(t,item,x,y,angle):
            animation=QtGui.QGraphicsItemAnimation()
            timeline=QtCore.QTimeLine(1000)
            timeline.setFrameRange(0,100)
            animation.setPosAt(t,QtCore.QPointF(x,y))
            animation.setRotationAt(t,angle)
            animation.setItem(item)
            animation.setTimeLine(timeline)
            return animation

        offsets=range(6)
        shuffle(offsets)

        # Some, animate with purpose
        h1,h2=map(int,'%02d'%time.localtime().tm_hour)
        h1+=offsets[0]*10
        h2+=offsets[1]*10
        self.animations[h1]=animate_to(0.2,self.digits[h1],-40,0,0)
        self.animations[h2]=animate_to(0.2,self.digits[h2],50,0,0)

        m1,m2=map(int,'%02d'%time.localtime().tm_min)
        m1+=offsets[2]*10
        m2+=offsets[3]*10
        self.animations[m1]=animate_to(0.2,self.digits[m1],230,0,0)
        self.animations[m2]=animate_to(0.2,self.digits[m2],320,0,0)

        s1,s2=map(int,'%02d'%time.localtime().tm_sec)
        s1+=offsets[4]*10
        s2+=offsets[5]*10
        self.animations[s1]=animate_to(0.2,self.digits[s1],500,0,0)
        self.animations[s2]=animate_to(0.2,self.digits[s2],590,0,0)

        # Random animations
        for i in range(60):
            l = self.digits[i]
            if i in [h1,h2,m1,m2,s1,s2]:
                l.setOpacity(1)
                continue
            l.setOpacity(.3)
            self.animations[i]=animate_to(1,l,randint(0,500),randint(0,300),randint(0,0))

        [ animation.timeLine().start() for animation in self.animations ]


        self.animator.start(1000)
        

def main():
    # Again, this is boilerplate, it's going to be the same on
    # almost every app you write
    app = QtGui.QApplication(sys.argv)
    window=Main()
    window.show()


    # It's exec_ because exec is a reserved word in Python
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-

"""The user interface for our app"""

import os,sys

# Import Qt modules
from PyQt4 import QtCore,QtGui

# Import the compiled UI module
from windowUi import Ui_MainWindow

# Create a class for our main window
class Main(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        
        # This is always the same
        self.ui=Ui_MainWindow()
        self.ui.setupUi(self)

def main():
    # Again, this is boilerplate, it's going to be the same on 
    # almost every app you write
    app = QtGui.QApplication(sys.argv)
    window=Main()
    window.show()
    # It's exec_ because exec is a reserved word in Python
    sys.exit(app.exec_())
    

if __name__ == "__main__":
    main()
    
########NEW FILE########
__FILENAME__ = todo
# -*- coding: utf-8 -*-

"""A simple backend for a TODO app, using Elixir"""

import os
from elixir import *

dbdir=os.path.join(os.path.expanduser("~"),".pyqtodo")
dbfile=os.path.join(dbdir,"tasks.sqlite")

# It's good policy to have your app use a hidden folder in 
# the user's home to store its files. That way, you can 
# always find them, and the user knows where everything is.

class Task(Entity):
    """
    A task for your TODO list.
    """
    
    # By inheriting Entity, we are using Elixir to make this 
    # class persistent, Task objects can easily be stored in 
    # our database, and you can search for them, change them, 
    # delete them, etc.        
    
    using_options(tablename='tasks')
    # This specifies the table name we will use in the database, 
    # I think it's nicer than the automatic names Elixir uses.
    
    text = Field(Unicode,required=True)
    date = Field(DateTime,default=None,required=False)
    done = Field(Boolean,default=False,required=True)
    tags  = ManyToMany("Tag")
    
    # A task has the following:
    #
    # * A text ("Buy groceries"). Always try to use unicode 
    #    in your app. Using anything else is *not worth 
    #    the trouble*. 
    #
    # * A date for when it's due.
    #
    # * A "Done" field. Is it done?
    #
    # * A list of tags. For example, "Buy groceries" could be 
    # tagged "Home" and "Important". It's ManyToMany because 
    # a task can have many tags and a tag can have many tasks.        
    
    def __repr__(self):
        return "Task: "+self.text
        
    # It's always nicer if objects know how to turn themselves 
    # into strings. That way you can help debug your program 
    # just by printing them. Here, our groceries task would 
    # print as "Task: Buy groceries".
    
# Since earlier I mentioned Tags, we need to define them too:

class Tag(Entity):
    """
    A tag we can apply to a task.
    """
    # Again, they go in the database, so they are an Entity.
    
    using_options(tablename='tags')
    name = Field(Unicode,required=True)
    tasks = ManyToMany("Task")
    
    def __repr__(self):
        return "Tag: "+self.name

    # They are much simpler objects: they have a name, 
    # a list of tagged tasks, and can convert themselves 
    # to strings.
    
saveData=None

# Using a database involves a few chores. I put them 
# in the initDB function. Just remember to call it before 
# trying to use Tasks or Tags!

def initDB():
    # Make sure ~/.pyqtodo exists
    if not os.path.isdir(dbdir):
        os.mkdir(dbdir)
    # Set up the Elixir internal thingamajigs
    metadata.bind = "sqlite:///%s"%dbfile
    setup_all()
    # And if the database doesn't exist: create it.
    if not os.path.exists(dbfile):
        create_all()
        
    # This is so Elixir 0.5.x and 0.6.x work
    # Yes, it's kinda ugly, but needed for Debian 
    # and Ubuntu and other distros.
    
    global saveData
    import elixir
    if elixir.__version__ < "0.6":
        saveData=session.flush
    else:
        saveData=session.commit
        
    
# Usually, I add a main() function to all modules that 
# does something useful, perhaps run unit tests. In this 
# case, it demonstrates our backend's functionality. 
# You can try it by running it like this::
#
#   python todo.py

# No detailed comments in this one: study it yourself, it's not complicated!

def main():
    
    # Initialize database
    initDB()
    
    # Create two tags
    green=Tag(name=u"green")
    red=Tag(name=u"red")
    
    #Create a few tags and tag them
    tarea1=Task(text=u"Buy tomatos",tags=[red])
    tarea2=Task(text=u"Buy chili",tags=[red])
    tarea3=Task(text=u"Buy lettuce",tags=[green])
    tarea4=Task(text=u"Buy strawberries",tags=[red,green])
    saveData()
    
    print "Green Tasks:"
    print green.tasks
    print
    print "Red Tasks:"
    print red.tasks
    print
    print "Tasks with l:"
    print [(t.id,t.text,t.done) for t in Task.query.filter(Task.text.like(ur'%l%')).all()]

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-

"""The user interface for our app"""

import os,sys

# Import Qt modules
from PyQt4 import QtCore,QtGui

# Import the compiled UI module
from windowUi import Ui_MainWindow

# Import our backend
import todo

# Create a class for our main window
class Main(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        
        # This is always the same
        self.ui=Ui_MainWindow()
        self.ui.setupUi(self)

        # Let's do something interesting: load the database contents 
        # into our task list widget
        for task in todo.Task.query().all():
            tags=','.join([t.name for t in task.tags])
            item=QtGui.QTreeWidgetItem([task.text,str(task.date),tags])
            item.task=task
            if task.done:
                item.setCheckState(0,QtCore.Qt.Checked)
            else:
                item.setCheckState(0,QtCore.Qt.Unchecked)
            self.ui.list.addTopLevelItem(item)

    def on_list_itemChanged(self,item,column):
        if item.checkState(0):
            item.task.done=True
        else:
            item.task.done=False
        todo.saveData()


def main():
    # Init the database before doing anything else
    todo.initDB()
    
    # Again, this is boilerplate, it's going to be the same on 
    # almost every app you write
    app = QtGui.QApplication(sys.argv)
    window=Main()
    window.show()
    # It's exec_ because exec is a reserved word in Python
    sys.exit(app.exec_())
    

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = todo
# -*- coding: utf-8 -*-

"""A simple backend for a TODO app, using Elixir"""

import os
from elixir import *

dbdir=os.path.join(os.path.expanduser("~"),".pyqtodo")
dbfile=os.path.join(dbdir,"tasks.sqlite")

# It's good policy to have your app use a hidden folder in 
# the user's home to store its files. That way, you can 
# always find them, and the user knows where everything is.

class Task(Entity):
    """
    A task for your TODO list.
    """
    
    # By inheriting Entity, we are using Elixir to make this 
    # class persistent, Task objects can easily be stored in 
    # our database, and you can search for them, change them, 
    # delete them, etc.        
    
    using_options(tablename='tasks')
    # This specifies the table name we will use in the database, 
    # I think it's nicer than the automatic names Elixir uses.
    
    text = Field(Unicode,required=True)
    date = Field(DateTime,default=None,required=False)
    done = Field(Boolean,default=False,required=True)
    tags  = ManyToMany("Tag")
    
    # A task has the following:
    #
    # * A text ("Buy groceries"). Always try to use unicode 
    #    in your app. Using anything else is *not worth 
    #    the trouble*. 
    #
    # * A date for when it's due.
    #
    # * A "Done" field. Is it done?
    #
    # * A list of tags. For example, "Buy groceries" could be 
    # tagged "Home" and "Important". It's ManyToMany because 
    # a task can have many tags and a tag can have many tasks.        
    
    def __repr__(self):
        return "Task: "+self.text
        
    # It's always nicer if objects know how to turn themselves 
    # into strings. That way you can help debug your program 
    # just by printing them. Here, our groceries task would 
    # print as "Task: Buy groceries".
    
# Since earlier I mentioned Tags, we need to define them too:

class Tag(Entity):
    """
    A tag we can apply to a task.
    """
    # Again, they go in the database, so they are an Entity.
    
    using_options(tablename='tags')
    name = Field(Unicode,required=True)
    tasks = ManyToMany("Task")
    
    def __repr__(self):
        return "Tag: "+self.name

    # They are much simpler objects: they have a name, 
    # a list of tagged tasks, and can convert themselves 
    # to strings.
    
saveData=None

# Using a database involves a few chores. I put them 
# in the initDB function. Just remember to call it before 
# trying to use Tasks or Tags!

def initDB():
    # Make sure ~/.pyqtodo exists
    if not os.path.isdir(dbdir):
        os.mkdir(dbdir)
    # Set up the Elixir internal thingamajigs
    metadata.bind = "sqlite:///%s"%dbfile
    setup_all()
    # And if the database doesn't exist: create it.
    if not os.path.exists(dbfile):
        create_all()
        
    # This is so Elixir 0.5.x and 0.6.x work
    # Yes, it's kinda ugly, but needed for Debian 
    # and Ubuntu and other distros.
    
    global saveData
    import elixir
    if elixir.__version__ < "0.6":
        saveData=session.flush
    else:
        saveData=session.commit
        
    
# Usually, I add a main() function to all modules that 
# does something useful, perhaps run unit tests. In this 
# case, it demonstrates our backend's functionality. 
# You can try it by running it like this::
#
#   python todo.py

# No detailed comments in this one: study it yourself, it's not complicated!

def main():
    
    # Initialize database
    initDB()
    
    # Create two tags
    green=Tag(name=u"green")
    red=Tag(name=u"red")
    
    #Create a few tags and tag them
    tarea1=Task(text=u"Buy tomatos",tags=[red])
    tarea2=Task(text=u"Buy chili",tags=[red])
    tarea3=Task(text=u"Buy lettuce",tags=[green])
    tarea4=Task(text=u"Buy strawberries",tags=[red,green])
    saveData()
    
    print "Green Tasks:"
    print green.tasks
    print
    print "Red Tasks:"
    print red.tasks
    print
    print "Tasks with l:"
    print [(t.id,t.text,t.done) for t in Task.query.filter(Task.text.like(ur'%l%')).all()]

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-

"""The user interface for our app"""

import os,sys

# Import Qt modules
from PyQt4 import QtCore,QtGui

# Import the compiled UI module
from windowUi import Ui_MainWindow

# Import our backend
import todo

# Create a class for our main window
class Main(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        
        # This is always the same
        self.ui=Ui_MainWindow()
        self.ui.setupUi(self)

        # Let's do something interesting: load the database contents 
        # into our task list widget
        for task in todo.Task.query().all():
            tags=','.join([t.name for t in task.tags])
            item=QtGui.QTreeWidgetItem([task.text,str(task.date),tags])
            item.task=task
            if task.done:
                item.setCheckState(0,QtCore.Qt.Checked)
            else:
                item.setCheckState(0,QtCore.Qt.Unchecked)
            self.ui.list.addTopLevelItem(item)

    def on_list_itemChanged(self,item,column):
        if item.checkState(0):
            item.task.done=True
        else:
            item.task.done=False
        todo.saveData()


def main():
    # Init the database before doing anything else
    todo.initDB()
    
    # Again, this is boilerplate, it's going to be the same on 
    # almost every app you write
    app = QtGui.QApplication(sys.argv)
    window=Main()
    window.show()
    # It's exec_ because exec is a reserved word in Python
    sys.exit(app.exec_())
    

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = todo
# -*- coding: utf-8 -*-

"""A simple backend for a TODO app, using Elixir"""

import os
from elixir import *

dbdir=os.path.join(os.path.expanduser("~"),".pyqtodo")
dbfile=os.path.join(dbdir,"tasks.sqlite")

# It's good policy to have your app use a hidden folder in 
# the user's home to store its files. That way, you can 
# always find them, and the user knows where everything is.

class Task(Entity):
    """
    A task for your TODO list.
    """
    
    # By inheriting Entity, we are using Elixir to make this 
    # class persistent, Task objects can easily be stored in 
    # our database, and you can search for them, change them, 
    # delete them, etc.        
    
    using_options(tablename='tasks')
    # This specifies the table name we will use in the database, 
    # I think it's nicer than the automatic names Elixir uses.
    
    text = Field(Unicode,required=True)
    date = Field(DateTime,default=None,required=False)
    done = Field(Boolean,default=False,required=True)
    tags  = ManyToMany("Tag")
    
    # A task has the following:
    #
    # * A text ("Buy groceries"). Always try to use unicode 
    #    in your app. Using anything else is *not worth 
    #    the trouble*. 
    #
    # * A date for when it's due.
    #
    # * A "Done" field. Is it done?
    #
    # * A list of tags. For example, "Buy groceries" could be 
    # tagged "Home" and "Important". It's ManyToMany because 
    # a task can have many tags and a tag can have many tasks.        
    
    def __repr__(self):
        return "Task: "+self.text
        
    # It's always nicer if objects know how to turn themselves 
    # into strings. That way you can help debug your program 
    # just by printing them. Here, our groceries task would 
    # print as "Task: Buy groceries".
    
# Since earlier I mentioned Tags, we need to define them too:

class Tag(Entity):
    """
    A tag we can apply to a task.
    """
    # Again, they go in the database, so they are an Entity.
    
    using_options(tablename='tags')
    name = Field(Unicode,required=True)
    tasks = ManyToMany("Task")
    
    def __repr__(self):
        return "Tag: "+self.name

    # They are much simpler objects: they have a name, 
    # a list of tagged tasks, and can convert themselves 
    # to strings.
    
saveData=None

# Using a database involves a few chores. I put them 
# in the initDB function. Just remember to call it before 
# trying to use Tasks or Tags!

def initDB():
    # Make sure ~/.pyqtodo exists
    if not os.path.isdir(dbdir):
        os.mkdir(dbdir)
    # Set up the Elixir internal thingamajigs
    metadata.bind = "sqlite:///%s"%dbfile
    setup_all()
    # And if the database doesn't exist: create it.
    if not os.path.exists(dbfile):
        create_all()
        
    # This is so Elixir 0.5.x and 0.6.x work
    # Yes, it's kinda ugly, but needed for Debian 
    # and Ubuntu and other distros.
    
    global saveData
    import elixir
    if elixir.__version__ < "0.6":
        saveData=session.flush
    else:
        saveData=session.commit
        
    
# Usually, I add a main() function to all modules that 
# does something useful, perhaps run unit tests. In this 
# case, it demonstrates our backend's functionality. 
# You can try it by running it like this::
#
#   python todo.py

# No detailed comments in this one: study it yourself, it's not complicated!

def main():
    
    # Initialize database
    initDB()
    
    # Create two tags
    green=Tag(name=u"green")
    red=Tag(name=u"red")
    
    #Create a few tags and tag them
    tarea1=Task(text=u"Buy tomatos",tags=[red])
    tarea2=Task(text=u"Buy chili",tags=[red])
    tarea3=Task(text=u"Buy lettuce",tags=[green])
    tarea4=Task(text=u"Buy strawberries",tags=[red,green])
    saveData()
    
    print "Green Tasks:"
    print green.tasks
    print
    print "Red Tasks:"
    print red.tasks
    print
    print "Tasks with l:"
    print [(t.id,t.text,t.done) for t in Task.query.filter(Task.text.like(ur'%l%')).all()]

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-

"""The user interface for our app"""

import os,sys

# Import Qt modules
from PyQt4 import QtCore,QtGui

# Import the compiled UI module
from windowUi import Ui_MainWindow

# Import our backend
import todo

# Create a class for our main window
class Main(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        
        # This is always the same
        self.ui=Ui_MainWindow()
        self.ui.setupUi(self)

        # Let's do something interesting: load the database contents 
        # into our task list widget
        for task in todo.Task.query().all():
            tags=','.join([t.name for t in task.tags])
            item=QtGui.QTreeWidgetItem([task.text,str(task.date),tags])
            item.task=task
            if task.done:
                item.setCheckState(0,QtCore.Qt.Checked)
            else:
                item.setCheckState(0,QtCore.Qt.Unchecked)
            self.ui.list.addTopLevelItem(item)

    def on_list_itemChanged(self,item,column):
        if item.checkState(0):
            item.task.done=True
        else:
            item.task.done=False
        todo.saveData()

    def on_actionDelete_Task_triggered(self,checked=None):
        if checked is None: return
        # First see what task is "current".
        item=self.ui.list.currentItem()
        
        if not item: # None selected, so we don't know what to delete!
            return
        # Actually delete the task
        item.task.delete()
        todo.saveData()
        
        # And remove the item. I think that's not pretty. Is it the only way?
        self.ui.list.takeTopLevelItem(self.ui.list.indexOfTopLevelItem(item))

    def on_list_currentItemChanged(self,current=None,previous=None):
        if current:
            print "enabling", current
            self.ui.actionDelete_Task.setEnabled(True)
        else:
            self.ui.actionDelete_Task.setEnabled(False)

def main():
    # Init the database before doing anything else
    todo.initDB()
    
    # Again, this is boilerplate, it's going to be the same on 
    # almost every app you write
    app = QtGui.QApplication(sys.argv)
    window=Main()
    window.show()
    # It's exec_ because exec is a reserved word in Python
    sys.exit(app.exec_())
    

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = todo
# -*- coding: utf-8 -*-

"""A simple backend for a TODO app, using Elixir"""

import os
from elixir import *

dbdir=os.path.join(os.path.expanduser("~"),".pyqtodo")
dbfile=os.path.join(dbdir,"tasks.sqlite")

# It's good policy to have your app use a hidden folder in 
# the user's home to store its files. That way, you can 
# always find them, and the user knows where everything is.

class Task(Entity):
    """
    A task for your TODO list.
    """
    
    # By inheriting Entity, we are using Elixir to make this 
    # class persistent, Task objects can easily be stored in 
    # our database, and you can search for them, change them, 
    # delete them, etc.        
    
    using_options(tablename='tasks')
    # This specifies the table name we will use in the database, 
    # I think it's nicer than the automatic names Elixir uses.
    
    text = Field(Unicode,required=True)
    date = Field(DateTime,default=None,required=False)
    done = Field(Boolean,default=False,required=True)
    tags  = ManyToMany("Tag")
    
    # A task has the following:
    #
    # * A text ("Buy groceries"). Always try to use unicode 
    #    in your app. Using anything else is *not worth 
    #    the trouble*. 
    #
    # * A date for when it's due.
    #
    # * A "Done" field. Is it done?
    #
    # * A list of tags. For example, "Buy groceries" could be 
    # tagged "Home" and "Important". It's ManyToMany because 
    # a task can have many tags and a tag can have many tasks.        
    
    def __repr__(self):
        return "Task: "+self.text
        
    # It's always nicer if objects know how to turn themselves 
    # into strings. That way you can help debug your program 
    # just by printing them. Here, our groceries task would 
    # print as "Task: Buy groceries".
    
# Since earlier I mentioned Tags, we need to define them too:

class Tag(Entity):
    """
    A tag we can apply to a task.
    """
    # Again, they go in the database, so they are an Entity.
    
    using_options(tablename='tags')
    name = Field(Unicode,required=True)
    tasks = ManyToMany("Task")
    
    def __repr__(self):
        return "Tag: "+self.name

    # They are much simpler objects: they have a name, 
    # a list of tagged tasks, and can convert themselves 
    # to strings.
    
saveData=None

# Using a database involves a few chores. I put them 
# in the initDB function. Just remember to call it before 
# trying to use Tasks or Tags!

def initDB():
    # Make sure ~/.pyqtodo exists
    if not os.path.isdir(dbdir):
        os.mkdir(dbdir)
    # Set up the Elixir internal thingamajigs
    metadata.bind = "sqlite:///%s"%dbfile
    setup_all()
    # And if the database doesn't exist: create it.
    if not os.path.exists(dbfile):
        create_all()
        
    # This is so Elixir 0.5.x and 0.6.x work
    # Yes, it's kinda ugly, but needed for Debian 
    # and Ubuntu and other distros.
    
    global saveData
    import elixir
    if elixir.__version__ < "0.6":
        saveData=session.flush
    else:
        saveData=session.commit
        
    
# Usually, I add a main() function to all modules that 
# does something useful, perhaps run unit tests. In this 
# case, it demonstrates our backend's functionality. 
# You can try it by running it like this::
#
#   python todo.py

# No detailed comments in this one: study it yourself, it's not complicated!

def main():
    
    # Initialize database
    initDB()
    
    # Create two tags
    green=Tag(name=u"green")
    red=Tag(name=u"red")
    
    #Create a few tags and tag them
    tarea1=Task(text=u"Buy tomatos",tags=[red])
    tarea2=Task(text=u"Buy chili",tags=[red])
    tarea3=Task(text=u"Buy lettuce",tags=[green])
    tarea4=Task(text=u"Buy strawberries",tags=[red,green])
    saveData()
    
    print "Green Tasks:"
    print green.tasks
    print
    print "Red Tasks:"
    print red.tasks
    print
    print "Tasks with l:"
    print [(t.id,t.text,t.done) for t in Task.query.filter(Task.text.like(ur'%l%')).all()]

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = editor
# -*- coding: utf-8 -*-

"""A custom widget that edits a task's properties"""

# Import Qt modules
from PyQt4 import QtCore,QtGui

# Import the compiled UI module
from editorUi import Ui_Form

# The backend
import todo

# Misc.
from datetime import datetime

class editor(QtGui.QWidget):
    def __init__(self,parent,task=None):
        QtGui.QWidget.__init__(self,parent)

        self.ui=Ui_Form()
        self.ui.setupUi(self)
        
        # Start with no task item to edit
        self.item=None

    def edit(self,item):
        """Takes an item, loads the widget with the item's
        task contents, shows the widget"""
        self.item=item
        self.ui.task.setText(self.item.task.text)
        self.ui.done.setChecked(self.item.task.done)
        dt=self.item.task.date
        if dt:
            self.ui.dateTime.setDate(QtCore.QDate(dt.year,dt.month,dt.day))
            self.ui.dateTime.setTime(QtCore.QTime(dt.hour,dt.minute))
        else:
            self.ui.dateTime.setDateTime(QtCore.QDateTime())
        self.ui.tags.setText(','.join( t.name for t in self.item.task.tags))
        self.show()
        
    def save(self):
        if self.item==None: return
        
        # Save date and time in the task
        d=self.ui.dateTime.date()
        t=self.ui.dateTime.time()
        
        self.item.task.date=datetime(
            d.year(),
            d.month(),
            d.day(),
            t.hour(),
            t.minute()
        )
        
        # Save text in the task
        self.item.task.text=unicode(self.ui.task.text())

        # Save tags.
        tags=[s.strip() for s in unicode(self.ui.tags.text()).split(',')]
        # For each tag, see if it is in the DB. If it is not, create it. If you had 
        # a million tags, this would be very very wrong code
        self.item.task.tags=[]
        for tag in tags:
            dbTag=todo.Tag.get_by(name=tag)
            if dbTag is None: # Tag is new, create it
                print "Creating tag: ",tag
                self.item.task.tags.append(todo.Tag(name=tag))
            else:
                self.item.task.tags.append(dbTag)
                
        # Display the data in the item
        self.item.setText(0,self.item.task.text)
        self.item.setText(1,str(self.item.task.date))
        self.item.setText(2,u','.join(t.name for t in self.item.task.tags))

        todo.saveData()
        
########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-

"""The user interface for our app"""

import os,sys

# Import Qt modules
from PyQt4 import QtCore,QtGui

# Import the compiled UI module
from windowUi import Ui_MainWindow

# Import our backend
import todo

# Create a class for our main window
class Main(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)
        
        # This is always the same
        self.ui=Ui_MainWindow()
        self.ui.setupUi(self)

        # Start with the editor hidden
        self.ui.editor.hide()

        # Let's do something interesting: load the database contents 
        # into our task list widget
        for task in todo.Task.query().all():
            tags=','.join([t.name for t in task.tags])
            item=QtGui.QTreeWidgetItem([task.text,str(task.date),tags])
            item.task=task
            if task.done:
                item.setCheckState(0,QtCore.Qt.Checked)
            else:
                item.setCheckState(0,QtCore.Qt.Unchecked)
            self.ui.list.addTopLevelItem(item)

    def on_list_itemChanged(self,item,column):
        if item.checkState(0):
            item.task.done=True
        else:
            item.task.done=False
        todo.saveData()

    def on_actionDelete_Task_triggered(self,checked=None):
        if checked is None: return
        # First see what task is "current".
        item=self.ui.list.currentItem()
        
        if not item: # None selected, so we don't know what to delete!
            return
        # Actually delete the task
        item.task.delete()
        todo.saveData()
        
        # And remove the item. I think that's not pretty. Is it the only way?
        self.ui.list.takeTopLevelItem(self.ui.list.indexOfTopLevelItem(item))

    def on_list_currentItemChanged(self,current=None,previous=None):
        # In Session 5, fixes a bug where an item was current but had no visible
        # changes, so it could be deleted/edited surprisingly.
        if current:
            current.setSelected(True)
            
        # Changed in session 5, because we have more than one action
        # that should only be enabled only if a task is selected
        for action in  [self.ui.actionDelete_Task,
                        self.ui.actionEdit_Task,
                       ]:
            if current:
                action.setEnabled(True)
            else:
                action.setEnabled(False)

    def on_actionNew_Task_triggered(self,checked=None):
        if checked is None: return
        # Create a dummy task
        task=todo.Task(text="New Task")
        
        # Create an item reflecting the task
        item=QtGui.QTreeWidgetItem([task.text,str(task.date),""])
        item.setCheckState(0,QtCore.Qt.Unchecked)
        item.task=task
        
        # Put the item in the task list
        self.ui.list.addTopLevelItem(item)
        self.ui.list.setCurrentItem(item)
        # Save it in the DB
        todo.saveData()
        # Open it with the editor
        self.ui.editor.edit(item)

    def on_actionEdit_Task_triggered(self,checked=None):
        if checked is None: return

        # First see what task is "current".
        item=self.ui.list.currentItem()
        
        if not item: # None selected, so we don't know what to edit!
            return
            
        # Open it with the editor
        self.ui.editor.edit(item)

def main():
    # Init the database before doing anything else
    todo.initDB()
    
    # Again, this is boilerplate, it's going to be the same on 
    # almost every app you write
    app = QtGui.QApplication(sys.argv)
    window=Main()
    window.show()
    # It's exec_ because exec is a reserved word in Python
    sys.exit(app.exec_())
    

if __name__ == "__main__":
    main()
    

########NEW FILE########
__FILENAME__ = todo
# -*- coding: utf-8 -*-

"""A simple backend for a TODO app, using Elixir"""

import os
from elixir import *

dbdir=os.path.join(os.path.expanduser("~"),".pyqtodo")
dbfile=os.path.join(dbdir,"tasks.sqlite")

# It's good policy to have your app use a hidden folder in 
# the user's home to store its files. That way, you can 
# always find them, and the user knows where everything is.

class Task(Entity):
    """
    A task for your TODO list.
    """
    
    # By inheriting Entity, we are using Elixir to make this 
    # class persistent, Task objects can easily be stored in 
    # our database, and you can search for them, change them, 
    # delete them, etc.        
    
    using_options(tablename='tasks')
    # This specifies the table name we will use in the database, 
    # I think it's nicer than the automatic names Elixir uses.
    
    text = Field(Unicode,required=True)
    date = Field(DateTime,default=None,required=False)
    done = Field(Boolean,default=False,required=True)
    tags  = ManyToMany("Tag")
    
    # A task has the following:
    #
    # * A text ("Buy groceries"). Always try to use unicode 
    #    in your app. Using anything else is *not worth 
    #    the trouble*. 
    #
    # * A date for when it's due.
    #
    # * A "Done" field. Is it done?
    #
    # * A list of tags. For example, "Buy groceries" could be 
    # tagged "Home" and "Important". It's ManyToMany because 
    # a task can have many tags and a tag can have many tasks.        
    
    def __repr__(self):
        return "Task: "+self.text
        
    # It's always nicer if objects know how to turn themselves 
    # into strings. That way you can help debug your program 
    # just by printing them. Here, our groceries task would 
    # print as "Task: Buy groceries".
    
# Since earlier I mentioned Tags, we need to define them too:

class Tag(Entity):
    """
    A tag we can apply to a task.
    """
    # Again, they go in the database, so they are an Entity.
    
    using_options(tablename='tags')
    name = Field(Unicode,required=True)
    tasks = ManyToMany("Task")
    
    def __repr__(self):
        return "Tag: "+self.name

    # They are much simpler objects: they have a name, 
    # a list of tagged tasks, and can convert themselves 
    # to strings.
    
saveData=None

# Using a database involves a few chores. I put them 
# in the initDB function. Just remember to call it before 
# trying to use Tasks or Tags!

def initDB():
    # Make sure ~/.pyqtodo exists
    if not os.path.isdir(dbdir):
        os.mkdir(dbdir)
    # Set up the Elixir internal thingamajigs
    metadata.bind = "sqlite:///%s"%dbfile
    setup_all()
    # And if the database doesn't exist: create it.
    if not os.path.exists(dbfile):
        create_all()
        
    # This is so Elixir 0.5.x and 0.6.x work
    # Yes, it's kinda ugly, but needed for Debian 
    # and Ubuntu and other distros.
    
    global saveData
    import elixir
    if elixir.__version__ < "0.6":
        saveData=session.flush
    else:
        saveData=session.commit
        
    
# Usually, I add a main() function to all modules that 
# does something useful, perhaps run unit tests. In this 
# case, it demonstrates our backend's functionality. 
# You can try it by running it like this::
#
#   python todo.py

# No detailed comments in this one: study it yourself, it's not complicated!

def main():
    
    # Initialize database
    initDB()
    
    # Create two tags
    green=Tag(name=u"green")
    red=Tag(name=u"red")
    
    #Create a few tags and tag them
    tarea1=Task(text=u"Buy tomatos",tags=[red])
    tarea2=Task(text=u"Buy chili",tags=[red])
    tarea3=Task(text=u"Buy lettuce",tags=[green])
    tarea4=Task(text=u"Buy strawberries",tags=[red,green])
    saveData()
    
    print "Green Tasks:"
    print green.tasks
    print
    print "Red Tasks:"
    print red.tasks
    print
    print "Tasks with l:"
    print [(t.id,t.text,t.done) for t in Task.query.filter(Task.text.like(ur'%l%')).all()]

if __name__ == "__main__":
    main()

########NEW FILE########
