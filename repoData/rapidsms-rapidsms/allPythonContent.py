__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# RapidSMS documentation build configuration file, created by
# sphinx-quickstart on Sun Oct 16 13:48:46 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
import rapidsms

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "_ext")))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['rapidsmsdocs', 'sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'RapidSMS'
copyright = u'2013, RapidSMS. Sphinx-powered using a <a href="https://github.com/mitsuhiko/flask-sphinx-themes">custom</a> theme'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '.'.join(rapidsms.__version__.split('.')[0:2])
# The full version, including alpha/beta/rc tags.
release = rapidsms.__version__
# The next version to be released
rapidsms_next_version = '0.18.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build', '_themes']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

intersphinx_mapping = {
    'python': ('http://docs.python.org/2.6', None),
    'django': ('https://django.readthedocs.org/en/1.4.X/', None),
}


# -- Options for HTML output ---------------------------------------------------

sys.path.append(os.path.abspath('_themes'))

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'kr'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'relations.html', 'sourcelink.html', 'searchbox.html'],
    '**':       ['sidebarintro.html', 'relations.html', 'localtoc.html', 'sourcelink.html',
                 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True


# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'RapidSMSdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'RapidSMS.tex', u'RapidSMS Documentation',
   u'RapidSMS', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'rapidsms', u'RapidSMS Documentation',
     [u'RapidSMS'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'RapidSMS', u'RapidSMS Documentation', u'RapidSMS',
   'RapidSMS', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# -- Additional config for Django ----------------------------------------------
# Arrange for importing rapidsms modules to work okay given that they'll
# try to pull in Django
# See http://techblog.ironfroggy.com/2012/06/how-to-use-sphinx-autodoc-on.html
sys.path.append(os.path.dirname(__file__))
import django
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")

########NEW FILE########
__FILENAME__ = settings
# Simple Django settings for use when generating docs
# See http://techblog.ironfroggy.com/2012/06/how-to-use-sphinx-autodoc-on.html

# Django settings for docs project.
# import source code dir
import os
import sys
sys.path.insert(0, os.getcwd())
sys.path.insert(0, os.path.join(os.getcwd(), os.pardir))

SITE_ID = 303
DEBUG = True
TEMPLATE_DEBUG = DEBUG

DATABASES = {"default": {
    "NAME": ":memory:",
    "ENGINE": "django.db.backends.sqlite3",
    "USER": '',
    "PASSWORD": '',
    "PORT": '',
    }}

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'rapidsms', # This is where you put your app
)

SECRET_KEY = 'dummy for sphinx builds'

########NEW FILE########
__FILENAME__ = rapidsmsdocs
"""
Sphinx plugins for RapidSMS documentation.
"""

try:
    import json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        try:
            from django.utils import simplejson as json
        except ImportError:
            json = None

from sphinx import addnodes, roles
from sphinx.util.compat import Directive


def setup(app):
    app.add_crossref_type(
        directivename = "setting",
        rolename      = "setting",
        indextemplate = "pair: %s; setting",
    )
    app.add_crossref_type(
        directivename = "templatetag",
        rolename      = "ttag",
        indextemplate = "pair: %s; template tag"
    )
    app.add_crossref_type(
        directivename = "templatefilter",
        rolename      = "tfilter",
        indextemplate = "pair: %s; template filter"
    )
    app.add_crossref_type(
        directivename = "router",
        rolename      = "router",
        indextemplate = "pair: %s; router",
    )
    app.add_config_value('rapidsms_next_version', '0.0', True)
    app.add_directive('versionadded', VersionDirective)
    app.add_directive('versionchanged', VersionDirective)


class VersionDirective(Directive):
    has_content = True
    required_arguments = 1
    optional_arguments = 1
    final_argument_whitespace = True
    option_spec = {}

    def run(self):
        env = self.state.document.settings.env
        arg0 = self.arguments[0]
        is_nextversion = env.config.rapidsms_next_version == arg0
        ret = []
        node = addnodes.versionmodified()
        ret.append(node)
        if not is_nextversion:
            if len(self.arguments) == 1:
                linktext = 'Please, see the release notes </releases/%s>' % (arg0)
                xrefs = roles.XRefRole()('doc', linktext, linktext,
                                         self.lineno, self.state)
                node.extend(xrefs[0])
            node['version'] = arg0
        else:
            node['version'] = "Development version"
        node['type'] = self.name
        if len(self.arguments) == 2:
            inodes, messages = self.state.inline_text(self.arguments[1],
                                                      self.lineno+1)
            node.extend(inodes)
            if self.content:
                self.state.nested_parse(self.content, self.content_offset,
                                        node)
            ret = ret + messages
        env.note_versionchange(node['type'], node['version'], node,
                               self.lineno)
        return ret

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = admin
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.contrib import admin
from .models import App, Backend, Connection, Contact


class ConnectionInline(admin.TabularInline):
    model = Connection
    extra = 1


class ContactAdmin(admin.ModelAdmin):
    inlines = (ConnectionInline,)


class ConnectionAdmin(admin.ModelAdmin):
    list_display = ('id', 'backend', 'identity', 'contact')
    list_filter = ('backend',)
    search_fields = ('identity',)
    raw_id_fields = ('contact',)


admin.site.register(App)
admin.site.register(Backend)
admin.site.register(Connection, ConnectionAdmin)
admin.site.register(Contact, ContactAdmin)

########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from ..utils.modules import try_import, get_class
from ..log.mixin import LoggerMixin


class AppBase(object, LoggerMixin):
    """
    """

    @classmethod
    def find(cls, app_name):
        """
        Return the RapidSMS app class from *app_name* (a standard Django
        app name), or None if it does not exist. Import errors raised
        *within* the module are allowed to propagate.
        """

        module_name = "%s.app" % app_name
        module = try_import(module_name)
        if module is None:
            return None
        try:
            app_class = get_class(module, cls)
        except AttributeError:
            app_class = None
        return app_class

    def __init__(self, router):
        self.router = router

    def _logger_name(self):  # pragma: no cover
        return "app/%s" % self.name

    @property
    def name(self):
        """
        Return the name of the module which this app was defined within.
        This can be considered a unique identifier with the project.
        """

        return self.__module__.split(".")[-2]

    def __unicode__(self):
        return self.name

    def __repr__(self):
        return "<app: %s>" %\
            self.name

    # incoming phases
    def filter(self, msg):
        pass

    def parse(self, msg):
        pass

    def handle(self, msg):
        pass

    def default(self, msg):
        pass

    def catch(self, msg):
        pass

    def cleanup(self, msg):
        pass

    # outgoing phases:
    def outgoing(self, msg):
        pass

########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.utils.modules import import_class
from rapidsms.log.mixin import LoggerMixin


class BackendBase(object, LoggerMixin):
    """Base class for outbound backend functionality."""

    @classmethod
    def find(cls, module_name):
        """
        Helper function to import backend classes.

        :param module_name: Dotted Python path to backend class name
        :returns: Imported class object
        """
        return import_class(module_name, cls)

    def __init__(self, router, name, **kwargs):
        self.router = router
        self.name = name

        self._config = kwargs
        self.configure(**kwargs)

    def _logger_name(self):  # pragma: no cover
        return "backend/%s" % self.name

    def __unicode__(self):
        return self.name

    def __repr__(self):
        return "<backend: %s>" % self.name

    def configure(self, **kwargs):
        """
        Configuration parameters from :setting:`INSTALLED_BACKENDS` will
        be passed here after the router is instantiated. You can override
        this method to parse your configuration.
        """
        pass

    def send(self, id_, text, identities, context={}):
        """
        Backend sending logic. The router will call this method for each
        outbound message. This method must be overridden by sub-classes.
        Backends typically initiate HTTP requests from within this method. Any
        exceptions raised here will be captured and logged by the selected
        router.

        If multiple ``identities`` are provided, the message is intended for
        all recipients.

        :param id\_: Message ID
        :param text: Message text
        :param identities: List of identities
        :param context: Optional extra context provided by router to backend
        """
        # subclasses should override this
        raise NotImplementedError()

    @property
    def model(self):
        """
        The model attribute is the RapidSMS model instance with this
        backend name. A new backend will automatically be created if
        one doesn't exist upon accessing this attribute.
        """
        from rapidsms.models import Backend
        backend, _ = Backend.objects.get_or_create(name=self.name)
        return backend

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'BackendMessage'
        db.create_table(u'database_backendmessage', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('date', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('direction', self.gf('django.db.models.fields.CharField')(max_length=1, db_index=True)),
            ('message_id', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('external_id', self.gf('django.db.models.fields.CharField')(max_length=64, blank=True)),
            ('identity', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('text', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'database', ['BackendMessage'])


    def backwards(self, orm):
        # Deleting model 'BackendMessage'
        db.delete_table(u'database_backendmessage')


    models = {
        u'database.backendmessage': {
            'Meta': {'object_name': 'BackendMessage'},
            'date': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'direction': ('django.db.models.fields.CharField', [], {'max_length': '1', 'db_index': 'True'}),
            'external_id': ('django.db.models.fields.CharField', [], {'max_length': '64', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identity': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'message_id': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'text': ('django.db.models.fields.TextField', [], {})
        }
    }

    complete_apps = ['database']
########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.db import models


INCOMING = 'I'
OUTGOING = 'O'

DIRECTION_CHOICES = (
    (INCOMING, "Incoming"),
    (OUTGOING, "Outgoing"),
)


class BackendMessage(models.Model):
    name = models.CharField(max_length=255)
    date = models.DateTimeField(auto_now_add=True)
    direction = models.CharField(max_length=1, choices=DIRECTION_CHOICES,
                                 db_index=True)
    message_id = models.CharField(max_length=64)
    external_id = models.CharField(max_length=64, blank=True)
    identity = models.CharField(max_length=100)
    text = models.TextField()

    def __unicode__(self):
        return self.text[:60]

########NEW FILE########
__FILENAME__ = outgoing
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import logging

from rapidsms.backends.base import BackendBase
from rapidsms.backends.database.models import BackendMessage


logger = logging.getLogger(__name__)


class DatabaseBackend(BackendBase):
    """
    Simple backend that uses the database for storage. Mostly used for testing.
    """

    def send(self, id_, text, identities, context):
        logger.info('Storing message: %s' % text)
        kwargs = {'name': self.name, 'direction': 'O', 'text': text,
                  'message_id': id_}
        if 'external_id' in context:
            kwargs['external_id'] = context['external_id']
        for identity in identities:
            kwargs['identity'] = identity
            BackendMessage.objects.create(**kwargs)
        return True

########NEW FILE########
__FILENAME__ = forms
from django import forms

from rapidsms.router import lookup_connections


class BaseHttpForm(forms.Form):
    """Helper form for validating incoming messages.

    :param backend_name: (Optional) name of the backend
    """

    def __init__(self, *args, **kwargs):
        """Save backend name to form for use later"""
        self.backend_name = kwargs.pop('backend_name')
        super(BaseHttpForm, self).__init__(*args, **kwargs)

    def lookup_connections(self, identities):
        """Simple wrapper to ease connection lookup on child forms."""
        return lookup_connections(self.backend_name, identities)

    def get_incoming_data(self):
        """
        Return a dictionary containing the connection and text
        for this message, based on the field
        names passed to __init__().

        Must be implemented by subclasses.
        """
        raise NotImplementedError()


class GenericHttpForm(BaseHttpForm):

    def __init__(self, *args, **kwargs):
        """
        Saves the identify (phone number) and text field names on self, calls
        super(), and then adds the required fields.
        """
        # defaults to "text" and "identity"
        self.text_name = kwargs.pop('text_name', 'text')
        self.identity_name = kwargs.pop('identity_name', 'identity')
        super(GenericHttpForm, self).__init__(*args, **kwargs)
        self.fields[self.text_name] = forms.CharField()
        self.fields[self.identity_name] = forms.CharField()

    def get_incoming_data(self):
        """
        Returns the connection and text for this message, based on the field
        names passed to __init__().
        """
        identity = self.cleaned_data[self.identity_name]
        connections = self.lookup_connections([identity])
        return {'connection': connections[0],
                'text': self.cleaned_data[self.text_name]}

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from django.core.urlresolvers import reverse
from django.conf.urls import patterns, url

from rapidsms.tests.harness import RapidTest
from rapidsms.backends.http import views
from rapidsms.backends.http.forms import BaseHttpForm, GenericHttpForm


class CustomHttpBackend(views.GenericHttpBackendView):
    """Generic HTTP backend with custom parameters."""

    backend_name = 'custom-http-backend'
    params = {'identity_name': 'phone', 'text_name': 'message'}


urlpatterns = patterns('',
                       url(r"^backend/http/$",
                           views.GenericHttpBackendView.as_view(
                               backend_name='http-backend'),
                           name='http-backend'
                           ),
                       url(r"^backend/http-custom/$",
                           CustomHttpBackend.as_view(),
                           name='custom-http-backend'
                           ),
                       )


class HttpFormTest(TestCase):

    def test_valid_default_post(self):
        """Form should be valid if POST keys match default configuration."""
        data = {'identity': '1112223333', 'text': 'hi there'}
        form = GenericHttpForm(data, backend_name='http-backend')
        self.assertTrue(form.is_valid(), form.errors)

    def test_valid_form_get(self):
        """Form should be valid if POST keys match configuration."""
        data = {'phone': '1112223333', 'message': 'hi there'}
        form = GenericHttpForm(data, backend_name='http-backend',
                               identity_name='phone', text_name='message')
        self.assertTrue(form.is_valid(), form.errors)

    def test_invalid_form_post(self):
        """Form is invalid if POST keys don't match configuration."""
        data = {'invalid-phone': '1112223333', 'invalid-message': 'hi there'}
        form = GenericHttpForm(data, backend_name='http-backend')
        self.assertFalse(form.is_valid())

    def test_not_implemented_get_incoming_data(self):
        """Subclasses must implement get_incoming_data."""
        form = BaseHttpForm(backend_name='http-backend')
        self.assertRaises(NotImplementedError, form.get_incoming_data)

    def test_get_incoming_data(self):
        """get_incoming_data should return matching text and connection."""
        data = {'identity': '1112223333', 'text': 'hi there'}
        form = GenericHttpForm(data, backend_name='http-backend')
        form.is_valid()
        incoming_data = form.get_incoming_data()
        self.assertEqual(data['text'], incoming_data['text'])
        self.assertEqual(data['identity'],
                         incoming_data['connection'].identity)
        self.assertEqual('http-backend',
                         incoming_data['connection'].backend.name)


class HttpViewTest(RapidTest):

    urls = 'rapidsms.backends.http.tests'
    disable_phases = True

    def setUp(self):
        self.http_backend_url = reverse('http-backend')
        self.custom_http_backend_url = reverse('custom-http-backend')

    def test_valid_response_get(self):
        """HTTP 200 should return with valid GET data."""
        data = {'identity': '1112223333', 'text': 'hi there'}
        response = self.client.get(self.http_backend_url, data)
        self.assertEqual(response.status_code, 200)

    def test_valid_response_post(self):
        """HTTP 200 should return with valid POST data."""
        data = {'identity': '1112223333', 'text': 'hi there'}
        response = self.client.post(self.http_backend_url, data)
        self.assertEqual(response.status_code, 200)

    def test_custom_valid_response_post(self):
        """HTTP 200 should return with custom valid POST data."""
        data = {'phone': '1112223333', 'message': 'hi there'}
        response = self.client.post(self.custom_http_backend_url, data)
        self.assertEqual(response.status_code, 200)

    def test_invalid_response_get(self):
        """HTTP 400 should return with invalid GET data."""
        data = {'invalid-phone': '1112223333', 'message': 'hi there'}
        response = self.client.get(self.http_backend_url, data)
        self.assertEqual(response.status_code, 400)

    def test_invalid_response_post(self):
        """HTTP 400 should return with invalid POST data."""
        data = {'invalid-phone': '1112223333', 'message': 'hi there'}
        response = self.client.post(self.http_backend_url, data)
        self.assertEqual(response.status_code, 400)

    def test_custom_invalid_response_post(self):
        """HTTP 400 should return with custom valid POST data."""
        data = {'bad-phone': '1112223333', 'bad-message': 'hi there'}
        response = self.client.post(self.custom_http_backend_url, data)
        self.assertEqual(response.status_code, 400)

    def test_valid_post_message(self):
        """Valid POSTs should pass message object to router."""
        data = {'identity': '1112223333', 'text': 'hi there'}
        self.client.post(self.http_backend_url, data)
        message = self.inbound[0]
        self.assertEqual(data['text'], message.text)
        self.assertEqual(data['identity'],
                         message.connection.identity)
        self.assertEqual('http-backend',
                         message.connection.backend.name)

    def test_valid_post_message_backend_name(self):
        """Created message/connection should be from custom http backend"""
        data = {'phone': '1112223333', 'message': 'hi there'}
        self.client.post(self.custom_http_backend_url, data)
        message = self.inbound[0]
        self.assertEqual('custom-http-backend',
                         message.connection.backend.name)

########NEW FILE########
__FILENAME__ = views
import pprint
import logging

from django.http import HttpResponse, HttpResponseBadRequest
from django.views.generic.edit import FormMixin, ProcessFormView
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt

from rapidsms.router import receive

from rapidsms.backends.http.forms import GenericHttpForm


logger = logging.getLogger(__name__)


class BaseHttpBackendView(FormMixin, ProcessFormView):

    backend_name = None
    http_method_names = []  # must set in child class

    @method_decorator(csrf_exempt)
    def dispatch(self, *args, **kwargs):
        """
        Wraps the main entry point into the view with the csrf_exempt
        decorator, which most (if not all) clients using this view will not
        know about.
        """
        if 'backend_name' in kwargs:
            self.backend_name = kwargs['backend_name']
        return super(BaseHttpBackendView, self).dispatch(*args, **kwargs)

    def get_form_kwargs(self):
        """Always pass backend_name into __init__"""
        kwargs = super(BaseHttpBackendView, self).get_form_kwargs()
        kwargs['backend_name'] = self.backend_name
        return kwargs

    def get(self, request, *args, **kwargs):
        """
        All this view does is processing inbound messages, and they may come
        through get() or post().  Pass HTTP GETs along to post() for
        form validation and subsequent handling by the router.
        """
        return self.post(request, *args, **kwargs)

    def form_valid(self, form):
        """
        If the form validated successfully, passes the message on to the
        router for processing.
        """
        data = form.get_incoming_data()
        receive(**data)
        return HttpResponse('OK')

    def form_invalid(self, form):
        """
        If the form failed to validate, logs the errors and returns a bad
        response to the client.
        """
        logger.error("%s data:" % self.request.method)
        logger.error(pprint.pformat(form.data))
        errors = dict((k, v[0]) for k, v in form.errors.items())
        logger.error(unicode(errors))
        if form.non_field_errors():
            logger.error(form.non_field_errors())
        return HttpResponseBadRequest('form failed to validate')


class GenericHttpBackendView(BaseHttpBackendView):
    """Simple view that allows customization of accepted paramters."""

    #: Accepts GET and POST by default.
    http_method_names = ['get', 'post']
    #: Dictionary that defines mappings to ``identity`` and ``text``.
    params = {}
    #: Form to validate that received parameters match defined ``params``.
    form_class = GenericHttpForm

    def get_form_kwargs(self):
        kwargs = super(GenericHttpBackendView, self).get_form_kwargs()
        # pass the identity and text field names into the form
        if self.params:
            kwargs.update(self.params)
        # if we accept GETs instead of POSTs and this request is a GET,
        # pass the GET parameters into the form
        if 'get' in self.http_method_names and self.request.method == 'GET':
            kwargs['data'] = self.request.GET
        return kwargs

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from rapidsms.backends.kannel.models import DeliveryReport


class DeliveryReportAdmin(admin.ModelAdmin):
    search_fields = ('text', 'sms_id', 'smsc')
    list_display = ('id', 'message_id', 'date', 'identity', 'status',
                    'status_text', 'smsc', 'date_sent')
    list_filter = ('smsc', 'status')
    ordering = ('-date',)


admin.site.register(DeliveryReport, DeliveryReportAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms

from rapidsms.backends.http.forms import BaseHttpForm


class KannelForm(BaseHttpForm):
    text = forms.CharField()
    id = forms.CharField()
    charset = forms.CharField(required=False)
    coding = forms.CharField(required=False)

    def clean_text(self):
        # UTF-8 (and possible other charsets) will already be decoded, while
        # UTF-16BE will not, so decode them manually here if we don't already
        # have a unicode string
        charset = self.cleaned_data.get('charset', None)
        text = self.cleaned_data['text']
        if charset and not isinstance(text, unicode):
            text = text.decode(charset)
        return text

    def get_incoming_data(self):
        connections = self.lookup_connections([self.cleaned_data['id']])
        return {'connection': connections[0],
                'text': self.cleaned_data['text']}

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'DeliveryReport'
        db.create_table(u'kannel_deliveryreport', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('date', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('date_sent', self.gf('django.db.models.fields.DateTimeField')()),
            ('message_id', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('identity', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('sms_id', self.gf('django.db.models.fields.CharField')(max_length=36)),
            ('smsc', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('status', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('status_text', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal(u'kannel', ['DeliveryReport'])


    def backwards(self, orm):
        # Deleting model 'DeliveryReport'
        db.delete_table(u'kannel_deliveryreport')


    models = {
        u'kannel.deliveryreport': {
            'Meta': {'object_name': 'DeliveryReport'},
            'date': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'date_sent': ('django.db.models.fields.DateTimeField', [], {}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identity': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'message_id': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'sms_id': ('django.db.models.fields.CharField', [], {'max_length': '36'}),
            'smsc': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'status': ('django.db.models.fields.SmallIntegerField', [], {}),
            'status_text': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        }
    }

    complete_apps = ['kannel']
########NEW FILE########
__FILENAME__ = models
from django.db import models


STATUS_CHOICES = (
    (1, 'Delivery Success'),
    (2, 'Delivery Failure'),
    (4, 'Message Buffered'),
    (8, 'SMSC Submit'),
    (16, 'SMSC Reject'),
)


class DeliveryReport(models.Model):
    """
    Model to track Kannel delivery reports.
    http://kannel.org/download/1.5.0/userguide-1.5.0/userguide.html#DELIVERY-REPORTS
    """
    date = models.DateTimeField(auto_now_add=True)
    date_sent = models.DateTimeField()
    message_id = models.CharField("Message ID", max_length=255)
    identity = models.CharField(max_length=100)
    sms_id = models.CharField("SMS ID", max_length=36)
    smsc = models.CharField("SMSC", max_length=255)
    status = models.SmallIntegerField(choices=STATUS_CHOICES)
    status_text = models.CharField(max_length=255)

########NEW FILE########
__FILENAME__ = outgoing
import copy
import requests
import logging

from django.core.urlresolvers import reverse
from rapidsms.backends.base import BackendBase


logger = logging.getLogger(__name__)


class KannelBackend(BackendBase):
    """Backend for use with the Kannel SMS Gateway."""

    def configure(self, sendsms_url='http://127.0.0.1:13013/cgi-bin/sendsms',
                  sendsms_params=None, charset=None, coding=None,
                  encode_errors=None, delivery_report_url=None, **kwargs):
        self.sendsms_url = sendsms_url
        self.sendsms_params = sendsms_params or {}
        self.charset = charset or 'ascii'
        self.coding = coding or 0
        self.encode_errors = encode_errors or 'ignore'
        self.delivery_report_url = delivery_report_url

    def prepare_request(self, id_, text, identities, context):
        """Prepare URL query string with message context."""
        kwargs = {'url': self.sendsms_url}
        query = copy.copy(self.sendsms_params)
        query['to'] = ' '.join(identities)
        query['text'] = text.encode(self.charset, self.encode_errors)
        query['coding'] = self.coding
        query['charset'] = self.charset
        if self.delivery_report_url:
            query['dlr-mask'] = 31
            dlr_url_params = ("message_id=%s" % id_,
                              "status=%d",
                              "status_text=%A",
                              "smsc=%i",
                              "sms_id=%I",
                              "date_sent=%t",
                              "identity=%p")
            dlr_url_params = '&'.join(dlr_url_params)
            dlr_url = "%s%s" % (self.delivery_report_url,
                                reverse('kannel-delivery-report'))
            query['dlr-url'] = '?'.join([dlr_url, dlr_url_params])
        kwargs['params'] = query
        return kwargs

    def send(self, id_, text, identities, context={}):
        logger.debug('Sending message: %s' % text)
        kwargs = self.prepare_request(id_, text, identities, context)
        r = requests.get(**kwargs)
        if r.status_code != requests.codes.ok:
            r.raise_for_status()

########NEW FILE########
__FILENAME__ = tests
import datetime

from django.test import TestCase
from django.core.urlresolvers import reverse
from django.conf.urls import patterns, url
from django.utils.timezone import now

from rapidsms.backends.kannel import views
from rapidsms.backends.kannel import KannelBackend
from rapidsms.backends.kannel.forms import KannelForm
from rapidsms.backends.kannel.models import DeliveryReport
from rapidsms.tests.harness import RapidTest, CreateDataMixin


urlpatterns = patterns('',
    url(r"^backend/kannel/$",
        views.KannelBackendView.as_view(backend_name='kannel-backend'),
        name='kannel-backend'),
)


class KannelFormTest(TestCase):

    def test_valid_form(self):
        """Form should be valid if GET keys match configuration."""
        data = {'id': '1112223333', 'text': 'hi there'}
        form = KannelForm(data, backend_name='kannel-backend')
        self.assertTrue(form.is_valid())

    def test_invalid_form(self):
        """Form is invalid if POST keys don't match configuration."""
        data = {'invalid-phone': '1112223333', 'invalid-message': 'hi there'}
        form = KannelForm(data, backend_name='kannel-backend')
        self.assertFalse(form.is_valid())

    def test_get_incoming_data(self):
        """get_incoming_data should return matching text and connection."""
        data = {'id': '1112223333', 'text': 'hi there'}
        form = KannelForm(data, backend_name='kannel-backend')
        form.is_valid()
        incoming_data = form.get_incoming_data()
        self.assertEqual(data['text'], incoming_data['text'])
        self.assertEqual(data['id'],
                         incoming_data['connection'].identity)
        self.assertEqual('kannel-backend',
                         incoming_data['connection'].backend.name)


class KannelViewTest(RapidTest):

    urls = 'rapidsms.backends.kannel.tests'
    disable_phases = True

    def test_valid_response_get(self):
        """HTTP 200 should return if data is valid."""
        data = {'id': '1112223333', 'text': 'hi there'}
        response = self.client.get(reverse('kannel-backend'), data)
        self.assertEqual(response.status_code, 200)

    def test_invalid_response(self):
        """HTTP 400 should return if data is invalid."""
        data = {'invalid-phone': '1112223333', 'message': 'hi there'}
        response = self.client.get(reverse('kannel-backend'), data)
        self.assertEqual(response.status_code, 400)

    def test_valid_post_message(self):
        """Valid POSTs should pass message object to router."""
        data = {'id': '1112223333', 'text': 'hi there'}
        self.client.get(reverse('kannel-backend'), data)
        message = self.inbound[0]
        self.assertEqual(data['text'], message.text)
        self.assertEqual(data['id'],
                         message.connection.identity)
        self.assertEqual('kannel-backend',
                         message.connection.backend.name)


class KannelSendTest(CreateDataMixin, TestCase):

    urls = 'rapidsms.backends.kannel.urls'

    def test_outgoing_keys(self):
        """Outgoing POST data should contain the proper keys."""
        message = self.create_outgoing_message()
        config = {
            "sendsms_url": "http://127.0.0.1:13013/cgi-bin/sendsms",
            "sendsms_params": {"smsc": "usb0-modem",
                               "from": "+SIMphonenumber",
                               "username": "rapidsms",
                               "password": "CHANGE-ME"},
            "coding": 0,
            "charset": "ascii",
            "encode_errors": "ignore",
        }
        backend = KannelBackend(None, "kannel", **config)
        kwargs = backend.prepare_request(1, message.text,
                                         [message.connections[0].identity], {})
        data = kwargs['params']
        self.assertEqual(config['sendsms_params']['smsc'], data['smsc'])
        self.assertEqual(config['sendsms_params']['from'], data['from'])
        self.assertEqual(config['sendsms_params']['username'],
                         data['username'])
        self.assertEqual(config['sendsms_params']['password'],
                         data['password'])
        self.assertEqual(message.connection.identity, data['to'])
        self.assertEqual(message.text, data['text'])
        self.assertEqual(config['coding'], data['coding'])
        self.assertEqual(config['charset'], data['charset'])

    def test_outgoing_unicode_characters(self):
        """Ensure outgoing messages are encoded properly."""
        message = self.create_outgoing_message()
        config = {
            "sendsms_params": {"smsc": "usb0-modem",
                               "from": "+SIMphonenumber",
                               "username": "rapidsms",
                               "password": "CHANGE-ME"},
            "charset": "UTF-8",
        }
        backend = KannelBackend(None, "kannel", **config)
        kwargs = backend.prepare_request(1, message.text,
                                         [message.connections[0].identity], {})
        data = kwargs['params']
        self.assertEqual(data['text'].decode('UTF-8'), message.text)

    def test_delivery_report_url(self):
        """delivery_report_url config option should send Kannel proper args."""
        message = self.create_outgoing_message()
        config = {
            "sendsms_params": {"smsc": "usb0-modem",
                               "from": "+SIMphonenumber",
                               "username": "rapidsms",
                               "password": "CHANGE-ME"},
            "delivery_report_url": "http://localhost:8000",
        }
        backend = KannelBackend(None, "kannel", **config)
        kwargs = backend.prepare_request(1, message.text,
                                         [message.connections[0].identity], {})
        data = kwargs['params']
        self.assertEqual(31, data['dlr-mask'])
        self.assertTrue("http://localhost:8000" in data['dlr-url'])


class KannelDeliveryReportTest(CreateDataMixin, TestCase):

    urls = 'rapidsms.backends.kannel.urls'

    def test_valid_post(self):
        """Valid delivery reports should create reports in the DB."""
        msg = self.create_outgoing_message()
        query = {'message_id': msg.id,
                 'identity': msg.connections[0].identity,
                 'status': 1,
                 'status_text': 'Success',
                 'smsc': 'usb0-modem',
                 'sms_id': self.random_string(36),
                 'date_sent': now()}
        url = reverse('kannel-delivery-report')
        response = self.client.get(url, query)
        self.assertEqual(200, response.status_code)
        self.assertEqual(1, DeliveryReport.objects.count())
        report = DeliveryReport.objects.all()[0]
        self.assertEqual(msg.id, report.message_id)

    def test_invalid_post(self):
        """Invalid post data should generate a 400."""
        msg = self.create_outgoing_message()
        query = {'message_id': msg.id,
                 'identity': msg.connections[0].identity,
                 'status': 3,
                 'status_text': 'Success',
                 'smsc': 'usb0-modem',
                 'sms_id': self.random_string(36),
                 'date_sent': now()}
        url = reverse('kannel-delivery-report')
        response = self.client.get(url, query)
        self.assertEqual(400, response.status_code)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from rapidsms.backends.kannel.views import DeliveryReportView


urlpatterns = patterns('',
    url(r"^delivery-report/$", DeliveryReportView.as_view(),
        name="kannel-delivery-report"),
)

########NEW FILE########
__FILENAME__ = views
import logging
import pprint

from django.http import HttpResponse, HttpResponseBadRequest
from django.views.generic.edit import CreateView

from rapidsms.backends.kannel.models import DeliveryReport
from rapidsms.backends.kannel.forms import KannelForm
from rapidsms.backends.http.views import BaseHttpBackendView


logger = logging.getLogger(__name__)


class KannelBackendView(BaseHttpBackendView):
    """Backend view for handling inbound SMSes from Kannel."""

    http_method_names = ['get']
    form_class = KannelForm

    def get(self, *args, **kwargs):
        """Kannel issues a GET instead of a POST, so pass it to post() here."""
        return self.post(*args, **kwargs)

    def get_form_kwargs(self):
        kwargs = super(KannelBackendView, self).get_form_kwargs()
        kwargs['data'] = self.request.GET  # passes request.GET to the form
        return kwargs

    def form_valid(self, form):
        super(KannelBackendView, self).form_valid(form)
        # any text in the response will be sent as an SMS, so make that ''
        return HttpResponse('')


class DeliveryReportView(CreateView):

    model = DeliveryReport
    http_method_names = ['get']

    def get(self, *args, **kwargs):
        """Kannel issues a GET instead of a POST, so pass it to post() here."""
        self.object = None
        return self.post(*args, **kwargs)

    def get_form_kwargs(self):
        kwargs = super(DeliveryReportView, self).get_form_kwargs()
        kwargs['data'] = self.request.GET  # passes request.GET to the form
        return kwargs

    def form_valid(self, form):
        self.object = form.save()
        return HttpResponse('')

    def form_invalid(self, form):
        """
        If the form failed to validate, logs the errors and returns a bad
        response to the client.
        """
        logger.error("%s data:" % self.request.method)
        logger.error(pprint.pformat(form.data))
        errors = dict((k, v[0]) for k, v in form.errors.items())
        logger.error(unicode(errors))
        if form.non_field_errors():
            logger.error(form.non_field_errors())
        return HttpResponseBadRequest('form failed to validate')

########NEW FILE########
__FILENAME__ = test_base
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4
from django.test import TestCase

from rapidsms.models import Backend
from rapidsms.backends.base import BackendBase


class TestBackend(BackendBase):
    pass


class BackendBaseTest(TestCase):

    def test_backend_has_name(self):
        backend = BackendBase(None, "mock")
        self.assertEquals(repr(backend), "<backend: mock>")
        self.assertEquals(unicode(backend), "mock")
        self.assertEquals(backend.name, "mock")

    def test_backend_has_model(self):
        backend = BackendBase(None, "mock")
        # the row should be created when .model is called.
        self.assertEquals(backend.model.__class__, Backend)
        self.assertEquals(backend.model.name, "mock")
        # check that the backend stub was committed to the db.
        self.assertEquals(Backend.objects.filter(name="mock").count(), 1)

    def test_backend_passes_kwargs_to_configure(self):
        class ConfigurableBackend(BackendBase):
            def configure(self, **kwargs):
                self.conf = kwargs
        conf_backend = ConfigurableBackend(None, "mock", a=1, b=2)
        self.assertEquals(conf_backend.conf, {"a": 1, "b": 2})

    def test_backend_finds_valid_backend_class(self):
        """Class should be returned if valid."""
        backend = BackendBase.find('rapidsms.backends.test_base.TestBackend')
        self.assertEquals(TestBackend, backend)

########NEW FILE########
__FILENAME__ = forms
from django import forms

from rapidsms.backends.http.forms import BaseHttpForm


class VumiForm(BaseHttpForm):
    message_id = forms.CharField()
    to_addr = forms.CharField()
    from_addr = forms.CharField()
    in_reply_to = forms.CharField(required=False)
    session_event = forms.CharField(required=False)
    content = forms.CharField(required=False)
    transport_name = forms.CharField()
    transport_type = forms.CharField()
    group = forms.CharField(required=False)

    def get_incoming_data(self):
        fields = self.cleaned_data.copy()
        # save message_id as external_id so RapidSMS will handle it properly
        fields['external_id'] = self.cleaned_data['message_id']
        connections = self.lookup_connections([self.cleaned_data['from_addr']])
        return {'connection': connections[0],
                'text': self.cleaned_data['content'],
                'fields': fields}

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = outgoing
import copy
import json
import logging
import requests

from rapidsms.backends.base import BackendBase


logger = logging.getLogger(__name__)


class VumiBackend(BackendBase):
    """Outgoing SMS backend for Vumi."""

    def configure(self, sendsms_url, sendsms_params=None, sendsms_user=None,
                  sendsms_pass=None, **kwargs):
        self.sendsms_url = sendsms_url
        self.sendsms_params = sendsms_params or {}
        self.sendsms_user = sendsms_user
        self.sendsms_pass = sendsms_pass

    def prepare_request(self, id_, text, identities, context):
        """Construct outbound data for requests.post."""
        kwargs = {'url': self.sendsms_url,
                  'headers': {'content-type': 'application/json'}}
        payload = copy.copy(self.sendsms_params)
        payload.update({'content': text,
                        'to_addr': identities,
                        'session_event': None,
                        'metadata': {'rapidsms_msg_id': id_}})
        if len(identities) == 1 and 'external_id' in context:
            payload['in_reply_to'] = context['external_id']
        if self.sendsms_user and self.sendsms_pass:
            kwargs['auth'] = (self.sendsms_user, self.sendsms_pass)
        kwargs['data'] = json.dumps(payload)
        return kwargs

    def send(self, id_, text, identities, context={}):
        logger.debug('Sending message: %s' % text)
        kwargs = self.prepare_request(id_, text, identities, context)
        r = requests.post(**kwargs)
        if r.status_code != requests.codes.ok:
            r.raise_for_status()

########NEW FILE########
__FILENAME__ = tests
import json

from django.test import TestCase
from django.core.urlresolvers import reverse
from django.conf.urls import patterns, url

from rapidsms.backends.vumi import views
from rapidsms.backends.vumi.outgoing import VumiBackend
from rapidsms.backends.vumi.forms import VumiForm
from rapidsms.tests.harness import RapidTest, CreateDataMixin


urlpatterns = patterns('',
    url(r"^backend/vumi/$",
        views.VumiBackendView.as_view(backend_name='vumi-backend'),
        name='vumi-backend'),
)


class VumiFormTest(TestCase):

    def setUp(self):
        self.valid_data = {
            "transport_name": "transport",
            "in_reply_to": None,
            "group": None,
            "from_addr": "127.0.0.1:38634",
            "message_type": "user_message",
            "helper_metadata": {},
            "to_addr": "0.0.0.0:8005",
            "content": "ping",
            "message_version": "20110921",
            "transport_type": "telnet",
            "timestamp": "2012-07-06 14:08:20.845715",
            "transport_metadata": {},
            "session_event": "resume",
            "message_id": "56047985ceec40da908ca064f2fd59d3"
        }

    def test_valid_form(self):
        """Form should be valid if GET keys match configuration."""
        form = VumiForm(self.valid_data, backend_name='vumi-backend')
        self.assertTrue(form.is_valid())

    def test_invalid_form(self):
        """Form is invalid if POST keys don't match configuration."""
        data = {'invalid-phone': '1112223333', 'invalid-message': 'hi there'}
        form = VumiForm(data, backend_name='vumi-backend')
        self.assertFalse(form.is_valid())

    def test_get_incoming_data(self):
        """get_incoming_data should return matching text and connection."""
        form = VumiForm(self.valid_data, backend_name='vumi-backend')
        form.is_valid()
        incoming_data = form.get_incoming_data()
        self.assertEqual(self.valid_data['content'], incoming_data['text'])
        self.assertEqual(self.valid_data['from_addr'],
                         incoming_data['connection'].identity)
        self.assertEqual('vumi-backend',
                         incoming_data['connection'].backend.name)


class VumiViewTest(RapidTest):

    urls = 'rapidsms.backends.vumi.tests'
    disable_phases = True

    def setUp(self):
        self.valid_data = {
            "transport_name": "transport",
            "in_reply_to": None,
            "group": None,
            "from_addr": "127.0.0.1:38634",
            "message_type": "user_message",
            "helper_metadata": {},
            "to_addr": "0.0.0.0:8005",
            "content": "ping",
            "message_version": "20110921",
            "transport_type": "telnet",
            "timestamp": "2012-07-06 14:08:20.845715",
            "transport_metadata": {},
            "session_event": "resume",
            "message_id": "56047985ceec40da908ca064f2fd59d3"
        }

    def test_valid_response_post(self):
        """HTTP 200 should return if data is valid."""
        response = self.client.post(reverse('vumi-backend'),
                                    json.dumps(self.valid_data),
                                    content_type='text/json')
        self.assertEqual(response.status_code, 200)

    def test_invalid_response(self):
        """HTTP 400 should return if data is invalid."""
        data = {'invalid-phone': '1112223333', 'message': 'hi there'}
        response = self.client.post(reverse('vumi-backend'), json.dumps(data),
                                    content_type='text/json')
        self.assertEqual(response.status_code, 400)

    def test_invalid_json(self):
        """HTTP 400 should return if JSON is invalid."""
        data = "{bad json, , lala}"
        response = self.client.post(reverse('vumi-backend'), data,
                                    content_type='text/json')
        self.assertEqual(response.status_code, 400)

    def test_valid_post_message(self):
        """Valid POSTs should pass message object to router."""
        self.client.post(reverse('vumi-backend'), json.dumps(self.valid_data),
                         content_type='text/json')
        message = self.inbound[0]
        self.assertEqual(self.valid_data['content'], message.text)
        self.assertEqual(self.valid_data['from_addr'],
                         message.connection.identity)
        self.assertEqual('vumi-backend',
                         message.connection.backend.name)

    def test_blank_message_is_valid(self):
        """Blank messages should be considered valid."""
        empty = self.valid_data.copy()
        empty.update({'content': ''})
        null = self.valid_data.copy()
        null.update({'content': None})
        no_content = self.valid_data.copy()
        del no_content['content']
        for blank_msg in [empty, null, no_content]:
            self.client.post(reverse('vumi-backend'), json.dumps(blank_msg),
                             content_type='text/json')
            message = self.inbound[0]
            self.assertEqual('', message.text)


class VumiSendTest(CreateDataMixin, TestCase):

    def test_required_fields(self):
        """Vumi backend requires Gateway URL and credentials."""
        self.assertRaises(TypeError, VumiBackend, None, "vumi")

    def test_outgoing_keys(self):
        """Vumi requires JSON to include to_addr and content."""
        message = self.create_outgoing_message()
        config = {"sendsms_url": "http://example.com"}
        backend = VumiBackend(None, "vumi", **config)
        kwargs = backend.prepare_request(message.id, message.text,
                                         [message.connections[0].identity], {})
        self.assertEqual(kwargs['url'], config['sendsms_url'])
        data = json.loads(kwargs['data'])
        self.assertEqual(data['to_addr'], [message.connections[0].identity])
        self.assertEqual(data['content'], message.text)

    def test_response_external_id(self):
        """Make sure external_id context is sent to Vumi."""
        message = self.create_outgoing_message()
        config = {"sendsms_url": "http://example.com"}
        backend = VumiBackend(None, "vumi", **config)
        kwargs = backend.prepare_request(message.id, message.text,
                                         [message.connections[0].identity],
                                         {'external_id': 'ASDF1234'})
        data = json.loads(kwargs['data'])
        self.assertEqual("ASDF1234", data['in_reply_to'])

    def test_bulk_response_external_id(self):
        """Only single messages should include in_response_to."""
        conn1 = self.create_connection()
        conn2 = self.create_connection()
        config = {"sendsms_url": "http://example.com"}
        backend = VumiBackend(None, "vumi", **config)
        kwargs = backend.prepare_request("1234", "foo",
                                         [conn1.identity, conn2.identity],
                                         {'external_id': 'ASDF1234'})
        data = json.loads(kwargs['data'])
        self.assertTrue('in_reply_to' not in data)

    def test_message_id_in_metadata(self):
        """Make sure our uuid is sent to Vumi."""
        message = self.create_outgoing_message()
        config = {"sendsms_url": "http://example.com"}
        backend = VumiBackend(None, "vumi", **config)
        kwargs = backend.prepare_request(message.id, message.text,
                                         [message.connections[0].identity], {})
        data = json.loads(kwargs['data'])
        self.assertIn(message.id, data.get('metadata', {}).values())

    def test_auth(self):
        """Vumi backend shold use basic authentication if given user/pass."""
        message = self.create_outgoing_message()
        config = {"sendsms_url": "http://example.com",
                  "sendsms_user": "username",
                  "sendsms_pass": "password"}
        backend = VumiBackend(None, "vumi", **config)
        kwargs = backend.prepare_request(message.id, message.text,
                                         [message.connections[0].identity], {})
        self.assertTrue('auth' in kwargs)

########NEW FILE########
__FILENAME__ = views
import json
import logging

from django.http import HttpResponse

from rapidsms.backends.vumi.forms import VumiForm
from rapidsms.backends.http.views import BaseHttpBackendView


logger = logging.getLogger(__name__)


class VumiBackendView(BaseHttpBackendView):
    """
    Backend view for handling inbound SMSes from Vumi (http://vumi.org/)
    """

    http_method_names = ['post']
    form_class = VumiForm

    def get_form_kwargs(self):
        """Load JSON POST data."""
        kwargs = super(VumiBackendView, self).get_form_kwargs()
        try:
            kwargs['data'] = json.loads(self.request.body)
        except ValueError:
            logger.exception("Failed to parse JSON from Vumi.")
        return kwargs

    def form_valid(self, form):
        super(VumiBackendView, self).form_valid(form)
        # return 200 for Vumi
        return HttpResponse('')

########NEW FILE########
__FILENAME__ = conf
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

"""
This module wraps `djappsettings`_, a helper which provides per-app
default settings for RapidSMS apps. This makes it much easier to create
reusable apps, while remaining 100% backwards-compatible with Django's
``django.conf.settings`` object. To support this, apps should include a
``settings.py`` module containing their default settings, which can be
overriden by the project author in the top-level ``settings.py``.

.. _djappsettings: http://github.com/adammck/djappsettings
"""

try:
    from djappsettings import settings
except:
    from django.conf import settings

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.conf import settings
from rapidsms.apps.base import AppBase


class App(AppBase):

    def default(self, msg):
        response = settings.DEFAULT_RESPONSE
        if response is not None:
            response = response % {'project_name': settings.PROJECT_NAME}
            msg.error(response)

########NEW FILE########
__FILENAME__ = settings
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


DEFAULT_RESPONSE = "Sorry, %(project_name)s could not understand your message."

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.tests.harness import EchoApp, RapidTest

try:
    from django.test.utils import override_settings
except ImportError:
    from rapidsms.tests.harness import setting as override_settings


class ReturningEchoApp(EchoApp):

    def handle(self, message):
        super(ReturningEchoApp, self).handle(message)
        return True  # Return so that future apps don't handle the message


class DefaultAppTest(RapidTest):
    apps = ['rapidsms.contrib.default']

    def setUp(self):
        self.connection = self.lookup_connections('1112223333')[0]

    def test_no_handle(self):
        """App should not respond to message if another has responded."""
        # Add another app & reset the test router.
        self.apps = [ReturningEchoApp, 'rapidsms.contrib.default']
        self.set_router()
        with override_settings(DEFAULT_RESPONSE='hello'):
            self.receive('ping', self.connection)
            self.assertEqual(len(self.outbound), 1)
            self.assertNotEqual(self.outbound[0].text, 'hello')

    def test_response_is_none(self):
        """App should not respond if DEFAULT_RESPONSE is None."""
        with override_settings(DEFAULT_RESPONSE=None):
            self.receive('asdf', self.connection)
            self.assertEqual(len(self.outbound), 0)

    def test_response_no_project_name(self):
        """App should respond with exact string if project_name is not used."""
        with override_settings(DEFAULT_RESPONSE='hello'):
            self.receive('asdf', self.connection)
            self.assertEqual(len(self.outbound), 1)
            self.assertEqual(self.outbound[0].text, 'hello')

    def test_response_with_project_name(self):
        """App should replace project_name in response if it is present."""
        with override_settings(DEFAULT_RESPONSE='hello %(project_name)s',
                               PROJECT_NAME='world'):
            self.receive('asdf', self.connection)
            self.assertEqual(len(self.outbound), 1)
            self.assertEqual(self.outbound[0].text, 'hello world')

########NEW FILE########
__FILENAME__ = echo
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.contrib.handlers.handlers.keyword import KeywordHandler


class EchoHandler(KeywordHandler):
    """
    Handle any message prefixed ``echo``, responding with the remainder
    of the text. Useful for remotely testing internationalization.
    """

    keyword = "echo"

    def help(self):
        self.respond("To echo some text, send: ECHO <ANYTHING>")

    def handle(self, text):
        self.respond(text)

########NEW FILE########
__FILENAME__ = ping
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.contrib.handlers.handlers.base import BaseHandler


class PingHandler(BaseHandler):
    """
    Handle the (precise) message ``ping``, by responding with ``pong``.
    Useful for remotely checking that the router is alive.
    """

    @classmethod
    def dispatch(cls, router, msg):
        if msg.text == "ping":
            return msg.respond("pong")

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.messages import IncomingMessage
from rapidsms.tests.harness import RapidTest

from rapidsms.contrib.echo.handlers.echo import EchoHandler
from rapidsms.contrib.echo.handlers.ping import PingHandler


class TestEchoHandler(RapidTest):

    def setUp(self):
        self.connection = self.create_connection()

    def _test_handle(self, text, correct_response):
        msg = IncomingMessage(self.connection, text)
        retVal = EchoHandler.dispatch(self.connection, msg)
        if correct_response is not None:
            self.assertTrue(retVal)
            self.assertEqual(len(msg.responses), 1)
            self.assertEqual(msg.responses[0]['text'], correct_response)
        else:
            self.assertFalse(retVal)
            self.assertEqual(len(msg.responses), 0)

    def test_no_match(self):
        self._test_handle('no match', None)

    def test_only_keyword(self):
        self._test_handle('echo', 'To echo some text, send: ECHO <ANYTHING>')

    def test_keyword_and_whitespace(self):
        self._test_handle('echo  ', 'To echo some text, send: ECHO <ANYTHING>')

    def test_match(self):
        self._test_handle('echo hello', 'hello')

    def test_case_insensitive_match(self):
        self._test_handle('EcHo hello', 'hello')

    def test_leading_whitespace(self):
        self._test_handle('  echo hello', 'hello')

    def test_trailing_whitespace(self):
        self._test_handle('echo hello  ', 'hello  ')

    def test_whitespace_after_keyword(self):
        self._test_handle('echo     hello', 'hello')


class TestPingHandler(RapidTest):

    def setUp(self):
        self.connection = self.create_connection()

    def _test_handle(self, text, correct_response):
        msg = IncomingMessage(self.connection, text)
        retVal = PingHandler.dispatch(self.connection, msg)
        if correct_response is not None:
            self.assertTrue(retVal)
            self.assertEqual(len(msg.responses), 1)
            self.assertEqual(msg.responses[0]['text'], correct_response)
        else:
            self.assertFalse(retVal)
            self.assertEqual(len(msg.responses), 0)

    def test_no_match(self):
        self._test_handle('no match', None)

    def test_match(self):
        self._test_handle('ping', 'pong')

    def test_leading_whitespace(self):
        self._test_handle('   ping', None)

    def test_trailing_whitespace(self):
        self._test_handle('ping   ', None)

    def test_case_sensitivity(self):
        self._test_handle('PiNg', None)

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4
import logging

from rapidsms.apps.base import AppBase
from .utils import get_handlers


logger = logging.getLogger(__name__)


class App(AppBase):

    def __init__(self, *args, **kwargs):
        """
        Spiders all apps, and registers all available handlers.
        """
        super(App, self).__init__(*args, **kwargs)
        self.handlers = get_handlers()
        if len(self.handlers):
            class_names = [cls.__name__ for cls in self.handlers]
            logger.info("Registered: %s" % (", ".join(class_names)))

    def handle(self, msg):
        """
        Forwards the *msg* to every handler, and short-circuits the
        phase if any of them accept it. The first to accept it will
        block the others, and there's deliberately no way to predict
        the order that they're called in. (This is intended to force
        handlers to be as reluctant as possible.)
        """
        for handler in self.handlers:
            if handler.dispatch(self.router, msg):
                logger.info("Incoming message handled by %s" % handler.__name__)
                return True

########NEW FILE########
__FILENAME__ = exceptions
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


class HandlerError(Exception):
    pass

########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.log.mixin import LoggerMixin


class BaseHandler(object, LoggerMixin):

    def _logger_name(self):
        app_label = self.__module__.split(".")[-3]
        return "app/%s/%s" % (app_label, self.__class__.__name__)

    @classmethod
    def dispatch(cls, router, msg):
        return False

    def __init__(self, router, msg):
        self.router = router
        self.msg = msg

    def respond(self, text, **kwargs):
        return self.msg.respond(text, **kwargs)

    def respond_error(self, text, **kwargs):
        return self.msg.error(text, **kwargs)

    @classmethod
    def test(cls, text, identity=None):
        """
        Test this handler by dispatching an IncomingMessage containing
        ``text``, as sent by ``identity`` via a mock backend. Return a
        list containing the ``text`` property of each response, in the
        order which they were sent.::

            >>> class AlwaysHandler(BaseHandler):
            ...
            ...     @classmethod
            ...     def dispatch(cls, router, msg):
            ...         msg.respond("xxx")
            ...         msg.respond("yyy")
            ...         return True

            >>> AlwaysHandler.test('anything')
            ['xxx', 'yyy']

        Return False if the handler ignored the message (ie, the
        ``dispatch`` method returned False or None).

            >>> class NeverHandler(BaseHandler):
            ...     pass

            >>> NeverHandler.test('anything')
            False

        This is intended to test the handler in complete isolation. To
        test the interaction between multiple apps and/or handlers, see
        the rapidsms.tests.scripted module.
        """

        # avoid setting the default identity to "mock" in the signature,
        # to avoid exposing it in the public API. it's not important.
        if identity is None:
            identity = "mock"

        # models can't be loaded until the django ORM is ready.
        from rapidsms.models import Backend, Connection
        from rapidsms.messages import IncomingMessage

        # spawn a mock backend for each handler, to allow multiple tests
        # to interact with one another without overlapping.
        if not hasattr(cls, "_mock_backend"):
            cls._mock_backend = Backend.objects.create(
                name="mock_%d" % id(cls))

        conn, created = Connection.objects.get_or_create(
            backend=cls._mock_backend,
            identity=identity)

        msg = IncomingMessage(
            connection=conn,
            text=text)

        accepted = cls.dispatch(None, msg)
        return [m['text'] for m in msg.responses]\
            if accepted else False

########NEW FILE########
__FILENAME__ = keyword
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


import re

from django.core.exceptions import ObjectDoesNotExist

from ..exceptions import HandlerError
from .base import BaseHandler


class KeywordHandler(BaseHandler):
    """
    This handler type can be subclassed to create simple keyword-based
    handlers. When a message is received, it is checked against the mandatory
    ``keyword`` attribute (a regular expression) for a prefix match. For
    example::

        >>> class AbcHandler(KeywordHandler):
        ...    keyword = "abc"
        ...
        ...    def help(self):
        ...        self.respond("Here is some help.")
        ...
        ...    def handle(self, text):
        ...        self.respond("You said: %s." % text)

    If the keyword is matched and followed by some text, the ``handle`` method
    is called::

        >>> AbcHandler.test("abc waffles")
        ['You said: waffles.']

    If *just* the keyword is matched, the ``help`` method is called::

        >>> AbcHandler.test("abc")
        ['Here is some help.']

    All other messages are silently ignored (as usual), to allow other apps or
    handlers to catch them.
    """

    #: A string specifying a regular expression matched against the
    #: beginning of the message. Not case sensitive.
    keyword = None

    def help(self):
        """Called when the keyword matches but no text follows"""
        raise NotImplementedError

    def handle(self, text):
        """Called when the keyword matches and text follows

        :param text: The text that follows the keyword.  Any whitespace
             between the keyword and the text is not included.
        """
        raise NotImplementedError

    @classmethod
    def _keyword(cls):
        if hasattr(cls, "keyword") and cls.keyword:
            # The 'keyword' is inside non-grouping parentheses so that a
            # user could set the keyword to a regex - e.g.
            # keyword = r'one|two|three'
            prefix = r"""
                ^\s*             # discard leading whitespace
                (?:{keyword})    # require the keyword or regex
                [\s,;:]*         # consume any whitespace , ; or :
                ([^\s,;:].*)?    # capture rest of line if any, starting
                                 # with the first non-whitespace
                $                # match all the way to the end
            """.format(keyword=cls.keyword)

            return re.compile(prefix, re.IGNORECASE|re.VERBOSE)
        raise HandlerError('KeywordHandler must define a keyword.')

    @classmethod
    def dispatch(cls, router, msg):
        keyword = cls._keyword()

        match = keyword.match(msg.text)
        if match is None:
            return False

        # spawn an instance of this handler, and stash
        # the low(er)-level router and message object
        inst = cls(router, msg)

        # if any non-whitespace content was send after the keyword, send
        # it along to the handle method. the instance can always find
        # the original text via self.msg if it really needs it.
        text = match.group(1)
        if text is not None and text.strip() != "":
            try:
                inst.handle(text)

            # special case: if an object was expected but not found,
            # return the (rather appropriate) "%s matching query does
            # not exist." message. this can, of course, be overridden by
            # catching the exception within the ``handle`` method.
            except ObjectDoesNotExist, err:
                return inst.respond_error(
                    unicode(err))

            # another special case: if something was miscast to an int
            # (it was probably a string from the ``text``), return a
            # more friendly (and internationalizable) error.
            except ValueError, err:
                p = r"^invalid literal for int\(\) with base (\d+?): '(.+?)'$"
                m = re.match(p, unicode(err))

                # allow other valueerrors to propagate.
                if m is None:
                    raise

                return inst.respond_error(
                    "Not a valid number: %(string)s" % dict(
                    string=m.group(2)))

        # if we received _just_ the keyword, with
        # no content, some help should be sent back
        else:
            inst.help()

        return True

########NEW FILE########
__FILENAME__ = pattern
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import re

from ..exceptions import HandlerError
from .base import BaseHandler


class PatternHandler(BaseHandler):

    """
    This handler type can be subclassed to create simple pattern-based
    handlers. This isn't usually a good idea -- it's cumbersome to write
    patterns with enough flexibility to be used in the real world -- but
    it's very handy for prototyping, and can easily be upgraded later.

    When a message is received, it is matched against the mandatory
    ``pattern`` attribute (a regular expression). If the pattern is
    matched, the ``handle`` method is called with the captures as
    arguments. For example::

        >>> class SumHandler(PatternHandler):
        ...    pattern = r'^(\d+) plus (\d+)$'
        ...
        ...    def handle(self, a, b):
        ...        a, b = int(a), int(b)
        ...        total = a + b
        ...
        ...        self.respond(
        ...            "%d+%d = %d" %
        ...            (a, b, total))

        >>> SumHandler.test("1 plus 2")
        ['1+2 = 3']

    Note that the pattern must be matched *precisely* (excepting case
    sensitivity). For example, this would not work because of the trailing
    whitespace::

        >>> SumHandler.test("1 plus 2 ")
        False

    All non-matching messages are silently ignored, to allow other apps or
    handlers to catch them.
    """

    #: A string specifying a regular expression that should match the message.
    #: Not case sensitive.
    pattern = None

    def handle(self, *args):
        """Called when the message matches the pattern. Any matching groups
        are passed to it.

        :param args: The matching groups from the regular expression.
        """
        raise NotImplementedError

    @classmethod
    def _pattern(cls):
        if hasattr(cls, "pattern") and cls.pattern:
            return re.compile(cls.pattern, re.IGNORECASE)
        raise HandlerError('PatternHandler must define a pattern.')

    @classmethod
    def dispatch(cls, router, msg):
        pattern = cls._pattern()

        match = pattern.match(msg.text)
        if match is None:
            return False

        cls(router, msg).handle(*match.groups())
        return True

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = settings
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


INSTALLED_HANDLERS = None

EXCLUDED_HANDLERS = []

RAPIDSMS_HANDLERS_EXCLUDE_APPS = []

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.contrib.echo.handlers.echo import EchoHandler
from rapidsms.contrib.echo.handlers.ping import PingHandler
from rapidsms.contrib.handlers.app import App as HandlersApp
from rapidsms.contrib.handlers.tests.harness import EchoKeywordHandler
from rapidsms.messages import IncomingMessage
from rapidsms.tests.harness import RapidTest

try:
    from django.test.utils import override_settings
except ImportError:
    from rapidsms.tests.harness import setting as override_settings


__all__ = ['TestHandlersApp']


class TestHandlersApp(RapidTest):

    def setUp(self):
        self.connection = self.create_connection()

    def test_init(self):
        """App should load handlers upon initialization."""
        settings = {
            'INSTALLED_APPS': ['rapidsms.contrib.echo'],  # Defines 2 handlers.
        }
        with override_settings(**settings):
            app = HandlersApp(self.router)
            self.assertEqual(len(app.handlers), 2)
            self.assertTrue(EchoHandler in app.handlers)
            self.assertTrue(PingHandler in app.handlers)

    def test_handle(self):
        """App should call upon its handlers to respond to the message."""
        app = HandlersApp(self.router)
        app.handlers = [EchoKeywordHandler]
        msg = IncomingMessage(self.connection, 'hello world')
        retVal = app.handle(msg)
        self.assertTrue(retVal)
        self.assertEqual(len(msg.responses), 1)
        self.assertEqual(msg.responses[0]['text'], 'world')

    def test_no_handlers(self):
        """If app has no (relevant) handlers, it should return nothing."""
        app = HandlersApp(self.router)
        app.handlers = []
        msg = IncomingMessage(self.connection, 'hello world')
        retVal = app.handle(msg)
        self.assertEqual(retVal, None)
        self.assertEqual(len(msg.responses), 0)

########NEW FILE########
__FILENAME__ = handlers
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.messages import IncomingMessage
from rapidsms.tests.harness import RapidTest

from rapidsms.contrib.handlers import BaseHandler
from rapidsms.contrib.handlers.exceptions import HandlerError
from rapidsms.contrib.handlers.tests.harness import EchoKeywordHandler
from rapidsms.contrib.handlers.tests.harness import AdditionPatternHandler


__all__ = ['TestBaseHandler', 'TestKeywordHandler', 'TestPatternHandler']


class TestBaseHandler(RapidTest):
    """Tests for rapidsms.contrib.handlers.handlers.base"""

    def setUp(self):
        self.connection = self.create_connection()

    def test_dispatch(self):
        """BaseHandler dispatch should always return False."""
        msg = IncomingMessage(self.connection, 'hello')
        retVal = BaseHandler.dispatch(self.router, msg)
        self.assertFalse(retVal)
        self.assertEqual(len(msg.responses), 0)


class TestKeywordHandler(RapidTest):
    """Tests for rapidsms.contrib.handlers.handlers.keyword"""

    def setUp(self):
        self.connection = self.create_connection()

    def _check_dispatch(self, text, correct_response):
        msg = IncomingMessage(self.connection, text)
        retVal = EchoKeywordHandler.dispatch(self.router, msg)
        if correct_response is not None:
            self.assertTrue(retVal)
            self.assertEqual(len(msg.responses), 1)
            self.assertEqual(msg.responses[0]['text'], correct_response)
        else:
            self.assertFalse(retVal)
            self.assertEqual(len(msg.responses), 0)

    def test_no_keyword(self):
        """Handler should raise an exception if there is no keyword."""
        keyword = getattr(EchoKeywordHandler, 'keyword')
        delattr(EchoKeywordHandler, 'keyword')
        try:
            with self.assertRaises(HandlerError):
                msg = IncomingMessage(self.connection, 'hello')
                EchoKeywordHandler.dispatch(self.router, msg)
        finally:
            setattr(EchoKeywordHandler, 'keyword', keyword)

    def test_no_match(self):
        """Handler should return nothing if there is no match."""
        self._check_dispatch('no match', None)

    def test_keyword_only(self):
        """Handler should call help() if only keyword is sent."""
        self._check_dispatch('hello', EchoKeywordHandler.HELP_TEXT)

    def test_keyword_and_whitespace(self):
        """Handler should call help() if only whitespace is after keyword."""
        self._check_dispatch('hello      ', EchoKeywordHandler.HELP_TEXT)

    def test_keyword_and_one_space(self):
        """Handler should call help() if only one space is after keyword."""
        self._check_dispatch('hello ', EchoKeywordHandler.HELP_TEXT)

    def test_punctuation(self):
        """Handler treats comma colon and semicolon same as whitespace
         between keyword and rest of line"""
        self._check_dispatch('hello,', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello,,', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello,world', 'world')
        self._check_dispatch('hello:', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello::', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello:world', 'world')
        self._check_dispatch('hello;', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello;;', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello;world', 'world')
        self._check_dispatch('hello,;:', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello,;,;:', EchoKeywordHandler.HELP_TEXT)
        self._check_dispatch('hello;,:,:world', 'world')

    def test_match(self):
        """
        Handler should call handle() if there is non-whitespace text after
        keyword.
        """
        self._check_dispatch('hello world', 'world')

    def test_case_insensitive_match(self):
        """Handler should use case-insensitive match."""
        self._check_dispatch('HeLlO World', 'World')

    def test_intermediate_whitespace(self):
        """All whitespace between keyword and text is ignored"""
        self._check_dispatch('hello            world', 'world')

    def test_trailing_whitespace(self):
        """Trailing whitespace should be passed to handler."""
        self._check_dispatch('hello world     ', 'world     ')

    def test_leading_whitespace(self):
        """Prepended whitespace should not be passed to the handler."""
        self._check_dispatch('    hello world', 'world')

    def test_rest_of_line(self):
        """Everything from the first char that's not space comma colon
        or semicolon is passed to the handler"""
        self._check_dispatch('hello x , : ; sdf    ,:   ',
                             'x , : ; sdf    ,:   ')


class TestPatternHandler(RapidTest):
    """Tests for rapidsms.contrib.handlers.handlers.pattern"""

    def setUp(self):
        self.connection = self.create_connection()

    def _check_dispatch(self, text, correct_response):
        msg = IncomingMessage(self.connection, text)
        retVal = AdditionPatternHandler.dispatch(self.router, msg)
        if correct_response is not None:
            self.assertTrue(retVal)
            self.assertEqual(len(msg.responses), 1)
            self.assertEqual(msg.responses[0]['text'], correct_response)
        else:
            self.assertFalse(retVal)
            self.assertEqual(len(msg.responses), 0)

    def test_no_pattern(self):
        """Handler should not operate if it does not have a pattern."""
        pattern = getattr(AdditionPatternHandler, 'pattern')
        delattr(AdditionPatternHandler, 'pattern')
        try:
            with self.assertRaises(HandlerError):
                msg = IncomingMessage(self.connection, '1 plus 2')
                AdditionPatternHandler.dispatch(self.router, msg)
        finally:
            setattr(AdditionPatternHandler, 'pattern', pattern)

    def test_no_match(self):
        """Handler should return False if there is no match."""
        self._check_dispatch('no match', None)

    def test_match(self):
        """Handler should return response if there is a match."""
        self._check_dispatch('1 plus 2', '1 + 2 = 3')

    def test_case_insensitive_match(self):
        """Handler pattern is not case sensitive."""
        self._check_dispatch('1 PLUS 2', '1 + 2 = 3')

    def test_leading_whitespace(self):
        """Handler pattern is sensitive to leading whitespace."""
        self._check_dispatch('  1 plus 2', None)

    def test_trailing_whitespace(self):
        """Handler pattern is sensitive to trailing whitespace."""
        self._check_dispatch('1 plus 2  ', None)

    def test_extra_whitespace(self):
        """Handler pattern is sensitive to extra whitespace."""
        self._check_dispatch('1    plus 2', None)

########NEW FILE########
__FILENAME__ = harness
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.contrib.handlers import KeywordHandler, PatternHandler


class EchoKeywordHandler(KeywordHandler):
    """A simple keyword handler for testing that echos the text it receives."""
    keyword = 'hello'
    HELP_TEXT = 'helpful text'

    def help(self):
        self.respond(self.HELP_TEXT)

    def handle(self, text):
        self.respond(text)


class AdditionPatternHandler(PatternHandler):
    """A simple pattern handler for testing that adds the values it receives."""
    pattern = r'^(\d+) plus (\d+)$'

    def handle(self, a, b):
        a, b = int(a), int(b)
        total = a + b
        self.respond('%d + %d = %d' % (a, b, total))

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.test import TestCase
from django.test.utils import override_settings

from rapidsms.contrib.echo.handlers.echo import EchoHandler
from rapidsms.contrib.echo.handlers.ping import PingHandler
from rapidsms.contrib.handlers.utils import get_handlers

import mock


__all__ = ['TestGetHandlers']


class TestGetHandlers(TestCase):
    DEFAULT_APP = 'rapidsms.contrib.default'  # Defines no handlers
    ECHO_APP = 'rapidsms.contrib.echo'  # Defines exactly 2 handlers
    ECHO_HANDLER = 'rapidsms.contrib.echo.handlers.echo'
    PING_HANDLER = 'rapidsms.contrib.echo.handlers.ping'
    ECHO_HANDLER_CLASS = 'rapidsms.contrib.echo.handlers.echo.EchoHandler'
    PING_HANDLER_CLASS = 'rapidsms.contrib.echo.handlers.ping.PingHandler'

    def setUp(self):
        # Used with override_settings, so that we test in a predictable
        # environment.
        self.settings = {
            'INSTALLED_APPS': [],
            'INSTALLED_HANDLERS': None,
            'EXCLUDED_HANDLERS': [],
            'RAPIDSMS_HANDLERS_EXCLUDE_APPS': [],
        }

    def _check_get_handlers(self, *args):
        with override_settings(**self.settings):
            with mock.patch('rapidsms.contrib.handlers.utils.warn') as warn:
                handlers = get_handlers()
        self.assertEqual(set(handlers), set(args))
        # If RAPIDSMS_HANDLERS is not defined, a deprecation warning is issued
        self.assertEqual(warn.called, 'RAPIDSMS_HANDLERS' not in self.settings)

    def test_no_installed_apps(self):
        """App should not load any handlers if there are no installed apps."""
        self._check_get_handlers()

    def test_no_relevant_installed_apps(self):
        """App should not load any handlers if no app contains handlers."""
        self.settings['INSTALLED_APPS'] = [self.DEFAULT_APP]
        self._check_get_handlers()

    def test_installed_apps(self):
        """App should load handlers from any app in INSTALLED_APPS."""
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self._check_get_handlers(EchoHandler, PingHandler)

    def test_installed_handler__installed_apps(self):
        """
        App should only include handlers listed in INSTALLED_HANDLERS, if it
        is defined.
        """
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self.settings['INSTALLED_HANDLERS'] = [self.PING_HANDLER]
        self._check_get_handlers(PingHandler)

    def test_installed_handlers__installed_apps(self):
        """
        App should only include handlers listedin INSTALLED_HANDLERS, if it
        is defined.
        """
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self.settings['INSTALLED_HANDLERS'] = [self.PING_HANDLER,
                                               self.ECHO_HANDLER]
        self._check_get_handlers(PingHandler, EchoHandler)

    def test_installed_handlers__no_installed_apps(self):
        """App should handle when an INSTALLED_HANDLER can't be found."""
        self.settings['INSTALLED_HANDLERS'] = [self.PING_HANDLER]
        self._check_get_handlers()

    def test_installed_app(self):
        """App should use prefix matching to determine handlers to include."""
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self.settings['INSTALLED_HANDLERS'] = [self.ECHO_APP]
        self._check_get_handlers(EchoHandler, PingHandler)

    def test_exclude_handlers__installed_apps(self):
        """App should exclude handlers listed in EXCLUDED_HANDLERS."""
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self.settings['EXCLUDED_HANDLERS'] = [self.PING_HANDLER]
        self._check_get_handlers(EchoHandler)

    def test_exclude_handlers__no_installed_apps(self):
        """App should handle when an EXCLUDED_HANDLER can't be found."""
        self.settings['EXCLUDED_HANDLERS'] = [self.PING_HANDLER]
        self._check_get_handlers()

    def test_exclude_app(self):
        """App should use prefix matching to determine handlers to exclude."""
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self.settings['EXCLUDED_HANDLERS'] = [self.ECHO_APP]
        self._check_get_handlers()

    def test_empty_rapidsms_handlers(self):
        # If RAPIDSMS_HANDLERS is empty, no handlers are loaded.
        self.settings['INSTALLED_APPS'] = [self.ECHO_APP]
        self.settings['INSTALLED_HANDLERS'] = [self.ECHO_APP]
        self.settings['RAPIDSMS_HANDLERS'] = []
        self._check_get_handlers()

    def test_rapidsms_handlers(self):
        # If RAPIDSMS_HANDLERS is set, it completely controls which handlers
        # are loaded.
        self.settings['INSTALLED_APPS'] = [self.DEFAULT_APP]
        self.settings['INSTALLED_HANDLERS'] = []
        self.settings['EXCLUDED_HANDLERS'] = [self.PING_HANDLER]
        self.settings['RAPIDSMS_HANDLERS'] = [
            self.ECHO_HANDLER_CLASS,
            self.PING_HANDLER_CLASS
        ]
        self._check_get_handlers(EchoHandler, PingHandler)

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from warnings import warn

from rapidsms.conf import settings
from rapidsms.utils.modules import (find_python_files, get_class,
                                    import_class, try_import)

from .exceptions import HandlerError
from .handlers.base import BaseHandler


def get_handlers():
    """
    Return a list of the handler classes to use in the current project.
    This is the classes whose names are listed in the RAPIDSMS_HANDLERS
    setting, but if that's not set, then we fall back to the deprecated
    behavior of returning all installed handlers, possibly modified by
    the INSTALLED_HANDLERS and/or EXCLUDED_HANDLERS settings.
    """

    if hasattr(settings, 'RAPIDSMS_HANDLERS'):
        return [import_class(name) for name in settings.RAPIDSMS_HANDLERS]

    warn("Please set RAPIDSMS_HANDLERS to the handlers that should "
         "be installed. The old behavior of installing all defined "
         "handlers, possibly modified by INSTALLED_HANDLERS and/or "
         "EXCLUDED_HANDLERS, is deprecated and will be removed",
         DeprecationWarning)

    handlers = _find_handlers(_apps())

    # if we're explicitly selecting handlers, filter out all those which
    # are not matched by one (or more) prefixes in INSTALLED_HANDLERS.
    if hasattr(settings, 'INSTALLED_HANDLERS') and \
            settings.INSTALLED_HANDLERS is not None:
        copy = [handler for handler in handlers]
        handlers = []
        while len(copy) > 0:
            for prefix in settings.INSTALLED_HANDLERS:
                if copy[-1].__module__.startswith(prefix):
                    handlers.append(copy[-1])
                    break
            copy.pop()

    # likewise, in reverse, for EXCLUDED_HANDLERS.
    if hasattr(settings, 'EXCLUDED_HANDLERS') and \
            settings.EXCLUDED_HANDLERS is not None:
        for prefix in settings.EXCLUDED_HANDLERS:
            handlers = [
                handler for handler in handlers
                if not handler.__module__.startswith(prefix)]

    return handlers


def _find_handlers(app_names):
    """
    Return a list of all handlers defined in ``app_names``.
    """

    handlers = []

    for module_name in app_names:
        handlers.extend(_handlers(module_name))

    return handlers


def _apps():
    """
    Return a list of the apps which may contain handlers. This is not
    quite as simple as returning ``settings.INSTALLED_APPS``, since:

    1. This app (rapidsms.contrib.handlers) should be excluded, because
       although it contains handlers, they are intended to be abstract,
       not instantiated directly. (I think this is cleaner than marking
       them explicitly.)

    2. Django contrib apps should be excluded, because the "auth" app
       has an unrelated "handlers" module. (If I'd noticed that when I
       created this app, I may have named it differently. Sorry.)

    3. If any other app defines a "handlers" module, it can be added
       to settings.RAPIDSMS_HANDLERS_EXCLUDE_APPS to not be loaded
    """

    def _in_exclusions(module_name):
        settings_exclusions = getattr(settings,
                                      "RAPIDSMS_HANDLERS_EXCLUDE_APPS", [])
        return module_name == "rapidsms.contrib.handlers" \
            or module_name.startswith("django.contrib.") \
            or module_name in settings_exclusions

    return [
        module_name
        for module_name in settings.INSTALLED_APPS
        if not _in_exclusions(module_name)]


def _handlers(module_name):
    """
    Return a list of handlers (subclasses of app.handlers.HandlerBase)
    defined in the ``handlers`` directory of ``module_name``. Each
    Python file is expected to contain a single new-style class, which
    can be named arbitrarily. (But probably shouldn't be.)

    Return an empty list if no handlers are defined, or the directory
    can't be opened. All exceptions raised while importing handlers are
    allowed to propagate, to avoid masking errors.
    """

    handlers_module = try_import(
        "%s.handlers" % module_name)

    if handlers_module is None:
        return []

    if not hasattr(handlers_module, "__path__"):
        raise HandlerError(
            "Module %s must be a directory." % (handlers_module.__name__))

    files = find_python_files(
        handlers_module.__path__[0])

    module_names = [
        "%s.%s" % (handlers_module.__name__, file)
        for file in files]

    modules = [
        try_import(mod_name)
        for mod_name in module_names]

    return [
        get_class(mod, BaseHandler)
        for mod in filter(None, modules)]

########NEW FILE########
__FILENAME__ = forms
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django import forms


# the built-in FileField doesn't specify the 'size' attribute, so the
# widget is rendered at its default width -- which is too wide for our
# form. this is a little hack to shrink the field.
from django.core.exceptions import ValidationError


class SmallFileField(forms.FileField):
    def widget_attrs(self, widget):
        return {"size": 10}


class MessageForm(forms.Form):
    identity = forms.CharField(
        label="Phone Number",
        max_length=100,
        help_text="The phone number which this message " +
                  "will appear to have originated from.")

    text = forms.CharField(
        label="Single Message",
        required=False,
        widget=forms.widgets.Textarea({
            "cols": 30,
            "rows": 4}))

    bulk = SmallFileField(
        label="Multiple Messages",
        required=False,
        help_text="Alternatively, upload a <em>plain text file</em> " +
                  "containing a single message per line.")

    def clean_identity(self):
        if 'identity' in self.cleaned_data:
            identity = self.cleaned_data['identity'].strip()
            if not identity.isnumeric():
                raise ValidationError("Phone number must be all numeric")
            return identity

########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

########NEW FILE########
__FILENAME__ = storage
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

""" Store and get messages from cache """

from rapidsms.backends.database.models import INCOMING, BackendMessage
from rapidsms.router import receive, lookup_connections


BACKEND_NAME = 'message_tester'


def get_messages():
    """Return a queryset with the message data"""
    return BackendMessage.objects.filter(name=BACKEND_NAME)


def store_message(direction, identity, text):
    """

    :param direction: "in" or "out" depending on whether the message
       was sent to (into) RapidSMS, or out of RapidSMS.
    :param identity: Phone number the message was sent from (in)
       or to (out)
    :param text: The message
    """
    BackendMessage.objects.create(direction=direction, identity=identity,
                                  text=text, name=BACKEND_NAME)


def store_and_queue(identity, text):
    """Store a message in our log and send it into RapidSMS.

    :param identity: Phone number the message will appear to come from
    :param text: The message text
    """
    store_message(INCOMING, identity, text)
    connection = lookup_connections(BACKEND_NAME, [identity])[0]
    receive(text, connection)


def clear_messages(identity):
    """Forget messages to/from this identity

    :param identity: The phone number whose messages will be cleared
    """
    BackendMessage.objects.filter(identity=identity,
                                  name=BACKEND_NAME).delete()


def clear_all_messages():
    """Forget all messages"""
    BackendMessage.objects.filter(name=BACKEND_NAME).delete()

########NEW FILE########
__FILENAME__ = tables
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.utils.safestring import mark_safe

import django_tables2 as tables

from rapidsms.backends.database.models import INCOMING, BackendMessage


class MessageTable(tables.Table):

    def render_identity(self, record):
        # Render the phone number with a double arrow pointing to it
        # or away from it, depending on whether the message was going
        # out or coming in.
        if record.direction == INCOMING:
            return mark_safe(record.identity + "&raquo;")
        else:
            return mark_safe(record.identity + "&laquo;")

    class Meta:
        model = BackendMessage
        sequence = ('date', 'identity', 'text')
        exclude = ('id', 'direction', 'name', 'message_id', 'external_id')
        order_by = ('-date', )
        attrs = {
            'id': 'log',
            'class': 'table table-striped table-bordered table-condensed'
        }

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4
from StringIO import StringIO
from django.core.urlresolvers import reverse
from django.utils import unittest as ut2
from mock import patch

from rapidsms.backends.database.models import INCOMING
from rapidsms.contrib.httptester.forms import MessageForm
from rapidsms.tests.harness import RapidTest
from .storage import store_and_queue, store_message, get_messages, \
    clear_messages, clear_all_messages


class StorageTest(RapidTest):

    disable_phases = True

    def test_store_and_queue(self):
        """store_and_queue should use receive() API correctly"""
        store_and_queue("1112223333", "hi there!")
        self.assertEqual(self.inbound[0].text, "hi there!")

    def test_store_and_get(self):
        """If we store something, we can get it again"""
        direction, identity, text = u"I", u"identity", u"text"
        store_message(direction, identity, text)
        msgs = get_messages()
        msg = msgs[0]
        self.assertEqual(identity, msg.identity)
        self.assertEqual(direction, msg.direction)
        self.assertEqual(text, msg.text)

    def test_clear(self):
        """We can clear messages for a given identity"""
        direction, identity, text = u"I", u"identity1", u"text"
        store_message(direction, identity, text)
        direction, identity, text = u"I", u"identity2", u"text"
        store_message(direction, identity, text)
        direction, identity, text = u"I", u"identity3", u"text"
        store_message(direction, identity, text)
        clear_messages(u"identity2")
        msgs = get_messages()
        for msg in msgs:
            self.assertNotEqual(u"identity2", msg.identity)

    def test_clear_all(self):
        """We can clear all messages"""
        direction, identity, text = u"I", u"identity1", u"text"
        store_message(direction, identity, text)
        direction, identity, text = u"I", u"identity2", u"text"
        store_message(direction, identity, text)
        direction, identity, text = u"I", u"identity3", u"text"
        store_message(direction, identity, text)
        clear_all_messages()
        self.assertEqual(0, len(get_messages()))


class ViewTest(RapidTest):
    disable_phases = True
    phone = "12345"
    url = reverse('httptester', kwargs={'identity': phone})

    def test_send_through_form(self):
        # Submitting a message to the form adds it to storage
        phone2 = "67890"
        message = "RapidSMS FTW"

        self.login()
        rsp = self.client.get(self.url)
        self.assertEqual(200, rsp.status_code)
        data = {
            'identity': phone2,
            'text': message,
        }
        self.client.post(self.url, data)
        self.assertEqual(200, rsp.status_code)
        msg = get_messages()[0]
        self.assertEqual(phone2, msg.identity)
        self.assertEqual(INCOMING, msg.direction)
        self.assertEqual(message, msg.text)

    def test_bulk(self):
        messages = ["message 1", "message 2", "message 3"]
        file_content = "\n".join(messages) + "\n"
        fake_file = StringIO(file_content)
        setattr(fake_file, 'name', 'fake_file')
        data = {
            'identity': self.phone,
            'bulk': fake_file,
        }
        self.login()
        rsp = self.client.post(self.url, data)
        self.assertRedirects(rsp, self.url)
        self.assertEqual(302, rsp.status_code)
        self.assertEqual(3, len(get_messages()))
        for i, m in enumerate(messages):
            self.assertEqual(m, get_messages()[i].text)

    @patch('rapidsms.contrib.httptester.storage.clear_messages')
    def test_clear_identity_messages(self, clear_messages):
        # Selecting the 'clear' button calls clear_messages for that phone #
        data = {
            'identity': self.phone,
            'clear-btn': True,
        }
        self.login()
        rsp = self.client.post(self.url, data)
        self.assertEqual(302, rsp.status_code)
        self.assertTrue(clear_messages.called)
        self.assertEqual(self.phone, clear_messages.call_args[0][0])

    @patch('rapidsms.contrib.httptester.storage.clear_all_messages')
    def test_clear_all_identity_messages(self, clear_all_messages):
        # Selecting the 'clear all' button calls clear_all_messages
        data = {
            'identity': self.phone,
            'clear-all-btn': True,
        }
        self.login()
        rsp = self.client.post(self.url, data)
        self.assertEqual(302, rsp.status_code, msg=rsp.content)
        self.assertTrue(clear_all_messages.called, msg=rsp.content)

    @patch('rapidsms.contrib.httptester.views.randint')
    def test_generate_identity(self, randint):
        randint.return_value = self.phone
        url = reverse('httptester-index')
        self.login()
        rsp = self.client.get(url)
        new_url = reverse('httptester',
                          kwargs={'identity': self.phone})
        self.assertRedirects(rsp, new_url)


class FormTest(ut2.TestCase):
    def test_clean_identity(self):
        # The form strips whitespace from the phone number, and does not
        # accept non-numeric input
        form = MessageForm({'identity': ' 123 '})
        self.assertTrue(form.is_valid(), msg=form.errors)
        self.assertEqual('123', form.cleaned_data['identity'])
        form = MessageForm({'identity': ' 1a23 '})
        self.assertFalse(form.is_valid())

########NEW FILE########
__FILENAME__ = urls
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.conf.urls import patterns, url
from . import views


urlpatterns = patterns('',
    url(r"^$", views.generate_identity, name='httptester-index'),
    url(r"^(?P<identity>\d+)/$", views.message_tester, name='httptester')
)

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from random import randint
from django.contrib import messages

from django.contrib.auth.decorators import login_required
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.shortcuts import render, redirect

from django_tables2 import RequestConfig

from rapidsms import settings
from . import forms
from . import storage
from .tables import MessageTable


@login_required
def generate_identity(request):
    """Simple view to generate a random identity.

    Just generates a random phone number and redirects to the
    message_tester view.

    :param request: HTTP request
    :return: An HTTPResponse
    """
    return redirect("httptester", randint(111111, 999999))


@login_required
def message_tester(request, identity):
    """The main Message Tester view.

    GET: will display the form, with the default phone number filled
    in from `identity`.

    POST: will process the form and handle it. In this case the identity
    passed to the view is ignored; the identity in the form is used to
    send any messages.

    :param request: HTTP request
    :param identity: Phone number the message will be sent from
    :return: An HTTPResponse
    """
    if request.method == "POST":
        form = forms.MessageForm(request.POST)
        if form.is_valid():
            cd = form.cleaned_data
            identity = cd["identity"]
            if 'clear-all-btn' in request.POST:
                storage.clear_all_messages()
                messages.add_message(request, messages.INFO, "Cleared all messages")
            elif 'clear-btn' in request.POST:
                storage.clear_messages(identity)
                messages.add_message(request, messages.INFO, "Cleared %s messages" % identity)
            else:
                if "bulk" in request.FILES:
                    for line in request.FILES["bulk"]:
                        line = line.rstrip("\n")
                        storage.store_and_queue(identity, line)
                    messages.add_message(request, messages.INFO, "Sent bulk messages")
                # no bulk file was submitted, so use the "single message"
                # field. this may be empty, which is fine, since contactcs
                # can (and will) submit empty sms, too.
                else:
                    storage.store_and_queue(identity, cd["text"])
                    messages.add_message(request, messages.INFO, "Sent message")
            url = reverse(message_tester, args=[identity])
            return HttpResponseRedirect(url)

    else:
        form = forms.MessageForm({"identity": identity})

    messages_table = MessageTable(storage.get_messages(),
                                  template="httptester/table.html")
    RequestConfig(request,
                  paginate={"per_page": settings.PAGINATOR_OBJECTS_PER_PAGE})\
        .configure(messages_table)

    context = {
        "router_available": True,
        "message_form": form,
        'messages_table': messages_table,
    }
    return render(request, "httptester/index.html", context)

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


import re
import logging
from rapidsms.apps.base import AppBase
from .models import *


logger = logging.getLogger(__name__)


class App(AppBase):
    PATTERN = re.compile(r"^(.+)\b(?:at)\b(.+?)$")

    def __find_location(self, text):
        try:
            # check for a location code first
            return Location.objects.get(slug__iexact=text)

        # nothing else is supported, for now!
        except Location.DoesNotExist:
            return None

    def parse(self, msg):

        # if this message ends in "at SOMEWHERE",
        # we have work to do. otherwise, ignore it
        m = self.PATTERN.match(msg.text)
        if m is not None:
            # resolve the string into a Location object
            # (or None), and attach it to msg for other
            # apps to deal with
            text = m.group(2).strip()

            #split the text by space to find if it has a village
            # locCode,village = text.split()

            # location = self.__find_location(locCode)
            # location.village = village

            #msg.location = location
            msg.location = self.__find_location(text)

            # strip the location tag from the message,
            # so other apps don't have to deal with it
            msg.text = m.group(1)

            # we should probably log this crazy behavior...
            logger.info("Stripped Location code: %s" % text)
            logger.info("Message is now: %s" % msg.text)

########NEW FILE########
__FILENAME__ = forms
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.utils.translation import ugettext_lazy as _
from django.forms import widgets
from django.forms import fields
from django import forms
from .models import *


class PointWidget(widgets.MultiWidget):
    default_attrs = {"size": 6}

    def __init__(self, attrs=None):
        attrs_ = self.default_attrs.copy()
        attrs_.update(attrs or {})

        _widgets = (widgets.TextInput(attrs=attrs_),
                    widgets.TextInput(attrs=attrs_))
        super(PointWidget, self).__init__(_widgets, attrs)

    def decompress(self, value):
        if value:
            p = Point.objects.get(pk=value)
            return [p.latitude, p.longitude]

        return [None, None]


class PointField(fields.MultiValueField):
    widget = PointWidget

    default_error_messages = {
        "invalid_lat": _(u"Enter a valid latitude."),
        "invalid_lng": _(u"Enter a valid longitude.")}

    def __init__(self, *args, **kwargs):
        errors = self.default_error_messages.copy()

        if "error_messages" in kwargs:
            errors.update(kwargs["error_messages"])

        lat_field = fields.FloatField(
            error_messages={"invalid": errors["invalid_lat"]},
            min_value=-90,
            max_value=90)

        lng_field = fields.FloatField(
            error_messages={"invalid": errors["invalid_lng"]},
            min_value=-180,
            max_value=180)

        super(PointField, self).__init__((lat_field, lng_field),
                                         *args, **kwargs)

    def compress(self, data_list):
        if data_list:
            lat = unicode(data_list[0])
            lng = unicode(data_list[1])
            return Point.objects.create(
                latitude=lat, longitude=lng)

        return None


class LocationForm(forms.ModelForm):
    point = PointField(
        label="Coordinates",
        help_text="The physical latitude and longitude of this location.")

    class Meta:
        model = Location
        exclude = ("parent_type", "parent_id", "type")


#class CountryForm(LocationForm):
#    class Meta:
#        model = Country
#        exclude = ("parent_type", "parent_id")


#class StateForm(LocationForm):
#    class Meta:
#        model = State
#        exclude = ("parent_type", "parent_id")


#class CityForm(LocationForm):
#    class Meta:
#        model = City
#        exclude = ("parent_type", "parent_id")

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Point'
        db.create_table(u'locations_point', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('latitude', self.gf('django.db.models.fields.DecimalField')(max_digits=13, decimal_places=10)),
            ('longitude', self.gf('django.db.models.fields.DecimalField')(max_digits=13, decimal_places=10)),
        ))
        db.send_create_signal(u'locations', ['Point'])

        # Adding model 'LocationType'
        db.create_table(u'locations_locationtype', (
            ('name', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=50, primary_key=True)),
        ))
        db.send_create_signal(u'locations', ['LocationType'])

        # Adding model 'Location'
        db.create_table(u'locations_location', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('point', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['locations.Point'], null=True, blank=True)),
            ('type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='locations', null=True, to=orm['locations.LocationType'])),
            ('parent_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'], null=True, blank=True)),
            ('parent_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
        ))
        db.send_create_signal(u'locations', ['Location'])


    def backwards(self, orm):
        # Deleting model 'Point'
        db.delete_table(u'locations_point')

        # Deleting model 'LocationType'
        db.delete_table(u'locations_locationtype')

        # Deleting model 'Location'
        db.delete_table(u'locations_location')


    models = {
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'locations.location': {
            'Meta': {'object_name': 'Location'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'parent_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'point': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['locations.Point']", 'null': 'True', 'blank': 'True'}),
            'type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'locations'", 'null': 'True', 'to': u"orm['locations.LocationType']"})
        },
        u'locations.locationtype': {
            'Meta': {'object_name': 'LocationType'},
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'primary_key': 'True'})
        },
        u'locations.point': {
            'Meta': {'object_name': 'Point'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'latitude': ('django.db.models.fields.DecimalField', [], {'max_digits': '13', 'decimal_places': '10'}),
            'longitude': ('django.db.models.fields.DecimalField', [], {'max_digits': '13', 'decimal_places': '10'})
        }
    }

    complete_apps = ['locations']
########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.db import models
from django.utils.html import escape
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from rapidsms.models import ExtensibleModelBase


class Point(models.Model):
    """
    This model represents an anonymous point on the globe. It should be
    replaced with something from GeoDjango soon, but I can't seem to get
    Spatialite to build right now...
    """

    latitude = models.DecimalField(max_digits=13, decimal_places=10)
    longitude = models.DecimalField(max_digits=13, decimal_places=10)

    def __unicode__(self):
        return "%s, %s" % (self.latitude, self.longitude)

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)


class LocationType(models.Model):
    """
    This model represents the 'type' of Location, as an option for a
    simpler way of having a location heirarchy without having different
    classes for each location type (as is supported by the generic
    relation to parent).
    """
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True, primary_key=True)

    def __unicode__(self):
        return self.name


class Location(models.Model):
    """
    This model represents a named point on the globe. It is deliberately
    spartan, so more specific apps can extend it with their own fields
    and relationships without clashing with built-in functionality.
    """

    __metaclass__ = ExtensibleModelBase
    point = models.ForeignKey(Point, null=True, blank=True)
    type = models.ForeignKey(LocationType, related_name="locations",
                             blank=True, null=True)
    parent_type = models.ForeignKey(ContentType, null=True, blank=True)
    parent_id = models.PositiveIntegerField(null=True, blank=True)
    parent = generic.GenericForeignKey("parent_type", "parent_id")

    # choices for the Location.direction method.
    # (values stolen from label-overlay.js)
    class Direction:
        CENTER = "center"
        ABOVE = "above"
        RIGHT = "right"
        BELOW = "below"
        LEFT = "left"

    def __unicode__(self):
        """
        """

        return getattr(self, "name", "#%d" % self.pk)

    @property
    def uid(self):
        """
        Return a unique ID for this location, suitable for embedding in
        URLs. The primary key is insufficient, because the name of the
        model must also be included.

        This method (and ``get_for_uid`` will go away, once the ``slug``
        field is validated as unique across all Location subclasses.
        """

        return "%s:%d" % (self.content_type, self.pk)

    @property
    def content_type(self):
        return ContentType.objects.get_for_model(self).model

    @staticmethod
    def get_for_uid(uid):
        """
        Return the object (an instance of a subclass of Location) named
        by ``uid``. The UID should be in the form ``model:id``, as
        returned by the Location.uid property.
        """

        model, pk = uid.split(":")
        type = ContentType.objects.get(model=model)
        return type.get_object_for_this_type(pk=pk)

    @staticmethod
    def subclasses():
        """
        Return a list of all known subclasses of Location.
        """

        return [
            cls
            for cls in models.loading.get_models()
            if issubclass(cls, Location) and\
                (cls is not Location)]

    @property
    def path(self):
        next = self
        locations = []

        while next is not None:
            locations.insert(0, next)
            next = next.parent

        return locations

    def as_html(self):
        """
        Return the HTML fragment to be embedded in the map. This method
        should be overridden by subclasses wishing to fully customize
        the the rendering of their instance in the map.

        The output of this method is not escaped before being included
        in the template, so be careful to escape it yourself.
        """

        return escape(self.label)

    @property
    def label(self):
        """
        Return the caption for this Location, to be embedded in the
        map. This method should be overridden by subclasses wishing to
        provide better contextual information.

        The output of this method is included in the template as-is, so
        is HTML-escaped by default. If you wish to customize the HTML,
        override the ``as_html`` method, instead.
        """

        return unicode(self)

    @property
    def css_class(self):
        """
        Return the CSS class name of the label overlay. This method
        should be overriden by subclasses wishing to customize the
        appearance of the embedded HTML fragment.
        """

        return "bubble"

    @property
    def direction(self):
        """
        Return the direction which the embedded HTML fragment should be
        offset from the anchor point. Return one of Location.Direction.
        """

        return self.Direction.ABOVE


#class Country(Location):
#    name = models.CharField(max_length=100)
#    iso_code = models.CharField("ISO Code", max_length=2)

#    class Meta:
#        verbose_name_plural = "countries"

#    @property
#    def label(self):
#        return self.iso_code.upper()


#class State(Location):
#    name = models.CharField(max_length=100)
#    usps_code = models.CharField("USPS Code", max_length=2,
#        help_text="The two-letter state abbreviation")

#    @property
#    def label(self):
#        return self.usps_code.upper()


#class City(Location):
#    name = models.CharField(max_length=100)

#    class Meta:
#        verbose_name_plural = "cities"

########NEW FILE########
__FILENAME__ = location
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8

from django.db import models


class NestedLocation(models.Model):
    """
    rapidsms.contrib.locations.nested makes the following assumptions about the
    needs of a deployment for its locations models:
        * They are concrete, heirarchical, and follow the same structure at
          every level (e.g. districts, subcounties, parishes, and towns are
          all more-or-less the same and serve solely as administrative
          boundaries.
        * They must be used for aggregation, and querying a subtree must be
          fast.
    This abstract class allows the default Location class in
    rapidsms.contrib.locations to inherit two additional fields:
     * name :
           As NestedLocations are concrete, they will have instances that
           need to be named.
     * tree_parent :
           As NestedLocations are uniformely typed, the need to have
           a non-generic relation to their parents.
    """
    tree_parent = models.ForeignKey('self', blank=True, null=True,
                                    related_name='children')
    name = models.CharField(max_length=100)

    class Meta:
        abstract = True

########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8

import mptt

from rapidsms.contrib.locations.models import Location

# This registers the Location model with the mptt library
# (`pip install django-mptt`), adding all the necessary internals for using
# nested sets, and registering the `tree_parent` field as the parent used
# within the nested set tree
mptt.register(Location, parent_attr='tree_parent')

########NEW FILE########
__FILENAME__ = settings
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

MAP_DEFAULT_LATITUDE = 40.726111
MAP_DEFAULT_LONGITUDE = -73.981389

########NEW FILE########
__FILENAME__ = tables
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from djtables import Table, Column


class LocationTable(Table):
    name = Column()
    #slug = Column()

    #class Meta:
    #    order_by = 'name'

########NEW FILE########
__FILENAME__ = urls
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.conf.urls import patterns, url
from . import views


urlpatterns = patterns('',
    url(r'^(?:(?P<location_uid>[a-z\-]+:\d+)/)?$',
        views.locations,
        name="locations")
)

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.utils.modules import try_import
from .forms import LocationForm
from .models import Location


def get_model(name):
    """
    """

    for type in Location.subclasses():
        if type._meta.module_name == name:
            return type

    raise StandardError("There is no Location subclass named '%s'" % name)


def form_for_model(model):
    """
    Return the Form which should be used to add/edit ``model`` in the
    WebUI, by importing the class named ``"%sForm" % model.__name__``
    from the sibling ``forms`` module. For example::

        app1.models.Alpha     -> myapp.forms.SchoolForm
        app2.models.beta.Beta -> app2.forms.beta.BetaForm

    If no such form is defined, an appropriately-patched copy of the
    rapidsms.contrib.locations.forms.LocationForm form is returned.
    """

    parts = model.__module__.split(".")
    parts[parts.index("models")] = "forms"

    module_name = ".".join(parts)
    form_name = model.__name__ + "Form"

    module = try_import(module_name)
    if module is not None:

        form = getattr(module, form_name, None)
        if form is not None:
            return form

    meta_dict = LocationForm.Meta.__dict__
    meta_dict["model"] = model

    return type(
        form_name,
        (LocationForm,), {
            "Meta": type("Meta", (), meta_dict)
        }
    )

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.contrib.auth.decorators import login_required
from django.contrib.contenttypes.models import ContentType
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext

from rapidsms.conf import settings
from . import utils
from .models import Location
from .tables import LocationTable


def _breadcrumbs(location=None, first_caption="Planet Earth"):
    """
    Return the breadcrumb trail leading to ``location``. To avoid the
    trail being empty when browsing the entire world, the caption of the
    first crumb is hard coded.
    """

    breadcrumbs = [(first_caption, reverse(locations))]

    if location is not None:
        for loc in location.path:
            url = reverse(locations, args=(loc.uid,))
            breadcrumbs.append((loc, url))

    return breadcrumbs


class LocationTypeStub(object):
    """
    This is a shim class, to encapsulate the nested type/location
    structure, and keep the code out of the template. It's not useful
    anywhere else, so I haven't moved it into a template tag.
    """

    def __init__(self, type, req, loc):
        self._type = type
        self._req = req
        self._loc = loc

    def singular(self):
        return self._type._meta.verbose_name

    def plural(self):
        return self._type._meta.verbose_name_plural

    def name(self):
        return self._type._meta.module_name

    def content_type(self):
        return ContentType.objects.get_for_model(
            self._loc)

    def prefix(self):
        return self.name() + "-"

    def table(self):
        return LocationTable(
            self.locations(),
            request=self._req,
            prefix=self.prefix())

    def form(self):
        return utils.form_for_model(
            self._type)()

    def locations(self):
        if self._loc is not None:
            return self._type.objects.filter(
                parent_type=self.content_type(),
                parent_id=self._loc.pk)

        else:
            return self._type.objects.filter(
                parent_type=None)

    def is_empty(self):
        return self.locations().count() == 0


@login_required
def locations(req, location_uid=None):
    view_location = None

    if location_uid is not None:
        view_location = Location.get_for_uid(
            location_uid)

    if req.method == "POST":
        model_class = utils.get_model(req.POST["type"])
        form_class = utils.form_for_model(model_class)
        model = None

        if req.POST.get("id", None):
            model = get_object_or_404(
                model_class, pk=req.POST["id"])

            if req.POST["submit"] == "Delete":
                model.delete()
                return HttpResponseRedirect(
                    reverse(view_location))

        form = form_class(instance=model, data=req.POST)

        if form.is_valid():
            model = form.save()

            if req.POST.get("parent_type", None) and req.POST.get(
                    "parent_id", None):
                parent_class = utils.get_model(req.POST["parent_type"])
                parent = get_object_or_404(parent_class,
                                           pk=req.POST["parent_id"])
                model.parent = parent
                model.save()

                return HttpResponseRedirect(
                    reverse(locations, args=(parent.uid,)))

            return HttpResponseRedirect(
                reverse(locations))

    types = [
        LocationTypeStub(type, req, view_location)
        for type in Location.subclasses()]

    return render_to_response(
        "locations/dashboard.html", {
            "breadcrumbs": _breadcrumbs(view_location),
            "location": view_location,
            "location_types": types,

            # from rapidsms.contrib.locations.settings
            "default_latitude":  settings.MAP_DEFAULT_LATITUDE,
            "default_longitude": settings.MAP_DEFAULT_LONGITUDE,

            # if there are no locationtypes, then we should display a
            # big error, since this app is useless without them.
            "no_location_types": (len(types) == 0)
        }, context_instance=RequestContext(req)
    )

########NEW FILE########
__FILENAME__ = admin
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.contrib import admin
from .models import Message


class MessageAdmin(admin.ModelAdmin):
    list_display = ("text", "direction", "who", "date")
    list_filter = ("direction", "date")


admin.site.register(Message, MessageAdmin)

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.utils import timezone
from rapidsms.apps.base import AppBase
from .models import Message


class MessageLogApp(AppBase):

    def _log(self, direction, msg):
        if not msg.contact and not msg.connection:
            raise ValueError
        text = msg.raw_text if direction == Message.INCOMING else msg.text
        return Message.objects.create(
            date=timezone.now(),
            direction=direction,
            text=text,
            contact=msg.contact,
            connection=msg.connection,
        )

    def parse(self, msg):
        # annotate the message as we log them in case any other apps
        # want a handle to them
        msg.logger_msg = self._log(Message.INCOMING, msg)

    def outgoing(self, msg):
        msg.logger_msg = self._log(Message.OUTGOING, msg)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Message'
        db.create_table(u'messagelog_message', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('contact', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['rapidsms.Contact'], null=True)),
            ('connection', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['rapidsms.Connection'], null=True)),
            ('direction', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('date', self.gf('django.db.models.fields.DateTimeField')()),
            ('text', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal(u'messagelog', ['Message'])


    def backwards(self, orm):
        # Deleting model 'Message'
        db.delete_table(u'messagelog_message')


    models = {
        u'messagelog.message': {
            'Meta': {'object_name': 'Message'},
            'connection': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Connection']", 'null': 'True'}),
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Contact']", 'null': 'True'}),
            'date': ('django.db.models.fields.DateTimeField', [], {}),
            'direction': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {})
        },
        u'rapidsms.backend': {
            'Meta': {'object_name': 'Backend'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '20'})
        },
        u'rapidsms.connection': {
            'Meta': {'unique_together': "(('backend', 'identity'),)", 'object_name': 'Connection'},
            'backend': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Backend']"}),
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Contact']", 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identity': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'rapidsms.contact': {
            'Meta': {'object_name': 'Contact'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '6', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100', 'blank': 'True'})
        }
    }

    complete_apps = ['messagelog']
########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.core.exceptions import ValidationError
from django.db import models
from rapidsms.models import Contact, Connection


class Message(models.Model):
    INCOMING = "I"
    OUTGOING = "O"
    DIRECTION_CHOICES = (
        (INCOMING, "Incoming"),
        (OUTGOING, "Outgoing"),
    )

    contact = models.ForeignKey(Contact, null=True)
    connection = models.ForeignKey(Connection, null=True)
    direction = models.CharField(max_length=1, choices=DIRECTION_CHOICES)
    date = models.DateTimeField()
    text = models.TextField()

    def save(self, *args, **kwargs):
        """
        Verifies that one (not both) of the contact or connection fields
        have been populated (raising ValidationError if not), and saves
        the object as usual.
        """
        if self.contact is None and self.connection is None:
            raise ValidationError("A valid (not null) contact or connection "
                    "(but not both) must be provided to save the object.")
        elif self.connection and self.contact and \
                (self.contact != self.connection.contact):
            raise ValidationError("The connection and contact you tried to "
                    "save did not match! You need to pick one or the other.")

        if self.connection and self.connection.contact is not None:
            # set the contact here as well, even if they didn't
            # do it explicitly. If the contact's number changes
            # we still might want to know who it originally came
            # in from.
            self.contact = self.connection.contact
        super(Message, self).save(*args, **kwargs)

    @property
    def who(self):
        """Returns the Contact or Connection linked to this object."""
        return self.contact or self.connection

    def __unicode__(self):
        # crop the text (to avoid exploding the admin)
        text = self.text if len(self.text) < 60 else "%s..." % self.text[0:57]
        direction = "to" if self.direction == self.INCOMING else "from"
        return "%s (%s %s)" % (text, direction, self.who)

########NEW FILE########
__FILENAME__ = tables
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import django_tables2 as tables
from rapidsms.contrib.messagelog.models import Message


class MessageTable(tables.Table):

    class Meta:
        model = Message
        exclude = ('id', )
        order_by = ('-date', )
        attrs = {
            'class': 'table table-striped table-bordered table-condensed'
        }

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.messages import IncomingMessage, OutgoingMessage
from rapidsms.tests.harness import RapidTest
from ..app import MessageLogApp
from ..models import Message


__all__ = ['MessageLogAppTestBase', 'IncomingMessageLogAppTest',
           'OutgoingMessageLogAppTest']


class MessageLogAppTestBase(object):

    def setUp(self):
        self.contact = self.create_contact()
        self.connection = self.lookup_connections(['1112223333'])[0]
        self.connection.contact = self.contact
        self.app = MessageLogApp(self.router)

    def _check_message(self, msg, msg_obj):
        if isinstance(msg, IncomingMessage):
            self.assertEqual(msg_obj.direction, Message.INCOMING)
        else:
            self.assertEqual(msg_obj.direction, Message.OUTGOING)
        self.assertEqual(msg_obj, msg.logger_msg)
        self.assertEqual(msg_obj.contact, msg.contact)
        self.assertEqual(msg_obj.connection, msg.connection)
        self.assertEqual(msg_obj.text, msg.text)

    def test_message(self):
        """Message should be logged & annotated."""
        msg = self.MessageType([self.connection], 'hello')
        self._send(msg)
        self.assertEqual(Message.objects.count(), 1)
        self._check_message(msg, Message.objects.get())

    def test_no_contact(self):
        """Message doesn't require a Contact if a Connection is present."""
        self.connection.contact = None
        msg = self.MessageType([self.connection], 'hello')
        self._send(msg)
        self.assertEqual(Message.objects.count(), 1)
        self._check_message(msg, Message.objects.get())


class IncomingMessageLogAppTest(MessageLogAppTestBase, RapidTest):
    MessageType = IncomingMessage

    def _send(self, msg):
        return self.app.parse(msg)


class OutgoingMessageLogAppTest(MessageLogAppTestBase, RapidTest):
    MessageType = OutgoingMessage

    def _send(self, msg):
        return self.app.outgoing(msg)

########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: aui ts=4 sts=4 et sw=4

from django.core.exceptions import ValidationError
from django.utils.timezone import now
from rapidsms.tests.harness import RapidTest
from ..models import Message


__all__ = ['MessageLogModelTest']


class MessageLogModelTest(RapidTest):

    def setUp(self):
        self.contact = self.create_contact()
        self.connection = self.lookup_connections(['1112223333'])[0]
        self.connection.contact = self.contact
        self.data = {
            'contact': self.contact,
            'connection': self.connection,
            'direction': Message.INCOMING,
            'date': now(),
            'text': 'hello',
        }

    def test_no_contact_or_connection(self):
        """Message requires a Contact or a Connection."""
        self.data.pop('contact')
        self.data.pop('connection')
        with self.assertRaises(ValidationError):
            Message.objects.create(**self.data)

    def test_no_contact(self):
        """Message does not require a Contact if a Connection is available."""
        self.data.pop('contact')
        msg = Message.objects.create(**self.data)
        self.assertEqual(msg.contact, self.contact)

        self.connection.contact = None
        msg = Message.objects.create(**self.data)
        self.assertEqual(msg.contact, None)

    def test_no_connection(self):
        """Message does not require a Connection if a Contact is available."""
        self.data.pop('connection')
        msg = Message.objects.create(**self.data)
        self.assertEqual(msg.connection, None)

    def test_contact_mismatch(self):
        """If both present, Contact and Connection Contact must match."""
        self.data['contact'] = self.create_contact()
        with self.assertRaises(ValidationError):
            Message.objects.create(**self.data)


########NEW FILE########
__FILENAME__ = urls
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.conf.urls import patterns, url
from . import views


urlpatterns = patterns('',
    url(r'^$', views.message_log, name="message_log"),
)

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.contrib.auth.decorators import login_required
from django.shortcuts import render

from rapidsms.contrib.messagelog.tables import MessageTable
from rapidsms.contrib.messagelog.models import Message
from rapidsms import settings

from django_tables2 import RequestConfig


@login_required
def message_log(request):
    qset = Message.objects.all()
    qset = qset.select_related('contact', 'connection__backend')
    template = "django_tables2/bootstrap-tables.html"

    messages_table = MessageTable(qset, template=template)

    paginate = {"per_page": settings.PAGINATOR_OBJECTS_PER_PAGE}
    RequestConfig(request, paginate=paginate).configure(messages_table)

    return render(request, "messagelog/index.html", {
        "messages_table": messages_table,
    })

########NEW FILE########
__FILENAME__ = forms
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django import forms

from rapidsms.router import send

from selectable.forms import AutoCompleteSelectMultipleField

from .lookups import ConnectionLookup


class MessageForm(forms.Form):
    message = forms.CharField(widget=forms.Textarea)
    connections = AutoCompleteSelectMultipleField(
            lookup_class=ConnectionLookup)

    def __init__(self, *args, **kwargs):
        super(MessageForm, self).__init__(*args, **kwargs)
        self.fields['connections'].widget.attrs['placeholder'] = 'Add a '\
                'Recipient'
        self.fields['message'].widget.attrs['placeholder'] = 'Message'

    def send(self):
        message = self.cleaned_data['message']
        connections = self.cleaned_data['connections']
        return send(message, connections)

########NEW FILE########
__FILENAME__ = lookups
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.models import Connection

from selectable.base import ModelLookup
from selectable.registry import registry


class ConnectionLookup(ModelLookup):
    model = Connection
    search_fields = ('identity__icontains', 'contact__name__icontains')

    def get_item_value(self, item):
        return self.get_item_label(item)

    def get_item_label(self, item):
        # Add an asterisk to default connections
        default = not item.contact or item == item.contact.default_connection
        if default:
            conn_name = '{0} - {1}*'.format(item.backend.name, item.identity)
        else:
            conn_name = '{0} - {1}'.format(item.backend.name, item.identity)

        if not item.contact or not item.contact.name:
            return conn_name
        return '{0} ({1})'.format(item.contact.name, conn_name)

registry.register(ConnectionLookup)

########NEW FILE########
__FILENAME__ = forms
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from rapidsms.tests.harness import RapidTest

from ..forms import MessageForm


__all__ = ['TestMessagingForm']


class TestMessagingForm(RapidTest):

    def setUp(self):
        self.contact = self.create_contact()
        self.backend = self.create_backend({'name': 'mockbackend'})
        self.connection = self.create_connection({
            'backend': self.backend,
            'contact': self.contact,
        })
        self.message = 'hello'
        self.data = {
            'message': self.message,
            'connections_1': [self.connection.pk],
        }

    def test_no_message(self):
        """Form should require the message field."""
        self.data.pop('message')
        form = MessageForm(self.data)
        self.assertFalse(form.is_valid())
        self.assertEqual(len(form.errors), 1)
        self.assertTrue('message' in form.errors)

    def test_no_recipients(self):
        """Form should require at least one recipient."""
        self.data.pop('connections_1')
        form = MessageForm(self.data)
        self.assertFalse(form.is_valid())
        self.assertEqual(len(form.errors), 1)
        self.assertTrue('connections' in form.errors)

    def test_valid_data(self):
        form = MessageForm(self.data)
        self.assertTrue(form.is_valid())

    def test_send(self):
        form = MessageForm(self.data)
        self.assertTrue(form.is_valid())
        message = form.send()
        self.assertEqual(message.text, self.message)
        self.assertEqual(message.connection, self.connection)

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import mock

from django.core.urlresolvers import reverse

from rapidsms.tests.harness import RapidTest


__all__ = ['TestMessagingView', 'TestSendView']


class TestMessagingView(RapidTest):
    url_name = 'messaging'

    def setUp(self):
        self.url = reverse(self.url_name)

    def test_get(self):
        """The messaging page should return a 200 code."""
        self.login()
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)


class TestSendView(RapidTest):
    url_name = 'send_message'

    def setUp(self):
        self.url = reverse(self.url_name)
        self.backend = self.create_backend({'name': 'mockbackend'})
        self.contact1 = self.create_contact({'name': 'one'})
        self.contact2 = self.create_contact({'name': 'two'})
        self.connection1 = self.create_connection({
            'backend': self.backend,
            'contact': self.contact1,
        })
        self.connection2 = self.create_connection({
            'backend': self.backend,
            'contact': self.contact2,
        })
        self.message = 'hello'
        self.data = {
            'message': self.message,
            'connections_1': [self.connection1.pk, self.connection2.pk],
        }

    def test_get(self):
        """Only POST should be allowed."""
        self.login()
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 405)  # Method Not Allowed

    def test_post(self):
        """Posting valid data should cause a 200 response."""
        self.login()
        response = self.client.post(self.url, self.data)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(self.outbound), 1)
        msg = self.outbound[0]
        self.assertEqual(msg.text, self.message)
        self.assertTrue(self.connection1 in msg.connections)
        self.assertTrue(self.connection2 in msg.connections)

    def test_post_no_message(self):
        """A form validation error should cause a 400 response."""
        self.data.pop('message')
        self.login()
        response = self.client.post(self.url, self.data)
        self.assertEqual(response.status_code, 400)  # Bad Request

    def test_post_no_contacts(self):
        """A form validation error should cause a 400 response."""
        self.data.pop('connections_1')
        self.login()
        response = self.client.post(self.url, self.data)
        self.assertEqual(response.status_code, 400)  # Bad Request

    def test_post_send_error(self):
        """
        An error during sending should cause a 500 response. No guarantees
        are made about whether the message has been sent to other recipients.
        """
        with mock.patch('rapidsms.contrib.messaging.forms.MessageForm.send')\
                as send:
            send.side_effect = Exception()
            self.login()
            response = self.client.post(self.url, self.data)
        self.assertEqual(response.status_code, 500)

########NEW FILE########
__FILENAME__ = urls
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.conf.urls import patterns, url
from . import views


urlpatterns = patterns('',
    url(r'^$', views.messaging, name='messaging'),
    url(r'^send/$', views.send, name='send_message'),
)

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


def send_message(connection, text):
    raise DeprecationWarning("rapidsms.contrib.messaging.utils is deprecated")

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, HttpResponseBadRequest
from django.shortcuts import render
from django.views.decorators.http import require_POST

from .forms import MessageForm


@login_required
def messaging(request):
    return render(request, 'messaging/dashboard.html', {
        'form': MessageForm(),
    })


@login_required
@require_POST
def send(request):
    try:
        form = MessageForm(request.POST)
        if form.is_valid():
            message = form.send()
            if len(message.connections) == 1:
                return HttpResponse('Your message was sent to 1 recipient.')
            else:
                msg = 'Your message was sent to {0} ' \
                    'recipients.'.format(len(message.connections))
                return HttpResponse(msg)
        else:
            return HttpResponseBadRequest(unicode(form.errors))
    except:
        return HttpResponse("Unable to send message.", status=500)

########NEW FILE########
__FILENAME__ = forms
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django import forms
from rapidsms.models import Contact, Connection


class ConnectionFormSetBase(forms.models.BaseInlineFormSet):
    def __init__(self, *args, **kwargs):
        super(ConnectionFormSetBase, self).__init__(*args, **kwargs)
        self.forms[0].empty_permitted = False
        for form in self.forms:
            if not form.initial:
                form.fields['DELETE'].widget = forms.widgets.HiddenInput()


ContactForm = forms.models.modelform_factory(Contact, exclude=("connections", ))

ConnectionFormSet = forms.models.inlineformset_factory(
    Contact,
    Connection,
    extra=1,
    formset=ConnectionFormSetBase,
)


# the built-in FileField doesn't specify the 'size' attribute, so the
# widget is rendered at its default width -- which is too wide for our
# form. this is a little hack to shrink the field.
class SmallFileField(forms.FileField):
    def widget_attrs(self, widget):
        return {"size": 10}


class BulkRegistrationForm(forms.Form):
    bulk = SmallFileField(
        label="Upload CSV file",
        required=False,
        help_text="Upload a <em>plain text file</em> " +
                  "containing a single contact per line, for example: <br/>" +
                  "<em>firstname lastname, backend_name, identity</em>")

########NEW FILE########
__FILENAME__ = language
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.conf import settings
from rapidsms.contrib.handlers.handlers.keyword import KeywordHandler


class LanguageHandler(KeywordHandler):
    """
    Allow remote users to set their preferred language, by updating the
    ``language`` field of the Contact associated with their connection.
    """

    keyword = "language|lang"

    def help(self):
        self.respond("To set your language, send LANGUAGE <CODE>")

    def handle(self, text):
        if self.msg.connection.contact is None:
            return self.respond_error(
                "You must JOIN or REGISTER yourself before you can " +
                "set your language preference.")

        t = text.lower()
        for code, name in settings.LANGUAGES:
            if t != code.lower() and t != name.lower():
                continue

            self.msg.connection.contact.language = code
            self.msg.connection.contact.save()

            return self.respond(
                "I will speak to you in %(language)s." % {
                'language': name})

        return self.respond_error(
            'Sorry, I don\'t speak "%(language)s".' % {
            'language': text})

########NEW FILE########
__FILENAME__ = register
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.contrib.handlers.handlers.keyword import KeywordHandler
from rapidsms.models import Contact


class RegisterHandler(KeywordHandler):
    """
    Allow remote users to register themselves, by creating a Contact
    object and associating it with their Connection. For example::

        >>> RegisterHandler.test('join Adam Mckaig')
        ['Thank you for registering, Adam Mckaig!']

        >>> Contact.objects.filter(name="Adam Mckaig")
        [<Contact: Adam Mckaig>]

    Note that the ``name`` field of the Contact model is not constrained
    to be unique, so this handler does not reject duplicate names. If
    you wish to enforce unique usernames or aliases, you must extend
    Contact, disable this handler, and write your own.
    """

    keyword = "register|reg|join"

    def help(self):
        self.respond("To register, send JOIN <NAME>")

    def handle(self, text):
        contact = Contact.objects.create(name=text)
        self.msg.connection.contact = contact
        self.msg.connection.save()

        self.respond(
            "Thank you for registering, %(name)s!" % {'name': contact.name})

########NEW FILE########
__FILENAME__ = tables
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.models import Contact
import django_tables2 as tables


class ContactTable(tables.Table):
    identities = tables.Column(empty_values=(), orderable=False)
    id = tables.LinkColumn('registration_contact_edit',
                           args=[tables.utils.A('pk')])

    class Meta:
        model = Contact
        order_by = ('id')
        attrs = {
            'class': 'table table-striped table-bordered table-condensed'
        }

    def render_identities(self, value, record):
        return ', '.join([x.identity for x in record.connection_set.all()])

########NEW FILE########
__FILENAME__ = tests
# coding=utf-8
from StringIO import StringIO
from django.http import Http404, HttpRequest, HttpResponseRedirect, QueryDict
from django.test import TestCase
from mock import Mock, patch
from rapidsms.models import Connection, Contact
from rapidsms.tests.harness import CreateDataMixin, LoginMixin

from rapidsms.tests.scripted import TestScript
import rapidsms.contrib.registration.views as views


RAPIDSMS_HANDLERS = [
    "rapidsms.contrib.registration.handlers.language.LanguageHandler",
    "rapidsms.contrib.registration.handlers.register.RegisterHandler",
]


class TestRegister(TestScript):
    handlers = RAPIDSMS_HANDLERS

    def testRegister(self):
        self.assertInteraction("""
          8005551212 > register as someuser
          8005551212 < Thank you for registering, as someuser!
        """)

    def testLang(self):
        self.assertInteraction("""
          8005551212 > lang english
          8005551212 < %s
          8005551212 > register as someuser
          8005551212 < Thank you for registering, as someuser!
          8005551212 > lang english
          8005551212 < I will speak to you in English.
          8005551212 > lang klingon
          8005551212 < Sorry, I don't speak "klingon".
        """ % ("You must JOIN or REGISTER yourself before you can set " +
               "your language preference."))

    def testHelp(self):
        self.assertInteraction("""
          8005551212 > lang
          8005551212 < To set your language, send LANGUAGE <CODE>
          8005551212 > register
          8005551212 < To register, send JOIN <NAME>
        """)


class TestViews(TestCase, CreateDataMixin, LoginMixin):
    def setUp(self):
        # Make some contacts
        self.contacts = [self.create_contact() for i in range(2)]
        self.backend = self.create_backend()
        # Give the first one some connections
        for i in range(2):
            self.create_connection(data={'contact': self.contacts[0]})

    def test_registration(self):
        # The registration view calls render with a context that has a
        # contacts_table that has the contacts in its data
        request = HttpRequest()
        request.GET = QueryDict('')
        self.login()
        request.user = self.user
        with patch('rapidsms.contrib.registration.views.render') as render:
            views.registration(request)
        context = render.call_args[0][2]
        table = context["contacts_table"]
        self.assertEqual(len(self.contacts), len(list(table.data.queryset)))

    def test_registration_render(self):
        # render actually works (django_tables2 and all)
        request = HttpRequest()
        request.GET = QueryDict('')
        self.login()
        request.user = self.user
        retval = views.registration(request)
        self.assertEqual(200, retval.status_code)

    def test_contact_existing_404(self):
        # Trying to edit a non-existing contact raises a 404
        with self.assertRaises(Http404):
            views.contact(Mock(), pk=27)

    def test_contact_existing(self):
        # GET on contact form with valid pk renders template with that contact
        contact = self.contacts[0]
        connection = contact.default_connection
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="GET")
            self.login()
            request.user = self.user
            views.contact(request, pk=contact.pk)
        context = render.call_args[0][2]
        self.assertEqual(contact.pk, context['contact'].pk)
        form = context['contact_form']
        data = form.initial
        self.assertEqual(contact.name, data['name'])
        self.assertEqual(contact.pk, form.instance.pk)
        formset = context['connection_formset']
        forms = formset.forms
        instances = [f.instance for f in forms]
        # Connection should be in there
        self.assertIn(connection, instances)
        # Should be 1 more form than we have connections
        self.assertEqual(len(forms), 1 + len(contact.connection_set.all()))

    def test_contact_get(self):
        # GET on contact form with no pk allows creating new one
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="GET")
            self.login()
            request.user = self.user
            views.contact(request)
        context = render.call_args[0][2]
        # ModelForms create a new unsaved instance
        self.assertIsNotNone(context['contact_form'].instance)
        self.assertTrue(context['contact_form'].instance.is_anonymous)
        self.assertEqual(1, len(context['connection_formset'].forms))

    def test_contact_update(self):
        # POST to contact view updates the contact and connections
        contact = self.contacts[0]
        data = {
            u'name': u'The Contact',
            u'language': u'wxyz',
            u'submit': u'Save Contact',
            u'connection_set-0-id': u'2',
            u'connection_set-0-DELETE': u'',
            u'connection_set-0-backend': u'1',
            u'connection_set-0-contact': u'1',
            u'connection_set-0-identity': u'4567',
            u'connection_set-1-id': u'',
            u'connection_set-1-contact': u'1',
            u'connection_set-1-identity': u'',
            u'connection_set-1-backend': u'',
            u'connection_set-INITIAL_FORMS': u'1',
            u'connection_set-TOTAL_FORMS': u'2',
            u'connection_set-MAX_NUM_FORMS': u'10',
        }
        with patch('rapidsms.contrib.registration.views.render'):
            request = Mock(method="POST", POST=data)
            self.login()
            request.user = self.user
            retval = views.contact(request, pk=contact.pk)
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        new_contact = Contact.objects.get(pk=contact.pk)
        self.assertEqual(data['name'], new_contact.name)
        self.assertEqual(data['language'], new_contact.language)
        identities = [c.identity for c in contact.connection_set.all()]
        self.assertIn(data['connection_set-0-identity'], identities)

    def test_contact_update_add_connection(self):
        # POST to contact view can add a connection
        contact = self.contacts[0]
        data = {
            u'name': u'The Contact',
            u'language': u'wxyz',
            u'submit': u'Save Contact',
            u'connection_set-0-id': u'2',
            u'connection_set-0-DELETE': u'',
            u'connection_set-0-backend': u'1',
            u'connection_set-0-contact': u'1',
            u'connection_set-0-identity': u'4567',
            u'connection_set-1-id': u'',
            u'connection_set-1-contact': u'1',
            u'connection_set-1-identity': u'987654',
            u'connection_set-1-backend': u'1',
            u'connection_set-INITIAL_FORMS': u'1',
            u'connection_set-TOTAL_FORMS': u'2',
            u'connection_set-MAX_NUM_FORMS': u'10',
        }

        identities = [c.identity for c in contact.connection_set.all()]
        self.assertNotIn(data['connection_set-1-identity'], identities)

        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="POST", POST=data)
            self.login()
            request.user = self.user
            retval = views.contact(request, pk=contact.pk)
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        render.assert_called()
        new_contact = Contact.objects.get(pk=contact.pk)
        self.assertEqual(data['name'], new_contact.name)
        self.assertEqual(data['language'], new_contact.language)
        identities = [c.identity for c in contact.connection_set.all()]
        self.assertIn(data['connection_set-1-identity'], identities)

    def test_contact_delete(self):
        # Submitting with Delete button deletes the contact
        contact = self.contacts[0]
        data = {
            u'name': u'The Contact',
            u'language': u'wxyz',
            u'submit': u"Delete Contact",
            u'connection_set-0-id': u'2',
            u'connection_set-0-DELETE': u'',
            u'connection_set-0-backend': u'1',
            u'connection_set-0-contact': u'1',
            u'connection_set-0-identity': u'4567',
            u'connection_set-1-id': u'',
            u'connection_set-1-contact': u'1',
            u'connection_set-1-identity': u'987654',
            u'connection_set-1-backend': u'1',
            u'connection_set-INITIAL_FORMS': u'1',
            u'connection_set-TOTAL_FORMS': u'2',
            u'connection_set-MAX_NUM_FORMS': u'10',
        }

        with patch('rapidsms.contrib.registration.views.render'):
            request = Mock(method="POST", POST=data)
            self.login()
            request.user = self.user
            retval = views.contact(request, pk=contact.pk)
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        self.assertFalse(Contact.objects.filter(pk=contact.pk).exists())

    def test_contact_create(self):
        # POST with no existing contact creates a new one
        name = u'A BRAND NEW CONTACT'
        data = {
            u'name': name,
            u'language': u'wxyz',
            u'submit': u'Save Contact',
            u'connection_set-0-id': u'',
            u'connection_set-0-DELETE': u'',
            u'connection_set-0-backend': u'1',
            u'connection_set-0-contact': u'',
            u'connection_set-0-identity': u'4567',
            u'connection_set-1-id': u'',
            u'connection_set-1-contact': u'',
            u'connection_set-1-identity': u'',
            u'connection_set-1-backend': u'',
            u'connection_set-INITIAL_FORMS': u'0',
            u'connection_set-TOTAL_FORMS': u'2',
            u'connection_set-MAX_NUM_FORMS': u'10',
        }
        with patch('rapidsms.contrib.registration.views.render'):
            request = Mock(method="POST", POST=data)
            self.login()
            request.user = self.user
            retval = views.contact(request)
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        Contact.objects.get(name=name)

    def test_delete_connection(self):
        # POST can delete one of the connections
        contact = self.create_contact()
        # Give it two connections
        self.create_connection(data={'contact': contact})
        self.create_connection(data={'contact': contact})

        # Submit form filled out to delete a connection
        connections = contact.connection_set.all()
        data = {
            u'name': u'Joe User',
            u'language': u'en',
            u'submit': u"Save Contact",

            u'connection_set-0-id': connections[0].pk,
            u'connection_set-0-identity': connections[0].identity,
            u'connection_set-0-backend': connections[0].backend.pk,
            u'connection_set-0-contact': contact.pk,

            u'connection_set-1-id': connections[1].pk,
            u'connection_set-1-identity': connections[1].identity,
            u'connection_set-1-backend': connections[1].backend.pk,
            u'connection_set-1-contact': contact.pk,
            u'connection_set-1-DELETE': u"connection_set-1-DELETE",

            u'connection_set-2-id': u'',
            u'connection_set-2-backend': u'',
            u'connection_set-2-identity': u'',
            u'connection_set-2-contact': u'',

            u'connection_set-TOTAL_FORMS': u'3',
            u'connection_set-MAX_NUM_FORMS': u'10',
            u'connection_set-INITIAL_FORMS': u'2',
        }
        old_pk = connections[1].pk
        with patch('rapidsms.contrib.registration.views.render'):
            request = Mock(method="POST", POST=data)
            self.login()
            request.user = self.user
            retval = views.contact(request, pk=contact.pk)
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        self.assertFalse(Connection.objects.filter(pk=old_pk).exists())

    def test_add_connection(self):
        # POST can add a new connection
        contact = self.create_contact()
        # Give it ONE connection
        self.create_connection(data={'contact': contact})

        # Submit form filled out to add another connection

        connections = contact.connection_set.all()
        data = {
            u'name': u'Joe User',
            u'language': u'en',
            u'submit': u"Save Contact",

            u'connection_set-0-id': connections[0].pk,
            u'connection_set-0-identity': connections[0].identity,
            u'connection_set-0-backend': connections[0].backend.pk,
            u'connection_set-0-contact': contact.pk,

            u'connection_set-1-id': u'',
            u'connection_set-1-identity': 'identity',
            u'connection_set-1-backend': connections[0].backend.pk,
            u'connection_set-1-contact': contact.pk,

            u'connection_set-TOTAL_FORMS': u'2',
            u'connection_set-MAX_NUM_FORMS': u'10',
            u'connection_set-INITIAL_FORMS': u'1',
        }
        with patch('rapidsms.contrib.registration.views.render'):
            request = Mock(method="POST", POST=data)
            self.login()
            request.user = self.user
            retval = views.contact(request, pk=contact.pk)
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        self.assertEqual(2, Connection.objects.filter(contact=contact).count())
        conn = Connection.objects.get(identity='identity', contact=contact)
        self.assertEqual(connections[0].backend, conn.backend)


class TestBulkAdd(TestCase, CreateDataMixin, LoginMixin):
    def test_bulk_get(self):
        # Just make sure the page loads
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="GET")
            views.contact_bulk_add(request)
        render.assert_called()

    def test_bulk_add(self):
        # We can upload a CSV file to create contacts & connections
        backend1 = self.create_backend()
        backend2 = self.create_backend()
        # Include a unicode name to make sure that works
        uname = u'Name 1 ḀḂḈ ᵺ'
        data = [
            (uname, backend1.name, u'11111'),
            (u'Name 2', backend2.name, u'22222'),
            (u'Name 3', backend1.name, u'33333'),
            (u'Name 4', backend2.name, u'44444'),
        ]
        # Create test file
        testfile = u"\n".join([u",".join(parts) for parts in data]) + u"\n"
        testfile_data = testfile.encode('utf-8')
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="POST",
                           FILES={'bulk': StringIO(testfile_data)})
            self.login()
            request.user = self.user
            retval = views.contact_bulk_add(request)
        if not isinstance(retval, HttpResponseRedirect):
            context = render.call_args[0][2]
            self.fail(context['bulk_form'].errors + context['csv_errors'])
        self.assertTrue(isinstance(retval, HttpResponseRedirect))
        self.assertEqual(302, retval.status_code)
        contacts = Contact.objects.all()
        self.assertEqual(4, contacts.count())
        names = [contact.name for contact in contacts]
        self.assertIn(uname, names)

    def test_bulk_add_no_lines(self):
        testfile = ""
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="POST", FILES={'bulk': StringIO(testfile)})
            self.login()
            request.user = self.user
            retval = views.contact_bulk_add(request)
        self.assertFalse(isinstance(retval, HttpResponseRedirect))
        context = render.call_args[0][2]
        self.assertIn('csv_errors', context)
        self.assertEqual('No contacts found in file', context['csv_errors'])

    def test_bulk_add_bad_line(self):
        testfile = "Field 1, field 2\n"
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="POST", FILES={'bulk': StringIO(testfile)})
            self.login()
            request.user = self.user
            retval = views.contact_bulk_add(request)
        self.assertFalse(isinstance(retval, HttpResponseRedirect))
        context = render.call_args[0][2]
        self.assertIn('csv_errors', context)
        self.assertEqual('Could not unpack line 1', context['csv_errors'])

    def test_bulk_add_bad_backend(self):
        testfile = "Field 1, no_such_backend, 123\n"
        with patch('rapidsms.contrib.registration.views.render') as render:
            request = Mock(method="POST", FILES={'bulk': StringIO(testfile)})
            self.login()
            request.user = self.user
            retval = views.contact_bulk_add(request)
        self.assertFalse(isinstance(retval, HttpResponseRedirect))
        context = render.call_args[0][2]
        self.assertIn('csv_errors', context)
        self.assertEqual("Could not find Backend.  Line: 1",
                         context['csv_errors'])

########NEW FILE########
__FILENAME__ = urls
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.conf.urls import patterns, url
from . import views


urlpatterns = patterns('',
    url(r'^$', views.registration, name="registration"),
    url(r'^contact/add/$', views.contact, name="registration_contact_add"),
    url(r'^contact/bulk_add/$', views.contact_bulk_add, name="registration_bulk_add"),
    url(r'^(?P<pk>\d+)/edit/$', views.contact, name="registration_contact_edit"),
)

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import csv
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.core.urlresolvers import reverse
from django.db import transaction
from django.http import HttpResponseRedirect
from django.shortcuts import render, get_object_or_404
from django_tables2 import RequestConfig
from rapidsms.models import Contact, Connection, Backend
from rapidsms.contrib.registration.tables import ContactTable
from rapidsms.contrib.registration.forms import (
    BulkRegistrationForm,
    ContactForm, ConnectionFormSet)
from rapidsms import settings


@login_required
def registration(request):
    contacts_table = ContactTable(
        Contact.objects.all().prefetch_related('connection_set'),
        template="django_tables2/bootstrap-tables.html")

    paginate = {"per_page": settings.PAGINATOR_OBJECTS_PER_PAGE}
    RequestConfig(request, paginate=paginate).configure(contacts_table)

    return render(request, "registration/dashboard.html", {
        "contacts_table": contacts_table,
    })


@login_required
def contact(request, pk=None):
    if pk:
        contact = get_object_or_404(Contact, pk=pk)
    else:
        contact = Contact()
    contact_form = ContactForm(instance=contact)
    connection_formset = ConnectionFormSet(instance=contact)
    if request.method == 'POST':
        data = {}
        for key in request.POST:
            val = request.POST[key]
            if isinstance(val, basestring):
                data[key] = val
            else:
                try:
                    data[key] = val[0]
                except (IndexError, TypeError):
                    data[key] = val
        # print repr(data)
        del data
        if pk:
            if request.POST["submit"] == "Delete Contact":
                contact.delete()
                messages.add_message(request, messages.INFO, "Deleted contact")
                return HttpResponseRedirect(reverse(registration))
            contact_form = ContactForm(request.POST, instance=contact)
        else:
            contact_form = ContactForm(request.POST)
        if contact_form.is_valid():
            contact = contact_form.save(commit=False)
            connection_formset = ConnectionFormSet(request.POST,
                                                   instance=contact)
            if connection_formset.is_valid():
                contact.save()
                connection_formset.save()
                messages.add_message(request, messages.INFO, "Added contact")
                return HttpResponseRedirect(reverse(registration))
    return render(request, 'registration/contact_form.html', {
        "contact": contact,
        "contact_form": contact_form,
        "connection_formset": connection_formset,
    })


@login_required
@transaction.commit_on_success
def contact_bulk_add(request):
    bulk_form = BulkRegistrationForm(request.POST)

    if request.method == "POST" and "bulk" in request.FILES:
        reader = csv.reader(
            request.FILES["bulk"],
            quoting=csv.QUOTE_NONE,
            skipinitialspace=True
        )
        count = 0
        for i, row in enumerate(reader, start=1):
            try:
                name, backend_name, identity = row
            except:
                return render(request, 'registration/bulk_form.html', {
                    "bulk_form": bulk_form,
                    "csv_errors": "Could not unpack line " + str(i),
                })
            contact = Contact.objects.create(name=name)
            try:
                backend = Backend.objects.get(name=backend_name)
            except:
                return render(request, 'registration/bulk_form.html', {
                    "bulk_form": bulk_form,
                    "csv_errors": "Could not find Backend.  Line: " + str(i),
                })
            Connection.objects.create(
                backend=backend,
                identity=identity,
                contact=contact)
            count += 1
        if not count:
            return render(request, 'registration/bulk_form.html', {
                "bulk_form": bulk_form,
                "csv_errors": "No contacts found in file",
            })
        messages.add_message(request, messages.INFO, "Added %d contacts" %
                                                     count)
        return HttpResponseRedirect(reverse(registration))
    return render(request, 'registration/bulk_form.html', {
        "bulk_form": bulk_form,
    })

########NEW FILE########
__FILENAME__ = errors
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


class MessageSendingError(StandardError):
    """
    This exception is raised when an outgoing message cannot be sent.
    Where possible, a more specific exception should be raised, along
    with a descriptive message.
    """


class NoRouterError(MessageSendingError):
    """
    This exception is raised when no Router is available to send an
    outgoing message. This usually means that it is being sent from the
    webui process(es), which is not currently possible in RapidSMS.
    """


class NoConnectionError(MessageSendingError):
    """
    This execption is raised when a Contact cannot be messaged because
    they do not have any Connections.
    """

########NEW FILE########
__FILENAME__ = mixin
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


import logging
import warnings


class LoggerMixin():
    """
    This mixin provides a quick way to log from classes within the
    RapidSMS framework. It's mostly pasted from logging.LoggingAdaptor
    (which isn't available in < Py2.6), with a couple of compatibility
    tweaks.
    """

    def _logger_name(self):
        """
        Returns the name of the log which will receive messages emitted
        by this object. This defaults to the class name (sanitized), but
        should almost always be overloaded by subclasses to make the
        hierarchy clear.
        """
        return type(self).__name__.lower()

    @property
    def _logger(self):
        name = self._logger_name()

        # check the type of the output of _log_name, since logging.getLogger
        # doesn't bother, resulting in an obscure explosion for non-strings
        if not isinstance(name, basestring):
            raise TypeError(
                "%s._logger_name returned '%r' (%s). (wanted a string)" %
                (type(self).__name__, name, type(name).__name__))

        return logging.getLogger(name)

    def log(self, *args, **kwargs):
        warnings.warn("LoggerMixin is deprecated; use the standard logging module instead",
                      DeprecationWarning)
        return self._logger.log(*args, **kwargs)

    def debug(self, *args, **kwargs):
        """Logs a 'msg % args' with severity DEBUG."""
        return self.log(logging.DEBUG, *args, **kwargs)

    def info(self, *args, **kwargs):
        """Logs a 'msg % args' with severity INFO."""
        return self.log(logging.INFO, *args, **kwargs)

    def warning(self, *args, **kwargs):
        """Logs a 'msg % args' with severity WARNING."""
        return self.log(logging.WARNING, *args, **kwargs)

    warn = warning

    def error(self, *args, **kwargs):
        """Logs a 'msg % args' with severity ERROR."""
        return self.log(logging.ERROR, *args, **kwargs)

    def critical(self, *args, **kwargs):
        """Logs a 'msg % args' with severity CRITICAL."""
        return self.log(logging.CRITICAL, *args, **kwargs)

    fatal = critical

    def exception(self, *args, **kwargs):
        """
        Log a 'msg % args' with severity ERROR, with the backtrace from
        the last exception raised.
        """

        # log the the most recent exception
        kwargs['exc_info'] = True

        # the logger requires a message, so add a very dull one if none
        # was provided. (often, it's useful to just log the exception.)
        if not len(args):
            args = ("An exception occurred",)

        return self.error(*args, **kwargs)

    # backwards-compatibility
    log_last_exception = exception

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from nose.tools import assert_equals, assert_raises, nottest
from ..log.mixin import LoggerMixin


class LoggableStub(object, LoggerMixin):
    pass


# Warnings are captured by the logging handler in Django 1.5+.
# Since this is being deprecated, I'm just going to disable this test. It'll
# be removed in the next release.
@nottest
def test_logger_mixin():
    obj = LoggableStub()

    from logging.handlers import MemoryHandler
    import logging

    log = logging.getLogger()
    handler = MemoryHandler(999)
    log.setLevel(logging.DEBUG)
    log.addHandler(handler)

    obj.debug("This is a DEBUG message")
    obj.info("This is an INFORMATIVE message")
    obj.warning("This is a WARNING")
    obj.error("This is an ERROR")
    obj.critical("This is a CRITICAL error")
    obj.exception("This is an exception")
    obj.exception()

    # There should be 8 messages: 7 from above, plus
    # one more for LoggerMixin's own deprecation warning
    assert_equals(len(handler.buffer), 7 + 1)
    assert_equals(handler.buffer[3].name, "loggablestub")
    assert_equals(handler.buffer[3].msg, "This is a WARNING")

    log.removeHandler(handler)


def test_logger_raises_on_invalid_name_type():
    class BrokenLoggableStub(object, LoggerMixin):
        def _logger_name(self):
            return 123

    broken_logger = BrokenLoggableStub()

    assert_raises(
        TypeError,
        broken_logger.debug,
        "This shouldn't work")

########NEW FILE########
__FILENAME__ = update_apps
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.core.management.base import NoArgsCommand
from rapidsms.models import App
from rapidsms.apps.base import AppBase
from ...conf import settings


class Command(NoArgsCommand):
    help = "Creates instances of the App model stub for all running apps."

    def handle_noargs(self, **options):
        verbosity = int(options.get("verbosity", 1))

        # fetch all of the apps (identified by their module name,
        # which is unique) that we already have objects for
        known_module_names = list(App.objects.values_list("module", flat=True))

        # find any running apps which currently
        # don't have objects, and fill in the gaps
        for module_name in settings.INSTALLED_APPS:
            if not module_name in known_module_names:
                # Assure the module is a rapidsms app with an App class
                if AppBase.find(module_name):
                    known_module_names.append(module_name)
                    app = App.objects.create(
                        module=module_name)

                    # log at the same level as syncdb's "created table..."
                    # messages, to stay silent when called with -v 0
                    if verbosity >= 1:
                        print "Added persistant app %s" % app

########NEW FILE########
__FILENAME__ = update_backends
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.core.management.base import NoArgsCommand
from rapidsms.models import Backend
from ...conf import settings


class Command(NoArgsCommand):
    help = "Creates an instance of the Backend model stub for each " +\
        "running backend."

    def handle_noargs(self, **options):
        verbosity = int(options.get("verbosity", 1))

        # fetch all of the backends (identified by their
        # name) that we already have instances for
        known_backend_names = list(
            Backend.objects.values_list("name", flat=True)
        )

        # find any running backends which currently
        # don't have instances, and fill in the gaps
        for name in settings.INSTALLED_BACKENDS:
            if not name in known_backend_names:
                known_backend_names.append(name)
                backend = Backend.objects.create(
                    name=name)

                # log at the same level as syncdb's "created table..."
                # messages, to stay silent when called with -v 0
                if verbosity >= 1:
                    print "Added persistant backend %s" % backend

########NEW FILE########
__FILENAME__ = base
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import copy
from uuid import uuid4
import warnings


class MessageBase(object):
    """Basic message representation with text and connection(s)."""

    def __init__(self, connections=None, text=None, id_=None,
                 in_response_to=None, fields=None,
                 connection=None):  # old deprecated parameter
        # Allow and cope with old 'connection' argument but issue a warning
        if connections is None and connection is not None:
            connections = [connection]
            connection = None
            warnings.warn("Message(connection=) is deprecated, please start "
                          "using .connections", DeprecationWarning)
        if connection is not None:
            raise TypeError("Do not pass both `connections` and `connection`"
                            "to MessageBase.__init__(), just `connections`")

        # had to make `text` optional so we could make connections optional,
        # but it really is required
        if text is None:
            raise TypeError("MessageBase.__init__ did not get required "
                            "argument `text`")
        #: a unique ID for this message
        self.id = id_ or self.generate_id()
        #: The connections this message was received from or sent to. A
        #: list of :py:class:`~rapidsms.models.Connection`
        self.connections = connections
        #: the message
        self.text = text
        #: save original text for future reference
        self.raw_text = copy.copy(self.text)
        #: fields can be used to pass along arbitrary metadata
        self.fields = fields or {}
        #: link back to original message if this is a response
        self.in_response_to = in_response_to
        #: a message is considered "unprocessed" until rapidsms has
        #: dispatched it to all apps.
        self.processed = False
        #: a message can be marked "handled" by any app, which will
        #: short-circuit the default phase in the router.
        self.handled = False

    def __unicode__(self):
        return self.text

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.text)

    @staticmethod
    def generate_id():
        """Create a random unique ID for this message object."""
        return uuid4().get_hex()

    @property
    def connection(self):
        """The first :py:class:`~rapidsms.models.Connection` - `deprecated`.
        """
        warnings.warn("MessageBase.connection is deprecated; please start using .connections", DeprecationWarning)
        return self.connections[0]

    @property
    def contact(self):
        """The first connection's :py:class:`~rapidsms.models.Contact`
        - `deprecated`
        """
        warnings.warn("MessageBase.contact is deprecated; please start using .connections[i].contact", DeprecationWarning)
        return self.connections[0].contact

    @property
    def peer(self):
        """
        Return the identity (eg. a phone number, email address, irc
        nickname) on the other end of this message. But you shouldn't
        use this method. It only seems to encourage people to ignore the
        distinction between backends and identities, and create fields
        like "mobile_number", which is all kinds of wrong.
        `deprecated`
        """
        warnings.warn("MessageBase.peer is deprecated; please access the needed data directly.")
        return self.connections[0].identity

########NEW FILE########
__FILENAME__ = error
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from rapidsms.messages.outgoing import OutgoingMessage


class ErrorMessage(OutgoingMessage):
    pass

########NEW FILE########
__FILENAME__ = incoming
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.utils.timezone import now
from rapidsms.messages.base import MessageBase
from rapidsms.messages.error import ErrorMessage


class IncomingMessage(MessageBase):
    """Inbound message that provides an API to handle responses.
    """

    def __init__(self, *args, **kwargs):
        if 'received_at' in kwargs:
            raise Exception("IncomingMessage.received_at is meaningless")
        super(IncomingMessage, self).__init__(*args, **kwargs)
        #: list of messages created by IncomingMessage.respond()
        self.responses = []

    @property
    def date(self):
        raise Exception("IncomingMessage.date is meaningless")

    def respond(self, text, **kwargs):
        """
        Respond to this message, sending the given text to the connections
        that this message came from.

        Responses are saved, and sent after incoming processing phases are
        complete.

        Arbitrary arguments are passed along to the
        :py:meth:`~rapidsms.router.send` method.

        :param string text: The text of the message
        :param connections: (optional) send to a different set of connections
            than were in the incoming message.
        :type connections: list of :py:class:`~rapidsms.models.Connection`
        :param in_response_to: (optional) the message being responded to.
        :type in_response_to: :py:class:`~rapidsms.messages.base.MessageBase`
        :returns: dictionary with the arguments that will be passed to
            :py:meth:`rapidsms.router.send` to send this response.
        """
        if 'template' in kwargs:
            raise TypeError("`template` is no longer valid usage for "
                            "respond().  Pass the message text as `text`.")

        context = {'text': text,
                   'connections': self.connections,
                   'in_response_to': self}
        context.update(kwargs)
        self.responses.append(context)
        return context

    def error(self, text, **kwargs):
        return self.respond(class_=ErrorMessage, text=text, **kwargs)

########NEW FILE########
__FILENAME__ = outgoing
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.utils.timezone import now
from rapidsms.messages.base import MessageBase


class OutgoingMessage(MessageBase):
    """Outbound message that can easily be sent to the router.
    """

    def __init__(self, *args, **kwargs):
        self.received_at = kwargs.pop('sent_at', now())
        if 'sent_at' in kwargs:
            raise Exception("OutgoingMessage.sent_at is meaningless")
        super(OutgoingMessage, self).__init__(*args, **kwargs)

    @property
    def sent_at(self):
        raise Exception("OutgoingMessage.sent_at is meaningless")

    @property
    def sent(self):
        raise Exception("OutgoingMessage.sent is meaningless")

    @property
    def date(self):
        raise Exception("OutgoingMessage.date is meaningless")

    def extra_backend_context(self):
        """Specific metadata to be included when passed to backends."""
        context = {}
        if self.in_response_to:
            original = self.in_response_to
            context['in_response_to'] = original.id
            if 'external_id' in original.fields:
                context['external_id'] = original.fields['external_id']
        return context

    def send(self):
        """Send the message.  Equivalent to
        ``rapidsms.router.send(text, connections)``.
        """
        from rapidsms.router import send
        send(self.text, self.connection)
########NEW FILE########
__FILENAME__ = tests
from rapidsms.messages.base import MessageBase
from rapidsms.messages.incoming import IncomingMessage
from rapidsms.messages.outgoing import OutgoingMessage
from rapidsms.tests.harness import RapidTest


class MessagesTest(RapidTest):

    disable_phases = True

    def test_message_id(self):
        """All message objects should have IDs."""
        connections = [self.create_connection()]
        msg = MessageBase(text="test", connections=connections)
        self.assertIsNotNone(msg.id)
        msg = IncomingMessage(text="test", connections=connections)
        self.assertIsNotNone(msg.id)
        msg = OutgoingMessage(text="test", connections=connections)
        self.assertIsNotNone(msg.id)

    def test_saved_message_fields(self):
        """Extra data should be attached to IncomingMessage."""
        connection = self.create_connection()
        fields = {'extra-field': 'extra-value'}
        message = IncomingMessage(connection, 'test incoming message',
                                  fields=fields)
        self.assertIn('extra-field', message.fields)
        self.assertEqual(message.fields['extra-field'], fields['extra-field'])

    def test_outgoing_message_link(self):
        """Extra data should be attached to response (OutgoingMessage)."""
        connection = self.create_connection()
        fields = {'extra-field': 'extra-value'}
        message = IncomingMessage(connection, 'test incoming message',
                                  fields=fields)
        response = message.respond('response')
        self.assertEqual(message, response['in_response_to'])
        self.assertIn('extra-field', response['in_response_to'].fields)

    def test_outgoing_message_send(self):
        """OutgoingMessage.send should use send() API correctly"""
        message = self.create_outgoing_message()
        message.send()
        self.assertEqual(self.outbound[0].text, message.text)

    def test_response_context(self):
        """
        InboundMessage responses should contain proper context for
        creating OutboundMessages by the router.
        """
        inbound_message = self.create_incoming_message()
        inbound_message.respond('test1')
        inbound_message.respond('test2')
        self.assertEqual(2, len(inbound_message.responses))
        response1 = inbound_message.responses[0]
        self.assertEqual("test1", response1['text'])
        self.assertEqual(inbound_message.connections, response1['connections'])
        # reply_to should reference original message
        self.assertEqual(inbound_message, response1['in_response_to'])

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Backend'
        db.create_table(u'rapidsms_backend', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=20)),
        ))
        db.send_create_signal(u'rapidsms', ['Backend'])

        # Adding model 'App'
        db.create_table(u'rapidsms_app', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('module', self.gf('django.db.models.fields.CharField')(unique=True, max_length=100)),
            ('active', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal(u'rapidsms', ['App'])

        # Adding model 'Contact'
        db.create_table(u'rapidsms_contact', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=100, blank=True)),
            ('language', self.gf('django.db.models.fields.CharField')(max_length=6, blank=True)),
        ))
        db.send_create_signal(u'rapidsms', ['Contact'])

        # Adding model 'Connection'
        db.create_table(u'rapidsms_connection', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('backend', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['rapidsms.Backend'])),
            ('identity', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('contact', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['rapidsms.Contact'], null=True, blank=True)),
        ))
        db.send_create_signal(u'rapidsms', ['Connection'])

        # Adding unique constraint on 'Connection', fields ['backend', 'identity']
        db.create_unique(u'rapidsms_connection', ['backend_id', 'identity'])


    def backwards(self, orm):
        # Removing unique constraint on 'Connection', fields ['backend', 'identity']
        db.delete_unique(u'rapidsms_connection', ['backend_id', 'identity'])

        # Deleting model 'Backend'
        db.delete_table(u'rapidsms_backend')

        # Deleting model 'App'
        db.delete_table(u'rapidsms_app')

        # Deleting model 'Contact'
        db.delete_table(u'rapidsms_contact')

        # Deleting model 'Connection'
        db.delete_table(u'rapidsms_connection')


    models = {
        u'rapidsms.app': {
            'Meta': {'object_name': 'App'},
            'active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'module': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'})
        },
        u'rapidsms.backend': {
            'Meta': {'object_name': 'Backend'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '20'})
        },
        u'rapidsms.connection': {
            'Meta': {'unique_together': "(('backend', 'identity'),)", 'object_name': 'Connection'},
            'backend': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Backend']"}),
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Contact']", 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identity': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'rapidsms.contact': {
            'Meta': {'object_name': 'Contact'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '6', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100', 'blank': 'True'})
        }
    }

    complete_apps = ['rapidsms']
########NEW FILE########
__FILENAME__ = 0002_auto__add_field_contact_created_on__add_field_contact_modified_on__add
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from django.utils.timezone import now


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'Contact.created_on'
        db.add_column(u'rapidsms_contact', 'created_on',
                      self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, default=now(), blank=True),
                      keep_default=False)

        # Adding field 'Contact.modified_on'
        db.add_column(u'rapidsms_contact', 'modified_on',
                      self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=now(), blank=True),
                      keep_default=False)

        # Adding field 'Connection.created_on'
        db.add_column(u'rapidsms_connection', 'created_on',
                      self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, default=now(), blank=True),
                      keep_default=False)

        # Adding field 'Connection.modified_on'
        db.add_column(u'rapidsms_connection', 'modified_on',
                      self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=now(), blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Deleting field 'Contact.created_on'
        db.delete_column(u'rapidsms_contact', 'created_on')

        # Deleting field 'Contact.modified_on'
        db.delete_column(u'rapidsms_contact', 'modified_on')

        # Deleting field 'Connection.created_on'
        db.delete_column(u'rapidsms_connection', 'created_on')

        # Deleting field 'Connection.modified_on'
        db.delete_column(u'rapidsms_connection', 'modified_on')


    models = {
        u'rapidsms.app': {
            'Meta': {'object_name': 'App'},
            'active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'module': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '100'})
        },
        u'rapidsms.backend': {
            'Meta': {'object_name': 'Backend'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '20'})
        },
        u'rapidsms.connection': {
            'Meta': {'unique_together': "(('backend', 'identity'),)", 'object_name': 'Connection'},
            'backend': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Backend']"}),
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Contact']", 'null': 'True', 'blank': 'True'}),
            'created_on': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identity': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'modified_on': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        u'rapidsms.contact': {
            'Meta': {'object_name': 'Contact'},
            'created_on': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '6', 'blank': 'True'}),
            'modified_on': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100', 'blank': 'True'})
        }
    }

    complete_apps = ['rapidsms']
########NEW FILE########
__FILENAME__ = models
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.db import models
from .utils.modules import try_import, get_classes
from .conf import settings


class ExtensibleModelBase(models.base.ModelBase):
    def __new__(cls, name, bases, attrs):
        try:
            app_label = attrs['Meta'].app_label
        except KeyError:
            module_name = attrs["__module__"]
            app_label = module_name.split('.')[-2]
        extensions = _find_extensions(app_label, name)
        bases = tuple(extensions) + bases

        return super(ExtensibleModelBase, cls).__new__(
            cls, name, bases, attrs)


def _find_extensions(app_label, model_name):
    ext = []

    suffix = "extensions.%s.%s" % (
        app_label, model_name.lower())
    modules = filter(None, [
        try_import("%s.%s" % (app_name, suffix))
        for app_name in settings.INSTALLED_APPS])

    for module in modules:
        for cls in get_classes(module, models.Model):
            ext.append(cls)

    return ext


class Backend(models.Model):
    """
    This model isn't really a backend. Those are regular Python classes,
    in rapidsms/backends. This is just a stub model to provide a primary
    key for each running backend, so other models can be linked to it
    with ForeignKeys.
    """

    #: the name of the backend
    name = models.CharField(max_length=20, unique=True)

    def __unicode__(self):
        return self.name

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)


class App(models.Model):
    """
    This model isn't really a RapidSMS App. Like Backend, it's just a
    stub model to provide a primary key for each app, so other models
    can be linked to it.

    The Django ContentType stuff doesn't quite work here, since not all
    RapidSMS apps are valid Django apps. It would be nice to fill in the
    gaps and inherit from it at some point in the future.

    Instances of this model are generated by the update_apps management
    command, (which is hooked on Router startup (TODO: webui startup)),
    and probably shouldn't be messed with after that.
    """

    module = models.CharField(max_length=100, unique=True)
    active = models.BooleanField()

    def __unicode__(self):
        return self.module

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)


class ContactBase(models.Model):
    #: The individual's name (optional)
    name = models.CharField(max_length=100, blank=True)
    #: when the contact was created
    created_on = models.DateTimeField(auto_now_add=True)
    #: when the contact was last modified
    modified_on = models.DateTimeField(auto_now=True)

    #: The contact's preferred language.  the
    #: spec: http://www.w3.org/International/articles/language-tags/Overview
    #: reference: http://www.iana.org/assignments/language-subtag-registry
    language = models.CharField(max_length=6, blank=True,
                                help_text="The language which this contact "
                                "prefers to communicate in, as a W3C "
                                "language tag. If this field is left blank, "
                                "RapidSMS will default to: " +
                                settings.LANGUAGE_CODE)

    class Meta:
        abstract = True

    def __unicode__(self):
        return self.name or "Anonymous"

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)

    @property
    def is_anonymous(self):
        """Return True if the individual has no name"""
        return not self.name

    @property
    def default_connection(self):
        """
        Return the default connection for this person.  Currently this
        arbitrarily returns the first connection.
        """
        # TODO: this is defined totally arbitrarily for a future
        # sane implementation
        if self.connection_set.count() > 0:
            return self.connection_set.all()[0]
        return None


class Contact(ContactBase):
    """This model represents a person with a name
    """
    __metaclass__ = ExtensibleModelBase


class ConnectionBase(models.Model):
    #: foreign key to this connection's
    #: :py:class:`~rapidsms.backends.base.BackendBase`
    backend = models.ForeignKey(Backend)
    #: unique identifier for this connection on this backend (e.g. phone
    #: number, email address, IRC nick, etc.)
    identity = models.CharField(max_length=100)
    #: (optional) associated :py:class:`~rapidsms.models.Contact`
    contact = models.ForeignKey(Contact, null=True, blank=True)
    #: when this connection was created
    created_on = models.DateTimeField(auto_now_add=True)
    #: when this connection was last modified
    modified_on = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True
        unique_together = (('backend', 'identity'),)

    def __unicode__(self):
        return "%s via %s" %\
            (self.identity, self.backend)

    def __repr__(self):
        return '<%s: %s>' %\
            (type(self).__name__, self)


class Connection(ConnectionBase):
    """
    This model pairs a Backend object with an identity unique to it (eg.
    a phone number, email address, or IRC nick), so RapidSMS developers
    need not worry about which backend a messge originated from.
    """

    __metaclass__ = ExtensibleModelBase

########NEW FILE########
__FILENAME__ = api
import collections

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from rapidsms.models import Backend
from rapidsms.utils.modules import import_class


def get_router():
    """Return router defined by RAPIDSMS_ROUTER setting."""
    router = getattr(settings, 'RAPIDSMS_ROUTER',
                     'rapidsms.router.blocking.BlockingRouter')
    if isinstance(router, basestring):
        try:
            router = import_class(router)()
        except ImportError as e:
            raise ImproperlyConfigured(e)
    return router


def receive(text, connection, **kwargs):
    """
    Creates an incoming message and passes it to the router for processing.

    :param text: text message
    :param connection: RapidSMS :py:class:`~rapidsms.models.Connection` object
    :param kwargs: Extra kwargs to pass to
        :py:class:`~rapidsms.messages.incoming.IncomingMessage` constructor
    :returns: :py:class:`~rapidsms.messages.incoming.IncomingMessage`
        object constructed by router. A returned
        message object does not indicate that router processing has
        finished or even started, as this depends on the router defined
        in :setting:`RAPIDSMS_ROUTER`.
    :rtype: :py:class:`~rapidsms.messages.incoming.IncomingMessage`
    """
    router = get_router()
    message = router.new_incoming_message(connections=[connection], text=text,
                                          **kwargs)
    router.receive_incoming(message)
    return message


def send(text, connections, **kwargs):
    """
    Creates an outgoing message and passes it to the router to be processed
    and sent via the respective backend.

    Arbitrary arguments are passed along to
    :py:meth:`~rapidsms.router.blocking.BlockingRouter.new_outgoing_message`.

    :param text: text message
    :param connections: list or QuerySet of RapidSMS
        :py:class:`~rapidsms.models.Connection` objects
    :param kwargs: Extra kwargs to pass to
        :py:class:`~rapidsms.messages.outgoing.OutgoingMessage` constructor
    :returns: message constructed by router. A returned
              message object does not indicate that router processing has
              finished or even started, as this depends on the router defined
              in :setting:`RAPIDSMS_ROUTER`.
    :rtype: :py:class:`~rapidsms.messages.outgoing.OutgoingMessage`
    """
    if not isinstance(connections, collections.Iterable):
        connections = [connections]
    router = get_router()
    message = router.new_outgoing_message(text=text, connections=connections,
                                          **kwargs)
    router.send_outgoing(message)
    return message


def lookup_connections(backend, identities):
    """
    Find connections associated with backend and identities. A new connection
    object will be created for every backend/identity pair not found.

    :param backend: backend name (as a string) or
        :py:class:`~rapidsms.backends.base.BackendBase` object
    :param identities: list of identities to find associated with the backend
    :returns: List of :py:class:`~rapidsms.models.Connection` objects
    """
    if isinstance(backend, basestring):
        backend, _ = Backend.objects.get_or_create(name=backend)
    connections = []
    for identity in identities:
        connection, _ = backend.connection_set.get_or_create(identity=identity)
        connections.append(connection)
    return connections

########NEW FILE########
__FILENAME__ = router
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8

import logging
import warnings
import copy
from collections import defaultdict

from django.db.models.query import QuerySet

from rapidsms.messages.incoming import IncomingMessage
from rapidsms.messages.outgoing import OutgoingMessage
from rapidsms.backends.base import BackendBase
from rapidsms.apps.base import AppBase
from rapidsms.conf import settings
from rapidsms.errors import MessageSendingError


logger = logging.getLogger(__name__)


class BlockingRouter(object):
    """Base RapidSMS router implementation."""

    #: Incoming router phases processed in the order in which they're defined.
    incoming_phases = ("filter", "parse", "handle", "default", "cleanup")
    #: Outgoing router phases processed in the order in which they're defined.
    outgoing_phases = ("outgoing",)

    def __init__(self, *args, **kwargs):
        self.apps = []
        self.backends = {}
        apps = kwargs.pop('apps', settings.INSTALLED_APPS)
        backends = kwargs.pop('backends', settings.INSTALLED_BACKENDS)
        for name in apps:
            try:
                self.add_app(name)
            except Exception:
                logger.exception("Failed to add app to router.")
        for name, conf in backends.iteritems():
            parsed_conf = copy.copy(conf)
            engine = parsed_conf.pop('ENGINE')
            self.add_backend(name, engine, parsed_conf)

    def add_app(self, module_name):
        """
        Add RapidSMS app to router. Installed apps will be notified of
        incoming and outgoing messages. If ``module_name`` is a Django app,
        the method looks in ``app_name.app`` for an ``AppBase`` subclass to
        use.

        :param module_name: ``AppBase`` object or dotted path to RapidSMS app.
        :returns: ``AppBase`` object if found, otherwise ``None``.
        """
        if isinstance(module_name, basestring):
            cls = AppBase.find(module_name)
        elif issubclass(module_name, AppBase):
            cls = module_name
        if not cls:
            return None
        app = cls(self)
        self.apps.append(app)
        return app

    def get_app(self, module_name):
        """
        Access installed app by name.

        :param module_name: Dotted path to RapidSMS app.
        :returns: ``AppBase`` object if found, otherwise ``None``.
        """
        cls = AppBase.find(module_name)
        if cls is None:
            return None
        for app in self.apps:
            if type(app) == cls:
                return app
        raise KeyError("The %s app was not found in the router!" % module_name)

    def add_backend(self, name, module_name, config=None):
        """
        Add RapidSMS backend to router. Installed backends will be used to
        send outgoing messages.

        :param name: Name of backend.
        :param module_name: :class:`BackendBase <rapidsms.backends.base.BackendBase>`
                            object or dotted path to backend class.
        :returns: :class:`BackendBase <rapidsms.backends.base.BackendBase>`
                  object if found, otherwise a ``ValueError`` exception
                  will be raised.
        """
        if isinstance(module_name, basestring):
            cls = BackendBase.find(module_name)
        elif issubclass(module_name, BackendBase):
            cls = module_name
        if not cls:
            raise ValueError('No such backend "%s"' % module_name)
        config = self._clean_backend_config(config or {})
        backend = cls(self, name, **config)
        self.backends[name] = backend
        return backend

    @staticmethod
    def _clean_backend_config(config):
        """
        Return ``config`` (a dict) with the keys downcased. (This is
        intended to make the backend configuration case insensitive.)
        """

        return dict([
            (key.lower(), val)
            for key, val in config.iteritems()
        ])

    def receive_incoming(self, msg):
        """
        All inbound messages will be routed through ``receive_incoming``
        by :func:`send <rapidsms.router.send>`. ``receive_incoming`` is
        typically overridden in child routers to customize incoming message
        handling.

        :param msg: :class:`IncomingMessage <rapidsms.messages.incoming.IncomingMessage>` object
        """
        self.process_incoming(msg)

    def process_incoming(self, msg):
        """
        Process message through incoming phases and pass any generated
        responses to :func:`send <rapidsms.router.send>`. Called by
        ``receive_incoming``.

        :param msg: :class:`IncomingMessage <rapidsms.messages.incoming.IncomingMessage>` object
        """
        from rapidsms.router import send
        continue_processing = self.process_incoming_phases(msg)
        if continue_processing:
            for msg_context in msg.responses:
                send(**msg_context)

    def process_incoming_phases(self, msg):
        """
        Route message through each phase and installed app.

        :param msg: :class:`IncomingMessage <rapidsms.messages.incoming.IncomingMessage>` object
        :returns: ``True`` if inbound processing should continue.
        """
        # Note: this method can't ever return False, but some subclass might
        # override it and use that feature.
        logger.info("Incoming (%s): %s" % (msg.connection, msg.text))

        try:
            for phase in self.incoming_phases:
                logger.debug("In %s phase" % phase)

                if phase == "default":
                    if msg.handled:
                        logger.debug("Skipping phase")
                        break

                for app in self.apps:
                    logger.debug("In %s app" % app)
                    handled = False

                    func = getattr(app, phase)
                    handled = func(msg)

                    # during the _filter_ phase, an app can return True
                    # to abort ALL further processing of this message
                    if phase == "filter":
                        if handled is True:
                            logger.warning("Message filtered")
                            raise StopIteration

                    # during the _handle_ phase, apps can return True
                    # to "short-circuit" this phase, preventing any
                    # further apps from receiving the message
                    elif phase == "handle":
                        if handled is True:
                            logger.debug("Short-circuited")
                            # mark the message handled to avoid the
                            # default phase firing unnecessarily
                            msg.handled = True
                            break

                    elif phase == "default":
                        # allow default phase of apps to short circuit
                        # for prioritized contextual responses.
                        if handled is True:
                            logger.debug("Short-circuited default")
                            break

        except StopIteration:
            pass

        return True

    def send_outgoing(self, msg):
        """
        All outbound messages will be routed through ``send_outgoing``
        by :func:`receive <rapidsms.router.receive>`. ``send_outgoing`` is
        typically overridden in child routers to customize outgoing message
        handling.

        :param msg: :class:`OutgoingMessage <rapidsms.messages.outgoing.OutgoingMessage>` object
        """
        self.process_outgoing(msg)

    def process_outgoing(self, msg):
        """Process message through outgoing phases and pass to backend(s)."""
        logger.info("Outgoing: %s" % msg)
        continue_sending = self.process_outgoing_phases(msg)
        if continue_sending:
            self.backend_preparation(msg)

    def process_outgoing_phases(self, msg):
        """Process message through outgoing phases and apps."""
        for phase in self.outgoing_phases:
            logger.debug("Out %s phase" % phase)
            continue_sending = True
            # call outgoing phases in the opposite order of the incoming
            # phases, so the first app called with an incoming message
            # is the last app called with an outgoing message
            for app in reversed(self.apps):
                logger.debug("Out %s app" % app)
                try:
                    func = getattr(app, phase)
                    continue_sending = func(msg)
                except Exception:
                    logger.exception("Error while processing outgoing phase.")
                # during any outgoing phase, an app can return False to
                # abort ALL further processing of this message
                if continue_sending is False:
                    logger.warning("Message cancelled")
                    return False
        msg.processed = True
        return True

    def backend_preparation(self, msg):
        """
        Prepare message for backend processing. This includes grouping
        connections by backend and calling send_to_backend() with each group.
        """
        context = msg.extra_backend_context()
        grouped_identities = self.group_outgoing_identities(msg)
        for backend_name, identities in grouped_identities.iteritems():
            try:
                self.send_to_backend(backend_name, msg.id, msg.text,
                                     identities, context)
            except MessageSendingError:
                # This exception has already been logged in send_to_backend.
                # The blocking router doesn't have a mechanism to handle
                # errors, so we simply pass here and continue routing messages.
                pass

    def group_outgoing_identities(self, msg):
        """Return a dictionary of backend_name -> identities for a message."""
        grouped_identities = defaultdict(list)
        if isinstance(msg.connections, QuerySet):
            backend_names = msg.connections.values_list('backend__name',
                                                        flat=True)
            for backend_name in backend_names.distinct():
                identities = msg.connections.filter(backend__name=backend_name)
                identities = identities.values_list('identity', flat=True)
                grouped_identities[backend_name].extend(list(identities))
        else:
            for connection in msg.connections:
                backend_name = connection.backend.name
                identity = connection.identity
                grouped_identities[backend_name].append(identity)
        return grouped_identities

    def send_to_backend(self, backend_name, id_, text, identities, context):
        """Send message context to specified backend."""
        try:
            backend = self.backends[backend_name]
        except KeyError:
            msg = "Router is not configured with the %s backend" % backend_name
            logger.exception(msg)
            raise MessageSendingError(msg)
        try:
            backend.send(id_=id_, text=text, identities=identities,
                         context=context)
        except Exception:
            msg = "%s encountered an error while sending." % backend_name
            logger.exception(msg)
            raise MessageSendingError(msg)

    def new_incoming_message(self, text, connections, class_=IncomingMessage,
                             **kwargs):
        """
        Create and return a new incoming message. Called by
        :func:`send <rapidsms.router.send>`. Overridable by child-routers.

        :param text: Message text
        :param connections: List or QuerySet of ``Connection`` objects
        :param class_: Message class to instaniate
        :returns: :class:`IncomingMessage <rapidsms.messages.incoming.IncomingMessage>` object.
        """
        return class_(text=text, connections=connections,
                      **kwargs)

    def new_outgoing_message(self, text, connections, class_=OutgoingMessage,
                             **kwargs):
        """
        Create and return a new outgoing message. Called by
        :func:`receive <rapidsms.router.receive>`. Overridable by child-routers.

        :param text: Message text
        :param connections: List or QuerySet of ``Connection`` objects
        :param class_: Message class to instaniate
        :returns: :class:`OutgoingMessage <rapidsms.messages.outgoing.OutgoingMessage>` object.
        """
        return class_(text=text, connections=connections, **kwargs)

    def incoming(self, msg):
        """Legacy support for Router.incoming() -- Deprecated"""
        msg = "Router.incoming is deprecated. Please use receive_incoming."
        warnings.warn(msg, DeprecationWarning)
        self.receive_incoming(msg)

    def outgoing(self, msg):
        """Legacy support for Router.outgoing() -- Deprecated"""
        msg = "Router.outgoing is deprecated. Please use send_outgoing."
        warnings.warn(msg, DeprecationWarning)
        self.send_outgoing(msg)

########NEW FILE########
__FILENAME__ = test_app
from django.test import TestCase
from rapidsms.apps.base import AppBase
from rapidsms.router.blocking import BlockingRouter


class RouterAppTest(TestCase):
    """BlockingRouter app tests."""

    def setUp(self):
        self.router = BlockingRouter(apps=[], backends={})

    def test_valid_app_path(self):
        """Valid RapidSMS app modules should load properly."""
        app = self.router.add_app("rapidsms.contrib.default")
        self.assertTrue(app is not None)
        self.assertEquals(1, len(self.router.apps))

    def test_invalid_app_path(self):
        """Invalid RapidSMS app modules shouldn't raise any errors."""
        app = self.router.add_app('django.conrib.admin')
        self.assertTrue(app is None)

    def test_get_app_by_path(self):
        """get_app() returns loaded app matching the passed module."""
        app1 = self.router.add_app("rapidsms.contrib.default")
        app2 = self.router.get_app("rapidsms.contrib.default")
        self.assertEqual(app1, app2)

    def test_get_invalid_app_by_path(self):
        """get_app() returns None when loaded app is not found."""
        app = self.router.get_app("not.a.valid.app")
        self.assertTrue(app is None)

    def test_add_app_with_class(self):
        """add_app() should also accept a class."""
        self.router.add_app(AppBase)
        self.assertEquals(1, len(self.router.apps))

########NEW FILE########
__FILENAME__ = test_backend
from django.test import TestCase
from rapidsms.router.blocking import BlockingRouter
from rapidsms.backends.base import BackendBase
from rapidsms.tests.harness import RaisesBackend, CreateDataMixin
from rapidsms.errors import MessageSendingError


class RouterBackendTest(CreateDataMixin, TestCase):
    """BlockingRouter backend tests."""

    def setUp(self):
        self.router = BlockingRouter(apps=[], backends={})

    def test_valid_backend_path(self):
        """Valid RapidSMS backend modules should load properly."""
        backend = self.router.add_backend("backend",
                                          "rapidsms.backends.base.BackendBase")
        self.assertEquals(1, len(self.router.backends.keys()))
        self.assertEquals(backend, self.router.backends["backend"])

    def test_router_downcases_backend_configs(self):
        """Backend configuration should automatically be lowercased."""
        test_backend = "rapidsms.backends.base.BackendBase"
        test_conf = {"a": 1, "B": 2, "Cc": 3}
        backend = self.router.add_backend("backend", test_backend, test_conf)
        self.assertEquals(len(backend._config), 3)
        self.assertIn("a", backend._config)
        self.assertIn("b", backend._config)
        self.assertIn("cc", backend._config)
        self.assertNotIn("B", backend._config)
        self.assertNotIn("Cc", backend._config)

    def test_add_backend_class(self):
        """Router.add_backend should also accept a class."""
        self.router.add_backend("backend", BackendBase)
        self.assertEquals(1, len(self.router.backends.keys()))
        self.assertIn("backend", self.router.backends.keys())
        self.assertEquals("backend", self.router.backends['backend'].name)

    def test_router_not_configured_with_backend(self):
        """
        send_to_backend should raise MessageSendingError if backend
        hasn't been configured with the router.
        """
        args = ("missing-backend", "1234", "hello", ["1112223333"], {})
        self.assertRaises(MessageSendingError, self.router.send_to_backend,
                          *args)

    def test_backend_send_raises_error(self):
        """
        send_to_backend should capture all backend exceptions and raise the
        standard MessageSendingError.
        """
        backend = self.router.add_backend("backend", RaisesBackend)
        args = (backend.model.name, "1234", "hello", ["1112223333"], {})
        self.assertRaises(MessageSendingError, self.router.send_to_backend,
                          *args)

    def test_send_captures_exception(self):
        """BlockingRouter should catch exceptions during sending."""
        backend = self.router.add_backend("backend", RaisesBackend)
        msg = self.create_outgoing_message(backend=backend.model)
        try:
            self.router.send_outgoing(msg)
        except Exception:
            self.fail("send_outgoing should capture all excetpions.")

########NEW FILE########
__FILENAME__ = test_router
from django.test import TestCase
from django.test.utils import override_settings
from rapidsms.tests import harness
from rapidsms.router.blocking import BlockingRouter
from rapidsms.messages.incoming import IncomingMessage
from rapidsms.messages.outgoing import OutgoingMessage
from rapidsms.models import Connection


class BlockingRouterTest(harness.CreateDataMixin, TestCase):
    """Test router phases and message classes."""

    def setUp(self):
        self.router = BlockingRouter(apps=[], backends={})

    def test_router_incoming_phases(self):
        """Incoming messages should trigger proper router phases."""
        self.router.add_app(harness.MockApp)
        self.router.receive_incoming(self.create_incoming_message())
        self.assertEqual(set(self.router.apps[0].calls),
                         set(self.router.incoming_phases))

    def test_router_outgoing_phases(self):
        """Outgoing messages should trigger proper router phases."""
        self.router.add_app(harness.MockApp)
        self.router.add_backend("mockbackend", harness.MockBackend)
        backend = self.create_backend(data={'name': 'mockbackend'})
        connection = self.create_connection(data={'backend': backend})
        msg = self.create_outgoing_message(data={'connections': [connection]})
        self.router.send_outgoing(msg)
        self.assertEqual(set(self.router.apps[0].calls),
                         set(self.router.outgoing_phases))

    def test_new_incoming_message(self):
        """BaseRouter should return a standard IncomingMessage by default."""
        fields = {'foo': 'bar'}
        connection = self.create_connection()
        msg = self.router.new_incoming_message(text="foo",
                                               connections=[connection],
                                               fields=fields)
        self.assertTrue(isinstance(msg, IncomingMessage))
        self.assertEqual("foo", msg.text)
        self.assertEqual(connection, msg.connections[0])
        self.assertEqual(fields['foo'], msg.fields['foo'])

    def test_new_incoming_message_class(self):
        """Make sure you can customize the incoming message class."""
        class TestIncomingMessage(IncomingMessage):
            pass
        connection = self.create_connection()
        msg = self.router.new_incoming_message(text="foo",
                                               connections=[connection],
                                               class_=TestIncomingMessage)
        self.assertTrue(isinstance(msg, TestIncomingMessage))

    def test_new_outgoing_message(self):
        """BaseRouter should return a standard OutgoingMessage by default."""
        fields = {'foo': 'bar'}
        connection = self.create_connection()
        incoming_message = self.create_incoming_message()
        msg = self.router.new_outgoing_message(text="foo",
                                               connections=[connection],
                                               fields=fields,
                                               in_response_to=incoming_message)
        self.assertTrue(isinstance(msg, OutgoingMessage))
        self.assertEqual("foo", msg.text)
        self.assertEqual(connection, msg.connections[0])
        self.assertEqual(fields['foo'], msg.fields['foo'])
        self.assertEqual(incoming_message, msg.in_response_to)

    def test_new_outgoing_message_class(self):
        """Make sure you can customize the outgoing message class."""
        class TestOutgoingMessage(OutgoingMessage):
            pass
        connection = self.create_connection()
        msg = self.router.new_outgoing_message(text="foo",
                                               connections=[connection],
                                               class_=TestOutgoingMessage)
        self.assertTrue(isinstance(msg, TestOutgoingMessage))


class RouterOutgoingPhases(harness.RapidTest):
    """Test router outgoing phases."""

    apps = (harness.MockApp,)

    def test_outgoing_phase(self):
        """App.outgoing should be called for sent messages."""
        self.send('test', self.lookup_connections('1112223333'))
        app = self.router.apps[0]
        self.assertIn('outgoing', app.calls)

    def test_process_outgoing_phases_return_value(self):
        """
        Returning False from App.outgoing should cause
        Router.process_outgoing_phases() to return False as well.
        """
        self.router.apps[0].return_values['outgoing'] = False
        msg = self.create_outgoing_message()
        continue_sending = self.router.process_outgoing_phases(msg)
        self.assertFalse(continue_sending)

    def test_proccessed_flag_set(self):
        """
        BaseMessage.processed should be set to True after
        outgoing phase processing.
        """
        msg = self.create_outgoing_message()
        self.router.process_outgoing_phases(msg)
        self.assertTrue(msg.processed)

    def test_return_value(self):
        """
        Returning False from App.outgoing should prevent messages
        being passed to the backends.
        """
        self.router.apps[0].return_values['outgoing'] = False
        self.send('test', self.lookup_connections('1112223333'))
        self.assertEqual(0, len(self.sent_messages))

    def test_outgoing_exception(self):
        """App exceptions shouldn't halt message processing."""
        def outgoing_exception(message):
            raise Exception("Error!")
        self.router.apps[0].outgoing = outgoing_exception
        self.send('test', self.lookup_connections('1112223333'))
        self.assertEqual(1, len(self.sent_messages))

    def test_single_connection_outgoing_message_count(self):
        """Single connection should only create 1 message."""
        identities = ['1112223333']
        self.send('test', self.lookup_connections(identities))
        self.assertEqual(1, len(self.sent_messages[0]['identities']))
        self.assertEqual(1, len(self.sent_messages))

    def test_multiple_connection_outgoing_message_count(self):
        """Multiple connections should only create 1 message."""
        identities = ['1112223333', '9998887777']
        self.send('test', self.lookup_connections(identities))
        self.assertEqual(2, len(self.sent_messages[0]['identities']))
        self.assertEqual(1, len(self.sent_messages))

    def test_group_outgoing_identities(self):
        """group_outgoing_identities() should group connections by backend."""
        mockbackend_connections = self.lookup_connections([1112223333])
        other_connections = self.lookup_connections([2223334444, 9998887777],
                                                    backend='other')
        connections = mockbackend_connections + other_connections
        msg = self.create_outgoing_message(data={'connections': connections})
        grouped_identities = self.router.group_outgoing_identities(msg)
        self.assertEqual(2, len(grouped_identities.keys()))
        self.assertEqual(1, len(grouped_identities['mockbackend']))
        self.assertEqual(2, len(grouped_identities['other']))


class OutgoingQuerysetTest(harness.RapidTest):

    apps = (harness.MockApp,)

    def setUp(self):
        self.conn1 = self.create_connection(data={'identity': '1112223333'})
        self.conn2 = self.create_connection(data={'identity': '9998887777'})
        self.conns = Connection.objects.all()

    def test_group_does_not_contain_embedded_lists(self):
        """Using QuerySets should return a flat list of identities."""

        msg = self.create_outgoing_message(data={'connections': self.conns})
        grouped_identities = self.router.group_outgoing_identities(msg)
        backend_name = self.conn1.backend.name
        self.assertEqual(grouped_identities[backend_name][0],
                         self.conn1.identity)

    def test_distinct_grouping(self):
        """Connections should be grouped by backend name only once."""

        # create second connection using the same backend
        self.create_connection(data={'identity': '77766655555',
                                     'backend': self.conn1.backend})
        self.conns = Connection.objects.all()
        msg = self.create_outgoing_message(data={'connections': self.conns})
        grouped_identities = self.router.group_outgoing_identities(msg)
        backend_name = self.conn1.backend.name
        self.assertEqual(len(grouped_identities[backend_name]), 2)


class ExternalIDTest(harness.DatabaseBackendMixin, TestCase):

    def test_in_response_to_external_id(self):
        """BlockingRouter should maintain external_id through responses."""
        with override_settings(INSTALLED_APPS=[harness.EchoApp]):
            connection = self.lookup_connections(['1112223333'])[0]
            msg = self.receive("test", connection,
                               fields={'external_id': 'ABCD1234'})
            backend_msg = self.sent_messages[0]
            self.assertEqual(msg.fields['external_id'],
                             backend_msg.external_id)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = router
import logging

from rapidsms.router.blocking import BlockingRouter
from rapidsms.router.celery.tasks import receive_async, send_async


logger = logging.getLogger(__name__)


class CeleryRouter(BlockingRouter):
    """Skeleton router only used to execute the Celery task."""

    def is_eager(self, backend_name):
        """Return whether this backend is eager, meaning it runs
        tasks synchronously rather than queueing them to celery.

        A backend configures its eagerness by setting the backend
        configuration value ``router.celery.eager`` to True or
        False. The default is False.
        """
        try:
            backend = self.backends[backend_name]
        except KeyError:
            return False
        return backend._config.get('router.celery.eager', False)

    def receive_incoming(self, msg):
        """Queue incoming message to be processed in the background."""
        eager = self.is_eager(msg.connection.backend.name)
        if eager:
            logger.debug('Executing in current process')
            receive_async(msg.text, msg.connections[0].pk, msg.id,
                          msg.fields)
        else:
            logger.debug('Executing asynchronously')
            receive_async.delay(msg.text, msg.connections[0].pk, msg.id,
                                msg.fields)

    def backend_preparation(self, msg):
        """Queue outbound message to be processed in the background."""
        context = msg.extra_backend_context()
        grouped_identities = self.group_outgoing_identities(msg)
        for backend_name, identities in grouped_identities.iteritems():
            eager = self.is_eager(backend_name)
            if eager:
                logger.debug('Executing in current process')
                send_async(backend_name, msg.id, msg.text, identities,
                           context)
            else:
                logger.debug('Executing asynchronously')
                send_async.delay(backend_name, msg.id, msg.text, identities,
                                 context)

########NEW FILE########
__FILENAME__ = tasks
import celery
from celery.utils.log import get_task_logger
from rapidsms.errors import MessageSendingError


logger = get_task_logger(__name__)


@celery.task
def receive_async(text, connection_id, message_id, fields):
    """Task used to send inbound message through router phases."""
    from rapidsms.models import Connection
    from rapidsms.router import get_router
    logger.debug('receive_async: %s' % text)
    router = get_router()
    # reconstruct incoming message
    connection = Connection.objects.select_related().get(pk=connection_id)
    message = router.new_incoming_message(text=text, connections=[connection],
                                          id_=message_id, fields=fields)
    try:
        # call process_incoming directly to skip receive_incoming
        router.process_incoming(message)
    except Exception:
        logger.exception("Exception processing incoming message")
        raise


@celery.task
def send_async(backend_name, id_, text, identities, context):
    """Task used to send outgoing messages to backends."""
    logger.debug('send_async: %s' % text)
    from rapidsms.router import get_router
    router = get_router()
    try:
        router.send_to_backend(backend_name=backend_name, id_=id_, text=text,
                               identities=identities, context=context)
    except MessageSendingError:
        # This exception has already been logged in send_to_backend.
        # We'll simply pass here and not re-raise or log the exception again.
        pass

########NEW FILE########
__FILENAME__ = tests
from mock import patch

from django.test import TestCase
from django.test.utils import override_settings

from rapidsms.tests import harness
from rapidsms.router import get_router
from rapidsms.router.celery.tasks import receive_async, send_async


class CeleryRouterTest(harness.DatabaseBackendMixin, TestCase):
    """Tests for the CeleryRouter proxy class"""

    router_class = 'rapidsms.router.celery.CeleryRouter'

    def test_incoming(self):
        """Make sure the proper fields are passed to receive_async."""
        with patch.object(receive_async, 'delay') as mock_method:
            connections = self.lookup_connections(['1112223333'])
            msg = self.receive("test", connections[0], fields={'a': 'b'})
        mock_method.assert_called_once_with(msg.text, msg.connections[0].id,
                                            msg.id, msg.fields)

    def test_outgoing(self):
        """send() should preserve all message context."""
        connection = self.lookup_connections(['1112223333'])[0]
        msg = self.send("test", connection)
        backend_msg = self.sent_messages[0]
        self.assertEqual(msg.id, backend_msg.message_id)
        self.assertEqual(msg.text, backend_msg.text)
        self.assertEqual(msg.connections[0].identity, backend_msg.identity)

    def test_in_response_to_external_id(self):
        """CeleryRouter should maintain external_id through responses."""
        with override_settings(INSTALLED_APPS=[harness.EchoApp]):
            connection = self.lookup_connections([1112223333])[0]
            msg = self.receive("test", connection,
                               fields={'external_id': 'ABCD1234'})
            backend_msg = self.sent_messages[0]
            self.assertEqual(msg.fields['external_id'],
                             backend_msg.external_id)

    def test_send_async_catches_error(self):
        """send_async should capture sending exceptions properly."""
        backends = {'backend': {'ENGINE': harness.RaisesBackend}}
        with override_settings(INSTALLED_BACKENDS=backends):
            try:
                send_async("backend", "1234", "hello", ["1112223333"], {})
            except:
                self.fail("Sending exceptions should be caught within task")


class CeleryRouterConfigTest(harness.CustomRouterMixin, TestCase):

    router_class = 'rapidsms.router.celery.CeleryRouter'

    def test_eager_invalid_backend(self):
        """is_eager should return False if backend doesn't exist."""
        self.backends = {'mockbackend': {'ENGINE': harness.MockBackend}}
        self.set_backends()
        router = get_router()
        self.assertFalse(router.is_eager('foo'))

    def test_eager_not_set(self):
        """is_eager should return False if not set for specified backend."""
        self.backends = {'mockbackend': {'ENGINE': harness.MockBackend}}
        self.set_backends()
        router = get_router()
        self.assertFalse(router.is_eager('mockbackend'))

    def test_outgoing(self):
        """is_eager should return True if router.celery.eager is set."""
        self.backends = {'mockbackend': {'ENGINE': harness.MockBackend,
                                         'router.celery.eager': True}}
        self.set_backends()
        router = get_router()
        self.assertTrue(router.is_eager('mockbackend'))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from rapidsms.router.db.models import Message, Transmission


class MessageAdmin(admin.ModelAdmin):
    search_fields = ('text',)
    list_display = ('id', 'date', 'direction', 'text', 'status', 'updated',
                    'sent', 'delivered')
    list_filter = ('direction', 'status',)
    ordering = ('-updated',)


class TransmissionAdmin(admin.ModelAdmin):
    list_display = ('id', 'date', 'message', 'status', 'connection', 'updated',
                    'sent', 'delivered')
    ordering = ('-updated',)
    list_filter = ('status',)
    raw_id_fields = ('message', 'connection',)
    search_fields = ('message__text',)


admin.site.register(Message, MessageAdmin)
admin.site.register(Transmission, TransmissionAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Message'
        db.create_table(u'db_message', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('status', self.gf('django.db.models.fields.CharField')(default='Q', max_length=1, db_index=True)),
            ('date', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True, db_index=True, blank=True)),
            ('sent', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('delivered', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('direction', self.gf('django.db.models.fields.CharField')(max_length=1, db_index=True)),
            ('text', self.gf('django.db.models.fields.TextField')()),
            ('external_id', self.gf('django.db.models.fields.CharField')(max_length=1024, blank=True)),
            ('in_response_to', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='responses', null=True, to=orm['db.Message'])),
        ))
        db.send_create_signal(u'db', ['Message'])

        # Adding model 'Transmission'
        db.create_table(u'db_transmission', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('message', self.gf('django.db.models.fields.related.ForeignKey')(related_name='transmissions', to=orm['db.Message'])),
            ('connection', self.gf('django.db.models.fields.related.ForeignKey')(related_name='transmissions', to=orm['rapidsms.Connection'])),
            ('status', self.gf('django.db.models.fields.CharField')(max_length=1, db_index=True)),
            ('date', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, null=True, db_index=True, blank=True)),
            ('sent', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('delivered', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
        ))
        db.send_create_signal(u'db', ['Transmission'])


    def backwards(self, orm):
        # Deleting model 'Message'
        db.delete_table(u'db_message')

        # Deleting model 'Transmission'
        db.delete_table(u'db_transmission')


    models = {
        u'db.message': {
            'Meta': {'object_name': 'Message'},
            'date': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'delivered': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'direction': ('django.db.models.fields.CharField', [], {'max_length': '1', 'db_index': 'True'}),
            'external_id': ('django.db.models.fields.CharField', [], {'max_length': '1024', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'in_response_to': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'responses'", 'null': 'True', 'to': u"orm['db.Message']"}),
            'sent': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'default': "'Q'", 'max_length': '1', 'db_index': 'True'}),
            'text': ('django.db.models.fields.TextField', [], {}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'db_index': 'True', 'blank': 'True'})
        },
        u'db.transmission': {
            'Meta': {'object_name': 'Transmission'},
            'connection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'transmissions'", 'to': u"orm['rapidsms.Connection']"}),
            'date': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'delivered': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'transmissions'", 'to': u"orm['db.Message']"}),
            'sent': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'status': ('django.db.models.fields.CharField', [], {'max_length': '1', 'db_index': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'null': 'True', 'db_index': 'True', 'blank': 'True'})
        },
        u'rapidsms.backend': {
            'Meta': {'object_name': 'Backend'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '20'})
        },
        u'rapidsms.connection': {
            'Meta': {'unique_together': "(('backend', 'identity'),)", 'object_name': 'Connection'},
            'backend': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Backend']"}),
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['rapidsms.Contact']", 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identity': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        u'rapidsms.contact': {
            'Meta': {'object_name': 'Contact'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '6', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100', 'blank': 'True'})
        }
    }

    complete_apps = ['db']
########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.timezone import now

from rapidsms.models import Connection


DIRECTION_CHOICES = (
    ('I', "Incoming"),
    ('O', "Outgoing"),
)

STATUS_CHOICES = (
    ('Q', "Queued"),
    ('R', "Received"),
    ('P', "Processing"),
    ('S', "Sent"),
    ('D', "Delivered"),
    ('E', "Errored")
)


class Message(models.Model):
    #: Required. See :ref:`message-status-values`.
    status = models.CharField(max_length=1, choices=STATUS_CHOICES,
                              default='Q', db_index=True)
    #: Required. Date/time when message was created.
    date = models.DateTimeField(auto_now_add=True)
    #: Required. Last date/time the message was updated.
    updated = models.DateTimeField(auto_now=True, null=True, db_index=True)
    #: Date/time when all associated transmissions were sent.
    sent = models.DateTimeField(null=True, blank=True)
    #: Date/time when all associated transmissions were delivered (requires backend functionality).
    delivered = models.DateTimeField(null=True, blank=True)
    #: Required. Either ``'I'`` or ``'O'``.
    direction = models.CharField(max_length=1, choices=DIRECTION_CHOICES,
                                 db_index=True)
    #: Required. Message text.
    text = models.TextField()
    #: Optional. ID of message as defined by the associated backend.
    external_id = models.CharField(max_length=1024, blank=True)
    #: Optional. Foreign key to ``Message`` that generated this reply.
    in_response_to = models.ForeignKey('self', related_name='responses',
                                       null=True, blank=True)

    def set_status(self):
        if self.direction == 'O':
            if self.transmissions.filter(status='E').exists():
                self.status = 'E'
            elif self.transmissions.exclude(status__in=['S', 'D']).exists():
                self.status = 'P'
            elif self.transmissions.exclude(status__in=['D']).exists():
                self.status = 'S'
                self.sent = now()
            else:
                self.status = 'D'
                self.delivered = now()
        else:
            if self.transmissions.filter(status='E').exists():
                self.status = 'E'
            elif self.transmissions.exclude(status__in=['R']).exists():
                self.status = 'Q'
            else:
                self.status = 'R'
        self.updated = now()
        self.save()
        return self.status

    def __unicode__(self):
        return self.text[:60]


class Transmission(models.Model):
    #: Required. Foreign key to associated ``Message``.
    message = models.ForeignKey(Message, related_name='transmissions')
    #: Required. Foreign key to associated ``Connection``.
    connection = models.ForeignKey(Connection, related_name='transmissions')
    #: Required. See :ref:`message-status-values`.
    status = models.CharField(max_length=1, choices=STATUS_CHOICES,
                              db_index=True)
    #: Required. Date/time when transmission was created.
    date = models.DateTimeField(auto_now_add=True)
    #: Required. Last date/time when transmission was updated.
    updated = models.DateTimeField(auto_now=True, null=True, db_index=True)
    #: Date/time when transmission was sent.
    sent = models.DateTimeField(null=True, blank=True)
    #: Date/time when transmission was delivered (requires backend functionality).
    delivered = models.DateTimeField(null=True, blank=True)

    def __unicode__(self):
        return "%d: %s" % (self.pk, self.get_status_display())

########NEW FILE########
__FILENAME__ = router
from django.conf import settings
from django.db import transaction
from django.db.models import Q

from rapidsms.router.blocking import BlockingRouter
from rapidsms.router.db.tasks import receive_async, send_transmissions
from rapidsms.messages.incoming import IncomingMessage
from rapidsms.messages.outgoing import OutgoingMessage


class DatabaseRouter(BlockingRouter):

    def _default_batch_size(self):
        if hasattr(settings, 'DB_ROUTER_DEFAULT_BATCH_SIZE'):
            return settings.DB_ROUTER_DEFAULT_BATCH_SIZE
        return 200

    @transaction.commit_on_success
    def queue_message(self, direction, connections, text, fields=None):
        """Create Message and Transmission objects for messages."""
        from rapidsms.router.db.models import Message, Transmission
        kwargs = {'text': text, 'direction': direction}
        # save external_id in database
        if fields and 'external_id' in fields:
            kwargs['external_id'] = fields['external_id']
        dbm = Message.objects.create(**kwargs)
        transmissions = []
        for connection in connections:
            transmissions.append(Transmission(message=dbm, status='Q',
                                              connection=connection))
        Transmission.objects.bulk_create(transmissions)
        return dbm

    def new_incoming_message(self, connections, text, **kwargs):
        """Create and attach database message to message object."""
        msg = super(DatabaseRouter, self).new_incoming_message(connections,
                                                               text,
                                                               **kwargs)
        # save and attach database meessage to message object
        msg.dbm = self.queue_message("I", connections, text, **kwargs)
        # set id of message to the database message primary key
        msg.id = msg.dbm.pk
        return msg

    def receive_incoming(self, msg):
        """Queue message in DB for async inbound processing."""
        receive_async.delay(message_id=msg.id, fields=msg.fields)

    def group_transmissions(self, transmissions, batch_size=None):
        """Divide transmissions by backend and into manageable chunks.

        :param transmissions: A queryset of transmissions to send.

        :returns: A series of ``backend_id, batch`` pairs, where
           ``backend_id`` is the ID of a backend, and ``batch`` is
           a queryset of transmissions that all go with that
           backend, no more than ``batch_size`` each.
        """
        # divide transmissions by backend
        backends = transmissions.values_list('connection__backend_id',
                                             flat=True)
        for backend_id in backends.distinct():
            q = Q(connection__backend_id=backend_id)
            # filter down based on this backend and order by ID
            transmissions_group = transmissions.filter(q).order_by('id')

            start = 0
            if batch_size is None:
                batch_size = self._default_batch_size()
            end = batch_size

            while True:
                # divide transmissions into chunks of specified size
                batch = transmissions_group[start:end]
                if not batch.exists():
                    # query returned no rows, so we've seen all transmissions
                    break
                yield backend_id, batch
                start = end
                end += batch_size

    def backend_preparation(self, msg):
        """Queue message in DB rather than passing directly to backends."""
        # create queued message and associated transmissions
        dbm = self.queue_message("O", msg.connections, msg.text)
        # mark message as processing
        dbm.status = "P"
        # set in_response_to db field if available
        if msg.in_response_to and hasattr(msg.in_response_to, 'dbm'):
            dbm.in_response_to = msg.in_response_to.dbm
        dbm.save()
        for backend_id, trans in self.group_transmissions(dbm.transmissions):
            transmission_ids = list(trans.values_list('pk', flat=True))
            send_transmissions.delay(backend_id=backend_id,
                                     message_id=dbm.pk,
                                     transmission_ids=transmission_ids)

    def create_message_from_dbm(self, dbm, fields={}, fetch_connections=True):
        from rapidsms.models import Connection
        if fetch_connections:
            ids = dbm.transmissions.values_list('connection_id', flat=True)
            connections = Connection.objects.filter(id__in=list(ids))
        else:
            connections = []
        kwargs = {'connections': connections, 'text': dbm.text, 'id_': dbm.pk}
        if dbm.in_response_to:
            response = self.recreate_rapidsms_message(dbm.in_response_to,
                                                      fetch_connections)
            kwargs['in_response_to'] = response
        class_ = {'I': IncomingMessage, 'O': OutgoingMessage}[dbm.direction]
        msg = class_(**kwargs)
        msg.dbm = dbm
        msg.fields = fields
        return msg

########NEW FILE########
__FILENAME__ = tasks
import celery
from celery.utils.log import get_task_logger

from django.utils.timezone import now
from rapidsms.errors import MessageSendingError


__all__ = ('receive_async', 'send_transmissions')


logger = get_task_logger(__name__)


@celery.task
def receive_async(message_id, fields):
    """Retrieve message from DB and pass to BlockingRouter for processing."""
    from rapidsms.router.db.models import Message
    from rapidsms.router import get_router
    dbm = Message.objects.get(pk=message_id)
    router = get_router()
    message = router.create_message_from_dbm(dbm, fields)
    try:
        # call process_incoming directly to skip receive_incoming
        router.process_incoming(message)
    except Exception:
        logger.exception("Exception in router.process_incoming")
        dbm.transmissions.update(status='E', updated=now())
        dbm.set_status()
    if dbm.status != 'E':
        # mark message as being received
        dbm.transmissions.update(status='R', updated=now())
        dbm.set_status()


@celery.task
def send_transmissions(backend_id, message_id, transmission_ids):
    """Send message to backend with provided transmissions. Retry if failed."""
    from rapidsms.models import Backend
    from rapidsms.router.db.models import Message, Transmission
    from rapidsms.router import get_router
    backend = Backend.objects.get(pk=backend_id)
    dbm = Message.objects.select_related('in_response_to').get(pk=message_id)
    transmissions = Transmission.objects.filter(id__in=transmission_ids)
    # set (possibly reset) status to processing
    transmissions.update(status='P')
    identities = transmissions.values_list('connection__identity', flat=True)
    router = get_router()
    context = {}
    if dbm.in_response_to:
        context['external_id'] = dbm.in_response_to.external_id
    try:
        router.send_to_backend(backend_name=backend.name, id_=dbm.pk,
                               text=dbm.text, identities=list(identities),
                               context=context)
    except MessageSendingError as exc:
        # update database statuses, and re-execute this task
        logger.warning("Re-trying send_transmissions")
        Message.objects.filter(pk=message_id).update(status='E')
        transmissions.update(status='E', updated=now())
        raise send_transmissions.retry(exc=exc)
    # no error occured, so mark these transmissions as sent
    transmissions.update(status='S', sent=now())
    # we don't know if there are more transmissions pending, so
    # we always set the status at the end of each batch
    dbm.set_status()

########NEW FILE########
__FILENAME__ = tests
from mock import patch

from django.test import TestCase
from django.test.utils import override_settings

from rapidsms.models import Connection
from rapidsms.tests import harness
from rapidsms.router.db import DatabaseRouter
from rapidsms.router.db.models import Message, Transmission
from rapidsms.router.db.tasks import send_transmissions, receive_async


class MessageStatusTest(harness.CustomRouterMixin, TestCase):

    router_class = 'rapidsms.router.db.DatabaseRouter'

    def test_inbound_message_status_error(self):
        """Message should be E if transmissions are E."""
        dbm = Message.objects.create(text="test", direction="I")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='E')
        self.assertEqual('E', dbm.set_status())

    def test_inbound_message_status_queued(self):
        """Message should be Q if transmissions are Q."""
        dbm = Message.objects.create(text="test", direction="I")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='Q')
        self.assertEqual('Q', dbm.set_status())

    def test_inbound_message_status_received(self):
        """Message should be R if transmissions are R."""
        dbm = Message.objects.create(text="test", direction="I")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='R')
        self.assertEqual('R', dbm.set_status())

    def test_outbound_message_status_error(self):
        """Any transmission marked E means the message should be E."""
        dbm = Message.objects.create(text="test", direction="O")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='E')
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='S')
        self.assertEqual('E', dbm.set_status())

    def test_outbound_message_status_processing(self):
        """If transmissions aren't all sent or delivered, status shold be P."""
        dbm = Message.objects.create(text="test", direction="O")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='Q')
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='S')
        self.assertEqual('P', dbm.set_status())

    def test_outbound_message_status_sent(self):
        """If not all messages are delivered, then status should be S."""
        dbm = Message.objects.create(text="test", direction="O")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='S')
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='D')
        self.assertEqual('S', dbm.set_status())

    def test_outbound_message_status_delivered(self):
        """If all messages are delivered, then status should be S."""
        dbm = Message.objects.create(text="test", direction="O")
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='D')
        dbm.transmissions.create(connection=self.create_connection(),
                                 status='D')
        self.assertEqual('D', dbm.set_status())


@override_settings(INSTALLED_APPS=['rapidsms.contrib.echo'])
class DatabaseRouterReceiveTest(harness.CustomRouterMixin, TestCase):
    """Tests for the DatabaseRouter class"""

    router_class = 'rapidsms.router.db.DatabaseRouter'
    backends = {'mockbackend': {'ENGINE': harness.MockBackend}}

    def test_queue_status(self):
        """queue_message() should set the queued status."""
        router = DatabaseRouter()
        dbm = router.queue_message("I", [self.create_connection()], "foo")
        self.assertEqual("Q", dbm.status)
        transmission = dbm.transmissions.all()[0]
        self.assertEqual("Q", transmission.status)

    def test_queue_single_connection(self):
        """A single transmission should be created for 1 connection."""
        connections = [self.create_connection()]
        router = DatabaseRouter()
        dbm = router.queue_message("I", connections, "foo")
        self.assertEqual(1, dbm.transmissions.count())

    def test_queue_multi_connections(self):
        """Multiple transmissions should be created for > 1 connection."""
        connections = [self.create_connection(), self.create_connection()]
        router = DatabaseRouter()
        dbm = router.queue_message("I", connections, "foo")
        self.assertEqual(2, dbm.transmissions.count())

    def test_queue_queryset_connections(self):
        """queue_message() can accept a queryset of connections."""
        self.create_connection()
        self.create_connection()
        connections = Connection.objects.all()
        router = DatabaseRouter()
        dbm = router.queue_message("I", connections, "foo")
        self.assertEqual(2, dbm.transmissions.count())

    def test_receive(self):
        """receive() creates an inbound Message."""
        self.receive(text="foo", connection=self.create_connection())
        dbm = Message.objects.all()[0]
        self.assertEqual("foo", dbm.text)
        self.assertEqual("I", dbm.direction)
        self.assertEqual(1, dbm.transmissions.count())

    def test_receive_status(self):
        """Inbound messages should be marked with R if no errors occured."""
        self.receive(text="foo", connection=self.create_connection())
        dbm = Message.objects.all()[0]
        self.assertEqual("R", dbm.status)
        transmission = dbm.transmissions.all()[0]
        self.assertEqual("R", transmission.status)

    def test_receive_status_with_error(self):
        """Inbound messages should be marked with E if an error occured."""
        with override_settings(INSTALLED_APPS=[harness.ExceptionApp]):
            self.receive(text="foo", connection=self.create_connection())
            dbm = Message.objects.all()[0]
            self.assertEqual("E", dbm.status)
            transmission = dbm.transmissions.all()[0]
            self.assertEqual("E", transmission.status)

    def test_receive_message_id(self):
        """IncomingMessage.id should be set to the created database message."""
        msg = self.receive(text="foo", connection=self.create_connection())
        dbm = Message.objects.all()[0]
        self.assertEqual(msg.id, dbm.pk)

    def test_receive_external_id(self):
        """Router should save external_id to database for future reference."""
        fields = {'external_id': 'ASDF1234'}
        msg = self.receive(text="foo", connection=self.create_connection(),
                           fields=fields)
        dbm = Message.objects.all()[0]
        self.assertEqual("ASDF1234", msg.fields['external_id'])
        self.assertEqual("ASDF1234", dbm.external_id)

    def test_create_message_from_dbm(self):
        """Make sure the proper fields are passed through."""
        router = DatabaseRouter()
        dbm = router.queue_message(direction='I', text="foo",
                                   connections=[self.create_connection()])
        dbm2 = router.create_message_from_dbm(dbm, {'a': 'b'})
        self.assertEqual({'a': 'b'}, dbm2.fields)


@override_settings(INSTALLED_APPS=[harness.EchoApp])
class DatabaseRouterSendTest(harness.DatabaseBackendMixin, TestCase):
    """DatabaseRouter send tests."""

    router_class = 'rapidsms.router.db.DatabaseRouter'

    def create_trans(self, s1='Q', s2='Q'):
        Connection.objects.bulk_create((
            Connection(identity='1111111111', backend=self.backend),
            Connection(identity='2222222222', backend=self.backend),
            Connection(identity='3333333333', backend=self.backend),
            Connection(identity='4444444444', backend=self.backend),
        ))
        dbm = Message.objects.create(text="test", direction="O")
        for connection in Connection.objects.order_by('id')[:2]:
            dbm.transmissions.create(connection=connection, status=s1)
        for connection in Connection.objects.order_by('id')[2:]:
            dbm.transmissions.create(connection=connection, status=s2)
        ids = dbm.transmissions.order_by('id').values_list('id', flat=True)
        trans1 = dbm.transmissions.filter(id__in=ids[:2])
        trans2 = dbm.transmissions.filter(id__in=ids[2:])
        return self.backend, dbm, trans1, trans2

    def create_many_transmissions(self, num, backend=None):
        if not backend:
            backend = self.backend
        # Create a message that will be sent to many connections
        message = Message.objects.create(text="test", direction="O")
        for i in range(num):
            connection = Connection.objects.create(identity="%07d" % i,
                                                   backend=backend)
            message.transmissions.create(connection=connection, status="Q")

    def test_send_successful_status(self):
        """Transmissions should be marked with S if no errors occured."""
        # create 2 batches (queued, queued)
        backend, dbm, t1, t2 = self.create_trans(s1='Q', s2='Q')
        send_transmissions(backend.pk, dbm.pk, t1.values_list('id', flat=True))
        status = t1.values_list('status', flat=True).distinct()[0]
        self.assertEqual('S', status)

    def test_send_successful_message_status(self):
        """Message object should be updated if all transmissions were sent."""
        # create 2 batches (sent, queued)
        backend, dbm, t1, t2 = self.create_trans(s1='S', s2='Q')
        send_transmissions(backend.pk, dbm.pk, t2.values_list('id', flat=True))
        dbm = Message.objects.all()[0]
        self.assertEqual('S', dbm.status)

    def test_send_successful_message_status_previous_error(self):
        """Message should be marked E even if current batch sends."""
        # create 2 batches (error, queued)
        backend, dbm, t1, t2 = self.create_trans(s1='E', s2='Q')
        send_transmissions(backend.pk, dbm.pk, t2.values_list('id', flat=True))
        dbm = Message.objects.all()[0]
        self.assertEqual('E', dbm.status)

    def test_group_transmissions(self):
        """Transmissions should be grouped by batch_size."""
        # create 2 batches (queued, queued)
        backend, dbm, t1, t2 = self.create_trans(s1='Q', s2='Q')
        router = DatabaseRouter()
        trans = list(router.group_transmissions(Transmission.objects.all(),
                                                batch_size=2))
        _, batch1 = trans[0]
        _, batch2 = trans[1]
        self.assertEqual(list(batch1.values_list('id', flat=True)),
                         list(t1.values_list('id', flat=True)))
        self.assertEqual(list(batch2.values_list('id', flat=True)),
                         list(t2.values_list('id', flat=True)))

    def test_group_transmissions_different_backends(self):
        """Test grouping works across transmissions with different backends."""
        other_backend = self.create_backend(data={'name': 'other_backend'})
        self.create_many_transmissions(7)
        self.create_many_transmissions(6, backend=other_backend)
        router = DatabaseRouter()
        result = list(router.group_transmissions(Transmission.objects.all(),
                                                 batch_size=4))
        # 4 total batches
        self.assertEqual(4, len(result))
        # first two batches should be lenth 4 and 3 (=7)
        self.assertEqual(4, len(result[0][1]))
        self.assertEqual(3, len(result[1][1]))
        # second two batches should be lenth 4 and 2 (=6)
        self.assertEqual(4, len(result[2][1]))
        self.assertEqual(2, len(result[3][1]))

    def test_group_transmissions_default_batch_size(self):
        """Default max batch size is 200"""
        self.create_many_transmissions(201)
        router = DatabaseRouter()
        result = list(router.group_transmissions(Transmission.objects.all()))
        self.assertEqual(2, len(result))  # 2 batches
        self.assertEqual(200, len(result[0][1]))  # first batch has 200

    def test_group_transmissions_custom_default_batch_size(self):
        """Default max batch size can be configured in settings"""
        self.create_many_transmissions(3)
        router = DatabaseRouter()
        with self.settings(DB_ROUTER_DEFAULT_BATCH_SIZE=2):
            transmissions = Transmission.objects.all()
            result = list(router.group_transmissions(transmissions))
        self.assertEqual(2, len(result))  # 2 batches
        self.assertEqual(2, len(result[0][1]))  # first batch has 2

    def test_in_response_to(self):
        """Make sure responses set the in_response_to DB fields."""
        connection = self.lookup_connections(['1112223333'])[0]
        self.receive(text="ping", connection=connection)
        message = Message.objects.get(direction='I')
        response = Message.objects.get(direction='O')
        self.assertEqual(message.pk, response.in_response_to.pk)

    def test_in_response_to_external_id(self):
        """DatabaseRouter should maintain external_id through responses."""
        connection = self.lookup_connections(['1112223333'])[0]
        msg = self.receive("test", connection,
                           fields={'external_id': 'ABCD1234'})
        backend_msg = self.sent_messages[0]
        self.assertEqual(msg.fields['external_id'], backend_msg.external_id)

    def test_receive_async_fields(self):
        """Make sure the proper fields are passed to receive_async."""
        with patch.object(receive_async, 'delay') as mock_method:
            connections = self.lookup_connections(['1112223333'])
            msg = self.receive("test", connections[0], fields={'a': 'b'})
        mock_method.assert_called_once_with(message_id=msg.id,
                                            fields=msg.fields)

    # not sure how to test this...
    # def test_send_error(self):
    #     """Message should be marked E even if current batch sends."""
    #     backends = {'mockbackend': {'ENGINE': RaisesBackend}}
    #     with patch.object(send_transmissions, 'retry') as mock_method:
    #         with override_settings(INSTALLED_BACKENDS=backends):
    #             backend, dbm, t1, t2 = self.create_trans(s1='S', s2='Q')
    #             send_transmissions(backend.pk, dbm.pk,
    #                                t2.values_list('id', flat=True))
    #             status = t2.values_list('status', flat=True).distinct()[0]
    #             self.assertEqual('E', status)

########NEW FILE########
__FILENAME__ = router
"""Router that can be used for testing."""

from rapidsms.router.blocking import BlockingRouter


class TestRouter(BlockingRouter):
    """Router that saves inbound/outbound messages for future inspection.

    Inherits from :router:`BlockingRouter`.
    """

    def __init__(self, *args, **kwargs):

        #: List of all the inbound messages
        self.inbound = []

        #: List of all the outbound messages
        self.outbound = []

        self.disable_phases = kwargs.pop('disable_phases', False)
        super(TestRouter, self).__init__(*args, **kwargs)

    def receive_incoming(self, msg):
        """Save all inbound messages locally for test inspection"""
        self.inbound.append(msg)
        # short-circut router phases if disabled
        if self.disable_phases:
            return
        super(TestRouter, self).receive_incoming(msg)

    def send_outgoing(self, msg):
        """Save all outbound messages locally for test inspection"""
        self.outbound.append(msg)
        # short-circut router phases if disabled
        if self.disable_phases:
            return
        super(TestRouter, self).send_outgoing(msg)

########NEW FILE########
__FILENAME__ = test_api
from django.test.utils import override_settings
from django.core.exceptions import ImproperlyConfigured

from rapidsms.router import get_router, receive, send
from rapidsms.tests import harness
from rapidsms.messages.incoming import IncomingMessage
from rapidsms.messages.outgoing import OutgoingMessage


class MockRouter(object):
    """Dummy class used to test importing with get_router()"""
    pass


class RouterAPITest(harness.RapidTest):
    """Tests for rapidsms.router.api"""

    disable_phases = True

    def test_get_router(self):
        """Test exceptions for bad input given to get_router()"""
        bad_module_router = 'rapidsms.tests.router.bad_module.MockRouter'
        bad_class_router = 'rapidsms.tests.router.test_base.BadClassName'
        good_mock_router = 'rapidsms.router.test_api.MockRouter'
        with override_settings(RAPIDSMS_ROUTER=bad_module_router):
                self.assertRaises(ImproperlyConfigured, get_router)
        with override_settings(RAPIDSMS_ROUTER=bad_class_router):
                self.assertRaises(ImproperlyConfigured, get_router)
        with override_settings(RAPIDSMS_ROUTER=good_mock_router):
                self.assertTrue(isinstance(get_router(), MockRouter))

    def test_send_with_connection(self):
        """Send accepts a single connection."""
        connection = self.create_connection()
        message = send("echo hello", connection)
        self.assertEqual(message.connection.identity, connection.identity)
        self.assertEqual(message.connection.backend.name,
                         connection.backend.name)

    def test_send_with_connections(self):
        """Send accepts a list of connections."""
        connections = [self.create_connection(), self.create_connection()]
        message = send("echo hello", connections)
        self.assertEqual(len(message.connections), 2)
        self.assertEqual(message.connection.identity,
                         connections[0].identity)
        self.assertEqual(message.connection.backend.name,
                         connections[0].backend.name)

    def test_saved_message_fields_receive(self):
        """Extra data should persist through receive."""
        connection = self.create_connection()
        fields = {'extra-field': 'extra-value'}
        message = receive('test incoming message',
                          connection=connection, fields=fields)
        self.assertTrue('extra-field' in message.fields)
        self.assertEqual(message.fields['extra-field'], fields['extra-field'])

    def test_receive_message_class(self):
        """receive() should let you customize the incoming message class."""
        class TestIncomingMessage(IncomingMessage):
            pass
        msg = self.receive("echo hello", self.create_connection(),
                           class_=TestIncomingMessage)
        self.assertTrue(isinstance(msg, TestIncomingMessage))

    def test_send_message_class(self):
        """send() should let you customize the outgoing message class."""
        class TestIncomingMessage(OutgoingMessage):
            pass
        msg = self.send("hello", self.create_connection(),
                        class_=TestIncomingMessage)
        self.assertTrue(isinstance(msg, TestIncomingMessage))

########NEW FILE########
__FILENAME__ = settings
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

PROJECT_NAME = "RapidSMS"
PAGINATOR_OBJECTS_PER_PAGE = 12
PAGINATOR_BORDER_LINKS = 2
PAGINATOR_ADJACENT_LINKS = 2

########NEW FILE########
__FILENAME__ = forms_tags
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django import template
register = template.Library()


@register.inclusion_tag('rapidsms/templatetags/form.html')
def render_form(form):
    return {"form": form}

########NEW FILE########
__FILENAME__ = paginator_tags
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django import template
from django.core.exceptions import ImproperlyConfigured


register = template.Library()

# when this module is imported via {% load paginator_tags %}, it is
# imported as django.templatetags.paginator_tags, which prevents a
# relative import (..conf) to rapidsms from working here. in fact, that
# would import django.conf, so it will appear to be working, but per-app
# settings won't work! PAGINATOR_ defaults are in the ..settings module.
from rapidsms.conf import settings


if "django.core.context_processors.request" not in settings.TEMPLATE_CONTEXT_PROCESSORS:
    raise ImproperlyConfigured("To use paginator tag, add 'django.core.context_processors.request' to TEMPLATE_CONTEXT_PROCESSORS")


@register.inclusion_tag("rapidsms/templatetags/paginator.html", takes_context=True)
def paginator(context, page, prefix=""):
    """Paginator Template Tag

    Take a page from a paginator, creates links to relevant pages, and returns
    an HTML version of those links.  It links to the first
    ``rapidsms.settings.PAGINATOR_BORDER_LINKS``, last
    ``rapidsms.settings.PAGINATOR_BORDER_LINKS`` pages,
    and the ``rapidsms.settings.PAGINATOR_ADJACENT_LINKS`` pages around the
    current page.

    :param context: Template context
    :param page: Paginator page object representing the current page
    :param prefix: Prefix for the page GET parameter
    """

    dom_id = prefix + "paginator"
    page_param = prefix + "page"
    request = context["request"]

    def _link(page_number):
        return _self_link(request, **{page_param: page_number})

    def _page(number):
        return {
            "number": number,
            "link": _link(number),
            "active": (page.number == number)}

    #num_border_links represent the first N pages and last N pages in the paginator
    num_border_links = min(settings.PAGINATOR_BORDER_LINKS, page.paginator.num_pages)
    #num_adjacent_links represents the N pages around the current page
    num_adjacent_links = min(settings.PAGINATOR_ADJACENT_LINKS, page.paginator.num_pages)
    last_page_number = page.paginator.num_pages + 1

    pages = set([page.number])
    #first set of border links
    for p in range(1, num_border_links + 1):
        pages.add(p)
    #last border links
    for p in range(last_page_number - num_border_links, last_page_number):
        pages.add(p)
    #make sure that the adjacent links do not go outside of the page range
    first_adjacent = max(1, page.number - num_adjacent_links)
    last_adjacent = min(page.number + num_adjacent_links + 1, last_page_number)
    for p in range(first_adjacent, last_adjacent):
        pages.add(p)

    page_links = []
    pages = sorted(pages)
    for i in range(len(pages) - 1):
        page_links.append(_page(pages[i]))
        gap = pages[i + 1] - pages[i]
        if gap == 2:
            #if the ellipsis would only cover 1 page, add that page.
            page_links.append(_page(pages[i] + 1))
        elif gap > 2:
            #add an ellipsis when there is a gap in the pages.
            page_links.append(None)
    if pages:
        page_links.append(_page(pages[-1]))

    subcontext = {
        "dom_id":     dom_id,
        "page_links": page_links}

    if page.number > 1:
        subcontext.update({
            "prev_page_link":  _link(page.previous_page_number())})

    if page.number < page.paginator.num_pages:
        subcontext.update({
            "next_page_link":  _link(page.next_page_number())})

    return subcontext


def _self_link(request, **kwargs):
    new_kwargs = request.GET.copy()

    # build a new querydict using the GET params from the current
    # request, with those passed to this function overridden. we can't
    # use QueryDict.update here, since it APPENDS, rather than REPLACES.
    for k, v in kwargs.items():
        new_kwargs[k] = v

    kwargs_enc = new_kwargs.urlencode()
    return "%s?%s" % (request.path, kwargs_enc)

########NEW FILE########
__FILENAME__ = app
from rapidsms.apps.base import AppBase


class MockApp(AppBase):
    """A subclass of AppBase with all the moving parts replaced."""

    def __init__(self, *args, **kwargs):
        super(MockApp, self).__init__(*args, **kwargs)
        self.calls = []
        self.return_values = {}

    def start(self):
        self.calls.append("start")
        return self.return_values.get('start', None)

    def filter(self, message):
        self.calls.append("filter")
        return self.return_values.get('filter', None)

    def parse(self, message):
        self.calls.append("parse")
        return self.return_values.get('parse', None)

    def handle(self, message):
        self.calls.append("handle")
        return self.return_values.get('handle', None)

    def default(self, message):
        self.calls.append("default")
        return self.return_values.get('default', None)

    def cleanup(self, message):
        self.calls.append("cleanup")
        return self.return_values.get('cleanup', None)

    def outgoing(self, message):
        self.calls.append("outgoing")
        return self.return_values.get('outgoing', None)

    def stop(self):
        self.calls.append("stop")
        return self.return_values.get('stop', None)


class EchoApp(MockApp):
    """Barebones echo app."""

    def handle(self, message):
        MockApp.handle(self, message)
        peer = message.connections[0].identity
        message.respond(peer + ": " + message.text)


class ExceptionApp(MockApp):
    """App that raises an exception."""

    def handle(self, message):
        raise Exception('Error!')

########NEW FILE########
__FILENAME__ = backend
from rapidsms.backends.base import BackendBase


class MockBackend(BackendBase):
    """Simple backend that stores sent messages."""

    def __init__(self, *args, **kwargs):
        super(MockBackend, self).__init__(*args, **kwargs)
        self.messages = []

    def clear(self):
        del self.messages[:]

    def send(self, **kwargs):
        self.messages.append(kwargs)
        return True


class RaisesBackend(BackendBase):
    """Simple backend that stores sent messages."""

    def send(self, **kwargs):
        raise Exception('Error!')

########NEW FILE########
__FILENAME__ = base
import string
import random
from django.contrib.auth.models import User

from rapidsms.models import Backend, Contact, Connection
from rapidsms.messages.outgoing import OutgoingMessage
from rapidsms.messages.incoming import IncomingMessage


__all__ = ('CreateDataMixin', 'LoginMixin')


UNICODE_CHARS = [unichr(x) for x in xrange(1, 0xD7FF)]


class CreateDataMixin(object):
    """Base test mixin class that provides helper functions to create data.

    No superclasses.
    """

    def random_string(self, length=255, extra_chars=''):
        """ Generate a random string of characters.

        :param length: Length of generated string.
        :param extra_chars: Additional characters to include in generated
            string.
        """
        chars = string.letters + extra_chars
        return ''.join([random.choice(chars) for i in range(length)])

    def random_unicode_string(self, max_length=255):
        """Generate a random string of unicode characters.

        :param length: Length of generated string.
        """
        output = u''
        for x in xrange(random.randint(1, max_length / 2)):
            c = UNICODE_CHARS[random.randint(0, len(UNICODE_CHARS) - 1)]
            output += c + u' '
        return output

    def create_backend(self, data={}):
        """Create and return RapidSMS backend object. A random ``name``
        will be created if not specified in ``data`` attribute.

        :param data: Optional dictionary of field name/value pairs to pass
            to the object's ``create`` method.
        """
        defaults = {
            'name': self.random_string(12),
        }
        defaults.update(data)
        return Backend.objects.create(**defaults)

    def create_contact(self, data={}):
        """ Create and return RapidSMS contact object. A random ``name``
        will be created if not specified in ``data`` attribute.

        :param data: Optional dictionary of field name/value pairs to
            pass to the object's ``create`` method."""
        defaults = {
            'name': self.random_string(12),
        }
        defaults.update(data)
        return Contact.objects.create(**defaults)

    def create_connection(self, data={}):
        """ Create and return RapidSMS connection object. A random
        ``identity`` and ``backend`` will be created if not specified in
        ``data`` attribute.

        :param data: Optional dictionary of field name/value pairs
            to pass to the object's ``create`` method."""
        defaults = {
            'identity': self.random_string(10),
        }
        defaults.update(data)
        if 'backend' not in defaults:
            defaults['backend'] = self.create_backend()
        return Connection.objects.create(**defaults)

    def create_outgoing_message(self, data={}, backend=None):
        """Create and return RapidSMS OutgoingMessage object. A random
        ``template`` will be created if not specified in ``data`` attribute.

        :param data: Optional dictionary of field name/value pairs to pass
            to ``OutgoingMessage.__init__``."""
        defaults = {
            'text': self.random_string(10),
        }
        defaults.update(data)
        if 'connections' not in defaults:
            conn_kwargs = {}
            if backend:
                conn_kwargs = {'data': {'backend': backend}}
            defaults['connections'] = [self.create_connection(**conn_kwargs)]
        return OutgoingMessage(**defaults)

    def create_incoming_message(self, data={}):
        """Create and return RapidSMS IncomingMessage object."""
        defaults = {
            'text': self.random_string(10),
        }
        defaults.update(data)
        if 'connections' not in defaults:
            defaults['connections'] = [self.create_connection()]
        return IncomingMessage(**defaults)


class LoginMixin(object):
    """Helpers for creating users and logging in"""
    def login(self):
        """If not already set, creates self.username and self.password,
        otherwise uses the existing values.
        If there's not already a user with that username, creates one.
        Sets self.user to that user.
        Logs the user in.
        """
        if not hasattr(self, 'username'):
            self.username = 'fred'
        if not hasattr(self, 'password'):
            self.password = 'bob'
        if not User.objects.filter(username=self.username).exists():
            User.objects.create_user(self.username, password=self.password)
        self.user = User.objects.get(username=self.username)
        logged_in = self.client.login(username=self.username,
                                      password=self.password)
        if not logged_in:
            self.fail("LOGIN failed")

########NEW FILE########
__FILENAME__ = router
from django.conf import settings

from rapidsms.tests.harness import CreateDataMixin
from rapidsms.tests.harness import backend
from rapidsms.router import lookup_connections, send, receive, get_router
from rapidsms.router import test as test_router
from rapidsms.backends.database.models import BackendMessage
from rapidsms.backends.database.outgoing import DatabaseBackend


__all__ = ('CustomRouter', 'MockBackendRouter')


class CustomRouterMixin(CreateDataMixin):
    """Inheritable TestCase-like object that allows Router customization.

    Inherits from :py:class:`~rapidsms.tests.harness.CreateDataMixin`.
    """

    #: String to override :setting:`RAPIDSMS_ROUTER` during testing. Defaults
    #: to ``'rapidsms.router.blocking.BlockingRouter'``.
    router_class = 'rapidsms.router.blocking.BlockingRouter'

    #: Dictionary to override :setting:`INSTALLED_BACKENDS` during testing.
    #: Defaults to ``{}``.
    backends = {}

    #: List to override RAPIDSMS_HANDLERS with, or if None, leave
    #: RAPIDSMS_HANDLERS alone
    handlers = None

    def _pre_rapidsms_setup(self):
        self._RAPIDSMS_HANDLERS = getattr(settings, 'RAPIDSMS_HANDLERS', None)
        self.set_handlers()
        self._INSTALLED_BACKENDS = getattr(settings, 'INSTALLED_BACKENDS', {})
        self.set_backends()
        self._RAPIDSMS_ROUTER = getattr(settings, 'RAPIDSMS_ROUTER', None)
        self.set_router()

    def _post_rapidsms_teardown(self):
        setattr(settings, 'INSTALLED_BACKENDS', self._INSTALLED_BACKENDS)
        setattr(settings, 'RAPIDSMS_ROUTER', self._RAPIDSMS_ROUTER)
        if self._RAPIDSMS_HANDLERS is None:
            # RAPIDSMS_HANDLERS was not set
            if hasattr(settings, 'RAPIDSMS_HANDLERS'):
                delattr(settings, 'RAPIDSMS_HANDLERS')
        else:
            setattr(settings, 'RAPIDSMS_HANDLERS', self._RAPIDSMS_HANDLERS)

    def __call__(self, result=None):
        self._pre_rapidsms_setup()
        super(CustomRouterMixin, self).__call__(result)
        self._post_rapidsms_teardown()

    def receive(self, text, connection, **kwargs):
        """
        A wrapper around the ``receive`` API. See :ref:`receiving-messages`.
        """
        return receive(text, connection, **kwargs)

    def send(self, text, connections, **kwargs):
        """A wrapper around the ``send`` API. See :ref:`sending-messages`."""
        return send(text, connections, **kwargs)

    def get_router(self):
        """get_router() API wrapper."""
        return get_router()

    def set_handlers(self):
        if self.handlers is not None:
            setattr(settings, 'RAPIDSMS_HANDLERS', self.handlers)

    def set_backends(self):
        setattr(settings, 'INSTALLED_BACKENDS', self.backends)

    def set_router(self):
        setattr(settings, 'RAPIDSMS_ROUTER', self.router_class)

    def lookup_connections(self, backend, identities):
        """loopup_connections() API wrapper."""
        return lookup_connections(backend, identities)


class DatabaseBackendMixin(CustomRouterMixin):
    """Arrange for test to use the DatabaseBackend, and add
    a ``.sent_messages`` attribute that will have the list
    of all messages sent.

    Inherits from :py:class:`~rapidsms.tests.harness.CustomRouterMixin`.
    """

    backends = {'mockbackend': {'ENGINE': DatabaseBackend}}

    def setUp(self):
        self.backend = self.create_backend(data={'name': 'mockbackend'})
        super(DatabaseBackendMixin, self).setUp()

    def lookup_connections(self, identities, backend='mockbackend'):
        """lookup_connections wrapper to use mockbackend by default"""
        return super(DatabaseBackendMixin, self).lookup_connections(backend,
                                                                    identities)

    @property
    def sent_messages(self):
        """Messages passed to backend."""
        return BackendMessage.objects.filter(name='mockbackend',
                                             direction='O')


class TestRouterMixin(CustomRouterMixin):
    """Test extension that uses TestRouter

    Inherits from :py:class:`~rapidsms.tests.harness.CustomRouterMixin`.
    """

    #: If `disable_phases` is True, messages will not be processed through the
    #: router phases.
    #: This is useful if you're not interested in testing application logic.
    #: For example, backends may use this flag to ensure messages are sent
    #: to the router, but don't want the message to be processed.
    disable_phases = False  # setting to True will disable router phases

    backends = {'mockbackend': {'ENGINE': backend.MockBackend}}

    def set_router(self):
        kwargs = {'disable_phases': self.disable_phases}
        if hasattr(self, 'apps'):
            kwargs['apps'] = self.apps
        if hasattr(self, 'backends'):
            kwargs['backends'] = self.backends
        self.router = test_router.TestRouter(**kwargs)
        # set RAPIDSMS_ROUTER to our newly created instance
        self.router_class = self.router
        super(TestRouterMixin, self).set_router()

    @property
    def inbound(self):
        """The list of message objects received by the router."""
        return self.router.inbound

    @property
    def outbound(self):
        """The list of message objects sent by the router."""
        return self.router.outbound

    @property
    def sent_messages(self):
        """The list of message objects sent to mockbackend."""
        return self.router.backends['mockbackend'].messages

    def clear_sent_messages(self):
        """Manually empty the outbox of mockbackend."""
        self.router.backends['mockbackend'].clear()

    def lookup_connections(self, identities, backend='mockbackend'):
        """A wrapper around the ``lookup_connections`` API.
        See :ref:`connection_lookup`."""
        return super(TestRouterMixin, self).lookup_connections(backend,
                                                               identities)

########NEW FILE########
__FILENAME__ = scripted
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import re
from datetime import datetime

from rapidsms.tests.harness import TestRouterMixin


class TestScriptMixin(TestRouterMixin):
    """
    The scripted.TestScript class subclasses unittest.TestCase
    and allows you to define unit tests for your RapidSMS apps
    in the form of a 'conversational' script::

        from myapp.app import App as MyApp
        from rapidsms.tests.scripted import TestScript

        class TestMyApp (TestScript):
            apps = (MyApp,)
            testRegister = \"""
               8005551212 > register as someuser
               8005551212 < Registered new user 'someuser' for 8005551212!
            \"""

            testDirectMessage = \"""
               8005551212 > tell anotheruser what's up??
               8005550000 < someuser said "what's up??"
            \"""


    This TestMyApp class would then work exactly as any other
    unittest.TestCase subclass (so you could, for example, call
    unittest.main()).

    Inherits from :py:class:`~rapidsms.tests.harness.router.TestRouterMixin`.
    """

    def assertInteraction(self, script):
        self.runParsedScript(self.parseScript(script))

    @classmethod
    def parseScript(cls, script):
        cmds = []
        for line in map(lambda(x): x.strip(), script.split("\n")):
            if not line or line.startswith("#"):
                continue
            tokens = re.split(r'([<>])', line, 1)
            num, dir, txt = map(lambda (x): x.strip(), tokens)
            # allow users to optionally put dates in the number
            # 19232922@200804150730
            if "@" in num:
                num, datestr = num.split("@")
                date = datetime.strptime(datestr, "%Y%m%d%H%M")
            else:
                date = datetime.now()
            cmds.append((num, date, dir, txt))
        return cmds

    def sendMessage(self, num, txt, date=None):
        if date is None:
            date = datetime.now()
        self.receive(text=txt, connection=self.lookup_connections([num])[0])

    def receiveAllMessages(self):
        messages = self.outbound
        self.router.outbound = []
        return messages

    def _checkAgainstMessage(self, num, txt, last_msg, msg):
        peer = msg.connections[0].identity
        self.assertEquals(peer, num,
                          "Expected to respond to "
                          "%s, but message was sent to %s.\n"
                          "\nMessage: %s\nReceived "
                          "text: %s\nExpected text: %s\n" % (num, peer,
                          last_msg, msg.text, txt))

        self.assertEquals(msg.text, txt, "\nMessage: %s\nReceived "
                          "text: %s\nExpected text: %s\n" %
                          (last_msg, msg.text, txt))

    def _checkAgainstMessages(self, num, txt, last_msg, msgs):
        self.assertTrue(len(msgs) != 0, "Message was ignored.\n"
                        "Message: '%s'\nExpecting: '%s'" %
                        (last_msg, txt))
        for i, msg in enumerate(msgs):
            try:
                self._checkAgainstMessage(num, txt, last_msg, msg)
                return i
            except AssertionError:
                # only raise this up if we've exhausted all our candidates
                if i == len(msgs) - 1:
                    raise

    def runParsedScript(self, cmds):
        last_msg = ''
        msgs = []
        for num, date, dir, txt in cmds:
            if dir == ">":
                self.sendMessage(num, txt, date)
            elif dir == "<":
                if len(msgs) == 0:
                    # only reload when we've exhausted our cache of messages
                    msgs = self.receiveAllMessages()
                match = self._checkAgainstMessages(num, txt, last_msg, msgs)
                msgs.pop(match)

            last_msg = txt

    def runScript(self, script):
        """Run a test script.

        :param string script: A multi-line test script. See
            :py:class:`~rapidsms.tests.harness.scripted.TestScriptMixin`.
        """
        self.clear_sent_messages()  # make sure the outbox is empty
        self.runParsedScript(self.parseScript(script))

########NEW FILE########
__FILENAME__ = scripted
import warnings

from rapidsms.tests.harness import TestScript as TestScriptMixin


class TestScript(TestScriptMixin):

    def startRouter(self):
        warnings.warn("startRouter is deprecated and will be removed in a "
                      "future release.  Please, see the release notes.",
                      DeprecationWarning, stacklevel=2)
        self.clear()  # make sure the outbox is clean

    def stopRouter(self):
        warnings.warn("stopRouter is deprecated and will be removed in a "
                      "future release.  Please, see the release notes.",
                      DeprecationWarning, stacklevel=2)

########NEW FILE########
__FILENAME__ = test_app_base
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from nose.tools import assert_equals
from ..apps.base import AppBase


# since AppBase introspects its name based upon the django app which it
# is located in, if the module name changes, the tests fail. this would
# be misleading, since it's the renamed tests at fault, not AppBase. to
# avoid confusion, explode early with a more detailed error.
if not __name__.startswith("rapidsms.tests"):
    raise Exception(
        "This module must be within the 'rapidsms.tests' package for " +
        "the unit tests to work, since AppBase introspects its name.")


class MockRouter(object):
    pass


class AppStub(AppBase):
    pass


def test_app_exposes_router():
    router = MockRouter()
    app = AppStub(router)

    assert_equals(app.router, router)


def test_app_has_name():
    router = MockRouter()
    app = AppStub(router)

    assert_equals(repr(app), "<app: tests>")
    assert_equals(unicode(app), "tests")
    assert_equals(app.name, "tests")


def test_app_finds_valid_app_classes():
    app = AppBase.find('rapidsms.contrib.default')
    from rapidsms.contrib.default.app import App
    assert_equals(app, App)


def test_app_ignores_invalid_modules():
    app = AppBase.find('not.a.valid.module')
    assert_equals(app, None)

########NEW FILE########
__FILENAME__ = test_paginator
from django.core.paginator import Paginator
from django.core.urlresolvers import reverse
from django.test import TestCase
from django.test.client import RequestFactory

from rapidsms.conf import settings
from rapidsms.templatetags.paginator_tags import paginator


class PaginatorTests(TestCase):
    def test_paginator(self):
        cases = [
            #viewing page, max_page, [shown pages] (None = ellipsis)
            (1, 10, [1, 2, 3, None, 9, 10]),
            (3, 10, [1, 2, 3, 4, 5, None, 9, 10]),
            (4, 10, [1, 2, 3, 4, 5, 6, None, 9, 10]),
            (10, 10, [1, 2, None, 8, 9, 10]),
            (6, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
            (5, 20, [1, 2, 3, 4, 5, 6, 7, None, 19, 20]),
            (18, 20, [1, 2, None, 16, 17, 18, 19, 20]),
            (17, 20, [1, 2, None, 15, 16, 17, 18, 19, 20]),
            (16, 20, [1, 2, None, 14, 15, 16, 17, 18, 19, 20]),
            (15, 20, [1, 2, None, 13, 14, 15, 16, 17, 18, 19, 20]),
            (20, 50, [1, 2, None, 18, 19, 20, 21, 22, None, 49, 50]),
            ]
        request = RequestFactory().get(
            reverse('rapidsms.contrib.registration.views.registration')
        )
        context = {'request': request}

        settings.PAGINATOR_BORDER_LINKS = 2
        settings.PAGINATOR_ADJACENT_LINKS = 2

        for page_num, max_num, test_case_pages in cases:
            pg = Paginator(range(max_num * 10), 10)
            result_pages = [
                p['number'] if p else None for p in
                    paginator(context, pg.page(page_num))['page_links']
            ]
            self.assertEqual(result_pages, test_case_pages)

########NEW FILE########
__FILENAME__ = test_scripted
from rapidsms.tests.harness import EchoApp
from rapidsms.tests.scripted import TestScript


class EchoTest(TestScript):
    apps = (EchoApp,)

    def testRunScript(self):
        self.runScript("""
            2345678901 > echo?
            2345678901 < 2345678901: echo?
        """)

########NEW FILE########
__FILENAME__ = test_views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from nose.tools import assert_equals

from django.core.urlresolvers import reverse
from django.contrib.auth.models import User
from django.test.client import Client


def test_login():
    c = Client()
    login_url = reverse("rapidsms.views.login")

    # check that the login form is displayed.
    response = c.get(login_url)
    assert_equals(response.status_code, 200)

    # check that visitors can log in successfully.
    u = User.objects.create_user("testuser", "user@example.com", "testpass")
    response = c.post(login_url,
                      {'username': "testuser", 'password': "testpass"})
    assert_equals(response.status_code, 302)

    # clean up.
    u.delete()

########NEW FILE########
__FILENAME__ = app
from rapidsms.apps.base import AppBase
from rapidsms.models import Connection
from rapidsms.router import send

from rapidsms.utils import translation as trans_helpers

from django.utils import translation
from django.utils.translation import ugettext as _


class TranslationApp(AppBase):

    def handle(self, msg):
        if msg.text == "lang-hello":
            with translation.override(msg.connection.contact.language):
                msg.respond(_('hello'))
            return True
        elif msg.text == 'settings-hello':
            msg.respond(_('hello'))
            return True


def lang_broadcast():
    connections = Connection.objects.all()
    for lang, conns in trans_helpers.group_connections(connections):
        with translation.override(lang):
            send(_('hello'), conns)

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
from django.test.utils import override_settings
from rapidsms.models import Connection
from rapidsms.tests.harness import RapidTest
from rapidsms.tests.translation import app
from rapidsms.utils import translation as trans_helpers


class TranslationTestMixin(object):

    def setUp(self):
        super(TranslationTestMixin, self).setUp()
        self.backend = self.create_backend(data={'name': 'mockbackend'})

    def create_lang_connection(self, identity, language):
        """Create a connection with specified identity and language."""
        contact = self.create_contact(data={'language': language})
        connection = self.create_connection(data={'identity': identity,
                                                  'contact': contact,
                                                  'backend': self.backend})
        return connection


class TranslationRoutingTest(TranslationTestMixin, RapidTest):

    apps = [app.TranslationApp]

    def test_translation_override(self):
        """Message should be translated to the contact's preference."""
        en_conn = self.create_lang_connection('1000000000', 'en')
        es_conn = self.create_lang_connection('1000000001', 'es')
        # both contacts text in to RapidSMS
        self.receive('lang-hello', en_conn)  # English contact
        self.receive('lang-hello', es_conn)  # Spanish contact
        # response should be translated as expected
        self.assertEqual(len(self.outbound), 2)
        self.assertEqual(self.outbound[0].text, 'hello')
        self.assertEqual(self.outbound[1].text, 'hola')

    def test_broadcast(self):
        """Test example broadcast functionality."""
        self.create_lang_connection('1000000000', 'en')
        self.create_lang_connection('1000000001', 'en')
        self.create_lang_connection('1000000002', 'en')
        self.create_lang_connection('1000000003', 'es')
        self.create_lang_connection('1000000004', 'es')
        app.lang_broadcast()
        self.assertEqual(2, len(self.outbound))
        for message in self.outbound:
            if message.text == 'hello':
                self.assertEqual(3, len(message.connections))
            elif message.text == 'hola':
                self.assertEqual(2, len(message.connections))

    def test_contact_settings_langauge(self):
        """settings.LANGUAGE_CODE should not override Contact preference."""
        en_conn = self.create_lang_connection('1000000000', 'en')
        with override_settings(LANGUAGE_CODE='es'):
            self.receive('lang-hello', en_conn)
            self.assertEqual(self.outbound[0].text, 'hello')


class TranslationHelperTest(TranslationTestMixin, RapidTest):

    def test_connection_grouping(self):
        """Make sure group_connections returns list of (lang, connections)"""
        connections = (
            self.create_lang_connection('1000000000', 'en'),
            self.create_lang_connection('1000000001', 'en'),
            self.create_lang_connection('1000000002', 'en'),
            self.create_lang_connection('1000000003', 'es'),
            self.create_lang_connection('1000000004', 'es'),
            self.create_lang_connection('1000000005', 'fr'),
        )
        grouped_conns = list(trans_helpers.group_connections(connections))
        for lang, conns in grouped_conns:
            if lang == 'en':
                self.assertEqual(3, len(conns))
            elif lang == 'es':
                self.assertEqual(2, len(conns))
            elif lang == 'fr':
                self.assertEqual(1, len(conns))

    def test_connection_grouping_queryset(self):
        """Same test as above but with a QuerySet object."""
        self.create_lang_connection('1000000000', 'en')
        self.create_lang_connection('1000000001', 'en')
        self.create_lang_connection('1000000002', 'en')
        self.create_lang_connection('1000000003', 'es')
        self.create_lang_connection('1000000004', 'es')
        self.create_lang_connection('1000000005', 'fr')
        connections = Connection.objects.all()
        grouped_conns = list(trans_helpers.group_connections(connections))
        for lang, conns in grouped_conns:
            if lang == 'en':
                self.assertEqual(3, len(conns))
            elif lang == 'es':
                self.assertEqual(2, len(conns))
            elif lang == 'fr':
                self.assertEqual(1, len(conns))

    def test_connection_grouping_no_language(self):
        """group_connections should handle empty languages without issue."""
        connections = (
            self.create_lang_connection('1000000000', 'en'),
            self.create_lang_connection('1000000001', ''),
            self.create_lang_connection('1000000002', 'en'),
            self.create_lang_connection('1000000003', ''),
            self.create_lang_connection('1000000004', ''),
        )
        grouped_conns = list(trans_helpers.group_connections(connections))
        for lang, conns in grouped_conns:
            if lang == 'en':
                self.assertEqual(2, len(conns))
            elif lang == '':
                self.assertEqual(3, len(conns))

########NEW FILE########
__FILENAME__ = login_logout
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.conf.urls import patterns, url
from .. import views

urlpatterns = patterns('',
    url(r'^login/$', views.login, name='rapidsms-login'),
    url(r'^logout/$', views.logout, name='rapidsms-logout'),
)

########NEW FILE########
__FILENAME__ = modules
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4
import os
import sys
import inspect

from django.utils.importlib import import_module


__all__ = ('import_class', 'import_module', 'try_import', 'find_python_files',
           'get_classes', 'get_class', 'get_package_path')


def import_class(import_path, base_class=None):
    """
    Imports and returns the class described by import_path, where
    import_path is the full Python path to the class.
    """
    try:
        module, class_name = import_path.rsplit('.', 1)
    except ValueError:
        raise ImportError("%s isn't a Python path." % import_path)
    try:
        mod = import_module(module)
    except ImportError, e:
        raise ImportError('Error importing module %s: "%s"' %
                          (module, e))
    try:
        class_ = getattr(mod, class_name)
    except AttributeError:
        raise ImportError('Module "%s" does not define a "%s" '
                          'class.' % (module, class_name))
    if not inspect.isclass(class_):
        raise ImportError('%s is not a class.' % import_path)
    if base_class and not issubclass(class_, base_class):
        msg = "%s is not a subclass of %s" % (class_name, base_class.__name__)
        raise ImportError(msg)
    return class_


def try_import(module_name):
    """
    Import and return *module_name*.

    >>> try_import("csv") # doctest: +ELLIPSIS
    <module 'csv' from '...'>

    Unlike the standard try/except approach to optional imports, inspect
    the stack to avoid catching ImportErrors raised from **within** the
    module. Only return None if *module_name* itself cannot be imported.

    >>> try_import("spam.spam.spam") is None
    True
    """

    try:
        __import__(module_name)
        return sys.modules[module_name]

    except ImportError:

        # extract a backtrace, so we can find out where the exception
        # was raised from. if there is a NEXT frame, it means that the
        # import statement succeeded, but an ImportError was raised from
        # *within* the imported module. we must allow this error to
        # propagate, to avoid silently masking it.
        traceback = sys.exc_info()[2]
        if traceback.tb_next:
            raise

        # else, the exception was raised from this scope. *module_name*
        # couldn't be imported, which is fine, since allowing that is
        # the purpose of this function.
        return None


def find_python_files(path):
    """
    Return a list of the Python files (*.py) in a directory. Note that
    the existance of a Python source file does not guarantee that it is
    a valid module, because the directory (or any number of its parents)
    may not contain an __init__.py, rendering it a non-module.

    For example, to list the Python files in the 'encodings' package,
    (which is always available, as part of the stdlib):

    >>> import encodings
    ... monkeys

    >>> p = encodings.__path__[0]
    >>> find_python_files(p) # doctest: +ELLIPSIS
    ['aliases', 'ascii', 'base64_codec', 'big5', ...]

    This seems a bit of an oversimplification, given that Python modules
    can live inside eggs and zips and the such, but if it's good enough
    for django.core.management.find_commands, it's good enough for me.

    Return an empty list if the directory doesn't exist, couldn't be
    iterated, or contains no relevant files.

    >>> find_python_files("doesnt-exist")
    []
    """

    try:
        return sorted([

            # trim the extension
            file[:-3]

            # iterate all files in the path
            # (doesn't include . and .. links)
            for file in os.listdir(path)

            # ignore __magic__ files and those
            # not ending with the .py suffix
            if not file.startswith(('_', '.'))
            and file.endswith('.py')])

    except OSError:
        return []


def get_classes(module, superclass=None):
    """
    Return a list of new-style classes defined in *module*, excluding
    _private and __magic__ names, and optionally filtering only those
    inheriting from *superclass*. Note that both arguments are actual
    modules, not names.

    This method only returns classes that were defined in *module*.
    Those imported from elsewhere are ignored.
    """

    objects = [
        getattr(module, name)
        for name in dir(module)
        if not name.startswith("_")]

    # filter out everything that isn't a new-style
    # class, or wasn't defined in *module* (ie, it
    # is imported from somewhere else)
    classes = [
        obj for obj in objects
        if isinstance(obj, type)
        and (obj.__module__ == module.__name__)]

    # if a superclass was given, filter the classes
    # again to remove those that aren't its subclass
    if superclass is not None:
        classes = [
            cls for cls in classes
            if issubclass(cls, superclass)]

    return classes


def get_class(module, superclass=None):
    """
    Return the lone class contained by *module*, or raise a descriptive
    AttributeError if *module* contains zero or more than one class.
    This is useful when expecting a single class from a module without
    knowing its name, to avoid the usual constantly-named object in a
    module (eg. App, Backend, Command, Handler).
    """

    classes = get_classes(
        module, superclass)

    if len(classes) == 1:
        return classes[0]

    # the error message includes *superclass*
    # if one was given, otherwise it's generic
    desc = "subclasses of %s" % (superclass.__name__)\
        if superclass else "new-style classes"

    if len(classes) > 1:
        names = ", ".join([cls.__name__ for cls in classes])
        raise(AttributeError("Module %s contains multiple %s (%s)." %
                            (module.__name__, desc, names)))

    else:  # len < 1
        raise(AttributeError("Module %s contains no %s." %
                            (module.__name__, desc)))


def get_package_path(package_name):
    """
    Import *package_name*, and return its absolute path.

    >>> get_package_path("encodings") # doctest: +ELLIPSIS
    '/.../python.../encodings'

    Raise AttributeError if *package_name* is a module (*.py).

    >>> get_package_path("csv")
    Traceback (most recent call last):
    ...
    AttributeError: 'csv' is not a package
    """

    try:
        __import__(package_name)
        return sys.modules[package_name].__path__[0]

    # wrap with a better message
    except AttributeError:
        raise(AttributeError('%r is not a package' % (package_name)))

########NEW FILE########
__FILENAME__ = pagination
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.core.paginator import Paginator, EmptyPage, InvalidPage


def paginated(req, query_set, per_page=None, default_page=1, prefix="",
              wrapper=None):
    if per_page is None:
        from ..conf import settings
        per_page = settings.PAGINATOR_OBJECTS_PER_PAGE

    # since the behavior of this function depends on GET parameters, if
    # there is more than one paginated set per view, we must prefix the
    # parameters to differentiate them: path?users-page=1&groups-page=2
    prefix = ("%s-" % (prefix)) if prefix else ""

    # the per_page argument to this function provides a default, but can
    # be overridden. (the template provides no interface for this yet.)
    if (prefix + "per-page") in req.GET:
        try:
            per_page = int(req.GET[prefix + "per-page"])

        # if it was provided, it must be valid
        except ValueError:
            raise ValueError("Invalid per-page parameter: %r" %
                            (req.GET[prefix + "per-page"]))

    # create the paginator early, so we can check that the page number
    # is valid, and (maybe) apply *wrapper* to this page's objects.
    paginator = Paginator(query_set, per_page)

    try:
        if (prefix + "page") in req.GET:
            page = int(req.GET[prefix + "page"])

        else:
            # if the default page was negative, count backwards from the
            # last page. this is handy for skipping to the latest page
            # in a stream of information (like a message log), rather
            # than displaying it backwards to suit the paginator.
            if default_page >= 0:
                page = default_page
            else:
                page = paginator.num_pages + (default_page + 1)

        # try to switch to the *page*. (might raise.)
        objects = paginator.page(page)

    # have no mercy if the page parameter is not valid. there should be
    # no links to an invalid page, so coercing it to assume "page=xyz"
    # means "page=1" would just mask bugs
    except (ValueError, EmptyPage, InvalidPage):
        raise ValueError("Invalid Page: %r" % (req.GET[prefix + "page"]))

    # if a wrapper function was provided, call it for each object on the
    # page, and replace the list with the result. TODO: make it lazy!
    if wrapper is not None:
        objects.raw_object_list = objects.object_list
        objects.object_list = map(wrapper, objects.object_list)

    # attach the prefix (it might be blank) and request to the objects,
    # for the {% paginator %} tag, to create the prev/next page links
    objects.prefix = prefix
    objects.request = req

    return objects

########NEW FILE########
__FILENAME__ = test_modules
from django.test import TestCase
from rapidsms.utils.modules import (import_class, import_module, get_class)


class ParentA(object):
    pass


class ChildOfA(ParentA):
    pass


class ParentB(object):
    pass


class ImportClassTest(TestCase):

    def test_bad_path(self):
        """Invalid paths should raise an error."""
        self.assertRaises(ImportError, import_class, "bad_path")

    def test_valid_class(self):
        """Valid paths should return the proper class."""
        class_ = import_class("rapidsms.utils.test_modules.ParentA")
        self.assertEqual(class_, ParentA)

    def test_nonexistent_class(self):
        """Valid path with invalid class should raise an error."""
        self.assertRaises(ImportError, import_class,
                          "rapidsms.utils.test_modules.NoClass")

    def test_valid_base_class(self):
        """Class should match base_class if supplied."""
        class_ = import_class("rapidsms.utils.test_modules.ChildOfA",
                              ParentA)
        self.assertTrue(issubclass(class_, ParentA))
        self.assertEqual(class_, ChildOfA)

    def test_invalid_base_class(self):
        """If class doesn't match base_class, an error should be raised."""
        self.assertRaises(ImportError, import_class,
                          "rapidsms.utils.test_modules.ParentB",
                          base_class=ParentA)


class GetClassTest(TestCase):

    def test_get_class(self):
        """get_class() should return the proper class."""
        module = import_module('rapidsms.utils.test_modules')
        class_ = get_class(module, ParentB)
        self.assertEqual(ParentB, class_)

    def test_no_classes_found(self):
        """An error should be raised if no classes are found."""
        from rapidsms.backends.base import BackendBase
        module = import_module('rapidsms.utils.test_modules')
        self.assertRaises(AttributeError, get_class, module, BackendBase)

    def test_multiple_classes_found(self):
        """An error should be raised if multiple classes are found."""
        module = import_module('rapidsms.utils.test_modules')
        self.assertRaises(AttributeError, get_class, module, ParentA)

########NEW FILE########
__FILENAME__ = translation
from collections import defaultdict

from django.db.models.query import QuerySet


def group_connections(connections):
    """
    Return a list of (language code, respective connections) pairs, while
    using Django's translation.override() to set each language.
    """
    grouped_conns = defaultdict(list)
    if isinstance(connections, QuerySet):
        languages = connections.values_list('contact__language', flat=True)
        for language in languages.distinct():
            lang_conns = connections.filter(contact__language=language)
            grouped_conns[language].extend(lang_conns)
    else:
        for connection in connections:
            language = connection.contact.language
            grouped_conns[language].append(connection)
    for lang, conns in grouped_conns.iteritems():
        yield lang, conns

########NEW FILE########
__FILENAME__ = web_message
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4


from django.template import RequestContext
from django.shortcuts import render_to_response


def web_message(req, msg, link=None):
    return render_to_response(
        "message.html", {
            "message": msg,
            "link": link
        }, context_instance=RequestContext(req)
    )

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4 encoding=utf-8

import pytz
from datetime import datetime


def empty_str(in_str):
    """
    Simple helper to return True if the passed
    string reference is None or '' or all whitespace

    """
    if in_str is not None and not isinstance(in_str, basestring):
        raise TypeError('Arg must be None or a string type')

    return in_str is None or \
        len(in_str.strip()) == 0


def to_naive_utc_dt(dt):
    """
    Converts a datetime to a naive datetime (no tzinfo)
    as follows:

    if inbound dt is already naive, it just returns it

    if inbound is timezone aware, converts it to UTC,
    then strips the tzinfo

    """
    if not isinstance(dt, datetime):
        raise TypeError('Arg must be type datetime')

    if dt.tzinfo is None:
        return dt

    return dt.astimezone(pytz.utc).replace(tzinfo=None)


def to_aware_utc_dt(dt):
    """
    Convert an inbound datetime into a timezone
    aware datetime in UTC as follows:

    if inbound is naive, uses 'tzinfo.localize' to
    add utc tzinfo. NOTE: Timevalues are not changed,
    only difference in tzinfo is added to identify this
    as a UTC tz aware object.

    if inbound is aware, uses 'datetime.astimezone'
    to convert timevalues to UTC and set tzinfo to
    utc.

    """
    if not isinstance(dt, datetime):
        raise TypeError('Arg must be type datetime')

    if dt.tzinfo is None:
        return pytz.utc.localize(dt)

    return dt.astimezone(pytz.utc)


def timedelta_as_minutes(td):
    """
    Returns the value of the entire timedelta as
    integer minutes, rounded down

    """
    return timedelta_as_seconds(td) / 60


def timedelta_as_seconds(td):
    '''
    Returns the value of the entire timedelta as
    integer seconds, rounded down

    '''
    return td.days * 86400 + td.seconds

########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

from django.contrib.auth.decorators import login_required
from django.contrib.auth.views import login as django_login
from django.contrib.auth.views import logout as django_logout
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.views.decorators.http import require_GET


@login_required
@require_GET
def dashboard(req):
    return render_to_response(
        "dashboard.html",
        context_instance=RequestContext(req))


def login(req, template_name="rapidsms/login.html"):
    return django_login(req, **{"template_name": template_name})


def logout(req, template_name="rapidsms/loggedout.html"):
    return django_logout(req, **{"template_name": template_name})

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python
# vim: ai ts=4 sts=4 et sw=4

import os
import sys


def run_tests(options, args, ci=False):
    from django.conf import settings
    if ci:
        settings.NOSE_ARGS = [
            '--with-xcoverage',
            '--cover-tests',
            '--cover-package=rapidsms',
        ]
    from django.test.utils import get_runner
    TestRunner = get_runner(settings)
    test_runner = TestRunner(verbosity=int(options.verbosity),
                             interactive=options.interactive,
                             failfast=False)
    if not args:
        args = ['rapidsms']
    failures = test_runner.run_tests(args)
    sys.exit(failures)


def main():
    from optparse import OptionParser
    usage = "%prog [options] [module module module ...]"
    parser = OptionParser(usage=usage)
    parser.add_option('-v', '--verbosity', action='store', dest='verbosity',
                      default=1, type='choice', choices=['0', '1', '2', '3'],
                      help='Verbosity level; 0=minimal output, 1=normal '
                           'output, 2=all output')
    parser.add_option('--noinput', action='store_false', dest='interactive',
                      default=True,
                      help='Tells Django to NOT prompt the user for input of '
                           'any kind.')
    parser.add_option('--settings',
                      help='Python path to settings module, e.g. '
                           '"myproject.settings". If this isn\'t provided, '
                           'the DJANGO_SETTINGS_MODULE environment variable '
                           'will be used.')
    parser.add_option('--ci', action='store_true', dest='ci',
                      default=False,
                      help='Run tests with CI environment')
    options, args = parser.parse_args()
    if options.settings:
        os.environ['DJANGO_SETTINGS_MODULE'] = options.settings
    elif "DJANGO_SETTINGS_MODULE" not in os.environ:
        parser.error("DJANGO_SETTINGS_MODULE is not set in the environment. "
                     "Set it or use --settings.")
    else:
        options.settings = os.environ['DJANGO_SETTINGS_MODULE']
    # I couldn't figure out how to get "CI" in as a command line argument,
    # because nosetests would also interpret the argument.
    ci = os.environ.get('CI', False)
    ci = False
    run_tests(options, ci=ci, args=args)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = coverage
from default import *

NOSE_ARGS = [
    '--with-coverage',
    '--cover-package=rapidsms',
]

########NEW FILE########
__FILENAME__ = default
import os

db_name = 'test_rapidsms'
db_engine = os.environ.get('DBENGINE', 'sqlite3')
db_name = "rapidsms_{0}".format(os.environ.get('TESTENV', db_name))

TEST_RUNNER = "django_nose.NoseTestSuiteRunner"

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.{0}'.format(db_engine),
        'NAME': '{0}.sqlite3'.format(db_name),
    }
}

INSTALLED_BACKENDS = {
    "message_tester": {
        "ENGINE": "rapidsms.backends.database.DatabaseBackend",
    },
}

INSTALLED_APPS = [
    "rapidsms",
    # third party apps.
    "django_nose",
    "djtables",
    "django_tables2",
    "selectable",
    # django contrib apps
    "django.contrib.sites",
    "django.contrib.auth",
    "django.contrib.admin",
    "django.contrib.sessions",
    "django.contrib.staticfiles",
    "django.contrib.contenttypes",
    # rapidsms contrib apps.
    "rapidsms.contrib.handlers",
    "rapidsms.contrib.httptester",
    "rapidsms.contrib.locations",
    "rapidsms.contrib.messagelog",
    "rapidsms.contrib.messaging",
    "rapidsms.contrib.registration",
    "rapidsms.contrib.echo",
    "rapidsms.router.db",
    "rapidsms.backends.database",
    "rapidsms.backends.kannel",
    "rapidsms.tests.translation",

    "rapidsms.contrib.default",  # Should be last
]

SITE_ID = 1

SECRET_KEY = 'super-secret'

LOGIN_REDIRECT_URL = "/"

STATIC_URL = '/static/'

# Insecure, but fast for running tests
PASSWORD_HASHERS = (
    'django.contrib.auth.hashers.MD5PasswordHasher',
)

ROOT_URLCONF = "tests.urls"

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages",
    "django.core.context_processors.request",
)

PROJECT_NAME = 'rapidsms-test-suite'

import djcelery
djcelery.setup_loader()

CELERY_ALWAYS_EAGER = True
CELERY_EAGER_PROPAGATES_EXCEPTIONS = True

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.contrib import admin

admin.autodiscover()

urlpatterns = patterns('',
    (r'^admin/', include(admin.site.urls)),

    # RapidSMS core URLs
    (r'^account/', include('rapidsms.urls.login_logout')),
    url(r'^$', 'rapidsms.views.dashboard', name='rapidsms-dashboard'),

    # RapidSMS contrib app URLs
    (r'^httptester/', include('rapidsms.contrib.httptester.urls')),
    (r'^locations/', include('rapidsms.contrib.locations.urls')),
    (r'^messagelog/', include('rapidsms.contrib.messagelog.urls')),
    (r'^messaging/', include('rapidsms.contrib.messaging.urls')),
    (r'^registration/', include('rapidsms.contrib.registration.urls')),

    # Third party URLs
    (r'^selectable/', include('selectable.urls')),
)

########NEW FILE########
