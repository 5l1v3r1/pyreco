__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# XWorkflows documentation build configuration file, created by
# sphinx-quickstart on Mon Jun 20 14:00:10 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.dirname(os.path.abspath('.')))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'XWorkflows'
copyright = u'2011-2013, Raphaël Barrois'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
root_dir = os.path.abspath(os.path.dirname(__file__))
def get_version():
    import re
    version_re = re.compile(r"^__version__ = '([\w_.-]+)'$")
    with open(os.path.join(root_dir, os.pardir, 'xworkflows', '__init__.py')) as f:
        for line in f:
            match = version_re.match(line[:-1])
            if match:
                return match.groups()[0]
    return '0.0.0'

release = get_version()
version = '.'.join(release.split('.')[:2])


# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'XWorkflowsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'XWorkflows.tex', u'XWorkflows Documentation',
   u'Raphaël Barrois', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'xworkflows', u'XWorkflows Documentation',
     [u'Raphaël Barrois'], 1)
]

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.

import sys

if sys.version_info[0] <= 2 and sys.version_info[1] < 7:  # pragma: no cover
    import unittest2 as unittest
else:  # pragma: no cover
    import unittest

is_python3 = (sys.version_info[0] >= 3)

if is_python3:  # pragma: no cover
    def u(txt):
        return txt
else:  # pragma: no cover
    def u(txt):
        return unicode(txt)

########NEW FILE########
__FILENAME__ = test_base
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.

from .compat import unittest, u

from xworkflows import base


class StateTestCase(unittest.TestCase):

    def test_definition(self):
        self.assertRaises(ValueError, base.State, 'a--b', 'A--B')

    def test_equality(self):
        self.assertNotEqual(base.State('foo', 'Foo'), base.State('foo', 'Foo'))

    def test_repr(self):
        a = base.State('foo', 'Foo')
        self.assertIn('foo', repr(a))
        self.assertNotIn('Foo', repr(a))


class StateListTestCase(unittest.TestCase):

    def setUp(self):
        self.foo = base.State('foo', 'Foo')
        self.bar = base.State('bar', 'Bar')
        self.bar2 = base.State('bar', 'Bar')
        self.sl = base.StateList([self.foo, self.bar])

    def test_access(self):
        self.assertEqual(self.foo, self.sl.foo)
        self.assertEqual(self.foo, self.sl['foo'])

        self.assertFalse(hasattr(self.sl, 'baz'))

    def test_contains(self):
        self.assertIn(self.foo, self.sl)
        self.assertIn(self.bar, self.sl)
        self.assertIn('foo', self.sl)

        self.assertNotIn(self.bar2, self.sl)
        self.assertNotIn('bar2', self.sl)

    def test_list_methods(self):
        self.assertTrue(self.sl)
        self.assertFalse(base.StateList([]))

        self.assertEqual(2, len(self.sl))


class TransitionListTestCase(unittest.TestCase):

    def setUp(self):
        self.foo = base.State('foo', 'Foo')
        self.bar = base.State('bar', 'Bar')
        self.baz = base.State('baz', 'Baz')
        self.baz2 = base.State('baz', 'Baz')
        self.foobar = base.Transition('foobar', self.foo, self.bar)
        self.foobar2 = base.Transition('foobar', self.foo, self.bar)
        self.gobaz = base.Transition('gobaz', [self.foo, self.bar], self.baz)
        self.tl = base.TransitionList([self.foobar, self.gobaz])

    def test_access(self):
        self.assertEqual(self.foobar, self.tl.foobar)
        self.assertEqual(self.foobar, self.tl['foobar'])

        self.assertFalse(hasattr(self.tl, 'foobaz'))

    def test_contains(self):
        self.assertIn(self.foobar, self.tl)
        self.assertIn(self.gobaz, self.tl)

        self.assertNotIn(self.foobar2, self.tl)

    def test_list_methods(self):
        self.assertTrue(self.tl)
        self.assertFalse(base.TransitionList([]))

        self.assertEqual(2, len(self.tl))

    def test_available(self):
        self.assertEqual([self.foobar, self.gobaz],
                              list(self.tl.available_from(self.foo)))
        self.assertEqual([self.gobaz],
                              list(self.tl.available_from(self.bar)))
        self.assertEqual([], list(self.tl.available_from(self.baz)))


class StateWrapperTestCase(unittest.TestCase):

    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.foo = base.State('foo', 'Foo')
        self.bar = base.State('bar', 'Bar')
        self.wf = MyWorkflow
        self.sf = base.StateWrapper(self.foo, self.wf)
        self.sf2 = base.StateWrapper(self.foo, self.wf)

    def test_comparison(self):
        self.assertEqual(self.sf, self.sf2)
        self.assertEqual(self.sf, self.foo)
        self.assertEqual(self.foo, self.sf)
        self.assertNotEqual(self.sf, self.bar)
        self.assertNotEqual(self.sf, 0)
        self.assertNotEqual(self.bar, self.sf)
        self.assertEqual(self.sf, 'foo')
        self.assertEqual('foo', self.sf)

    def test_attributes(self):
        self.assertTrue(self.sf.is_foo)
        self.assertFalse(self.sf.is_bar)
        self.assertFalse(hasattr(self.sf, 'foo'))
        self.assertEqual(self.foo.name, self.sf.name)
        self.assertEqual(self.foo.title, self.sf.title)

        class BadSubclass(base.StateWrapper):
            def __init__(self, *args, **kwargs):
                self.x = self.state  # Not yet defined!

        self.assertRaises(AttributeError, BadSubclass)

    def test_representation(self):
        self.assertEqual(str(self.foo), str(self.sf))
        self.assertIn(repr(self.foo), repr(self.sf))
        self.assertEqual(self.foo.name, u(self.sf))
        self.assertEqual(hash(self.foo.name), hash(self.sf))


class WorkflowEnabledTestCase(unittest.TestCase):
    def setUp(self):
        super(WorkflowEnabledTestCase, self).setUp()

        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        class MyWorkflowEnabled(base.WorkflowEnabled):
            state = MyWorkflow()

        self.foo = MyWorkflow.states.foo
        self.bar = MyWorkflow.states.bar
        self.wf = MyWorkflow
        self.wfe = MyWorkflowEnabled

    def test_access_state(self):
        obj = self.wfe()
        self.assertEqual(self.foo, obj.state)
        self.assertTrue(obj.state.is_foo)
        self.assertFalse(obj.state.is_bar)

        obj.state = self.bar

        self.assertEqual(self.bar, obj.state)
        self.assertTrue(obj.state.is_bar)
        self.assertFalse(obj.state.is_foo)

    def test_compare_state_text(self):
        obj = self.wfe()

        obj.state = 'bar'

        self.assertEqual(self.bar, obj.state)
        self.assertTrue(obj.state.is_bar)
        self.assertFalse(obj.state.is_foo)


class ImplementationPropertyTestCase(unittest.TestCase):

    def setUp(self):
        self.foo = base.State('foo', 'Foo')
        self.bar = base.State('bar', 'Bar')
        self.baz = base.State('baz', 'Baz')
        self.foobar = base.Transition('foobar', self.foo, self.bar)

    def test_creation(self):
        def blah(obj):  # pragma: no cover
            """doc for blah"""
            pass

        implem = base.ImplementationProperty(
            field_name='my_state', transition=self.foobar, workflow=None,
            implementation=blah)

        self.assertIn("'foobar'", repr(implem))
        self.assertIn("blah", repr(implem))
        self.assertIn('my_state', repr(implem))
        self.assertEqual('doc for blah', implem.__doc__)

    def test_using(self):
        def blah(obj):  # pragma: no cover
            pass

        class MyClass(object):
            state = self.foo

        implem = base.ImplementationProperty(
            field_name='my_state', transition=self.foobar, workflow=None,
            implementation=blah)

        MyClass.foobar = implem
        self.assertEqual(implem, MyClass.foobar)

        o = MyClass()
        self.assertRaises(TypeError, getattr, o, 'foobar')

    def test_copy(self):
        def blah(obj):  # pragma: no cover
            """Doc for blah"""
            pass

        implem = base.ImplementationProperty(
            field_name='my_state', transition=self.foobar, workflow=None,
            implementation=blah)

        implem2 = implem.copy()
        self.assertEqual('my_state', implem2.field_name)
        self.assertEqual(self.foobar, implem2.transition)
        self.assertIsNone(implem2.workflow)
        self.assertEqual(blah, implem2.implementation)
        self.assertEqual("Doc for blah", implem2.__doc__)
        self.assertEqual({}, implem2.hooks)

    def test_copy_exclude_hooks(self):
        def blah(obj):  # pragma: no cover
            """Doc for blah"""
            pass

        @base.before_transition('foo')
        def hook():
            pass

        implem = base.ImplementationProperty(
            field_name='my_state', transition=self.foobar, workflow=None,
            implementation=blah)
        # Structure: {'before': [('foo', hook)]}
        h = hook.xworkflows_hook['before'][0][1]
        implem.add_hook(h)

        implem2 = implem.copy()
        self.assertEqual({}, implem2.hooks)


class TransitionWrapperTestCase(unittest.TestCase):

    def setUp(self):
        self.wrapper = base.TransitionWrapper('foobar')

    def test_txt(self):
        self.assertIn('foobar', repr(self.wrapper))


class HookTestCase(unittest.TestCase):
    def test_validation(self):
        def make_invalid_hook():
            return base.Hook('invalid_kind', base.noop)

        self.assertRaises(AssertionError, make_invalid_hook)

    def test_no_names(self):
        hook = base.Hook(base.HOOK_BEFORE, base.noop)
        self.assertEqual(base.HOOK_BEFORE, hook.kind)
        self.assertEqual(0, hook.priority)
        self.assertEqual(base.noop, hook.function)
        self.assertEqual(('*',), hook.names)

    def test_no_names_but_priority(self):
        hook = base.Hook(base.HOOK_BEFORE, base.noop, priority=42)
        self.assertEqual(base.HOOK_BEFORE, hook.kind)
        self.assertEqual(42, hook.priority)
        self.assertEqual(base.noop, hook.function)
        self.assertEqual(('*',), hook.names)

    def test_some_names_no_priority(self):
        hook = base.Hook(base.HOOK_BEFORE, base.noop, 'foo', 'bar')
        self.assertEqual(base.HOOK_BEFORE, hook.kind)
        self.assertEqual(0, hook.priority)
        self.assertEqual(base.noop, hook.function)
        self.assertEqual(('foo', 'bar'), hook.names)

    def test_some_names_and_priority(self):
        hook = base.Hook(base.HOOK_BEFORE, base.noop, 'foo', 'bar', priority=42)
        self.assertEqual(base.HOOK_BEFORE, hook.kind)
        self.assertEqual(42, hook.priority)
        self.assertEqual(base.noop, hook.function)
        self.assertEqual(('foo', 'bar'), hook.names)

    def test_equality(self):
        hook1 = base.Hook(base.HOOK_BEFORE, base.noop)
        hook2 = base.Hook(base.HOOK_BEFORE, base.noop)
        hook3 = base.Hook(base.HOOK_AFTER, base.noop)
        def alt_noop(*args, **kwargs):  # pragma: no cover
            pass
        hook4 = base.Hook(base.HOOK_BEFORE, alt_noop)
        hook5 = base.Hook(base.HOOK_BEFORE, base.noop, 'foo')
        hook6 = base.Hook(base.HOOK_BEFORE, base.noop, priority=42)

        self.assertEqual(hook1, hook2)
        self.assertNotEqual(hook1, hook3)
        self.assertNotEqual(hook1, hook4)
        self.assertNotEqual(hook1, hook5)
        self.assertNotEqual(hook1, hook6)

    def test_invalid_equality_checks(self):
        hook = base.Hook(base.HOOK_BEFORE, base.noop)
        self.assertTrue(hook != base.noop)
        self.assertFalse(hook == base.noop)

    def test_comparison(self):
        hook1 = base.Hook(base.HOOK_BEFORE, base.noop)
        hook2 = base.Hook(base.HOOK_AFTER, base.noop)
        hook3 = base.Hook(base.HOOK_BEFORE, base.noop, priority=2)
        def alt_noop(*args, **kwargs):  # pragma: no cover
            pass
        hook4 = base.Hook(base.HOOK_BEFORE, alt_noop)

        # Hooks with same priority and function name compare equal wrt cmp
        self.assertFalse(hook1 < hook2)
        self.assertFalse(hook2 < hook1)
        # Hook 3 has higher priority, comes first
        self.assertLess(hook3, hook1)
        # Hook 4 has lower name, comes first
        self.assertLess(hook4, hook1)

    def test_repr(self):
        hook = base.Hook(base.HOOK_BEFORE, base.noop)
        self.assertIn(repr(base.noop), repr(hook))
        self.assertIn(base.HOOK_BEFORE, repr(hook))


class TransitionHookDeclarationTestCase(unittest.TestCase):
    def test_simple_definition(self):
        decl = base.before_transition('foo', 'bar')
        self.assertEqual(0, decl.priority)
        self.assertEqual('', decl.field)
        self.assertEqual(('foo', 'bar'), decl.names)

    def test_definition_no_transition_name(self):
        decl = base.before_transition()
        self.assertEqual(0, decl.priority)
        self.assertEqual('', decl.field)
        self.assertEqual(('*',), decl.names)

    def test_full_definition(self):
        decl = base.before_transition('foo', 'bar', priority=3, field='st')
        self.assertEqual(3, decl.priority)
        self.assertEqual('st', decl.field)
        self.assertEqual(('foo', 'bar'), decl.names)


class StateHookDeclarationTestCase(unittest.TestCase):
    def test_simple_definition(self):
        decl = base.on_enter_state('foo', 'bar')
        self.assertEqual(0, decl.priority)
        self.assertEqual('', decl.field)
        self.assertEqual(('foo', 'bar'), decl.names)

    def test_definition_no_transition_name(self):
        decl = base.on_enter_state()
        self.assertEqual(0, decl.priority)
        self.assertEqual('', decl.field)
        self.assertEqual(('*',), decl.names)

    def test_full_definition(self):
        decl = base.on_enter_state('foo', 'bar', priority=3, field='st')
        self.assertEqual(3, decl.priority)
        self.assertEqual('st', decl.field)
        self.assertEqual(('foo', 'bar'), decl.names)


class ImplementationWrapperTestCase(unittest.TestCase):
    def setUp(self):
        class Dummy(object):
            state1 = 'foo'
            state2 = 'bar'

        self.dummy = Dummy()

    def test_current_state(self):
        wrapper = base.ImplementationWrapper(self.dummy, 'state1', None, None,
            base.noop)
        self.assertEqual('foo', wrapper.current_state)
        self.assertEqual(base.noop.__doc__, wrapper.__doc__)

    def test_repr(self):
        wrapper = base.ImplementationWrapper(self.dummy, 'state1',
            base.Transition('foobar', [base.State('foo', 'Foo')],
                base.State('bar', 'Bar')), None,
            base.noop)
        self.assertIn('foobar', repr(wrapper))
        self.assertIn('state1', repr(wrapper))
        self.assertIn(repr(base.noop), repr(wrapper))


if __name__ == '__main__':  # pragma: no cover
    unittest.main()

########NEW FILE########
__FILENAME__ = test_using
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.

import warnings

from .compat import is_python3, unittest, u

from xworkflows import base


class WorkflowDeclarationTestCase(unittest.TestCase):

    def assertExpected(self, workflow, initial_state='foo'):
        self.assertEqual(3, len(workflow.states))
        self.assertEqual(3, len(workflow.transitions))
        self.assertEqual(workflow.states[initial_state], workflow.initial_state)
        self.assertEqual([workflow.states['foo']], workflow.transitions['foobar'].source)
        self.assertEqual(workflow.states['bar'], workflow.transitions['foobar'].target)

        for state in workflow.states:
            exp_title = state.name.capitalize()
            self.assertEqual(exp_title, state.title)
            self.assertIn(state.name, ('foo', 'bar', 'baz'))

    def test_simple_definition(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', 'Foo'),
                ('bar', 'Bar'),
                ('baz', 'Baz'),
            )
            transitions = (
                ('foobar', ('foo',), 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', ('baz',), 'bar'),
            )
            initial_state = 'foo'

        self.assertExpected(MyWorkflow)

    def test_subclassing(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.assertExpected(MyWorkflow)

        class MySubWorkflow(MyWorkflow):
            initial_state = 'bar'

        self.assertExpected(MySubWorkflow, initial_state='bar')

    def test_subclassing_alt(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.assertExpected(MyWorkflow)

        class MySubWorkflow(MyWorkflow):
            initial_state = 'bar'
            states = (
                ('bar', "BARBAR"),
                ('blah', 'Blah'),
            )
            transitions = (
                ('gobaz', ('foo', 'bar', 'blah'), 'baz'),
                ('blahblah', ('blah',), 'blah'),
            )

        self.assertEqual(4, len(MySubWorkflow.states))
        self.assertEqual([st.name for st in MySubWorkflow.states],
            ['foo', 'bar', 'baz', 'blah'])
        self.assertEqual('bar', MySubWorkflow.initial_state.name)
        self.assertEqual(MySubWorkflow.states.bar, MySubWorkflow.initial_state)
        self.assertEqual('BARBAR', MySubWorkflow.states.bar.title)
        self.assertEqual('Blah', MySubWorkflow.states.blah.title)

        self.assertEqual(4, len(MySubWorkflow.transitions))
        self.assertEqual([tr.name for tr in MySubWorkflow.transitions],
            ['foobar', 'gobaz', 'bazbar', 'blahblah'])
        self.assertEqual(3, len(MySubWorkflow.transitions.gobaz.source))

    def test_invalid_definitions(self):
        def create_invalid_workflow_1():
            class MyWorkflow(base.Workflow):
                states = (12, 13, 14)
                transitions = tuple()
                initial_state = 12

        self.assertRaises(TypeError, create_invalid_workflow_1)

        def create_invalid_workflow_2():
            class MyWorkflow(base.Workflow):
                states = (
                    (1, 2, 3),
                    (2, 3, 4)
                )
                transitions = tuple()
                initial_state = 12

        self.assertRaises(TypeError, create_invalid_workflow_2)

        def create_invalid_workflow_3():
            class MyWorkflow(base.Workflow):
                states = (
                    ('foo', "Foo"),
                    ('bar', "Bar"),
                    ('baz', "Baz"),
                )
                transitions = (
                    ('foobar', 'bbb', 'bar'),
                )
                initial_state = 'foo'

        self.assertRaises(KeyError, create_invalid_workflow_3)

        def create_invalid_workflow_4():
            class MyWorkflow(base.Workflow):
                states = (
                    ('foo', "Foo"),
                    ('bar', "Bar"),
                    ('baz', "Baz"),
                )
                transitions = (
                    ('foobar', 'bbb'),
                )
                initial_state = 'foo'

        self.assertRaises(TypeError, create_invalid_workflow_4)


class WorkflowEnabledTestCase(unittest.TestCase):
    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.MyWorkflow = MyWorkflow

    def test_declaration(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

        self.assertEqual('state', MyWorkflowObject.state.field_name)
        self.assertEqual(self.MyWorkflow.states, MyWorkflowObject.state.workflow.states)
        self.assertIn('state', str(MyWorkflowObject.state))

    def test_instantiation(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

        obj = MyWorkflowObject()
        self.assertEqual(self.MyWorkflow.initial_state, obj.state)
        self.assertEqual(2, len(list(obj.state.transitions())))

    def test_state_setting(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

        obj = MyWorkflowObject()

        self.assertRaises(ValueError, setattr, obj, 'state', base.State('a', 'A'))

    def test_implementation_conflict(self):
        def create_invalid_workflow_enabled():
            class MyWorkflowObject(base.WorkflowEnabled):
                wf = self.MyWorkflow()
                foobar = 42

        self.assertRaises(ValueError, create_invalid_workflow_enabled)

    def test_renamed_implementation(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

            @base.transition('foobar')
            def blah(self):  # pragma: no cover
                pass

        def create_invalid_workflow_enabled():
            class MyWorkflowObject(base.WorkflowEnabled):
                foobar = 42
                wf = MyWorkflow()

        # No implementation for 'foobar' - data from the Workflow was ignored.
        self.assertRaises(ValueError, create_invalid_workflow_enabled)

    def test_override_renamed(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

            def foobar(self):  # pragma: no cover
                pass

        class MyWorkflowObject(base.WorkflowEnabled):
            wf = MyWorkflow()

            @base.transition('foobar')
            def blah(self):  # pragma: no cover
                pass

        self.assertFalse(hasattr(MyWorkflowObject, 'foobar'))

    def test_override_conflict(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

            def foobar(self):  # pragma: no cover
                pass

        def create_invalid_workflow_enabled():
            class MyWorkflowObject(base.WorkflowEnabled):
                wf = MyWorkflow()

                @base.transition('gobaz')
                def foobar(self):  # pragma: no cover
                    pass

        self.assertRaises(ValueError, create_invalid_workflow_enabled)

    def test_override_with_invalid_wrapper(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

            def foobar(self):  # pragma: no cover
                pass

        def create_invalid_workflow_enabled():
            class MyWorkflowObject(base.WorkflowEnabled):
                wf = MyWorkflow()

                @base.transition('blah')
                def foobar(self):  # pragma: no cover
                    pass

        self.assertRaises(ValueError, create_invalid_workflow_enabled)

    def test_override_with_constant(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

            def foobar(self):  # pragma: no cover
                pass

        def create_invalid_workflow_enabled():
            class MyWorkflowObject(base.WorkflowEnabled):
                wf = MyWorkflow()

                foobar = 42

        self.assertRaises(ValueError, create_invalid_workflow_enabled)

    def test_dual_workflows_conflict(self):

        def create_invalid_workflow_enabled():
            class MyWorkflowObject(base.WorkflowEnabled):
                state1 = self.MyWorkflow()
                state2 = self.MyWorkflow()

        self.assertRaises(ValueError, create_invalid_workflow_enabled)

    def test_dual_workflows(self):
        class MyAltWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('altfoobar', 'foo', 'bar'),
                ('altgobaz', ('foo', 'bar'), 'baz'),
                ('altbazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        class MyWorkflowObject(base.WorkflowEnabled):
            state1 = self.MyWorkflow()
            state2 = MyAltWorkflow()

        self.assertEqual('state1', MyWorkflowObject.state1.field_name)
        self.assertEqual('state2', MyWorkflowObject.state2.field_name)

        obj = MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.initial_state, obj.state1)
        self.assertEqual(MyAltWorkflow.initial_state, obj.state2)

    def test_inheritance(self):
        class MyObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

        class MySubObject(MyObject):
            @base.transition()
            def foobar(self):
                return 42

        obj = MySubObject()
        self.assertTrue(hasattr(MySubObject, '_workflows'))
        self.assertIn('state', MySubObject._workflows)
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual(42, obj.foobar())
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)
        obj.gobaz()
        self.assertEqual(self.MyWorkflow.states.baz, obj.state)

    def test_inherited_implementation(self):
        class MyObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            @base.transition()
            def foobar(self):
                return 42

        class MySubObject(MyObject):
            pass

        obj = MySubObject()
        self.assertTrue(hasattr(MySubObject, '_workflows'))
        self.assertIn('state', MySubObject._workflows)
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual(42, obj.foobar())
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)
        obj.gobaz()
        self.assertEqual(self.MyWorkflow.states.baz, obj.state)

    def test_deeply_inherited_implementation(self):
        class MyObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            @base.transition()
            def foobar(self):
                return 42

        class MySubObject(MyObject):
            pass

        class MySubSubObject(MySubObject):
            pass

        obj = MySubSubObject()
        self.assertTrue(hasattr(MySubSubObject, '_workflows'))
        self.assertIn('state', MySubSubObject._workflows)
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual(42, obj.foobar())
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)
        obj.gobaz()
        self.assertEqual(self.MyWorkflow.states.baz, obj.state)

    def test_inherited_overridden_implementation(self):
        class MyObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            @base.transition()
            def foobar(self):  # pragma: no cover
                return 13

        class MySubObject(MyObject):
            @base.transition()
            def foobar(self):
                return 42

        class MySubSubObject(MySubObject):
            pass

        obj = MySubSubObject()
        self.assertTrue(hasattr(MySubSubObject, '_workflows'))
        self.assertIn('state', MySubSubObject._workflows)
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual(42, obj.foobar())
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)
        obj.gobaz()
        self.assertEqual(self.MyWorkflow.states.baz, obj.state)

    def test_inheritance_override_workflow(self):
        class MyAltWorkflow(base.Workflow):
            states = (
                ('fo', "Foo"),
                ('br', "Bar"),
                ('bz', "Baz"),
            )
            transitions = (
                ('altfoobar', 'fo', 'br'),
                ('altgobaz', ('fo', 'br'), 'bz'),
                ('altbazbar', 'bz', 'br'),
            )
            initial_state = 'fo'

        class MyObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

        class MySubObject(MyObject):
            state = MyAltWorkflow()

        self.assertTrue(hasattr(MySubObject, '_workflows'))
        self.assertIn('state', MySubObject._workflows)
        self.assertEqual(MyAltWorkflow,
            MySubObject._workflows['state'].workflow.__class__)
        obj = MySubObject()
        self.assertEqual(MyAltWorkflow.states.fo, obj.state)
        self.assertFalse(hasattr(obj, 'gobar'))


class TransitionRunningTestCase(unittest.TestCase):

    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        class MyWorkflowObject(base.WorkflowEnabled):
            state = MyWorkflow()

            def __repr__(self):
                return u("blé∫")

        self.MyWorkflow = MyWorkflow
        self.MyWorkflowObject = MyWorkflowObject

    def test_transition(self):
        obj = self.MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.states['foo'], obj.state)
        obj.foobar()
        self.assertEqual(self.MyWorkflow.states['bar'], obj.state)
        obj.gobaz()
        self.assertEqual(self.MyWorkflow.states.baz, obj.state)
        obj.bazbar()
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)

    def test_invalid_transition(self):
        obj = self.MyWorkflowObject()

        self.assertRaises(base.InvalidTransitionError, obj.bazbar)

    def test_instance_independance(self):
        obj1 = self.MyWorkflowObject()
        obj2 = self.MyWorkflowObject()

        obj1.foobar()

        self.assertEqual(self.MyWorkflow.states.bar, obj1.state)
        self.assertEqual(self.MyWorkflow.states.foo, obj2.state)

    def test_dual_workflows(self):
        class MyAltWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('altfoobar', 'foo', 'bar'),
                ('altgobaz', ('foo', 'bar'), 'baz'),
                ('altbazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        class MyWorkflowObject(base.WorkflowEnabled):
            state1 = self.MyWorkflow()
            state2 = MyAltWorkflow()

        obj = MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.states.foo, obj.state1)
        self.assertEqual(MyAltWorkflow.states.foo, obj.state2)

    def test_dual_workflows_conflict(self):
        """Define an object with two workflows and conflicting transitions."""

        class MyAltWorkflow(base.Workflow):
            states = (
                ('foo2', "Foo"),
                ('bar2', "Bar"),
                ('baz2', "Baz"),
            )
            transitions = (
                ('foobar', 'foo2', 'bar2'),
                ('gobaz', ('foo2', 'bar2'), 'baz2'),
                ('bazbar', 'baz2', 'bar2'),
            )
            initial_state = 'foo2'

        def create_invalid_workflow_object():
            class MyWorkflowObject(base.WorkflowEnabled):
                state1 = self.MyWorkflow()
                state2 = MyAltWorkflow()

        self.assertRaises(ValueError, create_invalid_workflow_object)

        def create_other_invalid_workflow_object():
            """Resolve only some transitions."""
            class MyWorkflowObject(base.WorkflowEnabled):
                state1 = self.MyWorkflow()
                state2 = MyAltWorkflow()

                @base.transition('foobar', field='state2')
                def foobar2(self):  # pragma: no cover
                    pass

                @base.transition('gobaz', field='state2')
                def gobaz2(self):  # pragma: no cover
                    pass

        self.assertRaises(ValueError, create_other_invalid_workflow_object)

    def test_dual_workflows_conflict_resolved(self):
        """Define an object with two workflows and renamed transitions."""

        class MyAltWorkflow(base.Workflow):
            states = (
                ('foo2', "Foo"),
                ('bar2', "Bar"),
                ('baz2', "Baz"),
            )
            transitions = (
                ('foobar', 'foo2', 'bar2'),
                ('gobaz', ('foo2', 'bar2'), 'baz2'),
                ('bazbar', 'baz2', 'bar2'),
            )
            initial_state = 'foo2'

        class MyWorkflowObject(base.WorkflowEnabled):
            state1 = self.MyWorkflow()
            state2 = MyAltWorkflow()

            @base.transition('foobar', field='state2')
            def foobar2(self):  # pragma: no cover
                pass

            @base.transition('gobaz', field='state2')
            def gobaz2(self):  # pragma: no cover
                pass

            @base.transition('bazbar', field='state2')
            def bazbar2(self):  # pragma: no cover
                pass

        obj = MyWorkflowObject()
        self.assertEqual(self.MyWorkflow.states.foo, obj.state1)
        self.assertEqual(MyAltWorkflow.states.foo2, obj.state2)

        obj.foobar()
        self.assertEqual(self.MyWorkflow.states.bar, obj.state1)
        self.assertEqual(MyAltWorkflow.states.foo2, obj.state2)

        obj.gobaz2()
        self.assertEqual(self.MyWorkflow.states.bar, obj.state1)
        self.assertEqual(MyAltWorkflow.states.baz2, obj.state2)


class CustomImplementationTestCase(unittest.TestCase):

    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('barbaz', 'bar', 'baz'),
            )
            initial_state = 'foo'

            def foobar(self, res):  # pragma: no cover
                return res

        self.MyWorkflow = MyWorkflow

    def test_workflow_defined(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

        obj = MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual(None, obj.foobar('blah'))  # Workflow method ignored.
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)

    def test_instance_defined(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            @base.transition()
            def gobaz(self, res):
                return res + res

        obj = MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual('blahblah', obj.gobaz('blah'))
        self.assertEqual(self.MyWorkflow.states.baz, obj.state)

    def test_instance_badly_defined(self):
        """Test misuse of the @transition decorator."""
        def misuse_decorator():
            @base.transition
            def my_transition():  # pragma: no cover
                pass

        self.assertRaises(ValueError, misuse_decorator)

    def test_instance_override(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            @base.transition()
            def foobar(self, res):
                return res + res

        obj = MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertEqual('blahblah', obj.foobar('blah'))
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)

    def test_transition_conflict(self):
        """Test conflict of two implementation for the same transition."""
        def declare_bad_workflow():
            class MyWorkflowObject(base.WorkflowEnabled):
                state = self.MyWorkflow()

                @base.transition('foobar')
                def foobar(self):  # pragma: no cover
                    pass

                @base.transition('foobar')
                def altfoobar(self):  # pragma: no cover
                    pass

        self.assertRaises(ValueError, declare_bad_workflow)

    def test_abort_transition(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def check_foobar(self):
                return False

            @base.transition(check=check_foobar)
            def foobar(self):  # pragma: no cover
                pass

            @base.transition()
            def gobaz(self):
                raise KeyError()

        obj = MyWorkflowObject()

        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertRaises(base.ForbiddenTransition, obj.foobar)
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)

        self.assertRaises(KeyError, obj.gobaz)
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)

    def test_checks(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()
            x = 13

            def check_foobar(self):
                return self.x == 42

            @base.transition(check=check_foobar)
            def foobar(self):
                pass

            def check_barbaz(self):
                return False

            @base.transition(check=check_barbaz)
            def barbaz(self):  # pragma: no cover
                pass

        obj = MyWorkflowObject()

        # Not available from state==foo
        self.assertRaises(base.InvalidTransitionError, obj.barbaz)
        self.assertFalse(obj.barbaz.is_available())

        # Transition forbidden by check_foobar
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        self.assertRaises(base.ForbiddenTransition, obj.foobar)
        self.assertFalse(obj.foobar.is_available())
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)

        obj.x = 42
        self.assertTrue(obj.foobar.is_available())
        obj.foobar()
        self.assertEqual(self.MyWorkflow.states.bar, obj.state)

        self.assertRaises(base.ForbiddenTransition, obj.barbaz)
        self.assertFalse(obj.barbaz.is_available())


class DeprecatedHookTestCase(unittest.TestCase):
    def test_check_hook(self):
        """Test that using @transition(check=X) raises a warning."""
        with warnings.catch_warnings(record=True) as w:
            __warningregistry__.clear()
            warnings.simplefilter('always')

            @base.transition(check=base.noop)
            def foobar(*args, **kwargs):  # pragma: no cover
                pass

            self.assertEqual(1, len(w))
            self.assertIn('deprecated', str(w[0].message))

    def test_before_hook(self):
        """Test that using @transition(before=X) raises a warning."""
        with warnings.catch_warnings(record=True) as w:
            __warningregistry__.clear()
            warnings.simplefilter('always')

            @base.transition(before=base.noop)
            def foobar(*args, **kwargs):  # pragma: no cover
                pass

            self.assertEqual(1, len(w))
            self.assertIn('deprecated', str(w[0].message))

    def test_after_hook(self):
        """Test that using @transition(after=X) raises a warning."""
        with warnings.catch_warnings(record=True) as w:
            __warningregistry__.clear()
            warnings.simplefilter('always')

            @base.transition(after=base.noop)
            def foobar(*args, **kwargs):  # pragma: no cover
                pass

            self.assertEqual(1, len(w))
            self.assertIn('deprecated', str(w[0].message))


class TransitionHookTestCase(unittest.TestCase):
    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.MyWorkflow = MyWorkflow

        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self, state=None):
                self.hooks = []
                if state:
                    self.state = state

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            @base.before_transition('foobar')
            def hook1(self, *args, **kwargs):
                self.seen_hook(1)

            @base.after_transition('foobar', 'gobaz')
            def hook2(self, *args, **kwargs):
                self.seen_hook(2)

            @base.before_transition('foobar', priority=2)
            @base.after_transition('gobaz', priority=3)
            def hook3(self, *args, **kwargs):
                self.seen_hook(3)
                return True

            @base.transition_check()
            def hook4(self, *args, **kwargs):
                self.seen_hook(4)
                return True

            @base.after_transition('gobaz', priority=1)
            @base.after_transition('bazbar')
            @base.after_transition('gobaz', priority=10)
            @base.transition_check('foobar', priority=1)
            def hook5(self, *args, **kwargs):
                self.seen_hook(5)
                return True

        self.MyWorkflowObject = MyWorkflowObject

    def assert_same_hooks(self, actual, expected, kind):
        """Tests that the 'actual' dict contains expected hooks.

        Matching is performed on (priority, callable, kind) pairs.
        """
        expected_items = sorted(
            ((priority, fun, kind) for (priority, fun) in expected),
            key=lambda t: (t[0], hash(t[1]), t[2]))
        actual_items = sorted(
            ((hook.priority, hook.function, hook.kind) for hook in actual),
            key=lambda t: (t[0], hash(t[1]), t[2]))
        self.assertEqual(list(expected_items), list(actual_items))

    def test_declarations(self):
        obj = self.MyWorkflowObject()
        self.assert_same_hooks(obj.foobar.hooks['check'], [
            (0, obj.hook4.__func__),
            (1, obj.hook5.__func__),
        ], 'check')
        self.assert_same_hooks(obj.foobar.hooks['before'], [
            (0, obj.hook1.__func__),
            (2, obj.hook3.__func__),
        ], 'before')
        self.assert_same_hooks(obj.foobar.hooks['after'], [
            (0, obj.hook2.__func__),
        ], 'after')

        self.assert_same_hooks(obj.gobaz.hooks['check'], [
            (0, obj.hook4.__func__),
        ], 'check')
        self.assert_same_hooks(obj.gobaz.hooks.get('before', []), [
        ], 'before')
        self.assert_same_hooks(obj.gobaz.hooks['after'], [
            (0, obj.hook2.__func__),
            (3, obj.hook3.__func__),
            (1, obj.hook5.__func__),
            (10, obj.hook5.__func__),
        ], 'after')

        self.assert_same_hooks(obj.bazbar.hooks['check'], [
            (0, obj.hook4.__func__),
        ], 'check')
        self.assert_same_hooks(obj.bazbar.hooks['after'], [
            (0, obj.hook5.__func__),
        ], 'after')

    def test_checks(self):
        obj = self.MyWorkflowObject()
        self.assertTrue(obj.foobar.is_available())
        self.assertEqual([5, 4], obj.hooks)

        obj = self.MyWorkflowObject()
        self.assertTrue(obj.gobaz.is_available())
        self.assertEqual([4], obj.hooks)

        obj = self.MyWorkflowObject(state=self.MyWorkflow.states.baz)
        self.assertTrue(obj.bazbar.is_available())
        self.assertEqual([4], obj.hooks)

    def test_transitions_a(self):
        obj = self.MyWorkflowObject()
        obj.foobar()
        # check: 5, 4
        # before: 3, 1
        # after: 2
        self.assertEqual([5, 4, 3, 1, 2], obj.hooks)

    def test_transitions_b(self):
        obj = self.MyWorkflowObject()
        obj.gobaz()
        # check: 4
        # before: -
        # after: 5, 3, 5, 2
        self.assertEqual([4, 5, 3, 5, 2], obj.hooks)

    def test_transitions_c(self):
        obj = self.MyWorkflowObject(state=self.MyWorkflow.states.baz)
        obj.bazbar()
        # check: 4
        # before: -
        # after: 5
        self.assertEqual([4, 5], obj.hooks)

    def test_oldstyle_check(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            def hook(self, *args, **kwargs):
                self.seen_hook(1)
                return True

            @base.transition(check=hook)
            def foobar(self, *args, **kwargs):
                self.seen_hook(2)

        obj = MyWorkflowObject()
        obj.foobar.is_available()
        self.assertEqual([1], obj.hooks)
        obj.foobar()
        self.assertEqual([1, 1, 2], obj.hooks)

    def test_oldstyle_before(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            def hook(self, *args, **kwargs):
                self.seen_hook(1)

            @base.transition(before=hook)
            def foobar(self, *args, **kwargs):
                self.seen_hook(2)

        obj = MyWorkflowObject()
        obj.foobar()
        self.assertEqual([1, 2], obj.hooks)

    def test_oldstyle_after(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            def hook(self, *args, **kwargs):
                self.seen_hook(1)

            @base.transition(after=hook)
            def foobar(self, *args, **kwargs):
                self.seen_hook(2)

        obj = MyWorkflowObject()
        obj.foobar()
        self.assertEqual([2, 1], obj.hooks)

    def test_named_state(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.args = None
                self.kwargs = None

            @base.before_transition(self.MyWorkflow.transitions.foobar)
            def before(self, *args, **kwargs):
                self.args = args
                self.kwargs = kwargs

        obj = MyWorkflowObject()
        self.assertIsNone(obj.args)
        self.assertIsNone(obj.kwargs)

        obj.foobar(1, 2, 3, a=4, b=5)
        self.assertEqual((1, 2, 3), obj.args)
        self.assertEqual({'a': 4, 'b': 5}, obj.kwargs)


    def test_before_args(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.args = None
                self.kwargs = None

            @base.before_transition('foobar')
            def before(self, *args, **kwargs):
                self.args = args
                self.kwargs = kwargs

        obj = MyWorkflowObject()
        self.assertIsNone(obj.args)
        self.assertIsNone(obj.kwargs)

        obj.foobar(1, 2, 3, a=4, b=5)
        self.assertEqual((1, 2, 3), obj.args)
        self.assertEqual({'a': 4, 'b': 5}, obj.kwargs)

    def test_check_args(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.args = None
                self.kwargs = None

            @base.transition_check('foobar')
            def check(self, *args, **kwargs):
                self.args = args
                self.kwargs = kwargs
                return True

        obj = MyWorkflowObject()
        self.assertIsNone(obj.args)
        self.assertIsNone(obj.kwargs)

        obj.foobar(1, 2, 3, a=4, b=5)
        self.assertEqual((), obj.args)
        self.assertEqual({}, obj.kwargs)

    def test_after_args(self):
        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.args = None
                self.kwargs = None

            @base.after_transition('foobar')
            def after(self, *args, **kwargs):
                self.args = args
                self.kwargs = kwargs

            @base.transition()
            def foobar(self, *args, **kwargs):
                return 42

        obj = MyWorkflowObject()
        self.assertIsNone(obj.args)
        self.assertIsNone(obj.kwargs)

        obj.foobar(1, 2, 3, a=4, b=5)
        self.assertEqual((42, 1, 2, 3), obj.args)
        self.assertEqual({'a': 4, 'b': 5}, obj.kwargs)

    def test_mixed_fields(self):
        """Test hooks in a dual workflow setup."""
        class MyWorkflowObject(base.WorkflowEnabled):
            state1 = self.MyWorkflow()
            state2 = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            @base.before_transition()
            def hook1(self, *args, **kwargs):
                self.seen_hook(1)

            @base.before_transition('foobar', field='state1')
            def hook2(self, *args, **kwargs):
                self.seen_hook(2)

            @base.transition('foobar', field='state2')
            def foobar2(self):
                pass

            @base.transition('gobaz', field='state2')
            def gobaz2(self):  # pragma: no cover
                pass

            @base.transition('bazbar', field='state2')
            def bazbar2(self):  # pragma: no cover
                pass

        obj = MyWorkflowObject()
        obj.foobar()
        self.assertEqual([1, 2], obj.hooks)

        obj = MyWorkflowObject()
        obj.foobar2()
        self.assertEqual([1], obj.hooks)


class StateHookTestCase(unittest.TestCase):
    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.MyWorkflow = MyWorkflow

        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self, state=None):
                self.hooks = []
                if state:
                    self.state = state

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            @base.on_leave_state('foo')
            def hook1(self, *args, **kwargs):
                self.seen_hook(1)

            @base.on_enter_state('bar', 'baz')
            def hook2(self, *args, **kwargs):
                self.seen_hook(2)

            @base.on_enter_state('bar', priority=2)
            @base.on_leave_state('bar', priority=3)
            def hook3(self, *args, **kwargs):
                self.seen_hook(3)

            @base.on_leave_state()
            def hook4(self, *args, **kwargs):
                self.seen_hook(4)

        self.MyWorkflowObject = MyWorkflowObject

    def assert_same_hooks(self, actual, expected, kind):
        """Tests that the 'actual' dict contains expected hooks.

        Matching is performed on (priority, callable, kind) pairs.
        """
        expected_items = sorted(
            ((priority, fun, kind) for (priority, fun) in expected),
            key=lambda t: (t[0], hash(t[1]), t[2]))
        actual_items = sorted(
            ((hook.priority, hook.function, hook.kind) for hook in actual),
            key=lambda t: (t[0], hash(t[1]), t[2]))
        self.assertEqual(list(expected_items), list(actual_items))

    def test_declarations(self):
        obj = self.MyWorkflowObject()
        self.assert_same_hooks(obj.foobar.hooks['on_leave'], [
            (0, obj.hook1.__func__),
            (0, obj.hook4.__func__),
        ], 'on_leave')
        self.assert_same_hooks(obj.foobar.hooks['on_enter'], [
            (0, obj.hook2.__func__),
            (2, obj.hook3.__func__),
        ], 'on_enter')

        self.assert_same_hooks(obj.gobaz.hooks['on_leave'], [
            (0, obj.hook1.__func__),
            (3, obj.hook3.__func__),
            (0, obj.hook4.__func__),
        ], 'on_leave')
        self.assert_same_hooks(obj.gobaz.hooks['on_enter'], [
            (0, obj.hook2.__func__),
        ], 'on_enter')

        self.assert_same_hooks(obj.bazbar.hooks['on_leave'], [
            (0, obj.hook4.__func__),
        ], 'on_leave')
        self.assert_same_hooks(obj.bazbar.hooks['on_enter'], [
            (0, obj.hook2.__func__),
            (2, obj.hook3.__func__),
        ], 'on_enter')

    def test_transitions_a(self):
        obj = self.MyWorkflowObject()
        obj.foobar()
        # on_leave: 1, 4
        # on_enter: 3, 2
        self.assertEqual([1, 4, 3, 2], obj.hooks)

    def test_transitions_b(self):
        obj = self.MyWorkflowObject()
        obj.gobaz()
        # on_leave: 1, 4
        # on_enter: 2
        self.assertEqual([1, 4, 2], obj.hooks)

    def test_transitions_c(self):
        obj = self.MyWorkflowObject(state=self.MyWorkflow.states.baz)
        obj.bazbar()
        # on_leave: 4
        # on_enter: 3, 2
        self.assertEqual([4, 3, 2], obj.hooks)


class HookInheritanceTestCase(unittest.TestCase):
    """Tests related to hooks and inherited workflows."""

    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.MyWorkflow = MyWorkflow

        class MyWorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            @base.before_transition('foobar')
            def hook1(self, *args, **kwargs):
                self.seen_hook(1)

            @base.after_transition('foobar', 'gobaz')
            def hook2(self, *args, **kwargs):
                self.seen_hook(2)

        self.MyWorkflowObject = MyWorkflowObject

    def test_no_override(self):
        class MySubWorkflowObject(self.MyWorkflowObject):
            pass

        obj = MySubWorkflowObject()
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        obj.foobar()
        # check: -
        # before: 1
        # after: 2
        self.assertEqual([1, 2], obj.hooks)

    def test_multiple_inherited(self):
        class WorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            @base.on_leave_state('foo')
            def hook1(self, *args, **kwargs):
                self.seen_hook(1)

        class MyFirstSub(WorkflowObject):
            pass

        class MySecondSub(WorkflowObject):
            pass

        o1 = MyFirstSub()
        self.assertEqual(self.MyWorkflow.states.foo, o1.state)
        o1.foobar()
        # check: -
        # before: 1
        # after: 2
        self.assertEqual([1], o1.hooks)

        o2 = MySecondSub()
        self.assertEqual(self.MyWorkflow.states.foo, o2.state)
        o2.foobar()
        # check: -
        # before: 1
        # after: 2
        self.assertEqual([1], o2.hooks)

    def test_extra_hook(self):
        class MySubWorkflowObject(self.MyWorkflowObject):
            @base.before_transition('foobar')
            def hook3(self, *args, **kwargs):
                self.seen_hook(3)

        obj = MySubWorkflowObject()
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        obj.foobar()
        # check: -
        # before: 1, 3
        # after: 2
        self.assertEqual([1, 3, 2], obj.hooks)

    def test_conflict_extend(self):
        """Tests that a hook with a conflicting name replaces parents.."""

        class MySubWorkflowObject(self.MyWorkflowObject):
            @base.before_transition('foobar')
            def hook1(self, *args, **kwargs):
                self.seen_hook(3)

        obj = MySubWorkflowObject()
        self.assertEqual(self.MyWorkflow.states.foo, obj.state)
        obj.foobar()
        # check: -
        # before: 3
        # after: 2
        self.assertEqual([3, 2], obj.hooks)

    def test_multiple_inherited_with_implem(self):
        class WorkflowObject(base.WorkflowEnabled):
            state = self.MyWorkflow()

            def __init__(self):
                self.hooks = []

            def seen_hook(self, hook_id):
                self.hooks.append(hook_id)

            @base.transition()
            def foobar(self, *args, **kwargs):
                pass

            @base.on_leave_state('foo')
            def hook1(self, *args, **kwargs):
                self.seen_hook(1)

        class MyFirstSub(WorkflowObject):
            pass

        class MySecondSub(WorkflowObject):
            pass

        o1 = MyFirstSub()
        self.assertEqual(self.MyWorkflow.states.foo, o1.state)
        o1.foobar()
        # check: -
        # before: 1
        # after: 2
        self.assertEqual([1], o1.hooks)

        o2 = MySecondSub()
        self.assertEqual(self.MyWorkflow.states.foo, o2.state)
        o2.foobar()
        # check: -
        # before: 1
        # after: 2
        self.assertEqual([1], o2.hooks)



class ExtendedTransitionImplementationTestCase(unittest.TestCase):
    """Tests extending TransitionImplementation with extra arguments."""

    def setUp(self):
        class MyWorkflow(base.Workflow):
            states = (
                ('foo', "Foo"),
                ('bar', "Bar"),
                ('baz', "Baz"),
            )
            transitions = (
                ('foobar', 'foo', 'bar'),
                ('gobaz', ('foo', 'bar'), 'baz'),
                ('bazbar', 'baz', 'bar'),
            )
            initial_state = 'foo'

        self.MyWorkflow = MyWorkflow

    def test_implementation(self):
        class MyImplementationWrapper(base.ImplementationWrapper):
            """Custom TransitionImplementation, with extra kwarg 'blah'."""

            def _post_transition(self, res, *args, **kwargs):
                super(MyImplementationWrapper, self)._post_transition(res, *args, **kwargs)
                self.instance.blah = kwargs.get('blah', 42)

        class MyWorkflow(self.MyWorkflow):
            implementation_class = MyImplementationWrapper

        class MyWorkflowObject(base.WorkflowEnabled):
            state = MyWorkflow()

            @base.transition()
            def foobar(self, **kwargs):
                return 1

            @base.transition()
            def gobaz(self, blah=10):
                return blah

        obj = MyWorkflowObject()

        # Transition doesn't know 'blah'
        self.assertEqual(1, obj.foobar())
        self.assertEqual(42, obj.blah)

        # Transition knows 'blah'
        self.assertEqual(13, obj.gobaz(blah=13))
        self.assertEqual(13, obj.blah)

        # Transition knows 'blah', but not provided => different defaults.
        obj = MyWorkflowObject()
        self.assertEqual(10, obj.gobaz())
        self.assertEqual(42, obj.blah)


if __name__ == '__main__':  # pragma: no cover
    unittest.main()

########NEW FILE########
__FILENAME__ = test_utils
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.

import warnings

from .compat import is_python3, unittest, u

from xworkflows import utils


class IterClassTestCase(unittest.TestCase):
    def test_simple_class(self):
        class MyClass(object):

            x = 42

            def inst_mth(self):  # pragma: no cover
                pass

            @classmethod
            def cls_mth(cls):  # pragma: no cover
                pass

            @staticmethod
            def st_mth(cls):  # pragma: no cover
                pass

        fields = list(utils.iterclass(MyClass))
        self.assertIn(('x', 42), fields)
        self.assertIn(('inst_mth', MyClass.inst_mth), fields)
        self.assertIn(('cls_mth', MyClass.cls_mth), fields)
        self.assertIn(('st_mth', MyClass.st_mth), fields)

    def test_mixed_attr(self):
        """Tests for fields in dir() but whose getattr() fails."""

        class InstanceOnlyDescriptor(object):
            def __get__(self, instance, owner):
                if instance is None:
                    raise AttributeError("You can't retrieve InstanceOnlyDescriptor.")
                return len(instance.__dict__)

        class MyClass(object):
            x = InstanceOnlyDescriptor()
            y = 13

        # Make sure the 'InstanceOnlyDescriptor' works.
        self.assertRaises(AttributeError, getattr, MyClass, 'x')

        obj = MyClass()
        self.assertEqual(0, obj.x)
        obj.y = 3
        self.assertEqual(1, obj.x)


        # Fetch fields
        fields = dict(utils.iterclass(MyClass))

        # Check for normal fields
        self.assertIn('y', fields)
        self.assertEqual(13, fields['y'])

        # Check that the invalid attribute is ignored.
        self.assertNotIn('x', fields)


if __name__ == '__main__':  # pragma: no cover
    unittest.main()

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.


"""Base components of XWorkflows."""

import functools
import inspect
import logging
import re
import warnings

from .compat import is_callable, is_python3, is_string, u
from . import utils

class WorkflowError(Exception):
    """Base class for errors from the xworkflows module."""


class AbortTransition(WorkflowError):
    """Raised to prevent a transition from proceeding."""


class InvalidTransitionError(AbortTransition):
    """Raised when trying to perform a transition not available from current state."""


class ForbiddenTransition(AbortTransition):
    """Raised when the 'check' hook of a transition was defined and returned False."""


class State(object):
    """A state within a workflow.

    Attributes:
        name (str): the name of the state
        title (str): the human-readable title for the state
    """
    STATE_NAME_RE = re.compile('\w+$')

    def __init__(self, name, title):
        if not self.STATE_NAME_RE.match(name):
            raise ValueError('Invalid state name %s.' % name)
        self.name = name
        self.title = title

    def __str__(self):
        return self.name

    def __repr__(self):
        return '<%s: %r>' % (self.__class__.__name__, self.name)


class StateList(object):
    """A list of states."""
    def __init__(self, states):
        self._states = dict((st.name, st) for st in states)
        self._order = tuple(st.name for st in states)

    def __getattr__(self, name):
        try:
            return self._states[name]
        except KeyError:
            raise AttributeError('StateList %s has no state named %s' % (self, name))

    def __len__(self):
        return len(self._states)

    def __getitem__(self, name_or_state):
        if isinstance(name_or_state, State):
            return self._states[name_or_state.name]
        else:
            return self._states[name_or_state]

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self._states)

    def __iter__(self):
        for name in self._order:
            yield self._states[name]

    def __contains__(self, state):
        if isinstance(state, State):
            return state.name in self._states and self._states[state.name] == state
        else:  # Expect a state name
            return state in self._states


class Transition(object):
    """A transition.

    Attributes:
        name (str): the name of the Transition
        source (State list): the 'source' states of the transition
        target (State): the 'target' state of the transition
    """
    def __init__(self, name, source, target):
        self.name = name
        if isinstance(source, State):
            source = [source]
        self.source = source
        self.target = target

    def __repr__(self):
        return '%s(%r, %r, %r)' % (self.__class__.__name__,
                                   self.name, self.source, self.target)


class TransitionList(object):
    """Holder for the transitions of a given workflow."""

    def __init__(self, transitions):
        """Create a TransitionList.

        Args:
            transitions (list of (name, source, target) tuple): the transitions
                to include.
        """
        self._transitions = {}
        self._order = []
        for trdef in transitions:
            self._transitions[trdef.name] = trdef
            self._order.append(trdef.name)

    def __len__(self):
        return len(self._transitions)

    def __getattr__(self, name):
        try:
            return self._transitions[name]
        except KeyError:
            raise AttributeError('TransitionList %s has no transition named %s.'
                    % (self, name))

    def __getitem__(self, name):
        return self._transitions[name]

    def __iter__(self):
        for name in self._order:
            yield self._transitions[name]

    def __contains__(self, value):
        if isinstance(value, Transition):
            return value.name in self._transitions and self._transitions[value.name] == value
        else:
            return value in self._transitions

    def available_from(self, state):
        """Retrieve all transitions available from a given state.

        Args:
            state (State): the initial state.

        Yields:
            Transition: all transitions starting from that state
        """
        for transition in self:
            if state in transition.source:
                yield transition

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self._transitions.values())


def _setup_states(state_definitions, prev=()):
    """Create a StateList object from a 'states' Workflow attribute."""
    states = list(prev)
    for state_def in state_definitions:
        if len(state_def) != 2:
            raise TypeError("The 'state' attribute of a workflow should be "
                "a two-tuple of strings; got %r instead." % (state_def,))
        name, title = state_def
        state = State(name, title)
        if any(st.name == name for st in states):
            # Replacing an existing state
            states = [state if st.name == name else st for st in states]
        else:
            states.append(state)
    return StateList(states)


def _setup_transitions(tdef, states, prev=()):
    """Create a TransitionList object from a 'transitions' Workflow attribute.

    Args:
        tdef: list of transition definitions
        states (StateList): already parsed state definitions.
        prev (TransitionList): transition definitions from a parent.

    Returns:
        TransitionList: the list of transitions defined in the 'tdef' argument.
    """
    trs = list(prev)
    for transition in tdef:
        if len(transition) == 3:
            (name, source, target) = transition
            if is_string(source) or isinstance(source, State):
                source = [source]
            source = [states[src] for src in source]
            target = states[target]
            tr = Transition(name, source, target)
        else:
            raise TypeError("Elements of the 'transition' attribute of a "
                "workflow should be three-tuples; got %r instead." % (transition,))

        if any(prev_tr.name == tr.name for prev_tr in trs):
            # Replacing an existing state
            trs = [tr if prev_tr.name == tr.name else prev_tr for prev_tr in trs]
        else:
            trs.append(tr)
    return TransitionList(trs)


HOOK_BEFORE = 'before'
HOOK_AFTER = 'after'
HOOK_CHECK = 'check'
HOOK_ON_ENTER = 'on_enter'
HOOK_ON_LEAVE = 'on_leave'


class Hook(object):
    """A hook to run when a transition occurs.

    Attributes:
        kind (str): the kind of hook
        priority (int): the priority of the hook (higher values run first)
        function (callable): the actual function to call
        names (str list): name of the transitions or states to which the hook
            relates. The special value '*' means 'applies to all transitions/
            states'.

    Hooks are sortable by descending priority and ascending function name.

    Hook kinds are as follow:
        - HOOK_BEFORE: run before the related transitions
        - HOOK_AFTER: run after the related transitions
        - HOOK_CHECK: run as part of pre-transition checks (return value matters)
        - HOOK_ON_ENTER: run just after a transition entering a related state
        - HOOK_ON_LEAVE: run just before a transition leaving from a related state
    """

    def __init__(self, kind, function, *names, **kwargs):
        assert kind in (HOOK_BEFORE, HOOK_AFTER, HOOK_CHECK,
            HOOK_ON_ENTER, HOOK_ON_LEAVE)

        self.kind = kind
        self.priority = kwargs.get('priority', 0)
        self.function = function
        self.names = names or ('*',)

    def _match_state(self, state):
        """Checks whether a given State matches self.names."""
        return (self.names == '*'
                or state in self.names
                or state.name in self.names)

    def _match_transition(self, transition):
        """Checks whether a given Transition matches self.names."""
        return (self.names == '*'
                or transition in self.names
                or transition.name in self.names)

    def applies_to(self, transition, from_state=None):
        """Whether this hook applies to the given transition/state.

        Args:
            transition (Transition): the transition to check
            from_state (State or None): the state to check. If absent, the check
                is 'might this hook apply to the related transition, given a
                valid source state'.
        """
        if '*' in self.names:
            return True
        elif self.kind in (HOOK_BEFORE, HOOK_AFTER, HOOK_CHECK):
            return self._match_transition(transition)
        elif self.kind == HOOK_ON_ENTER:
            return self._match_state(transition.target)
        elif from_state is None:
            # Testing whether the hook may apply to at least one source of the
            # transition
            return any(self._match_state(src) for src in transition.source)
        else:
            return self._match_state(from_state)

    def __call__(self, *args, **kwargs):
        return self.function(*args, **kwargs)

    def __eq__(self, other):
        """Equality is based on priority, function and kind."""
        if not isinstance(other, Hook):
            return NotImplemented
        return (self.priority == other.priority
            and self.function == other.function
            and self.kind == other.kind
            and self.names == other.names
        )

    def __ne__(self, other):
        if not isinstance(other, Hook):
            return NotImplemented
        return not (self == other)

    def __lt__(self, other):
        """Compare hooks of the same kind."""
        if not isinstance(other, Hook):
            return NotImplemented
        return (
            (other.priority, self.function.__name__)
            < (self.priority, other.function.__name__))

    def __gt__(self, other):
        """Compare hooks of the same kind."""
        if not isinstance(other, Hook):
            return NotImplemented
        return (
            (other.priority, self.function.__name__)
            > (self.priority, other.function.__name__))

    def __repr__(self):
        return '<%s: %s %r>' % (
            self.__class__.__name__, self.kind, self.function)


class ImplementationWrapper(object):
    """Wraps a transition implementation.

    Emulates a function behaviour, but provides a few extra features.

    Attributes:
        instance (WorkflowEnabled): the instance to update
.
        field_name (str): the name of the field of the instance to update.
        transition (Transition): the transition to perform
        workflow (Workflow): the workflow to which this is related.

        hooks (Hook list): optional hooks to call during the transition
        implementation (callable): the code to invoke between 'before' and the
            state update.
    """

    def __init__(self, instance, field_name, transition, workflow,
            implementation, hooks=None):
        self.instance = instance
        self.field_name = field_name
        self.transition = transition
        self.workflow = workflow

        self.hooks = hooks or {}
        self.implementation = implementation

        self.__doc__ = implementation.__doc__

    @property
    def current_state(self):
        return getattr(self.instance, self.field_name)

    def _pre_transition_checks(self):
        """Run the pre-transition checks."""
        current_state = getattr(self.instance, self.field_name)
        if current_state not in self.transition.source:
            raise InvalidTransitionError(
                "Transition '%s' isn't available from state '%s'." %
                (self.transition.name, current_state.name))

        for check in self._filter_hooks(HOOK_CHECK):
            if not check(self.instance):
                raise ForbiddenTransition(
                    "Transition '%s' was forbidden by "
                    "custom pre-transition check." % self.transition.name)

    def _filter_hooks(self, *hook_kinds):
        """Filter a list of hooks, keeping only applicable ones."""
        hooks = sum((self.hooks.get(kind, []) for kind in hook_kinds), [])
        return sorted(hook for hook in hooks
                      if hook.applies_to(self.transition, self.current_state))

    def _pre_transition(self, *args, **kwargs):
        for hook in self._filter_hooks(HOOK_BEFORE, HOOK_ON_LEAVE):
            hook(self.instance, *args, **kwargs)

    def _during_transition(self, *args, **kwargs):
        return self.implementation(self.instance, *args, **kwargs)

    def _log_transition(self, from_state, *args, **kwargs):
        self.workflow.log_transition(self.transition, from_state, self.instance,
            *args, **kwargs)

    def _post_transition(self, result, *args, **kwargs):
        """Performs post-transition actions."""
        for hook in self._filter_hooks(HOOK_AFTER, HOOK_ON_ENTER):
            hook(self.instance, result, *args, **kwargs)

    def __call__(self, *args, **kwargs):
        """Run the transition, with all checks."""

        self._pre_transition_checks()
        # Call hooks.
        self._pre_transition(*args, **kwargs)

        result = self._during_transition(*args, **kwargs)

        from_state = getattr(self.instance, self.field_name)
        setattr(self.instance, self.field_name, self.transition.target)

        # Call hooks.
        self._log_transition(from_state, *args, **kwargs)
        self._post_transition(result, *args, **kwargs)
        return result

    def is_available(self):
        """Check whether this transition is available on the current object.

        Returns:
            bool
        """
        try:
            self._pre_transition_checks()
        except (InvalidTransitionError, ForbiddenTransition):
            return False
        return True

    def __repr__(self):
        return "<%s for %r on %r: %r>" % (self.__class__.__name__,
            self.transition.name, self.field_name, self.implementation)


class ImplementationProperty(object):
    """Holds an implementation of a transition.

    This class is a 'non-data descriptor', somewhat similar to a property.

    Attributes:
        field_name (str): the name of the field of the instance to update.
        transition (Transition): the transition to perform
        workflow (Workflow): the workflow to which this is related.

        hooks (Hook list): hooks to apply along with the transition.
        implementation (callable): the code to invoke between 'before' and the
            state update.
    """
    def __init__(self, field_name, transition, workflow, implementation,
            hooks=None):
        self.field_name = field_name
        self.transition = transition
        self.workflow = workflow
        self.hooks = hooks or {}
        self.implementation = implementation
        self.__doc__ = implementation.__doc__

    def copy(self):
        return self.__class__(
            field_name=self.field_name,
            transition=self.transition,
            workflow=self.workflow,
            implementation=self.implementation,
            # Don't copy hooks: they'll be re-generated during metaclass __new__
            hooks={},
        )

    def add_hook(self, hook):
        self.hooks.setdefault(hook.kind, []).append(hook)

    def __get__(self, instance, owner):
        if instance is None:
            return self

        if not isinstance(instance, BaseWorkflowEnabled):
            raise TypeError(
                "Unable to apply transition '%s' to object %r, which is not "
                "attached to a Workflow." % (self.transition.name, instance))

        return self.workflow.implementation_class(instance,
            self.field_name, self.transition, self.workflow,
            self.implementation, self.hooks)

    def __repr__(self):
        return "<%s for '%s' on '%s': %s>" % (self.__class__.__name__,
            self.transition.name, self.field_name, self.implementation)


class TransitionWrapper(object):
    """Mark that a method should be used for a transition with a different name.

    Attributes:
        trname (str): the name of the transition that the method implements
        func (function): the decorated method
    """

    def __init__(self, trname, field='', check=None, before=None, after=None):
        self.trname = trname
        self.field = field
        self.check = check
        self.before = before
        self.after = after
        self.func = None

    def __call__(self, func):
        self.func = func
        if self.trname == '':
            self.trname = func.__name__
        return self

    def __repr__(self):
        return "<%s for %r: %s>" % (self.__class__.__name__, self.trname, self.func)


def transition(trname='', field='', check=None, before=None, after=None):
    """Decorator to declare a function as a transition implementation."""
    if is_callable(trname):
        raise ValueError("The @transition decorator should be called as "
            "@transition(['transition_name'], **kwargs)")
    if check or before or after:
        warnings.warn(
            "The use of check=, before= and after= in @transition decorators is "
            "deprecated in favor of @transition_check, @before_transition and "
            "@after_transition decorators.",
            DeprecationWarning,
            stacklevel=2)
    return TransitionWrapper(trname, field=field,
        check=check, before=before, after=after)


def _make_hook_dict(fun):
    """Ensure the given function has a xworkflows_hook attribute.

    That attribute has the following structure:
    >>> {
    ...     'before': [('state', <TransitionHook>), ...],
    ... }
    """
    if not hasattr(fun, 'xworkflows_hook'):
        fun.xworkflows_hook = {
            HOOK_BEFORE: [],
            HOOK_AFTER: [],
            HOOK_CHECK: [],
            HOOK_ON_ENTER: [],
            HOOK_ON_LEAVE: [],
        }
    return fun.xworkflows_hook


class _HookDeclaration(object):
    """Base class for decorators declaring methods as transition hooks.

    Args:
        *names (str tuple): name of the states/transitions to bind to; use '*'
            for 'all'
        priority (int): priority of the hook, defaults to 0
        field (str): name of the field to which the hooked transition relates

    Usage:
        >>> @_HookDeclaration('foo', 'bar', priority=4)
        ... def my_hook(self):
        ...   pass
    """

    def __init__(self, *names, **kwargs):
        if not names:
            names = ('*',)
        self.names = names
        self.priority = kwargs.get('priority', 0)
        self.field = kwargs.get('field', '')

    def _as_hook(self, func):
        return Hook(self.hook_name, func, *self.names, priority=self.priority)

    def __call__(self, func):
        hook_dict = _make_hook_dict(func)
        hooks = hook_dict[self.hook_name]
        hooks.append((self.field, self._as_hook(func)))
        return func


class before_transition(_HookDeclaration):
    """Decorates a method that should be called before a given transition.

    Example:
        >>> @before_transition('foobar')
        ... def blah(self):
        ...   pass
    """
    hook_name = HOOK_BEFORE


class after_transition(_HookDeclaration):
    """Decorates a method that should be called after a given transition.

    Example:
        >>> @after_transition('foobar')
        ... def blah(self):
        ...   pass
    """
    hook_name = HOOK_AFTER


class transition_check(_HookDeclaration):
    """Decorates a method that should be called after a given transition.

    Example:
        >>> @transition_check('foobar')
        ... def blah(self):
        ...   pass
    """
    hook_name = HOOK_CHECK


class on_enter_state(_HookDeclaration):
    """Decorates a method that should be used as a hook for a state.

    Example:
        >>> @on_enter_state('foo', 'bar')
        ... def blah(self):
        ...   pass
    """
    hook_name = HOOK_ON_ENTER


class on_leave_state(_HookDeclaration):
    """Decorates a method that should be used as a hook for a state.

    Example:
        >>> @on_leave_state('foo', 'bar')
        ... def blah(self):
        ...   pass
    """
    hook_name = HOOK_ON_LEAVE


def noop(instance, *args, **kwargs):
    """NoOp function, ignores all arguments."""
    pass


class ImplementationList(object):
    """Stores all implementations.

    Attributes:
        state_field (str): the name of the field holding the state of objects.
        implementations (dict(str => ImplementationProperty)): maps a transition
            name to the associated implementation.
        workflow (Workflow): the related workflow
        transitions_at (dict(str => str)): maps a transition name to the
            name of the attribute holding the related implementation.
        custom_implems (str set): list of transition names for which a custom
            implementation has been defined.
    """

    def __init__(self, state_field, workflow):
        self.state_field = state_field
        self.workflow = workflow
        self.implementations = {}
        self.transitions_at = {}
        self.custom_implems = set()

    def load_parent_implems(self, parent_implems):
        """Import previously defined implementations.

        Args:
            parent_implems (ImplementationList): List of implementations defined
                in a parent class.
        """
        for trname, attr, implem in parent_implems.get_custom_implementations():
            self.implementations[trname] = implem.copy()
            self.transitions_at[trname] = attr
            self.custom_implems.add(trname)

    def add_implem(self, transition, attribute, function, **kwargs):
        """Add an implementation.

        Args:
            transition (Transition): the transition for which the implementation
                is added
            attribute (str): the name of the attribute where the implementation
                will be available
            function (callable): the actual implementation function
            **kwargs: extra arguments for the related ImplementationProperty.
        """
        implem = ImplementationProperty(
            field_name=self.state_field,
            transition=transition,
            workflow=self.workflow,
            implementation=function,
            **kwargs)
        self.implementations[transition.name] = implem
        self.transitions_at[transition.name] = attribute
        return implem

    def should_collect(self, value):
        """Decide whether a given value should be collected."""
        return (
            # decorated with @transition
            isinstance(value, TransitionWrapper)
            # Relates to a compatible transition
            and value.trname in self.workflow.transitions
            # Either not bound to a state field or bound to the current one
            and (not value.field or value.field == self.state_field))

    def collect(self, attrs):
        """Collect the implementations from a given attributes dict."""

        for name, value in attrs.items():
            if self.should_collect(value):
                transition = self.workflow.transitions[value.trname]

                if (value.trname in self.implementations
                    and value.trname in self.custom_implems
                    and name != self.transitions_at[value.trname]):
                    # We already have an implementation registered.
                    other_implem_at = self.transitions_at[value.trname]
                    raise ValueError(
                        "Error for attribute %s: it defines implementation "
                        "%s for transition %s, which is already implemented "
                        "at %s." % (name, value, transition, other_implem_at))

                implem = self.add_implem(transition, name, value.func)
                self.custom_implems.add(transition.name)
                if value.check:
                    implem.add_hook(Hook(HOOK_CHECK, value.check))
                if value.before:
                    implem.add_hook(Hook(HOOK_BEFORE, value.before))
                if value.after:
                    implem.add_hook(Hook(HOOK_AFTER, value.after))

    def get_custom_implementations(self):
        """Retrieve a list of cutom implementations.

        Yields:
            (str, str, ImplementationProperty) tuples: The name of the attribute
                an implementation lives at, the name of the related transition,
                and the related implementation.
        """
        for trname in self.custom_implems:
            attr = self.transitions_at[trname]
            implem = self.implementations[trname]
            yield (trname, attr, implem)

    def add_missing_implementations(self):
        for transition in self.workflow.transitions:
            if transition.name not in self.implementations:
                self.add_implem(transition, transition.name, noop)

    def register_hooks(self, cls):
        for field, value in utils.iterclass(cls):
            if is_callable(value) and hasattr(value, 'xworkflows_hook'):
                self.register_function_hooks(value)

    def register_function_hooks(self, func):
        """Looks at an object method and registers it for relevent transitions."""
        for hook_kind, hooks in func.xworkflows_hook.items():
            for field_name, hook in hooks:
                if field_name and field_name != self.state_field:
                    continue
                for transition in self.workflow.transitions:
                    if hook.applies_to(transition):
                        implem = self.implementations[transition.name]
                        implem.add_hook(hook)

    def _may_override(self, implem, other):
        """Checks whether an ImplementationProperty may override an attribute."""
        if isinstance(other, ImplementationProperty):
            # Overriding another custom implementation for the same transition
            # and field
            return (other.transition == implem.transition
                and other.field_name == self.state_field)

        elif isinstance(other, TransitionWrapper):
            # Overriding the definition that led to adding the current
            # ImplementationProperty.
            return (other.trname == implem.transition.name
                and (not other.field or other.field == self.state_field)
                and other.func == implem.implementation)

        return False

    def fill_attrs(self, attrs):
        """Update the 'attrs' dict with generated ImplementationProperty."""
        for trname, attrname in self.transitions_at.items():

            implem = self.implementations[trname]

            if attrname in attrs:
                conflicting = attrs[attrname]
                if not self._may_override(implem, conflicting):
                    raise ValueError(
                        "Can't override transition implementation %s=%r with %r" %
                        (attrname, conflicting, implem))

            attrs[attrname] = implem
        return attrs

    def transform(self, attrs):
        """Perform all actions on a given attribute dict."""
        self.collect(attrs)
        self.add_missing_implementations()
        self.fill_attrs(attrs)


class WorkflowMeta(type):
    """Base metaclass for all Workflows.

    Sets the 'states', 'transitions', and 'initial_state' attributes.
    """

    def __new__(mcs, name, bases, attrs):

        state_defs = attrs.pop('states', [])
        transitions_defs = attrs.pop('transitions', [])
        initial_state = attrs.pop('initial_state', None)

        new_class = super(WorkflowMeta, mcs).__new__(mcs, name, bases, attrs)

        new_class.states = _setup_states(state_defs,
            getattr(new_class, 'states', []))
        new_class.transitions = _setup_transitions(transitions_defs,
            new_class.states, getattr(new_class, 'transitions', []))
        if initial_state is not None:
            new_class.initial_state = new_class.states[initial_state]

        return new_class


class BaseWorkflow(object):
    """Base class for all workflows.

    Attributes:
        states (StateList): list of states of this Workflow
        transitions (TransitionList): list of Transitions of this Workflow
        initial_state (State): initial state for the Workflow
        implementation_class (ImplementationWrapper subclass): class to use
            for transition implementation wrapping.

    For each transition, a ImplementationWrapper with the same name (unless
    another name has been specified through the use of the @transition
    decorator) is provided to perform the specified transition.
    """
    implementation_class = ImplementationWrapper

    def log_transition(self, transition, from_state, instance, *args, **kwargs):
        """Log a transition.

        Args:
            transition (Transition): the name of the performed transition
            from_state (State): the source state
            instance (object): the modified object

        Kwargs:
            Any passed when calling the transition
        """
        logger = logging.getLogger('xworkflows.transitions')
        try:
            instance_repr = u(repr(instance), 'ignore')
        except (UnicodeEncodeError, UnicodeDecodeError):
            instance_repr = u("<bad repr>")
        logger.info(u("%s performed transition %s.%s (%s -> %s)"), instance_repr,
            self.__class__.__name__, transition.name, from_state.name,
            transition.target.name)


# Workaround for metaclasses on python2/3.
# Equivalent to:
# Python2
#
# class Workflow(BaseWorkflow):
#     __metaclass__ = WorkflowMeta
#
# Python3
#
# class Workflow(metaclass=WorkflowMeta):
#     pass

Workflow = WorkflowMeta('Workflow', (BaseWorkflow,), {})


class StateWrapper(object):
    """Slightly enhanced wrapper around a base State object.

    Knows about the workflow.
    """
    def __init__(self, state, workflow):
        self.state = state
        self.workflow = workflow
        for st in workflow.states:
            setattr(self, 'is_%s' % st.name, st.name == self.state.name)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.state == other.state
        elif isinstance(other, State):
            return self.state == other
        elif is_string(other):
            return self.state.name == other
        else:
            return NotImplemented

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return self.state.name

    def __repr__(self):
        return '<%s: %r>' % (self.__class__.__name__, self.state)

    def __getattr__(self, attr):
        if attr == 'state':
            raise AttributeError(
                'Trying to access attribute %s of a non-initialized %r object!'
                % (attr, self.__class__))
        else:
            return getattr(self.state, attr)

    if not is_python3:
        def __unicode__(self):
            return u(str(self))

    def __hash__(self):
        # A StateWrapper should compare equal to its name.
        return hash(self.state.name)

    def transitions(self):
        """Retrieve a list of transitions available from this state."""
        return self.workflow.transitions.available_from(self.state)


class StateProperty(object):
    """Property-like attribute holding the state of a WorkflowEnabled object.

    The state is stored in the internal __dict__ of the instance.
    """

    def __init__(self, workflow, state_field_name):
        super(StateProperty, self).__init__()
        self.workflow = workflow
        self.field_name = state_field_name

    def __get__(self, instance, owner):
        """Retrieve the current state of the 'instance' object."""
        if instance is None:
            return self
        state = instance.__dict__.get(self.field_name,
                                      self.workflow.initial_state)
        return StateWrapper(state, self.workflow)

    def __set__(self, instance, value):
        """Set the current state of the 'instance' object."""
        try:
            state = self.workflow.states[value]
        except KeyError:
            raise ValueError("Value %s is not a valid state for workflow %s." %
                    (value, self.workflow))
        instance.__dict__[self.field_name] = state

    def __str__(self):
        return 'StateProperty(%s, %s)' % (self.workflow, self.field_name)


class StateField(object):
    """Indicates that a given class attribute is actually a workflow state."""
    def __init__(self, workflow):
        self.workflow = workflow


class WorkflowEnabledMeta(type):
    """Base metaclass for all Workflow Enabled objects.

    Defines:
    - one class attribute for each the attached workflows,
    - a '_workflows' attribute, a dict mapping each field_name to the related
        Workflow,
    - a '_xworkflows_implems' attribute, a dict mapping each field_name to a
        dict of related ImplementationProperty.
    - one class attribute for each transition for each attached workflow
    """

    @classmethod
    def _add_workflow(mcs, field_name, state_field, attrs):
        """Attach a workflow to the attribute list (create a StateProperty)."""
        attrs[field_name] = StateProperty(state_field.workflow, field_name)

    @classmethod
    def _find_workflows(mcs, attrs):
        """Finds all occurrences of a workflow in the attributes definitions.

        Returns:
            dict(str => StateField): maps an attribute name to a StateField
                describing the related Workflow.
        """
        workflows = {}
        for attribute, value in attrs.items():
            if isinstance(value, Workflow):
                workflows[attribute] = StateField(value)
        return workflows

    @classmethod
    def _add_transitions(mcs, field_name, workflow, attrs, implems=None):
        """Collect and enhance transition definitions to a workflow.

        Modifies the 'attrs' dict in-place.

        Args:
            field_name (str): name of the field transitions should update
            workflow (Workflow): workflow we're working on
            attrs (dict): dictionary of attributes to be updated.
            implems (ImplementationList): Implementation list from parent
                classes (optional)

        Returns:
            ImplementationList: The new implementation list for this field.
        """
        new_implems = ImplementationList(field_name, workflow)
        if implems:
            new_implems.load_parent_implems(implems)
        new_implems.transform(attrs)

        return new_implems

    @classmethod
    def _register_hooks(mcs, cls, implems):
        for implem_list in implems.values():
            implem_list.register_hooks(cls)

    def __new__(mcs, name, bases, attrs):
        # Map field_name => StateField
        workflows = {}
        # Map field_name => ImplementationList
        implems = {}

        # Collect workflows and implementations from parents
        for base in reversed(bases):
            if hasattr(base, '_workflows'):
                workflows.update(base._workflows)
                implems.update(base._xworkflows_implems)

        workflows.update(mcs._find_workflows(attrs))

        # Update attributes with workflow descriptions, and collect
        # implementation declarations.
        for field, state_field in workflows.items():
            mcs._add_workflow(field, state_field, attrs)

            implems[field] = mcs._add_transitions(
                field, state_field.workflow, attrs, implems.get(field))

        # Set specific attributes for children
        attrs['_workflows'] = workflows
        attrs['_xworkflows_implems'] = implems

        cls = super(WorkflowEnabledMeta, mcs).__new__(mcs, name, bases, attrs)
        mcs._register_hooks(cls, implems)
        return cls


class BaseWorkflowEnabled(object):
    """Base class for all objects using a workflow.

    Attributes:
        workflows (dict(str, StateField)): Maps the name of a 'state_field' to
            the related Workflow
    """


# Workaround for metaclasses on python2/3.
# Equivalent to:
# Python2
#
# class WorkflowEnabled(BaseWorkflowEnabled):
#     __metaclass__ = WorkflowEnabledMeta
#
# Python3
#
# class WorkflowEnabled(metaclass=WorkflowEnabledMeta):
#     pass

WorkflowEnabled = WorkflowEnabledMeta('WorkflowEnabled', (BaseWorkflowEnabled,), {})

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.

import collections
import sys

is_python3 = (sys.version_info[0] >= 3)

if is_python3:
    def u(text, errors=''):
        return str(text)

    def is_string(var):
        return isinstance(var, str)
else:

    def u(text, errors=''):
        return unicode(text, 'utf8', errors)

    def is_string(var):
        return isinstance(var, basestring)


def is_callable(var):
    return isinstance(var, collections.Callable)

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
# Copyright (c) 2011-2013 Raphaël Barrois
# This code is distributed under the two-clause BSD License.


"""Base components of XWorkflows."""


def iterclass(cls):
    """Iterates over (valid) attributes of a class.

    Args:
        cls (object): the class to iterate over

    Yields:
        (str, obj) tuples: the class-level attributes.
    """
    for field in dir(cls):
        if hasattr(cls, field):
            value = getattr(cls, field)
            yield field, value

########NEW FILE########
