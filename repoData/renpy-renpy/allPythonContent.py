__FILENAME__ = add
#!/usr/bin/env python

import argparse
import os
import subprocess
import sys

from renpy import version_tuple #@UnresolvedImport

version = ".".join(str(i) for i in version_tuple)
short_version = ".".join(str(i) for i in version_tuple[:3])
print "Version", version

ap = argparse.ArgumentParser()

ap.add_argument("--release", action="store_true")
ap.add_argument("--prerelease", action="store_true")
ap.add_argument("--experimental", action="store_true")
ap.add_argument("--no-tag", "-n", action="store_true")

args = ap.parse_args()

if args.release:
    links = [ "release", "prerelease", "experimental" ]
    tag = True
elif args.prerelease:
    links = [ "prerelease", "experimental" ]
    tag = True
elif args.experimental:
    links = [ "experimental" ]
    tag = False
else:
    links = [ ]
    tag = False


def check_dirty():
    if args.no_tag:
        return

    if subprocess.check_call([ "git", "diff", "--quiet", "HEAD" ]):
        print "Directory not checked in: {}".format(os.getcwd())
        sys.exit(1)

os.chdir("/home/tom/ab/renpy")
check_dirty()

os.chdir("/home/tom/ab/renpy/android")
check_dirty()

if not args.no_tag:
    subprocess.check_call([ "git", "tag", "-a", "rapt-" + version, "-m", "Tagging RAPT release." ])

os.chdir("/home/tom/ab/renpy/dl")

for i in links:
    if os.path.exists(i):
        os.unlink(i)
    os.symlink(short_version, i)

os.chdir("/home/tom/ab/renpy")

if tag and not args.no_tag:
    cmd = [ "git", "tag", "-a", version, "-m", "Ren'Py " + version ]
    subprocess.check_call(cmd)

os.chdir("/home/tom/ab/website")
subprocess.check_call("./upload.sh")

########NEW FILE########
__FILENAME__ = distribute
#!/home/tom/bin/renpython -O

# Builds a distribution of Ren'Py.

import sys
import os
import compileall
import shutil
import subprocess
import argparse
import glob

ROOT = os.path.dirname(os.path.abspath(__file__))

def copy_tutorial_file(src, dest):
    """
    Copies a file from src to dst. Lines between  "# tutorial-only" and
    "# end-tutorial-only" comments are omitted from the copy.
    """

    sf = open(src, "rb")
    df = open(dest, "wb")

    # True if we want to copy the line.
    copy = True

    for l in sf:
        if "# tutorial-only" in l:
            copy = False
        elif "# end-tutorial-only" in l:
            copy = True
        else:
            if copy:
                df.write(l)

    sf.close()
    df.close()


def main():

    if not sys.flags.optimize:
        raise Exception("Not running with python optimization.")

    ap = argparse.ArgumentParser()
    ap.add_argument("version")
    ap.add_argument("--fast", action="store_true")

    args = ap.parse_args()

    # Revision updating is done early, so we can do it even if the rest
    # of the program fails.

    # Determine the version. We grab the current revision, and if any
    # file has changed, bump it by 1.
    import renpy

    match_version = ".".join(str(i) for i in renpy.version_tuple[:2]) #@UndefinedVariable
    zip_version = ".".join(str(i) for i in renpy.version_tuple[:3]) #@UndefinedVariable

    s = subprocess.check_output([ "git", "describe", "--tags", "--dirty", "--match", match_version ])
    parts = s.strip().split("-")

    if len(parts) <= 2:
        vc_version = 0
    else:
        vc_version = int(parts[1])

    if parts[-1] == "dirty":
        vc_version += 1

    with open("renpy/vc_version.py", "w") as f:
        f.write("vc_version = {}".format(vc_version))

    try:
        reload(sys.modules['renpy.vc_version']) #@UndefinedVariable
    except:
        import renpy.vc_version # @UnusedImport

    reload(sys.modules['renpy'])

    # Check that the versions match.
    full_version = ".".join(str(i) for i in renpy.version_tuple) #@UndefinedVariable
    if args.version != "renpy-experimental" \
        and not args.version.startswith("renpy-nightly-") \
        and not full_version.startswith(args.version):

        raise Exception("The command-line and Ren'Py versions do not match.")

    # The destination directory.
    destination = os.path.join("dl", args.version)

    print "Version {} ({})".format(args.version, full_version)

    # Copy over the screens, to keep them up to date.
    copy_tutorial_file("tutorial/game/screens.rpy", "templates/english/game/screens.rpy")

    # Compile all the python files.
    compileall.compile_dir("renpy/", ddir="renpy/", force=1, quiet=1)

    # Generate launcher/game/script_version.rpy
    with open("launcher/game/script_version.rpy", "w") as f:
        f.write("init -999 python:\n")
        f.write("    config.script_version = {!r}\n".format(renpy.version_tuple[:3]))  # @UndefinedVariable

    # Compile the various games.
    if not args.fast:
        for i in [ 'tutorial', 'launcher', 'the_question' ] + glob.glob("templates/*"):
            print "Compiling", i
            subprocess.check_call(["./renpy.sh", i, "quit" ])


    # Kick off the rapt build.
    if not args.fast:
        out = open("/tmp/rapt_build.txt", "wb")

        print("Building RAPT.")

        android = os.path.abspath("android")

        rapt_build = subprocess.Popen([
            os.path.join(android, "build_renpy.sh"),
            "renpy",
            ROOT,
            ],
            cwd = android,
            stdout=out,
            stderr=out)

        code = rapt_build.wait()

        if code:
            print "RAPT build failed. The output is in /tmp/rapt_build.txt."
            sys.exit(1)
        else:
            print "RAPT build succeeded."

    if not os.path.exists(destination):
        os.makedirs(destination)

    if args.fast:

        cmd = [
            "./renpy.sh",
            "launcher",
            "distribute",
            "launcher",
            "--package",
            "sdk",
            "--destination",
            destination,
            "--no-update",
            ]

    else:
        cmd = [
            "./renpy.sh",
            "launcher",
            "distribute",
            "launcher",
            "--destination",
            destination,
            ]

    print
    subprocess.check_call(cmd)

    # Sign the update.
    if not args.fast:
        subprocess.check_call([
            "scripts/sign_update.py",
            "/home/tom/ab/keys/renpy_private.pem",
            os.path.join(destination, "updates.json"),
            ])


    # Write 7z.exe.
    sdk = "renpy-{}-sdk".format(zip_version)

    if args.version.startswith("renpy-nightly-"):
        sdk = args.version + "-sdk"

    if not args.fast:

        # shutil.copy("renpy-ppc.zip", os.path.join(destination, "renpy-ppc.zip"))

        with open("7z.sfx", "rb") as f:
            sfx = f.read()

        os.chdir(destination)

        if os.path.exists(sdk):
            shutil.rmtree(sdk)

        subprocess.check_call([ "unzip", "-q", sdk + ".zip" ])

        if os.path.exists(sdk + ".7z"):
            os.unlink(sdk + ".7z")

        sys.stdout.write("Creating -sdk.7z")

        p = subprocess.Popen([ "7z", "a", sdk +".7z", sdk], stdout=subprocess.PIPE)
        for i, _l in enumerate(p.stdout):
            if i % 10 != 0:
                continue

            sys.stdout.write(".")
            sys.stdout.flush()

        if p.wait() != 0:
            raise Exception("7z failed")

        with open(sdk + ".7z", "rb") as f:
            data = f.read()

        with open(sdk + ".7z.exe", "wb") as f:
            f.write(sfx)
            f.write(data)

        os.unlink(sdk + ".7z")
        shutil.rmtree(sdk)

    else:
        os.chdir(destination)

        if os.path.exists(sdk + ".7z.exe"):
            os.unlink(sdk + ".7z.exe")

    print

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = change_icon
ï»¿# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


# http://www.csn.ul.ie/~caolan/publink/winresdump/winresdump/doc/pefile.html
# Contains a reasonable description of the format.

import struct
import sys
import array
import pefile # @UnresolvedImport

# This class performs various operations on memory-loaded binary files,
# including modifications.
class BinFile(object):

    def set_u32(self, addr, value):
        self.a[addr+0] = (value >> 0) & 0xff
        self.a[addr+1] = (value >> 8) & 0xff
        self.a[addr+2] = (value >> 16) & 0xff
        self.a[addr+3] = (value >> 24) & 0xff

    def u32(self):
        addr = self.addr
        rv = self.a[addr]
        rv |= self.a[addr+1] << 8
        rv |= self.a[addr+2] << 16
        rv |= self.a[addr+3] << 24
        self.addr += 4
        return rv

    def u16(self):
        addr = self.addr
        rv = self.a[addr]
        rv |= self.a[addr+1] << 8
        self.addr += 2
        return rv

    def u8(self):
        rv = self.a[self.addr]
        self.addr += 1
        return rv

    def name(self):
        c = self.u16()

        rv = u""
        for _i in range(c):
            rv += unichr(self.u16())

        return rv

    def seek(self, addr):
        self.addr = addr

    def tostring(self):
        return self.a.tostring()

    def substring(self, start, len): #@ReservedAssignment
        return self.a[start:start+len].tostring()

    def __init__(self, data):
        self.a = array.array('B')
        self.a.fromstring(data)

##############################################################################
# These functions parse data out of the file. In these functions, offset is
# relative to the start of the file.

# The virtual address of the resource segment.
resource_virtual = 0

# This parses a data block out of the resources.
def parse_data(bf, offset):
    bf.seek(offset)
    data_offset = bf.u32()
    data_len = bf.u32()
    code_page = bf.u32()
    bf.u32()

    l = [ ]

    bf.seek(data_offset - resource_virtual)
    for _i in range(data_len):
        l.append(chr(bf.u8()))

    return (code_page, "".join(l))

# This parses a resource directory.
def parse_directory(bf, offset):

    bf.seek(offset)
    char = bf.u32() #@UnusedVariable
    timedate = bf.u32() #@UnusedVariable
    major = bf.u16() #@UnusedVariable
    minor = bf.u16() #@UnusedVariable
    n_named = bf.u16()
    n_id = bf.u16()

    entries = [ ]

    for _i in range(n_named + n_id):
        entries.append((bf.u32(), bf.u32()))

    rv = { }

    for name, value in entries:

        if name & 0x80000000:
            bf.seek((name & 0x7fffffff))
            name = bf.name()

        if value & 0x80000000:
            value = parse_directory(bf, value & 0x7fffffff)
        else:
            value = parse_data(bf, value)

        rv[name] = value

    return rv


##############################################################################
# This utility function displays the tree of resources that have been loaded.
def show_resources(d, prefix):

    if not isinstance(d, dict):
        print prefix, "Codepage", d[0], "length", len(d[1])
        return

    for k in d:
        print prefix, k
        show_resources(d[k], prefix + "  ")

##############################################################################
# These functions repack the resources into a new resource segment. Here,
# the offset is relative to the start of the resource segment.

class Packer(object):

    def pack(self, d):
        self.data = ""
        self.data_offset = 0

        self.entries = ""
        self.entries_offset = 0

        head = self.pack_dict(d, 0)

        self.data = ""
        self.data_offset = len(head) + len(self.entries)

        self.entries = ""
        self.entries_offset = len(head)

        return self.pack_dict(d, 0) + self.entries + self.data

    def pack_name(self, s):
        rv = self.data_offset + len(self.data)

        l = len(s)
        s = s.encode("utf-16le")
        self.data += struct.pack("<H", l) + s + "\0\0"

        return rv

    def pack_tuple(self, t):
        codepage, data = t

        rv = len(self.entries) + self.entries_offset

        if len(self.data) % 2:
            self.data += "P"

        daddr = len(self.data) + self.data_offset

        self.entries += struct.pack("<IIII", daddr + resource_virtual, len(data), codepage, 0)
        self.data += data

        # if len(self.data) % 1 == 1:
        #    self.data += 'P'

        return rv

    def pack_dict(self, d, offset):
        name_entries = sorted((a, b) for a, b in d.iteritems() if isinstance(a, unicode))
        id_entries = sorted((a, b) for a, b in d.iteritems() if isinstance(a, int))

        rv = struct.pack("<IIHHHH", 0, 0, 4, 0, len(name_entries), len(id_entries))

        offset += len(rv) + (len(name_entries) + len(id_entries)) * 8

        rest = ""

        for (name, value) in name_entries + id_entries:
            if isinstance(name, unicode):
                name = 0x80000000 | self.pack_name(name)

            if isinstance(value, dict):
                addr = offset | 0x80000000
                packed = self.pack_dict(value, offset)
                offset += len(packed)
                rest += packed
            else:
                addr = self.pack_tuple(value)

            rv += struct.pack("<II", name, addr)

        return rv + rest

##############################################################################
# This loads in an icon file, and returns a dictionary that is suitable for
# use in the resources of an exe file.
def load_icon(fn):
    f = BinFile(file(fn, "rb").read())

    f.seek(0)
    f.u16()
    f.u16()
    count = f.u16()

    rv = { }
    rv[3] = { }

    group = struct.pack("HHH", 0, 1, count)

    for i in range(count):
        width = f.u8()
        height = f.u8()
        colors = f.u8()
        reserved = f.u8()
        planes = f.u16()
        bpp = f.u16()
        size = f.u32()
        offset = f.u32()

        addr = f.addr
        f.seek(offset + 16)
        if not f.u32():
            f.set_u32(offset + 20, 0)

        rv[3][i + 1] = { 0 : (1252, f.substring(offset, size)) }


        group += struct.pack("BBBBHHIH", width, height, colors, reserved,
                             planes, bpp, size, i + 1)

        f.seek(addr)

    rv[14] = { 1 : { 0 : (1252, group) } }

    return rv


##############################################################################
# This is the main function that should be called externally, that copies over
# the icons.
def change_icons(oldexe, icofn):
    global resource_virtual

    pe = pefile.PE(oldexe)

    for s in pe.sections:
        if s.Name == ".rsrc\0\0\0":
            rsrc_section = s
            break
    else:
        raise Exception("Couldn't find resource section.")

    base = rsrc_section.PointerToRawData
    resource_virtual = rsrc_section.VirtualAddress

    physize = rsrc_section.SizeOfRawData
    virsize = rsrc_section.Misc_VirtualSize

    f = file(oldexe, "rb")
    f.seek(base)
    data = f.read(physize)
    f.close()

    bf = BinFile(data)

    resources = parse_directory(bf, 0)
    # show_resources(resources, "")
    resources.update(load_icon(icofn))
    # show_resources(resources, "")

    rsrc = Packer().pack(resources)

    alignment = pe.OPTIONAL_HEADER.SectionAlignment

    # print "Alignment is", alignment

    if len(rsrc) % alignment:
        pad = alignment - (len(rsrc) % alignment)
        padding = "RENPYVNE" * (pad / 8 + 1)
        padding = padding[:pad]
        rsrc += padding

    newsize = len(rsrc)

    rsrc_section.Misc_VirtualSize += newsize - virsize
    rsrc_section.Misc_PhysicalAddress += newsize - virsize
    rsrc_section.Misc += newsize - virsize
    rsrc_section.SizeOfRawData += newsize - physize

    pe.OPTIONAL_HEADER.SizeOfInitializedData += newsize - physize

    # Resource size.
    pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size += newsize - virsize

    # Compute the total size of the image.
    total_size = 0

    for i in pe.sections:

        sec_size = i.Misc_VirtualSize
        sec_size = sec_size - (sec_size % alignment) + alignment

        total_size += sec_size

    pe.OPTIONAL_HEADER.SizeOfImage = total_size

    return pe.write()[:base] + rsrc

if __name__ == "__main__":

    f = file(sys.argv[3], "wb")
    f.write(change_icons(sys.argv[1], sys.argv[2]))
    f.close()


########NEW FILE########
__FILENAME__ = EasyDialogsResources
import binascii


def a2b(a):
    return binascii.a2b_hex(''.join(a.split()))


resources = {
             260 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 c8 00 c0 80
                          02 00 00 00 00 00 b8 00  29 00 00 00 00 00 00 00
                          08 00 90 01 00 01 4d 00  53 00 20 00 53 00 68 00
                          65 00 6c 00 6c 00 20 00  44 00 6c 00 67 00 00 00
                          00 00 00 00 00 00 00 00  01 00 01 50 7f 00 14 00
                          32 00 0e 00 01 00 00 00  ff ff 80 00 4f 00 4b 00
                          00 00 00 00 00 00 00 00  00 00 00 00 04 08 00 50
                          07 00 07 00 aa 00 0c 00  ea 03 00 00 ff ff 81 00
                          00 00 00 00             
                       '''),
             261 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 c8 00 c0 80
                          04 00 00 00 00 00 b8 00  3a 00 00 00 00 00 00 00
                          08 00 90 01 00 01 4d 00  53 00 20 00 53 00 68 00
                          65 00 6c 00 6c 00 20 00  44 00 6c 00 67 00 00 00
                          00 00 00 00 00 00 00 00  80 00 81 50 07 00 14 00
                          aa 00 0c 00 ec 03 00 00  ff ff 81 00 00 00 00 00
                          00 00 00 00 00 00 00 00  01 00 01 50 7f 00 25 00
                          32 00 0e 00 01 00 00 00  ff ff 80 00 4f 00 4b 00
                          00 00 00 00 00 00 00 00  00 00 00 00 00 00 01 50
                          4a 00 25 00 32 00 0e 00  02 00 00 00 ff ff 80 00
                          43 00 61 00 6e 00 63 00  65 00 6c 00 00 00 00 00
                          00 00 00 00 00 00 00 00  04 08 00 50 07 00 07 00
                          aa 00 0c 00 eb 03 00 00  ff ff 81 00 00 00 00 00
                       '''),
             262 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 c8 00 c0 80
                          04 00 00 00 00 00 b8 00  29 00 00 00 00 00 00 00
                          08 00 90 01 00 01 4d 00  53 00 20 00 53 00 68 00
                          65 00 6c 00 6c 00 20 00  44 00 6c 00 67 00 00 00
                          00 00 00 00 00 00 00 00  00 00 01 50 7f 00 14 00
                          32 00 0e 00 06 00 00 00  ff ff 80 00 59 00 65 00
                          73 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
                          04 08 00 50 07 00 07 00  aa 00 0c 00 ed 03 00 00
                          ff ff 81 00 00 00 00 00  00 00 00 00 00 00 00 00
                          00 00 01 50 07 00 14 00  32 00 0e 00 07 00 00 00
                          ff ff 80 00 4e 00 6f 00  00 00 00 00 00 00 00 00
                          00 00 00 00 00 00 01 50  4b 00 14 00 32 00 0e 00
                          02 00 00 00 ff ff 80 00  43 00 61 00 6e 00 63 00
                          65 00 6c 00 00 00 00 00         
                       '''),
             263 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 80 00 ca 80
                          03 00 00 00 00 00 e2 00  29 00 00 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 81 50 07 00 14 00
                          97 00 0e 00 eb 03 00 00  6d 00 73 00 63 00 74 00
                          6c 00 73 00 5f 00 70 00  72 00 6f 00 67 00 72 00
                          65 00 73 00 73 00 33 00  32 00 00 00 00 00 00 00
                          00 00 00 00 00 00 00 00  04 08 00 50 07 00 07 00
                          d4 00 0c 00 ea 03 00 00  ff ff 81 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 00 50 a9 00 14 00
                          32 00 0e 00 02 00 00 00  ff ff 80 00 43 00 61 00
                          6e 00 63 00 65 00 6c 00  00 00 00 00    
                       '''),
             264 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 c8 00 c0 80
                          04 00 00 00 00 00 b8 00  3a 00 00 00 00 00 00 00
                          08 00 90 01 00 01 4d 00  53 00 20 00 53 00 68 00
                          65 00 6c 00 6c 00 20 00  44 00 6c 00 67 00 00 00
                          00 00 00 00 00 00 00 00  a0 00 81 50 07 00 14 00
                          aa 00 0c 00 ec 03 00 00  ff ff 81 00 00 00 00 00
                          00 00 00 00 00 00 00 00  01 00 01 50 7f 00 25 00
                          32 00 0e 00 01 00 00 00  ff ff 80 00 4f 00 4b 00
                          00 00 00 00 00 00 00 00  00 00 00 00 00 00 01 50
                          4a 00 25 00 32 00 0e 00  02 00 00 00 ff ff 80 00
                          43 00 61 00 6e 00 63 00  65 00 6c 00 00 00 00 00
                          00 00 00 00 00 00 00 00  04 08 00 50 07 00 07 00
                          aa 00 0c 00 eb 03 00 00  ff ff 81 00 00 00 00 00
                       '''),
             265 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 c8 00 c8 80
                          12 00 00 00 00 00 d9 00  fc 00 00 00 00 00 00 00
                          08 00 90 01 00 01 4d 00  53 00 20 00 53 00 68 00
                          65 00 6c 00 6c 00 20 00  44 00 6c 00 67 00 00 00
                          00 00 00 00 00 00 00 00  01 00 01 50 6c 00 ea 00
                          30 00 0e 00 01 00 00 00  ff ff 80 00 4f 00 4b 00
                          00 00 00 00 00 00 00 00  00 00 00 00 00 00 01 50
                          a2 00 ea 00 30 00 0e 00  02 00 00 00 ff ff 80 00
                          43 00 61 00 6e 00 63 00  65 00 6c 00 00 00 00 00
                          00 00 00 00 00 00 00 00  07 00 00 50 06 00 06 00
                          cc 00 4e 00 ff ff ff ff  ff ff 80 00 00 00 00 00
                          00 00 00 00 00 00 00 00  03 00 21 50 48 00 12 00
                          84 00 64 00 03 00 00 00  ff ff 85 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 02 50 0c 00 24 00
                          c0 00 08 00 04 00 00 00  ff ff 82 00 00 00 00 00
                          00 00 00 00 00 00 00 00  80 00 81 50 0c 00 30 00
                          c0 00 0e 00 05 00 00 00  ff ff 81 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 01 50 9c 00 42 00
                          30 00 0e 00 06 00 00 00  ff ff 80 00 41 00 64 00
                          64 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
                          07 00 00 50 06 00 54 00  cb 00 3c 00 ff ff ff ff
                          ff ff 80 00 00 00 00 00  00 00 00 00 00 00 00 00
                          03 00 21 50 48 00 61 00  84 00 64 00 07 00 00 00
                          ff ff 85 00 00 00 00 00  00 00 00 00 00 00 00 00
                          00 00 02 50 0c 00 72 00  c0 00 08 00 08 00 00 00
                          ff ff 82 00 00 00 00 00  00 00 00 00 00 00 00 00
                          00 00 01 50 9c 00 7e 00  30 00 0e 00 09 00 00 00
                          ff ff 80 00 41 00 64 00  64 00 00 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 01 50 06 00 96 00
                          42 00 0e 00 0a 00 00 00  ff ff 80 00 41 00 64 00
                          64 00 20 00 66 00 69 00  6c 00 65 00 2e 00 2e 00
                          2e 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
                          00 00 01 50 4e 00 96 00  42 00 0e 00 0b 00 00 00
                          ff ff 80 00 41 00 64 00  64 00 20 00 6e 00 65 00
                          77 00 20 00 66 00 69 00  6c 00 65 00 2e 00 2e 00
                          2e 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
                          00 00 01 50 06 00 a8 00  42 00 0e 00 0c 00 00 00
                          ff ff 80 00 41 00 64 00  64 00 20 00 66 00 6f 00
                          6c 00 64 00 65 00 72 00  2e 00 2e 00 2e 00 00 00
                          00 00 00 00 00 00 00 00  00 00 00 00 07 00 00 50
                          06 00 c6 00 cc 00 1e 00  ff ff ff ff ff ff 80 00
                          43 00 6f 00 6d 00 6d 00  61 00 6e 00 64 00 20 00
                          6c 00 69 00 6e 00 65 00  3a 00 00 00 00 00 00 00
                          00 00 00 00 00 00 00 00  80 00 81 50 0c 00 d2 00
                          c0 00 0e 00 0e 00 00 00  ff ff 81 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 02 50 0c 00 14 00
                          3c 00 08 00 1e 00 00 00  ff ff 82 00 4f 00 70 00
                          74 00 69 00 6f 00 6e 00  3a 00 00 00 00 00 00 00
                          00 00 00 00 00 00 00 00  00 00 02 50 0c 00 63 00
                          3c 00 08 00 46 00 00 00  ff ff 82 00 43 00 6f 00
                          6d 00 6d 00 61 00 6e 00  64 00 3a 00 00 00 00 00
                       '''),
             270 : a2b('''
                          01 00 ff ff 00 00 00 00  00 00 00 00 48 04 00 44
                          02 00 00 00 00 00 23 01  1a 00 00 00 00 00 00 00
                          08 00 00 00 00 00 4d 00  53 00 20 00 53 00 68 00
                          65 00 6c 00 6c 00 20 00  44 00 6c 00 67 00 00 00
                          00 00 00 00 00 00 00 00  01 00 02 50 00 00 07 00
                          23 01 08 00 ff ff ff ff  ff ff 82 00 53 00 74 00
                          61 00 74 00 69 00 63 00  00 00 00 00 00 00 00 00
                          00 00 00 00 00 00 02 40  00 00 12 00 23 01 08 00
                          5f 04 00 00 ff ff 82 00  73 00 74 00 63 00 33 00
                          32 00 00 00 00 00           
                       '''),
            }

########NEW FILE########
__FILENAME__ = EasyDialogsWin
#@PydevCodeAnalysisIgnore
"""Easy to use dialogs.

Message(msg) -- display a message and an OK button.
AskString(prompt, default) -- ask for a string, display OK and Cancel buttons.
AskPassword(prompt, default) -- like AskString(), but shows text as bullets.
AskYesNoCancel(question, default) -- display a question and Yes, No and Cancel buttons.
GetArgv(optionlist, commandlist) -- fill a sys.argv-like list using a dialog
AskFileForOpen(...) -- Ask the user for an existing file
AskFileForSave(...) -- Ask the user for an output file
AskFolder(...) -- Ask the user to select a folder
bar = Progress(label, maxvalue) -- Display a progress bar
bar.set(value) -- Set value
bar.inc( *amount ) -- increment value by amount (default=1)
bar.label( *newlabel ) -- get or set text label.

More documentation in each function.
This module uses DLOG resources 260 and on.
Based upon STDWIN dialogs with the same names and functions.
"""

from __future__ import division

import os

import ctypes
import ctypes.wintypes as wintypes

from EasyDialogsResources import resources


__all__ = ['Message', 'AskString', 'AskPassword', 'AskYesNoCancel',
    'GetArgv', 'AskFileForOpen', 'AskFileForSave', 'AskFolder',
    'ProgressBar']


# Load required Windows DLLs
comdlg32 = ctypes.windll.comdlg32
kernel32 = ctypes.windll.kernel32
ole32 = ctypes.windll.ole32
shell32 = ctypes.windll.shell32
user32 = ctypes.windll.user32


# Windows Constants
BFFM_INITIALIZED = 1
BFFM_SETOKTEXT = 1129
BFFM_SETSELECTIONA = 1126
BIF_EDITBOX = 16
BS_DEFPUSHBUTTON = 1
CB_ADDSTRING = 323
CB_GETCURSEL = 327
CB_SETCURSEL = 334
CDM_SETCONTROLTEXT = 1128
EM_GETLINECOUNT = 186
EM_GETMARGINS = 212
EM_POSFROMCHAR = 214
EM_SETSEL = 177
GWL_STYLE = -16
IDC_STATIC = -1
IDCANCEL = 2
IDNO = 7
IDOK = 1
IDYES = 6
MAX_PATH = 260
OFN_ALLOWMULTISELECT = 512
OFN_ENABLEHOOK = 32
OFN_ENABLESIZING = 8388608
OFN_ENABLETEMPLATEHANDLE = 128
OFN_EXPLORER = 524288
OFN_OVERWRITEPROMPT = 2
OPENFILENAME_SIZE_VERSION_400 = 76
PBM_GETPOS = 1032
PBM_SETMARQUEE = 1034
PBM_SETPOS = 1026
PBM_SETRANGE = 1025
PBM_SETRANGE32 = 1030
PBS_MARQUEE = 8
PM_REMOVE = 1
SW_HIDE = 0
SW_SHOW = 5
SW_SHOWNORMAL = 1
SWP_NOACTIVATE = 16
SWP_NOMOVE = 2
SWP_NOSIZE = 1
SWP_NOZORDER = 4
VER_PLATFORM_WIN32_NT = 2
WM_COMMAND = 273
WM_GETTEXT = 13
WM_GETTEXTLENGTH = 14
WM_INITDIALOG = 272
WM_NOTIFY = 78


# Windows function prototypes
BrowseCallbackProc = ctypes.WINFUNCTYPE(ctypes.c_int, wintypes.HWND, ctypes.c_uint, wintypes.LPARAM, wintypes.LPARAM)
DialogProc = ctypes.WINFUNCTYPE(ctypes.c_int, wintypes.HWND, ctypes.c_uint, wintypes.WPARAM, wintypes.LPARAM)
EnumChildProc = ctypes.WINFUNCTYPE(ctypes.c_int, wintypes.HWND, wintypes.LPARAM)
LPOFNHOOKPROC = ctypes.WINFUNCTYPE(ctypes.c_int, wintypes.HWND, ctypes.c_uint, wintypes.WPARAM, wintypes.LPARAM)


# Windows types
LPCTSTR = ctypes.c_char_p
LPTSTR = ctypes.c_char_p
LPVOID = ctypes.c_voidp
TCHAR = ctypes.c_char

class OSVERSIONINFO(ctypes.Structure):
    _fields_ = [
                ("dwOSVersionInfoSize", wintypes.DWORD),
                ("dwMajorVersion", wintypes.DWORD),
                ("dwMinorVersion", wintypes.DWORD),
                ("dwBuildNumber", wintypes.DWORD),
                ("dwPlatformId", wintypes.DWORD),
                ("szCSDVersion", TCHAR*128)
               ]
    def __init__(self):
        ctypes.Structure.__init__(self)
        self.dwOSVersionInfoSize = ctypes.sizeof(self)

class OPENFILENAME(ctypes.Structure):
    _fields_ = [
                ("lStructSize", wintypes.DWORD),
                ("hwndOwner", wintypes.HWND),
                ("hInstance", LPCTSTR),
                ("lpstrFilter", LPCTSTR),
                ("lpstrCustomFilter", LPTSTR),
                ("nMaxCustFilter", wintypes.DWORD),
                ("nFilterIndex", wintypes.DWORD),
                ("lpstrFile", LPTSTR),
                ("nMaxFile", wintypes.DWORD),
                ("lpstrFileTitle", LPTSTR),
                ("nMaxFileTitle", wintypes.DWORD),
                ("lpstrInitialDir", LPCTSTR),
                ("lpstrTitle", LPCTSTR),
                ("flags", wintypes.DWORD),
                ("nFileOffset", wintypes.WORD),
                ("nFileExtension", wintypes.WORD),
                ("lpstrDefExt", LPCTSTR),
                ("lCustData", wintypes.LPARAM),
                ("lpfnHook", LPOFNHOOKPROC),
                ("lpTemplateName", LPCTSTR),
                ("pvReserved", LPVOID),
                ("dwReserved", wintypes.DWORD),
                ("FlagsEx", wintypes.DWORD)
               ]

    def __init__(self):
        ctypes.Structure.__init__(self)
        versionInfo = OSVERSIONINFO()
        kernel32.GetVersionExA(ctypes.byref(versionInfo))
        if versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT:
            if (versionInfo.dwMajorVersion, versionInfo.dwMinorVersion) == (4, 0):
                self.lStructSize = OPENFILENAME_SIZE_VERSION_400
            elif versionInfo.dwMajorVersion >= 5:
                self.lStructSize = ctypes.sizeof(OPENFILENAME)
            else:
                raise RuntimeError('Windows NT 4.0 or later is required.')
        else:
            self.lStructSize = ctypes.sizeof(OPENFILENAME) - 12

class BROWSEINFO(ctypes.Structure):
    _fields_ = [
                ("hwndOwner", wintypes.HWND),
                ("pidlRoot", LPVOID),
                ("pszDisplayName", LPTSTR),
                ("lpszTitle", LPCTSTR),
                ("ulFlags", ctypes.c_uint),
                ("lpfn", BrowseCallbackProc),
                ("lParam", wintypes.LPARAM),
                ("iImage", ctypes.c_int)
               ]


# Windows macro emulation
def HIWORD(x):
    return (x >> 16) & 0xffff

def LOWORD(x):
    return x & 0xffff

def MAKELONG(a, b):
    return (a & 0xffff) | ((b & 0xffff) << 16)

MAKELPARAM = MAKELONG


# Utilities
def CenterWindow(hwnd):
    desktopRect = GetWindowRect(user32.GetDesktopWindow())
    myRect = GetWindowRect(hwnd)
    x = width(desktopRect) // 2 - width(myRect) // 2
    y = height(desktopRect) // 2 - height(myRect) // 2
    user32.SetWindowPos(hwnd, 0,
                        desktopRect.left + x,
                        desktopRect.top + y,
                        0, 0,
                        SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER
                       )

def EnumChildWindows(hwnd):
    childWindows = []
    def enumChildProc(hwnd, lParam):
        childWindows.append(hwnd)
        return True
    enumChildProc = EnumChildProc(enumChildProc)
    user32.EnumChildWindows(hwnd, enumChildProc, 0)
    return childWindows

def GetText(hwnd):
    length = user32.SendMessageA(hwnd, WM_GETTEXTLENGTH, 0, 0) + 1
    buffer = ctypes.c_char_p('\0' * length)
    user32.SendMessageA(hwnd, WM_GETTEXT, length, buffer)
    return buffer.value

def GetWindowRect(hwnd):
    rect = wintypes.RECT()
    user32.GetWindowRect(hwnd, ctypes.byref(rect))
    return rect

def width(rect):
    return rect.right-rect.left

def height(rect):
    return rect.bottom-rect.top


# Mac API emulation
def AutoSizeDialog(dialog, center=True):
    classNameBuffer = ctypes.c_buffer(1024)
    children = []
    editBoxes = []
    for child in EnumChildWindows(dialog):
        children.append(child)
        user32.GetClassNameA(child, classNameBuffer, 1024)
        if classNameBuffer.value.lower() == 'edit':
            editBoxes.append(child)

    editBoxes.sort(lambda x, y: cmp(GetWindowRect(x).top, GetWindowRect(y).top))

    for editBox in editBoxes:
        text = GetText(editBox)
        user32.SetWindowTextA(editBox, 'X\r\nX')
        if user32.SendMessageA(editBox, EM_GETLINECOUNT, 0, 0) < 2:
            user32.SetWindowTextA(editBox, text)
        else:
            lineHeight = HIWORD(user32.SendMessageA(editBox, EM_POSFROMCHAR, 3, 0)) - HIWORD(user32.SendMessageA(editBox, EM_POSFROMCHAR, 0, 0))
            user32.SetWindowTextA(editBox, text)
            newHeight = user32.SendMessageA(editBox, EM_GETLINECOUNT, 0, 0)*lineHeight + 2*LOWORD(user32.SendMessageA(editBox, EM_GETMARGINS, 0, 0))
            editBoxRect = GetWindowRect(editBox)
            oldHeight = height(editBoxRect)
            if newHeight != oldHeight:
                topLeft = wintypes.POINT(editBoxRect.left, editBoxRect.top)
                user32.ScreenToClient(dialog, ctypes.byref(topLeft))
                user32.MoveWindow(editBox, topLeft.x, topLeft.y, width(editBoxRect), newHeight, False)

                for child in children:
                    childRect = GetWindowRect(child)
                    if childRect.top >= editBoxRect.bottom:
                        topLeft = wintypes.POINT(childRect.left, childRect.top)
                        user32.ScreenToClient(dialog, ctypes.byref(topLeft))
                        user32.MoveWindow(child,
                                          topLeft.x, topLeft.y + newHeight - oldHeight,
                                          width(childRect), height(childRect),
                                          False
                                         )

                dRect = GetWindowRect(dialog)
                dRect.bottom += newHeight - oldHeight
                topLeft = wintypes.POINT(dRect.left, dRect.top)
                user32.MoveWindow(dialog, topLeft.x, topLeft.y, width(dRect), height(dRect), False)
                user32.InvalidateRect(dialog, None, True)

    if center:
        CenterWindow(dialog)


# Mac EasyDialogs emulation
def crlf2lf(text):
    if '\r\n' in text:
        text = '\n'.join(text.split('\r\n'))
    return text


def lf2crlf(text):
    if '\n' in text:
        text = '\r\n'.join(text.split('\n'))
    if len(text) > 253:
        text = text[:253] + '\205'
    return text


def Message(msg, id=260, ok=None):
    """Display a MESSAGE string.

    Return when the user clicks the OK button or presses Return.

    The MESSAGE string can be at most 255 characters long.
    """
    def DlgProc(hwnd, uMsg, wParam, lParam):
        if uMsg == WM_INITDIALOG:
            user32.SetWindowTextA(user32.GetDlgItem(hwnd, 1002), lf2crlf(msg))
            if ok:
                user32.SetWindowTextA(user32.GetDlgItem(hwnd, IDOK), ok)
            AutoSizeDialog(hwnd)
            return False
        if uMsg == WM_COMMAND and LOWORD(wParam) == IDOK:
            user32.EndDialog(hwnd, IDOK)
            return True
        if uMsg == WM_COMMAND and LOWORD(wParam) == IDCANCEL:
            user32.EndDialog(hwnd, IDCANCEL)
            return True
        else:
            return False

    # This next line is needed to prevent gc of the callback
    myDialogProc = DialogProc(DlgProc)
    return user32.DialogBoxIndirectParamA(0, resources[id], 0, myDialogProc, 0)


def AskString(prompt, default = '', id=261, ok=None, cancel=None):
    """Display a PROMPT string and a text entry field with a DEFAULT string.

    Return the contents of the text entry field when the user clicks the
    OK button or presses Return.
    Return None when the user clicks the Cancel button.

    If omitted, DEFAULT is empty.

    The PROMPT and DEFAULT strings, as well as the return value,
    can be at most 255 characters long.
    """
    result = [None]
    def DlgProc(hwnd, uMsg, wParam, lParam):
        if uMsg == WM_INITDIALOG:
            user32.SetWindowTextA(user32.GetDlgItem(hwnd, 1003), lf2crlf(prompt))
            user32.SetWindowTextA(user32.GetDlgItem(hwnd, 1004), lf2crlf(default))
            if ok:
                user32.SetWindowTextA(user32.GetDlgItem(hwnd, IDOK), ok)
            if cancel:
                user32.SetWindowTextA(user32.GetDlgItem(hwnd, IDCANCEL), cancel)
            AutoSizeDialog(hwnd)
            return False
        if uMsg == WM_COMMAND and LOWORD(wParam) == IDOK:
            result[0] = crlf2lf(GetText(user32.GetDlgItem(hwnd, 1004)))
            user32.EndDialog(hwnd, IDOK)
            return True
        if uMsg == WM_COMMAND and LOWORD(wParam) == IDCANCEL:
            user32.EndDialog(hwnd, IDCANCEL)
            return True
        else:
            return False

    # This next line is needed to prevent gc of the callback
    myDialogProc = DialogProc(DlgProc)
    user32.DialogBoxIndirectParamA(0, resources[id], 0, myDialogProc, 0)
    return result[0]


def AskPassword(prompt, default='', id=264, ok=None, cancel=None):
    """Display a PROMPT string and a text entry field with a DEFAULT string.
    The string is displayed as bullets only.

    Return the contents of the text entry field when the user clicks the
    OK button or presses Return.
    Return None when the user clicks the Cancel button.

    If omitted, DEFAULT is empty.

    The PROMPT and DEFAULT strings, as well as the return value,
    can be at most 255 characters long.
    """
    return AskString(prompt, default=default, id=id, ok=ok, cancel=cancel)


def AskYesNoCancel(question, default=0, yes=None, no=None, cancel=None, id=262):
    """Display a QUESTION string which can be answered with Yes or No.

    Return 1 when the user clicks the Yes button.
    Return 0 when the user clicks the No button.
    Return -1 when the user clicks the Cancel button.

    When the user presses Return, the DEFAULT value is returned.
    If omitted, this is 0 (No).

    The QUESTION string can be at most 255 characters.
    """
    def DlgProc(hwnd, uMsg, wParam, lParam):
        if uMsg == WM_INITDIALOG:
            user32.SetWindowTextA(user32.GetDlgItem(hwnd, 1005), lf2crlf(question))

            if yes is not None:
                button = user32.GetDlgItem(hwnd, IDYES)
                if yes == '':
                    user32.ShowWindow(button, False)
                else:
                    user32.SetWindowTextA(button, yes)
            if no is not None:
                button = user32.GetDlgItem(hwnd, IDNO)
                if no == '':
                    user32.ShowWindow(button, False)
                else:
                    user32.SetWindowTextA(button, no)
            if cancel is not None:
                button = user32.GetDlgItem(hwnd, IDCANCEL)
                if cancel == '':
                    user32.ShowWindow(button, False)
                else:
                    user32.SetWindowTextA(button, cancel)

            button = None
            if default == 1:
                button = user32.GetDlgItem(hwnd, IDYES)
            elif default == 0:
                button = user32.GetDlgItem(hwnd, IDNO)
            elif default == -1:
                button = user32.GetDlgItem(hwnd, IDCANCEL)
            if button:
                style = user32.GetWindowLongA(button, GWL_STYLE)
                user32.SetWindowLongA(button, GWL_STYLE, style | BS_DEFPUSHBUTTON)
                user32.SetFocus(button)

            AutoSizeDialog(hwnd)
            return False
        if uMsg == WM_COMMAND and LOWORD(wParam) == IDYES:
            user32.EndDialog(hwnd, 1)
            return True
        elif uMsg == WM_COMMAND and LOWORD(wParam) == IDNO:
            user32.EndDialog(hwnd, 0)
            return True
        elif uMsg == WM_COMMAND and LOWORD(wParam) == IDCANCEL:
            user32.EndDialog(hwnd, -1)
            return True
        else:
            return False

    # This next line is needed to prevent gc of the callback
    myDialogProc = DialogProc(DlgProc)
    return user32.DialogBoxIndirectParamA(0, resources[id], 0, myDialogProc, 0)


class ProgressBar:
    def __init__(self, title="Working...", maxval=0, label="", id=263):
        self._label = lf2crlf(label)
        def DlgProc(hwnd, uMsg, wParam, lParam):
            if uMsg == WM_INITDIALOG:
                user32.SetWindowTextA(hwnd, title)
                user32.SetWindowTextA(user32.GetDlgItem(hwnd, 1002), DlgProc.label)
            if uMsg == WM_COMMAND and LOWORD(wParam) == IDOK:
                user32.EndDialog(hwnd, IDOK)
                return True
            if uMsg == WM_COMMAND and LOWORD(wParam) == IDCANCEL:
                user32.EndDialog(hwnd, IDCANCEL)
                return True
            else:
                return False

        # Why a function attribute? Originally nested scopes
        # were used to get at self._label. This caused a cyclic reference
        # and since ProgressBar has a __del__ method (which closes the
        # window) it would never be collected (and hence the window
        # wouldn't close). Think of label as being like self. When this
        # function it used it will be used as a bound method where the
        # label is the object.
        DlgProc.label = self._label

        # This next line is needed to prevent gc of the callback
        self.wrappedDlgProc = DialogProc(DlgProc)
        self.hwnd = user32.CreateDialogIndirectParamA(0, resources[id], 0, self.wrappedDlgProc, 0)

        AutoSizeDialog(self.hwnd)
        user32.ShowWindow(self.hwnd, SW_SHOWNORMAL)
        self.set(0, maxval)

    def __del__(self):
        user32.DestroyWindow(self.hwnd)

    def title(self, newstr=""):
        """title(text) - Set title of progress window"""
        user32.SetWindowTextA(self.hwnd, newstr)
        self._pump()

    def label( self, *newstr ):
        """label(text) - Set text in progress box"""
        if newstr:
            self._label = lf2crlf(newstr[0])
        user32.SetWindowTextA(user32.GetDlgItem(self.hwnd, 1002), self._label)
        AutoSizeDialog(self.hwnd, center=False)
        self._pump()


    def _pump(self):
        msg = wintypes.MSG()
        while user32.PeekMessageA(ctypes.byref(msg), 0, 0, 0, PM_REMOVE):
            if not user32.IsDialogMessage(self.hwnd, ctypes.byref(msg)):
                user32.TranslateMessage(ctypes.byref(msg))
                user32.DispatchMessageA(ctypes.byref(msg))

        if not user32.IsWindowVisible(self.hwnd):
            raise KeyboardInterrupt


    def _update(self, value):
        maxval = self.maxval
        progbar = user32.GetDlgItem(self.hwnd, 1003)
        if maxval == 0:     # an indeterminate bar
            # make the bar grow and wrap around in case Marquee bars aren't supported
            pass
            pos = user32.SendMessageA(progbar, PBM_GETPOS, 0, 0)
            user32.SendMessageA(progbar, PBM_SETRANGE, 0, MAKELPARAM(0, 10))
            user32.SendMessageA(progbar, PBM_SETPOS, (pos+1) % 10, 0)
        else:               # a determinate bar
            if maxval > 32767:
                value = int(value/(maxval/32767.0))
                maxval = 32767
            maxval = int(maxval)
            value = int(value)
            if maxval > 65535:
                user32.SendMessageA(progbar, PBM_SETRANGE32, 0, maxval)
            else:
                user32.SendMessageA(progbar, PBM_SETRANGE, 0, MAKELPARAM(0, maxval))
            user32.SendMessageA(progbar, PBM_SETPOS, value, 0)  # set the bar length
        self._pump()


    def set(self, value, max=None):
        """set(value) - Set progress bar position"""
        if max != None:
            self.maxval = max
            bar = user32.GetDlgItem(self.hwnd, 1003)
            if max <= 0:    # indeterminate bar
                self.maxval = 0
                style = user32.GetWindowLongA(bar, GWL_STYLE)
                if not (style & PBS_MARQUEE):
                    user32.SetWindowLongA(bar, GWL_STYLE, style | PBS_MARQUEE)
                    user32.SendMessageA(bar, PBM_SETMARQUEE, 1, 10)
            else:           # determinate bar
                user32.SendMessageA(bar, PBM_SETMARQUEE, 0, 0)
                style = user32.GetWindowLongA(bar, GWL_STYLE)
                if style & PBS_MARQUEE:
                    user32.SetWindowLongA(bar, GWL_STYLE, style - PBS_MARQUEE)
        if value < 0:
            value = 0
        elif value > self.maxval:
            value = self.maxval
        self.curval = value
        self._update(value)

    def inc(self, n=1):
        """inc(amt) - Increment progress bar position"""
        self.set(self.curval + n)


def AskFileForOpen(
        message=None,
        typeList=None,
        # From here on the order is not documented
        version=None,
        defaultLocation=None,
        dialogOptionFlags=None,
        location=None,
        clientName=None,
        windowTitle=None,
        actionButtonLabel=None,
        cancelButtonLabel=None,
        preferenceKey=None,
        popupExtension=None,
        eventProc=None,
        previewProc=None,
        filterProc=None,
        wanted=None,
        multiple=None,
        # the following are for implementation use only
        defaultfn='',
        defaultext=None,
        fn=comdlg32.GetOpenFileNameA):
    """Display a dialog asking the user for a file to open.

    wanted is the return type wanted: FSSpec, FSRef, unicode or string (default)
    the other arguments can be looked up in Apple's Navigation Services documentation

    Windows differences:

    typeList is used for the same purpose, but file type handling is different
    between Windows and Mac, so the form of this argument is different. In an
    attempt to remain as similar as possible, a list of extensions can be
    supplied (e.g., ['*', 'txt', 'bat']). A more complete form is also
    allowed: [('All Files (*.*)', '*.*'), ('C Files (*.c, *.h)', '*.c;*.h')].
    The first item in each tuple is the text description presented to the
    user. The second item in each tuple is a semi-colon seperated list of
    standard Windows wildcard patterns that will match files described in the
    text description.

    The folowing parameters are ignored on Windows:
    clientName, dialogOptionFlags, eventProc, filterProc, popupExtension,
    preferenceKey, previewProc, version, wanted
    """

    ofn = OPENFILENAME()
    filename = defaultfn + '\0'*1024
    ofn.lpstrFile = filename
    ofn.nMaxFile = len(filename)
    ofn.flags = OFN_ENABLEHOOK | OFN_EXPLORER | OFN_ENABLESIZING | OFN_OVERWRITEPROMPT
    if multiple:
        ofn.flags |= OFN_ALLOWMULTISELECT
    ofn.lpstrTitle = windowTitle
    ofn.lpstrInitialDir = defaultLocation

    if typeList and filter(None, typeList):
        lpstrFilter = ''
        for typeSpec in typeList:
            try:
                lpstrFilter += '*.'+typeSpec+'\0*.'+typeSpec+'\0'
                if defaultext and not ofn.lpstrDefExt:
                    ofn.lpstrDefExt = typeSpec
            except TypeError:
                lpstrFilter += '%s\0%s\0' % typeSpec
                if defaultext and not ofn.lpstrDefExt:
                    ext = os.path.splitext(typeSpec[1])[1].lstrip('.')
                    if ext != '*':
                        ofn.lpstrDefExt = ext
        ofn.lpstrFilter = lpstrFilter + '\0'
    else:
        ofn.lpstrFilter = 'All Files (*.*)\0*.*\0\0'

    if message:
        ofn.flags |= OFN_ENABLETEMPLATEHANDLE
        ofn.hInstance = resources[270]

    hookProcInitDone = []
    def hookProc(hdlg, uiMsg, wParam, lParam):
        if uiMsg == WM_INITDIALOG:
            dialog = user32.GetParent(hdlg)
            if message:
                handle = user32.FindWindowExA(hdlg, 0, 0, 0)
                user32.SetWindowTextA(handle, message)
            if actionButtonLabel:
                user32.SendMessageA(dialog, CDM_SETCONTROLTEXT, IDOK, actionButtonLabel)
            if cancelButtonLabel:
                user32.SendMessageA(dialog, CDM_SETCONTROLTEXT, IDCANCEL, cancelButtonLabel)
        elif uiMsg == WM_NOTIFY:
            if not hookProcInitDone:
                hookProcInitDone.append(True)
                dialog = user32.GetParent(hdlg)
                desktop = user32.GetDesktopWindow()
                if message:
                    clientRect = wintypes.RECT()
                    user32.GetClientRect(dialog, ctypes.byref(clientRect))
                    dlgRect = wintypes.RECT()
                    user32.GetWindowRect(hdlg, ctypes.byref(dlgRect))
                    user32.SetWindowPos(hdlg, 0,
                                      0, 0,
                                      width(clientRect), height(dlgRect),
                                      SWP_NOMOVE | SWP_NOZORDER)
                    handle = user32.GetDlgItem(hdlg, IDC_STATIC)
                    user32.SetWindowPos(handle, 0,
                                      0, 0,
                                      width(clientRect), height(dlgRect),
                                      SWP_NOMOVE | SWP_NOZORDER)
                if location:
                    x, y = location
                    desktopRect = wintypes.RECT()
                    user32.GetWindowRect(desktop, ctypes.byref(desktopRect))
                    user32.SetWindowPos(dialog, 0,
                                      desktopRect.left + x,
                                      desktopRect.top + y, 0, 0,
                                      SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER)
                else: # center
                    CenterWindow(dialog)
        return 0

    ofn.lpfnHook = LPOFNHOOKPROC(hookProc)

    if fn(ctypes.byref(ofn)):
        filenames = filter(None, filename.split('\0'))
        if len(filenames) > 1:
            dir, filenames = filenames[0], filenames[1:]
            return map(lambda fn: os.path.join(dir, fn), filenames)
        elif multiple:
            return filenames
        else:
            return filenames[0]
    else:
        return None


def AskFileForSave(
        message=None,
        savedFileName=None,
        # From here on the order is not documented
        version=None,
        defaultLocation=None,
        dialogOptionFlags=None,
        location=None,
        clientName=None,
        windowTitle=None,
        actionButtonLabel=None,
        cancelButtonLabel=None,
        preferenceKey=None,
        popupExtension=None,
        eventProc=None,
        fileType=None,
        fileCreator=None,
        wanted=None,
        multiple=None):
    """Display a dialog asking the user for a filename to save to.

    wanted is the return type wanted: FSSpec, FSRef, unicode or string (default)
    the other arguments can be looked up in Apple's Navigation Services documentation

    Windows differences:

    fileType is used for the same purpose, but file type handling is different
    between Windows and Mac, so the form of this argument is different. In an
    attempt to remain as similar as possible, an extensions can be supplied
    (e.g., 'txt'). A more complete form is also	allowed:
    ('Text Files (*.txt)', '*.txt'). The first item in the tuple is the text
    description presented to the user. The second item in the tuple is a
    standard Windows wildcard pattern that will match files described in the
    text description.

    The folowing parameters are ignored on Windows:
    clientName, dialogOptionFlags, eventProc, fileCreator, filterProc,
    multiple, popupExtension, preferenceKey, previewProc, version, wanted
    """
    return AskFileForOpen(
                        message=message, typeList=[fileType], version=version,
                        defaultLocation=defaultLocation,
                        dialogOptionFlags=dialogOptionFlags, location=location,
                        clientName=clientName, windowTitle=windowTitle,
                        actionButtonLabel=actionButtonLabel,
                        cancelButtonLabel=cancelButtonLabel,
                        preferenceKey=preferenceKey,
                        popupExtension=popupExtension, eventProc=eventProc,
                        wanted=wanted, multiple=multiple,
                        defaultfn=savedFileName or '',
                        defaultext=True,
                        fn=comdlg32.GetSaveFileNameA)


def AskFolder(
        message=None,
        # From here on the order is not documented
        version=None,
        defaultLocation=None,
        dialogOptionFlags=None,
        location=None,
        clientName=None,
        windowTitle=None,
        actionButtonLabel=None,
        cancelButtonLabel=None,
        preferenceKey=None,
        popupExtension=None,
        eventProc=None,
        filterProc=None,
        wanted=None,
        multiple=None):
    """Display a dialog asking the user for select a folder.

    wanted is the return type wanted: FSSpec, FSRef, unicode or string (default)
    the other arguments can be looked up in Apple's Navigation Services documentation

    Windows differences:

    The folowing parameters are ignored on Windows:
    clientName, dialogOptionFlags, eventProc, filterProc,
    multiple, popupExtension, preferenceKey, version, wanted
    """


    def BrowseCallback(hwnd, uMsg, lParam, lpData):
        if uMsg == BFFM_INITIALIZED:
            if actionButtonLabel:
                label = unicode(actionButtonLabel, errors='replace')
                user32.SendMessageW(hwnd, BFFM_SETOKTEXT, 0, label)
            if cancelButtonLabel:
                cancelButton = user32.GetDlgItem(hwnd, IDCANCEL)
                if cancelButton:
                    user32.SetWindowTextA(cancelButton, cancelButtonLabel)
            if windowTitle:
                user32.SetWindowTextA(hwnd, windowTitle)
            if defaultLocation:
                user32.SendMessageW(hwnd, BFFM_SETSELECTIONA, 1, defaultLocation.replace('/', '\\'))
            if location:
                x, y = location
                desktopRect = wintypes.RECT()
                user32.GetWindowRect(0, ctypes.byref(desktopRect))
                user32.SetWindowPos(hwnd, 0,
                                  desktopRect.left + x,
                                  desktopRect.top + y, 0, 0,
                                  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER)
            else:
                CenterWindow(hwnd)
        return 0

    # This next line is needed to prevent gc of the callback
    callback = BrowseCallbackProc(BrowseCallback)

    browseInfo = BROWSEINFO()
    browseInfo.pszDisplayName = ctypes.c_char_p('\0' * (MAX_PATH+1))
    browseInfo.lpszTitle = message
    browseInfo.lpfn = callback
    #~ browseInfo.ulFlags = BIF_EDITBOX

    # BIF_NEWDIALOGSTYLE is not used because it only works with apartment
    # threading. Using this style with COINIT_MULTITHREADED can cause problems.
    pidl = shell32.SHBrowseForFolder(ctypes.byref(browseInfo))
    if not pidl:
        result = None
    else:
        path = ctypes.c_char_p('\0' * (MAX_PATH+1))
        shell32.SHGetPathFromIDList(pidl, path)
        ole32.CoTaskMemFree(pidl)
        result = path.value
    return result


ARGV_ID=265
ARGV_ITEM_OK=1
ARGV_ITEM_CANCEL=2
ARGV_OPTION_GROUP=3
ARGV_OPTION_EXPLAIN=4
ARGV_OPTION_VALUE=5
ARGV_OPTION_ADD=6
ARGV_COMMAND_GROUP=7
ARGV_COMMAND_EXPLAIN=8
ARGV_COMMAND_ADD=9
ARGV_ADD_OLDFILE=10
ARGV_ADD_NEWFILE=11
ARGV_ADD_FOLDER=12
ARGV_CMDLINE_GROUP=13
ARGV_CMDLINE_DATA=14

def _setmenu(control, items):
    for item in items:
        if type(item) == type(()):
            label = item[0]
        else:
            label = item
        if label[-1] == '=' or label[-1] == ':':
            label = label[:-1]
        user32.SendMessageA(control, CB_ADDSTRING, 0, label)
    user32.SendMessageA(control, CB_SETCURSEL, 0, 0)

def _selectoption(d, optionlist, idx):
    if idx < 0 or idx >= len(optionlist):
        user32.MessageBeep(-1)
        return
    option = optionlist[idx]
    if type(option) == type(()):
        if len(option) == 4:
            help = option[2]
        elif len(option) > 1:
            help = option[-1]
        else:
            help = ''
    else:
        help = ''
    h = user32.GetDlgItem(d, ARGV_OPTION_EXPLAIN)
    if help and len(help) > 250:
        help = help[:250] + '...'
    user32.SetWindowTextA(h, help)
    hasvalue = 0
    if type(option) == type(()):
        label = option[0]
    else:
        label = option
    if label[-1] == '=' or label[-1] == ':':
        hasvalue = 1
    h = user32.GetDlgItem(d, ARGV_OPTION_VALUE)
    user32.SetWindowTextA(h, '')
    if hasvalue:
        user32.ShowWindow(h, SW_SHOW)
        #~ d.SelectDialogItemText(ARGV_OPTION_VALUE, 0, 0)
    else:
        user32.ShowWindow(h, SW_HIDE)

def GetArgv(optionlist=None, commandlist=None, addoldfile=1, addnewfile=1, addfolder=1, id=ARGV_ID):
    commandLineContents = []
    def DlgProc(hwnd, uMsg, wParam, lParam):
        if uMsg == WM_INITDIALOG:
            if optionlist:
                _setmenu(user32.GetDlgItem(hwnd, ARGV_OPTION_GROUP), optionlist)
                _selectoption(hwnd, optionlist, 0)
            else:
                for id in (30, ARGV_OPTION_GROUP, ARGV_OPTION_VALUE, ARGV_OPTION_ADD):
                    user32.EnableWindow(user32.GetDlgItem(hwnd, id), False)
            if commandlist:
                _setmenu(user32.GetDlgItem(hwnd, ARGV_COMMAND_GROUP), commandlist)
                if type(commandlist[0]) == type(()) and len(commandlist[0]) > 1:
                    help = commandlist[0][-1]
                    h = user32.GetDlgItem(hwnd, ARGV_COMMAND_EXPLAIN)
                    user32.SetWindowTextA(h, help)
            else:
                for id in (70, ARGV_COMMAND_GROUP, ARGV_COMMAND_ADD):
                    user32.EnableWindow(user32.GetDlgItem(hwnd, id), False)
            if not addoldfile:
                user32.EnableWindow(user32.GetDlgItem(hwnd, ARGV_ADD_OLDFILE), False)
            if not addnewfile:
                user32.EnableWindow(user32.GetDlgItem(hwnd, ARGV_ADD_NEWFILE), False)
            if not addfolder:
                user32.EnableWindow(user32.GetDlgItem(hwnd, ARGV_ADD_FOLDER), False)
            CenterWindow(hwnd)
            return False
        elif uMsg == WM_COMMAND and LOWORD(wParam) == IDOK:
            h = user32.GetDlgItem(hwnd, ARGV_CMDLINE_DATA)
            commandLineContents.append(GetText(h))
            user32.EndDialog(hwnd, IDOK)
            return True
        elif uMsg == WM_COMMAND and LOWORD(wParam) == IDCANCEL:
            user32.EndDialog(hwnd, IDCANCEL)
            return True

        if uMsg == WM_COMMAND:
            stringstoadd = []
            n = LOWORD(wParam)
            if n == ARGV_OPTION_GROUP:
                idx = user32.SendMessageA(lParam, CB_GETCURSEL, 0, 0)
                _selectoption(hwnd, optionlist, idx)
                return True
            elif n == ARGV_OPTION_ADD:
                idx = user32.SendMessageA(user32.GetDlgItem(hwnd, ARGV_OPTION_GROUP), CB_GETCURSEL, 0, 0)
                if 0 <= idx < len(optionlist):
                    option = optionlist[idx]
                    if type(option) == type(()):
                        option = option[0]
                    if option[-1] == '=' or option[-1] == ':':
                        option = option[:-1]
                        h = user32.GetDlgItem(hwnd, ARGV_OPTION_VALUE)
                        value = GetText(h)
                    else:
                        value = ''
                    if len(option) == 1:
                        stringtoadd = '-' + option
                    else:
                        stringtoadd = '--' + option
                    stringstoadd[:] = [stringtoadd]
                    if value:
                        stringstoadd.append(value)
                else:
                    user32.MessageBeep(-1)
            elif n == ARGV_COMMAND_GROUP:
                idx = user32.SendMessageA(lParam, CB_GETCURSEL, 0, 0)
                if 0 <= idx < len(commandlist) and type(commandlist[idx]) == type(()) and \
                        len(commandlist[idx]) > 1:
                    help = commandlist[idx][-1]
                    h = user32.GetDlgItem(hwnd, ARGV_COMMAND_EXPLAIN)
                    user32.SetWindowTextA(h, help)
            elif n == ARGV_COMMAND_ADD:
                idx = user32.SendMessageA(user32.GetDlgItem(hwnd, ARGV_COMMAND_GROUP), CB_GETCURSEL, 0, 0)
                if 0 <= idx < len(commandlist):
                    command = commandlist[idx]
                    if type(command) == type(()):
                        command = command[0]
                    stringstoadd = [command]
                else:
                    user32.MessageBeep(-1)
            elif n == ARGV_ADD_OLDFILE:
                pathname = AskFileForOpen()
                if pathname:
                    stringstoadd = [pathname]
            elif n == ARGV_ADD_NEWFILE:
                pathname = AskFileForSave()
                if pathname:
                    stringstoadd = [pathname]
            elif n == ARGV_ADD_FOLDER:
                pathname = AskFolder()
                if pathname:
                    stringstoadd = [pathname]

            for stringtoadd in stringstoadd:
                if '"' in stringtoadd or "'" in stringtoadd or " " in stringtoadd:
                    stringtoadd = repr(stringtoadd)
                h = user32.GetDlgItem(hwnd, ARGV_CMDLINE_DATA)
                oldstr = GetText(h)
                if oldstr and oldstr[-1] != ' ':
                    oldstr = oldstr + ' '
                oldstr = oldstr + stringtoadd
                if oldstr[-1] != ' ':
                    oldstr = oldstr + ' '
                user32.SetWindowTextA(h, oldstr)
                user32.SendMessageA(user32.GetDlgItem(hwnd, ARGV_CMDLINE_DATA), EM_SETSEL, 0, -1)

        return False

    # This next line is needed to prevent gc of the callback
    myDialogProc = DialogProc(DlgProc)
    if IDOK == user32.DialogBoxIndirectParamA(0, resources[id], 0, myDialogProc, 0):
        oldstr = commandLineContents[0]
        tmplist = oldstr.split()
        newlist = []
        while tmplist:
            item = tmplist[0]
            del tmplist[0]
            if item[0] == '"':
                while item[-1] != '"':
                    if not tmplist:
                        raise RuntimeError, "Unterminated quoted argument"
                    item = item + ' ' + tmplist[0]
                    del tmplist[0]
                item = item[1:-1]
            if item[0] == "'":
                while item[-1] != "'":
                    if not tmplist:
                        raise RuntimeError, "Unterminated quoted argument"
                    item = item + ' ' + tmplist[0]
                    del tmplist[0]
                item = item[1:-1]
            newlist.append(item)
        return newlist
    else:
        raise SystemExit


def test():
    import time

    class empty: pass
    Carbon = empty()
    Carbon.File = empty()
    Carbon.File.FSSpec = None
    Carbon.File.FSRef = None
    MacOS = empty()

    Message("Testing EasyDialogs.")
    optionlist = (('v', 'Verbose'), ('verbose', 'Verbose as long option'),
                ('flags=', 'Valued option'), ('f:', 'Short valued option'))
    commandlist = (('start', 'Start something'), ('stop', 'Stop something'))
    argv = GetArgv(optionlist=optionlist, commandlist=commandlist, addoldfile=0)
    Message("Command line: %s"%' '.join(argv))
    for i in range(len(argv)):
        print 'arg[%d] = %r' % (i, argv[i])
    ok = AskYesNoCancel("Do you want to proceed?")
    ok = AskYesNoCancel("Do you want to identify?", yes="Identify", no="No")
    if ok > 0:
        s = AskString("Enter your first name", "Joe")
        s2 = AskPassword("Okay %s, tell us your nickname"%s, s, cancel="None")
        if not s2:
            Message("%s has no secret nickname"%s)
        else:
            Message("Hello everybody!!\nThe secret nickname of %s is %s!!!"%(s, s2))
    else:
        s = 'Anonymous'
    rv = AskFileForOpen(message="Gimme a file, %s"%s, wanted=Carbon.File.FSSpec)
    Message("rv: %s"%rv)
    rv = AskFileForSave(wanted=Carbon.File.FSRef, savedFileName="%s.txt"%s)
    Message("rv: %s"%rv) # was: Message("rv.as_pathname: %s"%rv.as_pathname())
    rv = AskFolder()
    Message("Folder name: %s"%rv)
    text = ( "Working Hard...", "Hardly Working..." ,
            "So far, so good!", "Keep on truckin'" )
    bar = ProgressBar("Progress, progress...", 0, label="Ramping up...")
    try:
        if hasattr(MacOS, 'SchedParams'):
            appsw = MacOS.SchedParams(1, 0)
        for i in xrange(20):
            bar.inc()
            time.sleep(0.05)
        bar.set(0,100)
        for i in xrange(100):
            bar.set(i)
            time.sleep(0.05)
            if i % 10 == 0:
                bar.label(text[(i//10) % 4])
        bar.label("Done.")
        time.sleep(1.0)     # give'em a chance to see "Done."
    finally:
        del bar
        if hasattr(MacOS, 'SchedParams'):
            MacOS.SchedParams(*appsw)

if __name__ == '__main__':
    try:
        test()
    except KeyboardInterrupt:
        Message("Operation Canceled.")

########NEW FILE########
__FILENAME__ = pefile
#@PydevCodeAnalysisIgnore


"""pefile, Portable Executable reader module


All the PE file basic structures are available with their default names
as attributes of the instance returned.

Processed elements such as the import table are made available with lowercase
names, to differentiate them from the upper case basic structure names.

pefile has been tested against the limits of valid PE headers, that is, malware.
Lots of packed malware attempt to abuse the format way beyond its standard use.
To the best of my knowledge most of the abuses are handled gracefully.

Copyright (c) 2005, 2006, 2007, 2008, 2009 Ero Carrera <ero@dkbza.org>

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
OF SUCH DAMAGE.
"""

__revision__ = "$LastChangedRevision: 63 $"
__author__ = 'Ero Carrera'
__version__ = '1.2.10-%d' % int( __revision__[21:-2] )
__contact__ = 'ero@dkbza.org'


import struct
import time
import math
import exceptions
import string
import array

sha1, sha256, sha512, md5 = None, None, None, None

try:
    import hashlib
    sha1 = hashlib.sha1
    sha256 = hashlib.sha256
    sha512 = hashlib.sha512
    md5 = hashlib.md5
except ImportError:
    try:
        import sha
        sha1 = sha.new
    except ImportError:
        pass
    try:
        import md5
        md5 = md5.new
    except ImportError:
        pass


fast_load = False

IMAGE_DOS_SIGNATURE             = 0x5A4D
IMAGE_OS2_SIGNATURE             = 0x454E
IMAGE_OS2_SIGNATURE_LE          = 0x454C
IMAGE_VXD_SIGNATURE             = 0x454C
IMAGE_NT_SIGNATURE              = 0x00004550
IMAGE_NUMBEROF_DIRECTORY_ENTRIES= 16
IMAGE_ORDINAL_FLAG              = 0x80000000L
IMAGE_ORDINAL_FLAG64            = 0x8000000000000000L
OPTIONAL_HEADER_MAGIC_PE        = 0x10b
OPTIONAL_HEADER_MAGIC_PE_PLUS   = 0x20b


directory_entry_types = [
    ('IMAGE_DIRECTORY_ENTRY_EXPORT',        0),
    ('IMAGE_DIRECTORY_ENTRY_IMPORT',        1),
    ('IMAGE_DIRECTORY_ENTRY_RESOURCE',      2),
    ('IMAGE_DIRECTORY_ENTRY_EXCEPTION',     3),
    ('IMAGE_DIRECTORY_ENTRY_SECURITY',      4),
    ('IMAGE_DIRECTORY_ENTRY_BASERELOC',     5),
    ('IMAGE_DIRECTORY_ENTRY_DEBUG',         6),
    ('IMAGE_DIRECTORY_ENTRY_COPYRIGHT',     7),
    ('IMAGE_DIRECTORY_ENTRY_GLOBALPTR',     8),
    ('IMAGE_DIRECTORY_ENTRY_TLS',           9),
    ('IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG',   10),
    ('IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT',  11),
    ('IMAGE_DIRECTORY_ENTRY_IAT',           12),
    ('IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT',  13),
    ('IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR',14),
    ('IMAGE_DIRECTORY_ENTRY_RESERVED',      15) ]

DIRECTORY_ENTRY = dict([(e[1], e[0]) for e in directory_entry_types]+directory_entry_types)


image_characteristics = [
    ('IMAGE_FILE_RELOCS_STRIPPED',          0x0001),
    ('IMAGE_FILE_EXECUTABLE_IMAGE',         0x0002),
    ('IMAGE_FILE_LINE_NUMS_STRIPPED',       0x0004),
    ('IMAGE_FILE_LOCAL_SYMS_STRIPPED',      0x0008),
    ('IMAGE_FILE_AGGRESIVE_WS_TRIM',        0x0010),
    ('IMAGE_FILE_LARGE_ADDRESS_AWARE',      0x0020),
    ('IMAGE_FILE_16BIT_MACHINE',            0x0040),
    ('IMAGE_FILE_BYTES_REVERSED_LO',        0x0080),
    ('IMAGE_FILE_32BIT_MACHINE',            0x0100),
    ('IMAGE_FILE_DEBUG_STRIPPED',           0x0200),
    ('IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP',  0x0400),
    ('IMAGE_FILE_NET_RUN_FROM_SWAP',        0x0800),
    ('IMAGE_FILE_SYSTEM',                   0x1000),
    ('IMAGE_FILE_DLL',                      0x2000),
    ('IMAGE_FILE_UP_SYSTEM_ONLY',           0x4000),
    ('IMAGE_FILE_BYTES_REVERSED_HI',        0x8000) ]

IMAGE_CHARACTERISTICS = dict([(e[1], e[0]) for e in
    image_characteristics]+image_characteristics)


section_characteristics = [
    ('IMAGE_SCN_CNT_CODE',                  0x00000020),
    ('IMAGE_SCN_CNT_INITIALIZED_DATA',      0x00000040),
    ('IMAGE_SCN_CNT_UNINITIALIZED_DATA',    0x00000080),
    ('IMAGE_SCN_LNK_OTHER',                 0x00000100),
    ('IMAGE_SCN_LNK_INFO',                  0x00000200),
    ('IMAGE_SCN_LNK_REMOVE',                0x00000800),
    ('IMAGE_SCN_LNK_COMDAT',                0x00001000),
    ('IMAGE_SCN_MEM_FARDATA',               0x00008000),
    ('IMAGE_SCN_MEM_PURGEABLE',             0x00020000),
    ('IMAGE_SCN_MEM_16BIT',                 0x00020000),
    ('IMAGE_SCN_MEM_LOCKED',                0x00040000),
    ('IMAGE_SCN_MEM_PRELOAD',               0x00080000),
    ('IMAGE_SCN_ALIGN_1BYTES',              0x00100000),
    ('IMAGE_SCN_ALIGN_2BYTES',              0x00200000),
    ('IMAGE_SCN_ALIGN_4BYTES',              0x00300000),
    ('IMAGE_SCN_ALIGN_8BYTES',              0x00400000),
    ('IMAGE_SCN_ALIGN_16BYTES',             0x00500000),
    ('IMAGE_SCN_ALIGN_32BYTES',             0x00600000),
    ('IMAGE_SCN_ALIGN_64BYTES',             0x00700000),
    ('IMAGE_SCN_ALIGN_128BYTES',            0x00800000),
    ('IMAGE_SCN_ALIGN_256BYTES',            0x00900000),
    ('IMAGE_SCN_ALIGN_512BYTES',            0x00A00000),
    ('IMAGE_SCN_ALIGN_1024BYTES',           0x00B00000),
    ('IMAGE_SCN_ALIGN_2048BYTES',           0x00C00000),
    ('IMAGE_SCN_ALIGN_4096BYTES',           0x00D00000),
    ('IMAGE_SCN_ALIGN_8192BYTES',           0x00E00000),
    ('IMAGE_SCN_ALIGN_MASK',                0x00F00000),
    ('IMAGE_SCN_LNK_NRELOC_OVFL',           0x01000000),
    ('IMAGE_SCN_MEM_DISCARDABLE',           0x02000000),
    ('IMAGE_SCN_MEM_NOT_CACHED',            0x04000000),
    ('IMAGE_SCN_MEM_NOT_PAGED',             0x08000000),
    ('IMAGE_SCN_MEM_SHARED',                0x10000000),
    ('IMAGE_SCN_MEM_EXECUTE',               0x20000000),
    ('IMAGE_SCN_MEM_READ',                  0x40000000),
    ('IMAGE_SCN_MEM_WRITE',                 0x80000000L) ]

SECTION_CHARACTERISTICS = dict([(e[1], e[0]) for e in
    section_characteristics]+section_characteristics)


debug_types = [
    ('IMAGE_DEBUG_TYPE_UNKNOWN',        0),
    ('IMAGE_DEBUG_TYPE_COFF',           1),
    ('IMAGE_DEBUG_TYPE_CODEVIEW',       2),
    ('IMAGE_DEBUG_TYPE_FPO',            3),
    ('IMAGE_DEBUG_TYPE_MISC',           4),
    ('IMAGE_DEBUG_TYPE_EXCEPTION',      5),
    ('IMAGE_DEBUG_TYPE_FIXUP',          6),
    ('IMAGE_DEBUG_TYPE_OMAP_TO_SRC',    7),
    ('IMAGE_DEBUG_TYPE_OMAP_FROM_SRC',  8),
    ('IMAGE_DEBUG_TYPE_BORLAND',        9),
    ('IMAGE_DEBUG_TYPE_RESERVED10',     10) ]

DEBUG_TYPE = dict([(e[1], e[0]) for e in debug_types]+debug_types)


subsystem_types = [
    ('IMAGE_SUBSYSTEM_UNKNOWN',     0),
    ('IMAGE_SUBSYSTEM_NATIVE',      1),
    ('IMAGE_SUBSYSTEM_WINDOWS_GUI', 2),
    ('IMAGE_SUBSYSTEM_WINDOWS_CUI', 3),
    ('IMAGE_SUBSYSTEM_OS2_CUI',     5),
    ('IMAGE_SUBSYSTEM_POSIX_CUI',   7),
    ('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI',  9),
    ('IMAGE_SUBSYSTEM_EFI_APPLICATION', 10),
    ('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', 11),
    ('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER',      12),
    ('IMAGE_SUBSYSTEM_EFI_ROM',     13),
    ('IMAGE_SUBSYSTEM_XBOX',        14)]

SUBSYSTEM_TYPE = dict([(e[1], e[0]) for e in subsystem_types]+subsystem_types)


machine_types = [
    ('IMAGE_FILE_MACHINE_UNKNOWN',  0),
    ('IMAGE_FILE_MACHINE_AM33',     0x1d3),
    ('IMAGE_FILE_MACHINE_AMD64',    0x8664),
    ('IMAGE_FILE_MACHINE_ARM',      0x1c0),
    ('IMAGE_FILE_MACHINE_EBC',      0xebc),
    ('IMAGE_FILE_MACHINE_I386',     0x14c),
    ('IMAGE_FILE_MACHINE_IA64',     0x200),
    ('IMAGE_FILE_MACHINE_MR32',     0x9041),
    ('IMAGE_FILE_MACHINE_MIPS16',   0x266),
    ('IMAGE_FILE_MACHINE_MIPSFPU',  0x366),
    ('IMAGE_FILE_MACHINE_MIPSFPU16',0x466),
    ('IMAGE_FILE_MACHINE_POWERPC',  0x1f0),
    ('IMAGE_FILE_MACHINE_POWERPCFP',0x1f1),
    ('IMAGE_FILE_MACHINE_R4000',    0x166),
    ('IMAGE_FILE_MACHINE_SH3',      0x1a2),
    ('IMAGE_FILE_MACHINE_SH3DSP',   0x1a3),
    ('IMAGE_FILE_MACHINE_SH4',      0x1a6),
    ('IMAGE_FILE_MACHINE_SH5',      0x1a8),
    ('IMAGE_FILE_MACHINE_THUMB',    0x1c2),
    ('IMAGE_FILE_MACHINE_WCEMIPSV2',0x169),
 ]

MACHINE_TYPE = dict([(e[1], e[0]) for e in machine_types]+machine_types)


relocation_types = [
    ('IMAGE_REL_BASED_ABSOLUTE',        0),
    ('IMAGE_REL_BASED_HIGH',            1),
    ('IMAGE_REL_BASED_LOW',             2),
    ('IMAGE_REL_BASED_HIGHLOW',         3),
    ('IMAGE_REL_BASED_HIGHADJ',         4),
    ('IMAGE_REL_BASED_MIPS_JMPADDR',    5),
    ('IMAGE_REL_BASED_SECTION',         6),
    ('IMAGE_REL_BASED_REL',             7),
    ('IMAGE_REL_BASED_MIPS_JMPADDR16',  9),
    ('IMAGE_REL_BASED_IA64_IMM64',      9),
    ('IMAGE_REL_BASED_DIR64',           10),
    ('IMAGE_REL_BASED_HIGH3ADJ',        11) ]

RELOCATION_TYPE = dict([(e[1], e[0]) for e in relocation_types]+relocation_types)


dll_characteristics = [
    ('IMAGE_DLL_CHARACTERISTICS_RESERVED_0x0001', 0x0001),
    ('IMAGE_DLL_CHARACTERISTICS_RESERVED_0x0002', 0x0002),
    ('IMAGE_DLL_CHARACTERISTICS_RESERVED_0x0004', 0x0004),
    ('IMAGE_DLL_CHARACTERISTICS_RESERVED_0x0008', 0x0008),
    ('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE',      0x0040),
    ('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY',   0x0080),
    ('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT',         0x0100),
    ('IMAGE_DLL_CHARACTERISTICS_NO_ISOLATION',      0x0200),
    ('IMAGE_DLL_CHARACTERISTICS_NO_SEH',    0x0400),
    ('IMAGE_DLL_CHARACTERISTICS_NO_BIND',   0x0800),
    ('IMAGE_DLL_CHARACTERISTICS_RESERVED_0x1000', 0x1000),
    ('IMAGE_DLL_CHARACTERISTICS_WDM_DRIVER',    0x2000),
    ('IMAGE_DLL_CHARACTERISTICS_TERMINAL_SERVER_AWARE', 0x8000) ]

DLL_CHARACTERISTICS = dict([(e[1], e[0]) for e in dll_characteristics]+dll_characteristics)


# Resource types
resource_type = [
    ('RT_CURSOR',          1),
    ('RT_BITMAP',          2),
    ('RT_ICON',            3),
    ('RT_MENU',            4),
    ('RT_DIALOG',          5),
    ('RT_STRING',          6),
    ('RT_FONTDIR',         7),
    ('RT_FONT',            8),
    ('RT_ACCELERATOR',     9),
    ('RT_RCDATA',          10),
    ('RT_MESSAGETABLE',    11),
    ('RT_GROUP_CURSOR',    12),
    ('RT_GROUP_ICON',      14),
    ('RT_VERSION',         16),
    ('RT_DLGINCLUDE',      17),
    ('RT_PLUGPLAY',        19),
    ('RT_VXD',             20),
    ('RT_ANICURSOR',       21),
    ('RT_ANIICON',         22),
    ('RT_HTML',            23),
    ('RT_MANIFEST',        24) ]

RESOURCE_TYPE = dict([(e[1], e[0]) for e in resource_type]+resource_type)


# Language definitions
lang = [
 ('LANG_NEUTRAL',       0x00),
 ('LANG_INVARIANT',     0x7f),
 ('LANG_AFRIKAANS',     0x36),
 ('LANG_ALBANIAN',      0x1c),
 ('LANG_ARABIC',        0x01),
 ('LANG_ARMENIAN',      0x2b),
 ('LANG_ASSAMESE',      0x4d),
 ('LANG_AZERI',         0x2c),
 ('LANG_BASQUE',        0x2d),
 ('LANG_BELARUSIAN',    0x23),
 ('LANG_BENGALI',       0x45),
 ('LANG_BULGARIAN',     0x02),
 ('LANG_CATALAN',       0x03),
 ('LANG_CHINESE',       0x04),
 ('LANG_CROATIAN',      0x1a),
 ('LANG_CZECH',         0x05),
 ('LANG_DANISH',        0x06),
 ('LANG_DIVEHI',        0x65),
 ('LANG_DUTCH',         0x13),
 ('LANG_ENGLISH',       0x09),
 ('LANG_ESTONIAN',      0x25),
 ('LANG_FAEROESE',      0x38),
 ('LANG_FARSI',         0x29),
 ('LANG_FINNISH',       0x0b),
 ('LANG_FRENCH',        0x0c),
 ('LANG_GALICIAN',      0x56),
 ('LANG_GEORGIAN',      0x37),
 ('LANG_GERMAN',        0x07),
 ('LANG_GREEK',         0x08),
 ('LANG_GUJARATI',      0x47),
 ('LANG_HEBREW',        0x0d),
 ('LANG_HINDI',         0x39),
 ('LANG_HUNGARIAN',     0x0e),
 ('LANG_ICELANDIC',     0x0f),
 ('LANG_INDONESIAN',    0x21),
 ('LANG_ITALIAN',       0x10),
 ('LANG_JAPANESE',      0x11),
 ('LANG_KANNADA',       0x4b),
 ('LANG_KASHMIRI',      0x60),
 ('LANG_KAZAK',         0x3f),
 ('LANG_KONKANI',       0x57),
 ('LANG_KOREAN',        0x12),
 ('LANG_KYRGYZ',        0x40),
 ('LANG_LATVIAN',       0x26),
 ('LANG_LITHUANIAN',    0x27),
 ('LANG_MACEDONIAN',    0x2f),
 ('LANG_MALAY',         0x3e),
 ('LANG_MALAYALAM',     0x4c),
 ('LANG_MANIPURI',      0x58),
 ('LANG_MARATHI',       0x4e),
 ('LANG_MONGOLIAN',     0x50),
 ('LANG_NEPALI',        0x61),
 ('LANG_NORWEGIAN',     0x14),
 ('LANG_ORIYA',         0x48),
 ('LANG_POLISH',        0x15),
 ('LANG_PORTUGUESE',    0x16),
 ('LANG_PUNJABI',       0x46),
 ('LANG_ROMANIAN',      0x18),
 ('LANG_RUSSIAN',       0x19),
 ('LANG_SANSKRIT',      0x4f),
 ('LANG_SERBIAN',       0x1a),
 ('LANG_SINDHI',        0x59),
 ('LANG_SLOVAK',        0x1b),
 ('LANG_SLOVENIAN',     0x24),
 ('LANG_SPANISH',       0x0a),
 ('LANG_SWAHILI',       0x41),
 ('LANG_SWEDISH',       0x1d),
 ('LANG_SYRIAC',        0x5a),
 ('LANG_TAMIL',         0x49),
 ('LANG_TATAR',         0x44),
 ('LANG_TELUGU',        0x4a),
 ('LANG_THAI',          0x1e),
 ('LANG_TURKISH',       0x1f),
 ('LANG_UKRAINIAN',     0x22),
 ('LANG_URDU',          0x20),
 ('LANG_UZBEK',         0x43),
 ('LANG_VIETNAMESE',    0x2a),
 ('LANG_GAELIC',        0x3c),
 ('LANG_MALTESE',       0x3a),
 ('LANG_MAORI',         0x28),
 ('LANG_RHAETO_ROMANCE',0x17),
 ('LANG_SAAMI',         0x3b),
 ('LANG_SORBIAN',       0x2e),
 ('LANG_SUTU',          0x30),
 ('LANG_TSONGA',        0x31),
 ('LANG_TSWANA',        0x32),
 ('LANG_VENDA',         0x33),
 ('LANG_XHOSA',         0x34),
 ('LANG_ZULU',          0x35),
 ('LANG_ESPERANTO',     0x8f),
 ('LANG_WALON',         0x90),
 ('LANG_CORNISH',       0x91),
 ('LANG_WELSH',         0x92),
 ('LANG_BRETON',        0x93) ]

LANG = dict(lang+[(e[1], e[0]) for e in lang])


# Sublanguage definitions
sublang =  [
 ('SUBLANG_NEUTRAL',                        0x00),
 ('SUBLANG_DEFAULT',                        0x01),
 ('SUBLANG_SYS_DEFAULT',                    0x02),
 ('SUBLANG_ARABIC_SAUDI_ARABIA',            0x01),
 ('SUBLANG_ARABIC_IRAQ',                    0x02),
 ('SUBLANG_ARABIC_EGYPT',                   0x03),
 ('SUBLANG_ARABIC_LIBYA',                   0x04),
 ('SUBLANG_ARABIC_ALGERIA',                 0x05),
 ('SUBLANG_ARABIC_MOROCCO',                 0x06),
 ('SUBLANG_ARABIC_TUNISIA',                 0x07),
 ('SUBLANG_ARABIC_OMAN',                    0x08),
 ('SUBLANG_ARABIC_YEMEN',                   0x09),
 ('SUBLANG_ARABIC_SYRIA',                   0x0a),
 ('SUBLANG_ARABIC_JORDAN',                  0x0b),
 ('SUBLANG_ARABIC_LEBANON',                 0x0c),
 ('SUBLANG_ARABIC_KUWAIT',                  0x0d),
 ('SUBLANG_ARABIC_UAE',                     0x0e),
 ('SUBLANG_ARABIC_BAHRAIN',                 0x0f),
 ('SUBLANG_ARABIC_QATAR',                   0x10),
 ('SUBLANG_AZERI_LATIN',                    0x01),
 ('SUBLANG_AZERI_CYRILLIC',                 0x02),
 ('SUBLANG_CHINESE_TRADITIONAL',            0x01),
 ('SUBLANG_CHINESE_SIMPLIFIED',             0x02),
 ('SUBLANG_CHINESE_HONGKONG',               0x03),
 ('SUBLANG_CHINESE_SINGAPORE',              0x04),
 ('SUBLANG_CHINESE_MACAU',                  0x05),
 ('SUBLANG_DUTCH',                          0x01),
 ('SUBLANG_DUTCH_BELGIAN',                  0x02),
 ('SUBLANG_ENGLISH_US',                     0x01),
 ('SUBLANG_ENGLISH_UK',                     0x02),
 ('SUBLANG_ENGLISH_AUS',                    0x03),
 ('SUBLANG_ENGLISH_CAN',                    0x04),
 ('SUBLANG_ENGLISH_NZ',                     0x05),
 ('SUBLANG_ENGLISH_EIRE',                   0x06),
 ('SUBLANG_ENGLISH_SOUTH_AFRICA',           0x07),
 ('SUBLANG_ENGLISH_JAMAICA',                0x08),
 ('SUBLANG_ENGLISH_CARIBBEAN',              0x09),
 ('SUBLANG_ENGLISH_BELIZE',                 0x0a),
 ('SUBLANG_ENGLISH_TRINIDAD',               0x0b),
 ('SUBLANG_ENGLISH_ZIMBABWE',               0x0c),
 ('SUBLANG_ENGLISH_PHILIPPINES',            0x0d),
 ('SUBLANG_FRENCH',                         0x01),
 ('SUBLANG_FRENCH_BELGIAN',                 0x02),
 ('SUBLANG_FRENCH_CANADIAN',                0x03),
 ('SUBLANG_FRENCH_SWISS',                   0x04),
 ('SUBLANG_FRENCH_LUXEMBOURG',              0x05),
 ('SUBLANG_FRENCH_MONACO',                  0x06),
 ('SUBLANG_GERMAN',                         0x01),
 ('SUBLANG_GERMAN_SWISS',                   0x02),
 ('SUBLANG_GERMAN_AUSTRIAN',                0x03),
 ('SUBLANG_GERMAN_LUXEMBOURG',              0x04),
 ('SUBLANG_GERMAN_LIECHTENSTEIN',           0x05),
 ('SUBLANG_ITALIAN',                        0x01),
 ('SUBLANG_ITALIAN_SWISS',                  0x02),
 ('SUBLANG_KASHMIRI_SASIA',                 0x02),
 ('SUBLANG_KASHMIRI_INDIA',                 0x02),
 ('SUBLANG_KOREAN',                         0x01),
 ('SUBLANG_LITHUANIAN',                     0x01),
 ('SUBLANG_MALAY_MALAYSIA',                 0x01),
 ('SUBLANG_MALAY_BRUNEI_DARUSSALAM',        0x02),
 ('SUBLANG_NEPALI_INDIA',                   0x02),
 ('SUBLANG_NORWEGIAN_BOKMAL',               0x01),
 ('SUBLANG_NORWEGIAN_NYNORSK',              0x02),
 ('SUBLANG_PORTUGUESE',                     0x02),
 ('SUBLANG_PORTUGUESE_BRAZILIAN',           0x01),
 ('SUBLANG_SERBIAN_LATIN',                  0x02),
 ('SUBLANG_SERBIAN_CYRILLIC',               0x03),
 ('SUBLANG_SPANISH',                        0x01),
 ('SUBLANG_SPANISH_MEXICAN',                0x02),
 ('SUBLANG_SPANISH_MODERN',                 0x03),
 ('SUBLANG_SPANISH_GUATEMALA',              0x04),
 ('SUBLANG_SPANISH_COSTA_RICA',             0x05),
 ('SUBLANG_SPANISH_PANAMA',                 0x06),
 ('SUBLANG_SPANISH_DOMINICAN_REPUBLIC',     0x07),
 ('SUBLANG_SPANISH_VENEZUELA',              0x08),
 ('SUBLANG_SPANISH_COLOMBIA',               0x09),
 ('SUBLANG_SPANISH_PERU',                   0x0a),
 ('SUBLANG_SPANISH_ARGENTINA',              0x0b),
 ('SUBLANG_SPANISH_ECUADOR',                0x0c),
 ('SUBLANG_SPANISH_CHILE',                  0x0d),
 ('SUBLANG_SPANISH_URUGUAY',                0x0e),
 ('SUBLANG_SPANISH_PARAGUAY',               0x0f),
 ('SUBLANG_SPANISH_BOLIVIA',                0x10),
 ('SUBLANG_SPANISH_EL_SALVADOR',            0x11),
 ('SUBLANG_SPANISH_HONDURAS',               0x12),
 ('SUBLANG_SPANISH_NICARAGUA',              0x13),
 ('SUBLANG_SPANISH_PUERTO_RICO',            0x14),
 ('SUBLANG_SWEDISH',                        0x01),
 ('SUBLANG_SWEDISH_FINLAND',                0x02),
 ('SUBLANG_URDU_PAKISTAN',                  0x01),
 ('SUBLANG_URDU_INDIA',                     0x02),
 ('SUBLANG_UZBEK_LATIN',                    0x01),
 ('SUBLANG_UZBEK_CYRILLIC',                 0x02),
 ('SUBLANG_DUTCH_SURINAM',                  0x03),
 ('SUBLANG_ROMANIAN',                       0x01),
 ('SUBLANG_ROMANIAN_MOLDAVIA',              0x02),
 ('SUBLANG_RUSSIAN',                        0x01),
 ('SUBLANG_RUSSIAN_MOLDAVIA',               0x02),
 ('SUBLANG_CROATIAN',                       0x01),
 ('SUBLANG_LITHUANIAN_CLASSIC',             0x02),
 ('SUBLANG_GAELIC',                         0x01),
 ('SUBLANG_GAELIC_SCOTTISH',                0x02),
 ('SUBLANG_GAELIC_MANX',                    0x03) ]

SUBLANG = dict(sublang+[(e[1], e[0]) for e in sublang])


class UnicodeStringWrapperPostProcessor:
    """This class attemps to help the process of identifying strings
    that might be plain Unicode or Pascal. A list of strings will be
    wrapped on it with the hope the overlappings will help make the
    decission about their type."""

    def __init__(self, pe, rva_ptr):
        self.pe = pe
        self.rva_ptr = rva_ptr
        self.string = None


    def get_rva(self):
        """Get the RVA of the string."""

        return self.rva_ptr


    def __str__(self):
        """Return the escaped ASCII representation of the string."""

        def convert_char(char):
            if char in string.printable:
                return char
            else:
                return r'\x%02x' % ord(char)

        if self.string:
            return ''.join([convert_char(c) for c in self.string])

        return ''


    def invalidate(self):
        """Make this instance None, to express it's no known string type."""

        self = None


    def render_pascal_16(self):

        self.string = self.pe.get_string_u_at_rva(
            self.rva_ptr+2,
            max_length=self.__get_pascal_16_length())


    def ask_pascal_16(self, next_rva_ptr):
        """The next RVA is taken to be the one immediately following this one.

        Such RVA could indicate the natural end of the string and will be checked
        with the possible length contained in the first word.
        """

        length = self.__get_pascal_16_length()

        if length == (next_rva_ptr - (self.rva_ptr+2)) / 2:
            self.length = length
            return True

        return False


    def __get_pascal_16_length(self):

        return self.__get_word_value_at_rva(self.rva_ptr)


    def __get_word_value_at_rva(self, rva):

        try:
            data = self.pe.get_data(self.rva_ptr, 2)
        except PEFormatError, e:
            return False

        if len(data)<2:
            return False

        return struct.unpack('<H', data)[0]


    #def render_pascal_8(self):
    #    """"""


    def ask_unicode_16(self, next_rva_ptr):
        """The next RVA is taken to be the one immediately following this one.

        Such RVA could indicate the natural end of the string and will be checked
        to see if there's a Unicode NULL character there.
        """

        if self.__get_word_value_at_rva(next_rva_ptr-2) == 0:
            self.length = next_rva_ptr - self.rva_ptr
            return True

        return False


    def render_unicode_16(self):

        self.string = self.pe.get_string_u_at_rva(self.rva_ptr)


class PEFormatError(Exception):
    """Generic PE format error exception."""

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)

class Dump:
    """Convenience class for dumping the PE information."""

    def __init__(self):
        self.text = list()


    def add_lines(self, txt, indent=0):
        """Adds a list of lines.

        The list can be indented with the optional argument 'indent'.
        """
        for line in txt:
            self.add_line(line, indent)


    def add_line(self, txt, indent=0):
        """Adds a line.

        The line can be indented with the optional argument 'indent'.
        """

        self.add(txt+'\n', indent)


    def add(self, txt, indent=0):
        """Adds some text, no newline will be appended.

        The text can be indented with the optional argument 'indent'.
        """

        if isinstance(txt, unicode):
            try:
                txt = str(txt)
            except UnicodeEncodeError:
                s = []
                for c in txt:
                    try:
                        s.append(str(c))
                    except UnicodeEncodeError:
                        s.append(repr(c))

                txt = ''.join(s)

        self.text.append( ' '*indent + txt )


    def add_header(self, txt):
        """Adds a header element."""

        self.add_line('-'*10+txt+'-'*10+'\n')


    def add_newline(self):
        """Adds a newline."""

        self.text.append( '\n' )


    def get_text(self):
        """Get the text in its current state."""

        return ''.join( self.text )



class Structure:
    """Prepare structure object to extract members from data.

    Format is a list containing definitions for the elements
    of the structure.
    """


    def __init__(self, format, name=None, file_offset=None):
        # Format is forced little endian, for big endian non Intel platforms
        self.__format__ = '<'
        self.__keys__ = []
        #self.values = {}
        self.__format_length__ = 0
        self.__set_format__(format[1])
        self.__all_zeroes__ = False
        self.__unpacked_data_elms__ = None
        self.__file_offset__ = file_offset
        if name:
            self.name = name
        else:
            self.name = format[0]


    def __get_format__(self):
        return self.__format__


    def get_file_offset(self):
        return self.__file_offset__

    def set_file_offset(self, offset):
        self.__file_offset__ = offset

    def all_zeroes(self):
        """Returns true is the unpacked data is all zeroes."""

        return self.__all_zeroes__


    def __set_format__(self, format):

        for elm in format:
            if ',' in elm:
                elm_type, elm_name = elm.split(',', 1)
                self.__format__ += elm_type

                elm_names = elm_name.split(',')
                names = []
                for elm_name in elm_names:
                    if elm_name in self.__keys__:
                        search_list = [x[:len(elm_name)] for x in self.__keys__]
                        occ_count = search_list.count(elm_name)
                        elm_name = elm_name+'_'+str(occ_count)
                    names.append(elm_name)
                # Some PE header structures have unions on them, so a certain
                # value might have different names, so each key has a list of
                # all the possible members referring to the data.
                self.__keys__.append(names)

        self.__format_length__ = struct.calcsize(self.__format__)


    def sizeof(self):
        """Return size of the structure."""

        return self.__format_length__


    def __unpack__(self, data):

        if len(data) > self.__format_length__:
            data = data[:self.__format_length__]

        # OC Patch:
        # Some malware have incorrect header lengths.
        # Fail gracefully if this occurs
        # Buggy malware: a29b0118af8b7408444df81701ad5a7f
        #
        elif len(data)<self.__format_length__:
            raise PEFormatError('Data length less than expected header length.')


        if data.count(chr(0)) == len(data):
            self.__all_zeroes__ = True

        self.__unpacked_data_elms__ = struct.unpack(self.__format__, data)
        for i in xrange(len(self.__unpacked_data_elms__)):
            for key in self.__keys__[i]:
                #self.values[key] = self.__unpacked_data_elms__[i]
                setattr(self, key, self.__unpacked_data_elms__[i])


    def __pack__(self):

        new_values = []

        for i in xrange(len(self.__unpacked_data_elms__)):

            for key in self.__keys__[i]:
                new_val = getattr(self, key)
                old_val = self.__unpacked_data_elms__[i]

                # In the case of Unions, when the first changed value
                # is picked the loop is exited
                if new_val != old_val:
                    break

            new_values.append(new_val)

        return struct.pack(self.__format__, *new_values)


    def __str__(self):
        return '\n'.join( self.dump() )

    def __repr__(self):
        return '<Structure: %s>' % (' '.join( [' '.join(s.split()) for s in self.dump()] ))


    def dump(self, indentation=0):
        """Returns a string representation of the structure."""

        dump = []

        dump.append('[%s]' % self.name)

        # Refer to the __set_format__ method for an explanation
        # of the following construct.
        for keys in self.__keys__:
            for key in keys:

                val = getattr(self, key)
                if isinstance(val, int) or isinstance(val, long):
                    val_str = '0x%-8X' % (val)
                    if key == 'TimeDateStamp' or key == 'dwTimeStamp':
                        try:
                            val_str += ' [%s UTC]' % time.asctime(time.gmtime(val))
                        except exceptions.ValueError, e:
                            val_str += ' [INVALID TIME]'
                else:
                    val_str = ''.join(filter(lambda c:c != '\0', str(val)))

                dump.append('%-30s %s' % (key+':', val_str))

        return dump



class SectionStructure(Structure):
    """Convenience section handling class."""

    def get_data(self, start, length=None):
        """Get data chunk from a section.

        Allows to query data from the section by passing the
        addresses where the PE file would be loaded by default.
        It is then possible to retrieve code and data by its real
        addresses as it would be if loaded.
        """

        offset = start - self.VirtualAddress

        if length:
            end = offset+length
        else:
            end = len(self.data)

        return self.data[offset:end]


    def get_rva_from_offset(self, offset):
        return offset - self.PointerToRawData + self.VirtualAddress


    def get_offset_from_rva(self, rva):
        return (rva - self.VirtualAddress) + self.PointerToRawData


    def contains_offset(self, offset):
        """Check whether the section contains the file offset provided."""

        if not self.PointerToRawData:
            # bss and other sections containing only uninitialized data must have 0
            # and do not take space in the file
            return False

        return self.PointerToRawData <= offset < self.PointerToRawData + self.SizeOfRawData


    def contains_rva(self, rva):
        """Check whether the section contains the address provided."""

        # PECOFF documentation v8 says:
        # The total size of the section when loaded into memory.
        # If this value is greater than SizeOfRawData, the section is zero-padded.
        # This field is valid only for executable images and should be set to zero
        # for object files.

        if len(self.data) < self.SizeOfRawData:
            size = self.Misc_VirtualSize
        else:
            size = max(self.SizeOfRawData, self.Misc_VirtualSize)

        return self.VirtualAddress <= rva < self.VirtualAddress + size

    def contains(self, rva):
        #print "DEPRECATION WARNING: you should use contains_rva() instead of contains()"
        return self.contains_rva(rva)


    def set_data(self, data):
        """Set the data belonging to the section."""

        self.data = data


    def get_entropy(self):
        """Calculate and return the entropy for the section."""

        return self.entropy_H( self.data )


    def get_hash_sha1(self):
        """Get the SHA-1 hex-digest of the section's data."""

        if sha1 is not None:
            return sha1( self.data ).hexdigest()


    def get_hash_sha256(self):
        """Get the SHA-256 hex-digest of the section's data."""

        if sha256 is not None:
            return sha256( self.data ).hexdigest()


    def get_hash_sha512(self):
        """Get the SHA-512 hex-digest of the section's data."""

        if sha512 is not None:
            return sha512( self.data ).hexdigest()


    def get_hash_md5(self):
        """Get the MD5 hex-digest of the section's data."""

        if md5 is not None:
            return md5( self.data ).hexdigest()


    def entropy_H(self, data):
        """Calculate the entropy of a chunk of data."""

        if len(data) == 0:
            return 0.0

        occurences = array.array('L', [0]*256)

        for x in data:
            occurences[ord(x)] += 1

        entropy = 0
        for x in occurences:
            if x:
                p_x = float(x) / len(data)
                entropy -= p_x*math.log(p_x, 2)

        return entropy



class DataContainer:
    """Generic data container."""

    def __init__(self, **args):
        for key, value in args.items():
            setattr(self, key, value)



class ImportDescData(DataContainer):
    """Holds import descriptor information.

    dll:        name of the imported DLL
    imports:    list of imported symbols (ImportData instances)
    struct:     IMAGE_IMPORT_DESCRIPTOR sctruture
    """

class ImportData(DataContainer):
    """Holds imported symbol's information.

    ordinal:    Ordinal of the symbol
    name:       Name of the symbol
    bound:      If the symbol is bound, this contains
                the address.
    """

class ExportDirData(DataContainer):
    """Holds export directory information.

    struct:     IMAGE_EXPORT_DIRECTORY structure
    symbols:    list of exported symbols (ExportData instances)
"""

class ExportData(DataContainer):
    """Holds exported symbols' information.

    ordinal:    ordinal of the symbol
    address:    address of the symbol
    name:       name of the symbol (None if the symbol is
                exported by ordinal only)
    forwarder:  if the symbol is forwarded it will
                contain the name of the target symbol,
                None otherwise.
    """


class ResourceDirData(DataContainer):
    """Holds resource directory information.

    struct:     IMAGE_RESOURCE_DIRECTORY structure
    entries:    list of entries (ResourceDirEntryData instances)
    """

class ResourceDirEntryData(DataContainer):
    """Holds resource directory entry data.

    struct:     IMAGE_RESOURCE_DIRECTORY_ENTRY structure
    name:       If the resource is identified by name this
                attribute will contain the name string. None
                otherwise. If identified by id, the id is
                availabe at 'struct.Id'
    id:         the id, also in struct.Id
    directory:  If this entry has a lower level directory
                this attribute will point to the
                ResourceDirData instance representing it.
    data:       If this entry has no futher lower directories
                and points to the actual resource data, this
                attribute will reference the corresponding
                ResourceDataEntryData instance.
    (Either of the 'directory' or 'data' attribute will exist,
    but not both.)
    """

class ResourceDataEntryData(DataContainer):
    """Holds resource data entry information.

    struct:     IMAGE_RESOURCE_DATA_ENTRY structure
    lang:       Primary language ID
    sublang:    Sublanguage ID
    """

class DebugData(DataContainer):
    """Holds debug information.

    struct:     IMAGE_DEBUG_DIRECTORY structure
    """

class BaseRelocationData(DataContainer):
    """Holds base relocation information.

    struct:     IMAGE_BASE_RELOCATION structure
    entries:    list of relocation data (RelocationData instances)
    """

class RelocationData(DataContainer):
    """Holds relocation information.

    type:       Type of relocation
                The type string is can be obtained by
                RELOCATION_TYPE[type]
    rva:        RVA of the relocation
    """

class TlsData(DataContainer):
    """Holds TLS information.

    struct:     IMAGE_TLS_DIRECTORY structure
    """

class BoundImportDescData(DataContainer):
    """Holds bound import descriptor data.

    This directory entry will provide with information on the
    DLLs this PE files has been bound to (if bound at all).
    The structure will contain the name and timestamp of the
    DLL at the time of binding so that the loader can know
    whether it differs from the one currently present in the
    system and must, therefore, re-bind the PEs imports.

    struct:     IMAGE_BOUND_IMPORT_DESCRIPTOR structure
    name:       DLL name
    entries:    list of entries (BoundImportRefData instances)
                the entries will exist if this DLL has forwarded
                symbols. If so, the destination DLL will have an
                entry in this list.
    """

class LoadConfigData(DataContainer):
    """Holds Load Config data.

    struct:     IMAGE_LOAD_CONFIG_DIRECTORY structure
    name:       dll name
    """

class BoundImportRefData(DataContainer):
    """Holds bound import forwader reference data.

    Contains the same information as the bound descriptor but
    for forwarded DLLs, if any.

    struct:     IMAGE_BOUND_FORWARDER_REF structure
    name:       dll name
    """


class PE:
    """A Portable Executable representation.

    This class provides access to most of the information in a PE file.

    It expects to be supplied the name of the file to load or PE data
    to process and an optional argument 'fast_load' (False by default)
    which controls whether to load all the directories information,
    which can be quite time consuming.

    pe = pefile.PE('module.dll')
    pe = pefile.PE(name='module.dll')

    would load 'module.dll' and process it. If the data would be already
    available in a buffer the same could be achieved with:

    pe = pefile.PE(data=module_dll_data)

    The "fast_load" can be set to a default by setting its value in the
    module itself by means,for instance, of a "pefile.fast_load = True".
    That will make all the subsequent instances not to load the
    whole PE structure. The "full_load" method can be used to parse
    the missing data at a later stage.

    Basic headers information will be available in the attributes:

    DOS_HEADER
    NT_HEADERS
    FILE_HEADER
    OPTIONAL_HEADER

    All of them will contain among their attrbitues the members of the
    corresponding structures as defined in WINNT.H

    The raw data corresponding to the header (from the beginning of the
    file up to the start of the first section) will be avaiable in the
    instance's attribute 'header' as a string.

    The sections will be available as a list in the 'sections' attribute.
    Each entry will contain as attributes all the structure's members.

    Directory entries will be available as attributes (if they exist):
    (no other entries are processed at this point)

    DIRECTORY_ENTRY_IMPORT (list of ImportDescData instances)
    DIRECTORY_ENTRY_EXPORT (ExportDirData instance)
    DIRECTORY_ENTRY_RESOURCE (ResourceDirData instance)
    DIRECTORY_ENTRY_DEBUG (list of DebugData instances)
    DIRECTORY_ENTRY_BASERELOC (list of BaseRelocationData instances)
    DIRECTORY_ENTRY_TLS
    DIRECTORY_ENTRY_BOUND_IMPORT (list of BoundImportData instances)

    The following dictionary attributes provide ways of mapping different
    constants. They will accept the numeric value and return the string
    representation and the opposite, feed in the string and get the
    numeric constant:

    DIRECTORY_ENTRY
    IMAGE_CHARACTERISTICS
    SECTION_CHARACTERISTICS
    DEBUG_TYPE
    SUBSYSTEM_TYPE
    MACHINE_TYPE
    RELOCATION_TYPE
    RESOURCE_TYPE
    LANG
    SUBLANG
    """

    #
    # Format specifications for PE structures.
    #

    __IMAGE_DOS_HEADER_format__ = ('IMAGE_DOS_HEADER',
        ('H,e_magic', 'H,e_cblp', 'H,e_cp',
        'H,e_crlc', 'H,e_cparhdr', 'H,e_minalloc',
        'H,e_maxalloc', 'H,e_ss', 'H,e_sp', 'H,e_csum',
        'H,e_ip', 'H,e_cs', 'H,e_lfarlc', 'H,e_ovno', '8s,e_res',
        'H,e_oemid', 'H,e_oeminfo', '20s,e_res2',
        'I,e_lfanew'))

    __IMAGE_FILE_HEADER_format__ = ('IMAGE_FILE_HEADER',
        ('H,Machine', 'H,NumberOfSections',
        'I,TimeDateStamp', 'I,PointerToSymbolTable',
        'I,NumberOfSymbols', 'H,SizeOfOptionalHeader',
        'H,Characteristics'))

    __IMAGE_DATA_DIRECTORY_format__ = ('IMAGE_DATA_DIRECTORY',
        ('I,VirtualAddress', 'I,Size'))


    __IMAGE_OPTIONAL_HEADER_format__ = ('IMAGE_OPTIONAL_HEADER',
        ('H,Magic', 'B,MajorLinkerVersion',
        'B,MinorLinkerVersion', 'I,SizeOfCode',
        'I,SizeOfInitializedData', 'I,SizeOfUninitializedData',
        'I,AddressOfEntryPoint', 'I,BaseOfCode', 'I,BaseOfData',
        'I,ImageBase', 'I,SectionAlignment', 'I,FileAlignment',
        'H,MajorOperatingSystemVersion', 'H,MinorOperatingSystemVersion',
        'H,MajorImageVersion', 'H,MinorImageVersion',
        'H,MajorSubsystemVersion', 'H,MinorSubsystemVersion',
        'I,Reserved1', 'I,SizeOfImage', 'I,SizeOfHeaders',
        'I,CheckSum', 'H,Subsystem', 'H,DllCharacteristics',
        'I,SizeOfStackReserve', 'I,SizeOfStackCommit',
        'I,SizeOfHeapReserve', 'I,SizeOfHeapCommit',
        'I,LoaderFlags', 'I,NumberOfRvaAndSizes' ))


    __IMAGE_OPTIONAL_HEADER64_format__ = ('IMAGE_OPTIONAL_HEADER64',
        ('H,Magic', 'B,MajorLinkerVersion',
        'B,MinorLinkerVersion', 'I,SizeOfCode',
        'I,SizeOfInitializedData', 'I,SizeOfUninitializedData',
        'I,AddressOfEntryPoint', 'I,BaseOfCode',
        'Q,ImageBase', 'I,SectionAlignment', 'I,FileAlignment',
        'H,MajorOperatingSystemVersion', 'H,MinorOperatingSystemVersion',
        'H,MajorImageVersion', 'H,MinorImageVersion',
        'H,MajorSubsystemVersion', 'H,MinorSubsystemVersion',
        'I,Reserved1', 'I,SizeOfImage', 'I,SizeOfHeaders',
        'I,CheckSum', 'H,Subsystem', 'H,DllCharacteristics',
        'Q,SizeOfStackReserve', 'Q,SizeOfStackCommit',
        'Q,SizeOfHeapReserve', 'Q,SizeOfHeapCommit',
        'I,LoaderFlags', 'I,NumberOfRvaAndSizes' ))


    __IMAGE_NT_HEADERS_format__ = ('IMAGE_NT_HEADERS', ('I,Signature',))

    __IMAGE_SECTION_HEADER_format__ = ('IMAGE_SECTION_HEADER',
        ('8s,Name', 'I,Misc,Misc_PhysicalAddress,Misc_VirtualSize',
        'I,VirtualAddress', 'I,SizeOfRawData', 'I,PointerToRawData',
        'I,PointerToRelocations', 'I,PointerToLinenumbers',
        'H,NumberOfRelocations', 'H,NumberOfLinenumbers',
        'I,Characteristics'))

    __IMAGE_DELAY_IMPORT_DESCRIPTOR_format__ = ('IMAGE_DELAY_IMPORT_DESCRIPTOR',
        ('I,grAttrs', 'I,szName', 'I,phmod', 'I,pIAT', 'I,pINT',
        'I,pBoundIAT', 'I,pUnloadIAT', 'I,dwTimeStamp'))

    __IMAGE_IMPORT_DESCRIPTOR_format__ =  ('IMAGE_IMPORT_DESCRIPTOR',
        ('I,OriginalFirstThunk,Characteristics',
        'I,TimeDateStamp', 'I,ForwarderChain', 'I,Name', 'I,FirstThunk'))

    __IMAGE_EXPORT_DIRECTORY_format__ =  ('IMAGE_EXPORT_DIRECTORY',
        ('I,Characteristics',
        'I,TimeDateStamp', 'H,MajorVersion', 'H,MinorVersion', 'I,Name',
        'I,Base', 'I,NumberOfFunctions', 'I,NumberOfNames',
        'I,AddressOfFunctions', 'I,AddressOfNames', 'I,AddressOfNameOrdinals'))

    __IMAGE_RESOURCE_DIRECTORY_format__ = ('IMAGE_RESOURCE_DIRECTORY',
        ('I,Characteristics',
        'I,TimeDateStamp', 'H,MajorVersion', 'H,MinorVersion',
        'H,NumberOfNamedEntries', 'H,NumberOfIdEntries'))

    __IMAGE_RESOURCE_DIRECTORY_ENTRY_format__ = ('IMAGE_RESOURCE_DIRECTORY_ENTRY',
        ('I,Name',
        'I,OffsetToData'))

    __IMAGE_RESOURCE_DATA_ENTRY_format__ = ('IMAGE_RESOURCE_DATA_ENTRY',
        ('I,OffsetToData', 'I,Size', 'I,CodePage', 'I,Reserved'))

    __VS_VERSIONINFO_format__ = ( 'VS_VERSIONINFO',
        ('H,Length', 'H,ValueLength', 'H,Type' ))

    __VS_FIXEDFILEINFO_format__ = ( 'VS_FIXEDFILEINFO',
        ('I,Signature', 'I,StrucVersion', 'I,FileVersionMS', 'I,FileVersionLS',
         'I,ProductVersionMS', 'I,ProductVersionLS', 'I,FileFlagsMask', 'I,FileFlags',
         'I,FileOS', 'I,FileType', 'I,FileSubtype', 'I,FileDateMS', 'I,FileDateLS'))

    __StringFileInfo_format__ = ( 'StringFileInfo',
        ('H,Length', 'H,ValueLength', 'H,Type' ))

    __StringTable_format__ = ( 'StringTable',
        ('H,Length', 'H,ValueLength', 'H,Type' ))

    __String_format__ = ( 'String',
        ('H,Length', 'H,ValueLength', 'H,Type' ))

    __Var_format__ = ( 'Var', ('H,Length', 'H,ValueLength', 'H,Type' ))

    __IMAGE_THUNK_DATA_format__ = ('IMAGE_THUNK_DATA',
        ('I,ForwarderString,Function,Ordinal,AddressOfData',))

    __IMAGE_THUNK_DATA64_format__ = ('IMAGE_THUNK_DATA',
        ('Q,ForwarderString,Function,Ordinal,AddressOfData',))

    __IMAGE_DEBUG_DIRECTORY_format__ = ('IMAGE_DEBUG_DIRECTORY',
        ('I,Characteristics', 'I,TimeDateStamp', 'H,MajorVersion',
        'H,MinorVersion', 'I,Type', 'I,SizeOfData', 'I,AddressOfRawData',
        'I,PointerToRawData'))

    __IMAGE_BASE_RELOCATION_format__ = ('IMAGE_BASE_RELOCATION',
        ('I,VirtualAddress', 'I,SizeOfBlock') )

    __IMAGE_TLS_DIRECTORY_format__ = ('IMAGE_TLS_DIRECTORY',
        ('I,StartAddressOfRawData', 'I,EndAddressOfRawData',
        'I,AddressOfIndex', 'I,AddressOfCallBacks',
        'I,SizeOfZeroFill', 'I,Characteristics' ) )

    __IMAGE_TLS_DIRECTORY64_format__ = ('IMAGE_TLS_DIRECTORY',
        ('Q,StartAddressOfRawData', 'Q,EndAddressOfRawData',
        'Q,AddressOfIndex', 'Q,AddressOfCallBacks',
        'I,SizeOfZeroFill', 'I,Characteristics' ) )

    __IMAGE_LOAD_CONFIG_DIRECTORY_format__ = ('IMAGE_LOAD_CONFIG_DIRECTORY',
        ('I,Size', 'I,TimeDateStamp',
        'H,MajorVersion', 'H,MinorVersion',
        'I,GlobalFlagsClear', 'I,GlobalFlagsSet',
        'I,CriticalSectionDefaultTimeout',
        'I,DeCommitFreeBlockThreshold',
        'I,DeCommitTotalFreeThreshold',
        'I,LockPrefixTable',
        'I,MaximumAllocationSize',
        'I,VirtualMemoryThreshold',
        'I,ProcessHeapFlags',
        'I,ProcessAffinityMask',
        'H,CSDVersion', 'H,Reserved1',
        'I,EditList', 'I,SecurityCookie',
        'I,SEHandlerTable', 'I,SEHandlerCount' ) )

    __IMAGE_LOAD_CONFIG_DIRECTORY64_format__ = ('IMAGE_LOAD_CONFIG_DIRECTORY',
        ('I,Size', 'I,TimeDateStamp',
      'H,MajorVersion', 'H,MinorVersion',
      'I,GlobalFlagsClear', 'I,GlobalFlagsSet',
      'I,CriticalSectionDefaultTimeout',
      'Q,DeCommitFreeBlockThreshold',
      'Q,DeCommitTotalFreeThreshold',
      'Q,LockPrefixTable',
      'Q,MaximumAllocationSize',
      'Q,VirtualMemoryThreshold',
      'Q,ProcessAffinityMask',
      'I,ProcessHeapFlags',
      'H,CSDVersion', 'H,Reserved1',
      'Q,EditList', 'Q,SecurityCookie',
      'Q,SEHandlerTable', 'Q,SEHandlerCount' ) )

    __IMAGE_BOUND_IMPORT_DESCRIPTOR_format__ = ('IMAGE_BOUND_IMPORT_DESCRIPTOR',
        ('I,TimeDateStamp', 'H,OffsetModuleName', 'H,NumberOfModuleForwarderRefs'))

    __IMAGE_BOUND_FORWARDER_REF_format__ = ('IMAGE_BOUND_FORWARDER_REF',
        ('I,TimeDateStamp', 'H,OffsetModuleName', 'H,Reserved') )


    def __init__(self, name=None, data=None, fast_load=None):

        self.sections = []

        self.__warnings = []

        self.PE_TYPE = None

        if  not name and not data:
            return

        # This list will keep track of all the structures created.
        # That will allow for an easy iteration through the list
        # in order to save the modifications made
        self.__structures__ = []

        if not fast_load:
            fast_load = globals()['fast_load']
        self.__parse__(name, data, fast_load)


    def __unpack_data__(self, format, data, file_offset):
        """Apply structure format to raw data.

        Returns and unpacked structure object if successful, None otherwise.
        """

        structure = Structure(format, file_offset=file_offset)
        #if len(data) < structure.sizeof():
        #    return None

        try:
            structure.__unpack__(data)
        except PEFormatError, err:
            self.__warnings.append(
                'Corrupt header "%s" at file offset %d. Exception: %s' % (
                    format[0], file_offset, str(err))  )
            return None

        self.__structures__.append(structure)

        return structure


    def __parse__(self, fname, data, fast_load):
        """Parse a Portable Executable file.

        Loads a PE file, parsing all its structures and making them available
        through the instance's attributes.
        """

        if fname:
            fd = file(fname, 'rb')
            self.__data__ = fd.read()
            fd.close()
        elif data:
            self.__data__ = data


        self.DOS_HEADER = self.__unpack_data__(
            self.__IMAGE_DOS_HEADER_format__,
            self.__data__, file_offset=0)

        if not self.DOS_HEADER or self.DOS_HEADER.e_magic != IMAGE_DOS_SIGNATURE:
            raise PEFormatError('DOS Header magic not found.')

        # OC Patch:
        # Check for sane value in e_lfanew
        #
        if self.DOS_HEADER.e_lfanew > len(self.__data__):
            raise PEFormatError('Invalid e_lfanew value, probably not a PE file')

        nt_headers_offset = self.DOS_HEADER.e_lfanew

        self.NT_HEADERS = self.__unpack_data__(
            self.__IMAGE_NT_HEADERS_format__,
            self.__data__[nt_headers_offset:],
            file_offset = nt_headers_offset)

        # We better check the signature right here, before the file screws
        # around with sections:
        # OC Patch:
        # Some malware will cause the Signature value to not exist at all
        if not self.NT_HEADERS or not self.NT_HEADERS.Signature:
            raise PEFormatError('NT Headers not found.')

        if self.NT_HEADERS.Signature != IMAGE_NT_SIGNATURE:
            raise PEFormatError('Invalid NT Headers signature.')

        self.FILE_HEADER = self.__unpack_data__(
            self.__IMAGE_FILE_HEADER_format__,
            self.__data__[nt_headers_offset+4:],
            file_offset = nt_headers_offset+4)
        image_flags = self.retrieve_flags(IMAGE_CHARACTERISTICS, 'IMAGE_FILE_')

        if not self.FILE_HEADER:
            raise PEFormatError('File Header missing')

        # Set the image's flags according the the Characteristics member
        self.set_flags(self.FILE_HEADER, self.FILE_HEADER.Characteristics, image_flags)

        optional_header_offset =    \
            nt_headers_offset+4+self.FILE_HEADER.sizeof()

        # Note: location of sections can be controlled from PE header:
        sections_offset = optional_header_offset + self.FILE_HEADER.SizeOfOptionalHeader

        self.OPTIONAL_HEADER = self.__unpack_data__(
            self.__IMAGE_OPTIONAL_HEADER_format__,
            self.__data__[optional_header_offset:],
            file_offset = optional_header_offset)

        # According to solardesigner's findings for his
        # Tiny PE project, the optional header does not
        # need fields beyond "Subsystem" in order to be
        # loadable by the Windows loader (given that zeroes
        # are acceptable values and the header is loaded
        # in a zeroed memory page)
        # If trying to parse a full Optional Header fails
        # we try to parse it again with some 0 padding
        #
        MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE = 69

        if ( self.OPTIONAL_HEADER is None and
            len(self.__data__[optional_header_offset:])
                >= MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE ):

            # Add enough zeroes to make up for the unused fields
            #
            padding_length = 128

            # Create padding
            #
            padded_data = self.__data__[optional_header_offset:] + (
                '\0' * padding_length)

            self.OPTIONAL_HEADER = self.__unpack_data__(
                self.__IMAGE_OPTIONAL_HEADER_format__,
                padded_data,
                file_offset = optional_header_offset)


        # Check the Magic in the OPTIONAL_HEADER and set the PE file
        # type accordingly
        #
        if self.OPTIONAL_HEADER is not None:

            if self.OPTIONAL_HEADER.Magic == OPTIONAL_HEADER_MAGIC_PE:

                self.PE_TYPE = OPTIONAL_HEADER_MAGIC_PE

            elif self.OPTIONAL_HEADER.Magic == OPTIONAL_HEADER_MAGIC_PE_PLUS:

                self.PE_TYPE = OPTIONAL_HEADER_MAGIC_PE_PLUS

                self.OPTIONAL_HEADER = self.__unpack_data__(
                    self.__IMAGE_OPTIONAL_HEADER64_format__,
                    self.__data__[optional_header_offset:],
                    file_offset = optional_header_offset)

                # Again, as explained above, we try to parse
                # a reduced form of the Optional Header which
                # is still valid despite not including all
                # structure members
                #
                MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE = 69+4

                if ( self.OPTIONAL_HEADER is None and
                    len(self.__data__[optional_header_offset:])
                        >= MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE ):

                    padding_length = 128
                    padded_data = self.__data__[optional_header_offset:] + (
                        '\0' * padding_length)
                    self.OPTIONAL_HEADER = self.__unpack_data__(
                        self.__IMAGE_OPTIONAL_HEADER64_format__,
                        padded_data,
                        file_offset = optional_header_offset)


        if not self.FILE_HEADER:
            raise PEFormatError('File Header missing')


        # OC Patch:
        # Die gracefully if there is no OPTIONAL_HEADER field
        # 975440f5ad5e2e4a92c4d9a5f22f75c1
        if self.PE_TYPE is None or self.OPTIONAL_HEADER is None:
            raise PEFormatError("No Optional Header found, invalid PE32 or PE32+ file")

        dll_characteristics_flags = self.retrieve_flags(DLL_CHARACTERISTICS, 'IMAGE_DLL_CHARACTERISTICS_')

        # Set the Dll Characteristics flags according the the DllCharacteristics member
        self.set_flags(
            self.OPTIONAL_HEADER,
            self.OPTIONAL_HEADER.DllCharacteristics,
            dll_characteristics_flags)


        self.OPTIONAL_HEADER.DATA_DIRECTORY = []
        #offset = (optional_header_offset + self.FILE_HEADER.SizeOfOptionalHeader)
        offset = (optional_header_offset + self.OPTIONAL_HEADER.sizeof())


        self.NT_HEADERS.FILE_HEADER = self.FILE_HEADER
        self.NT_HEADERS.OPTIONAL_HEADER = self.OPTIONAL_HEADER


        # The NumberOfRvaAndSizes is sanitized to stay within
        # reasonable limits so can be casted to an int
        #
        if self.OPTIONAL_HEADER.NumberOfRvaAndSizes > 0x10:
            self.__warnings.append(
                'Suspicious NumberOfRvaAndSizes in the Optional Header. ' +
                'Normal values are never larger than 0x10, the value is: 0x%x' %
                self.OPTIONAL_HEADER.NumberOfRvaAndSizes )

        for i in xrange(int(0x7fffffffL & self.OPTIONAL_HEADER.NumberOfRvaAndSizes)):

            if len(self.__data__[offset:]) == 0:
                break

            if len(self.__data__[offset:]) < 8:
                data = self.__data__[offset:]+'\0'*8
            else:
                data = self.__data__[offset:]

            dir_entry = self.__unpack_data__(
                self.__IMAGE_DATA_DIRECTORY_format__,
                data,
                file_offset = offset)

            if dir_entry is None:
                break

            # Would fail if missing an entry
            # 1d4937b2fa4d84ad1bce0309857e70ca offending sample
            try:
                dir_entry.name = DIRECTORY_ENTRY[i]
            except (KeyError, AttributeError):
                break

            offset += dir_entry.sizeof()

            self.OPTIONAL_HEADER.DATA_DIRECTORY.append(dir_entry)

            # If the offset goes outside the optional header,
            # the loop is broken, regardless of how many directories
            # NumberOfRvaAndSizes says there are
            #
            # We assume a normally sized optional header, hence that we do
            # a sizeof() instead of reading SizeOfOptionalHeader.
            # Then we add a default number of drectories times their size,
            # if we go beyond that, we assume the number of directories
            # is wrong and stop processing
            if offset >= (optional_header_offset +
                self.OPTIONAL_HEADER.sizeof() + 8*16) :

                break


        offset = self.parse_sections(sections_offset)

        # OC Patch:
        # There could be a problem if there are no raw data sections
        # greater than 0
        # fc91013eb72529da005110a3403541b6 example
        # Should this throw an exception in the minimum header offset
        # can't be found?
        #
        rawDataPointers = [
            s.PointerToRawData for s in self.sections if s.PointerToRawData>0]

        if len(rawDataPointers) > 0:
            lowest_section_offset = min(rawDataPointers)
        else:
            lowest_section_offset = None

        if not lowest_section_offset or lowest_section_offset<offset:
            self.header = self.__data__[:offset]
        else:
            self.header = self.__data__[:lowest_section_offset]


        # Check whether the entry point lies within a section
        #
        if self.get_section_by_rva(self.OPTIONAL_HEADER.AddressOfEntryPoint) is not None:

            # Check whether the entry point lies within the file
            #
            ep_offset = self.get_offset_from_rva(self.OPTIONAL_HEADER.AddressOfEntryPoint)
            if ep_offset > len(self.__data__):

                self.__warnings.append(
                    'Possibly corrupt file. AddressOfEntryPoint lies outside the file. ' +
                    'AddressOfEntryPoint: 0x%x' %
                    self.OPTIONAL_HEADER.AddressOfEntryPoint )

        else:

            self.__warnings.append(
                'AddressOfEntryPoint lies outside the sections\' boundaries. ' +
                'AddressOfEntryPoint: 0x%x' %
                self.OPTIONAL_HEADER.AddressOfEntryPoint )


        if not fast_load:
            self.parse_data_directories()


    def get_warnings(self):
        """Return the list of warnings.

        Non-critical problems found when parsing the PE file are
        appended to a list of warnings. This method returns the
        full list.
        """

        return self.__warnings


    def show_warnings(self):
        """Print the list of warnings.

        Non-critical problems found when parsing the PE file are
        appended to a list of warnings. This method prints the
        full list to standard output.
        """

        for warning in self.__warnings:
            print '>', warning


    def full_load(self):
        """Process the data directories.

        This mathod will load the data directories which might not have
        been loaded if the "fast_load" option was used.
        """

        self.parse_data_directories()


    def write(self, filename=None):
        """Write the PE file.

        This function will process all headers and components
        of the PE file and include all changes made (by just
        assigning to attributes in the PE objects) and write
        the changes back to a file whose name is provided as
        an argument. The filename is optional, if not
        provided the data will be returned as a 'str' object.
        """

        file_data = list(self.__data__)
        for structure in self.__structures__:

            struct_data = list(structure.__pack__())
            offset = structure.get_file_offset()

            file_data[offset:offset+len(struct_data)] = struct_data

        if hasattr(self, 'VS_VERSIONINFO'):
            if hasattr(self, 'FileInfo'):
                for entry in self.FileInfo:
                    if hasattr(entry, 'StringTable'):
                        for st_entry in entry.StringTable:
                            for key, entry in st_entry.entries.items():

                                offsets = st_entry.entries_offsets[key]
                                lengths = st_entry.entries_lengths[key]

                                if len( entry ) > lengths[1]:

                                    l = list()
                                    for idx, c in enumerate(entry):
                                        if ord(c) > 256:
                                            l.extend( [ chr(ord(c) & 0xff), chr( (ord(c) & 0xff00) >>8) ]  )
                                        else:
                                            l.extend( [chr( ord(c) ), '\0'] )

                                    file_data[
                                        offsets[1] : offsets[1] + lengths[1]*2 ] = l

                                else:

                                    l = list()
                                    for idx, c in enumerate(entry):
                                        if ord(c) > 256:
                                            l.extend( [ chr(ord(c) & 0xff), chr( (ord(c) & 0xff00) >>8) ]  )
                                        else:
                                            l.extend( [chr( ord(c) ), '\0'] )

                                    file_data[
                                        offsets[1] : offsets[1] + len(entry)*2 ] = l

                                    remainder = lengths[1] - len(entry)
                                    file_data[
                                        offsets[1] + len(entry)*2 :
                                        offsets[1] + lengths[1]*2 ] = [
                                            u'\0' ] * remainder*2

        new_file_data = ''.join( [ chr(ord(c)) for c in file_data] )

        if filename:
            f = file(filename, 'wb+')
            f.write(new_file_data)
            f.close()
        else:
            return new_file_data


    def parse_sections(self, offset):
        """Fetch the PE file sections.

        The sections will be readily available in the "sections" attribute.
        Its attributes will contain all the section information plus "data"
        a buffer containing the section's data.

        The "Characteristics" member will be processed and attributes
        representing the section characteristics (with the 'IMAGE_SCN_'
        string trimmed from the constant's names) will be added to the
        section instance.

        Refer to the SectionStructure class for additional info.
        """

        self.sections = []

        for i in xrange(self.FILE_HEADER.NumberOfSections):
            section = SectionStructure(self.__IMAGE_SECTION_HEADER_format__)
            if not section:
                break
            section_offset = offset + section.sizeof() * i
            section.set_file_offset(section_offset)
            section.__unpack__(self.__data__[section_offset:])
            self.__structures__.append(section)

            if section.SizeOfRawData > len(self.__data__):
                self.__warnings.append(
                    ('Error parsing section %d. ' % i) +
                    'SizeOfRawData is larger than file.')

            if section.PointerToRawData > len(self.__data__):
                self.__warnings.append(
                    ('Error parsing section %d. ' % i) +
                    'PointerToRawData points beyond the end of the file.')

            if section.Misc_VirtualSize > 0x10000000:
                self.__warnings.append(
                    ('Suspicious value found parsing section %d. ' % i) +
                    'VirtualSize is extremely large > 256MiB.')

            if section.VirtualAddress > 0x10000000:
                self.__warnings.append(
                    ('Suspicious value found parsing section %d. ' % i) +
                    'VirtualAddress is beyond 0x10000000.')

            #
            # Some packer used a non-aligned PointerToRawData in the sections,
            # which causes several common tools not to load the section data
            # properly as they blindly read from the indicated offset.
            # It seems that Windows will round the offset down to the largest
            # offset multiple of FileAlignment which is smaller than
            # PointerToRawData. The following code will do the same.
            #

            #alignment = self.OPTIONAL_HEADER.FileAlignment
            self.update_section_data(section)

            if ( self.OPTIONAL_HEADER.FileAlignment != 0 and
                (section.PointerToRawData % self.OPTIONAL_HEADER.FileAlignment) != 0):
                self.__warnings.append(
                    ('Error parsing section %d. ' % i) +
                    'Suspicious value for FileAlignment in the Optional Header. ' +
                    'Normally the PointerToRawData entry of the sections\' structures ' +
                    'is a multiple of FileAlignment, this might imply the file ' +
                    'is trying to confuse tools which parse this incorrectly')


            section_flags = self.retrieve_flags(SECTION_CHARACTERISTICS, 'IMAGE_SCN_')

            # Set the section's flags according the the Characteristics member
            self.set_flags(section, section.Characteristics, section_flags)

            if ( section.__dict__.get('IMAGE_SCN_MEM_WRITE', False)  and
                section.__dict__.get('IMAGE_SCN_MEM_EXECUTE', False) ):

                self.__warnings.append(
                    ('Suspicious flags set for section %d. ' % i) +
                    'Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set.' +
                    'This might indicate a packed executable.')

            self.sections.append(section)

        if self.FILE_HEADER.NumberOfSections > 0 and self.sections:
            return offset + self.sections[0].sizeof()*self.FILE_HEADER.NumberOfSections
        else:
            return offset


    def retrieve_flags(self, flag_dict, flag_filter):
        """Read the flags from a dictionary and return them in a usable form.

        Will return a list of (flag, value) for all flags in "flag_dict"
        matching the filter "flag_filter".
        """

        return [(f[0], f[1]) for f in flag_dict.items() if
                isinstance(f[0], str) and f[0].startswith(flag_filter)]


    def set_flags(self, obj, flag_field, flags):
        """Will process the flags and set attributes in the object accordingly.

        The object "obj" will gain attritutes named after the flags provided in
        "flags" and valued True/False, matching the results of applyin each
        flag value from "flags" to flag_field.
        """

        for flag in flags:
            if flag[1] & flag_field:
                setattr(obj, flag[0], True)
            else:
                setattr(obj, flag[0], False)


    def parse_data_directories(self, directories=None):
        """Parse and process the PE file's data directories.

        If the optional argument 'directories' is given, only
        the directories at the specified indices will be parsed.
        Such funcionality allows parsing of areas of interest
        without the burden of having to parse all others.
        The directories can then be specified as:

        For export/import only:

          directories = [ 0, 1 ]

        or (more verbosely):

          directories = [ DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT'],
            DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT'] ]

        If 'directories' is a list, the ones that are processed will be removed,
        leaving only the ones that are not present in the image.
        """

        directory_parsing = (
            ('IMAGE_DIRECTORY_ENTRY_IMPORT', self.parse_import_directory),
            ('IMAGE_DIRECTORY_ENTRY_EXPORT', self.parse_export_directory),
            ('IMAGE_DIRECTORY_ENTRY_RESOURCE', self.parse_resources_directory),
            ('IMAGE_DIRECTORY_ENTRY_DEBUG', self.parse_debug_directory),
            ('IMAGE_DIRECTORY_ENTRY_BASERELOC', self.parse_relocations_directory),
            ('IMAGE_DIRECTORY_ENTRY_TLS', self.parse_directory_tls),
            ('IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG', self.parse_directory_load_config),
            ('IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT', self.parse_delay_import_directory),
            ('IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT', self.parse_directory_bound_imports) )

        if directories is not None:
            if not isinstance(directories, (tuple, list)):
                directories = [directories]

        for entry in directory_parsing:
            # OC Patch:
            #
            try:
                directory_index = DIRECTORY_ENTRY[entry[0]]
                dir_entry = self.OPTIONAL_HEADER.DATA_DIRECTORY[directory_index]
            except IndexError:
                break

            # Only process all the directories if no individual ones have
            # been chosen
            #
            if directories is None or directory_index in directories:

                if dir_entry.VirtualAddress:
                    value = entry[1](dir_entry.VirtualAddress, dir_entry.Size)
                    if value:
                        setattr(self, entry[0][6:], value)

            if (directories is not None) and isinstance(directories, list) and (entry[0] in directories):
                directories.remove(directory_index)



    def parse_directory_bound_imports(self, rva, size):
        """"""

        bnd_descr = Structure(self.__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__)
        bnd_descr_size = bnd_descr.sizeof()
        start = rva

        bound_imports = []
        while True:

            bnd_descr = self.__unpack_data__(
                self.__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__,
                   self.__data__[rva:rva+bnd_descr_size],
                   file_offset = rva)
            if bnd_descr is None:
                # If can't parse directory then silently return.
                # This directory does not necesarily have to be valid to
                # still have a valid PE file

                self.__warnings.append(
                    'The Bound Imports directory exists but can\'t be parsed.')

                return

            if bnd_descr.all_zeroes():
                break

            rva += bnd_descr.sizeof()

            forwarder_refs = []
            for idx in xrange(bnd_descr.NumberOfModuleForwarderRefs):
                # Both structures IMAGE_BOUND_IMPORT_DESCRIPTOR and
                # IMAGE_BOUND_FORWARDER_REF have the same size.
                bnd_frwd_ref = self.__unpack_data__(
                    self.__IMAGE_BOUND_FORWARDER_REF_format__,
                    self.__data__[rva:rva+bnd_descr_size],
                    file_offset = rva)
                # OC Patch:
                if not bnd_frwd_ref:
                    raise PEFormatError(
                        "IMAGE_BOUND_FORWARDER_REF cannot be read")
                rva += bnd_frwd_ref.sizeof()

                name_str =  self.get_string_from_data(
                    start+bnd_frwd_ref.OffsetModuleName, self.__data__)

                if not name_str:
                    break
                forwarder_refs.append(BoundImportRefData(
                    struct = bnd_frwd_ref,
                    name = name_str))

            name_str = self.get_string_from_data(
                start+bnd_descr.OffsetModuleName, self.__data__)

            if not name_str:
                break
            bound_imports.append(
                BoundImportDescData(
                    struct = bnd_descr,
                    name = name_str,
                    entries = forwarder_refs))

        return bound_imports


    def parse_directory_tls(self, rva, size):
        """"""

        if self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:
            format = self.__IMAGE_TLS_DIRECTORY_format__

        elif self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:
            format = self.__IMAGE_TLS_DIRECTORY64_format__

        try:
            tls_struct = self.__unpack_data__(
                format,
                self.get_data( rva, Structure(format).sizeof() ),
                file_offset = self.get_offset_from_rva(rva))
        except PEFormatError:
            self.__warnings.append(
                'Invalid TLS information. Can\'t read ' +
                'data at RVA: 0x%x' % rva)
            tls_struct = None

        if not tls_struct:
            return None

        return TlsData( struct = tls_struct )


    def parse_directory_load_config(self, rva, size):
        """"""

        if self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:
            format = self.__IMAGE_LOAD_CONFIG_DIRECTORY_format__

        elif self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:
            format = self.__IMAGE_LOAD_CONFIG_DIRECTORY64_format__

        try:
            load_config_struct = self.__unpack_data__(
                format,
                self.get_data( rva, Structure(format).sizeof() ),
                file_offset = self.get_offset_from_rva(rva))
        except PEFormatError:
            self.__warnings.append(
                'Invalid LOAD_CONFIG information. Can\'t read ' +
                'data at RVA: 0x%x' % rva)
            load_config_struct = None

        if not load_config_struct:
            return None

        return LoadConfigData( struct = load_config_struct )


    def parse_relocations_directory(self, rva, size):
        """"""

        rlc_size = Structure(self.__IMAGE_BASE_RELOCATION_format__).sizeof()
        end = rva+size

        relocations = []
        while rva<end:

            # OC Patch:
            # Malware that has bad rva entries will cause an error.
            # Just continue on after an exception
            #
            try:
                rlc = self.__unpack_data__(
                    self.__IMAGE_BASE_RELOCATION_format__,
                    self.get_data(rva, rlc_size),
                    file_offset = self.get_offset_from_rva(rva) )
            except PEFormatError:
                self.__warnings.append(
                    'Invalid relocation information. Can\'t read ' +
                    'data at RVA: 0x%x' % rva)
                rlc = None

            if not rlc:
                break

            reloc_entries = self.parse_relocations(
                rva+rlc_size, rlc.VirtualAddress, rlc.SizeOfBlock-rlc_size)

            relocations.append(
                BaseRelocationData(
                    struct = rlc,
                    entries = reloc_entries))

            if not rlc.SizeOfBlock:
                break
            rva += rlc.SizeOfBlock

        return relocations


    def parse_relocations(self, data_rva, rva, size):
        """"""

        data = self.get_data(data_rva, size)

        entries = []
        for idx in xrange(len(data)/2):
            word = struct.unpack('<H', data[idx*2:(idx+1)*2])[0]
            reloc_type = (word>>12)
            reloc_offset = (word&0x0fff)
            entries.append(
                RelocationData(
                    type = reloc_type,
                    rva = reloc_offset+rva))

        return entries


    def parse_debug_directory(self, rva, size):
        """"""

        dbg_size = Structure(self.__IMAGE_DEBUG_DIRECTORY_format__).sizeof()

        debug = []
        for idx in xrange(size/dbg_size):
            try:
                data = self.get_data(rva+dbg_size*idx, dbg_size)
            except PEFormatError, e:
                self.__warnings.append(
                    'Invalid debug information. Can\'t read ' +
                    'data at RVA: 0x%x' % rva)
                return None

            dbg = self.__unpack_data__(
                self.__IMAGE_DEBUG_DIRECTORY_format__,
                data, file_offset = self.get_offset_from_rva(rva+dbg_size*idx))

            if not dbg:
                return None

            debug.append(
                DebugData(
                    struct = dbg))

        return debug


    def parse_resources_directory(self, rva, size=0, base_rva = None, level = 0):
        """Parse the resources directory.

        Given the rva of the resources directory, it will process all
        its entries.

        The root will have the corresponding member of its structure,
        IMAGE_RESOURCE_DIRECTORY plus 'entries', a list of all the
        entries in the directory.

        Those entries will have, correspondingly, all the structure's
        members (IMAGE_RESOURCE_DIRECTORY_ENTRY) and an additional one,
        "directory", pointing to the IMAGE_RESOURCE_DIRECTORY structure
        representing upper layers of the tree. This one will also have
        an 'entries' attribute, pointing to the 3rd, and last, level.
        Another directory with more entries. Those last entries will
        have a new atribute (both 'leaf' or 'data_entry' can be used to
        access it). This structure finally points to the resource data.
        All the members of this structure, IMAGE_RESOURCE_DATA_ENTRY,
        are available as its attributes.
        """

        # OC Patch:
        original_rva = rva

        if base_rva is None:
            base_rva = rva

        resources_section = self.get_section_by_rva(rva)

        try:
            # If the RVA is invalid all would blow up. Some EXEs seem to be
            # specially nasty and have an invalid RVA.
            data = self.get_data(rva, Structure(self.__IMAGE_RESOURCE_DIRECTORY_format__).sizeof() )
        except PEFormatError, e:
            self.__warnings.append(
                'Invalid resources directory. Can\'t read ' +
                'directory data at RVA: 0x%x' % rva)
            return None

        # Get the resource directory structure, that is, the header
        # of the table preceding the actual entries
        #
        resource_dir = self.__unpack_data__(
            self.__IMAGE_RESOURCE_DIRECTORY_format__, data,
            file_offset = self.get_offset_from_rva(rva) )
        if resource_dir is None:
            # If can't parse resources directory then silently return.
            # This directory does not necesarily have to be valid to
            # still have a valid PE file
            self.__warnings.append(
                'Invalid resources directory. Can\'t parse ' +
                'directory data at RVA: 0x%x' % rva)
            return None

        dir_entries = []

        # Advance the rva to the positon immediately following the directory
        # table header and pointing to the first entry in the table
        #
        rva += resource_dir.sizeof()

        number_of_entries = (
            resource_dir.NumberOfNamedEntries +
            resource_dir.NumberOfIdEntries )

        strings_to_postprocess = list()

        for idx in xrange(number_of_entries):

            res = self.parse_resource_entry(rva)
            if res is None:
                self.__warnings.append(
                    'Error parsing the resources directory, ' +
                    'Entry %d is invalid, RVA = 0x%x. ' %
                    (idx, rva) )
                break


            entry_name = None
            entry_id = None

            # If all named entries have been processed, only Id ones
            # remain

            if idx >= resource_dir.NumberOfNamedEntries:
                entry_id = res.Name
            else:
                ustr_offset = base_rva+res.NameOffset
                try:
                    #entry_name = self.get_string_u_at_rva(ustr_offset, max_length=16)
                    entry_name = UnicodeStringWrapperPostProcessor(self, ustr_offset)
                    strings_to_postprocess.append(entry_name)

                except PEFormatError, excp:
                    self.__warnings.append(
                        'Error parsing the resources directory, ' +
                        'attempting to read entry name. ' +
                        'Can\'t read unicode string at offset 0x%x' %
                        (ustr_offset) )


            if res.DataIsDirectory:
                # OC Patch:
                #
                # One trick malware can do is to recursively reference
                # the next directory. This causes hilarity to ensue when
                # trying to parse everything correctly.
                # If the original RVA given to this function is equal to
                # the next one to parse, we assume that it's a trick.
                # Instead of raising a PEFormatError this would skip some
                # reasonable data so we just break.
                #
                # 9ee4d0a0caf095314fd7041a3e4404dc is the offending sample
                if original_rva == (base_rva + res.OffsetToDirectory):

                    break

                else:
                    entry_directory = self.parse_resources_directory(
                        base_rva+res.OffsetToDirectory,
                        base_rva=base_rva, level = level+1)

                if not entry_directory:
                    break
                dir_entries.append(
                    ResourceDirEntryData(
                        struct = res,
                        name = entry_name,
                        id = entry_id,
                        directory = entry_directory))

            else:
                struct = self.parse_resource_data_entry(
                    base_rva + res.OffsetToDirectory)

                if struct:
                    entry_data = ResourceDataEntryData(
                        struct = struct,
                        lang = res.Name & 0xff,
                        sublang = (res.Name>>8) & 0xff)

                    dir_entries.append(
                        ResourceDirEntryData(
                            struct = res,
                            name = entry_name,
                            id = entry_id,
                            data = entry_data))

                else:
                    break



            # Check if this entry contains version information
            #
            if level == 0 and res.Id == RESOURCE_TYPE['RT_VERSION']:
                if len(dir_entries)>0:
                    last_entry = dir_entries[-1]

                rt_version_struct = None
                try:
                    rt_version_struct = last_entry.directory.entries[0].directory.entries[0].data.struct
                except:
                    # Maybe a malformed directory structure...?
                    # Lets ignore it
                    pass

                if rt_version_struct is not None:
                    self.parse_version_information(rt_version_struct)

            rva += res.sizeof()


        string_rvas = [s.get_rva() for s in strings_to_postprocess]
        string_rvas.sort()

        for idx, s in enumerate(strings_to_postprocess):
            s.render_pascal_16()


        resource_directory_data = ResourceDirData(
            struct = resource_dir,
            entries = dir_entries)

        return resource_directory_data


    def parse_resource_data_entry(self, rva):
        """Parse a data entry from the resources directory."""

        try:
            # If the RVA is invalid all would blow up. Some EXEs seem to be
            # specially nasty and have an invalid RVA.
            data = self.get_data(rva, Structure(self.__IMAGE_RESOURCE_DATA_ENTRY_format__).sizeof() )
        except PEFormatError, excp:
            self.__warnings.append(
                'Error parsing a resource directory data entry, ' +
                'the RVA is invalid: 0x%x' % ( rva ) )
            return None

        data_entry = self.__unpack_data__(
            self.__IMAGE_RESOURCE_DATA_ENTRY_format__, data,
            file_offset = self.get_offset_from_rva(rva) )

        return data_entry


    def parse_resource_entry(self, rva):
        """Parse a directory entry from the resources directory."""

        resource = self.__unpack_data__(
            self.__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__,
            self.get_data( rva, Structure(self.__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__).sizeof() ),
            file_offset = self.get_offset_from_rva(rva) )

        if resource is None:
            return None

        #resource.NameIsString = (resource.Name & 0x80000000L) >> 31
        resource.NameOffset = resource.Name & 0x7FFFFFFFL

        resource.__pad = resource.Name & 0xFFFF0000L
        resource.Id = resource.Name & 0x0000FFFFL

        resource.DataIsDirectory = (resource.OffsetToData & 0x80000000L) >> 31
        resource.OffsetToDirectory = resource.OffsetToData & 0x7FFFFFFFL

        return resource


    def parse_version_information(self, version_struct):
        """Parse version information structure.

        The date will be made available in three attributes of the PE object.

        VS_VERSIONINFO     will contain the first three fields of the main structure:
            'Length', 'ValueLength', and 'Type'

        VS_FIXEDFILEINFO    will hold the rest of the fields, accessible as sub-attributes:
            'Signature', 'StrucVersion', 'FileVersionMS', 'FileVersionLS',
            'ProductVersionMS', 'ProductVersionLS', 'FileFlagsMask', 'FileFlags',
            'FileOS', 'FileType', 'FileSubtype', 'FileDateMS', 'FileDateLS'

        FileInfo    is a list of all StringFileInfo and VarFileInfo structures.

        StringFileInfo structures will have a list as an attribute named 'StringTable'
        containing all the StringTable structures. Each of those structures contains a
        dictionary 'entries' with all the key/value version information string pairs.

        VarFileInfo structures will have a list as an attribute named 'Var' containing
        all Var structures. Each Var structure will have a dictionary as an attribute
        named 'entry' which will contain the name and value of the Var.
        """


        # Retrieve the data for the version info resource
        #
        start_offset = self.get_offset_from_rva( version_struct.OffsetToData )
        raw_data = self.__data__[ start_offset : start_offset+version_struct.Size ]


        # Map the main structure and the subsequent string
        #
        versioninfo_struct = self.__unpack_data__(
            self.__VS_VERSIONINFO_format__, raw_data,
            file_offset = start_offset )

        if versioninfo_struct is None:
            return

        ustr_offset = version_struct.OffsetToData + versioninfo_struct.sizeof()
        try:
            versioninfo_string = self.get_string_u_at_rva( ustr_offset )
        except PEFormatError, excp:
            self.__warnings.append(
                'Error parsing the version information, ' +
                'attempting to read VS_VERSION_INFO string. Can\'t ' +
                'read unicode string at offset 0x%x' % (
                ustr_offset ) )

            versioninfo_string = None

        # If the structure does not contain the expected name, it's assumed to be invalid
        #
        if versioninfo_string != u'VS_VERSION_INFO':

            self.__warnings.append('Invalid VS_VERSION_INFO block')
            return


        # Set the PE object's VS_VERSIONINFO to this one
        #
        self.VS_VERSIONINFO = versioninfo_struct

        # The the Key attribute to point to the unicode string identifying the structure
        #
        self.VS_VERSIONINFO.Key = versioninfo_string


        # Process the fixed version information, get the offset and structure
        #
        fixedfileinfo_offset = self.dword_align(
            versioninfo_struct.sizeof() + 2 * (len(versioninfo_string) + 1),
            version_struct.OffsetToData)
        fixedfileinfo_struct = self.__unpack_data__(
            self.__VS_FIXEDFILEINFO_format__,
            raw_data[fixedfileinfo_offset:],
            file_offset = start_offset+fixedfileinfo_offset )

        if not fixedfileinfo_struct:
            return

        # Set the PE object's VS_FIXEDFILEINFO to this one
        #
        self.VS_FIXEDFILEINFO = fixedfileinfo_struct


        # Start parsing all the StringFileInfo and VarFileInfo structures
        #

        # Get the first one
        #
        stringfileinfo_offset = self.dword_align(
            fixedfileinfo_offset + fixedfileinfo_struct.sizeof(),
            version_struct.OffsetToData)
        original_stringfileinfo_offset = stringfileinfo_offset


        # Set the PE object's attribute that will contain them all.
        #
        self.FileInfo = list()


        while True:

            # Process the StringFileInfo/VarFileInfo struct
            #
            stringfileinfo_struct = self.__unpack_data__(
                self.__StringFileInfo_format__,
                raw_data[stringfileinfo_offset:],
                file_offset = start_offset+stringfileinfo_offset )

            if stringfileinfo_struct is None:
                self.__warnings.append(
                    'Error parsing StringFileInfo/VarFileInfo struct' )
                return None

            # Get the subsequent string defining the structure.
            #
            ustr_offset = ( version_struct.OffsetToData +
                stringfileinfo_offset + versioninfo_struct.sizeof() )
            try:
                stringfileinfo_string = self.get_string_u_at_rva( ustr_offset )
            except PEFormatError, excp:
                self.__warnings.append(
                    'Error parsing the version information, ' +
                    'attempting to read StringFileInfo string. Can\'t ' +
                    'read unicode string at offset 0x%x' %  ( ustr_offset ) )
                break

            # Set such string as the Key attribute
            #
            stringfileinfo_struct.Key = stringfileinfo_string


            # Append the structure to the PE object's list
            #
            self.FileInfo.append(stringfileinfo_struct)


            # Parse a StringFileInfo entry
            #
            if stringfileinfo_string.startswith(u'StringFileInfo'):

                if stringfileinfo_struct.Type == 1 and stringfileinfo_struct.ValueLength == 0:

                    stringtable_offset = self.dword_align(
                        stringfileinfo_offset + stringfileinfo_struct.sizeof() +
                            2*(len(stringfileinfo_string)+1),
                        version_struct.OffsetToData)

                    stringfileinfo_struct.StringTable = list()

                    # Process the String Table entries
                    #
                    while True:

                        stringtable_struct = self.__unpack_data__(
                            self.__StringTable_format__,
                            raw_data[stringtable_offset:],
                            file_offset = start_offset+stringtable_offset )

                        if not stringtable_struct:
                            break

                        ustr_offset = ( version_struct.OffsetToData + stringtable_offset +
                            stringtable_struct.sizeof() )
                        try:
                            stringtable_string = self.get_string_u_at_rva( ustr_offset )
                        except PEFormatError, excp:
                            self.__warnings.append(
                                'Error parsing the version information, ' +
                                'attempting to read StringTable string. Can\'t ' +
                                'read unicode string at offset 0x%x' % ( ustr_offset ) )
                            break

                        stringtable_struct.LangID = stringtable_string
                        stringtable_struct.entries = dict()
                        stringtable_struct.entries_offsets = dict()
                        stringtable_struct.entries_lengths = dict()
                        stringfileinfo_struct.StringTable.append(stringtable_struct)

                        entry_offset = self.dword_align(
                            stringtable_offset + stringtable_struct.sizeof() +
                                2*(len(stringtable_string)+1),
                            version_struct.OffsetToData)

                        # Process all entries in the string table
                        #

                        while entry_offset < stringtable_offset + stringtable_struct.Length:

                            string_struct = self.__unpack_data__(
                                self.__String_format__, raw_data[entry_offset:],
                                file_offset = start_offset+entry_offset )

                            if not string_struct:
                                break

                            ustr_offset = ( version_struct.OffsetToData + entry_offset +
                                string_struct.sizeof() )
                            try:
                                key = self.get_string_u_at_rva( ustr_offset )
                                key_offset = self.get_offset_from_rva( ustr_offset )
                            except PEFormatError, excp:
                                self.__warnings.append(
                                    'Error parsing the version information, ' +
                                    'attempting to read StringTable Key string. Can\'t ' +
                                    'read unicode string at offset 0x%x' % ( ustr_offset ) )
                                break

                            value_offset = self.dword_align(
                                2*(len(key)+1) + entry_offset + string_struct.sizeof(),
                                version_struct.OffsetToData)

                            ustr_offset = version_struct.OffsetToData + value_offset
                            try:
                                value = self.get_string_u_at_rva( ustr_offset,
                                    max_length = string_struct.ValueLength )
                                value_offset = self.get_offset_from_rva( ustr_offset )
                            except PEFormatError, excp:
                                self.__warnings.append(
                                    'Error parsing the version information, ' +
                                    'attempting to read StringTable Value string. ' +
                                    'Can\'t read unicode string at offset 0x%x' % (
                                    ustr_offset ) )
                                break

                            if string_struct.Length == 0:
                                entry_offset = stringtable_offset + stringtable_struct.Length
                            else:
                                entry_offset = self.dword_align(
                                    string_struct.Length+entry_offset, version_struct.OffsetToData)

                            key_as_char = []
                            for c in key:
                                if ord(c)>128:
                                    key_as_char.append('\\x%02x' %ord(c))
                                else:
                                    key_as_char.append(c)

                            key_as_char = ''.join(key_as_char)

                            setattr(stringtable_struct, key_as_char, value)
                            stringtable_struct.entries[key] = value
                            stringtable_struct.entries_offsets[key] = (key_offset, value_offset)
                            stringtable_struct.entries_lengths[key] = (len(key), len(value))


                        new_stringtable_offset = self.dword_align(
                            stringtable_struct.Length + stringtable_offset,
                            version_struct.OffsetToData)

                        # check if the entry is crafted in a way that would lead to an infinite
                        # loop and break if so
                        #
                        if new_stringtable_offset == stringtable_offset:
                            break
                        stringtable_offset = new_stringtable_offset

                        if stringtable_offset >= stringfileinfo_struct.Length:
                            break

            # Parse a VarFileInfo entry
            #
            elif stringfileinfo_string.startswith( u'VarFileInfo' ):

                varfileinfo_struct = stringfileinfo_struct
                varfileinfo_struct.name = 'VarFileInfo'

                if varfileinfo_struct.Type == 1 and varfileinfo_struct.ValueLength == 0:

                    var_offset = self.dword_align(
                        stringfileinfo_offset + varfileinfo_struct.sizeof() +
                            2*(len(stringfileinfo_string)+1),
                        version_struct.OffsetToData)

                    varfileinfo_struct.Var = list()

                    # Process all entries
                    #

                    while True:
                        var_struct = self.__unpack_data__(
                            self.__Var_format__,
                            raw_data[var_offset:],
                            file_offset = start_offset+var_offset )

                        if not var_struct:
                            break

                        ustr_offset = ( version_struct.OffsetToData + var_offset +
                            var_struct.sizeof() )
                        try:
                            var_string = self.get_string_u_at_rva( ustr_offset )
                        except PEFormatError, excp:
                            self.__warnings.append(
                                'Error parsing the version information, ' +
                                'attempting to read VarFileInfo Var string. ' +
                                'Can\'t read unicode string at offset 0x%x' % (ustr_offset))
                            break


                        varfileinfo_struct.Var.append(var_struct)

                        varword_offset = self.dword_align(
                            2*(len(var_string)+1) + var_offset + var_struct.sizeof(),
                            version_struct.OffsetToData)
                        orig_varword_offset = varword_offset

                        while varword_offset < orig_varword_offset + var_struct.ValueLength:
                            word1 = self.get_word_from_data(
                                raw_data[varword_offset:varword_offset+2], 0)
                            word2 = self.get_word_from_data(
                                raw_data[varword_offset+2:varword_offset+4], 0)
                            varword_offset += 4

                            if isinstance(word1, (int, long)) and isinstance(word1, (int, long)):
                                var_struct.entry = {var_string: '0x%04x 0x%04x' % (word1, word2)}

                        var_offset = self.dword_align(
                            var_offset+var_struct.Length, version_struct.OffsetToData)

                        if var_offset <= var_offset+var_struct.Length:
                            break


            # Increment and align the offset
            #
            stringfileinfo_offset = self.dword_align(
                stringfileinfo_struct.Length+stringfileinfo_offset,
                version_struct.OffsetToData)

            # Check if all the StringFileInfo and VarFileInfo items have been processed
            #
            if stringfileinfo_struct.Length == 0 or stringfileinfo_offset >= versioninfo_struct.Length:
                break



    def parse_export_directory(self, rva, size):
        """Parse the export directory.

        Given the rva of the export directory, it will process all
        its entries.

        The exports will be made available through a list "exports"
        containing a tuple with the following elements:

            (ordinal, symbol_address, symbol_name)

        And also through a dicionary "exports_by_ordinal" whose keys
        will be the ordinals and the values tuples of the from:

            (symbol_address, symbol_name)

        The symbol addresses are relative, not absolute.
        """

        try:
            export_dir =  self.__unpack_data__(
                self.__IMAGE_EXPORT_DIRECTORY_format__,
                self.get_data( rva, Structure(self.__IMAGE_EXPORT_DIRECTORY_format__).sizeof() ),
                file_offset = self.get_offset_from_rva(rva) )
        except PEFormatError:
            self.__warnings.append(
                'Error parsing export directory at RVA: 0x%x' % ( rva ) )
            return

        if not export_dir:
            return

        try:
            address_of_names = self.get_data(
                export_dir.AddressOfNames, export_dir.NumberOfNames*4)
            address_of_name_ordinals = self.get_data(
                export_dir.AddressOfNameOrdinals, export_dir.NumberOfNames*4)
            address_of_functions = self.get_data(
                export_dir.AddressOfFunctions, export_dir.NumberOfFunctions*4)
        except PEFormatError:
            self.__warnings.append(
                'Error parsing export directory at RVA: 0x%x' % ( rva ) )
            return

        exports = []

        for i in xrange(export_dir.NumberOfNames):


            symbol_name = self.get_string_at_rva(
                self.get_dword_from_data(address_of_names, i))

            symbol_ordinal = self.get_word_from_data(
                address_of_name_ordinals, i)


            if symbol_ordinal*4<len(address_of_functions):
                symbol_address = self.get_dword_from_data(
                    address_of_functions, symbol_ordinal)
            else:
                # Corrupt? a bad pointer... we assume it's all
                # useless, no exports
                return None

            # If the funcion's rva points within the export directory
            # it will point to a string with the forwarded symbol's string
            # instead of pointing the the function start address.

            if symbol_address>=rva and symbol_address<rva+size:
                forwarder_str = self.get_string_at_rva(symbol_address)
            else:
                forwarder_str = None


            exports.append(
                ExportData(
                    ordinal = export_dir.Base+symbol_ordinal,
                    address = symbol_address,
                    name = symbol_name,
                    forwarder = forwarder_str))

        ordinals = [exp.ordinal for exp in exports]

        for idx in xrange(export_dir.NumberOfFunctions):

            if not idx+export_dir.Base in ordinals:
                symbol_address = self.get_dword_from_data(
                    address_of_functions,
                    idx)

                #
                # Checking for forwarder again.
                #
                if symbol_address>=rva and symbol_address<rva+size:
                    forwarder_str = self.get_string_at_rva(symbol_address)
                else:
                    forwarder_str = None

                exports.append(
                    ExportData(
                        ordinal = export_dir.Base+idx,
                        address = symbol_address,
                        name = None,
                        forwarder = forwarder_str))

        return ExportDirData(
                struct = export_dir,
                symbols = exports)


    def dword_align(self, offset, base):
        offset += base
        return (offset+3) - ((offset+3)%4) - base


    def parse_delay_import_directory(self, rva, size):
        """Walk and parse the delay import directory."""

        import_descs =  []
        while True:
            try:
                # If the RVA is invalid all would blow up. Some PEs seem to be
                # specially nasty and have an invalid RVA.
                data = self.get_data( rva, Structure(self.__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__).sizeof() )
            except PEFormatError, e:
                self.__warnings.append(
                    'Error parsing the Delay import directory at RVA: 0x%x' % ( rva ) )
                break

            import_desc =  self.__unpack_data__(
                self.__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__,
                data, file_offset = self.get_offset_from_rva(rva) )


            # If the structure is all zeores, we reached the end of the list
            if not import_desc or import_desc.all_zeroes():
                break


            rva += import_desc.sizeof()

            try:
                import_data =  self.parse_imports(
                    import_desc.pINT,
                    import_desc.pIAT,
                    None)
            except PEFormatError, e:
                self.__warnings.append(
                    'Error parsing the Delay import directory. ' +
                    'Invalid import data at RVA: 0x%x' % ( rva ) )
                break

            if not import_data:
                continue


            dll = self.get_string_at_rva(import_desc.szName)
            if dll:
                import_descs.append(
                    ImportDescData(
                        struct = import_desc,
                        imports = import_data,
                        dll = dll))

        return import_descs



    def parse_import_directory(self, rva, size):
        """Walk and parse the import directory."""

        import_descs =  []
        while True:
            try:
                # If the RVA is invalid all would blow up. Some EXEs seem to be
                # specially nasty and have an invalid RVA.
                data = self.get_data(rva, Structure(self.__IMAGE_IMPORT_DESCRIPTOR_format__).sizeof() )
            except PEFormatError, e:
                self.__warnings.append(
                    'Error parsing the Import directory at RVA: 0x%x' % ( rva ) )
                break

            import_desc =  self.__unpack_data__(
                self.__IMAGE_IMPORT_DESCRIPTOR_format__,
                data, file_offset = self.get_offset_from_rva(rva) )

            # If the structure is all zeores, we reached the end of the list
            if not import_desc or import_desc.all_zeroes():
                break

            rva += import_desc.sizeof()

            try:
                import_data =  self.parse_imports(
                    import_desc.OriginalFirstThunk,
                    import_desc.FirstThunk,
                    import_desc.ForwarderChain)
            except PEFormatError, excp:
                self.__warnings.append(
                    'Error parsing the Import directory. ' +
                    'Invalid Import data at RVA: 0x%x' % ( rva ) )
                break
                #raise excp

            if not import_data:
                continue

            dll = self.get_string_at_rva(import_desc.Name)
            if dll:
                import_descs.append(
                    ImportDescData(
                        struct = import_desc,
                        imports = import_data,
                        dll = dll))

        return import_descs



    def parse_imports(self, original_first_thunk, first_thunk, forwarder_chain):
        """Parse the imported symbols.

        It will fill a list, which will be avalable as the dictionary
        attribute "imports". Its keys will be the DLL names and the values
        all the symbols imported from that object.
        """

        imported_symbols = []
        imports_section = self.get_section_by_rva(first_thunk)
        if not imports_section:
            raise PEFormatError, 'Invalid/corrupt imports.'


        # Import Lookup Table. Contains ordinals or pointers to strings.
        ilt = self.get_import_table(original_first_thunk)
        # Import Address Table. May have identical content to ILT if
        # PE file is not bounded, Will contain the address of the
        # imported symbols once the binary is loaded or if it is already
        # bound.
        iat = self.get_import_table(first_thunk)

        # OC Patch:
        # Would crash if iat or ilt had None type
        if not iat and not ilt:
            raise PEFormatError(
                'Invalid Import Table information. ' +
                'Both ILT and IAT appear to be broken.')

        table = None
        if ilt:
            table = ilt
        elif iat:
            table = iat
        else:
            return None


        for idx in xrange(len(table)):

            imp_ord = None
            imp_hint = None
            imp_name = None
            hint_name_table_rva = None

            if table[idx].AddressOfData:

                if self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:
                    ordinal_flag = IMAGE_ORDINAL_FLAG
                elif self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:
                    ordinal_flag = IMAGE_ORDINAL_FLAG64

                # If imported by ordinal, we will append the ordinal number
                #
                if table[idx].AddressOfData & ordinal_flag:
                    import_by_ordinal = True
                    imp_ord = table[idx].AddressOfData & 0xffff
                    imp_name = None
                else:
                    import_by_ordinal = False
                    try:
                        hint_name_table_rva = table[idx].AddressOfData & 0x7fffffff
                        data = self.get_data(hint_name_table_rva, 2)
                        # Get the Hint
                        imp_hint = self.get_word_from_data(data, 0)
                        imp_name = self.get_string_at_rva(table[idx].AddressOfData+2)
                    except PEFormatError, e:
                        pass

            imp_address = first_thunk+self.OPTIONAL_HEADER.ImageBase+idx*4

            try:
                if iat and ilt and ilt[idx].AddressOfData != iat[idx].AddressOfData:
                    imp_bound = iat[idx].AddressOfData
                else:
                    imp_bound = None
            except IndexError:
                imp_bound = None

            if imp_name != '' and (imp_ord or imp_name):
                imported_symbols.append(
                    ImportData(
                        import_by_ordinal = import_by_ordinal,
                        ordinal = imp_ord,
                        hint = imp_hint,
                        name = imp_name,
                        bound = imp_bound,
                        address = imp_address,
                        hint_name_table_rva = hint_name_table_rva))

        return imported_symbols



    def get_import_table(self, rva):

        table = []

        while True and rva:

            if self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE:
                format = self.__IMAGE_THUNK_DATA_format__
            elif self.PE_TYPE == OPTIONAL_HEADER_MAGIC_PE_PLUS:
                format = self.__IMAGE_THUNK_DATA64_format__

            try:
                data = self.get_data( rva, Structure(format).sizeof() )
            except PEFormatError, e:
                self.__warnings.append(
                    'Error parsing the import table. ' +
                    'Invalid data at RVA: 0x%x' % ( rva ) )
                return None

            thunk_data = self.__unpack_data__(
                format, data, file_offset=self.get_offset_from_rva(rva) )

            if not thunk_data or thunk_data.all_zeroes():
                break

            rva += thunk_data.sizeof()

            table.append(thunk_data)

        return table


    def get_memory_mapped_image(self, max_virtual_address=0x10000000, ImageBase=None):
        """Returns the data corresponding to the memory layout of the PE file.

        The data includes the PE header and the sections loaded at offsets
        corresponding to their relative virtual addresses. (the VirtualAddress
        section header member).
        Any offset in this data corresponds to the absolute memory address
        ImageBase+offset.

        The optional argument 'max_virtual_address' provides with means of limiting
        which section are processed.
        Any section with their VirtualAddress beyond this value will be skipped.
        Normally, sections with values beyond this range are just there to confuse
        tools. It's a common trick to see in packed executables.

        If the 'ImageBase' optional argument is supplied, the file's relocations
        will be applied to the image by calling the 'relocate_image()' method. Beware
        that the relocation information is applied permanently.
        """

        # Rebase if requested
        #
        if ImageBase is not None:

            # Keep a copy of the image's data before modifying it by rebasing it
            #
            original_data = self.__data__

            self.relocate_image(ImageBase)

        # Collect all sections in one code block
        mapped_data = self.header
        for section in self.sections:

            # Miscellanous integrity tests.
            # Some packer will set these to bogus values to
            # make tools go nuts.
            #
            if section.Misc_VirtualSize == 0 or section.SizeOfRawData == 0:
                continue

            if section.SizeOfRawData > len(self.__data__):
                continue

            if section.PointerToRawData > len(self.__data__):
                continue

            if section.VirtualAddress >= max_virtual_address:
                continue

            padding_length = section.VirtualAddress - len(mapped_data)

            if padding_length>0:
                mapped_data += '\0'*padding_length
            elif padding_length<0:
                mapped_data = mapped_data[:padding_length]

            mapped_data += section.data

        # If the image was rebased, restore it to its original form
        #
        if ImageBase is not None:
            self.__data__ = original_data

            self.update_all_section_data()

        return mapped_data


    def get_data(self, rva, length=None):
        """Get data regardless of the section where it lies on.

        Given a rva and the size of the chunk to retrieve, this method
        will find the section where the data lies and return the data.
        """

        s = self.get_section_by_rva(rva)

        if not s:
            if rva<len(self.header):
                if length:
                    end = rva+length
                else:
                    end = None
                return self.header[rva:end]

            raise PEFormatError, 'data at RVA can\'t be fetched. Corrupt header?'

        return s.get_data(rva, length)


    def get_rva_from_offset(self, offset):
        """Get the rva corresponding to this file offset. """

        s = self.get_section_by_offset(offset)
        if not s:
            raise PEFormatError("specified offset (0x%x) doesn't belong to any section." % offset)
        return s.get_rva_from_offset(offset)

    def get_offset_from_rva(self, rva):
        """Get the file offset corresponding to this rva.

        Given a rva , this method will find the section where the
        data lies and return the offset within the file.
        """

        s = self.get_section_by_rva(rva)
        if not s:

            raise PEFormatError, 'data at RVA can\'t be fetched. Corrupt header?'

        return s.get_offset_from_rva(rva)


    def get_string_at_rva(self, rva):
        """Get an ASCII string located at the given address."""

        s = self.get_section_by_rva(rva)
        if not s:
            if rva<len(self.header):
                return self.get_string_from_data(rva, self.header)
            return None

        return self.get_string_from_data(rva-s.VirtualAddress, s.data)


    def get_string_from_data(self, offset, data):
        """Get an ASCII string from within the data."""

        # OC Patch
        b = None

        try:
            b = data[offset]
        except IndexError:
            return ''

        s = ''
        while ord(b):
            s += b
            offset += 1
            try:
                b = data[offset]
            except IndexError:
                break

        return s


    def get_string_u_at_rva(self, rva, max_length = 2**16):
        """Get an Unicode string located at the given address."""

        try:
            # If the RVA is invalid all would blow up. Some EXEs seem to be
            # specially nasty and have an invalid RVA.
            self.get_data(rva, 2)
        except PEFormatError, e:
            return None

        #length = struct.unpack('<H', data)[0]

        s = u''
        for idx in xrange(max_length):
            try:
                uchr = struct.unpack('<H', self.get_data(rva+2*idx, 2))[0]
            except struct.error:
                break

            if unichr(uchr) == u'\0':
                break
            s += unichr(uchr)

        return s


    def get_section_by_offset(self, offset):
        """Get the section containing the given file offset."""

        sections = [s for s in self.sections if s.contains_offset(offset)]

        if sections:
            return sections[0]

        return None


    def get_section_by_rva(self, rva):
        """Get the section containing the given address."""

        sections = [s for s in self.sections if s.contains_rva(rva)]

        if sections:
            return sections[0]

        return None

    def __str__(self):
        return self.dump_info()


    def print_info(self):
        """Print all the PE header information in a human readable from."""
        print self.dump_info()


    def dump_info(self, dump=None):
        """Dump all the PE header information into human readable string."""


        if dump is None:
            dump = Dump()

        warnings = self.get_warnings()
        if warnings:
            dump.add_header('Parsing Warnings')
            for warning in warnings:
                dump.add_line(warning)
                dump.add_newline()


        dump.add_header('DOS_HEADER')
        dump.add_lines(self.DOS_HEADER.dump())
        dump.add_newline()

        dump.add_header('NT_HEADERS')
        dump.add_lines(self.NT_HEADERS.dump())
        dump.add_newline()

        dump.add_header('FILE_HEADER')
        dump.add_lines(self.FILE_HEADER.dump())

        image_flags = self.retrieve_flags(IMAGE_CHARACTERISTICS, 'IMAGE_FILE_')

        dump.add('Flags: ')
        flags = []
        for flag in image_flags:
            if getattr(self.FILE_HEADER, flag[0]):
                flags.append(flag[0])
        dump.add_line(', '.join(flags))
        dump.add_newline()

        if hasattr(self, 'OPTIONAL_HEADER') and self.OPTIONAL_HEADER is not None:
            dump.add_header('OPTIONAL_HEADER')
            dump.add_lines(self.OPTIONAL_HEADER.dump())

        dll_characteristics_flags = self.retrieve_flags(DLL_CHARACTERISTICS, 'IMAGE_DLL_CHARACTERISTICS_')

        dump.add('DllCharacteristics: ')
        flags = []
        for flag in dll_characteristics_flags:
            if getattr(self.OPTIONAL_HEADER, flag[0]):
                flags.append(flag[0])
        dump.add_line(', '.join(flags))
        dump.add_newline()


        dump.add_header('PE Sections')

        section_flags = self.retrieve_flags(SECTION_CHARACTERISTICS, 'IMAGE_SCN_')

        for section in self.sections:
            dump.add_lines(section.dump())
            dump.add('Flags: ')
            flags = []
            for flag in section_flags:
                if getattr(section, flag[0]):
                    flags.append(flag[0])
            dump.add_line(', '.join(flags))
            dump.add_line('Entropy: %f (Min=0.0, Max=8.0)' % section.get_entropy() )
            if md5 is not None:
                dump.add_line('MD5     hash: %s' % section.get_hash_md5() )
            if sha1 is not None:
                dump.add_line('SHA-1   hash: %s' % section.get_hash_sha1() )
            if sha256 is not None:
                dump.add_line('SHA-256 hash: %s' % section.get_hash_sha256() )
            if sha512 is not None:
                dump.add_line('SHA-512 hash: %s' % section.get_hash_sha512() )
            dump.add_newline()



        if (hasattr(self, 'OPTIONAL_HEADER') and
            hasattr(self.OPTIONAL_HEADER, 'DATA_DIRECTORY') ):

            dump.add_header('Directories')
            for idx in xrange(len(self.OPTIONAL_HEADER.DATA_DIRECTORY)):
                directory = self.OPTIONAL_HEADER.DATA_DIRECTORY[idx]
                dump.add_lines(directory.dump())
            dump.add_newline()


        def convert_char(char):
            if char in string.ascii_letters or char in string.digits or char in string.punctuation or char in string.whitespace:
                return char
            else:
                return r'\x%02x' % ord(char)

        def convert_to_printable(s):
            return ''.join([convert_char(c) for c in s])

        if hasattr(self, 'VS_VERSIONINFO'):
            dump.add_header('Version Information')
            dump.add_lines(self.VS_VERSIONINFO.dump())
            dump.add_newline()

            if hasattr(self, 'VS_FIXEDFILEINFO'):
                dump.add_lines(self.VS_FIXEDFILEINFO.dump())
                dump.add_newline()

            if hasattr(self, 'FileInfo'):
                for entry in self.FileInfo:
                    dump.add_lines(entry.dump())
                    dump.add_newline()

                    if hasattr(entry, 'StringTable'):
                        for st_entry in entry.StringTable:
                            [dump.add_line('  '+line) for line in st_entry.dump()]
                            dump.add_line('  LangID: '+st_entry.LangID)
                            dump.add_newline()
                            for str_entry in st_entry.entries.items():
                                dump.add_line( '    ' +
                                    convert_to_printable(str_entry[0]) + ': ' +
                                    convert_to_printable(str_entry[1]) )
                        dump.add_newline()

                    elif hasattr(entry, 'Var'):
                        for var_entry in entry.Var:
                            if hasattr(var_entry, 'entry'):
                                [dump.add_line('  '+line) for line in var_entry.dump()]
                                dump.add_line(
                                    '    ' +
                                    convert_to_printable(var_entry.entry.keys()[0]) +
                                    ': ' + var_entry.entry.values()[0])

                        dump.add_newline()



        if hasattr(self, 'DIRECTORY_ENTRY_EXPORT'):
            dump.add_header('Exported symbols')
            dump.add_lines(self.DIRECTORY_ENTRY_EXPORT.struct.dump())
            dump.add_newline()
            dump.add_line('%-10s   %-10s  %s' % ('Ordinal', 'RVA', 'Name'))
            for export in self.DIRECTORY_ENTRY_EXPORT.symbols:
                dump.add('%-10d 0x%08Xh    %s' % (
                    export.ordinal, export.address, export.name))
                if export.forwarder:
                    dump.add_line(' forwarder: %s' % export.forwarder)
                else:
                    dump.add_newline()

            dump.add_newline()

        if hasattr(self, 'DIRECTORY_ENTRY_IMPORT'):
            dump.add_header('Imported symbols')
            for module in self.DIRECTORY_ENTRY_IMPORT:
                dump.add_lines(module.struct.dump())
                dump.add_newline()
                for symbol in module.imports:

                    if symbol.import_by_ordinal is True:
                        dump.add('%s Ordinal[%s] (Imported by Ordinal)' % (
                            module.dll, str(symbol.ordinal)))
                    else:
                        dump.add('%s.%s Hint[%s]' % (
                            module.dll, symbol.name, str(symbol.hint)))

                    if symbol.bound:
                        dump.add_line(' Bound: 0x%08X' % (symbol.bound))
                    else:
                        dump.add_newline()
                dump.add_newline()


        if hasattr(self, 'DIRECTORY_ENTRY_BOUND_IMPORT'):
            dump.add_header('Bound imports')
            for bound_imp_desc in self.DIRECTORY_ENTRY_BOUND_IMPORT:

                dump.add_lines(bound_imp_desc.struct.dump())
                dump.add_line('DLL: %s' % bound_imp_desc.name)
                dump.add_newline()

                for bound_imp_ref in bound_imp_desc.entries:
                    dump.add_lines(bound_imp_ref.struct.dump(), 4)
                    dump.add_line('DLL: %s' % bound_imp_ref.name, 4)
                    dump.add_newline()


        if hasattr(self, 'DIRECTORY_ENTRY_DELAY_IMPORT'):
            dump.add_header('Delay Imported symbols')
            for module in self.DIRECTORY_ENTRY_DELAY_IMPORT:

                dump.add_lines(module.struct.dump())
                dump.add_newline()

                for symbol in module.imports:
                    if symbol.import_by_ordinal is True:
                        dump.add('%s Ordinal[%s] (Imported by Ordinal)' % (
                            module.dll, str(symbol.ordinal)))
                    else:
                        dump.add('%s.%s Hint[%s]' % (
                            module.dll, symbol.name, str(symbol.hint)))

                    if symbol.bound:
                        dump.add_line(' Bound: 0x%08X' % (symbol.bound))
                    else:
                        dump.add_newline()
                dump.add_newline()


        if hasattr(self, 'DIRECTORY_ENTRY_RESOURCE'):
            dump.add_header('Resource directory')

            dump.add_lines(self.DIRECTORY_ENTRY_RESOURCE.struct.dump())

            for resource_type in self.DIRECTORY_ENTRY_RESOURCE.entries:

                if resource_type.name is not None:
                    dump.add_line('Name: [%s]' % resource_type.name, 2)
                else:
                    dump.add_line('Id: [0x%X] (%s)' % (
                        resource_type.struct.Id, RESOURCE_TYPE.get(
                            resource_type.struct.Id, '-')),
                        2)

                dump.add_lines(resource_type.struct.dump(), 2)

                if hasattr(resource_type, 'directory'):

                    dump.add_lines(resource_type.directory.struct.dump(), 4)

                    for resource_id in resource_type.directory.entries:

                        if resource_id.name is not None:
                            dump.add_line('Name: [%s]' % resource_id.name, 6)
                        else:
                            dump.add_line('Id: [0x%X]' % resource_id.struct.Id, 6)

                        dump.add_lines(resource_id.struct.dump(), 6)

                        if hasattr(resource_id, 'directory'):
                            dump.add_lines(resource_id.directory.struct.dump(), 8)

                            for resource_lang in resource_id.directory.entries:
                            #    dump.add_line('\\--- LANG [%d,%d][%s]' % (
                            #        resource_lang.data.lang,
                            #        resource_lang.data.sublang,
                            #        LANG[resource_lang.data.lang]), 8)
                                dump.add_lines(resource_lang.struct.dump(), 10)
                                dump.add_lines(resource_lang.data.struct.dump(), 12)
                dump.add_newline()

            dump.add_newline()


        if ( hasattr(self, 'DIRECTORY_ENTRY_TLS') and
             self.DIRECTORY_ENTRY_TLS and
             self.DIRECTORY_ENTRY_TLS.struct ):

            dump.add_header('TLS')
            dump.add_lines(self.DIRECTORY_ENTRY_TLS.struct.dump())
            dump.add_newline()


        if ( hasattr(self, 'DIRECTORY_ENTRY_LOAD_CONFIG') and
             self.DIRECTORY_ENTRY_LOAD_CONFIG and
             self.DIRECTORY_ENTRY_LOAD_CONFIG.struct ):

            dump.add_header('LOAD_CONFIG')
            dump.add_lines(self.DIRECTORY_ENTRY_LOAD_CONFIG.struct.dump())
            dump.add_newline()


        if hasattr(self, 'DIRECTORY_ENTRY_DEBUG'):
            dump.add_header('Debug information')
            for dbg in self.DIRECTORY_ENTRY_DEBUG:
                dump.add_lines(dbg.struct.dump())
                try:
                    dump.add_line('Type: '+DEBUG_TYPE[dbg.struct.Type])
                except KeyError:
                    dump.add_line('Type: 0x%x(Unknown)' % dbg.struct.Type)
                dump.add_newline()


        if hasattr(self, 'DIRECTORY_ENTRY_BASERELOC'):
            dump.add_header('Base relocations')
            for base_reloc in self.DIRECTORY_ENTRY_BASERELOC:
                dump.add_lines(base_reloc.struct.dump())
                for reloc in base_reloc.entries:
                    try:
                        dump.add_line('%08Xh %s' % (
                            reloc.rva, RELOCATION_TYPE[reloc.type][16:]), 4)
                    except KeyError:
                        dump.add_line('0x%08X 0x%x(Unknown)' % (
                            reloc.rva, reloc.type), 4)
                dump.add_newline()


        return dump.get_text()

    # OC Patch
    def get_physical_by_rva(self, rva):
        """Gets the physical address in the PE file from an RVA value."""
        try:
            return self.get_offset_from_rva(rva)
        except Exception:
            return None


    ##
    # Double-Word get/set
    ##

    def get_data_from_dword(self, dword):
        """Return a four byte string representing the double word value. (little endian)."""
        return struct.pack('<L', dword & 0xffffffff)


    def get_dword_from_data(self, data, offset):
        """Convert four bytes of data to a double word (little endian)

        'offset' is assumed to index into a dword array. So setting it to
        N will return a dword out of the data sarting at offset N*4.

        Returns None if the data can't be turned into a double word.
        """

        if (offset+1)*4 > len(data):
            return None

        return struct.unpack('<I', data[offset*4:(offset+1)*4])[0]


    def get_dword_at_rva(self, rva):
        """Return the double word value at the given RVA.

        Returns None if the value can't be read, i.e. the RVA can't be mapped
        to a file offset.
        """

        try:
            return self.get_dword_from_data(self.get_data(rva)[:4], 0)
        except PEFormatError:
            return None


    def get_dword_from_offset(self, offset):
        """Return the double word value at the given file offset. (little endian)"""

        if offset+4 > len(self.__data__):
            return None

        return self.get_dword_from_data(self.__data__[offset:offset+4], 0)


    def set_dword_at_rva(self, rva, dword):
        """Set the double word value at the file offset corresponding to the given RVA."""
        return self.set_bytes_at_rva(rva, self.get_data_from_dword(dword))


    def set_dword_at_offset(self, offset, dword):
        """Set the double word value at the given file offset."""
        return self.set_bytes_at_offset(offset, self.get_data_from_dword(dword))



    ##
    # Word get/set
    ##

    def get_data_from_word(self, word):
        """Return a two byte string representing the word value. (little endian)."""
        return struct.pack('<H', word)


    def get_word_from_data(self, data, offset):
        """Convert two bytes of data to a word (little endian)

        'offset' is assumed to index into a word array. So setting it to
        N will return a dword out of the data sarting at offset N*2.

        Returns None if the data can't be turned into a word.
        """

        if (offset+1)*2 > len(data):
            return None

        return struct.unpack('<H', data[offset*2:(offset+1)*2])[0]


    def get_word_at_rva(self, rva):
        """Return the word value at the given RVA.

        Returns None if the value can't be read, i.e. the RVA can't be mapped
        to a file offset.
        """

        try:
            return self.get_word_from_data(self.get_data(rva)[:2], 0)
        except PEFormatError:
            return None


    def get_word_from_offset(self, offset):
        """Return the word value at the given file offset. (little endian)"""

        if offset+2 > len(self.__data__):
            return None

        return self.get_word_from_data(self.__data__[offset:offset+2], 0)


    def set_word_at_rva(self, rva, word):
        """Set the word value at the file offset corresponding to the given RVA."""
        return self.set_bytes_at_rva(rva, self.get_data_from_word(word))


    def set_word_at_offset(self, offset, word):
        """Set the word value at the given file offset."""
        return self.set_bytes_at_offset(offset, self.get_data_from_word(word))


    ##
    # Quad-Word get/set
    ##

    def get_data_from_qword(self, word):
        """Return a eight byte string representing the quad-word value. (little endian)."""
        return struct.pack('<Q', word)


    def get_qword_from_data(self, data, offset):
        """Convert eight bytes of data to a word (little endian)

        'offset' is assumed to index into a word array. So setting it to
        N will return a dword out of the data sarting at offset N*8.

        Returns None if the data can't be turned into a quad word.
        """

        if (offset+1)*8 > len(data):
            return None

        return struct.unpack('<Q', data[offset*8:(offset+1)*8])[0]


    def get_qword_at_rva(self, rva):
        """Return the quad-word value at the given RVA.

        Returns None if the value can't be read, i.e. the RVA can't be mapped
        to a file offset.
        """

        try:
            return self.get_qword_from_data(self.get_data(rva)[:8], 0)
        except PEFormatError:
            return None


    def get_qword_from_offset(self, offset):
        """Return the quad-word value at the given file offset. (little endian)"""

        if offset+8 > len(self.__data__):
            return None

        return self.get_qword_from_data(self.__data__[offset:offset+8], 0)


    def set_qword_at_rva(self, rva, qword):
        """Set the quad-word value at the file offset corresponding to the given RVA."""
        return self.set_bytes_at_rva(rva, self.get_data_from_qword(qword))


    def set_qword_at_offset(self, offset, qword):
        """Set the quad-word value at the given file offset."""
        return self.set_bytes_at_offset(offset, self.get_data_from_qword(qword))



    ##
    # Set bytes
    ##


    def set_bytes_at_rva(self, rva, data):
        """Overwrite, with the given string, the bytes at the file offset corresponding to the given RVA.

        Return True if successful, False otherwise. It can fail if the
        offset is outside the file's boundaries.
        """

        offset = self.get_physical_by_rva(rva)
        if not offset:
            raise False

        return self.set_bytes_at_offset(offset, data)


    def set_bytes_at_offset(self, offset, data):
        """Overwrite the bytes at the given file offset with the given string.

        Return True if successful, False otherwise. It can fail if the
        offset is outside the file's boundaries.
        """

        if not isinstance(data, str):
            raise TypeError('data should be of type: str')

        if offset >= 0 and offset < len(self.__data__):
            self.__data__ = ( self.__data__[:offset] +
                data +
                self.__data__[offset+len(data):] )
        else:
            return False

        self.update_all_section_data()

        return True


    def update_all_section_data(self):
        """Refresh the data of all section in the file.

        Will call update_section_data() for each section in the file.
        """

        for section in self.sections:
            self.update_section_data(section)


    def update_section_data(self, section):
        """Update the section data with any data updated in the file.

        If the file's data is modified, the section's data can be refreshed
        by invoking this method.
        """

        # Refresh the section's data with the modified information
        #
        section_data_start = section.PointerToRawData
        section_data_end = section_data_start+section.SizeOfRawData
        section.set_data(self.__data__[section_data_start:section_data_end])



    def relocate_image(self, new_ImageBase):
        """Apply the relocation information to the image using the provided new image base.

        This method will apply the relocation information to the image. Given the new base,
        all the relocations will be processed and both the raw data and the section's data
        will be fixed accordingly.
        The resulting image can be retrieved as well through the method:

            get_memory_mapped_image()

        In order to get something that would more closely match what could be found in memory
        once the Windows loader finished its work.
        """

        relocation_difference = new_ImageBase - self.OPTIONAL_HEADER.ImageBase


        for reloc in self.DIRECTORY_ENTRY_BASERELOC:

            virtual_address = reloc.struct.VirtualAddress
            size_of_block = reloc.struct.SizeOfBlock

            # We iterate with an index because if the relocation is of type
            # IMAGE_REL_BASED_HIGHADJ we need to also process the next entry
            # at once and skip it for the next interation
            #
            entry_idx = 0
            while entry_idx<len(reloc.entries):

                entry = reloc.entries[entry_idx]
                entry_idx += 1

                if entry.type == RELOCATION_TYPE['IMAGE_REL_BASED_ABSOLUTE']:
                    # Nothing to do for this type of relocation
                    pass

                elif entry.type == RELOCATION_TYPE['IMAGE_REL_BASED_HIGH']:
                    # Fix the high 16bits of a relocation
                    #
                    # Add high 16bits of relocation_difference to the
                    # 16bit value at RVA=entry.rva

                    self.set_word_at_rva(
                        entry.rva,
                        ( self.get_word_at_rva(entry.rva) + relocation_difference>>16)&0xffff )

                elif entry.type == RELOCATION_TYPE['IMAGE_REL_BASED_LOW']:
                    # Fix the low 16bits of a relocation
                    #
                    # Add low 16 bits of relocation_difference to the 16bit value
                    # at RVA=entry.rva

                    self.set_word_at_rva(
                        entry.rva,
                        ( self.get_word_at_rva(entry.rva) + relocation_difference)&0xffff)

                elif entry.type == RELOCATION_TYPE['IMAGE_REL_BASED_HIGHLOW']:
                    # Handle all high and low parts of a 32bit relocation
                    #
                    # Add relocation_difference to the value at RVA=entry.rva

                    self.set_dword_at_rva(
                        entry.rva,
                        self.get_dword_at_rva(entry.rva)+relocation_difference)

                elif entry.type == RELOCATION_TYPE['IMAGE_REL_BASED_HIGHADJ']:
                    # Fix the high 16bits of a relocation and adjust
                    #
                    # Add high 16bits of relocation_difference to the 32bit value
                    # composed from the (16bit value at RVA=entry.rva)<<16 plus
                    # the 16bit value at the next relocation entry.
                    #

                    # If the next entry is beyond the array's limits,
                    # abort... the table is corrupt
                    #
                    if entry_idx == len(reloc.entries):
                        break

                    next_entry = reloc.entries[entry_idx]
                    entry_idx += 1
                    self.set_word_at_rva( entry.rva,
                        ((self.get_word_at_rva(entry.rva)<<16) + next_entry.rva +
                        relocation_difference & 0xffff0000) >> 16 )

                elif entry.type == RELOCATION_TYPE['IMAGE_REL_BASED_DIR64']:
                    # Apply the difference to the 64bit value at the offset
                    # RVA=entry.rva

                    self.set_qword_at_rva(
                        entry.rva,
                        self.get_qword_at_rva(entry.rva) + relocation_difference)


    def verify_checksum(self):

        return self.OPTIONAL_HEADER.CheckSum == self.generate_checksum()


    def generate_checksum(self):

        # This will make sure that the data represeting the PE image
        # is updated with any changes that might have been made by
        # assigning values to header fields as those are not automatically
        # updated upon assignment.
        #
        self.__data__ = self.write()

        # Get the offset to the CheckSum field in the OptionalHeader
        #
        checksum_offset = self.OPTIONAL_HEADER.__file_offset__ + 0x40 # 64

        checksum = 0

        for i in range( len(self.__data__) / 4 ):

            # Skip the checksum field
            #
            if i == checksum_offset / 4:
                continue

            dword = struct.unpack('I', self.__data__[ i*4 : i*4+4 ])[0]
            checksum = (checksum & 0xffffffff) + dword + (checksum>>32)
            if checksum > 2**32:
                checksum = (checksum & 0xffffffff) + (checksum >> 32)

        checksum = (checksum & 0xffff) + (checksum >> 16)
        checksum = (checksum) + (checksum >> 16)
        checksum = checksum & 0xffff

        return checksum + len(self.__data__)


if __name__ == "__main__":
    import sys
    pe = PE(sys.argv[1])
    print pe


########NEW FILE########
__FILENAME__ = tkaskdir
#!/usr/bin/env python

# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This is used on Linux and Mac to prompt the user for the projects
# directory.

import sys

# Python3 and Python2-style imports.
try:
    from tkinter import Tk
    from tkinter.filedialog import askdirectory
except ImportError:
    from Tkinter import Tk
    from tkFileDialog import askdirectory

# Binary mode stdout for python3.
try:
    sys.stdout = sys.stdout.buffer
except:
    pass

# Create the TK canvas.

if __name__ == "__main__":
    root = Tk()
    root.withdraw()

    result = askdirectory(initialdir=sys.argv[1], parent=root, title="Select Ren'Py Projects Directory")
    sys.stdout.write(result.encode("utf8"))

########NEW FILE########
__FILENAME__ = None.edit
import renpy

# Do nothing when the editor is invoked.
Editor = renpy.editor.Editor

########NEW FILE########
__FILENAME__ = System Editor.edit
import renpy

# Pass the file off to the system editor (as determined by file associations).
Editor = renpy.editor.SystemEditor

########NEW FILE########
__FILENAME__ = generate_linebreak
# encoding: utf-8

# Based on: http://www.unicode.org/Public/UNIDATA/LineBreak.txt
# Based on: http://unicode.org/reports/tr14/#PairBasedImplementation

import re

breaking = """OP    CL    CP    QU    GL    NS    EX    SY    IS    PR    PO    NU    AL    HL    ID    IN    HY    BA    BB    B2    ZW    CM    WJ    H2    H3    JL    JV    JT    RI
OP    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    ^    @    ^    ^    ^    ^    ^    ^    ^
CL    _    ^    ^    %    %    ^    ^    ^    ^    %    %    _    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
CP    _    ^    ^    %    %    ^    ^    ^    ^    %    %    %    %    %    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
QU    ^    ^    ^    %    %    %    ^    ^    ^    %    %    %    %    %    %    %    %    %    %    %    ^    #    ^    %    %    %    %    %    %
GL    %    ^    ^    %    %    %    ^    ^    ^    %    %    %    %    %    %    %    %    %    %    %    ^    #    ^    %    %    %    %    %    %
NS    _    ^    ^    %    %    %    ^    ^    ^    _    _    _    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
EX    _    ^    ^    %    %    %    ^    ^    ^    _    _    _    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
SY    _    ^    ^    %    %    %    ^    ^    ^    _    _    %    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
IS    _    ^    ^    %    %    %    ^    ^    ^    _    _    %    %    %    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
PR    %    ^    ^    %    %    %    ^    ^    ^    _    _    %    %    %    %    _    %    %    _    _    ^    #    ^    %    %    %    %    %    _
PO    %    ^    ^    %    %    %    ^    ^    ^    _    _    %    %    %    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
NU    %    ^    ^    %    %    %    ^    ^    ^    %    %    %    %    %    _    %    %    %    _    _    ^    #    ^    _    _    _    _    _    _
AL    %    ^    ^    %    %    %    ^    ^    ^    _    _    %    %    %    _    %    %    %    _    _    ^    #    ^    _    _    _    _    _    _
HL    %    ^    ^    %    %    %    ^    ^    ^    _    _    %    %    %    _    %    %    %    _    _    ^    #    ^    _    _    _    _    _    _
ID    _    ^    ^    %    %    %    ^    ^    ^    _    %    _    _    _    _    %    %    %    _    _    ^    #    ^    _    _    _    _    _    _
IN    _    ^    ^    %    %    %    ^    ^    ^    _    _    _    _    _    _    %    %    %    _    _    ^    #    ^    _    _    _    _    _    _
HY    _    ^    ^    %    _    %    ^    ^    ^    _    _    %    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
BA    _    ^    ^    %    _    %    ^    ^    ^    _    _    _    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    _
BB    %    ^    ^    %    %    %    ^    ^    ^    %    %    %    %    %    %    %    %    %    %    %    ^    #    ^    %    %    %    %    %    %
B2    _    ^    ^    %    %    %    ^    ^    ^    _    _    _    _    _    _    _    %    %    _    ^    ^    #    ^    _    _    _    _    _    _
ZW    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _    ^    _    _    _    _    _    _    _    _
CM    %    ^    ^    %    %    %    ^    ^    ^    _    _    %    %    %    _    %    %    %    _    _    ^    #    ^    _    _    _    _    _    _
WJ    %    ^    ^    %    %    %    ^    ^    ^    %    %    %    %    %    %    %    %    %    %    %    ^    #    ^    %    %    %    %    %    %
H2    _    ^    ^    %    %    %    ^    ^    ^    _    %    _    _    _    _    %    %    %    _    _    ^    #    ^    _    _    _    %    %    _
H3    _    ^    ^    %    %    %    ^    ^    ^    _    %    _    _    _    _    %    %    %    _    _    ^    #    ^    _    _    _    _    %    _
JL    _    ^    ^    %    %    %    ^    ^    ^    _    %    _    _    _    _    %    %    %    _    _    ^    #    ^    %    %    %    %    _    _
JV    _    ^    ^    %    %    %    ^    ^    ^    _    %    _    _    _    _    %    %    %    _    _    ^    #    ^    _    _    _    %    %    _
JT    _    ^    ^    %    %    %    ^    ^    ^    _    %    _    _    _    _    %    %    %    _    _    ^    #    ^    _    _    _    _    %    _
RI    _    ^    ^    %    %    %    ^    ^    ^    _    _    _    _    _    _    _    %    %    _    _    ^    #    ^    _    _    _    _    _    %
"""

other_classes = " PITCH AI BK CB CJ CR LF NL SA SG SP XX"

lines = breaking.split("\n")

print "# This is generated code. Do not edit."
print

# A map from character class to the number that represents it.
cl = { }


for i, j in enumerate((lines[0] + other_classes).split()):
    print "cdef char BC_{} = {}".format(j, i)
    cl[j] = i

print "CLASSES = {"

for i, j in enumerate((lines[0] + other_classes).split()):
    print "    \"{}\" : {},".format(j, i)
    cl[j] = i

print "}"

rules = [ ]

for l in lines[1:]:
    for c in l.split()[1:]:
        rules.append(c)

print
print "cdef char *break_rules = \"" + "".join(rules) + "\""

cc = [ 'XX' ] * 65536

for l in file("LineBreak.txt"):
    m = re.match("(\w+)\.\.(\w+);(\w\w)", l)
    if m:
        start = int(m.group(1), 16)
        end = int(m.group(2), 16)

        if start > 65535:
            continue

        if end > 65535:
            end = 65535

        for i in range(start, end + 1):
            cc[i] = m.group(3)

        continue

    m = re.match("(\w+);(\w\w)", l)
    if m:
        start = int(m.group(1), 16)

        if start > 65535:
            continue

        cc[start] = m.group(2)
        continue

def generate(name, func):

    ncc = [ ]

    for i, ccl in enumerate(cc):
        ncc.append(func(i, ccl))

    assert "CJ" not in ncc
    assert "AI" not in ncc

    print "cdef char *break_" + name + " = \"" + "".join("\\x%02x" % cl[i] for i in ncc) + "\""

def western(i, cl):
    if cl == "CJ":
        return "ID"
    elif cl == "AI":
        return "AL"

    return cl

hyphens = [ 0x2010, 0x2013, 0x301c, 0x30a0 ]

iteration = [ 0x3005, 0x303B, 0x309D, 0x309E, 0x30FD, 0x30FE ]
inseperable = [ 0x2025, 0x2026 ]

centered = [ 0x003A, 0x003B, 0x30FB, 0xff1a, 0xff1b, 0xff65, 0x0021, 0x003f, 0x203c, 0x2047, 0x2048, 0x2049, 0xff01, 0xff1f ]
postfixes = [ 0x0025, 0x00A2, 0x00B0, 0x2030, 0x2032, 0x2033, 0x2103, 0xff05, 0xffe0 ]
prefixes = [ 0x0024, 0x00a3, 0x00a5, 0x20ac, 0x2116, 0xff04, 0xffe1, 0xffe5 ]

def cjk_strict(i, cl):

    if cl == "CJ":
        return "NS"
    if cl == "AI":
        return "ID"

    return cl

def cjk_normal(i, cl):

    if i in hyphens:
        return "ID"

    if cl == "CJ":
        return "ID"
    if cl == "AI":
        return "ID"

    return cl

def cjk_loose(i, cl):

    if i in hyphens:
        return "ID"
    if i in iteration:
        return "ID"
    if i in inseperable:
        return "ID"
    if i in centered:
        return "ID"
    if i in postfixes:
        return "ID"
    if i in prefixes:
        return "ID"

    if cl == "CJ":
        return "ID"
    if cl == "AI":
        return "ID"

    return cl

generate("western", western)
generate("cjk_strict", cjk_strict)
generate("cjk_normal", cjk_normal)
generate("cjk_loose", cjk_loose)

########NEW FILE########
__FILENAME__ = generate_styles
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import print_function, unicode_literals, division, absolute_import

str = unicode # @ReservedAssignment

import collections
import os

try:
    from io import StringIO
except:
    from StringIO import StringIO

# Paths
BASE = os.path.dirname(os.path.abspath(__file__))
ROOT = os.path.dirname(BASE)

def sorted_dict(**kwargs):
    """
    Constructs an ordered_dict from the keyword arguments in sorted order.
    """

    items = list(kwargs.items())
    return collections.OrderedDict(items)

################################################################################
# Prefixes
################################################################################

# A map from prefix name to Prefix object.
prefixes = collections.OrderedDict()

class Prefix(object):
    def __init__(self, index, name, priority, alts):

        # The index of where this prefix is stored in memory, or -1 if this
        # prefix isn't stored in memory.
        self.index = index

        # The name of this prefix.
        self.name = name

        # The priority of this prefix. When added at the same time, higher
        # priority prefixes take precendence over lower priority prefixes.
        self.priority = priority

        # A list of prefix indexes that should be updated when this prefix is
        # updated, including this prefix.
        if index >= 0:
            self.alts = [ self.index ]
            self.alt_names = [ self.name ]
        else:
            self.alts = [ ]
            self.alt_names = [ ]

        for i in alts:
            self.alts.append(prefixes[i].index)
            self.alt_names.append(i)

        prefixes[name] = self

# The number of priority levels we have.
PRIORITY_LEVELS = 4

# The number of prefixes we have.
PREFIX_COUNT = 6

Prefix(5, 'selected_hover_', 3, [ ])
Prefix(4, 'selected_idle_', 3, [ ])
Prefix(3, 'selected_insensitive_', 3, [ ])
Prefix(-3, 'selected_', 2, [ "selected_hover_", "selected_idle_", "selected_insensitive_" ])
Prefix(2, 'hover_', 1, [ "selected_hover_" ])
Prefix(1, 'idle_', 1, [ "selected_idle_" ] )
Prefix(0, 'insensitive_', 1, [ "selected_insensitive_" ])
Prefix(-4, '', 0, [ "selected_hover_", "selected_idle_", "selected_insensitive_", "idle_", "hover_", "insensitive_" ] )

Prefix(-2, 'activate_', 0, [ ])
Prefix(-1, 'selected_activate_', 0, [ ])


################################################################################
# Style Properties
################################################################################

# All the style properties we know about. This is a dict, that maps each style
# to a function that is called when it is set, or None if no such function
# is needed.
style_properties = sorted_dict(
    activate_sound = None,
    aft_bar = 'none_is_null',
    aft_gutter = None,
    antialias = None,
    vertical = None,
    background = 'renpy.easy.displayable_or_none',
    bar_invert = None,
    bar_resizing = None,
    unscrollable = None,
    bar_vertical = None,
    black_color = 'renpy.easy.color',
    bold = None,
    bottom_margin = None,
    bottom_padding = None,
    box_layout = None,
    box_reverse = None,
    box_wrap = None,
    caret = 'renpy.easy.displayable_or_none',
    child = 'renpy.easy.displayable_or_none',
    clipping = None,
    color = 'renpy.easy.color',
    drop_shadow = None,
    drop_shadow_color = 'renpy.easy.color',
    first_indent = None,
    first_spacing = None,
    fit_first = None,
    focus_mask = None,
    focus_rect = None,
    font = None,
    fore_bar = 'none_is_null',
    fore_gutter = None,
    foreground = 'renpy.easy.displayable_or_none',
    hover_sound = None,
    hyperlink_functions=None,
    italic = None,
    justify = None,
    kerning = None,
    language = None,
    layout = None,
    line_leading = None,
    left_margin = None,
    line_overlap_split=None,
    left_padding = None,
    line_spacing = None,
    mouse = None,
    min_width = None,
    newline_indent = None,
    order_reverse = None,
    outlines = 'expand_outlines',
    rest_indent = None,
    right_margin = None,
    right_padding = None,
    ruby_style = None,
    size = None,
    size_group = None,
    slow_abortable = None,
    slow_cps = None,
    slow_cps_multiplier = None,
    spacing = None,
    strikethrough = None,
    subtitle_width = None,
    subpixel = None,
    text_y_fudge = None,
    text_align = None,
    thumb = 'none_is_null',
    thumb_offset = None,
    thumb_shadow = 'none_is_null',
    time_policy = None,
    top_margin = None,
    top_padding = None,
    underline = None,
    xanchor = 'expand_anchor',
    xfill = None,
    xmaximum = None,
    xminimum = None,
    xoffset = None,
    xpos = None,
    yanchor = 'expand_anchor',
    yfill = None,
    ymaximum = None,
    yminimum = None,
    yoffset = None,
    ypos = None,
    )

# A map from a style property to its index in the order of style_properties.
style_property_index = collections.OrderedDict()
for i, name in enumerate(style_properties):
    style_property_index[name] = i

style_property_count = len(style_properties)

# print("{} properties * {} prefixes = {} cache entries".format(
#     style_property_count, PREFIX_COUNT, style_property_count * PREFIX_COUNT))

# A list of synthetic style properties, where each property is expanded into
# multiple style properties. Each property are mapped into a list of tuples,
# with each consisting of:
#
# * The name of the style to assign.
# * A string giving the name of a functon to call to get the value to assign, a constant
#   numeric value, or None to not change the argument.
synthetic_properties = sorted_dict(
    xmargin = [
        ('left_margin', None),
        ('right_margin', None)
        ],

    ymargin = [
        ('top_margin', None),
        ('bottom_margin', None),
        ],

    xalign = [
        ('xpos', None),
        ('xanchor', None),
        ],

    yalign = [
        ('ypos', None),
        ('yanchor', None),
        ],

    xpadding = [
        ('left_padding', None),
        ('right_padding', None),
        ],

    ypadding = [
        ('top_padding', None),
        ('bottom_padding', None),
        ],

    minwidth = [ ('min_width', None) ],
    textalign = [ ('text_align', None) ],
    slow_speed = [ ('slow_cps', None) ],
    enable_hover = [ ],
    left_gutter = [ ('fore_gutter', None) ],
    right_gutter = [ ('aft_gutter', None) ],
    top_gutter = [ ('fore_gutter', None) ],
    bottom_gutter = [ ('aft_gutter', None) ],
    left_bar = [ ('fore_bar', None) ],
    right_bar = [ ('aft_bar', None) ],
    top_bar = [ ('fore_bar', None) ],
    bottom_bar = [ ('aft_bar', None) ],
    box_spacing = [ ( 'spacing', None ) ],
    box_first_spacing = [ ( 'first_spacing', None) ],

    pos = [
        ('xpos', 'index_0'),
        ('ypos', 'index_1'),
        ],

    anchor = [
        ('xanchor', 'index_0'),
        ('yanchor', 'index_1'),
        ],

    # Conflicts w/ a variable used in the Style implementation.
    # offset = [
    #     ('xoffset', index_0),
    #     ('yoffset', index_1),
    #     ],

    align = [
        ('xpos', 'index_0'),
        ('ypos', 'index_1'),
        ('xanchor', 'index_0'),
        ('yanchor', 'index_1'),
        ],

    maximum = [
        ('xmaximum', 'index_0'),
        ('ymaximum', 'index_1'),
        ],

    minimum = [
        ('xminimum', 'index_0'),
        ('yminimum', 'index_1'),
        ],

    xsize = [
        ('xminimum', None),
        ('xmaximum', None),
        ],

    ysize = [
        ('yminimum', None),
        ('ymaximum', None),
        ],

    xysize = [
        ('xminimum', 'index_0'),
        ('xmaximum', 'index_0'),
        ('yminimum', 'index_1'),
        ('ymaximum', 'index_1'),
        ],

    area = [
        ('xpos', 'index_0'),
        ('ypos', 'index_1'),
        ('xanchor', 0),
        ('yanchor', 0),
        ('xfill', True),
        ('yfill', True),
        ('xmaximum', 'index_2'),
        ('ymaximum', 'index_3'),
        ('xminimum', 'index_2'),
        ('yminimum', 'index_3'),
        ],

    xcenter = [
        ('xpos', None),
        ('xanchor', 0.5),
        ],

    ycenter = [
        ('ypos', None),
        ('yanchor', 0.5),
        ],
    )

all_properties = collections.OrderedDict()

for k, v in style_properties.items():
    all_properties[k] = [ (k, None) ]

all_properties.update(synthetic_properties)

################################################################################
# Code Generation
################################################################################

class CodeGen(object):
    """
    Utility class for code generation.

    `filename`
        The name of the file we code-generate into.
    `spew`
        If true, spew the generated code to stdout.
    """

    def __init__(self, filename, spew=False):
        self.filename = os.path.join(ROOT, filename)
        self.f = StringIO()
        self.depth = 0
        self.spew = spew

    def close(self):

        text = self.f.getvalue()

        if os.path.exists(self.filename):
            with open(self.filename, "rb") as f:
                old = f.read()

            if old == text:
                return

        with open(self.filename, "wb") as f:
            f.write(text)

    def write(self, s, *args, **kwargs):
        out = "    " * self.depth
        out += s.format(*args, **kwargs)
        out = out.rstrip()

        if self.spew:
            print(out)

        out += "\n"
        self.f.write(out)

    def indent(self):
        self.depth += 1

    def dedent(self):
        self.depth -= 1


def generate_constants():
    """
    This generates code that defines the property functions.
    """

    g = CodeGen("module/gen/styleconstants.pxi")

    g.write("DEF PRIORITY_LEVELS = {}", PRIORITY_LEVELS)
    g.write("DEF PREFIX_COUNT = {}", PREFIX_COUNT)
    g.write("DEF STYLE_PROPERTY_COUNT = {}", style_property_count)

    for p in prefixes.values():
        if p.index < 0:
            continue

        g.write("DEF {}PREFIX = {}", p.name.upper(), p.index * style_property_count)

    for k in style_properties:
        g.write("DEF {}_INDEX = {}", k.upper(), style_property_index[k])

    g.close()

def generate_property_function(g, prefix, propname, properties):
    name = prefix.name + propname

    g.write("cdef int {name}_property(PyObject **cache, int *cache_priorities, int priority, object value) except -1:", name=name)
    g.indent()

    g.write("priority += {}", prefix.priority)

    for stylepropname, func in properties:
        value = "value"

        g.write("")

        if isinstance(func, str):
            g.write("v = {func}({value})", func=func, value=value)
            value = "v"
        elif func is not None:
            g.write("v = {}", func)
            value = "v"

        propfunc = style_properties[stylepropname]

        if propfunc is not None:
            g.write("v = {propfunc}({value})", propfunc=propfunc, value=value)
            value = "v"

        for alt, alt_name in zip(prefix.alts, prefix.alt_names):
            g.write("assign({}, cache, cache_priorities, priority, <PyObject *> {}) # {}{}",
                alt * len(style_properties) + style_property_index[stylepropname],
                value, alt_name, stylepropname)

    g.write("return 0")
    g.dedent()

    g.write("")
    g.write('register_property_function("{}", {}_property)', name, name)
    g.write("")

    pass

def generate_property_functions():
    """
    This generates code that defines the property functions.
    """

    g = CodeGen("module/gen/stylepropertyfunctions.pxi")

    for propname, proplist in all_properties.items():
        for prefix in sorted(prefixes.values(), key=lambda p : p.index):
            generate_property_function(g, prefix, propname, proplist)

    g.close()

def generate_property(g, propname, prefix):
    """
    This generates the code for a single property on the style object.
    """

    name = prefix.name + propname

    g.write("property {}:", name)
    g.indent()

    if name in style_properties:
        # __get__
        g.write("def __get__(self):")
        g.indent()
        g.write("return self._get({})", style_property_index[propname])
        g.dedent()

    # __set__
    g.write("def __set__(self, value):")
    g.indent()
    g.write("self.properties.append({{ '{}' : value }})", name)
    g.dedent()

    # __del__
    g.write("def __del__(self):")
    g.indent()
    g.write("self.delattr('{}')", name)
    g.dedent()

    g.dedent()
    g.write("")

def generate_properties():

    g = CodeGen("module/gen/styleproperties.pxi")

    g.write("cdef class Style(StyleCore):")
    g.write("")

    g.indent()

    for propname in all_properties:
        for prefix in sorted(prefixes.values(), key=lambda p : p.index):
            generate_property(g, propname, prefix)

    g.dedent()
    g.close()

def generate_sets():
    """
    Generates code for sets of properties.
    """

    ap = collections.OrderedDict()

    for k, v in all_properties.items():
        ap[k] = [ i[0] for i in v ]

    prefix_priority = collections.OrderedDict()
    prefix_alts = collections.OrderedDict()

    for p in prefixes.values():
        prefix_priority[p.name] = p.priority
        prefix_alts[p.name] = p.alt_names

    g = CodeGen("module/gen/stylesets.pxi")

    g.write("# This file is generated by generate_styles.py.")
    g.write("")
    g.write('exec """\\')
    g.write("all_properties = {}", ap)
    g.write("prefix_priority = {}", prefix_priority)
    g.write("prefix_alts = {}", prefix_alts)
    g.write('"""')
    g.close()


def generate():
    generate_constants()
    generate_property_functions()
    generate_properties()
    generate_sets()

if __name__ == "__main__":
    generate()

########NEW FILE########
__FILENAME__ = maketegl
# tegl.c  -*- coding: utf-8 -*-

# Copyright (c) 2008 Carl Banks
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the Author nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

# Modified in 2010 by PyTom to generate Cython code that uses glew.

VERSION = "0.1"

import sys

#-----------------------------------------------------------------------
# Options

# Module names (you can specify the same name to put gl and glu
# functions in the same module).

# Enable or disable extensions

OPENGL_1_2 = True
OPENGL_1_3 = True
OPENGL_1_4 = False
OPENGL_1_5 = False
OPENGL_2_0 = False
OPENGL_2_1 = False
GL_ARB_IMAGING = False
GL_ARB_MULTITEXTURE = True
GL_ARB_WINDOW_POS = False
GL_ARB_TRANSPOSE_MATRIX = False
GL_ARB_MULTISAMPLE = False
GL_ARB_TEXTURE_CUBE_MAP = False
GL_ARB_TEXTURE_COMPRESSION = False
GL_ARB_TEXTURE_BORDER_CLAMP = False
GL_ARB_POINT_PARAMETERS = False
GL_ARB_VERTEX_BLEND = False
GL_ARB_MATRIX_PALETTE = False
GL_ARB_TEXTURE_ENV_COMBINE = True
GL_ARB_TEXTURE_ENV_DOT3 = False
GL_ARB_TEXTURE_MIRRORED_REPEAT = False
GL_ARB_DEPTH_TEXTURE = False
GL_ARB_SHADOW = False
GL_ARB_SHADOW_AMBIENT = False
GL_ARB_VERTEX_PROGRAM = True
GL_ARB_FRAGMENT_PROGRAM = True
GL_ARB_VERTEX_BUFFER_OBJECT = True
GL_ARB_OCCLUSION_QUERY = False
GL_ARB_SHADER_OBJECTS = True
GL_ARB_VERTEX_SHADER = True
GL_ARB_FRAGMENT_SHADER = True
GL_ARB_SHADING_LANGUAGE_100 = True
GL_ARB_POINT_SPRITE = False
GL_ARB_DRAW_BUFFERS = False
GL_ARB_TEXTURE_RECTANGLE = False
GL_ARB_COLOR_BUFFER_FLOAT = False
GL_ARB_HALF_FLOAT_PIXEL = False
GL_ARB_TEXTURE_FLOAT = False
GL_ARB_PIXEL_BUFFER_OBJECT = False

GL_EXT_FRAMEBUFFER_OBJECT = True


#-----------------------------------------------------------------------
# generate tegl.c

def generate_tegl():

    # -------- GL Function Prototypes --------

    # Miscellaneous
    declare("ClearIndex",GLfloat)
    declare("ClearColor",GLclampf,GLclampf,GLclampf,GLclampf)
    declare("Clear",GLbitfield)
    declare("IndexMask",GLuint)
    declare("ColorMask",GLboolean,GLboolean,GLboolean,GLboolean)
    declare("AlphaFunc",GLenum,GLclampf)
    declare("BlendFunc",GLenum,GLenum)
    declare("LogicOp",GLenum)
    declare("CullFace",GLenum)
    declare("FrontFace",GLenum)
    declare("PointSize",GLfloat)
    declare("LineWidth",GLfloat)
    declare("LineStipple",GLint,GLushort)
    declare("PolygonMode",GLenum,GLenum)
    declare("PolygonOffset",GLfloat,GLfloat)
    declare("PolygonStipple",GLbuffer)
    declare("GetPolygonStipple",GLbuffer.asreturn())
    declare("EdgeFlag",GLboolean)
    declare("EdgeFlagv",GLboolean[1])
    declare("Scissor",GLint,GLint,GLsizei,GLsizei)
    declare("ClipPlane",GLenum,GLdouble[4])
    declare("GetClipPlane",GLenum,GLdouble[4].asreturn())
    declare("DrawBuffer",GLenum)
    declare("ReadBuffer",GLenum)
    declare("Enable",GLenum)
    declare("Disable",GLenum)
    declare(GLboolean,"IsEnabled",GLenum);
    declare("EnableClientState",GLenum)
    declare("DisableClientState",GLenum)
    declare("GetBooleanv",GLenum,GLboolean[4].asreturn())
    declare("GetDoublev",GLenum,GLdouble[4].asreturn())
    declare("GetFloatv",GLenum,GLfloat[4].asreturn())
    declare("GetIntegerv",GLenum,GLint[4].asreturn())
    declare("PushAttrib",GLbitfield)
    declare("PopAttrib")
    declare("PushClientAttrib",GLbitfield)
    declare("PopClientAttrib")
    declare(GLint,"RenderMode",GLenum);
    declare(GLenum,"GetError");
    declare(GLstring, "GetString", GLenum)
    declare("Finish")
    declare("Flush")
    declare("Hint",GLenum,GLenum)

    # Depth Buffer
    declare("ClearDepth",GLclampd)
    declare("DepthFunc",GLenum)
    declare("DepthMask",GLboolean)
    declare("DepthRange",GLclampd,GLclampd)

    # Accumulation Buffer
    declare("ClearAccum",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("Accum",GLenum,GLfloat)

    # Transformation
    declare("MatrixMode",GLenum)
    declare("Ortho",GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
    declare("Frustum",GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
    declare("Viewport",GLint,GLint,GLsizei,GLsizei)
    declare("PushMatrix")
    declare("PopMatrix")
    declare("LoadIdentity")
    declare("LoadMatrixd",GLdouble[16])
    declare("LoadMatrixf",GLfloat[16])
    declare("MultMatrixd",GLdouble[16])
    declare("MultMatrixf",GLfloat[16])
    declare("Rotated",GLdouble,GLdouble,GLdouble,GLdouble)
    declare("Rotatef",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("Scaled",GLdouble,GLdouble,GLdouble)
    declare("Scalef",GLfloat,GLfloat,GLfloat)
    declare("Translated",GLdouble,GLdouble,GLdouble)
    declare("Translatef",GLfloat,GLfloat,GLfloat)

    # Display Lists
    declare(GLboolean,"IsList",GLuint);
    declare("DeleteLists",GLuint,GLsizei)
    declare(GLuint,"GenLists",GLsizei);
    declare("NewList",GLuint,GLenum)
    declare("EndList")
    declare("CallList",GLuint)
    declare("CallLists",GLsizei,GLenum,GLbuffer)
    declare("ListBase",GLuint)

    # Drawing Functions
    declare("Begin",GLenum)
    declare("End")
    declare("Vertex2d",GLdouble,GLdouble)
    declare("Vertex2f",GLfloat,GLfloat)
    declare("Vertex2i",GLint,GLint)
    declare("Vertex2s",GLshort,GLshort)
    declare("Vertex3d",GLdouble,GLdouble,GLdouble)
    declare("Vertex3f",GLfloat,GLfloat,GLfloat)
    declare("Vertex3i",GLint,GLint,GLint)
    declare("Vertex3s",GLshort,GLshort,GLshort)
    declare("Vertex4d",GLdouble,GLdouble,GLdouble,GLdouble)
    declare("Vertex4f",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("Vertex4i",GLint,GLint,GLint,GLint)
    declare("Vertex4s",GLshort,GLshort,GLshort,GLshort)
    declare("Vertex2dv",GLdouble[2])
    declare("Vertex2fv",GLfloat[2])
    declare("Vertex2iv",GLint[2])
    declare("Vertex2sv",GLshort[2])
    declare("Vertex3dv",GLdouble[3])
    declare("Vertex3fv",GLfloat[3])
    declare("Vertex3iv",GLint[3])
    declare("Vertex3sv",GLshort[3])
    declare("Vertex4dv",GLdouble[4])
    declare("Vertex4fv",GLfloat[4])
    declare("Vertex4iv",GLint[4])
    declare("Vertex4sv",GLshort[4])
    declare("Normal3b",GLbyte,GLbyte,GLbyte)
    declare("Normal3d",GLdouble,GLdouble,GLdouble)
    declare("Normal3f",GLfloat,GLfloat,GLfloat)
    declare("Normal3i",GLint,GLint,GLint)
    declare("Normal3s",GLshort,GLshort,GLshort)
    declare("Normal3bv",GLbyte[3])
    declare("Normal3dv",GLdouble[3])
    declare("Normal3fv",GLfloat[3])
    declare("Normal3iv",GLint[3])
    declare("Normal3sv",GLshort[3])
    declare("Indexd",GLdouble)
    declare("Indexf",GLfloat)
    declare("Indexi",GLint)
    declare("Indexs",GLshort)
    declare("Indexub",GLubyte)
    declare("Indexdv",GLdouble[1])
    declare("Indexfv",GLfloat[1])
    declare("Indexiv",GLint[1])
    declare("Indexsv",GLshort[1])
    declare("Indexubv",GLubyte[1])
    declare("Color3b",GLbyte,GLbyte,GLbyte)
    declare("Color3d",GLdouble,GLdouble,GLdouble)
    declare("Color3f",GLfloat,GLfloat,GLfloat)
    declare("Color3i",GLint,GLint,GLint)
    declare("Color3s",GLshort,GLshort,GLshort)
    declare("Color3ub",GLubyte,GLubyte,GLubyte)
    declare("Color3ui",GLuint,GLuint,GLuint)
    declare("Color3us",GLushort,GLushort,GLushort)
    declare("Color4b",GLbyte,GLbyte,GLbyte,GLbyte)
    declare("Color4d",GLdouble,GLdouble,GLdouble,GLdouble)
    declare("Color4f",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("Color4i",GLint,GLint,GLint,GLint)
    declare("Color4s",GLshort,GLshort,GLshort,GLshort)
    declare("Color4ub",GLubyte,GLubyte,GLubyte,GLubyte)
    declare("Color4ui",GLuint,GLuint,GLuint,GLuint)
    declare("Color4us",GLushort,GLushort,GLushort,GLushort)
    declare("Color3bv",GLbyte[3])
    declare("Color3dv",GLdouble[3])
    declare("Color3fv",GLfloat[3])
    declare("Color3iv",GLint[3])
    declare("Color3sv",GLshort[3])
    declare("Color3ubv",GLubyte[3])
    declare("Color3uiv",GLuint[3])
    declare("Color3usv",GLushort[3])
    declare("Color4bv",GLbyte[4])
    declare("Color4dv",GLdouble[4])
    declare("Color4fv",GLfloat[4])
    declare("Color4iv",GLint[4])
    declare("Color4sv",GLshort[4])
    declare("Color4ubv",GLubyte[4])
    declare("Color4uiv",GLuint[4])
    declare("Color4usv",GLushort[4])
    declare("TexCoord1d",GLdouble)
    declare("TexCoord1f",GLfloat)
    declare("TexCoord1i",GLint)
    declare("TexCoord1s",GLshort)
    declare("TexCoord2d",GLdouble,GLdouble)
    declare("TexCoord2f",GLfloat,GLfloat)
    declare("TexCoord2i",GLint,GLint)
    declare("TexCoord2s",GLshort,GLshort)
    declare("TexCoord3d",GLdouble,GLdouble,GLdouble)
    declare("TexCoord3f",GLfloat,GLfloat,GLfloat)
    declare("TexCoord3i",GLint,GLint,GLint)
    declare("TexCoord3s",GLshort,GLshort,GLshort)
    declare("TexCoord4d",GLdouble,GLdouble,GLdouble,GLdouble)
    declare("TexCoord4f",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("TexCoord4i",GLint,GLint,GLint,GLint)
    declare("TexCoord4s",GLshort,GLshort,GLshort,GLshort)
    declare("TexCoord1dv",GLdouble[1])
    declare("TexCoord1fv",GLfloat[1])
    declare("TexCoord1iv",GLint[1])
    declare("TexCoord1sv",GLshort[1])
    declare("TexCoord2dv",GLdouble[2])
    declare("TexCoord2fv",GLfloat[2])
    declare("TexCoord2iv",GLint[2])
    declare("TexCoord2sv",GLshort[2])
    declare("TexCoord3dv",GLdouble[3])
    declare("TexCoord3fv",GLfloat[3])
    declare("TexCoord3iv",GLint[3])
    declare("TexCoord3sv",GLshort[3])
    declare("TexCoord4dv",GLdouble[4])
    declare("TexCoord4fv",GLfloat[4])
    declare("TexCoord4iv",GLint[4])
    declare("TexCoord4sv",GLshort[4])
    declare("RasterPos2d",GLdouble,GLdouble)
    declare("RasterPos2f",GLfloat,GLfloat)
    declare("RasterPos2i",GLint,GLint)
    declare("RasterPos2s",GLshort,GLshort)
    declare("RasterPos3d",GLdouble,GLdouble,GLdouble)
    declare("RasterPos3f",GLfloat,GLfloat,GLfloat)
    declare("RasterPos3i",GLint,GLint,GLint)
    declare("RasterPos3s",GLshort,GLshort,GLshort)
    declare("RasterPos4d",GLdouble,GLdouble,GLdouble,GLdouble)
    declare("RasterPos4f",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("RasterPos4i",GLint,GLint,GLint,GLint)
    declare("RasterPos4s",GLshort,GLshort,GLshort,GLshort)
    declare("RasterPos2dv",GLdouble[2])
    declare("RasterPos2fv",GLfloat[2])
    declare("RasterPos2iv",GLint[2])
    declare("RasterPos2sv",GLshort[2])
    declare("RasterPos3dv",GLdouble[3])
    declare("RasterPos3fv",GLfloat[3])
    declare("RasterPos3iv",GLint[3])
    declare("RasterPos3sv",GLshort[3])
    declare("RasterPos4dv",GLdouble[4])
    declare("RasterPos4fv",GLfloat[4])
    declare("RasterPos4iv",GLint[4])
    declare("RasterPos4sv",GLshort[4])
    declare("Rectd",GLdouble,GLdouble,GLdouble,GLdouble)
    declare("Rectf",GLfloat,GLfloat,GLfloat,GLfloat)
    declare("Recti",GLint,GLint,GLint,GLint)
    declare("Rects",GLshort,GLshort,GLshort,GLshort)
    declare("Rectdv",GLdouble[2],GLdouble[2])
    declare("Rectfv",GLfloat[2],GLfloat[2])
    declare("Rectiv",GLint[2],GLint[2])
    declare("Rectsv",GLshort[2],GLshort[2])

    # Vertex Arrays
    declare("VertexPointer",GLint,GLenum,GLsizei,GLbuffer)
    declare("NormalPointer",GLenum,GLsizei,GLbuffer)
    declare("ColorPointer",GLint,GLenum,GLsizei,GLbuffer)
    declare("IndexPointer",GLenum,GLsizei,GLbuffer)
    declare("TexCoordPointer",GLint,GLenum,GLsizei,GLbuffer)
    declare("EdgeFlagPointer",GLsizei,GLbuffer)
    #declare("GetPointerv",GLenum,GLvoid **params)
    declare("ArrayElement",GLint)
    declare("DrawArrays",GLenum,GLint,GLsizei)
    declare("DrawElements",GLenum,GLsizei,GLenum,GLbuffer)
    declare("InterleavedArrays",GLenum,GLsizei,GLbuffer)

    # Lighting
    declare("ShadeModel",GLenum)
    declare("Lightf",GLenum,GLenum,GLfloat)
    declare("Lighti",GLenum,GLenum,GLint)
    declare("Lightfv",GLenum,GLenum,GLfloat[4])
    declare("Lightiv",GLenum,GLenum,GLint[4])
    declare("GetLightfv",GLenum,GLenum,GLfloat[4].asreturn())
    declare("GetLightiv",GLenum,GLenum,GLint[4].asreturn())
    declare("LightModelf",GLenum,GLfloat)
    declare("LightModeli",GLenum,GLint)
    declare("LightModelfv",GLenum,GLfloat[4])
    declare("LightModeliv",GLenum,GLint[4])
    declare("Materialf",GLenum,GLenum,GLfloat)
    declare("Materiali",GLenum,GLenum,GLint)
    declare("Materialfv",GLenum,GLenum,GLfloat[4])
    declare("Materialiv",GLenum,GLenum,GLint[4])
    declare("GetMaterialfv",GLenum,GLenum,GLfloat[4].asreturn())
    declare("GetMaterialiv",GLenum,GLenum,GLint[4].asreturn())
    declare("ColorMaterial",GLenum,GLenum)

    # Raster functions
    declare("PixelZoom",GLfloat,GLfloat)
    declare("PixelStoref",GLenum,GLfloat)
    declare("PixelStorei",GLenum,GLint)
    declare("PixelTransferf",GLenum,GLfloat)
    declare("PixelTransferi",GLenum,GLint)
    declare("PixelMapfv",GLenum,GLsizei,GLbuffer)
    declare("PixelMapuiv",GLenum,GLsizei,GLbuffer)
    declare("PixelMapusv",GLenum,GLsizei,GLbuffer)
    declare("GetPixelMapfv",GLenum,GLbuffer.asreturn())
    declare("GetPixelMapuiv",GLenum,GLbuffer.asreturn())
    declare("GetPixelMapusv",GLenum,GLbuffer.asreturn())
    declare("Bitmap",GLsizei,GLsizei,GLfloat,GLfloat,GLfloat,GLfloat,GLbuffer)
    declare("ReadPixels",GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,GLbuffer.asreturn())
    declare("DrawPixels",GLsizei,GLsizei,GLenum,GLenum,GLbuffer)
    declare("CopyPixels",GLint,GLint,GLsizei,GLsizei,GLenum)

    # Stenciling
    declare("StencilFunc",GLenum,GLint,GLuint)
    declare("StencilMask",GLuint)
    declare("StencilOp",GLenum,GLenum,GLenum)
    declare("ClearStencil",GLint)

    # Texture mapping
    declare("TexGend",GLenum,GLenum,GLdouble)
    declare("TexGenf",GLenum,GLenum,GLfloat)
    declare("TexGeni",GLenum,GLenum,GLint)
    declare("TexGendv",GLenum,GLenum,GLdouble[4])
    declare("TexGenfv",GLenum,GLenum,GLfloat[4])
    declare("TexGeniv",GLenum,GLenum,GLint[4])
    declare("GetTexGendv",GLenum,GLenum,GLdouble[4].asreturn())
    declare("GetTexGenfv",GLenum,GLenum,GLfloat[4].asreturn())
    declare("GetTexGeniv",GLenum,GLenum,GLint[4].asreturn())
    declare("TexEnvf",GLenum,GLenum,GLfloat)
    declare("TexEnvi",GLenum,GLenum,GLint)
    declare("TexEnvfv",GLenum,GLenum,GLfloat[4])
    declare("TexEnviv",GLenum,GLenum,GLint[4])
    declare("GetTexEnvfv",GLenum,GLenum,GLfloat[4].asreturn())
    declare("GetTexEnviv",GLenum,GLenum,GLint[4].asreturn())
    declare("TexParameterf",GLenum,GLenum,GLfloat)
    declare("TexParameteri",GLenum,GLenum,GLint)
    declare("TexParameterfv",GLenum,GLenum,GLfloat[4])
    declare("TexParameteriv",GLenum,GLenum,GLint[4])
    declare("GetTexParameterfv",GLenum,GLenum,GLfloat[4].asreturn())
    declare("GetTexParameteriv",GLenum,GLenum,GLint[4].asreturn())
    declare("GetTexLevelParameterfv",GLenum,GLint,GLenum,GLfloat[4].asreturn())
    declare("GetTexLevelParameteriv",GLenum,GLint,GLenum,GLint[4].asreturn())
    declare("TexImage1D",GLenum,GLint,GLint,GLsizei,GLint,GLenum,GLenum,GLbuffer)
    declare("TexImage2D",GLenum,GLint,GLint,GLsizei,GLsizei,GLint,GLenum,GLenum,GLbuffer)
    declare("GetTexImage",GLenum,GLint,GLenum,GLenum,GLbuffer.asreturn())
    declare("BindTexture",GLenum,GLuint)
    declare(GLboolean,"IsTexture",GLuint);
    declare("TexSubImage1D",GLenum,GLint,GLint,GLsizei,GLenum,GLenum,GLbuffer)
    declare("TexSubImage2D",GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,GLbuffer)
    declare("CopyTexImage1D",GLenum,GLint,GLenum,GLint,GLint,GLsizei,GLint)
    declare("CopyTexImage2D",GLenum,GLint,GLenum,GLint,GLint,GLsizei,GLsizei,GLint)
    declare("CopyTexSubImage1D",GLenum,GLint,GLint,GLint,GLint,GLsizei)
    declare("CopyTexSubImage2D",GLenum,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei)
    declare("GenTextures",GLsizei,GLuint[1].asreturn())  ### not a dynamic size
    declare("DeleteTextures",GLsizei,GLuint[1])  ### not a dynamic size
    declare("PrioritizeTextures",GLsizei,GLuint[1],
            GLclampf[1])  ### not a dynamic size
    declare(GLboolean,"AreTexturesResident",GLsizei,GLuint[1],
            GLboolean[1].asreturn());  ### not a dynamic size

    # Evaluators
    declare("Map1d",GLenum,GLdouble,GLdouble,GLint,GLint,GLbuffer)
    declare("Map1f",GLenum,GLfloat,GLfloat,GLint,GLint,GLbuffer)
    declare("Map2d",GLenum,GLdouble,GLdouble,GLint,GLint,GLdouble,GLdouble,GLint,GLint,GLbuffer)
    declare("Map2f",GLenum,GLfloat,GLfloat,GLint,GLint,GLfloat,GLfloat,GLint,GLint,GLbuffer)
    declare("GetMapdv",GLenum,GLenum,GLbuffer.asreturn())
    declare("GetMapfv",GLenum,GLenum,GLbuffer.asreturn())
    declare("GetMapiv",GLenum,GLenum,GLbuffer.asreturn())
    declare("EvalCoord1d",GLdouble)
    declare("EvalCoord1f",GLfloat)
    declare("EvalCoord1dv",GLdouble[1])
    declare("EvalCoord1fv",GLfloat[1])
    declare("EvalCoord2d",GLdouble,GLdouble)
    declare("EvalCoord2f",GLfloat,GLfloat)
    declare("EvalCoord2dv",GLdouble[2])
    declare("EvalCoord2fv",GLfloat[2])
    declare("MapGrid1d",GLint,GLdouble,GLdouble)
    declare("MapGrid1f",GLint,GLfloat,GLfloat)
    declare("MapGrid2d",GLint,GLdouble,GLdouble,GLint,GLdouble,GLdouble)
    declare("MapGrid2f",GLint,GLfloat,GLfloat,GLint,GLfloat,GLfloat)
    declare("EvalPoint1",GLint)
    declare("EvalPoint2",GLint,GLint)
    declare("EvalMesh1",GLenum,GLint,GLint)
    declare("EvalMesh2",GLenum,GLint,GLint,GLint,GLint)

    # Fog
    declare("Fogf",GLenum,GLfloat)
    declare("Fogi",GLenum,GLint)
    declare("Fogfv",GLenum,GLfloat[4])
    declare("Fogiv",GLenum,GLint[4])

    # Selection and Feedback
    declare("FeedbackBuffer",GLsizei,GLenum,GLbuffer.asreturn())
    declare("PassThrough",GLfloat)
    declare("SelectBuffer",GLsizei,GLbuffer.asreturn())
    declare("InitNames")
    declare("LoadName",GLuint)
    declare("PushName",GLuint)
    declare("PopName")

    if OPENGL_1_2:
        declare("DrawRangeElements",GLenum,GLuint,
                GLuint,GLsizei,GLenum,GLbuffer)
        declare("TexImage3D",GLenum,GLint,GLint,GLsizei,GLsizei,GLsizei,GLint,
                GLenum,GLenum,GLbuffer)
        declare("TexSubImage3D",GLenum,GLint,GLint,GLint,GLint,GLsizei,
                GLsizei,GLsizei,GLenum,GLenum,GLbuffer)
        declare("CopyTexSubImage3D",GLenum,GLint,GLint,GLint,GLint,GLint,
                GLint,GLsizei,GLsizei)

    if GL_ARB_IMAGING:
        declare("ColorTable",GLenum,GLenum,GLsizei,GLenum,GLenum,GLbuffer)
        declare("ColorSubTable",GLenum,GLsizei,GLsizei,GLenum,GLenum,GLbuffer)
        declare("ColorTableParameteriv",GLenum,GLenum,GLint[4])
        declare("ColorTableParameterfv",GLenum,GLenum,GLfloat[4])
        declare("CopyColorSubTable",GLenum,GLsizei,GLint,GLint,GLsizei)
        declare("CopyColorTable",GLenum,GLenum,GLint,GLint,GLsizei)
        declare("GetColorTable",GLenum,GLenum,GLenum,GLbuffer.asreturn())
        declare("GetColorTableParameterfv",GLenum,GLenum,GLfloat[4].asreturn())
        declare("GetColorTableParameteriv",GLenum,GLenum,GLint[4].asreturn())
        declare("BlendEquation",GLenum)
        declare("BlendColor",GLclampf,GLclampf,GLclampf,GLclampf)
        declare("Histogram",GLenum,GLsizei,GLenum,GLboolean)
        declare("ResetHistogram",GLenum)
        declare("GetHistogram",GLenum,GLboolean,GLenum,GLenum,GLbuffer.asreturn())
        declare("GetHistogramParameterfv",GLenum,GLenum,GLfloat[1].asreturn())
        declare("GetHistogramParameteriv",GLenum,GLenum,GLint[1].asreturn())
        declare("Minmax",GLenum,GLenum,GLboolean)
        declare("ResetMinmax",GLenum)
        declare("GetMinmax",GLenum,GLboolean,GLenum,GLenum,GLbuffer.asreturn())
        declare("GetMinmaxParameterfv",GLenum,GLenum,GLfloat[1].asreturn())
        declare("GetMinmaxParameteriv",GLenum,GLenum,GLint[1].asreturn())
        declare("ConvolutionFilter1D",GLenum,GLenum,GLsizei,GLenum,GLenum,GLbuffer)
        declare("ConvolutionFilter2D",GLenum,GLenum,GLsizei,GLsizei,GLenum,GLenum,GLbuffer)
        declare("ConvolutionParameterf",GLenum,GLenum,GLfloat)
        declare("ConvolutionParameterfv",GLenum,GLenum,GLfloat[4])
        declare("ConvolutionParameteri",GLenum,GLenum,GLint)
        declare("ConvolutionParameteriv",GLenum,GLenum,GLint[4])
        declare("CopyConvolutionFilter1D",GLenum,GLenum,GLint,GLint,GLsizei)
        declare("CopyConvolutionFilter2D",GLenum,GLenum,GLint,GLint,GLsizei,GLsizei)
        declare("GetConvolutionFilter",GLenum,GLenum,GLenum,GLbuffer.asreturn())
        declare("GetConvolutionParameterfv",GLenum,GLenum,GLfloat[4].asreturn())
        declare("GetConvolutionParameteriv",GLenum,GLenum,GLint[4].asreturn())
        declare("SeparableFilter2D",GLenum,GLenum,GLsizei,GLsizei,GLenum,GLenum,GLbuffer,GLbuffer)
        declare("GetSeparableFilter",GLenum,GLenum,GLenum,GLbuffer.asreturn(),GLbuffer.asreturn(),
                GLbuffer.asreturn())

    if OPENGL_1_3:
        declare("ActiveTexture",GLenum)
        declare("ClientActiveTexture",GLenum)
        declare("CompressedTexImage1D",GLenum,GLint,GLenum,GLsizei,GLint,GLsizei,GLbuffer)
        declare("CompressedTexImage2D",GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,GLbuffer)
        declare("CompressedTexImage3D",GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,
                GLsizei,GLbuffer)
        declare("CompressedTexSubImage1D",GLenum,GLint,GLint,GLsizei,GLenum,GLsizei,GLbuffer)
        declare("CompressedTexSubImage2D",GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,
                GLsizei,GLbuffer)
        declare("CompressedTexSubImage3D",GLenum,GLint,GLint,GLint,GLint,GLsizei,GLsizei,
                GLsizei,GLenum,GLsizei,GLbuffer)
        declare("GetCompressedTexImage",GLenum,GLint,GLbuffer.asreturn())
        declare("MultiTexCoord1d",GLenum,GLdouble)
        declare("MultiTexCoord1dv",GLenum,GLdouble[1])
        declare("MultiTexCoord1f",GLenum,GLfloat)
        declare("MultiTexCoord1fv",GLenum,GLfloat[1])
        declare("MultiTexCoord1i",GLenum,GLint)
        declare("MultiTexCoord1iv",GLenum,GLint[1])
        declare("MultiTexCoord1s",GLenum,GLshort)
        declare("MultiTexCoord1sv",GLenum,GLshort[1])
        declare("MultiTexCoord2d",GLenum,GLdouble,GLdouble)
        declare("MultiTexCoord2dv",GLenum,GLdouble[2])
        declare("MultiTexCoord2f",GLenum,GLfloat,GLfloat)
        declare("MultiTexCoord2fv",GLenum,GLfloat[2])
        declare("MultiTexCoord2i",GLenum,GLint,GLint)
        declare("MultiTexCoord2iv",GLenum,GLint[2])
        declare("MultiTexCoord2s",GLenum,GLshort,GLshort)
        declare("MultiTexCoord2sv",GLenum,GLshort[2])
        declare("MultiTexCoord3d",GLenum,GLdouble,GLdouble,GLdouble)
        declare("MultiTexCoord3dv",GLenum,GLdouble[3])
        declare("MultiTexCoord3f",GLenum,GLfloat,GLfloat,GLfloat)
        declare("MultiTexCoord3fv",GLenum,GLfloat[3])
        declare("MultiTexCoord3i",GLenum,GLint,GLint,GLint)
        declare("MultiTexCoord3iv",GLenum,GLint[3])
        declare("MultiTexCoord3s",GLenum,GLshort,GLshort,GLshort)
        declare("MultiTexCoord3sv",GLenum,GLshort[3])
        declare("MultiTexCoord4d",GLenum,GLdouble,GLdouble,GLdouble,GLdouble)
        declare("MultiTexCoord4dv",GLenum,GLdouble[4])
        declare("MultiTexCoord4f",GLenum,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("MultiTexCoord4fv",GLenum,GLfloat[4])
        declare("MultiTexCoord4i",GLenum,GLint,GLint,GLint,GLint)
        declare("MultiTexCoord4iv",GLenum,GLint[4])
        declare("MultiTexCoord4s",GLenum,GLshort,GLshort,GLshort,GLshort)
        declare("MultiTexCoord4sv",GLenum,GLshort[4])
        declare("LoadTransposeMatrixd",GLdouble[16])
        declare("LoadTransposeMatrixf",GLfloat[16])
        declare("MultTransposeMatrixd",GLdouble[16])
        declare("MultTransposeMatrixf",GLfloat[16])
        declare("SampleCoverage",GLclampf,GLboolean)

    if GL_ARB_MULTITEXTURE:
        declare("ActiveTextureARB",GLenum)
        declare("ClientActiveTextureARB",GLenum)
        declare("MultiTexCoord1dARB",GLenum,GLdouble)
        declare("MultiTexCoord1dvARB",GLenum,GLdouble[1])
        declare("MultiTexCoord1fARB",GLenum,GLfloat)
        declare("MultiTexCoord1fvARB",GLenum,GLfloat[1])
        declare("MultiTexCoord1iARB",GLenum,GLint)
        declare("MultiTexCoord1ivARB",GLenum,GLint[1])
        declare("MultiTexCoord1sARB",GLenum,GLshort)
        declare("MultiTexCoord1svARB",GLenum,GLshort[1])
        declare("MultiTexCoord2dARB",GLenum,GLdouble,GLdouble)
        declare("MultiTexCoord2dvARB",GLenum,GLdouble[2])
        declare("MultiTexCoord2fARB",GLenum,GLfloat,GLfloat)
        declare("MultiTexCoord2fvARB",GLenum,GLfloat[2])
        declare("MultiTexCoord2iARB",GLenum,GLint,GLint)
        declare("MultiTexCoord2ivARB",GLenum,GLint[2])
        declare("MultiTexCoord2sARB",GLenum,GLshort,GLshort)
        declare("MultiTexCoord2svARB",GLenum,GLshort[2])
        declare("MultiTexCoord3dARB",GLenum,GLdouble,GLdouble,GLdouble)
        declare("MultiTexCoord3dvARB",GLenum,GLdouble[3])
        declare("MultiTexCoord3fARB",GLenum,GLfloat,GLfloat,GLfloat)
        declare("MultiTexCoord3fvARB",GLenum,GLfloat[3])
        declare("MultiTexCoord3iARB",GLenum,GLint,GLint,GLint)
        declare("MultiTexCoord3ivARB",GLenum,GLint[3])
        declare("MultiTexCoord3sARB",GLenum,GLshort,GLshort,GLshort)
        declare("MultiTexCoord3svARB",GLenum,GLshort[3])
        declare("MultiTexCoord4dARB",GLenum,GLdouble,GLdouble,GLdouble,GLdouble)
        declare("MultiTexCoord4dvARB",GLenum,GLdouble[4])
        declare("MultiTexCoord4fARB",GLenum,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("MultiTexCoord4fvARB",GLenum,GLfloat[4])
        declare("MultiTexCoord4iARB",GLenum,GLint,GLint,GLint,GLint)
        declare("MultiTexCoord4ivARB",GLenum,GLint[4])
        declare("MultiTexCoord4sARB",GLenum,GLshort,GLshort,GLshort,GLshort)
        declare("MultiTexCoord4svARB",GLenum,GLshort[4])

    if OPENGL_1_4:
        declare("BlendFuncSeparate",GLenum,GLenum,GLenum,GLenum)
        declare("FogCoordf",GLfloat)
        declare("FogCoordfv",GLfloat[4])
        declare("FogCoordd",GLdouble)
        declare("FogCoorddv",GLdouble[4])
        declare("FogCoordPointer",GLenum,GLsizei,GLbuffer)
        #declare("MultiDrawArrays",GLenum,GLbuffer,GLbuffer,GLsizei)
        #declare("MultiDrawElements",GLenum,GLsizei[],GLenum, const GLvoid**,GLsizei)
        declare("PointParameterf",GLenum,GLfloat)
        declare("PointParameterfv",GLenum,GLfloat[1])
        declare("PointParameteri",GLenum,GLint)
        declare("PointParameteriv",GLenum,GLint[1])
        declare("SecondaryColor3b",GLbyte,GLbyte,GLbyte)
        declare("SecondaryColor3bv",GLbyte[3])
        declare("SecondaryColor3d",GLdouble,GLdouble,GLdouble)
        declare("SecondaryColor3dv",GLdouble[3])
        declare("SecondaryColor3f",GLfloat,GLfloat,GLfloat)
        declare("SecondaryColor3fv",GLfloat[3])
        declare("SecondaryColor3i",GLint,GLint,GLint)
        declare("SecondaryColor3iv",GLint[3])
        declare("SecondaryColor3s",GLshort,GLshort,GLshort)
        declare("SecondaryColor3sv",GLshort[3])
        declare("SecondaryColor3ub",GLubyte,GLubyte,GLubyte)
        declare("SecondaryColor3ubv",GLubyte[3])
        declare("SecondaryColor3ui",GLuint,GLuint,GLuint)
        declare("SecondaryColor3uiv",GLuint[3])
        declare("SecondaryColor3us",GLushort,GLushort,GLushort)
        declare("SecondaryColor3usv",GLushort[3])
        declare("SecondaryColorPointer",GLint,GLenum,GLsizei,GLbuffer)
        declare("WindowPos2d",GLdouble,GLdouble)
        declare("WindowPos2dv",GLdouble[2])
        declare("WindowPos2f",GLfloat,GLfloat)
        declare("WindowPos2fv",GLfloat[2])
        declare("WindowPos2i",GLint,GLint)
        declare("WindowPos2iv",GLint[2])
        declare("WindowPos2s",GLshort,GLshort)
        declare("WindowPos2sv",GLshort[2])
        declare("WindowPos3d",GLdouble,GLdouble,GLdouble)
        declare("WindowPos3dv",GLdouble[3])
        declare("WindowPos3f",GLfloat,GLfloat,GLfloat)
        declare("WindowPos3fv",GLfloat[3])
        declare("WindowPos3i",GLint,GLint,GLint)
        declare("WindowPos3iv",GLint[3])
        declare("WindowPos3s",GLshort,GLshort,GLshort)
        declare("WindowPos3sv",GLshort[3])

    if OPENGL_1_5:
        # declare("GenQueries",GLsizei,GLuint[MAX_QUERY_ARRAY_SIZE].asreturn())  ### not a dynamic size
        # declare("DeleteQueries",GLsizei,GLuint[MAX_QUERY_ARRAY_SIZE])  ### not a dynamic size
        declare(GLboolean,"IsQuery",GLuint)
        declare("BeginQuery",GLenum,GLuint)
        declare("EndQuery",GLenum)
        declare("GetQueryiv",GLenum,GLenum,GLint[1].asreturn())
        declare("GetQueryObjectiv",GLuint,GLenum,GLint[1].asreturn())
        declare("GetQueryObjectuiv",GLuint,GLenum,GLuint[1].asreturn())
        declare("BindBuffer",GLenum,GLuint)
        # declare("DeleteBuffers",GLsizei,GLuint[MAX_BUFFER_ARRAY_SIZE])  ### not a dynamic size
        # declare("GenBuffers",GLsizei,GLuint[MAX_BUFFER_ARRAY_SIZE].asreturn())  ### not a dynamic size
        declare(GLboolean,"IsBuffer",GLuint)
        #declare("BufferData",GLenum,GLsizeiptr,GLbuffer,GLenum)
        #declare("BufferSubData",GLenum,GLintptr,GLsizeiptr,GLbuffer)
        #declare("GetBufferSubData",GLenum,GLintptr,GLsizeiptr,GLbuffer.asreturn())
        declare(GLpointer,"MapBuffer",GLenum,GLenum)
        declare(GLboolean,"UnmapBuffer",GLenum)
        declare("GetBufferParameteriv",GLenum,GLenum,GLint[1].asreturn())
        #declare("GetBufferPointerv",GLenum,GLenum,GLvoid**)

    if OPENGL_2_0:
        declare("BlendEquationSeparate",GLenum,GLenum)
        declare("DrawBuffers",GLsizei,GLenum[16])  ### not a dynamic size
        declare("StencilOpSeparate",GLenum,GLenum,GLenum,GLenum)
        declare("StencilFuncSeparate",GLenum,GLenum,GLint,GLuint)
        declare("StencilMaskSeparate",GLenum,GLuint)
        declare("AttachShader",GLuint,GLuint)
        declare("BindAttribLocation",GLuint,GLuint,GLstring)
        declare("CompileShader",GLuint)
        declare(GLuint,"CreateProgram")
        declare(GLuint,"CreateShader",GLenum)
        declare("DeleteProgram",GLuint)
        declare("DeleteShader",GLuint)
        declare("DetachShader",GLuint,GLuint)
        declare("DisableVertexAttribArray",GLuint)
        declare("EnableVertexAttribArray",GLuint)
        declare("GetActiveAttrib",GLuint,GLuint,GLsizei,GLsizei[1].asreturn(),
                GLint[1].asreturn(),GLenum[1].asreturn(),GLstring.asreturn())
        declare("GetActiveUniform",GLuint,GLuint,GLsizei,GLsizei[1].asreturn(),
                GLint[1].asreturn(),GLenum[1].asreturn(),GLstring.asreturn())
        declare("GetAttachedShaders",GLuint,GLsizei,GLsizei[1].asreturn(),
                GLbuffer.asreturn())
        declare(GLint,"GetAttribLocation",GLuint,GLstring)
        declare("GetProgramiv",GLuint,GLenum,GLint[1].asreturn())
        declare("GetProgramInfoLog",GLuint,GLsizei,GLsizei[1].asreturn(),
                GLstring.asreturn())
        declare("GetShaderiv",GLuint,GLenum,GLint[1].asreturn())
        declare("GetShaderInfoLog",GLuint,GLsizei,GLsizei[1].asreturn(),
                GLstring.asreturn())
        declare("GetShaderSource",GLuint,GLsizei,GLsizei[1].asreturn(),
                GLstring.asreturn())
        declare(GLint,"GetUniformLocation",GLuint,GLstring)
        declare("GetUniformfv",GLuint,GLint,GLfloat[16].asreturn())
        declare("GetUniformiv",GLuint,GLint,GLint[16].asreturn())
        declare("GetVertexAttribdv",GLuint,GLenum,GLdouble[1].asreturn())
        declare("GetVertexAttribfv",GLuint,GLenum,GLfloat[1].asreturn())
        declare("GetVertexAttribiv",GLuint,GLenum,GLint[1].asreturn())
        #declare("GetVertexAttribPointerv",GLuint,GLenum, GLvoid**)
        declare(GLboolean,"IsProgram",GLuint)
        declare(GLboolean,"IsShader",GLuint)
        declare("LinkProgram",GLuint)
        #declare("ShaderSource",GLuint,GLsizei,GLvoid**,GLint[])
        #handcoded("ShaderSource",4)
        declare("UseProgram",GLuint)
        declare("Uniform1f",GLint,GLfloat)
        declare("Uniform2f",GLint,GLfloat,GLfloat)
        declare("Uniform3f",GLint,GLfloat,GLfloat,GLfloat)
        declare("Uniform4f",GLint,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("Uniform1i",GLint,GLint)
        declare("Uniform2i",GLint,GLint,GLint)
        declare("Uniform3i",GLint,GLint,GLint,GLint)
        declare("Uniform4i",GLint,GLint,GLint,GLint,GLint)
        declare("Uniform1fv",GLint,GLsizei,GLfloat[1])
        declare("Uniform2fv",GLint,GLsizei,GLfloat[2])
        declare("Uniform3fv",GLint,GLsizei,GLfloat[3])
        declare("Uniform4fv",GLint,GLsizei,GLfloat[4])
        declare("Uniform1iv",GLint,GLsizei,GLint[1])
        declare("Uniform2iv",GLint,GLsizei,GLint[2])
        declare("Uniform3iv",GLint,GLsizei,GLint[3])
        declare("Uniform4iv",GLint,GLsizei,GLint[4])
        declare("UniformMatrix2fv",GLint,GLsizei,GLboolean,GLfloat[4])
        declare("UniformMatrix3fv",GLint,GLsizei,GLboolean,GLfloat[9])
        declare("UniformMatrix4fv",GLint,GLsizei,GLboolean,GLfloat[16])
        declare("ValidateProgram",GLuint)
        declare("VertexAttrib1d",GLuint,GLdouble)
        declare("VertexAttrib1dv",GLuint,GLdouble[1])
        declare("VertexAttrib1f",GLuint,GLfloat)
        declare("VertexAttrib1fv",GLuint,GLfloat[1])
        declare("VertexAttrib1s",GLuint,GLshort)
        declare("VertexAttrib1sv",GLuint,GLshort[1])
        declare("VertexAttrib2d",GLuint,GLdouble,GLdouble)
        declare("VertexAttrib2dv",GLuint,GLdouble[2])
        declare("VertexAttrib2f",GLuint,GLfloat,GLfloat)
        declare("VertexAttrib2fv",GLuint,GLfloat[2])
        declare("VertexAttrib2s",GLuint,GLshort,GLshort)
        declare("VertexAttrib2sv",GLuint,GLshort[2])
        declare("VertexAttrib3d",GLuint,GLdouble,GLdouble,GLdouble)
        declare("VertexAttrib3dv",GLuint,GLdouble[3])
        declare("VertexAttrib3f",GLuint,GLfloat,GLfloat,GLfloat)
        declare("VertexAttrib3fv",GLuint,GLfloat[3])
        declare("VertexAttrib3s",GLuint,GLshort,GLshort,GLshort)
        declare("VertexAttrib3sv",GLuint,GLshort[3])
        declare("VertexAttrib4Nbv",GLuint,GLbyte[4])
        declare("VertexAttrib4Niv",GLuint,GLint[4])
        declare("VertexAttrib4Nsv",GLuint,GLshort[4])
        declare("VertexAttrib4Nub",GLuint,GLubyte,GLubyte,GLubyte,GLubyte)
        declare("VertexAttrib4Nubv",GLuint,GLubyte[4])
        declare("VertexAttrib4Nuiv",GLuint,GLuint[4])
        declare("VertexAttrib4Nusv",GLuint,GLushort[4])
        declare("VertexAttrib4bv",GLuint,GLbyte[4])
        declare("VertexAttrib4d",GLuint,GLdouble,GLdouble,GLdouble,GLdouble)
        declare("VertexAttrib4dv",GLuint,GLdouble[4])
        declare("VertexAttrib4f",GLuint,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("VertexAttrib4fv",GLuint,GLfloat[4])
        declare("VertexAttrib4iv",GLuint,GLint[4])
        declare("VertexAttrib4s",GLuint,GLshort,GLshort,GLshort,GLshort)
        declare("VertexAttrib4sv",GLuint,GLshort[4])
        declare("VertexAttrib4ubv",GLuint,GLubyte[4])
        declare("VertexAttrib4uiv",GLuint,GLuint[4])
        declare("VertexAttrib4usv",GLuint,GLushort[4])
        declare("VertexAttribPointer",GLuint,GLint,GLenum,GLboolean,GLsizei,GLbuffer)

    if OPENGL_2_1:
        declare("UniformMatrix2x3fv",GLint,GLsizei,GLboolean,GLfloat[6])
        declare("UniformMatrix3x2fv",GLint,GLsizei,GLboolean,GLfloat[6])
        declare("UniformMatrix2x4fv",GLint,GLsizei,GLboolean,GLfloat[8])
        declare("UniformMatrix4x2fv",GLint,GLsizei,GLboolean,GLfloat[8])
        declare("UniformMatrix3x4fv",GLint,GLsizei,GLboolean,GLfloat[12])
        declare("UniformMatrix4x3fv",GLint,GLsizei,GLboolean,GLfloat[12])

    if GL_ARB_TRANSPOSE_MATRIX:
        declare("LoadTransposeMatrixfARB",GLfloat[16])
        declare("LoadTransposeMatrixdARB",GLdouble[16])
        declare("MultTransposeMatrixfARB",GLfloat[16])
        declare("MultTransposeMatrixdARB",GLdouble[16])

    if GL_ARB_MULTISAMPLE:
        declare("SampleCoverageARB",GLclampf,GLboolean)

    if GL_ARB_TEXTURE_COMPRESSION:
        declare("CompressedTexImage3DARB",GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,
                GLint,GLsizei,GLbuffer)
        declare("CompressedTexImage2DARB",GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,
                GLsizei,GLbuffer)
        declare("CompressedTexImage1DARB",GLenum,GLint,GLenum,GLsizei,GLint,GLsizei,
                GLbuffer)
        declare("CompressedTexSubImage3DARB",GLenum,GLint,GLint,GLint,GLint,GLsizei,
                GLsizei,GLsizei,GLenum,GLsizei,GLbuffer)
        declare("CompressedTexSubImage2DARB",GLenum,GLint,GLint,GLint,GLsizei,GLsizei,
                GLenum,GLsizei,GLbuffer)
        declare("CompressedTexSubImage1DARB",GLenum,GLint,GLint,GLsizei,GLenum,GLsizei,
                GLbuffer)
        declare("GetCompressedTexImageARB",GLenum,GLint,GLbuffer.asreturn())

    if GL_ARB_POINT_PARAMETERS:
        declare("PointParameterfARB",GLenum,GLfloat)
        declare("PointParameterfvARB",GLenum,GLfloat[1])

    if GL_ARB_VERTEX_BLEND:
        declare("WeightbvARB",GLint,GLbyte[32])  ### not a dynamic size
        declare("WeightsvARB",GLint,GLshort[32])  ### not a dynamic size
        declare("WeightivARB",GLint,GLint[32])  ### not a dynamic size
        declare("WeightfvARB",GLint,GLfloat[32])  ### not a dynamic size
        declare("WeightdvARB",GLint,GLdouble[32])  ### not a dynamic size
        declare("WeightubvARB",GLint,GLubyte[32])  ### not a dynamic size
        declare("WeightusvARB",GLint,GLushort[32])  ### not a dynamic size
        declare("WeightuivARB",GLint,GLuint[32])  ### not a dynamic size
        declare("WeightPointerARB",GLint,GLenum,GLsizei,GLbuffer)
        declare("VertexBlendARB",GLint)

    if GL_ARB_MATRIX_PALETTE:
        declare("CurrentPaletteMatrixARB",GLint)
        declare("MatrixIndexubvARB",GLint,GLubyte[32])  ### not a dynamic size
        declare("MatrixIndexusvARB",GLint,GLushort[32])  ### not a dynamic size
        declare("MatrixIndexuivARB",GLint,GLuint[32])  ### not a dynamic size
        declare("MatrixIndexPointerARB",GLint,GLenum,GLsizei,GLbuffer)

    if GL_ARB_WINDOW_POS:
        declare("WindowPos2dARB",GLdouble,GLdouble)
        declare("WindowPos2dvARB",GLdouble[2])
        declare("WindowPos2fARB",GLfloat,GLfloat)
        declare("WindowPos2fvARB",GLfloat[2])
        declare("WindowPos2iARB",GLint,GLint)
        declare("WindowPos2ivARB",GLint[2])
        declare("WindowPos2sARB",GLshort,GLshort)
        declare("WindowPos2svARB",GLshort[2])
        declare("WindowPos3dARB",GLdouble,GLdouble,GLdouble)
        declare("WindowPos3dvARB",GLdouble[3])
        declare("WindowPos3fARB",GLfloat,GLfloat,GLfloat)
        declare("WindowPos3fvARB",GLfloat[3])
        declare("WindowPos3iARB",GLint,GLint,GLint)
        declare("WindowPos3ivARB",GLint[3])
        declare("WindowPos3sARB",GLshort,GLshort,GLshort)
        declare("WindowPos3svARB",GLshort[3])

    if GL_ARB_FRAGMENT_PROGRAM or GL_ARB_VERTEX_PROGRAM:
        declare("VertexAttrib1dARB",GLuint,GLdouble)
        declare("VertexAttrib1dvARB",GLuint,GLdouble[1])
        declare("VertexAttrib1fARB",GLuint,GLfloat)
        declare("VertexAttrib1fvARB",GLuint,GLfloat[1])
        declare("VertexAttrib1sARB",GLuint,GLshort)
        declare("VertexAttrib1svARB",GLuint,GLshort[1])
        declare("VertexAttrib2dARB",GLuint,GLdouble,GLdouble)
        declare("VertexAttrib2dvARB",GLuint,GLdouble[2])
        declare("VertexAttrib2fARB",GLuint,GLfloat,GLfloat)
        declare("VertexAttrib2fvARB",GLuint,GLfloat[2])
        declare("VertexAttrib2sARB",GLuint,GLshort,GLshort)
        declare("VertexAttrib2svARB",GLuint,GLshort[2])
        declare("VertexAttrib3dARB",GLuint,GLdouble,GLdouble,GLdouble)
        declare("VertexAttrib3dvARB",GLuint,GLdouble[3])
        declare("VertexAttrib3fARB",GLuint,GLfloat,GLfloat,GLfloat)
        declare("VertexAttrib3fvARB",GLuint,GLfloat[3])
        declare("VertexAttrib3sARB",GLuint,GLshort,GLshort,GLshort)
        declare("VertexAttrib3svARB",GLuint,GLshort[3])
        declare("VertexAttrib4NbvARB",GLuint,GLbyte[4])
        declare("VertexAttrib4NivARB",GLuint,GLint[4])
        declare("VertexAttrib4NsvARB",GLuint,GLshort[4])
        declare("VertexAttrib4NubARB",GLuint,GLubyte,GLubyte,GLubyte,GLubyte)
        declare("VertexAttrib4NubvARB",GLuint,GLubyte[4])
        declare("VertexAttrib4NuivARB",GLuint,GLuint[4])
        declare("VertexAttrib4NusvARB",GLuint,GLushort[4])
        declare("VertexAttrib4bvARB",GLuint,GLbyte[4])
        declare("VertexAttrib4dARB",GLuint,GLdouble,GLdouble,GLdouble,GLdouble)
        declare("VertexAttrib4dvARB",GLuint,GLdouble[4])
        declare("VertexAttrib4fARB",GLuint,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("VertexAttrib4fvARB",GLuint,GLfloat[4])
        declare("VertexAttrib4ivARB",GLuint,GLint[4])
        declare("VertexAttrib4sARB",GLuint,GLshort,GLshort,GLshort,GLshort)
        declare("VertexAttrib4svARB",GLuint,GLshort[4])
        declare("VertexAttrib4ubvARB",GLuint,GLubyte[4])
        declare("VertexAttrib4uivARB",GLuint,GLuint[4])
        declare("VertexAttrib4usvARB",GLuint,GLushort[4])
        declare("VertexAttribPointerARB",GLuint,GLint,GLenum,GLboolean,GLsizei,GLbuffer)
        declare("EnableVertexAttribArrayARB",GLuint)
        declare("DisableVertexAttribArrayARB",GLuint)
        declare("ProgramStringARB",GLenum,GLenum,GLsizei,GLbuffer)
        declare("BindProgramARB",GLenum,GLuint)
        declare("DeleteProgramsARB",GLsizei,
                 GLuint[1])  ### not a dynamic size
        declare("GenProgramsARB",GLsizei,
                 GLuint[1].asreturn())  ### not a dynamic size
        declare("ProgramEnvParameter4dARB",GLenum,GLuint,GLdouble,GLdouble,GLdouble,GLdouble)
        declare("ProgramEnvParameter4dvARB",GLenum,GLuint,GLdouble[4])
        declare("ProgramEnvParameter4fARB",GLenum,GLuint,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("ProgramEnvParameter4fvARB",GLenum,GLuint,GLfloat[4])
        declare("ProgramLocalParameter4dARB",GLenum,GLuint,GLdouble,GLdouble,GLdouble,GLdouble)
        declare("ProgramLocalParameter4dvARB",GLenum,GLuint,GLdouble[4])
        declare("ProgramLocalParameter4fARB",GLenum,GLuint,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("ProgramLocalParameter4fvARB",GLenum,GLuint,GLfloat[4])
        declare("GetProgramEnvParameterdvARB",GLenum,GLuint,GLdouble[4].asreturn())
        declare("GetProgramEnvParameterfvARB",GLenum,GLuint,GLfloat[4].asreturn())
        declare("GetProgramLocalParameterdvARB",GLenum,GLuint,GLdouble[4].asreturn())
        declare("GetProgramLocalParameterfvARB",GLenum,GLuint,GLfloat[4].asreturn())
        declare("GetProgramivARB",GLenum,GLenum,GLint[1].asreturn())
        declare("GetProgramStringARB",GLenum,GLenum,GLstring.asreturn())
        declare("GetVertexAttribdvARB",GLuint,GLenum,GLdouble[1].asreturn())
        declare("GetVertexAttribfvARB",GLuint,GLenum,GLfloat[1].asreturn())
        declare("GetVertexAttribivARB",GLuint,GLenum,GLint[1].asreturn())
        #declare("GetVertexAttribPointervARB",GLuint,GLenum,GLvoid**)
        declare(GLboolean,"IsProgramARB",GLuint)

    if GL_ARB_VERTEX_BUFFER_OBJECT:
        declare("BindBufferARB",GLenum,GLuint)
        # declare("DeleteBuffersARB",GLsizei,
        #         GLuint[MAX_BUFFER_ARRAY_SIZE])  ### not a dynamic size
        # declare("GenBuffersARB",GLsizei,
        #         GLuint[MAX_BUFFER_ARRAY_SIZE].asreturn())  ### not a dynamic size
        declare(GLboolean,"IsBufferARB",GLuint)
        declare("BufferDataARB",GLenum,GLsizeiptrARB,GLbuffer,GLenum)
        declare("BufferSubDataARB",GLenum,GLintptrARB,GLsizeiptrARB,GLbuffer)
        declare("GetBufferSubDataARB",GLenum,GLintptrARB,GLsizeiptrARB,GLbuffer.asreturn())
        declare(GLpointer,"MapBufferARB",GLenum,GLenum)
        declare(GLboolean,"UnmapBufferARB",GLenum)
        declare("GetBufferParameterivARB",GLenum,GLenum,GLint[1].asreturn())
        #declare("GetBufferPointervARB",GLenum,GLenum,GLvoid**)

    if GL_ARB_OCCLUSION_QUERY:
        # declare("GenQueriesARB",GLsizei,
        #         GLuint[MAX_QUERY_ARRAY_SIZE].asreturn())  ### not a dynamic size
        # declare("DeleteQueriesARB",GLsizei,
        #         GLuint[MAX_QUERY_ARRAY_SIZE])  ### not a dynamic size
        declare(GLboolean,"IsQueryARB",GLuint)
        declare("BeginQueryARB",GLenum,GLuint)
        declare("EndQueryARB",GLenum)
        declare("GetQueryivARB",GLenum,GLenum,GLint[1].asreturn())
        declare("GetQueryObjectivARB",GLuint,GLenum,GLint[1].asreturn())
        declare("GetQueryObjectuivARB",GLuint,GLenum,GLuint[1].asreturn())

    if GL_ARB_SHADER_OBJECTS:
        declare("DeleteObjectARB",GLhandleARB)
        declare(GLhandleARB,"GetHandleARB",GLenum)
        declare("DetachObjectARB",GLhandleARB,GLhandleARB)
        declare(GLhandleARB,"CreateShaderObjectARB",GLenum)
        # declare("ShaderSourceARB",GLhandleARB,GLsizei, const GLcharARB**,GLint[])
        #handcoded("ShaderSourceARB",4)
        declare("ShaderSourceARB",GLhandleARB,GLsizei,GLcharARB[1][1],GLint[1])
        declare("CompileShaderARB",GLhandleARB)
        declare(GLhandleARB,"CreateProgramObjectARB")
        declare("AttachObjectARB",GLhandleARB,GLhandleARB)
        declare("LinkProgramARB",GLhandleARB)
        declare("UseProgramObjectARB",GLhandleARB)
        declare("ValidateProgramARB",GLhandleARB)
        declare("Uniform1fARB",GLint,GLfloat)
        declare("Uniform2fARB",GLint,GLfloat,GLfloat)
        declare("Uniform3fARB",GLint,GLfloat,GLfloat,GLfloat)
        declare("Uniform4fARB",GLint,GLfloat,GLfloat,GLfloat,GLfloat)
        declare("Uniform1iARB",GLint,GLint)
        declare("Uniform2iARB",GLint,GLint,GLint)
        declare("Uniform3iARB",GLint,GLint,GLint,GLint)
        declare("Uniform4iARB",GLint,GLint,GLint,GLint,GLint)
        declare("Uniform1fvARB",GLint,GLsizei,GLfloat[1])
        declare("Uniform2fvARB",GLint,GLsizei,GLfloat[2])
        declare("Uniform3fvARB",GLint,GLsizei,GLfloat[3])
        declare("Uniform4fvARB",GLint,GLsizei,GLfloat[4])
        declare("Uniform1ivARB",GLint,GLsizei,GLint[1])
        declare("Uniform2ivARB",GLint,GLsizei,GLint[2])
        declare("Uniform3ivARB",GLint,GLsizei,GLint[3])
        declare("Uniform4ivARB",GLint,GLsizei,GLint[4])
        declare("UniformMatrix2fvARB",GLint,GLsizei,GLboolean,GLfloat[4])
        declare("UniformMatrix3fvARB",GLint,GLsizei,GLboolean,GLfloat[9])
        declare("UniformMatrix4fvARB",GLint,GLsizei,GLboolean,GLfloat[16])
        declare("GetObjectParameterfvARB",GLhandleARB,GLenum,GLfloat[1].asreturn())
        declare("GetObjectParameterivARB",GLhandleARB,GLenum,GLint[1].asreturn())
        declare("GetInfoLogARB",GLhandleARB,GLsizei,GLsizei[1].asreturn(),GLstring.asreturn())
        declare("GetAttachedObjectsARB",GLhandleARB,GLsizei,GLsizei[1].asreturn(),
                GLbuffer.asreturn())
        declare(GLint,"GetUniformLocationARB",GLhandleARB,GLstring)
        declare("GetActiveUniformARB",GLhandleARB,GLuint,GLsizei,GLsizei[1].asreturn(),
                GLint[1].asreturn(),GLenum[1].asreturn(),GLstring.asreturn())
        declare("GetUniformfvARB",GLhandleARB,GLint,GLfloat[16].asreturn())
        declare("GetUniformivARB",GLhandleARB,GLint,GLint[16].asreturn())
        declare("GetShaderSourceARB",GLhandleARB,GLsizei,GLsizei[1].asreturn(),
                GLstring.asreturn())

    if GL_ARB_VERTEX_SHADER:
        declare("BindAttribLocationARB",GLhandleARB,GLuint,GLstring)
        declare("GetActiveAttribARB",GLhandleARB,GLuint,GLsizei,GLsizei[1].asreturn(),
                GLint[1].asreturn(),GLenum[1].asreturn(),GLstring.asreturn())
        declare(GLint,"GetAttribLocationARB",GLhandleARB,GLstring)

    if GL_ARB_DRAW_BUFFERS:
        declare("DrawBuffersARB",GLsizei,GLenum[16])  ### not a dynamic size

    if GL_ARB_COLOR_BUFFER_FLOAT:
        declare("ClampColorARB",GLenum,GLenum)

    # Things we force to exist via GL trickery.
    declare("GetProgramiv",GLuint,GLenum,GLint[1].asreturn())
    declare("GetShaderiv",GLuint,GLenum,GLint[1].asreturn())
    declare("DeleteProgram",GLuint)
    declare("DeleteShader",GLuint)
    declare("GetProgramInfoLog",GLhandleARB,GLsizei,GLsizei[1].asreturn(),GLstring.asreturn())
    declare("GetShaderInfoLog",GLhandleARB,GLsizei,GLsizei[1].asreturn(),GLstring.asreturn())

    # -------- GL Constants --------

    # Boolean values
    constant("FALSE")
    constant("TRUE")

    # Data types
    constant("BYTE")
    constant("UNSIGNED_BYTE")
    constant("SHORT")
    constant("UNSIGNED_SHORT")
    constant("INT")
    constant("UNSIGNED_INT")
    constant("FLOAT")
    constant("2_BYTES")
    constant("3_BYTES")
    constant("4_BYTES")
    constant("DOUBLE")

    # Primitives
    constant("POINTS")
    constant("LINES")
    constant("LINE_LOOP")
    constant("LINE_STRIP")
    constant("TRIANGLES")
    constant("TRIANGLE_STRIP")
    constant("TRIANGLE_FAN")
    constant("QUADS")
    constant("QUAD_STRIP")
    constant("POLYGON")

    # Vertex Arrays
    constant("VERTEX_ARRAY")
    constant("NORMAL_ARRAY")
    constant("COLOR_ARRAY")
    constant("INDEX_ARRAY")
    constant("TEXTURE_COORD_ARRAY")
    constant("EDGE_FLAG_ARRAY")
    constant("VERTEX_ARRAY_SIZE")
    constant("VERTEX_ARRAY_TYPE")
    constant("VERTEX_ARRAY_STRIDE")
    constant("NORMAL_ARRAY_TYPE")
    constant("NORMAL_ARRAY_STRIDE")
    constant("COLOR_ARRAY_SIZE")
    constant("COLOR_ARRAY_TYPE")
    constant("COLOR_ARRAY_STRIDE")
    constant("INDEX_ARRAY_TYPE")
    constant("INDEX_ARRAY_STRIDE")
    constant("TEXTURE_COORD_ARRAY_SIZE")
    constant("TEXTURE_COORD_ARRAY_TYPE")
    constant("TEXTURE_COORD_ARRAY_STRIDE")
    constant("EDGE_FLAG_ARRAY_STRIDE")
    constant("VERTEX_ARRAY_POINTER")
    constant("NORMAL_ARRAY_POINTER")
    constant("COLOR_ARRAY_POINTER")
    constant("INDEX_ARRAY_POINTER")
    constant("TEXTURE_COORD_ARRAY_POINTER")
    constant("EDGE_FLAG_ARRAY_POINTER")
    constant("V2F")
    constant("V3F")
    constant("C4UB_V2F")
    constant("C4UB_V3F")
    constant("C3F_V3F")
    constant("N3F_V3F")
    constant("C4F_N3F_V3F")
    constant("T2F_V3F")
    constant("T4F_V4F")
    constant("T2F_C4UB_V3F")
    constant("T2F_C3F_V3F")
    constant("T2F_N3F_V3F")
    constant("T2F_C4F_N3F_V3F")
    constant("T4F_C4F_N3F_V4F")

    # Matrix Mode
    constant("MATRIX_MODE")
    constant("MODELVIEW")
    constant("PROJECTION")
    constant("TEXTURE")

    # Points
    constant("POINT_SMOOTH")
    constant("POINT_SIZE")
    constant("POINT_SIZE_GRANULARITY")
    constant("POINT_SIZE_RANGE")

    # Lines
    constant("LINE_SMOOTH")
    constant("LINE_STIPPLE")
    constant("LINE_STIPPLE_PATTERN")
    constant("LINE_STIPPLE_REPEAT")
    constant("LINE_WIDTH")
    constant("LINE_WIDTH_GRANULARITY")
    constant("LINE_WIDTH_RANGE")

    # Polygons
    constant("POINT")
    constant("LINE")
    constant("FILL")
    constant("CW")
    constant("CCW")
    constant("FRONT")
    constant("BACK")
    constant("POLYGON_MODE")
    constant("POLYGON_SMOOTH")
    constant("POLYGON_STIPPLE")
    constant("EDGE_FLAG")
    constant("CULL_FACE")
    constant("CULL_FACE_MODE")
    constant("FRONT_FACE")
    constant("POLYGON_OFFSET_FACTOR")
    constant("POLYGON_OFFSET_UNITS")
    constant("POLYGON_OFFSET_POINT")
    constant("POLYGON_OFFSET_LINE")
    constant("POLYGON_OFFSET_FILL")

    # Display Lists
    constant("COMPILE")
    constant("COMPILE_AND_EXECUTE")
    constant("LIST_BASE")
    constant("LIST_INDEX")
    constant("LIST_MODE")

    # Depth buffer
    constant("NEVER")
    constant("LESS")
    constant("EQUAL")
    constant("LEQUAL")
    constant("GREATER")
    constant("NOTEQUAL")
    constant("GEQUAL")
    constant("ALWAYS")
    constant("DEPTH_TEST")
    constant("DEPTH_BITS")
    constant("DEPTH_CLEAR_VALUE")
    constant("DEPTH_FUNC")
    constant("DEPTH_RANGE")
    constant("DEPTH_WRITEMASK")
    constant("DEPTH_COMPONENT")

    # Lighting
    constant("LIGHTING")
    constant("LIGHT0")
    constant("LIGHT1")
    constant("LIGHT2")
    constant("LIGHT3")
    constant("LIGHT4")
    constant("LIGHT5")
    constant("LIGHT6")
    constant("LIGHT7")
    constant("SPOT_EXPONENT")
    constant("SPOT_CUTOFF")
    constant("CONSTANT_ATTENUATION")
    constant("LINEAR_ATTENUATION")
    constant("QUADRATIC_ATTENUATION")
    constant("AMBIENT")
    constant("DIFFUSE")
    constant("SPECULAR")
    constant("SHININESS")
    constant("EMISSION")
    constant("POSITION")
    constant("SPOT_DIRECTION")
    constant("AMBIENT_AND_DIFFUSE")
    constant("COLOR_INDEXES")
    constant("LIGHT_MODEL_TWO_SIDE")
    constant("LIGHT_MODEL_LOCAL_VIEWER")
    constant("LIGHT_MODEL_AMBIENT")
    constant("FRONT_AND_BACK")
    constant("SHADE_MODEL")
    constant("FLAT")
    constant("SMOOTH")
    constant("COLOR_MATERIAL")
    constant("COLOR_MATERIAL_FACE")
    constant("COLOR_MATERIAL_PARAMETER")
    constant("NORMALIZE")

    # User clipping planes
    constant("CLIP_PLANE0")
    constant("CLIP_PLANE1")
    constant("CLIP_PLANE2")
    constant("CLIP_PLANE3")
    constant("CLIP_PLANE4")
    constant("CLIP_PLANE5")

    # Accumulation buffer
    constant("ACCUM_RED_BITS")
    constant("ACCUM_GREEN_BITS")
    constant("ACCUM_BLUE_BITS")
    constant("ACCUM_ALPHA_BITS")
    constant("ACCUM_CLEAR_VALUE")
    constant("ACCUM")
    constant("ADD")
    constant("LOAD")
    constant("MULT")
    constant("RETURN")

    # Alpha testing
    constant("ALPHA_TEST")
    constant("ALPHA_TEST_REF")
    constant("ALPHA_TEST_FUNC")

    # Blending
    constant("BLEND")
    constant("BLEND_SRC")
    constant("BLEND_DST")
    constant("ZERO")
    constant("ONE")
    constant("SRC_COLOR")
    constant("ONE_MINUS_SRC_COLOR")
    constant("SRC_ALPHA")
    constant("ONE_MINUS_SRC_ALPHA")
    constant("DST_ALPHA")
    constant("ONE_MINUS_DST_ALPHA")
    constant("DST_COLOR")
    constant("ONE_MINUS_DST_COLOR")
    constant("SRC_ALPHA_SATURATE")

    # Render Mode
    constant("FEEDBACK")
    constant("RENDER")
    constant("SELECT")

    # Feedback
    constant("2D")
    constant("3D")
    constant("3D_COLOR")
    constant("3D_COLOR_TEXTURE")
    constant("4D_COLOR_TEXTURE")
    constant("POINT_TOKEN")
    constant("LINE_TOKEN")
    constant("LINE_RESET_TOKEN")
    constant("POLYGON_TOKEN")
    constant("BITMAP_TOKEN")
    constant("DRAW_PIXEL_TOKEN")
    constant("COPY_PIXEL_TOKEN")
    constant("PASS_THROUGH_TOKEN")
    constant("FEEDBACK_BUFFER_POINTER")
    constant("FEEDBACK_BUFFER_SIZE")
    constant("FEEDBACK_BUFFER_TYPE")

    # Selection
    constant("SELECTION_BUFFER_POINTER")
    constant("SELECTION_BUFFER_SIZE")

    # Fog
    constant("FOG")
    constant("FOG_MODE")
    constant("FOG_DENSITY")
    constant("FOG_COLOR")
    constant("FOG_INDEX")
    constant("FOG_START")
    constant("FOG_END")
    constant("LINEAR")
    constant("EXP")
    constant("EXP2")

    # Logic Ops
    constant("LOGIC_OP")
    constant("INDEX_LOGIC_OP")
    constant("COLOR_LOGIC_OP")
    constant("LOGIC_OP_MODE")
    constant("CLEAR")
    constant("SET")
    constant("COPY")
    constant("COPY_INVERTED")
    constant("NOOP")
    constant("INVERT")
    constant("AND")
    constant("NAND")
    constant("OR")
    constant("NOR")
    constant("XOR")
    constant("EQUIV")
    constant("AND_REVERSE")
    constant("AND_INVERTED")
    constant("OR_REVERSE")
    constant("OR_INVERTED")

    # Stencil
    constant("STENCIL_BITS")
    constant("STENCIL_TEST")
    constant("STENCIL_CLEAR_VALUE")
    constant("STENCIL_FUNC")
    constant("STENCIL_VALUE_MASK")
    constant("STENCIL_FAIL")
    constant("STENCIL_PASS_DEPTH_FAIL")
    constant("STENCIL_PASS_DEPTH_PASS")
    constant("STENCIL_REF")
    constant("STENCIL_WRITEMASK")
    constant("STENCIL_INDEX")
    constant("KEEP")
    constant("REPLACE")
    constant("INCR")
    constant("DECR")

    # Buffers, Pixel Drawing/Reading
    constant("NONE")
    constant("LEFT")
    constant("RIGHT")
    constant("FRONT_LEFT")
    constant("FRONT_RIGHT")
    constant("BACK_LEFT")
    constant("BACK_RIGHT")
    constant("AUX0")
    constant("AUX1")
    constant("AUX2")
    constant("AUX3")
    constant("COLOR_INDEX")
    constant("RED")
    constant("GREEN")
    constant("BLUE")
    constant("ALPHA")
    constant("LUMINANCE")
    constant("LUMINANCE_ALPHA")
    constant("ALPHA_BITS")
    constant("RED_BITS")
    constant("GREEN_BITS")
    constant("BLUE_BITS")
    constant("INDEX_BITS")
    constant("SUBPIXEL_BITS")
    constant("AUX_BUFFERS")
    constant("READ_BUFFER")
    constant("DRAW_BUFFER")
    constant("DOUBLEBUFFER")
    constant("STEREO")
    constant("BITMAP")
    constant("COLOR")
    constant("DEPTH")
    constant("STENCIL")
    constant("DITHER")
    constant("RGB")
    constant("RGBA")

    # Implementation limits
    constant("MAX_LIST_NESTING")
    constant("MAX_EVAL_ORDER")
    constant("MAX_LIGHTS")
    constant("MAX_CLIP_PLANES")
    constant("MAX_TEXTURE_SIZE")
    constant("MAX_PIXEL_MAP_TABLE")
    constant("MAX_ATTRIB_STACK_DEPTH")
    constant("MAX_MODELVIEW_STACK_DEPTH")
    constant("MAX_NAME_STACK_DEPTH")
    constant("MAX_PROJECTION_STACK_DEPTH")
    constant("MAX_TEXTURE_STACK_DEPTH")
    constant("MAX_VIEWPORT_DIMS")
    constant("MAX_CLIENT_ATTRIB_STACK_DEPTH")

    # Gets
    constant("ATTRIB_STACK_DEPTH")
    constant("CLIENT_ATTRIB_STACK_DEPTH")
    constant("COLOR_CLEAR_VALUE")
    constant("COLOR_WRITEMASK")
    constant("CURRENT_INDEX")
    constant("CURRENT_COLOR")
    constant("CURRENT_NORMAL")
    constant("CURRENT_RASTER_COLOR")
    constant("CURRENT_RASTER_DISTANCE")
    constant("CURRENT_RASTER_INDEX")
    constant("CURRENT_RASTER_POSITION")
    constant("CURRENT_RASTER_TEXTURE_COORDS")
    constant("CURRENT_RASTER_POSITION_VALID")
    constant("CURRENT_TEXTURE_COORDS")
    constant("INDEX_CLEAR_VALUE")
    constant("INDEX_MODE")
    constant("INDEX_WRITEMASK")
    constant("MODELVIEW_MATRIX")
    constant("MODELVIEW_STACK_DEPTH")
    constant("NAME_STACK_DEPTH")
    constant("PROJECTION_MATRIX")
    constant("PROJECTION_STACK_DEPTH")
    constant("RENDER_MODE")
    constant("RGBA_MODE")
    constant("TEXTURE_MATRIX")
    constant("TEXTURE_STACK_DEPTH")
    constant("VIEWPORT")

    # Evaluators
    constant("AUTO_NORMAL")
    constant("MAP1_COLOR_4")
    constant("MAP1_INDEX")
    constant("MAP1_NORMAL")
    constant("MAP1_TEXTURE_COORD_1")
    constant("MAP1_TEXTURE_COORD_2")
    constant("MAP1_TEXTURE_COORD_3")
    constant("MAP1_TEXTURE_COORD_4")
    constant("MAP1_VERTEX_3")
    constant("MAP1_VERTEX_4")
    constant("MAP2_COLOR_4")
    constant("MAP2_INDEX")
    constant("MAP2_NORMAL")
    constant("MAP2_TEXTURE_COORD_1")
    constant("MAP2_TEXTURE_COORD_2")
    constant("MAP2_TEXTURE_COORD_3")
    constant("MAP2_TEXTURE_COORD_4")
    constant("MAP2_VERTEX_3")
    constant("MAP2_VERTEX_4")
    constant("MAP1_GRID_DOMAIN")
    constant("MAP1_GRID_SEGMENTS")
    constant("MAP2_GRID_DOMAIN")
    constant("MAP2_GRID_SEGMENTS")
    constant("COEFF")
    constant("ORDER")
    constant("DOMAIN")

    # Hints
    constant("PERSPECTIVE_CORRECTION_HINT")
    constant("POINT_SMOOTH_HINT")
    constant("LINE_SMOOTH_HINT")
    constant("POLYGON_SMOOTH_HINT")
    constant("FOG_HINT")
    constant("DONT_CARE")
    constant("FASTEST")
    constant("NICEST")

    # Scissor box
    constant("SCISSOR_BOX")
    constant("SCISSOR_TEST")

    # Pixel Mode / Transfer
    constant("MAP_COLOR")
    constant("MAP_STENCIL")
    constant("INDEX_SHIFT")
    constant("INDEX_OFFSET")
    constant("RED_SCALE")
    constant("RED_BIAS")
    constant("GREEN_SCALE")
    constant("GREEN_BIAS")
    constant("BLUE_SCALE")
    constant("BLUE_BIAS")
    constant("ALPHA_SCALE")
    constant("ALPHA_BIAS")
    constant("DEPTH_SCALE")
    constant("DEPTH_BIAS")
    constant("PIXEL_MAP_S_TO_S_SIZE")
    constant("PIXEL_MAP_I_TO_I_SIZE")
    constant("PIXEL_MAP_I_TO_R_SIZE")
    constant("PIXEL_MAP_I_TO_G_SIZE")
    constant("PIXEL_MAP_I_TO_B_SIZE")
    constant("PIXEL_MAP_I_TO_A_SIZE")
    constant("PIXEL_MAP_R_TO_R_SIZE")
    constant("PIXEL_MAP_G_TO_G_SIZE")
    constant("PIXEL_MAP_B_TO_B_SIZE")
    constant("PIXEL_MAP_A_TO_A_SIZE")
    constant("PIXEL_MAP_S_TO_S")
    constant("PIXEL_MAP_I_TO_I")
    constant("PIXEL_MAP_I_TO_R")
    constant("PIXEL_MAP_I_TO_G")
    constant("PIXEL_MAP_I_TO_B")
    constant("PIXEL_MAP_I_TO_A")
    constant("PIXEL_MAP_R_TO_R")
    constant("PIXEL_MAP_G_TO_G")
    constant("PIXEL_MAP_B_TO_B")
    constant("PIXEL_MAP_A_TO_A")
    constant("PACK_ALIGNMENT")
    constant("PACK_LSB_FIRST")
    constant("PACK_ROW_LENGTH")
    constant("PACK_SKIP_PIXELS")
    constant("PACK_SKIP_ROWS")
    constant("PACK_SWAP_BYTES")
    constant("UNPACK_ALIGNMENT")
    constant("UNPACK_LSB_FIRST")
    constant("UNPACK_ROW_LENGTH")
    constant("UNPACK_SKIP_PIXELS")
    constant("UNPACK_SKIP_ROWS")
    constant("UNPACK_SWAP_BYTES")
    constant("ZOOM_X")
    constant("ZOOM_Y")

    # Texture mapping
    constant("TEXTURE_ENV")
    constant("TEXTURE_ENV_MODE")
    constant("TEXTURE_1D")
    constant("TEXTURE_2D")
    constant("TEXTURE_WRAP_S")
    constant("TEXTURE_WRAP_T")
    constant("TEXTURE_MAG_FILTER")
    constant("TEXTURE_MIN_FILTER")
    constant("TEXTURE_ENV_COLOR")
    constant("TEXTURE_GEN_S")
    constant("TEXTURE_GEN_T")
    constant("TEXTURE_GEN_MODE")
    constant("TEXTURE_BORDER_COLOR")
    constant("TEXTURE_WIDTH")
    constant("TEXTURE_HEIGHT")
    constant("TEXTURE_BORDER")
    constant("TEXTURE_COMPONENTS")
    constant("TEXTURE_RED_SIZE")
    constant("TEXTURE_GREEN_SIZE")
    constant("TEXTURE_BLUE_SIZE")
    constant("TEXTURE_ALPHA_SIZE")
    constant("TEXTURE_LUMINANCE_SIZE")
    constant("TEXTURE_INTENSITY_SIZE")
    constant("NEAREST_MIPMAP_NEAREST")
    constant("NEAREST_MIPMAP_LINEAR")
    constant("LINEAR_MIPMAP_NEAREST")
    constant("LINEAR_MIPMAP_LINEAR")
    constant("OBJECT_LINEAR")
    constant("OBJECT_PLANE")
    constant("EYE_LINEAR")
    constant("EYE_PLANE")
    constant("SPHERE_MAP")
    constant("DECAL")
    constant("MODULATE")
    constant("NEAREST")
    constant("REPEAT")
    constant("CLAMP")
    constant("S")
    constant("T")
    constant("R")
    constant("Q")
    constant("TEXTURE_GEN_R")
    constant("TEXTURE_GEN_Q")

    # Utility
    constant("VENDOR")
    constant("RENDERER")
    constant("VERSION")
    constant("EXTENSIONS")

    # Errors
    constant("NO_ERROR")
    constant("INVALID_ENUM")
    constant("INVALID_VALUE")
    constant("INVALID_OPERATION")
    constant("STACK_OVERFLOW")
    constant("STACK_UNDERFLOW")
    constant("OUT_OF_MEMORY")

    # glPush/PopAttrib bits
    constant("CURRENT_BIT")
    constant("POINT_BIT")
    constant("LINE_BIT")
    constant("POLYGON_BIT")
    constant("POLYGON_STIPPLE_BIT")
    constant("PIXEL_MODE_BIT")
    constant("LIGHTING_BIT")
    constant("FOG_BIT")
    constant("DEPTH_BUFFER_BIT")
    constant("ACCUM_BUFFER_BIT")
    constant("STENCIL_BUFFER_BIT")
    constant("VIEWPORT_BIT")
    constant("TRANSFORM_BIT")
    constant("ENABLE_BIT")
    constant("COLOR_BUFFER_BIT")
    constant("HINT_BIT")
    constant("EVAL_BIT")
    constant("LIST_BIT")
    constant("TEXTURE_BIT")
    constant("SCISSOR_BIT")
    constant("ALL_ATTRIB_BITS")

    # OpenGL 1.1
    constant("PROXY_TEXTURE_1D")
    constant("PROXY_TEXTURE_2D")
    constant("TEXTURE_PRIORITY")
    constant("TEXTURE_RESIDENT")
    constant("TEXTURE_BINDING_1D")
    constant("TEXTURE_BINDING_2D")
    constant("TEXTURE_INTERNAL_FORMAT")
    constant("ALPHA4")
    constant("ALPHA8")
    constant("ALPHA12")
    constant("ALPHA16")
    constant("LUMINANCE4")
    constant("LUMINANCE8")
    constant("LUMINANCE12")
    constant("LUMINANCE16")
    constant("LUMINANCE4_ALPHA4")
    constant("LUMINANCE6_ALPHA2")
    constant("LUMINANCE8_ALPHA8")
    constant("LUMINANCE12_ALPHA4")
    constant("LUMINANCE12_ALPHA12")
    constant("LUMINANCE16_ALPHA16")
    constant("INTENSITY")
    constant("INTENSITY4")
    constant("INTENSITY8")
    constant("INTENSITY12")
    constant("INTENSITY16")
    constant("R3_G3_B2")
    constant("RGB4")
    constant("RGB5")
    constant("RGB8")
    constant("RGB10")
    constant("RGB12")
    constant("RGB16")
    constant("RGBA2")
    constant("RGBA4")
    constant("RGB5_A1")
    constant("RGBA8")
    constant("RGB10_A2")
    constant("RGBA12")
    constant("RGBA16")
    constant("CLIENT_PIXEL_STORE_BIT")
    constant("CLIENT_VERTEX_ARRAY_BIT")
    # constant("ALL_CLIENT_ATTRIB_BITS")
    constant("CLIENT_ALL_ATTRIB_BITS")

    if OPENGL_1_2:
        constant("RESCALE_NORMAL")
        constant("CLAMP_TO_EDGE")
        constant("MAX_ELEMENTS_VERTICES")
        constant("MAX_ELEMENTS_INDICES")
        constant("BGR")
        constant("BGRA")
        constant("UNSIGNED_BYTE_3_3_2")
        constant("UNSIGNED_BYTE_2_3_3_REV")
        constant("UNSIGNED_SHORT_5_6_5")
        constant("UNSIGNED_SHORT_5_6_5_REV")
        constant("UNSIGNED_SHORT_4_4_4_4")
        constant("UNSIGNED_SHORT_4_4_4_4_REV")
        constant("UNSIGNED_SHORT_5_5_5_1")
        constant("UNSIGNED_SHORT_1_5_5_5_REV")
        constant("UNSIGNED_INT_8_8_8_8")
        constant("UNSIGNED_INT_8_8_8_8_REV")
        constant("UNSIGNED_INT_10_10_10_2")
        constant("UNSIGNED_INT_2_10_10_10_REV")
        constant("LIGHT_MODEL_COLOR_CONTROL")
        constant("SINGLE_COLOR")
        constant("SEPARATE_SPECULAR_COLOR")
        constant("TEXTURE_MIN_LOD")
        constant("TEXTURE_MAX_LOD")
        constant("TEXTURE_BASE_LEVEL")
        constant("TEXTURE_MAX_LEVEL")
        constant("SMOOTH_POINT_SIZE_RANGE")
        constant("SMOOTH_POINT_SIZE_GRANULARITY")
        constant("SMOOTH_LINE_WIDTH_RANGE")
        constant("SMOOTH_LINE_WIDTH_GRANULARITY")
        constant("ALIASED_POINT_SIZE_RANGE")
        constant("ALIASED_LINE_WIDTH_RANGE")
        constant("PACK_SKIP_IMAGES")
        constant("PACK_IMAGE_HEIGHT")
        constant("UNPACK_SKIP_IMAGES")
        constant("UNPACK_IMAGE_HEIGHT")
        constant("TEXTURE_3D")
        constant("PROXY_TEXTURE_3D")
        constant("TEXTURE_DEPTH")
        constant("TEXTURE_WRAP_R")
        constant("MAX_3D_TEXTURE_SIZE")
        constant("TEXTURE_BINDING_3D")

    if GL_ARB_IMAGING:
        constant("CONSTANT_COLOR")
        constant("ONE_MINUS_CONSTANT_COLOR")
        constant("CONSTANT_ALPHA")
        constant("ONE_MINUS_CONSTANT_ALPHA")
        constant("COLOR_TABLE")
        constant("POST_CONVOLUTION_COLOR_TABLE")
        constant("POST_COLOR_MATRIX_COLOR_TABLE")
        constant("PROXY_COLOR_TABLE")
        constant("PROXY_POST_CONVOLUTION_COLOR_TABLE")
        constant("PROXY_POST_COLOR_MATRIX_COLOR_TABLE")
        constant("COLOR_TABLE_SCALE")
        constant("COLOR_TABLE_BIAS")
        constant("COLOR_TABLE_FORMAT")
        constant("COLOR_TABLE_WIDTH")
        constant("COLOR_TABLE_RED_SIZE")
        constant("COLOR_TABLE_GREEN_SIZE")
        constant("COLOR_TABLE_BLUE_SIZE")
        constant("COLOR_TABLE_ALPHA_SIZE")
        constant("COLOR_TABLE_LUMINANCE_SIZE")
        constant("COLOR_TABLE_INTENSITY_SIZE")
        constant("CONVOLUTION_1D")
        constant("CONVOLUTION_2D")
        constant("SEPARABLE_2D")
        constant("CONVOLUTION_BORDER_MODE")
        constant("CONVOLUTION_FILTER_SCALE")
        constant("CONVOLUTION_FILTER_BIAS")
        constant("REDUCE")
        constant("CONVOLUTION_FORMAT")
        constant("CONVOLUTION_WIDTH")
        constant("CONVOLUTION_HEIGHT")
        constant("MAX_CONVOLUTION_WIDTH")
        constant("MAX_CONVOLUTION_HEIGHT")
        constant("POST_CONVOLUTION_RED_SCALE")
        constant("POST_CONVOLUTION_GREEN_SCALE")
        constant("POST_CONVOLUTION_BLUE_SCALE")
        constant("POST_CONVOLUTION_ALPHA_SCALE")
        constant("POST_CONVOLUTION_RED_BIAS")
        constant("POST_CONVOLUTION_GREEN_BIAS")
        constant("POST_CONVOLUTION_BLUE_BIAS")
        constant("POST_CONVOLUTION_ALPHA_BIAS")
        constant("CONSTANT_BORDER")
        constant("REPLICATE_BORDER")
        constant("CONVOLUTION_BORDER_COLOR")
        constant("COLOR_MATRIX")
        constant("COLOR_MATRIX_STACK_DEPTH")
        constant("MAX_COLOR_MATRIX_STACK_DEPTH")
        constant("POST_COLOR_MATRIX_RED_SCALE")
        constant("POST_COLOR_MATRIX_GREEN_SCALE")
        constant("POST_COLOR_MATRIX_BLUE_SCALE")
        constant("POST_COLOR_MATRIX_ALPHA_SCALE")
        constant("POST_COLOR_MATRIX_RED_BIAS")
        constant("POST_COLOR_MATRIX_GREEN_BIAS")
        constant("POST_COLOR_MATRIX_BLUE_BIAS")
        constant("POST_COLOR_MATRIX_ALPHA_BIAS")
        constant("HISTOGRAM")
        constant("PROXY_HISTOGRAM")
        constant("HISTOGRAM_WIDTH")
        constant("HISTOGRAM_FORMAT")
        constant("HISTOGRAM_RED_SIZE")
        constant("HISTOGRAM_GREEN_SIZE")
        constant("HISTOGRAM_BLUE_SIZE")
        constant("HISTOGRAM_ALPHA_SIZE")
        constant("HISTOGRAM_LUMINANCE_SIZE")
        constant("HISTOGRAM_SINK")
        constant("MINMAX")
        constant("MINMAX_FORMAT")
        constant("MINMAX_SINK")
        constant("TABLE_TOO_LARGE")
        constant("BLEND_EQUATION")
        constant("MIN")
        constant("MAX")
        constant("FUNC_ADD")
        constant("FUNC_SUBTRACT")
        constant("FUNC_REVERSE_SUBTRACT")
        constant("BLEND_COLOR")

    if OPENGL_1_3:
        constant("TEXTURE0")
        constant("TEXTURE1")
        constant("TEXTURE2")
        constant("TEXTURE3")
        constant("TEXTURE4")
        constant("TEXTURE5")
        constant("TEXTURE6")
        constant("TEXTURE7")
        constant("TEXTURE8")
        constant("TEXTURE9")
        constant("TEXTURE10")
        constant("TEXTURE11")
        constant("TEXTURE12")
        constant("TEXTURE13")
        constant("TEXTURE14")
        constant("TEXTURE15")
        constant("TEXTURE16")
        constant("TEXTURE17")
        constant("TEXTURE18")
        constant("TEXTURE19")
        constant("TEXTURE20")
        constant("TEXTURE21")
        constant("TEXTURE22")
        constant("TEXTURE23")
        constant("TEXTURE24")
        constant("TEXTURE25")
        constant("TEXTURE26")
        constant("TEXTURE27")
        constant("TEXTURE28")
        constant("TEXTURE29")
        constant("TEXTURE30")
        constant("TEXTURE31")
        constant("ACTIVE_TEXTURE")
        constant("CLIENT_ACTIVE_TEXTURE")
        constant("MAX_TEXTURE_UNITS")
        constant("NORMAL_MAP")
        constant("REFLECTION_MAP")
        constant("TEXTURE_CUBE_MAP")
        constant("TEXTURE_BINDING_CUBE_MAP")
        constant("TEXTURE_CUBE_MAP_POSITIVE_X")
        constant("TEXTURE_CUBE_MAP_NEGATIVE_X")
        constant("TEXTURE_CUBE_MAP_POSITIVE_Y")
        constant("TEXTURE_CUBE_MAP_NEGATIVE_Y")
        constant("TEXTURE_CUBE_MAP_POSITIVE_Z")
        constant("TEXTURE_CUBE_MAP_NEGATIVE_Z")
        constant("PROXY_TEXTURE_CUBE_MAP")
        constant("MAX_CUBE_MAP_TEXTURE_SIZE")
        constant("COMPRESSED_ALPHA")
        constant("COMPRESSED_LUMINANCE")
        constant("COMPRESSED_LUMINANCE_ALPHA")
        constant("COMPRESSED_INTENSITY")
        constant("COMPRESSED_RGB")
        constant("COMPRESSED_RGBA")
        constant("TEXTURE_COMPRESSION_HINT")
        constant("TEXTURE_COMPRESSED_IMAGE_SIZE")
        constant("TEXTURE_COMPRESSED")
        constant("NUM_COMPRESSED_TEXTURE_FORMATS")
        constant("COMPRESSED_TEXTURE_FORMATS")
        constant("MULTISAMPLE")
        constant("SAMPLE_ALPHA_TO_COVERAGE")
        constant("SAMPLE_ALPHA_TO_ONE")
        constant("SAMPLE_COVERAGE")
        constant("SAMPLE_BUFFERS")
        constant("SAMPLES")
        constant("SAMPLE_COVERAGE_VALUE")
        constant("SAMPLE_COVERAGE_INVERT")
        constant("MULTISAMPLE_BIT")
        constant("TRANSPOSE_MODELVIEW_MATRIX")
        constant("TRANSPOSE_PROJECTION_MATRIX")
        constant("TRANSPOSE_TEXTURE_MATRIX")
        constant("TRANSPOSE_COLOR_MATRIX")
        constant("COMBINE")
        constant("COMBINE_RGB")
        constant("COMBINE_ALPHA")
        constant("SOURCE0_RGB")
        constant("SOURCE1_RGB")
        constant("SOURCE2_RGB")
        constant("SOURCE0_ALPHA")
        constant("SOURCE1_ALPHA")
        constant("SOURCE2_ALPHA")
        constant("OPERAND0_RGB")
        constant("OPERAND1_RGB")
        constant("OPERAND2_RGB")
        constant("OPERAND0_ALPHA")
        constant("OPERAND1_ALPHA")
        constant("OPERAND2_ALPHA")
        constant("RGB_SCALE")
        constant("ADD_SIGNED")
        constant("INTERPOLATE")
        constant("SUBTRACT")
        constant("CONSTANT")
        constant("PRIMARY_COLOR")
        constant("PREVIOUS")
        constant("DOT3_RGB")
        constant("DOT3_RGBA")
        constant("CLAMP_TO_BORDER")

    if GL_ARB_MULTITEXTURE:
        constant("TEXTURE0_ARB")
        constant("TEXTURE1_ARB")
        constant("TEXTURE2_ARB")
        constant("TEXTURE3_ARB")
        constant("TEXTURE4_ARB")
        constant("TEXTURE5_ARB")
        constant("TEXTURE6_ARB")
        constant("TEXTURE7_ARB")
        constant("TEXTURE8_ARB")
        constant("TEXTURE9_ARB")
        constant("TEXTURE10_ARB")
        constant("TEXTURE11_ARB")
        constant("TEXTURE12_ARB")
        constant("TEXTURE13_ARB")
        constant("TEXTURE14_ARB")
        constant("TEXTURE15_ARB")
        constant("TEXTURE16_ARB")
        constant("TEXTURE17_ARB")
        constant("TEXTURE18_ARB")
        constant("TEXTURE19_ARB")
        constant("TEXTURE20_ARB")
        constant("TEXTURE21_ARB")
        constant("TEXTURE22_ARB")
        constant("TEXTURE23_ARB")
        constant("TEXTURE24_ARB")
        constant("TEXTURE25_ARB")
        constant("TEXTURE26_ARB")
        constant("TEXTURE27_ARB")
        constant("TEXTURE28_ARB")
        constant("TEXTURE29_ARB")
        constant("TEXTURE30_ARB")
        constant("TEXTURE31_ARB")
        constant("ACTIVE_TEXTURE_ARB")
        constant("CLIENT_ACTIVE_TEXTURE_ARB")
        constant("MAX_TEXTURE_UNITS_ARB")

    if OPENGL_1_4:
        constant("BLEND_DST_RGB")
        constant("BLEND_SRC_RGB")
        constant("BLEND_DST_ALPHA")
        constant("BLEND_SRC_ALPHA")
        constant("POINT_SIZE_MIN")
        constant("POINT_SIZE_MAX")
        constant("POINT_FADE_THRESHOLD_SIZE")
        constant("POINT_DISTANCE_ATTENUATION")
        constant("GENERATE_MIPMAP")
        constant("GENERATE_MIPMAP_HINT")
        constant("DEPTH_COMPONENT16")
        constant("DEPTH_COMPONENT24")
        constant("DEPTH_COMPONENT32")
        constant("MIRRORED_REPEAT")
        constant("FOG_COORDINATE_SOURCE")
        constant("FOG_COORDINATE")
        constant("FRAGMENT_DEPTH")
        constant("CURRENT_FOG_COORDINATE")
        constant("FOG_COORDINATE_ARRAY_TYPE")
        constant("FOG_COORDINATE_ARRAY_STRIDE")
        constant("FOG_COORDINATE_ARRAY_POINTER")
        constant("FOG_COORDINATE_ARRAY")
        constant("COLOR_SUM")
        constant("CURRENT_SECONDARY_COLOR")
        constant("SECONDARY_COLOR_ARRAY_SIZE")
        constant("SECONDARY_COLOR_ARRAY_TYPE")
        constant("SECONDARY_COLOR_ARRAY_STRIDE")
        constant("SECONDARY_COLOR_ARRAY_POINTER")
        constant("SECONDARY_COLOR_ARRAY")
        constant("MAX_TEXTURE_LOD_BIAS")
        constant("TEXTURE_FILTER_CONTROL")
        constant("TEXTURE_LOD_BIAS")
        constant("INCR_WRAP")
        constant("DECR_WRAP")
        constant("TEXTURE_DEPTH_SIZE")
        constant("DEPTH_TEXTURE_MODE")
        constant("TEXTURE_COMPARE_MODE")
        constant("TEXTURE_COMPARE_FUNC")
        constant("COMPARE_R_TO_TEXTURE")

    if OPENGL_1_5:
        constant("BUFFER_SIZE")
        constant("BUFFER_USAGE")
        constant("QUERY_COUNTER_BITS")
        constant("CURRENT_QUERY")
        constant("QUERY_RESULT")
        constant("QUERY_RESULT_AVAILABLE")
        constant("ARRAY_BUFFER")
        constant("ELEMENT_ARRAY_BUFFER")
        constant("ARRAY_BUFFER_BINDING")
        constant("ELEMENT_ARRAY_BUFFER_BINDING")
        constant("VERTEX_ARRAY_BUFFER_BINDING")
        constant("NORMAL_ARRAY_BUFFER_BINDING")
        constant("COLOR_ARRAY_BUFFER_BINDING")
        constant("INDEX_ARRAY_BUFFER_BINDING")
        constant("TEXTURE_COORD_ARRAY_BUFFER_BINDING")
        constant("EDGE_FLAG_ARRAY_BUFFER_BINDING")
        constant("SECONDARY_COLOR_ARRAY_BUFFER_BINDING")
        constant("FOG_COORDINATE_ARRAY_BUFFER_BINDING")
        constant("WEIGHT_ARRAY_BUFFER_BINDING")
        constant("VERTEX_ATTRIB_ARRAY_BUFFER_BINDING")
        constant("READ_ONLY")
        constant("WRITE_ONLY")
        constant("READ_WRITE")
        constant("BUFFER_ACCESS")
        constant("BUFFER_MAPPED")
        constant("BUFFER_MAP_POINTER")
        constant("STREAM_DRAW")
        constant("STREAM_READ")
        constant("STREAM_COPY")
        constant("STATIC_DRAW")
        constant("STATIC_READ")
        constant("STATIC_COPY")
        constant("DYNAMIC_DRAW")
        constant("DYNAMIC_READ")
        constant("DYNAMIC_COPY")
        constant("SAMPLES_PASSED")
        constant("FOG_COORD_SRC")
        constant("FOG_COORD")
        constant("CURRENT_FOG_COORD")
        constant("FOG_COORD_ARRAY_TYPE")
        constant("FOG_COORD_ARRAY_STRIDE")
        constant("FOG_COORD_ARRAY_POINTER")
        constant("FOG_COORD_ARRAY")
        constant("FOG_COORD_ARRAY_BUFFER_BINDING")
        constant("SRC0_RGB")
        constant("SRC1_RGB")
        constant("SRC2_RGB")
        constant("SRC0_ALPHA")
        constant("SRC1_ALPHA")
        constant("SRC2_ALPHA")

    if OPENGL_2_0:
        constant("BLEND_EQUATION_RGB")
        constant("VERTEX_ATTRIB_ARRAY_ENABLED")
        constant("VERTEX_ATTRIB_ARRAY_SIZE")
        constant("VERTEX_ATTRIB_ARRAY_STRIDE")
        constant("VERTEX_ATTRIB_ARRAY_TYPE")
        constant("CURRENT_VERTEX_ATTRIB")
        constant("VERTEX_PROGRAM_POINT_SIZE")
        constant("VERTEX_PROGRAM_TWO_SIDE")
        constant("VERTEX_ATTRIB_ARRAY_POINTER")
        constant("STENCIL_BACK_FUNC")
        constant("STENCIL_BACK_FAIL")
        constant("STENCIL_BACK_PASS_DEPTH_FAIL")
        constant("STENCIL_BACK_PASS_DEPTH_PASS")
        constant("MAX_DRAW_BUFFERS")
        constant("DRAW_BUFFER0")
        constant("DRAW_BUFFER1")
        constant("DRAW_BUFFER2")
        constant("DRAW_BUFFER3")
        constant("DRAW_BUFFER4")
        constant("DRAW_BUFFER5")
        constant("DRAW_BUFFER6")
        constant("DRAW_BUFFER7")
        constant("DRAW_BUFFER8")
        constant("DRAW_BUFFER9")
        constant("DRAW_BUFFER10")
        constant("DRAW_BUFFER11")
        constant("DRAW_BUFFER12")
        constant("DRAW_BUFFER13")
        constant("DRAW_BUFFER14")
        constant("DRAW_BUFFER15")
        constant("BLEND_EQUATION_ALPHA")
        constant("POINT_SPRITE")
        constant("COORD_REPLACE")
        constant("MAX_VERTEX_ATTRIBS")
        constant("VERTEX_ATTRIB_ARRAY_NORMALIZED")
        constant("MAX_TEXTURE_COORDS")
        constant("MAX_TEXTURE_IMAGE_UNITS")
        constant("FRAGMENT_SHADER")
        constant("VERTEX_SHADER")
        constant("MAX_FRAGMENT_UNIFORM_COMPONENTS")
        constant("MAX_VERTEX_UNIFORM_COMPONENTS")
        constant("MAX_VARYING_FLOATS")
        constant("MAX_VERTEX_TEXTURE_IMAGE_UNITS")
        constant("MAX_COMBINED_TEXTURE_IMAGE_UNITS")
        constant("SHADER_TYPE")
        constant("FLOAT_VEC2")
        constant("FLOAT_VEC3")
        constant("FLOAT_VEC4")
        constant("INT_VEC2")
        constant("INT_VEC3")
        constant("INT_VEC4")
        constant("BOOL")
        constant("BOOL_VEC2")
        constant("BOOL_VEC3")
        constant("BOOL_VEC4")
        constant("FLOAT_MAT2")
        constant("FLOAT_MAT3")
        constant("FLOAT_MAT4")
        constant("SAMPLER_1D")
        constant("SAMPLER_2D")
        constant("SAMPLER_3D")
        constant("SAMPLER_CUBE")
        constant("SAMPLER_1D_SHADOW")
        constant("SAMPLER_2D_SHADOW")
        constant("DELETE_STATUS")
        constant("COMPILE_STATUS")
        constant("LINK_STATUS")
        constant("VALIDATE_STATUS")
        constant("INFO_LOG_LENGTH")
        constant("ATTACHED_SHADERS")
        constant("ACTIVE_UNIFORMS")
        constant("ACTIVE_UNIFORM_MAX_LENGTH")
        constant("SHADER_SOURCE_LENGTH")
        constant("ACTIVE_ATTRIBUTES")
        constant("ACTIVE_ATTRIBUTE_MAX_LENGTH")
        constant("FRAGMENT_SHADER_DERIVATIVE_HINT")
        constant("SHADING_LANGUAGE_VERSION")
        constant("CURRENT_PROGRAM")
        constant("POINT_SPRITE_COORD_ORIGIN")
        constant("LOWER_LEFT")
        constant("UPPER_LEFT")
        constant("STENCIL_BACK_REF")
        constant("STENCIL_BACK_VALUE_MASK")
        constant("STENCIL_BACK_WRITEMASK")

    if OPENGL_2_1:
        constant("CURRENT_RASTER_SECONDARY_COLOR")
        constant("PIXEL_PACK_BUFFER")
        constant("PIXEL_UNPACK_BUFFER")
        constant("PIXEL_PACK_BUFFER_BINDING")
        constant("PIXEL_UNPACK_BUFFER_BINDING")
        constant("FLOAT_MAT2")
        constant("FLOAT_MAT2")
        constant("FLOAT_MAT3")
        constant("FLOAT_MAT3")
        constant("FLOAT_MAT4")
        constant("FLOAT_MAT4")
        constant("SRGB")
        constant("SRGB8")
        constant("SRGB_ALPHA")
        constant("SRGB8_ALPHA8")
        constant("SLUMINANCE_ALPHA")
        constant("SLUMINANCE8_ALPHA8")
        constant("SLUMINANCE")
        constant("SLUMINANCE8")
        constant("COMPRESSED_SRGB")
        constant("COMPRESSED_SRGB_ALPHA")
        constant("COMPRESSED_SLUMINANCE")
        constant("COMPRESSED_SLUMINANCE_ALPHA")

    if GL_ARB_TRANSPOSE_MATRIX:
        constant("TRANSPOSE_MODELVIEW_MATRIX_ARB")
        constant("TRANSPOSE_PROJECTION_MATRIX_ARB")
        constant("TRANSPOSE_TEXTURE_MATRIX_ARB")
        constant("TRANSPOSE_COLOR_MATRIX_ARB")

    if GL_ARB_MULTISAMPLE:
        constant("MULTISAMPLE_ARB")
        constant("SAMPLE_ALPHA_TO_COVERAGE_ARB")
        constant("SAMPLE_ALPHA_TO_ONE_ARB")
        constant("SAMPLE_COVERAGE_ARB")
        constant("SAMPLE_BUFFERS_ARB")
        constant("SAMPLES_ARB")
        constant("SAMPLE_COVERAGE_VALUE_ARB")
        constant("SAMPLE_COVERAGE_INVERT_ARB")
        constant("MULTISAMPLE_BIT_ARB")

    if GL_ARB_TEXTURE_CUBE_MAP:
        constant("NORMAL_MAP_ARB")
        constant("REFLECTION_MAP_ARB")
        constant("TEXTURE_CUBE_MAP_ARB")
        constant("TEXTURE_BINDING_CUBE_MAP_ARB")
        constant("TEXTURE_CUBE_MAP_POSITIVE_X_ARB")
        constant("TEXTURE_CUBE_MAP_NEGATIVE_X_ARB")
        constant("TEXTURE_CUBE_MAP_POSITIVE_Y_ARB")
        constant("TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB")
        constant("TEXTURE_CUBE_MAP_POSITIVE_Z_ARB")
        constant("TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB")
        constant("PROXY_TEXTURE_CUBE_MAP_ARB")
        constant("MAX_CUBE_MAP_TEXTURE_SIZE_ARB")

    if GL_ARB_TEXTURE_COMPRESSION:
        constant("COMPRESSED_ALPHA_ARB")
        constant("COMPRESSED_LUMINANCE_ARB")
        constant("COMPRESSED_LUMINANCE_ALPHA_ARB")
        constant("COMPRESSED_INTENSITY_ARB")
        constant("COMPRESSED_RGB_ARB")
        constant("COMPRESSED_RGBA_ARB")
        constant("TEXTURE_COMPRESSION_HINT_ARB")
        constant("TEXTURE_COMPRESSED_IMAGE_SIZE_ARB")
        constant("TEXTURE_COMPRESSED_ARB")
        constant("NUM_COMPRESSED_TEXTURE_FORMATS_ARB")
        constant("COMPRESSED_TEXTURE_FORMATS_ARB")

    if GL_ARB_TEXTURE_BORDER_CLAMP:
        constant("CLAMP_TO_BORDER_ARB")

    if GL_ARB_POINT_PARAMETERS:
        constant("POINT_SIZE_MIN_ARB")
        constant("POINT_SIZE_MAX_ARB")
        constant("POINT_FADE_THRESHOLD_SIZE_ARB")
        constant("POINT_DISTANCE_ATTENUATION_ARB")

    if GL_ARB_VERTEX_BLEND:
        constant("MAX_VERTEX_UNITS_ARB")
        constant("ACTIVE_VERTEX_UNITS_ARB")
        constant("WEIGHT_SUM_UNITY_ARB")
        constant("VERTEX_BLEND_ARB")
        constant("CURRENT_WEIGHT_ARB")
        constant("WEIGHT_ARRAY_TYPE_ARB")
        constant("WEIGHT_ARRAY_STRIDE_ARB")
        constant("WEIGHT_ARRAY_SIZE_ARB")
        constant("WEIGHT_ARRAY_POINTER_ARB")
        constant("WEIGHT_ARRAY_ARB")
        constant("MODELVIEW0_ARB")
        constant("MODELVIEW1_ARB")
        constant("MODELVIEW2_ARB")
        constant("MODELVIEW3_ARB")
        constant("MODELVIEW4_ARB")
        constant("MODELVIEW5_ARB")
        constant("MODELVIEW6_ARB")
        constant("MODELVIEW7_ARB")
        constant("MODELVIEW8_ARB")
        constant("MODELVIEW9_ARB")
        constant("MODELVIEW10_ARB")
        constant("MODELVIEW11_ARB")
        constant("MODELVIEW12_ARB")
        constant("MODELVIEW13_ARB")
        constant("MODELVIEW14_ARB")
        constant("MODELVIEW15_ARB")
        constant("MODELVIEW16_ARB")
        constant("MODELVIEW17_ARB")
        constant("MODELVIEW18_ARB")
        constant("MODELVIEW19_ARB")
        constant("MODELVIEW20_ARB")
        constant("MODELVIEW21_ARB")
        constant("MODELVIEW22_ARB")
        constant("MODELVIEW23_ARB")
        constant("MODELVIEW24_ARB")
        constant("MODELVIEW25_ARB")
        constant("MODELVIEW26_ARB")
        constant("MODELVIEW27_ARB")
        constant("MODELVIEW28_ARB")
        constant("MODELVIEW29_ARB")
        constant("MODELVIEW30_ARB")
        constant("MODELVIEW31_ARB")

    if GL_ARB_MATRIX_PALETTE:
        constant("MATRIX_PALETTE_ARB")
        constant("MAX_MATRIX_PALETTE_STACK_DEPTH_ARB")
        constant("MAX_PALETTE_MATRICES_ARB")
        constant("CURRENT_PALETTE_MATRIX_ARB")
        constant("MATRIX_INDEX_ARRAY_ARB")
        constant("CURRENT_MATRIX_INDEX_ARB")
        constant("MATRIX_INDEX_ARRAY_SIZE_ARB")
        constant("MATRIX_INDEX_ARRAY_TYPE_ARB")
        constant("MATRIX_INDEX_ARRAY_STRIDE_ARB")
        constant("MATRIX_INDEX_ARRAY_POINTER_ARB")

    if GL_ARB_TEXTURE_ENV_COMBINE:
        constant("COMBINE_ARB")
        constant("COMBINE_RGB_ARB")
        constant("COMBINE_ALPHA_ARB")
        constant("SOURCE0_RGB_ARB")
        constant("SOURCE1_RGB_ARB")
        constant("SOURCE2_RGB_ARB")
        constant("SOURCE0_ALPHA_ARB")
        constant("SOURCE1_ALPHA_ARB")
        constant("SOURCE2_ALPHA_ARB")
        constant("OPERAND0_RGB_ARB")
        constant("OPERAND1_RGB_ARB")
        constant("OPERAND2_RGB_ARB")
        constant("OPERAND0_ALPHA_ARB")
        constant("OPERAND1_ALPHA_ARB")
        constant("OPERAND2_ALPHA_ARB")
        constant("RGB_SCALE_ARB")
        constant("ADD_SIGNED_ARB")
        constant("INTERPOLATE_ARB")
        constant("SUBTRACT_ARB")
        constant("CONSTANT_ARB")
        constant("PRIMARY_COLOR_ARB")
        constant("PREVIOUS_ARB")

    if GL_ARB_TEXTURE_ENV_DOT3:
        constant("DOT3_RGB_ARB")
        constant("DOT3_RGBA_ARB")

    if GL_ARB_TEXTURE_MIRRORED_REPEAT:
        constant("MIRRORED_REPEAT_ARB")

    if GL_ARB_DEPTH_TEXTURE:
        constant("DEPTH_COMPONENT16_ARB")
        constant("DEPTH_COMPONENT24_ARB")
        constant("DEPTH_COMPONENT32_ARB")
        constant("TEXTURE_DEPTH_SIZE_ARB")
        constant("DEPTH_TEXTURE_MODE_ARB")

    if GL_ARB_SHADOW:
        constant("TEXTURE_COMPARE_MODE_ARB")
        constant("TEXTURE_COMPARE_FUNC_ARB")
        constant("COMPARE_R_TO_TEXTURE_ARB")

    if GL_ARB_SHADOW_AMBIENT:
        constant("TEXTURE_COMPARE_FAIL_VALUE_ARB")

    if GL_ARB_VERTEX_PROGRAM:
        constant("COLOR_SUM_ARB")
        constant("VERTEX_PROGRAM_ARB")
        constant("VERTEX_ATTRIB_ARRAY_ENABLED_ARB")
        constant("VERTEX_ATTRIB_ARRAY_SIZE_ARB")
        constant("VERTEX_ATTRIB_ARRAY_STRIDE_ARB")
        constant("VERTEX_ATTRIB_ARRAY_TYPE_ARB")
        constant("CURRENT_VERTEX_ATTRIB_ARB")
        constant("PROGRAM_LENGTH_ARB")
        constant("PROGRAM_STRING_ARB")
        constant("MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB")
        constant("MAX_PROGRAM_MATRICES_ARB")
        constant("CURRENT_MATRIX_STACK_DEPTH_ARB")
        constant("CURRENT_MATRIX_ARB")
        constant("VERTEX_PROGRAM_POINT_SIZE_ARB")
        constant("VERTEX_PROGRAM_TWO_SIDE_ARB")
        constant("VERTEX_ATTRIB_ARRAY_POINTER_ARB")
        constant("PROGRAM_ERROR_POSITION_ARB")
        constant("PROGRAM_BINDING_ARB")
        constant("MAX_VERTEX_ATTRIBS_ARB")
        constant("VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB")
        constant("PROGRAM_ERROR_STRING_ARB")
        constant("PROGRAM_FORMAT_ASCII_ARB")
        constant("PROGRAM_FORMAT_ARB")
        constant("PROGRAM_INSTRUCTIONS_ARB")
        constant("MAX_PROGRAM_INSTRUCTIONS_ARB")
        constant("PROGRAM_NATIVE_INSTRUCTIONS_ARB")
        constant("MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB")
        constant("PROGRAM_TEMPORARIES_ARB")
        constant("MAX_PROGRAM_TEMPORARIES_ARB")
        constant("PROGRAM_NATIVE_TEMPORARIES_ARB")
        constant("MAX_PROGRAM_NATIVE_TEMPORARIES_ARB")
        constant("PROGRAM_PARAMETERS_ARB")
        constant("MAX_PROGRAM_PARAMETERS_ARB")
        constant("PROGRAM_NATIVE_PARAMETERS_ARB")
        constant("MAX_PROGRAM_NATIVE_PARAMETERS_ARB")
        constant("PROGRAM_ATTRIBS_ARB")
        constant("MAX_PROGRAM_ATTRIBS_ARB")
        constant("PROGRAM_NATIVE_ATTRIBS_ARB")
        constant("MAX_PROGRAM_NATIVE_ATTRIBS_ARB")
        constant("PROGRAM_ADDRESS_REGISTERS_ARB")
        constant("MAX_PROGRAM_ADDRESS_REGISTERS_ARB")
        constant("PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB")
        constant("MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB")
        constant("MAX_PROGRAM_LOCAL_PARAMETERS_ARB")
        constant("MAX_PROGRAM_ENV_PARAMETERS_ARB")
        constant("PROGRAM_UNDER_NATIVE_LIMITS_ARB")
        constant("TRANSPOSE_CURRENT_MATRIX_ARB")
        constant("MATRIX0_ARB")
        constant("MATRIX1_ARB")
        constant("MATRIX2_ARB")
        constant("MATRIX3_ARB")
        constant("MATRIX4_ARB")
        constant("MATRIX5_ARB")
        constant("MATRIX6_ARB")
        constant("MATRIX7_ARB")
        constant("MATRIX8_ARB")
        constant("MATRIX9_ARB")
        constant("MATRIX10_ARB")
        constant("MATRIX11_ARB")
        constant("MATRIX12_ARB")
        constant("MATRIX13_ARB")
        constant("MATRIX14_ARB")
        constant("MATRIX15_ARB")
        constant("MATRIX16_ARB")
        constant("MATRIX17_ARB")
        constant("MATRIX18_ARB")
        constant("MATRIX19_ARB")
        constant("MATRIX20_ARB")
        constant("MATRIX21_ARB")
        constant("MATRIX22_ARB")
        constant("MATRIX23_ARB")
        constant("MATRIX24_ARB")
        constant("MATRIX25_ARB")
        constant("MATRIX26_ARB")
        constant("MATRIX27_ARB")
        constant("MATRIX28_ARB")
        constant("MATRIX29_ARB")
        constant("MATRIX30_ARB")
        constant("MATRIX31_ARB")

    if GL_ARB_FRAGMENT_PROGRAM:
        constant("FRAGMENT_PROGRAM_ARB")
        constant("PROGRAM_ALU_INSTRUCTIONS_ARB")
        constant("PROGRAM_TEX_INSTRUCTIONS_ARB")
        constant("PROGRAM_TEX_INDIRECTIONS_ARB")
        constant("PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB")
        constant("PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB")
        constant("PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB")
        constant("MAX_PROGRAM_ALU_INSTRUCTIONS_ARB")
        constant("MAX_PROGRAM_TEX_INSTRUCTIONS_ARB")
        constant("MAX_PROGRAM_TEX_INDIRECTIONS_ARB")
        constant("MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB")
        constant("MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB")
        constant("MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB")
        constant("MAX_TEXTURE_COORDS_ARB")
        constant("MAX_TEXTURE_IMAGE_UNITS_ARB")

    if GL_ARB_VERTEX_BUFFER_OBJECT:
        constant("BUFFER_SIZE_ARB")
        constant("BUFFER_USAGE_ARB")
        constant("ARRAY_BUFFER_ARB")
        constant("ELEMENT_ARRAY_BUFFER_ARB")
        constant("ARRAY_BUFFER_BINDING_ARB")
        constant("ELEMENT_ARRAY_BUFFER_BINDING_ARB")
        constant("VERTEX_ARRAY_BUFFER_BINDING_ARB")
        constant("NORMAL_ARRAY_BUFFER_BINDING_ARB")
        constant("COLOR_ARRAY_BUFFER_BINDING_ARB")
        constant("INDEX_ARRAY_BUFFER_BINDING_ARB")
        constant("TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB")
        constant("EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB")
        constant("SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB")
        constant("FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB")
        constant("WEIGHT_ARRAY_BUFFER_BINDING_ARB")
        constant("VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB")
        constant("READ_ONLY_ARB")
        constant("WRITE_ONLY_ARB")
        constant("READ_WRITE_ARB")
        constant("BUFFER_ACCESS_ARB")
        constant("BUFFER_MAPPED_ARB")
        constant("BUFFER_MAP_POINTER_ARB")
        constant("STREAM_DRAW_ARB")
        constant("STREAM_READ_ARB")
        constant("STREAM_COPY_ARB")
        constant("STATIC_DRAW_ARB")
        constant("STATIC_READ_ARB")
        constant("STATIC_COPY_ARB")
        constant("DYNAMIC_DRAW_ARB")
        constant("DYNAMIC_READ_ARB")
        constant("DYNAMIC_COPY_ARB")

    if GL_ARB_OCCLUSION_QUERY:
        constant("QUERY_COUNTER_BITS_ARB")
        constant("CURRENT_QUERY_ARB")
        constant("QUERY_RESULT_ARB")
        constant("QUERY_RESULT_AVAILABLE_ARB")
        constant("SAMPLES_PASSED_ARB")

    if GL_ARB_SHADER_OBJECTS:
        constant("PROGRAM_OBJECT_ARB")
        constant("SHADER_OBJECT_ARB")
        constant("OBJECT_TYPE_ARB")
        constant("OBJECT_SUBTYPE_ARB")
        constant("FLOAT_VEC2_ARB")
        constant("FLOAT_VEC3_ARB")
        constant("FLOAT_VEC4_ARB")
        constant("INT_VEC2_ARB")
        constant("INT_VEC3_ARB")
        constant("INT_VEC4_ARB")
        constant("BOOL_ARB")
        constant("BOOL_VEC2_ARB")
        constant("BOOL_VEC3_ARB")
        constant("BOOL_VEC4_ARB")
        constant("FLOAT_MAT2_ARB")
        constant("FLOAT_MAT3_ARB")
        constant("FLOAT_MAT4_ARB")
        constant("SAMPLER_1D_ARB")
        constant("SAMPLER_2D_ARB")
        constant("SAMPLER_3D_ARB")
        constant("SAMPLER_CUBE_ARB")
        constant("SAMPLER_1D_SHADOW_ARB")
        constant("SAMPLER_2D_SHADOW_ARB")
        constant("SAMPLER_2D_RECT_ARB")
        constant("SAMPLER_2D_RECT_SHADOW_ARB")
        constant("OBJECT_DELETE_STATUS_ARB")
        constant("OBJECT_COMPILE_STATUS_ARB")
        constant("OBJECT_LINK_STATUS_ARB")
        constant("OBJECT_VALIDATE_STATUS_ARB")
        constant("OBJECT_INFO_LOG_LENGTH_ARB")
        constant("OBJECT_ATTACHED_OBJECTS_ARB")
        constant("OBJECT_ACTIVE_UNIFORMS_ARB")
        constant("OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB")
        constant("OBJECT_SHADER_SOURCE_LENGTH_ARB")

    if GL_ARB_VERTEX_SHADER:
        constant("VERTEX_SHADER_ARB")
        constant("MAX_VERTEX_UNIFORM_COMPONENTS_ARB")
        constant("MAX_VARYING_FLOATS_ARB")
        constant("MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB")
        constant("MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB")
        constant("OBJECT_ACTIVE_ATTRIBUTES_ARB")
        constant("OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB")

    if GL_ARB_FRAGMENT_SHADER:
        constant("FRAGMENT_SHADER_ARB")
        constant("MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB")
        constant("FRAGMENT_SHADER_DERIVATIVE_HINT_ARB")

    if GL_ARB_SHADING_LANGUAGE_100:
        constant("SHADING_LANGUAGE_VERSION_ARB")

    if GL_ARB_POINT_SPRITE:
        constant("POINT_SPRITE_ARB")
        constant("COORD_REPLACE_ARB")

    if GL_ARB_DRAW_BUFFERS:
        constant("MAX_DRAW_BUFFERS_ARB")
        constant("DRAW_BUFFER0_ARB")
        constant("DRAW_BUFFER1_ARB")
        constant("DRAW_BUFFER2_ARB")
        constant("DRAW_BUFFER3_ARB")
        constant("DRAW_BUFFER4_ARB")
        constant("DRAW_BUFFER5_ARB")
        constant("DRAW_BUFFER6_ARB")
        constant("DRAW_BUFFER7_ARB")
        constant("DRAW_BUFFER8_ARB")
        constant("DRAW_BUFFER9_ARB")
        constant("DRAW_BUFFER10_ARB")
        constant("DRAW_BUFFER11_ARB")
        constant("DRAW_BUFFER12_ARB")
        constant("DRAW_BUFFER13_ARB")
        constant("DRAW_BUFFER14_ARB")
        constant("DRAW_BUFFER15_ARB")

    if GL_ARB_TEXTURE_RECTANGLE:
        constant("TEXTURE_RECTANGLE_ARB")
        constant("TEXTURE_BINDING_RECTANGLE_ARB")
        constant("PROXY_TEXTURE_RECTANGLE_ARB")
        constant("MAX_RECTANGLE_TEXTURE_SIZE_ARB")

    if GL_ARB_COLOR_BUFFER_FLOAT:
        constant("RGBA_FLOAT_MODE_ARB")
        constant("CLAMP_VERTEX_COLOR_ARB")
        constant("CLAMP_FRAGMENT_COLOR_ARB")
        constant("CLAMP_READ_COLOR_ARB")
        constant("FIXED_ONLY_ARB")

    if GL_ARB_HALF_FLOAT_PIXEL:
        constant("HALF_FLOAT_ARB")

    if GL_ARB_TEXTURE_FLOAT:
        constant("TEXTURE_RED_TYPE_ARB")
        constant("TEXTURE_GREEN_TYPE_ARB")
        constant("TEXTURE_BLUE_TYPE_ARB")
        constant("TEXTURE_ALPHA_TYPE_ARB")
        constant("TEXTURE_LUMINANCE_TYPE_ARB")
        constant("TEXTURE_INTENSITY_TYPE_ARB")
        constant("TEXTURE_DEPTH_TYPE_ARB")
        constant("UNSIGNED_NORMALIZED_ARB")
        constant("RGBA32F_ARB")
        constant("RGB32F_ARB")
        constant("ALPHA32F_ARB")
        constant("INTENSITY32F_ARB")
        constant("LUMINANCE32F_ARB")
        constant("LUMINANCE_ALPHA32F_ARB")
        constant("RGBA16F_ARB")
        constant("RGB16F_ARB")
        constant("ALPHA16F_ARB")
        constant("INTENSITY16F_ARB")
        constant("LUMINANCE16F_ARB")
        constant("LUMINANCE_ALPHA16F_ARB")

    if GL_ARB_PIXEL_BUFFER_OBJECT:
        constant("PIXEL_PACK_BUFFER_ARB")
        constant("PIXEL_UNPACK_BUFFER_ARB")
        constant("PIXEL_PACK_BUFFER_BINDING_ARB")
        constant("PIXEL_UNPACK_BUFFER_BINDING_ARB")


    if GL_EXT_FRAMEBUFFER_OBJECT:
        declare(GLboolean,"IsRenderbufferEXT", GLuint)
        declare("BindRenderbufferEXT", GLenum, GLuint)
        declare("DeleteRenderbuffersEXT", GLsizei, GLuint[1])
        declare("GenRenderbuffersEXT", GLsizei, GLuint[1].asreturn())
        declare("RenderbufferStorageEXT", GLenum, GLenum, GLsizei, GLsizei)
        declare("GetRenderbufferParameterivEXT", GLenum, GLenum, GLint[1].asreturn())
        declare(GLboolean, "IsFramebufferEXT", GLuint)
        declare("BindFramebufferEXT", GLenum, GLuint)
        declare("DeleteFramebuffersEXT", GLsizei, GLuint[1])
        declare("GenFramebuffersEXT", GLsizei, GLuint[1].asreturn())
        declare(GLenum, "CheckFramebufferStatusEXT", GLenum)
        declare("FramebufferTexture1DEXT", GLenum, GLenum, GLenum, GLuint, GLint)
        declare("FramebufferTexture2DEXT", GLenum, GLenum, GLenum, GLuint, GLint)
        declare("FramebufferTexture3DEXT", GLenum, GLenum, GLenum, GLuint, GLint, GLint)
        declare("FramebufferRenderbufferEXT", GLenum, GLenum, GLenum, GLuint)
        declare("GetFramebufferAttachmentParameterivEXT", GLenum, GLenum, GLenum, GLint[1].asreturn())
        declare("GenerateMipmapEXT", GLenum)
        constant("FRAMEBUFFER_EXT")
        constant("RENDERBUFFER_EXT")
        constant("STENCIL_INDEX1_EXT")
        constant("STENCIL_INDEX4_EXT")
        constant("STENCIL_INDEX8_EXT")
        constant("STENCIL_INDEX16_EXT")
        constant("RENDERBUFFER_WIDTH_EXT")
        constant("RENDERBUFFER_HEIGHT_EXT")
        constant("RENDERBUFFER_INTERNAL_FORMAT_EXT")
        constant("RENDERBUFFER_RED_SIZE_EXT")
        constant("RENDERBUFFER_GREEN_SIZE_EXT")
        constant("RENDERBUFFER_BLUE_SIZE_EXT")
        constant("RENDERBUFFER_ALPHA_SIZE_EXT")
        constant("RENDERBUFFER_DEPTH_SIZE_EXT")
        constant("RENDERBUFFER_STENCIL_SIZE_EXT")
        constant("FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT")
        constant("FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT")
        constant("FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT")
        constant("FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT")
        constant("FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT")
        constant("COLOR_ATTACHMENT0_EXT")
        constant("COLOR_ATTACHMENT1_EXT")
        constant("COLOR_ATTACHMENT2_EXT")
        constant("COLOR_ATTACHMENT3_EXT")
        constant("COLOR_ATTACHMENT4_EXT")
        constant("COLOR_ATTACHMENT5_EXT")
        constant("COLOR_ATTACHMENT6_EXT")
        constant("COLOR_ATTACHMENT7_EXT")
        constant("COLOR_ATTACHMENT8_EXT")
        constant("COLOR_ATTACHMENT9_EXT")
        constant("COLOR_ATTACHMENT10_EXT")
        constant("COLOR_ATTACHMENT11_EXT")
        constant("COLOR_ATTACHMENT12_EXT")
        constant("COLOR_ATTACHMENT13_EXT")
        constant("COLOR_ATTACHMENT14_EXT")
        constant("COLOR_ATTACHMENT15_EXT")
        constant("DEPTH_ATTACHMENT_EXT")
        constant("STENCIL_ATTACHMENT_EXT")
        constant("FRAMEBUFFER_COMPLETE_EXT")
        constant("FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT")
        constant("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT")
        constant("FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT")
        constant("FRAMEBUFFER_INCOMPLETE_FORMATS_EXT")
        constant("FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT")
        constant("FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT")
        constant("FRAMEBUFFER_UNSUPPORTED_EXT")
        constant("FRAMEBUFFER_BINDING_EXT")
        constant("RENDERBUFFER_BINDING_EXT")
        constant("MAX_COLOR_ATTACHMENTS_EXT")
        constant("MAX_RENDERBUFFER_SIZE_EXT")

    constant("INFO_LOG_LENGTH")


class gltype(object):

    def __init__(self, s):
        self.type = s

    def __getitem__(self, n):
        return gltype(self.type + " *")

    def asreturn(self):
        return self

    def __str__(self):
        return self.type

GLenum = gltype("GLenum")
GLboolean = gltype("GLboolean")
GLbitfield = gltype("GLbitfield")
GLvoid = gltype("GLvoid")
GLbyte = gltype("GLbyte")
GLshort = gltype("GLshort")
GLint = gltype("GLint")
GLubyte = gltype("GLubyte")
GLushort = gltype("GLushort")
GLuint = gltype("GLuint")
GLsizei = gltype("GLsizei")
GLfloat = gltype("GLfloat")
GLclampf = gltype("GLclampf")
GLdouble = gltype("GLdouble")
GLclampd = gltype("GLclampd")
GLbuffer = gltype("GLubyte *")
GLsizeiptrARB = gltype("GLsizeiptrARB")
GLintptrARB = gltype("GLintptrARB")
GLpointer = gltype("GLvoid *")
GLhandleARB = gltype("GLhandleARB")
GLstring = gltype("GLchar *")
GLcharARB = gltype("GLchar")

def declare(*args):
    global is_enum
    is_enum = False

    args = list(args)

    if isinstance(args[0], gltype):
        type = args.pop(0) #@ReservedAssignment
    else:
        type = "void" #@ReservedAssignment

    name = args.pop(0)

    print "    %s gl%s(%s)" % (
        type,
        name,
        ", ".join(str(i) for i in args))

constants = [ ]

def constant(name):
    constants.append("GL_" + name)

HEADER = """\
cdef extern from "glcompat.h":
    ctypedef unsigned int    GLenum
    ctypedef unsigned char   GLboolean
    ctypedef unsigned int    GLbitfield
    ctypedef void            GLvoid
    ctypedef signed char     GLbyte
    ctypedef short           GLshort
    ctypedef int             GLint
    ctypedef unsigned char   GLubyte
    ctypedef unsigned short  GLushort
    ctypedef unsigned int    GLuint
    ctypedef int             GLsizei
    ctypedef float           GLfloat
    ctypedef float           GLclampf
    ctypedef double          GLdouble
    ctypedef double          GLclampd
    ctypedef long int        GLsizeiptrARB
    ctypedef long int        GLintptrARB
    ctypedef unsigned int    GLhandleARB
    ctypedef unsigned int    GLhandle
    ctypedef char            GLchar
    ctypedef char            GLcharARB
"""

FOOTER = """\

cdef inline gl_check(where):
    cdef GLenum error
    error = glGetError()
    if error:
        import renpy
        renpy.display.log.write("GL error 0x%X at %s", error, where)

"""

def main():
    out = sys.stdout
    out.write(HEADER)

    generate_tegl()
    constant("BGRA")

    constants.sort()
    constants.append("RENPY_THIRD_TEXTURE")

    print
    print "    enum:"
    for i in constants:
        print "        %s" % i

    print
    print FOOTER

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = linmixer
#@PydevCodeAnalysisIgnore
from ossaudiodev import * #@UnusedWildImport
mixer = openmixer()

def get_wave():
    if not mixer.controls() & 1 << SOUND_MIXER_PCM:
        return None

    l, r = mixer.get(SOUND_MIXER_PCM)

    return (l + r) / 200.0

def set_wave(vol):
    if not mixer.controls() & 1 << SOUND_MIXER_PCM:
        return None

    v = int(vol * 100)

    mixer.set(SOUND_MIXER_PCM, (v, v))


def get_midi():
    return None

def set_midi(vol):
    return

########NEW FILE########
__FILENAME__ = glblacklist
# This file was automatically generated from renpy/gl/glblacklist.py
# Modifications will be automatically overwritten.

# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


# The blacklist of OpenGL cards. Fields are:
# - A substring of the Renderer.
# - A substring of the Version.
# - True to allow shader rendering.
# - True to allow fixed-function rendering.

# If both of the last two entries are false, GL refuses to
# start.

BLACKLIST = [

    # Crashes for Mugenjohncel.
    ("S3 Graphics DeltaChrome", "1.4 20.00", False, False),

    # A bug in Mesa 7.9 and 7.10 (before 7.10.3) causes the system to
    # fail to initialize the GLSL compiler.
    # https://bugs.freedesktop.org/show_bug.cgi?id=35603
    ("Mesa", "Mesa 7.9", False, True),
    ("Mesa", "Mesa 7.10.3", True, True),
    ("Mesa", "Mesa 7.10", False, True),

    # Default to allowing everything.
    ("", "", True, True),
    ]

########NEW FILE########
__FILENAME__ = arguments
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file handles argument parsing. Argument parsing takes place in
# two phases. In the first phase, we only parse the arguments that are
# necessary to load the game, and run the init phase. The init phase
# can register commands and arguments. These arguments are parsed at
# the end of the init phase, before the game begins running, and can
# decide if the game runs or some other action occurs.

import argparse
import renpy

try:
    import site
    site._renpy_argv_emulation() # @UndefinedVariable
except:
    pass


# A map from command name to a (function, flag) tuple. The flag is true if the
# function will parse command line arguments, and false otherwise.
commands = { }

class ArgumentParser(argparse.ArgumentParser):
    """
    Creates an argument parser that is capable of parsing the standard Ren'Py
    arguments, as well as arguments that are specific to a sub-command.
    """

    def __init__(self, second_pass=True, description=None, require_command=True):
        """
        Creates an argument parser.

        `second_pass`
            True if this is the second pass through argument parsing. (The pass
            that parses sub-commands.)

        `description`
            If supplied, this will be used as a description of the subcommand
            to run.
        """

        self.group = self

        argparse.ArgumentParser.__init__(self, description="The Ren'Py visual novel engine.", add_help=False)

        self.add_argument(
            "basedir", default=None,
            help="The base directory containing of the project to run. This defaults to the directory containing the Ren'Py executable.",
            nargs=1 if require_command else '?'
            )

        command_names = ", ".join(sorted(commands))

        self.add_argument(
            "command",
            help="The command to execute. Available commands are: " + command_names + ". Defaults to 'run'.",
            default="run",
            nargs=1 if require_command else '?')

        self.add_argument(
            "--savedir", dest='savedir', default=None, metavar="DIRECTORY",
            help="The directory where saves and persistent data are placed.")

        self.add_argument(
            '--trace', dest='trace', action='store', default=0, type=int, metavar="LEVEL",
            help="The level of trace Ren'Py will log to trace.txt. (1=per-call, 2=per-line)")

        self.add_argument(
            "--version", action='version', version=renpy.version,
            help="Displays the version of Ren'Py in use.")

        self.add_argument(
            "--compile", action='store_true', dest='compile',
            help='Forces all .rpy scripts to be recompiled before proceeding.')

        self.add_argument(
            "--lint", action="store_true", dest="lint",
            help=argparse.SUPPRESS)

        dump = self.add_argument_group("JSON Dump Arguments", description="Ren'Py can dump information about the game to a JSON file. These options let you select the file, and choose what is dumped.")
        dump.add_argument("--json-dump", action="store", metavar="FILE", help="The name of the JSON file.")
        dump.add_argument("--json-dump-private", action="store_true", default=False, help="Include private names. (Names beginning with _.)")
        dump.add_argument("--json-dump-common", action="store_true", default=False, help="Include names defined in the common directory.")

        if second_pass:
            self.add_argument("-h", "--help", action="help", help="Displays this help message, then exits.")

            command = renpy.game.args.command #@UndefinedVariable
            self.group = self.add_argument_group("{0} command".format(command), description)

    def add_argument(self, *args, **kwargs):
        if self.group is self:
            argparse.ArgumentParser.add_argument(self, *args, **kwargs)
        else:
            self.group.add_argument(*args, **kwargs)

def run():
    """
    The default command, that (when called) leads to normal game startup.
    """

    ap = ArgumentParser(description="Runs the current project normally.", require_command=False)

    ap.add_argument(
        '--profile-display', dest='profile_display', action='store_true', default=False,
        help="If present, Ren'Py will report the amount of time it takes to draw the screen.")

    ap.add_argument(
        '--debug-image-cache', dest='debug_image_cache', action='store_true', default=False,
        help="If present, Ren'Py will log information regarding the contents of the image cache.")

    ap.add_argument(
        '--warp', dest='warp', default=None,
        help='This takes as an argument a filename:linenumber pair, and tries to warp to the statement before that line number.')

    args = renpy.game.args = ap.parse_args()

    if args.warp:
        renpy.warp.warp_spec = args.warp

    if args.profile_display: #@UndefinedVariable
        renpy.config.profile = True

    if args.debug_image_cache:
        renpy.config.debug_image_cache = True

    return True

def compile(): #@ReservedAssignment
    """
    This command forces the game script to be recompiled.
    """

    takes_no_arguments("Recompiles the game script.")

    return False


def quit(): #@ReservedAssignment
    """
    This command is used to quit without doing anything.
    """

    takes_no_arguments("Recompiles the game script.")

    return False

def rmpersistent():
    """
    This command is used to delete the persistent data.
    """

    takes_no_arguments("Deletes the persistent data.")

    renpy.loadsave.location.unlink_persistent()

    return False


def register_command(name, function):
    """
    Registers a command that can be invoked when Ren'Py is run on the command
    line. When the command is run, `function` is called with no arguments.

    If `function` needs to take additional command-line arguments, it should
    instantiate a renpy.arguments.ArgumentParser(), and then call parse_args
    on it. Otherwise, it should call renpy.arguments.takes_no_arguments().

    If `function` returns true, Ren'Py startup proceeds normally. Otherwise,
    Ren'Py will terminate when function() returns.
    """

    commands[name] = function

def bootstrap():
    """
    Called during bootstrap to perform an initial parse of the arguments, ignoring
    unknown arguments. Returns the parsed arguments, and a list of unknown arguments.
    """

    global rest

    ap = ArgumentParser(False, require_command=False)
    args, _rest = ap.parse_known_args()
    return args

def pre_init():
    """
    Called before init, to set up argument parsing.
    """

    global subparsers

    register_command("run", run)
    register_command("lint", renpy.lint.lint)
    register_command("compile", compile)
    register_command("rmpersistent", rmpersistent)
    register_command("quit", quit)


def post_init():
    """
    Called after init, but before the game starts. This parses a command
    and its arguments. It then runs the command function, and returns True
    if execution should continue and False otherwise.
    """

    command = renpy.game.args.command #@UndefinedVariable

    if command == "run" and renpy.game.args.lint: # @UndefinedVariable
        command = "lint"

    if command not in commands:
        ArgumentParser().error("Command {0} is unknown.".format(command))

    return commands[command]()

def takes_no_arguments(description=None):
    """
    Used to report that a command takes no arguments.
    """

    ArgumentParser(description=description).parse_args()

########NEW FILE########
__FILENAME__ = ast
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains the AST for the Ren'Py script language. Each class
# here corresponds to a statement in the script language.

# NOTE:
# When updating this file, consider if lint.py or warp.py also need
# updating.

import renpy.display

import re
import time
import md5

def statement_name(name):
    """
    Reports the name of this statement to systems like window auto.
    """

    for i in renpy.config.statement_callbacks:
        i(name)

def next_node(n):
    """
    Indicates the next node that should be executed. When a statement
    can crash, this should be set as early as possible, so that ignore
    can bring us there.
    """

    renpy.game.context().next_node = n

class ParameterInfo(object):
    """
    This class is used to store information about parameters to a
    label.
    """
    def __init__(self, parameters, positional, extrapos, extrakw):

        # A list of parameter name, default value pairs.
        self.parameters = parameters

        # A list, giving the positional parameters to this function,
        # in order.
        self.positional = positional

        # A variable that takes the extra positional arguments, if
        # any. None if no such variable exists.
        self.extrapos = extrapos

        # A variable that takes the extra keyword arguments, if
        # any. None if no such variable exists.
        self.extrakw = extrakw


    def apply(self, args, kwargs):
        """
        Applies `args` and `kwargs` to these parameters. Returns
        a dictionary that can be used to update an enclosing
        scope.
        """

        values = { }
        rv = { }

        if args is None:
            args = ()

        if kwargs is None:
            kwargs = { }


        for name, value in zip(self.positional, args):
            if name in values:
                raise Exception("Parameter %s has two values." % name)

            values[name] = value

        extrapos = tuple(args[len(self.positional):])

        for name, value in kwargs.iteritems():
            if name in values:
                raise Exception("Parameter %s has two values." % name)

            values[name] = value

        for name, default in self.parameters:

            if name not in values:
                if default is None:
                    raise Exception("Required parameter %s has no value." % name)
                else:
                    rv[name] = renpy.python.py_eval(default)

            else:
                rv[name] = values[name]
                del values[name]

        # Now, values has the left-over keyword arguments, and extrapos
        # has the left-over positional arguments.

        if self.extrapos:
            rv[self.extrapos] = extrapos
        elif extrapos:
            raise Exception("Too many arguments in call (expected %d, got %d)." % (len(self.positional), len(args)))

        if self.extrakw:
            rv[self.extrakw] = values
        else:
            if values:
                raise Exception("Unknown keyword arguments: %s" % ( ", ".join(values.keys())))

        return rv

def apply_arguments(parameters, args, kwargs):

    if parameters is None:
        if args or kwargs:
            raise Exception("Arguments supplied, but parameter list not present")
        else:
            return { }

    return parameters.apply(args, kwargs)


class ArgumentInfo(object):

    def __init__(self, arguments, extrapos, extrakw):

        # A list of (keyword, expression) pairs. If an argument doesn't
        # have a keyword, it's thought of as positional.
        self.arguments = arguments

        # An expression giving extra positional arguments being
        # supplied to this function.
        self.extrapos = extrapos

        # An expression giving extra keyword arguments that need
        # to be supplied to this function.
        self.extrakw = extrakw

    def evaluate(self, scope=None):
        """
        Evaluates the arguments, returning a list of arguments and a
        dictionary of keyword arguments.
        """

        args = [ ]
        kwargs = renpy.python.RevertableDict()

        for k, v in self.arguments:
            if k is not None:
                kwargs[k] = renpy.python.py_eval(v, locals=scope)
            else:
                args.append(renpy.python.py_eval(v, locals=scope))

        if self.extrapos is not None:
            args.extend(renpy.python.py_eval(self.extrapos, locals=scope))

        if self.extrakw is not None:
            kwargs.update(renpy.python.py_eval(self.extrakw, locals=scope))

        return tuple(args), kwargs


def __newobj__(cls, *args):
    return cls.__new__(cls, *args)

# This represents a string containing python code.
class PyExpr(unicode):

    __slots__ = [
        'filename',
        'linenumber',
        ]

    def __new__(cls, s, filename, linenumber):
        self = unicode.__new__(cls, s)
        self.filename = filename
        self.linenumber = linenumber
        return self

    def __getnewargs__(self):
        return (unicode(self), self.filename, self.linenumber) # E1101

class PyCode(object):

    __slots__ = [
        'source',
        'location',
        'mode',
        'bytecode',
        'hash',
        ]

    def __getstate__(self):
        return (1, self.source, self.location, self.mode)

    def __setstate__(self, state):
        (_, self.source, self.location, self.mode) = state
        self.bytecode = None

        if renpy.game.script.record_pycode:
            renpy.game.script.all_pycode.append(self)

    def __init__(self, source, loc=('<none>', 1), mode='exec'):

        if isinstance(source, PyExpr):
            loc = (source.filename, source.linenumber, source)

        # The source code.
        self.source = source

        # The time is necessary so we can disambiguate between Python
        # blocks on the same line in different script versions.
        self.location = loc + ( int(time.time()), )
        self.mode = mode

        # This will be initialized later on, after we are serialized.
        self.bytecode = None

        if renpy.game.script.record_pycode:
            renpy.game.script.all_pycode.append(self)

        self.hash = None

    def get_hash(self):
        try:
            if self.hash is not None:
                return self.hash
        except:
            pass

        code = self.source
        if isinstance(code, renpy.python.ast.AST): #@UndefinedVariable
            code = renpy.python.ast.dump(code) #@UndefinedVariable

        self.hash = chr(renpy.bytecode_version) + md5.md5(repr(self.location) + code.encode("utf-8")).digest()
        return self.hash


def chain_block(block, next): #@ReservedAssignment
    """
    This is called to chain together all of the nodes in a block. Node
    n is chained with node n+1, while the last node is chained with
    next.
    """

    if not block:
        return

    for a, b in zip(block, block[1:]):
        a.chain(b)

    block[-1].chain(next)


class Scry(object):
    """
    This is used to store information about the future, if we know it. Unlike
    predict, this tries to only get things we _know_ will happen.
    """

    # By default, all attributes are None.
    def __getattr__(self, name):
        return None

    def next(self): #@ReservedAssignment
        if self._next is None:
            return None
        else:
            return self._next.scry()


class Node(object):
    """
    A node in the abstract syntax tree of the program.

    @ivar name: The name of this node.

    @ivar filename: The filename where this node comes from.
    @ivar linenumber: The line number of the line on which this node is defined.
    """

    __slots__ = [
        'name',
        'filename',
        'linenumber',
        'next',
        ]

    # True if this node is translatable, false otherwise. (This can be set on
    # the class or the instance.)
    translatable = False

    # Called to set the state of a Node, when necessary.
    def __setstate__(self, state):
        for k, v in state[1].iteritems():
            try:
                setattr(self, k, v)
            except AttributeError:
                pass


    def __init__(self, loc):
        """
        Initializes this Node object.

        @param loc: A (filename, physical line number) tuple giving the
        logical line on which this Node node starts.
        """

        self.filename, self.linenumber  = loc
        self.name = None
        self.next = None

    def diff_info(self):
        """
        Returns a tuple of diff info about ourself. This is used to
        compare Nodes to see if they should be considered the same node. The
        tuple returned must be hashable.
        """

        return ( id(self), )

    def get_children(self):
        """
        Returns a list of all of the nodes that are children of this
        node. (That is, all of the nodes in any block associated with
        this node.)
        """

        return [ ]

    def get_init(self):
        """
        Returns a node that should be run at init time (that is, before
        the normal start of the script.), or None if this node doesn't
        care to suggest one.

        (The only class that needs to override this is Init.)
        """

        return None

    def chain(self, next): #@ReservedAssignment
        """
        This is called with the Node node that should be followed after
        executing this node, and all nodes that this node
        executes. (For example, if this node is a block label, the
        next is the node that should be executed after all nodes in
        the block.)
        """

        self.next = next

    def execute(self):
        """
        Causes this node to execute, and any action it entails to be
        performed. The node should call next_node with the node to
        be executed after this one.
        """

        raise Exception("Node subclass forgot to define execute.")

    def early_execute(self):
        """
        Called when the module is loaded.
        """

    def predict(self):
        """
        This is called to predictively load images from this node.  It
        should cause renpy.display.predict.image and
        renpy.display.predict.screen to be called as necessary.
        """

        if self.next:
            return [ self.next ]
        else:
            return [ ]

    def scry(self):
        """
        Called to return an object with some general, user-definable information
        about the future.
        """

        rv = Scry()
        rv._next = self.next # W0201
        return rv

    def restructure(self, callback):
        """
        Called to restructure the AST.

        When this method is called, callback is called once for each child
        block of the node. The block, a list, can be updated by the callback
        using slice assignment to the list.
        """

        # Does nothing for nodes that do not contain child blocks.
        return

    def get_code(self, dialogue_filter=None):
        """
        Returns the canonical form of the code corresponding to this statement.
        This only needs to be defined if the statement is translatable.

        `filter`
            If present, a filter that should be applied to human-readable
            text in the statement.
        """

        raise Exception("Not Implemented")

def say_menu_with(expression, callback):
    """
    This handles the with clause of a say or menu statement.
    """

    if expression is not None:
        what = renpy.python.py_eval(expression)
    elif renpy.store.default_transition and renpy.game.preferences.transitions == 2:
        what = renpy.store.default_transition
    else:
        return

    if not what:
        return

    if renpy.game.preferences.transitions:
        # renpy.game.interface.set_transition(what)
        callback(what)

class Say(Node):

    __slots__ = [
        'who',
        'who_fast',
        'what',
        'with_',
        'interact',
        'attributes',
        ]

    def diff_info(self):
        return (Say, self.who, self.what)

    def __setstate__(self, state):
        self.attributes = None
        self.interact = True
        Node.__setstate__(self, state)

    def __init__(self, loc, who, what, with_, interact=True, attributes=None):

        super(Say, self).__init__(loc)

        if who is not None:
            self.who = who.strip()

            # True if who is a simple enough expression we can just look it up.
            if re.match(renpy.parser.word_regexp + "$", self.who):
                self.who_fast = True
            else:
                self.who_fast = False
        else:
            self.who = None
            self.who_fast = False

        self.what = what
        self.with_ = with_
        self.interact = interact

        # A tuple of attributes that are applied to the character that's
        # speaking, or None to disable this behavior.
        self.attributes = attributes

    def get_code(self, dialogue_filter=None):
        rv = [ ]

        if self.who:
            rv.append(self.who)

        if self.attributes is not None:
            rv.extend(self.attributes)

        what = self.what
        if dialogue_filter is not None:
            what = dialogue_filter(what)

        rv.append(renpy.translation.encode_say_string(what))

        if not self.interact:
            rv.append("nointeract")

        if self.with_:
            rv.append("with")
            rv.append(self.with_)

        return " ".join(rv)

    def execute(self):

        next_node(self.next)
        statement_name("say")

        try:

            renpy.game.context().say_attributes = self.attributes

            if self.who is not None:
                if self.who_fast:
                    who = renpy.python.store_dicts['store'].get(self.who, None)
                    if who is None:
                        raise Exception("Sayer '%s' is not defined." % self.who.encode("utf-8"))
                else:
                    who = renpy.python.py_eval(self.who)
            else:
                who = None

            if not (
                (who is None) or
                callable(who) or
                isinstance(who, basestring) ):

                raise Exception("Sayer %s is not a function or string." % self.who.encode("utf-8"))

            what = self.what
            if renpy.config.say_menu_text_filter:
                what = renpy.config.say_menu_text_filter(what) # E1102

            renpy.store._last_raw_what = what

            if getattr(who, "record_say", True):
                renpy.store._last_say_who = self.who
                renpy.store._last_say_what = what

            say_menu_with(self.with_, renpy.game.interface.set_transition)
            renpy.exports.say(who, what, interact=self.interact)

        finally:
            renpy.game.context().say_attributes = None


    def predict(self):

        old_attributes = renpy.game.context().say_attributes

        try:

            renpy.game.context().say_attributes = self.attributes

            if self.who is not None:
                if self.who_fast:
                    who = getattr(renpy.store, self.who)
                else:
                    who = renpy.python.py_eval(self.who)
            else:
                who = None

            def predict_with(trans):
                renpy.display.predict.displayable(trans(old_widget=None, new_widget=None))

            say_menu_with(self.with_, predict_with)

            what = self.what
            if renpy.config.say_menu_text_filter:
                what = renpy.config.say_menu_text_filter(what)

            renpy.exports.predict_say(who, what)

        finally:
            renpy.game.context().say_attributes = old_attributes

        return [ self.next ]

    def scry(self):
        rv = Node.scry(self)

        if self.who is not None:
            if self.who_fast:
                who = getattr(renpy.store, self.who)
            else:
                who = renpy.python.py_eval(self.who)
        else:
            who = None

        if self.interact:
            renpy.exports.scry_say(who, rv)
        else:
            rv.interacts = False

        return rv

# Copy the descriptor.
setattr(Say, "with", Say.with_) # E1101

class Init(Node):

    __slots__ = [
        'block',
        'priority',
        ]

    def __init__(self, loc, block, priority):
        super(Init, self).__init__(loc)

        self.block = block
        self.priority = priority


    def get_children(self):
        return self.block

    def get_init(self):
        return self.priority, self.block[0]

    # We handle chaining specially. We want to chain together the nodes in
    # the block, but we want that chain to end in None, and we also want
    # this node to just continue on to the next node in normal execution.
    def chain(self, next): #@ReservedAssignment
        self.next = next

        chain_block(self.block, None)

    def execute(self):
        next_node(self.next)
        statement_name("init")

    def restructure(self, callback):
        callback(self.block)


class Label(Node):

    __slots__ = [
        'name',
        'parameters',
        'block',
        'hide',
        ]

    def __setstate__(self, state):
        self.parameters = None
        self.hide = False
        Node.__setstate__(self, state)

    def __init__(self, loc, name, block, parameters, hide=False):
        """
        Constructs a new Label node.

        @param name: The name of this label.
        @param block: A (potentially empty) list of nodes making up the
        block associated with this label.
        """

        super(Label, self).__init__(loc)

        self.name = name
        self.block = block
        self.parameters = parameters
        self.hide = hide

    def diff_info(self):
        return (Label, self.name)

    def get_children(self):
        return self.block

    def chain(self, next): #@ReservedAssignment

        if self.block:
            self.next = self.block[0]
            chain_block(self.block, next)
        else:
            self.next = next

    def execute(self):
        next_node(self.next)
        statement_name("label")

        renpy.game.context().mark_seen()

        values = apply_arguments(self.parameters, renpy.store._args, renpy.store._kwargs)

        for k, v in values.iteritems():
            renpy.exports.dynamic(k)
            setattr(renpy.store, k, v)

        renpy.store._args = None
        renpy.store._kwargs = None

        if renpy.config.label_callback:
            renpy.config.label_callback(self.name, renpy.game.context().last_abnormal)

    def restructure(self, callback):
        callback(self.block)


class Python(Node):

    __slots__ = [
        'hide',
        'code',
        'store',
        ]

    def __setstate__(self, state):
        self.store = "store"
        super(Python, self).__setstate__(state)

    def __init__(self, loc, python_code, hide=False, store="store"):
        """
        @param code: A PyCode object.

        @param hide: If True, the code will be executed with its
        own local dictionary.
        """

        super(Python, self).__init__(loc)

        self.hide = hide
        self.code = PyCode(python_code, loc=loc, mode='exec')
        self.store = store

    def diff_info(self):
        return (Python, self.code.source)

    def early_execute(self):
        renpy.python.create_store(self.store)

    def execute(self):
        next_node(self.next)
        statement_name("python")

        try:
            renpy.python.py_exec_bytecode(self.code.bytecode, self.hide, store=self.store)
        finally:

            if not renpy.game.context().init_phase:
                for i in renpy.config.python_callbacks:
                    i()

    def scry(self):
        rv = Node.scry(self)
        rv.interacts = True
        return rv

class EarlyPython(Node):

    __slots__ = [
        'hide',
        'code',
        'store',
        ]

    def __setstate__(self, state):
        self.store = "store"
        super(EarlyPython, self).__setstate__(state)

    def __init__(self, loc, python_code, hide=False, store="store"):
        """
        @param code: A PyCode object.

        @param hide: If True, the code will be executed with its
        own local dictionary.
        """

        super(EarlyPython, self).__init__(loc)

        self.hide = hide
        self.code = PyCode(python_code, loc=loc, mode='exec')
        self.store = store

    def diff_info(self):
        return (EarlyPython, self.code.source)

    def execute(self):
        next_node(self.next)
        statement_name("python early")

    def early_execute(self):
        renpy.python.create_store(self.store)

        if self.code.bytecode:
            renpy.python.py_exec_bytecode(self.code.bytecode, self.hide, store=self.store)

class Image(Node):

    __slots__ = [
        'imgname',
        'code',
        'atl',
        ]

    def __init__(self, loc, name, expr=None, atl=None):
        """
        @param name: The name of the image being defined.

        @param expr: An expression yielding a Displayable that is
        assigned to the image.
        """

        super(Image, self).__init__(loc)

        self.imgname = name

        if expr:
            self.code = PyCode(expr, loc=loc, mode='eval')
            self.atl = None
        else:
            self.code = None
            self.atl = atl

    def diff_info(self):
        return (Image, tuple(self.imgname))

    def execute(self):

        # Note: We should always check that self.code is None before
        # accessing self.atl, as self.atl may not always exist.

        next_node(self.next)
        statement_name("image")

        if self.code is not None:
            img = renpy.python.py_eval_bytecode(self.code.bytecode)
        else:
            img = renpy.display.motion.ATLTransform(self.atl)

        renpy.exports.image(self.imgname, img)



class Transform(Node):

    __slots__ = [

        # The name of the transform.
        'varname',

        # The block of ATL associated with the transform.
        'atl',

        # The parameters associated with the transform, if any.
        'parameters',
        ]

    default_parameters = ParameterInfo([ ], [ ], None, None)

    def __init__(self, loc, name, atl=None, parameters=default_parameters):

        super(Transform, self).__init__(loc)

        self.varname = name
        self.atl = atl
        self.parameters = parameters

    def diff_info(self):
        return (Transform, self.varname)

    def execute(self):

        next_node(self.next)
        statement_name("transform")

        parameters = getattr(self, "parameters", None)

        if parameters is None:
            parameters = Transform.default_parameters

        trans = renpy.display.motion.ATLTransform(self.atl, parameters=parameters)
        renpy.dump.transforms.append((self.varname, self.filename, self.linenumber))
        setattr(renpy.store, self.varname, trans)


def predict_imspec(imspec, scene=False, atl=None):
    """
    Call this to use the given callback to predict the image named
    in imspec.
    """

    if len(imspec) == 7:
        name, expression, tag, at_expr_list, layer, _zorder, _behind = imspec

    elif len(imspec) == 6:
        name, expression, tag, at_expr_list, layer, _zorder = imspec

    elif len(imspec) == 3:
        name, at_expr_list, layer = imspec
        tag = None
        expression = None

    if expression:
        try:
            img = renpy.python.py_eval(expression)
            img = renpy.easy.displayable(img)
        except:
            return
    else:
        img = None

    at_list = [ ]
    for i in at_expr_list:
        try:
            at_list.append(renpy.python.py_eval(i))
        except:
            pass


    if atl is not None:
        try:
            at_list.append(renpy.display.motion.ATLTransform(atl))
        except:
            pass

    if scene:
        renpy.game.context().images.predict_scene(layer)

    renpy.exports.predict_show(name, layer, what=img, tag=tag)


def show_imspec(imspec, atl=None):

    if len(imspec) == 7:
        name, expression, tag, at_list, layer, zorder, behind = imspec

    elif len(imspec) == 6:
        name, expression, tag, at_list, layer, zorder = imspec
        behind = [ ]

    elif len(imspec) == 3:
        name, at_list, layer = imspec
        expression = None
        tag = None
        zorder = None
        behind = [ ]

    if zorder is not None:
        zorder = renpy.python.py_eval(zorder)
    else:
        zorder = 0

    if expression is not None:
        expression = renpy.python.py_eval(expression)
        expression = renpy.easy.displayable(expression)

    at_list = [ renpy.python.py_eval(i) for i in at_list ]

    renpy.config.show(name,
                      at_list=at_list,
                      layer=layer,
                      what=expression,
                      zorder=zorder,
                      tag=tag,
                      behind=behind,
                      atl=atl)

class Show(Node):

    __slots__ = [
        'imspec',
        'atl',
        ]

    def __init__(self, loc, imspec, atl=None):
        """
        @param imspec: A triple consisting of an image name (itself a
        tuple of strings), a list of at expressions, and a layer.
        """

        super(Show, self).__init__(loc)

        self.imspec = imspec
        self.atl = atl

    def diff_info(self):
        return (Show, tuple(self.imspec[0]))

    def execute(self):
        next_node(self.next)
        statement_name("show")

        show_imspec(self.imspec, atl=getattr(self, "atl", None))

    def predict(self):
        predict_imspec(self.imspec, atl=getattr(self, "atl", None))
        return [ self.next ]


class ShowLayer(Node):

    __slots__ = [
        'layer',
        'at_list',
        'atl',
        ]

    def __init__(self, loc, layer, at_list, atl):
        super(ShowLayer, self).__init__(loc)

        self.layer = layer
        self.at_list = at_list
        self.atl = atl

    def diff_info(self):
        return (ShowLayer, self.layer)

    def execute(self):
        next_node(self.next)
        statement_name("show layer")

        at_list = [ renpy.python.py_eval(i) for i in self.at_list ]

        if self.atl is not None:
            atl = renpy.display.motion.ATLTransform(self.atl)
            at_list.append(atl)

        renpy.exports.layer_at_list(at_list, layer=self.layer)

    def predict(self):
        return [ self.next ]


class Scene(Node):

    __slots__ = [
        'imspec',
        'layer',
        'atl',
        ]

    def __init__(self, loc, imgspec, layer, atl=None):
        """
        @param imspec: A triple consisting of an image name (itself a
        tuple of strings), a list of at expressions, and a layer, or
        None to not have this scene statement also display an image.
        """

        super(Scene, self).__init__(loc)

        self.imspec = imgspec
        self.layer = layer
        self.atl = atl

    def diff_info(self):

        if self.imspec:
            data = tuple(self.imspec[0])
        else:
            data = None

        return (Scene, data)

    def execute(self):

        next_node(self.next)
        statement_name("scene")

        renpy.config.scene(self.layer)

        if self.imspec:
            show_imspec(self.imspec, atl=getattr(self, "atl", None))

    def predict(self):

        if self.imspec:
            predict_imspec(self.imspec, atl=getattr(self, "atl", None), scene=True)

        return [ self.next ]


class Hide(Node):

    __slots__ = [
        'imspec',
        ]

    def __init__(self, loc, imgspec):
        """
        @param imspec: A triple consisting of an image name (itself a
        tuple of strings), a list of at expressions, and a list of
        with expressions.
        """

        super(Hide, self).__init__(loc)

        self.imspec = imgspec

    def diff_info(self):
        return (Hide, tuple(self.imspec[0]))

    def predict(self):

        if len(self.imspec) == 3:
            name, _at_list, layer = self.imspec
            tag = None
            _expression = None
            _zorder = None
            _behind = None
        elif len(self.imspec) == 6:
            name, _expression, tag, _at_list, layer, _zorder = self.imspec
            _behind = None
        elif len(self.imspec) == 7:
            name, _expression, tag, _at_list, layer, _zorder, _behind = self.imspec


        if tag is None:
            tag = name[0]

        renpy.game.context().images.predict_hide(tag, layer)

        return [ self.next ]

    def execute(self):

        next_node(self.next)
        statement_name("hide")

        if len(self.imspec) == 3:
            name, _at_list, layer = self.imspec
            _expression = None
            tag = None
            _zorder = 0
        elif len(self.imspec) == 6:
            name, _expression, tag, _at_list, layer, _zorder = self.imspec
        elif len(self.imspec) == 7:
            name, _expression, tag, _at_list, layer, _zorder, _behind = self.imspec

        renpy.config.hide(tag or name, layer)


class With(Node):

    __slots__ = [
        'expr',
        'paired',
        ]

    def __setstate__(self, state):
        self.paired = None
        Node.__setstate__(self, state)

    def __init__(self, loc, expr, paired=None):
        """
        @param expr: An expression giving a transition or None.
        """

        super(With, self).__init__(loc)
        self.expr = expr
        self.paired = paired

    def diff_info(self):
        return (With, self.expr)

    def execute(self):

        next_node(self.next)
        statement_name("with")

        trans = renpy.python.py_eval(self.expr)

        if self.paired is not None:
            paired = renpy.python.py_eval(self.paired)
        else:
            paired = None

        renpy.exports.with_statement(trans, paired)

    def predict(self):

        try:
            trans = renpy.python.py_eval(self.expr)

            if trans:
                renpy.display.predict.displayable(trans(old_widget=None, new_widget=None))

        except:
            pass


        return [ self.next ]


class Call(Node):

    __slots__ = [
        'label',
        'arguments',
        'expression',
        ]

    def __setstate__(self, state):
        self.arguments = None
        Node.__setstate__(self, state)

    def __init__(self, loc, label, expression, arguments):

        super(Call, self).__init__(loc)
        self.label = label
        self.expression = expression
        self.arguments = arguments

    def diff_info(self):
        return (Call, self.label, self.expression)

    def execute(self):

        statement_name("call")

        label = self.label
        if self.expression:
            label = renpy.python.py_eval(label)

        rv = renpy.game.context().call(label, return_site=self.next.name)
        next_node(rv)
        renpy.game.context().abnormal = True

        if self.arguments:
            args, kwargs = self.arguments.evaluate()
            renpy.store._args = args
            renpy.store._kwargs = kwargs

    def predict(self):
        if self.expression:
            return [ ]
        else:
            return [ renpy.game.script.lookup(self.label) ]

    def scry(self):
        rv = Node.scry(self)
        rv._next = None
        return rv


class Return(Node):

    __slots__ = [ 'expression']

    def __setstate__(self, state):
        self.expression = None
        Node.__setstate__(self, state)

    def __init__(self, loc, expression):
        super(Return, self).__init__(loc)
        self.expression = expression

    def diff_info(self):
        return (Return, )

    # We don't care what the next node is.
    def chain(self, next): #@ReservedAssignment
        self.next = None
        return

    def execute(self):

        statement_name("return")

        if self.expression:
            renpy.store._return = renpy.python.py_eval(self.expression)
        else:
            renpy.store._return = None

        renpy.game.context().pop_dynamic()

        next_node(renpy.game.context().lookup_return(pop=True))

    def predict(self):
        site = renpy.game.context().lookup_return(pop=False)
        if site:
            return [ site ]
        else:
            return [ ]

    def scry(self):
        rv = Node.scry(self)
        rv._next = None
        return rv


class Menu(Node):

    __slots__ = [
        'items',
        'set',
        'with_',
        ]

    def __init__(self, loc, items, set, with_): #@ReservedAssignment
        super(Menu, self).__init__(loc)

        self.items = items
        self.set = set
        self.with_ = with_

    def diff_info(self):
        return (Menu,)

    def get_children(self):
        rv = [ ]

        for _label, _condition, block in self.items:
            if block:
                rv.extend(block)

        return rv

    # Blocks of statements in a choice continue after the menu.
    def chain(self, next): #@ReservedAssignment

        self.next = next

        for (_label, _condition, block) in self.items:
            if block:
                chain_block(block, next)

    def execute(self):

        next_node(self.next)
        statement_name("menu")

        choices = [ ]
        narration = [ ]

        for i, (label, condition, block) in enumerate(self.items):

            if renpy.config.say_menu_text_filter:
                label = renpy.config.say_menu_text_filter(label)

            if block is None:
                if renpy.config.narrator_menu and label:
                    narration.append(label)
                else:
                    choices.append((label, condition, None))
            else:
                choices.append((label, condition, i))
                next_node(block[0])

        if narration:
            renpy.exports.say(None, "\n".join(narration), interact=False)

        say_menu_with(self.with_, renpy.game.interface.set_transition)
        choice = renpy.exports.menu(choices, self.set)

        if choice is not None:
            next_node(self.items[choice][2][0])
        else:
            next_node(self.next)


    def predict(self):
        rv = [ ]

        def predict_with(trans):
            renpy.display.predict.displayable(trans(old_widget=None, new_widget=None))

        say_menu_with(self.with_, predict_with)

        renpy.store.predict_menu()

        for _label, _condition, block in self.items:
            if block:
                rv.append(block[0])

        return rv

    def scry(self):
        rv = Node.scry(self)
        rv._next = None
        rv.interacts = True
        return rv

    def restructure(self, callback):
        for _label, _condition, block in self.items:
            if block is not None:
                callback(block)

setattr(Menu, "with", Menu.with_) # E1101


# Goto is considered harmful. So we decided to name it "jump"
# instead.
class Jump(Node):

    __slots__ = [
        'target',
        'expression',
        ]

    def  __init__(self, loc, target, expression):
        super(Jump, self).__init__(loc)

        self.target = target
        self.expression = expression

    def diff_info(self):
        return (Jump, self.target, self.expression)

    # We don't care what our next node is.
    def chain(self, next): #@ReservedAssignment
        self.next = None
        return

    def execute(self):

        statement_name("jump")

        target = self.target
        if self.expression:
            target = renpy.python.py_eval(target)

        rv = renpy.game.script.lookup(target)
        renpy.game.context().abnormal = True

        next_node(rv)

    def predict(self):

        if self.expression:
            return [ ]
        else:
            return [ renpy.game.script.lookup(self.target) ]

    def scry(self):
        rv = Node.scry(self)
        if self.expression:
            rv._next = None
        else:
            rv._next = renpy.game.script.lookup(self.target)

        return rv


# GNDN
class Pass(Node):

    __slots__ = [ ]

    def diff_info(self):
        return (Pass,)

    def execute(self):
        next_node(self.next)
        statement_name("pass")


class While(Node):

    __slots__ = [
        'condition',
        'block',
        ]

    def __init__(self, loc, condition, block):
        super(While, self).__init__(loc)

        self.condition = condition
        self.block = block

    def diff_info(self):
        return (While, self.condition)

    def get_children(self):
        return self.block

    def chain(self, next): #@ReservedAssignment
        self.next = next
        chain_block(self.block, self)

    def execute(self):

        next_node(self.next)
        statement_name("while")

        if renpy.python.py_eval(self.condition):
            next_node(self.block[0])

    def predict(self):
        return [ self.block[0], self.next ]

    def scry(self):
        rv = Node.scry(self)
        rv._next = None
        return rv

    def restructure(self, callback):
        callback(self.block)

class If(Node):

    __slots__ = [ 'entries' ]

    def __init__(self, loc, entries):
        """
        @param entries: A list of (condition, block) tuples.
        """

        super(If, self).__init__(loc)

        self.entries = entries

    def diff_info(self):
        return (If,)

    def get_children(self):
        rv = [ ]

        for _condition, block in self.entries:
            rv.extend(block)

        return rv

    def chain(self, next): #@ReservedAssignment
        self.next = next

        for _condition, block in self.entries:
            chain_block(block, next)

    def execute(self):

        next_node(self.next)
        statement_name("if")

        for condition, block in self.entries:
            if renpy.python.py_eval(condition):
                next_node(block[0])
                return

    def predict(self):

        return [ block[0] for _condition, block in self.entries ] + \
               [ self.next ]

    def scry(self):
        rv = Node.scry(self)
        rv._next = None
        return rv

    def restructure(self, callback):
        for _condition, block in self.entries:
            callback(block)

class UserStatement(Node):

    __slots__ = [
        'line',
        'parsed',
        'block',
        'translatable' ]

    def __setstate__(self, state):
        self.block = [ ]
        self.translatable = False
        Node.__setstate__(self, state)

    def __init__(self, loc, line, block):

        super(UserStatement, self).__init__(loc)
        self.line = line
        self.block = block
        self.parsed = None

        # Do not store the parse quite yet.
        _parse_info = renpy.statements.parse(self, self.line, self.block)

    def diff_info(self):
        return (UserStatement, self.line)

    def execute(self):
        next_node(self.get_next())
        statement_name(self.get_name())

        self.call("execute")

    def predict(self):
        predictions = self.call("predict")

        if predictions is not None:
            for i in predictions:
                renpy.easy.predict(i)

        return [ self.get_next() ]

    def call(self, method, *args, **kwargs):

        parsed = self.parsed
        if parsed is None:
            parsed = renpy.statements.parse(self, self.line, self.block)
            self.parsed = parsed

        renpy.statements.call(method, parsed, *args, **kwargs)

    def get_name(self):
        parsed = self.parsed
        if parsed is None:
            parsed = renpy.statements.parse(self, self.line, self.block)
            self.parsed = parsed

        return renpy.statements.get_name(parsed)

    def get_next(self):
        rv = self.call("next")
        if rv is not None:
            return renpy.game.script.lookup(rv)
        else:
            return self.next

    def scry(self):
        rv = Node.scry(self)
        rv._next = self.get_next()
        self.call("scry", rv)
        return rv

    def get_code(self, dialogue_filter=None):
        return self.line


class Define(Node):

    __slots__ = [
        'varname',
        'code',
        ]

    def __init__(self, loc, name, expr):
        """
        @param name: The name of the image being defined.

        @param expr: An expression yielding a Displayable that is
        assigned to the image.
        """

        super(Define, self).__init__(loc)

        self.varname = name
        self.code = PyCode(expr, loc=loc, mode='eval')

    def diff_info(self):
        return (Define, tuple(self.varname))

    def execute(self):

        next_node(self.next)
        statement_name("define")

        value = renpy.python.py_eval_bytecode(self.code.bytecode)
        renpy.dump.definitions.append((self.varname, self.filename, self.linenumber))
        renpy.exports.const(self.varname)
        renpy.python.store_dicts["store"][self.varname] = value


class Screen(Node):

    __slots__ = [
        'screen',
        ]

    def __init__(self, loc, screen):
        """
        @param name: The name of the image being defined.

        @param expr: An expression yielding a Displayable that is
        assigned to the image.
        """

        super(Screen, self).__init__(loc)

        self.screen = screen

    def diff_info(self):
        return (Screen, self.screen.name)

    def execute(self):
        next_node(self.next)
        statement_name("screen")

        self.screen.define()
        renpy.dump.screens.append((self.screen.name, self.filename, self.linenumber))


################################################################################
# Translations
################################################################################

class Translate(Node):
    """
    A translation block, produced either by explicit translation statements
    or implicit translation blocs.

    If language is None, when executed this transfers control to the translate
    statement in the current language, if any, and otherwise runs the block.
    If language is not None, causes an error to occur if control reaches this
    statement.

    When control normally leaves a translate statement, in any language, it
    goes to the end of the translate statement in the None language.
    """

    __slots__ = [
        "identifier",
        "language",
        "block",
        ]

    def __init__(self, loc, identifier, language, block):
        super(Translate, self).__init__(loc)

        self.identifier = identifier
        self.language = language
        self.block = block

    def diff_info(self):
        return (Translate, self.identifier, self.language)

    def chain(self, next): #@ReservedAssignment
        self.next = next
        chain_block(self.block, next)

    def execute(self):

        statement_name("translate")

        if self.language is not None:
            next_node(self.next)
            raise Exception("Translation nodes cannot be run directly.")

        next_node(renpy.game.script.translator.lookup_translate(self.identifier))

        renpy.game.context().translate_identifier = self.identifier

    def predict(self):
        node = renpy.game.script.translator.lookup_translate(self.identifier)
        return [ node ]

    def scry(self):
        rv = Scry()
        rv._next = renpy.game.script.translator.lookup_translate(self.identifier)
        return rv

    def get_children(self):
        return self.block

    def restructure(self, callback):
        return callback(self.block)


class EndTranslate(Node):
    """
    A node added implicitly after each translate block. It's responsible for
    resetting the translation identifier.
    """

    def __init__(self, loc):
        super(EndTranslate, self).__init__(loc)

    def diff_info(self):
        return (EndTranslate,)

    def execute(self):
        next_node(self.next)
        statement_name("end translate")

        renpy.game.context().translate_identifier = None


class TranslateString(Node):
    """
    A node used for translated strings.
    """

    __slots__ = [
        "language",
        "old",
        "new"
        ]

    def __init__(self, loc, language, old, new):
        super(TranslateString, self).__init__(loc)
        self.language = language
        self.old = old
        self.new = new

    def diff_info(self):
        return (TranslateString,)

    def execute(self):
        next_node(self.next)
        statement_name("translate string")

        renpy.translation.add_string_translation(self.language, self.old, self.new)

class TranslatePython(Node):
    """
    Runs python code when changing the language.

    This is no longer generated, but is still run when encountered.
    """

    __slots__ = [
        'language',
        'code',
        ]

    def __init__(self, loc, language, python_code):
        """
        @param code: A PyCode object.

        @param hide: If True, the code will be executed with its
        own local dictionary.
        """

        super(TranslatePython, self).__init__(loc)

        self.language = language
        self.code = PyCode(python_code, loc=loc, mode='exec')

    def diff_info(self):
        return (TranslatePython, self.code.source)

    def execute(self):
        next_node(self.next)
        statement_name("translate_python")

    # def early_execute(self):
    #    renpy.python.create_store(self.store)
    #    renpy.python.py_exec_bytecode(self.code.bytecode, self.hide, store=self.store)


class TranslateBlock(Node):
    """
    Runs a block of code when changing the language.
    """

    __slots__ = [
        'block',
        'language',
        ]

    def __init__(self, loc, language, block):
        super(TranslateBlock, self).__init__(loc)

        self.language = language
        self.block = block

    def get_children(self):
        return self.block

    # We handle chaining specially. We want to chain together the nodes in
    # the block, but we want that chain to end in None, and we also want
    # this node to just continue on to the next node in normal execution.
    def chain(self, next): #@ReservedAssignment
        self.next = next
        chain_block(self.block, None)

    def execute(self):
        next_node(self.next)
        statement_name("translate_block")

    def restructure(self, callback):
        callback(self.block)

class Style(Node):

    __slots__ = [
        'style_name',
        'parent',
        'properties',
        'clear',
        'take',
        'delattr',
        'variant',
    ]

    def __init__(self, loc, name):
        """
        `name`
            The name of the style to define.
        """

        super(Style, self).__init__(loc)

        self.style_name = name

        # The parent of this style.
        self.parent = None

        # Properties.
        self.properties = { }

        # Should we clear the style?
        self.clear = False

        # Should we take properties from another style?
        self.take = None

        # A list of attributes we should delete from this style.
        self.delattr = [ ]

        # If not none, an expression for the variant.
        self.variant = None

    def diff_info(self):
        return (Style, self.style_name)

    def execute(self):
        next_node(self.next)
        statement_name("style")

        if self.variant is not None:
            variant = renpy.python.py_eval(self.variant)
            if not renpy.exports.variant(variant):
                return

        s = renpy.style.get_or_create_style(self.style_name) # @UndefinedVariable

        if self.clear:
            s.clear()

        if self.parent is not None:
            s.set_parent(self.parent)

        if self.take is not None:
            s.take(self.take)

        for i in self.delattr:
            s.delattr(i)

        if self.properties:
            properties = { }
            for name, expr in self.properties.items():
                properties[name] = renpy.python.py_eval(expr)

            s.add_properties(properties)

########NEW FILE########
__FILENAME__ = atl
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import random

def compiling(loc):
    file, number = loc #@ReservedAssignment

    renpy.game.exception_info = "Compiling ATL code at %s:%d" % (file, number)

def executing(loc):
    file, number = loc #@ReservedAssignment

    renpy.game.exception_info = "Executing ATL code at %s:%d" % (file, number)


# A map from the name of a time warp function to the function itself.
warpers = { }

def atl_warper(f):
    name = f.func_name
    warpers[name] = f
    return f

# The pause warper is used internally when no other warper is
# specified.
@atl_warper
def pause(t):
    if t < 1.0:
        return 0.0
    else:
        return 1.0

position = renpy.object.Sentinel("position")

def any_object(x):
    return x

# A dictionary giving property names and the corresponding default
# values.
PROPERTIES = {
        "pos" : (position, position),
        "xpos" : position,
        "ypos" : position,
        "anchor" : (position, position),
        "xanchor" : position,
        "yanchor" : position,
        "xaround" : position,
        "yaround" : position,
        "xanchoraround" : float,
        "yanchoraround" : float,
        "align" : (float, float),
        "xalign" : float,
        "yalign" : float,
        "rotate" : float,
        "rotate_pad" : bool,
        "transform_anchor" : bool,
        "xzoom" : float,
        "yzoom" : float,
        "zoom" : float,
        "alpha" : float,
        "additive" : float,
        "around" : (position, position),
        "alignaround" : (float, float),
        "angle" : float,
        "radius" : float,
        "crop" : (float, float, float, float),
        "size" : (int, int),
        "corner1" : (float, float),
        "corner2" : (float, float),
        "subpixel" : bool,
        "delay" : float,
        "xoffset" : float,
        "yoffset" : float,
        "offset" : (int, int),
        "xcenter" : position,
        "ycenter" : position,
        "debug" : any_object,
        }


def correct_type(v, b, ty):
    """
    Corrects the type of v to match ty. b is used to inform the match.
    """

    if ty is position:
        if v is None:
            return None
        else:
            return type(b)(v)
    else:
        return ty(v)


def interpolate(t, a, b, type): #@ReservedAssignment
    """
    Linearly interpolate the arguments.
    """

    if t >= 1.0:
        return b

    # Recurse into tuples.
    if isinstance(b, tuple):
        if a is None:
            a = [ None ] * len(b)

        return tuple(interpolate(t, i, j, ty) for i, j, ty in zip(a, b, type))

    # Deal with booleans, nones, etc.
    elif b is None or isinstance(b, bool):
        if t >= 1.0:
            return b
        else:
            return a

    # Interpolate everything else.
    else:
        if a is None:
            a = 0

        return correct_type(a + t * (b - a), b, type)

# Interpolate the value of a spline. This code is based on Aenakume's code,
# from 00splines.rpy.
def interpolate_spline(t, spline):

    if isinstance(spline[-1], tuple):
        return tuple(interpolate_spline(t, i) for i in zip(*spline))

    if spline[0] is None:
        return spline[-1]

    if len(spline) == 2:
        t_p = 1.0 - t

        rv = t_p * spline[0] + t * spline[-1]

    elif len(spline) == 3:
        t_pp = (1.0 - t)**2
        t_p = 2 * t * (1.0 - t)
        t2 = t**2

        rv = t_pp * spline[0] + t_p * spline[1] + t2 * spline[2]

    elif len(spline) == 4:

        t_ppp = (1.0 - t)**3
        t_pp = 3 * t * (1.0 - t)**2
        t_p = 3 * t**2 * (1.0 - t)
        t3 = t**3

        rv = t_ppp * spline[0] + t_pp * spline[1] + t_p * spline[2] + t3 * spline[3]

    else:
        raise Exception("ATL can't interpolate splines of length %d." % len(spline))

    return correct_type(rv, spline[-1], position)


# This is the context used when compiling an ATL statement. It stores the
# scopes that are used to evaluate the various expressions in the statement,
# and has a method to do the evaluation and return a result.
class Context(object):
    def __init__(self, context):
        self.context = context

    def eval(self, expr): #@ReservedAssignment
        expr = renpy.python.escape_unicode(expr)
        return eval(expr, renpy.store.__dict__, self.context) #@UndefinedVariable

# This is intended to be subclassed by ATLTransform. It takes care of
# managing ATL execution, which allows ATLTransform itself to not care
# much about the contents of this file.
class ATLTransformBase(renpy.object.Object):

    # Compatibility with older saves.
    parameters = renpy.ast.ParameterInfo([ ], [ ], None, None)

    def __init__(self, atl, context, parameters):

        # The constructor will be called by atltransform.

        if parameters is None:
            parameters = ATLTransformBase.parameters

        # The parameters that we take.
        self.parameters = parameters

        # The raw code that makes up this ATL statement.
        self.atl = atl

        # The context in which execution occurs.
        self.context = Context(context)

        # The code after it has been compiled into a block.
        self.block = None

        # The properties of the block, if it contains only an
        # Interpolation.
        self.properties = None

        # The state of the statement we are executing. As this can be
        # shared between more than one object (in the case of a hide),
        # the data must not be altered.
        self.atl_state = None

        # Are we done?
        self.done = False

        # The transform event we are going to process.
        self.transform_event = None

        # The transform event we last processed.
        self.last_transform_event = None

        # The child transform event we last processed.
        self.last_child_transform_event = None

        # The child, without any transformations.
        self.raw_child = None

    def take_execution_state(self, t):
        """
        Updates self to begin executing from the same point as t. This
        requires that t.atl is self.atl.
        """

        super(ATLTransformBase, self).take_execution_state(t)

        if t.atl is not self.atl:
            return

        self.done = t.done
        self.block = t.block
        self.atl_state = t.atl_state
        self.transform_event = t.transform_event
        self.last_transform_event = t.last_transform_event
        self.last_child_transform_event = t.last_child_transform_event

        self.st = t.st
        self.at = t.at
        self.st_offset = t.st_offset
        self.at_offset = t.at_offset

        if self.child is renpy.display.motion.null:
            self.child = t.child
            self.raw_child = t.raw_child



    def __call__(self, *args, **kwargs):

        context = self.context.context.copy()

        for k, v in self.parameters.parameters:
            if v is not None:
                context[k] = renpy.python.py_eval(v)

        positional = list(self.parameters.positional)
        args = list(args)

        child = None

        if not positional and args:
            child = args.pop(0)

        # Handle positional arguments.
        while positional and args:
            name = positional.pop(0)
            value = args.pop(0)

            if name in kwargs:
                raise Exception('Parameter %r is used as both a positional and keyword argument to a transition.' % name)

            context[name] = value

        if args:
            raise Exception("Too many arguments passed to ATL transform.")

        # Handle keyword arguments.
        for k, v in kwargs.iteritems():

            if k in positional:
                positional.remove(k)
                context[k] = v
            elif k in context:
                context[k] = v
            elif k == 'child':
                child = v
            else:
                raise Exception('Parameter %r is not known by ATL Transform.' % k)

        if child is None:
            child = self.child

        if child is None:
            child = renpy.display.motion.get_null()

        # Create a new ATL Transform.
        parameters = renpy.ast.ParameterInfo({}, positional, None, None)

        rv = renpy.display.motion.ATLTransform(
            atl=self.atl,
            child=child,
            style=self.style_arg,
            context=context,
            parameters=parameters)

        rv.take_state(self)

        return rv


    def compile(self): #@ReservedAssignment
        """
        Compiles the ATL code into a block. As necessary, updates the
        properties.
        """

        if self.parameters.positional and self.parameters.positional[0][1] is None:
            raise Exception("Cannot compile ATL Transform, as it's missing positional parameter %s." % self.parameters.positional[0])

        old_exception_info = renpy.game.exception_info

        self.block = self.atl.compile(self.context)

        if len(self.block.statements) == 1 \
                and isinstance(self.block.statements[0], Interpolation):

            interp = self.block.statements[0]

            if interp.duration == 0 and interp.properties:
                self.properties = interp.properties[:]

        renpy.game.exception_info = old_exception_info


    def execute(self, trans, st, at):

        if self.done:
            return None

        if not self.block:
            self.compile()

        # Propagate transform_events from children.
        if self.child:
            if self.child.transform_event != self.last_child_transform_event:
                self.last_child_transform_event = self.child.transform_event
                self.transform_event = self.child.transform_event

        # Hide request.
        if trans.hide_request:
            self.transform_event = "hide"

        if trans.replaced_request:
            self.transform_event = "replaced"

        # Notice transform events.
        if self.transform_event != self.last_transform_event:
            event = self.transform_event
            self.last_transform_event = self.transform_event
        else:
            event = None

        old_exception_info = renpy.game.exception_info

        if self.atl.animation:
            timebase = at
        else:
            timebase = st

        action, arg, pause = self.block.execute(trans, timebase, self.atl_state, event)

        renpy.game.exception_info = old_exception_info

        # print "Executing", self, self.state, self.xpos, self.ypos

        if action == "continue":
            self.atl_state = arg
        else:
            self.done = True

        return pause

    def predict_one(self):
        self.atl.predict(self.context)

    def visit(self):
        if not self.block:
            self.compile()

        return self.children + self.block.visit()


# The base class for raw ATL statements.
class RawStatement(renpy.object.Object):

    def __init__(self, loc):
        super(RawStatement, self).__init__()
        self.loc = loc

    # Compiles this RawStatement into a Statement, by using ctx to
    # evaluate expressions as necessary.
    def compile(self, ctx): #@ReservedAssignment
        raise Exception("Compile not implemented.")

    # Predicts the images used by this statement.
    def predict(self, ctx):
        return

# The base class for compiled ATL Statements.
class Statement(renpy.object.Object):

    def __init__(self, loc):
        super(Statement, self).__init__()
        self.loc = loc

    # trans is the transform we're working on.
    # st is the time since this statement started executing.
    # state is the state stored by this statement, or None if
    # we've just started executing this statement.
    # event is an event we're triggering.
    #
    # "continue", state, pause - Causes this statement to execute
    # again, with the given state passed in the second time around.
    #
    #
    # "next", timeleft, pause - Causes the next statement to execute,
    # with timeleft being the amount of time left after this statement
    # finished.
    #
    # "event", (name, timeleft), pause - Causes an event to be reported,
    # and control to head up to the event handler.
    #
    # "repeat", (count, timeleft), pause - Causes the repeat behavior
    # to occur.
    #
    # As the Repeat statement can only appear in a block, only Block
    # needs to deal with the repeat behavior.
    #
    # Pause is the amount of time until execute should be called again,
    # or None if there's no need to call execute ever again.
    def execute(self, trans, st, state, event):
        raise Exception("Not implemented.")

    # Return a list of displayable children.
    def visit(self):
        return [ ]

# This represents a Raw ATL block.
class RawBlock(RawStatement):

    # Should we use the animation timebase or the showing timebase?
    animation = False

    def __init__(self, loc, statements, animation):

        super(RawBlock, self).__init__(loc)

        # A list of RawStatements in this block.
        self.statements = statements

        self.animation = animation

    def compile(self, ctx): #@ReservedAssignment
        compiling(self.loc)

        statements = [ i.compile(ctx) for i in self.statements ]

        return Block(self.loc, statements)

    def predict(self, ctx):
        for i in self.statements:
            i.predict(ctx)


# A compiled ATL block.
class Block(Statement):
    def __init__(self, loc, statements):

        super(Block, self).__init__(loc)

        # A list of statements in the block.
        self.statements = statements

        # The start times of various statements.
        self.times = [ ]

        for i, s in enumerate(statements):
            if isinstance(s, Time):
                self.times.append((s.time, i + 1))

        self.times.sort()

    def execute(self, trans, st, state, event):

        executing(self.loc)

        # Unpack the state.
        if state is not None:
            index, start, loop_start, repeats, times, child_state = state
        else:
            index, start, loop_start, repeats, times, child_state = 0, 0, 0, 0, self.times[:], None

        # What we might be returning.
        action = "continue"
        arg = None
        pause = None

        while action == "continue":

            # Target is the time we're willing to execute to.
            # Max_pause is how long we'll wait before executing again.

            # If we have times queued up, then use them to inform target
            # and time.
            if times:
                time, tindex = times[0]
                target = min(time, st)
                max_pause = time - target

            # Otherwise, take the defaults.
            else:
                target = st
                max_pause = 15

            while True:

                # If we've hit the last statement, it's the end of
                # this block.
                if index >= len(self.statements):
                    return "next", target - start, None


                # Find the statement and try to run it.
                stmt = self.statements[index]
                action, arg, pause = stmt.execute(trans, target - start, child_state, event)

                # On continue, persist our state.
                if action == "continue":
                    if pause is None:
                        pause = max_pause

                    action, arg, pause = "continue", (index, start, loop_start, repeats, times, arg), min(max_pause, pause)
                    break

                elif action == "event":
                    return action, arg, pause

                # On next, advance to the next statement in the block.
                elif action == "next":
                    index += 1
                    start = target - arg
                    child_state = None

                # On repeat, either terminate the block, or go to
                # the first statement.
                elif action == "repeat":

                    count, arg = arg
                    loop_end = target - arg
                    duration = loop_end - loop_start

                    if duration <= 0:
                        raise Exception("ATL appears to be in an infinite loop.")

                    # Figure how many durations can occur between the
                    # start of the loop and now.
                    new_repeats = int((target - loop_start) / duration)

                    if count is not None:
                        if repeats + new_repeats >= count:
                            new_repeats = count - repeats
                            loop_start += new_repeats * duration
                            return "next", target - loop_start, None

                    repeats += new_repeats
                    loop_start = loop_start + new_repeats * duration
                    start = loop_start
                    index = 0
                    child_state = None

            if times:
                time, tindex = times[0]
                if time <= target:
                    times.pop(0)

                    index = tindex
                    start = time
                    child_state = None

                    continue

            return action, arg, pause

    def visit(self):
        return [ j for i in self.statements for j in i.visit() ]

# This can become one of four things:
#
# - A pause.
# - An interpolation (which optionally can also reference other
# blocks, as long as they're not time-dependent, and have the same
# arity as the interpolation).
# - A call to another block.
# - A command to change the image, perhaps with a transition.
#
# We won't decide which it is until runtime, as we need the
# values of the variables here.
class RawMultipurpose(RawStatement):

    warp_function = None

    def __init__(self, loc):

        super(RawMultipurpose, self).__init__(loc)

        self.warper = None
        self.duration = None
        self.properties = [ ]
        self.expressions = [ ]
        self.splines = [ ]
        self.revolution = None
        self.circles = "0"

    def add_warper(self, name, duration, warp_function):
        self.warper = name
        self.duration = duration
        self.warp_function = warp_function

    def add_property(self, name, exprs):
        self.properties.append((name, exprs))

    def add_expression(self, expr, with_clause):
        self.expressions.append((expr, with_clause))

    def add_revolution(self, revolution):
        self.revolution = revolution

    def add_circles(self, circles):
        self.circles = circles

    def add_spline(self, name, exprs):
        self.splines.append((name, exprs))

    def compile(self, ctx): #@ReservedAssignment

        compiling(self.loc)

        # Figure out what kind of statement we have. If there's no
        # interpolator, and no properties, than we have either a
        # call, or a child statement.
        if (self.warper is None and
            self.warp_function is None and
            not self.properties and
            not self.splines and
            len(self.expressions) == 1):

            expr, withexpr = self.expressions[0]

            child = ctx.eval(expr)
            if withexpr:
                transition = ctx.eval(withexpr)
            else:
                transition = None

            if isinstance(child, (int, float)):
                return Interpolation(self.loc, "pause", child, [ ], None, 0, [ ])

            if isinstance(child, ATLTransformBase):
                child.compile()
                return child.block

            else:
                return Child(self.loc, child, transition)

        compiling(self.loc)

        # Otherwise, we probably have an interpolation statement.

        if self.warp_function:
            warper = ctx.eval(self.warp_function)
        else:
            warper = self.warper or "pause"

            if warper not in warpers:
                raise Exception("ATL Warper %s is unknown at runtime." % warper)

        properties = [ ]

        for name, expr in self.properties:
            if name not in PROPERTIES:
                raise Exception("ATL Property %s is unknown at runtime." % property)

            value = ctx.eval(expr)
            properties.append((name, value))

        splines = [ ]

        for name, exprs in self.splines:
            if name not in PROPERTIES:
                raise Exception("ATL Property %s is unknown at runtime." % property)

            values = [ ctx.eval(i) for i in exprs ]

            splines.append((name, values))

        for expr, _with in self.expressions:
            try:
                value = ctx.eval(expr)
            except:
                raise Exception("Could not evaluate expression %r when compiling ATL." % expr)

            if not isinstance(value, ATLTransformBase):
                raise Exception("Expression %r is not an ATL transform, and so cannot be included in an ATL interpolation." % expr)

            value.compile()

            if value.properties is None:
                raise Exception("ATL transform %r is too complicated to be included in interpolation." % expr)


            properties.extend(value.properties)

        duration = ctx.eval(self.duration)
        circles = ctx.eval(self.circles)

        return Interpolation(self.loc, warper, duration, properties, self.revolution, circles, splines)

    def predict(self, ctx):

        for i, _j in self.expressions:

            try:
                i = ctx.eval(i)
            except:
                continue

            if isinstance(i, ATLTransformBase):
                i.atl.predict(ctx)
                return

            try:
                renpy.easy.predict(i)
            except:
                continue

# This lets us have an ATL transform as our child.
class RawContainsExpr(RawStatement):

    def __init__(self, loc, expr):

        super(RawContainsExpr, self).__init__(loc)

        self.expression = expr

    def compile(self, ctx): #@ReservedAssignment
        compiling(self.loc)
        child = ctx.eval(self.expression)
        return Child(self.loc, child, None)


# This allows us to have multiple children, inside a Fixed.
class RawChild(RawStatement):

    def __init__(self, loc, child):

        super(RawChild, self).__init__(loc)

        self.children = [ child ]

    def compile(self, ctx): #@ReservedAssignment
        box = renpy.display.layout.MultiBox(layout='fixed')

        for i in self.children:
            box.add(renpy.display.motion.ATLTransform(i, context=ctx.context))

        return Child(self.loc, box, None)


# This changes the child of this statement, optionally with a transition.
class Child(Statement):

    def __init__(self, loc, child, transition):

        super(Child, self).__init__(loc)

        self.child = renpy.easy.displayable(child)
        self.transition = transition

    def execute(self, trans, st, state, event):

        executing(self.loc)

        old_child = trans.raw_child

        if (old_child is not None) and (old_child is not renpy.display.motion.null) and (self.transition is not None):
            child = self.transition(old_widget=old_child,
                                    new_widget=self.child)
        else:
            child = self.child

        trans.set_child(child)
        trans.raw_child = self.child

        return "next", st, None

    def visit(self):
        return [ self.child ]


# This causes interpolation to occur.
class Interpolation(Statement):

    def __init__(self, loc, warper, duration, properties, revolution, circles, splines):

        super(Interpolation, self).__init__(loc)

        self.warper = warper
        self.duration = duration
        self.properties = properties
        self.splines = splines

        # The direction we revolve in: cw, ccw, or None.
        self.revolution = revolution

        # The number of complete circles we make.
        self.circles = circles

    def execute(self, trans, st, state, event):

        executing(self.loc)

        warper = warpers.get(self.warper, self.warper)

        if self.duration:
            complete = min(1.0, st / self.duration)
        else:
            complete = 1.0

        complete = warper(complete)

        if state is None:

            # Create a new transform state, and apply the property
            # changes to it.
            newts = renpy.display.motion.TransformState()
            newts.take_state(trans.state)

            for k, v in self.properties:
                setattr(newts, k, v)

            # Now, the things we change linearly are in the difference
            # between the new and old states.
            linear = trans.state.diff(newts)

            revolution = None
            splines = [ ]

            # Clockwise revolution.
            if self.revolution is not None:

                # Remove various irrelevant motions.
                for i in [ 'xpos', 'ypos',
                           'xanchor', 'yanchor',
                           'xaround', 'yaround',
                           'xanchoraround', 'yanchoraround',
                           ]:

                    linear.pop(i, None)

                if newts.xaround is not None:

                    # Ensure we rotate around the new point.
                    trans.state.xaround = newts.xaround
                    trans.state.yaround = newts.yaround
                    trans.state.xanchoraround = newts.xanchoraround
                    trans.state.yanchoraround = newts.yanchoraround

                    # Get the start and end angles and radii.
                    startangle = trans.state.angle
                    endangle = newts.angle
                    startradius = trans.state.radius
                    endradius = newts.radius

                    # Make sure the revolution is in the appropriate direction,
                    # and contains an appropriate number of circles.

                    if self.revolution == "clockwise":
                        if endangle < startangle:
                            startangle -= 360

                        startangle -= self.circles * 360

                    elif self.revolution == "counterclockwise":
                        if endangle > startangle:
                            startangle += 360

                        startangle += self.circles * 360

                    # Store the revolution.
                    revolution = (startangle, endangle, startradius, endradius)

            # Figure out the splines.
            for name, values in self.splines:
                splines.append((name, [ getattr(trans.state, name) ] + values))

            state = (linear, revolution, splines)

            # Ensure that we set things, even if they don't actually
            # change from the old state.
            for k, v in self.properties:
                if k not in linear:
                    setattr(trans.state, k, v)

        else:
            linear, revolution, splines = state

        # Linearly interpolate between the things in linear.
        for k, (old, new) in linear.iteritems():
            value = interpolate(complete, old, new, PROPERTIES[k])

            setattr(trans.state, k, value)

        # Handle the revolution.
        if revolution is not None:
            startangle, endangle, startradius, endradius = revolution
            trans.state.angle = interpolate(complete, startangle, endangle, float)
            trans.state.radius = interpolate(complete, startradius, endradius, float)


        # Handle any splines we might have.
        for name, values in splines:
            value = interpolate_spline(complete, values)
            setattr(trans.state, name, value)

        if st >= self.duration:
            return "next", st - self.duration, None
        else:
            if not self.properties and not self.revolution and not self.splines:
                return "continue", state, self.duration - st
            else:
                return "continue", state, 0


# Implementation of the repeat statement.
class RawRepeat(RawStatement):

    def __init__(self, loc, repeats):

        super(RawRepeat, self).__init__(loc)

        self.repeats = repeats

    def compile(self, ctx): #@ReservedAssignment

        compiling(self.loc)

        repeats = self.repeats

        if repeats is not None:
            repeats = ctx.eval(repeats)

        return Repeat(self.loc, repeats)

class Repeat(Statement):

    def __init__(self, loc, repeats):

        super(Repeat, self).__init__(loc)

        self.repeats = repeats

    def execute(self, trans, st, state, event):
        return "repeat", (self.repeats, st), 0


# Parallel statement.

class RawParallel(RawStatement):

    def __init__(self, loc, block):

        super(RawParallel, self).__init__(loc)
        self.blocks = [ block ]

    def compile(self, ctx): #@ReservedAssignment
        return Parallel(self.loc, [i.compile(ctx) for i in self.blocks])

    def predict(self, ctx):
        for i in self.blocks:
            i.predict(ctx)


class Parallel(Statement):

    def __init__(self, loc, blocks):
        super(Parallel, self).__init__(loc)
        self.blocks = blocks

    def execute(self, trans, st, state, event):

        executing(self.loc)

        if state is None:
            state = [ (i, None) for i in self.blocks ]

        # The amount of time left after finishing this block.
        left = [ ]

        # The duration of the pause.
        pauses = [ ]

        # The new state structure.
        newstate = [ ]

        for i, istate in state:

            action, arg, pause = i.execute(trans, st, istate, event)

            if pause is not None:
                pauses.append(pause)

            if action == "continue":
                newstate.append((i, arg))
            elif action == "next":
                left.append(arg)
            elif action == "event":
                return action, arg, pause

        if newstate:
            return "continue", newstate, min(pauses)
        else:
            return "next", min(left), None

    def visit(self):
        return [ j for i in self.blocks for j in i.visit() ]


# The choice statement.

class RawChoice(RawStatement):

    def __init__(self, loc, chance, block):
        super(RawChoice, self).__init__(loc)

        self.choices = [ (chance, block) ]

    def compile(self, ctx): #@ReservedAssignment
        compiling(self.loc)
        return Choice(self.loc, [ (ctx.eval(chance), block.compile(ctx)) for chance, block in self.choices])

    def predict(self, ctx):
        for _i, j in self.choices:
            j.predict(ctx)

class Choice(Statement):

    def __init__(self, loc, choices):

        super(Choice, self).__init__(loc)

        self.choices = choices

    def execute(self, trans, st, state, event):

        executing(self.loc)

        if state is None:

            total = 0
            for chance, choice in self.choices:
                total += chance

            n = random.uniform(0, total)

            for chance, choice in self.choices:
                if n < chance:
                    break
                n -= chance

            cstate = None

        else:
            choice, cstate = state

        action, arg, pause = choice.execute(trans, st, cstate, event)

        if action == "continue":
            return "continue", (choice, arg), pause
        else:
            return action, arg, None

    def visit(self):
        return [ j for i in self.choices for j in i[1].visit() ]


# The Time statement.

class RawTime(RawStatement):

    def __init__(self, loc, time):

        super(RawTime, self).__init__(loc)
        self.time = time

    def compile(self, ctx): #@ReservedAssignment
        compiling(self.loc)
        return Time(self.loc, ctx.eval(self.time))

class Time(Statement):

    def __init__(self, loc, time):
        super(Time, self).__init__(loc)

        self.time = time

    def execute(self, trans, st, state, event):
        return "continue", None, None


# The On statement.

class RawOn(RawStatement):

    def __init__(self, loc, name, block):
        super(RawOn, self).__init__(loc)

        self.handlers = { name : block }

    def compile(self, ctx): #@ReservedAssignment

        compiling(self.loc)

        handlers = { }

        for k, v in self.handlers.iteritems():
            handlers[k] = v.compile(ctx)

        return On(self.loc, handlers)

    def predict(self, ctx):
        for i in self.handlers.itervalues():
            i.predict(ctx)

class On(Statement):

    def __init__(self, loc, handlers):
        super(On, self).__init__(loc)

        self.handlers = handlers

    def execute(self, trans, st, state, event):

        executing(self.loc)

        # If it's our first time through, start in the start state.
        if state is None:
            name, start, cstate = ("start", st, None)
        else:
            name, start, cstate = state

        # If we have an external event, and we have a handler for it,
        # handle it.
        if event in self.handlers:

            # Do not allow people to abort the hide handler with another
            # event.
            if name != "hide":
                name = event
                start = st
                cstate = None


        while True:

            # If we don't have a handler, return until we change event.
            if name not in self.handlers:
                return "continue", (name, start, cstate), None

            action, arg, pause = self.handlers[name].execute(trans, st - start, cstate, event)

            # If we get a continue, save our state.
            if action == "continue":

                # If it comes from a hide block, indicate that.
                if name == "hide" or name == "replaced":
                    trans.hide_response = False
                    trans.replaced_response = False

                return "continue", (name, start, arg), pause

            # If we get a next, then try going to the default
            # event, unless we're already in default, in which case we
            # go to None.
            elif action == "next":
                if name == "default" or name == "hide" or name == "replaced":
                    name = None
                else:
                    name = "default"

                start = st - arg
                cstate = None

                continue

            # If we get an event, then either handle it if we can, or
            # pass it up the stack if we can't.
            elif action == "event":

                name, arg = arg

                if name in self.handlers:
                    start = max(st - arg, st - 30)
                    cstate = None
                    continue

                return "event", (name, arg), None

    def visit(self):
        return [ j for i in self.handlers.itervalues() for j in i.visit() ]


# Event statement.

class RawEvent(RawStatement):

    def __init__(self, loc, name):
        super(RawEvent, self).__init__(loc)

        self.name = name

    def compile(self, ctx): #@ReservedAssignment
        return Event(self.loc, self.name)


class Event(Statement):

    def __init__(self, loc, name):
        super(Event, self).__init__(loc)

        self.name = name

    def execute(self, trans, st, state, event):
        return "event", (self.name, st), None


class RawFunction(RawStatement):

    def __init__(self, loc, expr):
        super(RawFunction, self).__init__(loc)

        self.expr = expr

    def compile(self, ctx): #@ReservedAssignment
        compiling(self.loc)
        return Function(self.loc, ctx.eval(self.expr))


class Function(Statement):

    def __init__(self, loc, function):
        super(Function, self).__init__(loc)

        self.function = function

    def execute(self, trans, st, state, event):
        fr = self.function(trans, st, trans.at)

        if fr is not None:
            return "continue", None, fr
        else:
            return "next", 0, None


# This parses an ATL block.
def parse_atl(l):

    l.advance()
    block_loc = l.get_location()

    statements = [ ]

    animation = False

    while not l.eob:

        loc = l.get_location()

        if l.keyword('repeat'):

            repeats = l.simple_expression()
            statements.append(RawRepeat(loc, repeats))

        elif l.keyword('block'):
            l.require(':')
            l.expect_eol()
            l.expect_block('block')

            block = parse_atl(l.subblock_lexer())
            statements.append(block)

        elif l.keyword('contains'):

            expr = l.simple_expression()

            if expr:

                l.expect_noblock('contains expression')
                statements.append(RawContainsExpr(loc, expr))

            else:

                l.require(':')
                l.expect_eol()
                l.expect_block('contains')

                block = parse_atl(l.subblock_lexer())
                statements.append(RawChild(loc, block))

        elif l.keyword('parallel'):
            l.require(':')
            l.expect_eol()
            l.expect_block('parallel')

            block = parse_atl(l.subblock_lexer())
            statements.append(RawParallel(loc, block))

        elif l.keyword('choice'):

            chance = l.simple_expression()
            if not chance:
                chance = "1.0"

            l.require(':')
            l.expect_eol()
            l.expect_block('choice')

            block = parse_atl(l.subblock_lexer())
            statements.append(RawChoice(loc, chance, block))

        elif l.keyword('on'):

            name = l.require(l.word)

            l.require(':')
            l.expect_eol()
            l.expect_block('on')

            block = parse_atl(l.subblock_lexer())
            statements.append(RawOn(loc, name, block))

        elif l.keyword('time'):
            time = l.require(l.simple_expression)
            l.expect_noblock('time')

            statements.append(RawTime(loc, time))

        elif l.keyword('function'):
            expr = l.require(l.simple_expression)
            l.expect_noblock('function')

            statements.append(RawFunction(loc, expr))

        elif l.keyword('event'):
            name = l.require(l.word)
            l.expect_noblock('event')

            statements.append(RawEvent(loc, name))

        elif l.keyword('pass'):
            l.expect_noblock('pass')
            statements.append(None)

        elif l.keyword('animation'):
            l.expect_noblock('animation')
            animation = True

        else:

            # If we can't assign it it a statement more specifically,
            # we try to parse it into a RawMultipurpose. That will
            # then be turned into another statement, as appropriate.

            # The RawMultipurpose we add things to.
            rm = renpy.atl.RawMultipurpose(loc)

            # Is the last clause an expression?
            last_expression = False

            # Is this clause an expression?
            this_expression = False

            # First, look for a warper.
            cp = l.checkpoint()
            warper = l.name()


            if warper in warpers:
                duration = l.require(l.simple_expression)
                warp_function = None

            elif warper == "warp":

                warper = None
                warp_function = l.require(l.simple_expression)
                duration = l.require(l.simple_expression)

            else:
                l.revert(cp)

                warper = None
                warp_function = None
                duration = "0"

            rm.add_warper(warper, duration, warp_function)

            # Now, look for properties and simple_expressions.
            while True:

                # Update expression status.
                last_expression = this_expression
                this_expression = False

                if l.keyword('pass'):
                    continue

                # Parse revolution keywords.
                if l.keyword('clockwise'):
                    rm.add_revolution('clockwise')
                    continue

                if l.keyword('counterclockwise'):
                    rm.add_revolution('counterclockwise')
                    continue

                if l.keyword('circles'):
                    expr = l.require(l.simple_expression)
                    rm.add_circles(expr)

                # Try to parse a property.
                cp = l.checkpoint()

                prop = l.name()

                if prop in PROPERTIES:

                    expr = l.require(l.simple_expression)

                    # We either have a property or a spline. It's the
                    # presence of knots that determine which one it is.

                    knots = [ ]

                    while l.keyword('knot'):
                        knots.append(l.require(l.simple_expression))

                    if knots:
                        knots.append(expr)
                        rm.add_spline(prop, knots)
                    else:
                        rm.add_property(prop, expr)

                    continue

                # Otherwise, try to parse it as a simple expressoon,
                # with an optional with clause.

                l.revert(cp)

                expr = l.simple_expression()

                if not expr:
                    break

                if last_expression:
                    l.error('ATL statement contains two expressions in a row; is one of them a misspelled property? If not, separate them with pass.')

                this_expression = True

                if l.keyword("with"):
                    with_expr = l.require(l.simple_expression)
                else:
                    with_expr = None

                rm.add_expression(expr, with_expr)

            l.expect_noblock('ATL')

            statements.append(rm)


        if l.eol():
            l.advance()
            continue

        l.require(",", "comma or end of line")


    # Merge together statements that need to be merged together.

    merged = [ ]
    old = None

    for new in statements:

        if isinstance(old, RawParallel) and isinstance(new, RawParallel):
            old.blocks.extend(new.blocks)
            continue

        elif isinstance(old, RawChoice) and isinstance(new, RawChoice):
            old.choices.extend(new.choices)
            continue

        elif isinstance(old, RawChild) and isinstance(new, RawChild):
            old.children.extend(new.children)
            continue

        elif isinstance(old, RawOn) and isinstance(new, RawOn):
            old.handlers.update(new.handlers)
            continue

        # None is a pause statement, which gets skipped, but also
        # prevents things from combining.
        elif new is None:
            old = new
            continue

        merged.append(new)
        old = new

    return RawBlock(block_loc, merged, animation)

########NEW FILE########
__FILENAME__ = audio
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# The latest and greatest Ren'Py audio system.

# Invariants: The periodic callback assumes pcm_ok. If we don't have
# at least pcm_ok, we have no sound whatsoever.

import renpy.audio  # @UnusedImport
import renpy.display  # @UnusedImport

import time
import pygame  # @UnusedImport
import os
import atexit

# Import the appropriate modules, or set them to None if we cannot.

disable = os.environ.get("RENPY_DISABLE_SOUND", "")

pss = None

if 'pss' not in disable:
    try:
        import pysdlsound as pss
        pss.check_version(4)  # @UndefinedVariable
        atexit.register(pss.quit)  # @UndefinedVariable
    except:
        pass

    if pss is None:
        try:
            import android.sound as pss #@UnresolvedImport @Reimport
            print "Imported android.sound."
        except:
            pass


# Save the mixer, and restore it at exit.

old_wave = None
old_midi = None

# This is True if we were able to sucessfully enable the pcm audio.
pcm_ok = None

unique = time.time()
serial = 0

def get_serial():
    """
    Gets a globally unique serial number for each music change.
    """

    global serial
    serial += 1
    return (unique, serial)


def load(fn):
    """
    Returns a file-like object for the given filename.
    """

    rv = renpy.loader.load(fn)
    return rv


class QueueEntry(object):
    """
    A queue entry object.
    """

    def __init__(self, filename, fadein, tight):
        self.filename = filename
        self.fadein = fadein
        self.tight = tight


class MusicContext(renpy.python.RevertableObject):
    """
    This stores information about the music in a game. This object
    participates in rollback, so when the user goes back in time, all
    the values get reverted as well.
    """

    __version__ = 0

    def __init__(self):

        super(MusicContext, self).__init__()

        # The time this channel was last ordered panned.
        self.pan_time = None

        # The pan this channel was ordered to.
        self.pan = 0

        # The time the secondary volume was last ordered changed.
        self.secondary_volume_time = None

        # The secondary volume.
        self.secondary_volume = 1.0

        # The time the channel was ordered last changed.
        self.last_changed = 0

        # Was the last change tight?
        self.last_tight = False

        # What were the filenames we were ordered to loop last?
        self.last_filenames = [ ]

        # Should we force stop this channel?
        self.force_stop = False

    def copy(self):
        """
        Returns a shallow copy of this context.
        """

        rv = MusicContext()
        rv.__dict__.update(self.__dict__)

        return rv

# The next channel number to be assigned.
next_channel_number = 0

class Channel(object):
    """
    This stores information about the currently-playing music.
    """

    def __init__(self, name, default_loop, stop_on_mute, tight, file_prefix, file_suffix, buffer_queue):

        # The name assigned to this channel. This is used to look up
        # information about the channel in the MusicContext object.
        self.name = name

        # The number this channel has been assigned, or None if we've yet
        # to assign a number to the channel. We only assign a channel
        # number when there's an operation on the channel other than
        # setting the mixer.
        self._number = None

        # The name of the mixer this channel uses. Set below, as there's
        # no good default.
        self.mixer = None

        # The volume imparted to this channel, as a fraction of the
        # mixer volume.
        self.chan_volume = 1.0

        # The actual volume we imparted onto this channel.
        self.actual_volume = 1.0

        # The QueueEntries queued for playback on this channel.
        self.queue = [ ]

        # If true, we loop the music. This entails adding everything in this
        # variable to the end of the queue.
        self.loop = [ ]

        # Are we playing anything at all?
        self.playing = False

        # If True, we'll wait for this channel to stop before
        # loading in more music from the queue. (This is necessary to
        # do a synchro-start.)
        self.wait_stop = False

        # If True, then this channel will participate in a synchro-start
        # once all channels are ready.
        self.synchro_start = False

        # The time the music in this channel was last changed.
        self.last_changed = 0

        # The callback that is called if the queue becomes empty.
        self.callback = None

        # The time this channel was last panned.
        self.pan_time = None

        # The time the secondary volume of this channel was last set.
        self.secondary_volume_time = None

        # Should we stop playing on mute?
        self.stop_on_mute = stop_on_mute

        # Is this channel tight?
        self.tight = tight

        # The number of items in the queue that should be kept
        # on queue clear.
        self.keep_queue = 0

        # A prefix and suffix that are used to create the full filenames.
        self.file_prefix = file_prefix
        self.file_suffix = file_suffix

        # Should we buffer upcoming music/video in the queue?
        self.buffer_queue = buffer_queue

        if default_loop is None:
            # By default, should we loop the music?
            self.default_loop = True
            # Was this set explicitly?
            self.default_loop_set = False

        else:
            self.default_loop = default_loop
            self.default_loop_set = True


    def get_number(self):
        """
        Returns the number of this channel, allocating a number if that
        proves necessary.
        """
        global next_channel_number

        rv = self._number
        if rv is None:
            rv = self._number = next_channel_number
            next_channel_number += 1

        return rv

    number = property(get_number)

    def get_context(self):
        """
        Returns the MusicContext corresponding to this channel, taken from
        the context object. Allocates a MusicContext if none exists.
        """

        mcd = renpy.game.context().music

        rv = mcd.get(self.name)
        if rv is None:
            rv = mcd[self.name] = MusicContext()

        return rv

    context = property(get_context)


    def periodic(self):
        """
        This is the periodic call that causes this channel to load new stuff
        into its queues, if necessary.
        """

        # Update the channel volume.
        vol = self.chan_volume * renpy.game.preferences.volumes[self.mixer]

        if vol != self.actual_volume:
            pss.set_volume(self.number, vol)
            self.actual_volume = vol


        # This should be set from something that checks to see if our
        # mixer is muted.
        force_stop = self.context.force_stop or (renpy.game.preferences.mute[self.mixer] and self.stop_on_mute)

        if self.playing and force_stop:
            pss.stop(self.number)
            self.playing = False
            self.wait_stop = False

        if force_stop:
            if self.loop:
                self.queue = self.queue[-len(self.loop):]
            else:
                self.queue = [ ]
            return

        # Should we do the callback?
        do_callback = False

        # This has been modified so we only queue a single sound file
        # per call, to prevent memory leaks with really short sound
        # files. So this loop will only execute once, in practice.
        while True:

            depth = pss.queue_depth(self.number)

            if depth == 0:
                self.wait_stop = False
                self.playing = False

            # Need to check this, so we don't do pointless work.
            if not self.queue:
                break

            # If the pcm_queue is full, then we can't queue
            # anything, regardless of if it is midi or pcm.
            if depth >= 2:
                break

            # If we can't buffer things, and we're playing something
            # give up here.
            if not self.buffer_queue and depth >= 1:
                break

            # We can't queue anything if the depth is > 0 and we're
            # waiting for a synchro_start.
            if self.synchro_start and depth:
                break

            # If the queue is full, return.
            if pss.queue_depth(self.number) >= 2:
                break

            # Otherwise, we might be able to enqueue something.
            topq = self.queue.pop(0)

            # Blacklist of old file formats we used to support, but we now
            # ignore.
            lfn = topq.filename.lower() + self.file_suffix.lower()
            for i in (".mod", ".xm", ".mid", ".midi"):
                if lfn.endswith(i):
                    topq = None

            if not topq:
                continue

            try:
                topf = load(self.file_prefix + topq.filename + self.file_suffix)

                if depth == 0:
                    pss.play(self.number, topf, topq.filename, paused=self.synchro_start, fadein=topq.fadein, tight=topq.tight)
                else:
                    pss.queue(self.number, topf, topq.filename, fadein=topq.fadein, tight=topq.tight)

                self.playing = True

            except:

                # If playing failed, remove topq.filename from self.loop
                # so we don't keep trying.
                while topq.filename in self.loop:
                    self.loop.remove(topq.filename)

                if renpy.config.debug_sound and not renpy.game.after_rollback:
                    raise
                else:
                    return

            break

        if self.loop and not self.queue:
            for i in self.loop:
                newq = QueueEntry(i, 0, topq.tight)
                self.queue.append(newq)
        else:
            do_callback = True

        # Queue empty callback.
        if do_callback and self.callback:
            self.callback() # E1102

    def dequeue(self, even_tight=False):
        """
        Clears the queued music.

        If the first item in the queue has not been started, then it is
        left in the queue unless all is given.
        """

        self.queue = self.queue[:self.keep_queue]
        self.loop = [ ]

        if not pcm_ok:
            return

        if self.keep_queue == 0:
            pss.dequeue(self.number, even_tight)

    def interact(self):
        """
        Called (mostly) once per interaction.
        """

        self.keep_queue = 0

        if pcm_ok:

            if self.pan_time != self.context.pan_time:
                self.pan_time = self.context.pan_time
                pss.set_pan(self.number,
                            self.context.pan,
                            0)


            if self.secondary_volume_time != self.context.secondary_volume_time:
                self.secondary_volume_time = self.context.secondary_volume_time
                pss.set_secondary_volume(self.number,
                                         self.context.secondary_volume,
                                         0)

        if not self.queue and self.callback:
            self.callback() # E1102


    def fadeout(self, secs):
        """
        Causes the playing music to be faded out for the given number
        of seconds. Also clears any queued music.
        """

        self.keep_queue = 0
        self.dequeue()

        if not pcm_ok:
            return

        if secs == 0:
            pss.stop(self.number)
        else:
            pss.fadeout(self.number, int(secs * 1000))

    def enqueue(self, filenames, loop=True, synchro_start=False, fadein=0, tight=None):

        for filename in filenames:
            renpy.game.persistent._seen_audio[filename] = True  # @UndefinedVariable

        if not pcm_ok:
            return

        if tight is None:
            tight = self.tight

        self.keep_queue += 1

        for filename in filenames:
            qe = QueueEntry(filename, int(fadein * 1000), tight)
            self.queue.append(qe)

            # Only fade the first thing in.
            fadein = 0

        if loop:
            self.loop = list(filenames)
        else:
            self.loop = [ ]

        self.wait_stop = synchro_start
        self.synchro_start = synchro_start

    def get_playing(self):

        if not pcm_ok:
            return None

        rv = pss.playing_name(self.number)

        if rv is None and self.queue:
            rv = self.queue[0].filename

        if rv is None and self.loop:
            rv = self.loop[0]

        return rv

    def set_volume(self, volume):
        self.chan_volume = volume

    def get_pos(self):

        if not pcm_ok:
            return -1

        return pss.get_pos(self.number)

    def set_pan(self, pan, delay):
        now = get_serial()
        self.context.pan_time = now
        self.context.pan = pan

        if pcm_ok:
            self.pan_time = self.context.pan_time
            pss.set_pan(self.number, self.context.pan, delay)

    def set_secondary_volume(self, volume, delay):
        now = get_serial()
        self.context.secondary_volume_time = now
        self.context.secondary_volume = volume

        if pcm_ok:
            self.secondary_volume_time = self.context.secondary_volume_time
            pss.set_secondary_volume(self.number, self.context.secondary_volume, delay)


################################################################################
# Android VideoPlayer Channel
################################################################################

if renpy.android:

    import jnius  # @UnresolvedImport

    VideoPlayer = jnius.autoclass("org.renpy.android.VideoPlayer")

    class AndroidVideoChannel(object):

        def __init__(self, name, file_prefix="", file_suffix="", default_loop=None):

            # A list of queued filenames.
            self.queue = [ ]

            # The filename that's currently playing.
            self.filename = None

            # The videoplayer that's currently playing.
            self.player = None

            # The name assigned to this channel. This is used to look up
            # information about the channel in the MusicContext object.
            self.name = name

            # The name of the mixer this channel uses. Set below, as there's
            # no good default.
            self.mixer = None

            # The time the music in this channel was last changed.
            self.last_changed = 0

            # The callback that is called if the queue becomes empty.
            self.callback = None

            # Ignored.
            self.synchro_start = False
            self.wait_stop = False
            self.loop = [ ]

            # A prefix and suffix that are used to create the full filenames.
            self.file_prefix = file_prefix
            self.file_suffix = file_suffix

            if default_loop is None:
                # By default, should we loop the music?
                self.default_loop = True
                # Was this set explicitly?
                self.default_loop_set = False

            else:
                self.default_loop = default_loop
                self.default_loop_set = True


        def get_context(self):
            """
            Returns the MusicContext corresponding to this channel, taken from
            the context object. Allocates a MusicContext if none exists.
            """

            mcd = renpy.game.context().music

            rv = mcd.get(self.name)
            if rv is None:
                rv = mcd[self.name] = MusicContext()

            return rv

        context = property(get_context)


        def start(self):
            """
            Starts playing the first video in the queue.
            """

            if not self.queue:
                return

            filename = self.queue.pop(0)

            f = renpy.loader.load(filename)

            real_fn = f.name
            base = getattr(f, "base", -1)
            length = getattr(f, "length", -1)

            self.filename = filename
            self.player = VideoPlayer(real_fn, base, length)

        def stop(self):

            if self.player is not None:
                self.player.stop()
                self.player = None

            self.filename = None

        def get_playing(self):

            if self.player is None:
                return None

            if self.player.isPlaying():
                return self.filename

        def periodic(self):

            # This should be set from something that checks to see if our
            # mixer is muted.
            force_stop = self.context.force_stop

            if force_stop:
                self.dequeue()
                self.stop()
                return

            if self.get_playing():
                return

            if self.queue:
                self.start()


        def dequeue(self, even_tight=False):
            """
            Clears the queued music, except for a first item that has
            not been started.
            """

            if self.get_playing():
                self.queue = [ ]
            else:
                self.queue = self.queue[:1]


        def interact(self):
            """
            Called (mostly) once per interaction.
            """

            self.periodic()


        def fadeout(self, secs):
            """
            Causes the playing music to be faded out for the given number
            of seconds. Also clears any queued music.
            """

            self.stop()
            self.queue = [ ]

        def enqueue(self, filenames, loop=True, synchro_start=False, fadein=0, tight=None):
            self.queue.extend(filenames)

        def set_volume(self, volume):
            pass

        def get_pos(self):
            pass

        def set_pan(self, pan, delay):
            pass

        def set_secondary_volume(self, volume, delay):
            pass


# A list of channels we know about.
all_channels = [ ]

# A map from channel name to Channel object.
channels = { }


def register_channel(name, mixer=None, loop=None, stop_on_mute=True, tight=False, file_prefix="", file_suffix="", buffer_queue=True):
    """
    :doc: audio

    This registers a new audio channel named `name`. Audio can then be
    played on the channel by supplying the channel name to the play or
    queue statements.

    `mixer`
        The name of the mixer the channel uses. By default, Ren'Py
        knows about the "music", "sfx", and "voice" mixers. Using
        other names is possible, but may require changing the
        preferences screens.

    `loop`
        If true, sounds on this channel loop by default.

    `stop_on_mute`
        If true, music on the channel is stopped when the channel is muted.

    `tight`
        If true, sounds will loop even when fadeout is occuring. This should
        be set to True for a sound effects or seamless music channel, and False
        if the music fades out on its own.

    `file_prefix`
        A prefix that is prepended to the filenames of the sound files being
        played on this channel.

    `file_suffix`
        A suffix that is appended to the filenames of the sound files being
        played on this channel.

    `buffer_queue`
        Should we buffer the first second or so of a queued file? This should
        be True for audio, and False for movie playback.
    """

    if not renpy.game.context().init_phase:
        raise Exception("Can't register channel outside of init phase.")

    if renpy.android and name == "movie":
        c = AndroidVideoChannel(name, default_loop=loop, file_prefix=file_prefix, file_suffix=file_suffix)
    else:
        c = Channel(name, loop, stop_on_mute, tight, file_prefix, file_suffix, buffer_queue)

    c.mixer = mixer

    all_channels.append(c)
    channels[name] = c


def alias_channel(name, newname):
    if not renpy.game.context().init_phase:
        raise Exception("Can't alias channel outside of init phase.")

    c = get_channel(name)
    channels[newname] = c


def get_channel(name):

    rv = channels.get(name)
    if rv is None:
        raise Exception("Audio channel %r is unknown." % name)

    return rv

def set_force_stop(name, value):
    get_channel(name).context.force_stop = value

def init():

    global pcm_ok
    global mix_ok

    if not renpy.config.sound:
        pcm_ok = False
        mix_ok = False
        return

    if pcm_ok is None and pss:
        bufsize = 2048

        if 'RENPY_SOUND_BUFSIZE' in os.environ:
            bufsize = int(os.environ['RENPY_SOUND_BUFSIZE'])

        try:
            pss.init(renpy.config.sound_sample_rate, 2, bufsize, False)
            pcm_ok = True
        except:
            if renpy.config.debug_sound:
                raise
            pcm_ok = False

    # Find all of the mixers in the game.
    mixers = [ ]

    for c in all_channels:
        if c.mixer not in mixers:
            mixers.append(c.mixer)

    default_volume = 1.0

    for m in mixers:
        renpy.game.preferences.volumes.setdefault(m, default_volume)
        renpy.game.preferences.mute.setdefault(m, False)


def quit(): #@ReservedAssignment

    global pcm_ok
    global mix_ok

    if not pcm_ok:
        return

    for c in all_channels:
        c.dequeue()
        c.fadeout(0)

        c.queue = [ ]
        c.loop = [ ]
        c.playing = False
        c.playing_midi = False
        c.wait_stop = False
        c.synchro_start = False

    pss.quit()

    pcm_ok = None
    mix_ok = None

# The last-set pcm volume.
pcm_volume = None


def periodic():
    """
    The periodic sound callback. This is called at around 20hz, and is
    responsible for adjusting the volume of the playing music if
    necessary, and also for calling the periodic functions of midi and
    the various channels, which then may play music.
    """

    global pcm_volume

    if not pcm_ok:
        return False

    try:

        for c in all_channels:
            c.periodic()

        pss.periodic()

        # Perform a synchro-start if necessary.
        need_ss = False

        for c in all_channels:

            if c.synchro_start and c.wait_stop:
                need_ss = False
                break

            if c.synchro_start and not c.wait_stop:
                need_ss = True

        if need_ss:
            pss.unpause_all()

            for c in all_channels:
                c.synchro_start = False

    except:
        if renpy.config.debug_sound:
            raise


def interact():
    """
    Called at least once per interaction.
    """

    if not pcm_ok:
        return

    try:
        for c in all_channels:

            c.interact()

            # if _music_volumes.get(i, 1.0) != c.chan_volume:
            #    c.set_volume(_music_volumes.get(i, 1.0))

            ctx = c.context

            # If we're in the same music change, then do nothing with the
            # music.
            if c.last_changed == ctx.last_changed:
                continue

            filenames = ctx.last_filenames
            tight = ctx.last_tight

            if c.default_loop:
                if not filenames or c.get_playing() not in filenames:
                    c.fadeout(renpy.config.fade_music)

            if filenames:
                c.enqueue(filenames, loop=True, synchro_start=True, tight=tight)

            c.last_changed = ctx.last_changed

    except:
        if renpy.config.debug_sound:
            raise

    periodic()

def rollback():
    """
    On rollback, we want to stop all the channels with non-empty sounds.
    """

    for c in all_channels:
        if not c.loop:
            c.fadeout(0)

########NEW FILE########
__FILENAME__ = music
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# The public API for music in games.

import renpy.audio

# A list of music channels.
music_channels = [ ]

# A list of channels for which set_music has been called, either way.
music_set = [ ]

from renpy.audio.audio import get_channel, get_serial

# Part of the public api:
from renpy.audio.audio import register_channel, alias_channel
register_channel; alias_channel

def play(filenames, channel="music", loop=None, fadeout=None, synchro_start=False, fadein=0, tight=None, if_changed=False):
    """
    :doc: audio

    This stops the music currently playing on the numbered channel, dequeues
    any queued music, and begins playing the specified file or files.

    `filenames`
        This may be a single file, or a list of files to be played.

    `channel`
        The channel to play the sound on.

    `loop`
        If this is True, the tracks will loop while they are the last thing
        in the queue.

    `fadeout`
        If not None, this is a time in seconds to fade for. Otherwise the
        fadeout time is taken from config.fade_music.

    `synchro_start`
        Ren'Py will ensure that all channels of with synchro_start set to true
        will start playing at exactly the same time. Synchro_start should be
        true when playing two audio files that are meant to be synchronized
        with each other.

    `fadein`
        This is the number of seconds to fade the music in for, on the
        first loop only.

    `tight`
        If this is True, then fadeouts will span into the next-queued sound.

    `if_changed`
        If this is True, and the music file is currently playing,
        then it will not be stopped/faded out and faded back in again, but
        instead will be kept playing. (This will always queue up an additional
        loop of the music.)
    """

    if renpy.game.context().init_phase:
        raise Exception("Can't play music during init phase.")

    if filenames is None:
        return

    if isinstance(filenames, basestring):
        filenames = [ filenames ]

    try:
        c = get_channel(channel)
        ctx = c.context

        if loop is None:
            loop = c.default_loop

        c.dequeue()

        if fadeout is None:
            fadeout = renpy.config.fade_music

        if if_changed and c.get_playing() in filenames:
            fadein = 0
        else:
            c.fadeout(fadeout)

        c.enqueue(filenames, loop=loop, synchro_start=synchro_start, fadein=fadein, tight=tight)

        t = get_serial()
        ctx.last_changed = t
        c.last_changed = t

        if loop:
            ctx.last_filenames = filenames
            ctx.last_tight = tight
        else:
            ctx.last_filenames = [ ]
            ctx.last_tight = False

    except:
        if renpy.config.debug_sound:
            raise


def queue(filenames, channel="music", loop=None, clear_queue=True, fadein=0, tight=None):
    """
    :doc: audio

    This queues the given filenames on the specified channel.

    `filenames`
        This may be a single file, or a list of files to be played.

    `channel`
        The channel to play the sound on.

    `loop`
        If this is True, the tracks will loop while they are the last thing
        in the queue.

    `clear_queue`
        If True, then the queue is cleared, making these files the files that
        are played when the currently playing file finishes. If it is False,
        then these files are placed at the back of the queue. In either case,
        if no music is playing these files begin playing immediately.

    `fadein`
        This is the number of seconds to fade the music in for, on the
        first loop only.

    `tight`
        If this is True, then fadeouts will span into the next-queued sound.
    """

    if renpy.game.context().init_phase:
        raise Exception("Can't play music during init phase.")

    if filenames is None:
        filenames = [ ]
        loop = False

    if isinstance(filenames, basestring):
        filenames = [ filenames ]

    try:

        c = get_channel(channel)
        ctx = c.context

        if loop is None:
            loop = c.default_loop

        if clear_queue:
            c.dequeue(True)

        c.enqueue(filenames, loop=loop, fadein=fadein, tight=tight)

        t = get_serial()
        ctx.last_changed = t
        c.last_changed = t

        if loop:
            ctx.last_filenames = filenames
            ctx.last_tight = tight
        else:
            ctx.last_filenames = [ ]
            ctx.last_tight = False

    except:
        if renpy.config.debug_sound:
            raise

def playable(filename, channel="music"):
    """
    Return true if the given filename is playable on the channel. This
    takes into account the prefix and suffix.
    """

    c = get_channel(channel)

    return renpy.loader.loadable(c.file_prefix + filename + c.file_suffix)


def stop(channel="music", fadeout=None):
    """
    :doc: audio

    This stops the music that is currently playing, and dequeues all
    queued music. If fadeout is None, the music is faded out for the
    time given in config.fade_music, otherwise it is faded for fadeout
    seconds.

    This sets the last queued file to None.

    `channel`
        The channel to stop the sound on.

    `fadeout`
        If not None, this is a time in seconds to fade for. Otherwise the
        fadeout time is taken from config.fade_music.


    """

    if renpy.game.context().init_phase:
        return

    try:
        c = get_channel(channel)
        ctx = c.context

        if fadeout is None:
            fadeout = renpy.config.fade_music

        c.fadeout(fadeout)

        t = get_serial()
        ctx.last_changed = t
        c.last_changed = t
        ctx.last_filenames = [ ]
        ctx.last_tight = False

    except:
        if renpy.config.debug_sound:
            raise


def set_music(channel, flag, default=False):
    """
    Determines if channel will loop by default.
    """

    c = get_channel(channel)

    if default and c.default_loop_set:
        return

    c.default_loop = flag
    c.default_loop_set = True

def get_delay(time, channel="music"):
    """
    Returns the number of seconds left until the given time in the
    music.
    """

    try:
        c = renpy.audio.audio.get_channel(channel)
        t = c.get_pos()

        if not t or t < 0:
            return None

        if t > time:
            return 0

        return time - t

    except:
        if renpy.config.debug_sound:
            raise

        return None

def get_playing(channel="music"):
    """
    :doc: audio

    If the given channel is playing, returns the playing file name.
    Otherwise, returns None.
    """

    try:
        c = renpy.audio.audio.get_channel(channel)
        return c.get_playing()
    except:
        if renpy.config.debug_sound:
            raise

        return None

def is_playing(channel="music"):
    """
    :doc: audio

    Returns True if the channel is currently playing a sound, False if
    it is not, or if the sound system isn't working.
    """

    return (get_playing(channel=channel) is not None)


def set_volume(volume, delay=0, channel="music"):
    """
    :doc: audio

    Sets the volume of this channel, as a fraction of the volume of the
    mixer controlling the channel.

    `volume`
        This is a number between 0.0 and 1.0, and is interpreted as a fraction
        of the mixer volume for the channel.

    `delay`
        It takes delay seconds to change/fade the volume from the old to
        the new value. This value is persisted into saves, and participates
        in rollback.

    `channel`
        The channel to be set
    """

    try:
        c = renpy.audio.audio.get_channel(channel)
        c.set_secondary_volume(volume, delay)
    except:
        if renpy.config.debug_sound:
            raise

def set_pan(pan, delay, channel="music"):
    """
    :doc: audio

    Sets the pan of this channel.

    `pan`
        A number between -1 and 1 that control the placement of the audio.
        If this is -1, then all audio is sent to the left channel.
        If it's 0, then the two channels are equally balanced. If it's 1,
        then all audio is sent to the right ear.

    `delay`
        The amount of time it takes for the panning to occur.

    `channel`
        The channel the panning takes place on. This can be a sound or a music
        channel. Often, this is channel 7, the default music channel.
    """

    try:
        c = renpy.audio.audio.get_channel(channel)
        c.set_pan(pan, delay)
    except:
        if renpy.config.debug_sound:
            raise

def set_queue_empty_callback(callback, channel="music"):
    """
    :doc: audio

    This sets a callback that is called when the queue is empty. This
    callback is called when the queue first becomes empty, and at
    least once per interaction while the queue is empty.

    The callback is called with no parameters. It can queue sounds by
    calling renpy.music.queue with the appropriate arguments. Please
    note that the callback may be called while a sound is playing, as
    long as a queue slot is empty.
    """
    try:
        c = renpy.audio.audio.get_channel(channel)
        c.callback = callback
    except:
        if renpy.config.debug_sound:
            raise

def set_mixer(channel, mixer, default=False):
    """
    This sets the name of the mixer associated with a given
    channel. By default, there are two mixers, 'sfx' and
    'music'. 'sfx' is on channels 0 to 3, and 'music'
    on 3 to 7. The voice module calls this function to set channel 2 to voice.
    You can create your own mixer, but will need to add a preference if you
    wish to allow the user to set it.

    This function should only be called in an init block.
    """

    try:
        c = renpy.audio.audio.get_channel(channel)

        if not default or c.mixer is None:
            c.mixer = mixer

    except:
        if renpy.config.debug_sound:
            raise

def channel_defined(channel):
    """
    Returns True if the channel exists, or False otherwise.
    """

    try:
        renpy.audio.audio.get_channel(channel)
        return True
    except:
        return False


# Music change logic:

# Use the queueing time to determine what should or should not be
# queued

# m_filenames - music filenames from info object
# m_loop - music loop from info object
# c_filenames - music filenames from channel
# c_filenames - music loop from channel

# if m_filenames == c_filenames and m_loop == c_loop:
#     do nothing, the music is right.

# otherwise,
#     dequeue music from the channel.

# if m_filenames != c_playing_filenames:
#     stop the music with fade. The music is wrong, change it.

# if m_loop:
#     queue m_filenames looping


########NEW FILE########
__FILENAME__ = sound
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# The public API for sound playback from games.

# TODO: Check to see if SFX are enabled before playing sounds with play or
# queue.

import renpy.audio

# This is basically a thin wrapper around music, with the default
# channel set to "sound".


def play(filename, channel="sound", fadeout=0, fadein=0, tight=False, loop=False):
    renpy.audio.music.play(filename,
                     channel=channel,
                     fadeout=fadeout,
                     fadein=fadein,
                     tight=tight,
                     loop=loop)

def queue(filename, channel="sound", clear_queue=True, fadein=0, tight=False, loop=False):
    renpy.audio.music.queue(filename,
                      channel=channel,
                      clear_queue=clear_queue,
                      fadein=fadein,
                      tight=tight,
                      loop=loop)

def stop(channel="sound", fadeout=0):
    renpy.audio.music.stop(channel=channel,
                     fadeout=fadeout)

set_mixer = renpy.audio.music.set_mixer
set_queue_empty_callback = renpy.audio.music.set_queue_empty_callback

def set_volume(volume, channel="sound"):
    renpy.audio.music.set_volume(volume, 0, channel=channel)

def set_pan(pan, delay, channel="sound"):
    renpy.audio.music.set_pan(pan, delay, channel=channel)

def is_playing(channel="sound"):
    return renpy.audio.music.is_playing(channel=channel)

def get_playing(channel="sound"):
    return renpy.audio.music.get_playing(channel=channel)

########NEW FILE########
__FILENAME__ = bootstrap
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os.path
import sys
import subprocess
import io

import renpy.error

FSENCODING = sys.getfilesystemencoding() or "utf-8"

# Extra things used for distribution.
def extra_imports():
    import datetime; datetime
    import encodings.ascii; encodings.ascii
    import encodings.utf_8; encodings.utf_8
    import encodings.zlib_codec; encodings.zlib_codec
    import encodings.unicode_escape; encodings.unicode_escape
    import encodings.string_escape; encodings.string_escape
    import encodings.raw_unicode_escape; encodings.raw_unicode_escape
    import encodings.mbcs; encodings.mbcs
    import encodings.utf_16; encodings.utf_16
    import encodings.utf_16_be; encodings.utf_16_be
    import encodings.utf_16_le; encodings.utf_16_le
    import encodings.utf_32_be; encodings.utf_32_be
    import encodings.latin_1; encodings.latin_1
    import encodings.hex_codec; encodings.hex_codec
    import encodings.base64_codec; encodings.base64_codec
    import math; math
    import glob; glob
    import pickle; pickle
    import pysdlsound; pysdlsound #@UnresolvedImport
    import pysdlsound.sound; pysdlsound.sound #@UnresolvedImport
    import pysdlsound.winmixer; pysdlsound.winmixer #@UnresolvedImport
    import pysdlsound.linmixer; pysdlsound.linmixer #@UnresolvedImport
    import difflib; difflib
    import shutil; shutil
    import tarfile; tarfile
    import bz2; bz2  # @UnresolvedImport
    import webbrowser; webbrowser
    import pygame.locals; pygame.locals
    import pygame.color; pygame.color
    import pygame.colordict; pygame.colordict
    import posixpath; posixpath
    import ctypes; ctypes
    import ctypes.wintypes; ctypes.wintypes
    import EasyDialogs; EasyDialogs #@UnresolvedImport
    import argparse; argparse
    import compiler; compiler
    import textwrap; textwrap
    import copy; copy
    import urllib; urllib
    import urllib2; urllib2
    import codecs; codecs
    import rsa; rsa
    import decimal; decimal
    import plistlib; plistlib

class NullFile(io.IOBase):
    """
    This file raises an error on input, and IOError on read.
    """

    def write(self, s):
        return

    def read(self, length=None):
        raise IOError("Not implemented.")

def null_files():
    try:
        if sys.stderr.fileno() < 0:
            sys.stderr = NullFile()

        if sys.stdout.fileno() < 0:
            sys.stdout = NullFile()
    except:
        pass

null_files()


trace_file = None
trace_local = None

def trace_function(frame, event, arg):
    fn = os.path.basename(frame.f_code.co_filename)
    print >>trace_file, fn, frame.f_lineno, frame.f_code.co_name, event
    return trace_local

def enable_trace(level):
    global trace_file
    global trace_local

    trace_file = file("trace.txt", "w", 1)

    if level > 1:
        trace_local = trace_function
    else:
        trace_local = None

    sys.settrace(trace_function)

def mac_start(fn):
    os.system("open " + fn)

# This code fixes a bug in subprocess.Popen.__del__
def popen_del(self, *args, **kwargs):
    return

def bootstrap(renpy_base):

    global renpy # W0602

    import renpy.log #@UnusedImport

    os.environ["RENPY_BASE"] = os.path.abspath(renpy_base)

    renpy_base = unicode(renpy_base, FSENCODING, "replace")

    # If environment.txt exists, load it into the os.environ dictionary.
    if os.path.exists(renpy_base + "/environment.txt"):
        evars = { }
        execfile(renpy_base + "/environment.txt", evars)
        for k, v in evars.iteritems():
            if k not in os.environ:
                os.environ[k] = str(v)

    # Also look for it in an alternate path (the path that contains the
    # .app file.), if on a mac.
    alt_path = os.path.abspath("renpy_base")
    if ".app" in alt_path:
        alt_path = alt_path[:alt_path.find(".app")+4]

        if os.path.exists(alt_path + "/environment.txt"):
            evars = { }
            execfile(alt_path + "/environment.txt", evars)
            for k, v in evars.iteritems():
                if k not in os.environ:
                    os.environ[k] = str(v)

    # Get a working name for the game.
    name = os.path.basename(sys.argv[0])

    if name.find(".") != -1:
        name = name[:name.find(".")]

    # Parse the arguments.
    import renpy.arguments
    args = renpy.arguments.bootstrap()

    # Since we don't have time to fully initialize before running the presplash
    # command, handle it specially.
    if args.command == "presplash":
        import renpy.display.presplash
        renpy.display.presplash.show(sys.argv[3])

    if args.trace:
        enable_trace(args.trace)

    if args.basedir:
        basedir = os.path.abspath(args.basedir).decode(FSENCODING)
    else:
        basedir = renpy_base


    gamedirs = [ name ]
    game_name = name

    while game_name:
        prefix = game_name[0]
        game_name = game_name[1:]

        if prefix == ' ' or prefix == '_':
            gamedirs.append(game_name)

    gamedirs.extend([ 'game', 'data', 'launcher/game' ])

    for i in gamedirs:

        if i == "renpy":
            continue

        gamedir = basedir + "/" + i
        if os.path.isdir(gamedir):
            break
    else:
        gamedir = basedir

    sys.path.insert(0, basedir)

    # Force windib on windows, unless the user explicitly overrides.
    if renpy.windows and not 'SDL_VIDEODRIVER' in os.environ:
        os.environ['SDL_VIDEODRIVER'] = 'windib'

    # If we're not given a command, show the presplash.
    if args.command == "run":
        import renpy.display.presplash #@Reimport
        renpy.display.presplash.start(basedir, gamedir)

    # If we're on a mac, install our own os.start.
    if renpy.macintosh:
        os.startfile = mac_start


    # Check that we have installed pygame properly. This also deals with
    # weird cases on Windows and Linux where we can't import modules. (On
    # windows ";" is a directory separator in PATH, so if it's in a parent
    # directory, we won't get the libraries in the PATH, and hence pygame
    # won't import.)
    try:
        import pygame; pygame
    except:
        print >>sys.stderr, """\
Could not import pygame. Please ensure that this program has been built
and unpacked properly. Also, make sure that the directories containing
this program do not contain : or ; in their names.

You may be using a system install of python. Please run {0}.sh,
{0}.exe, or {0}.app instead.
""".format(name)

        raise

    # Ditto for the Ren'Py module.
    try:
        import _renpy; _renpy
    except:
        print >>sys.stderr, """\
Could not import _renpy. Please ensure that this program has been built
and unpacked properly.

You may be using a system install of python. Please run {0}.sh,
{0}.exe, or {0}.app instead.
""".format(name)
        raise

    # Load up all of Ren'Py, in the right order.

    import renpy #@Reimport
    renpy.import_all()

    renpy.loader.init_importer()

    exit_status = None

    try:
        while exit_status is None:
            exit_status = 1

            try:
                renpy.game.args = args
                renpy.config.renpy_base = renpy_base
                renpy.config.basedir = basedir
                renpy.config.gamedir = gamedir
                renpy.config.args = [ ]

                if renpy.android:
                    renpy.config.logdir = os.environ['ANDROID_PUBLIC']
                else:
                    renpy.config.logdir = basedir

                if not os.path.exists(renpy.config.logdir):
                    os.makedirs(renpy.config.logdir, 0777)

                renpy.main.main()

                exit_status = 0

            except KeyboardInterrupt:
                raise

            except renpy.game.UtterRestartException:

                # On an UtterRestart, reload Ren'Py.
                renpy.reload_all()

                exit_status = None

            except renpy.game.QuitException as e:
                exit_status = e.status

                if e.relaunch:
                    subprocess.Popen([sys.executable, "-EO"] + sys.argv)

            except renpy.game.ParseErrorException:
                pass

            except Exception, e:
                renpy.error.report_exception(e)
                pass

        sys.exit(exit_status)

    finally:

        if "RENPY_SHUTDOWN_TRACE" in os.environ:
            enable_trace(int(os.environ["RENPY_SHUTDOWN_TRACE"]))

        renpy.display.im.cache.quit()

        if renpy.display.draw:
            renpy.display.draw.quit()

        # Prevent subprocess from throwing errors while trying to run it's
        # __del__ method during shutdown.
        subprocess.Popen.__del__ = popen_del

########NEW FILE########
__FILENAME__ = character
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# The Character object (and friends).

import renpy.display

import re

# This matches the dialogue-relevant text tags.
TAG_RE = re.compile(r'(\{\{)|(\{(p|w|nw|fast)(?:\=([^}]*))?\})', re.S)

class DialogueTextTags(object):
    """
    This object parses the text tags that only make sense in dialogue,
    like {fast}, {p}, {w}, and {nw}.
    """

    def __init__(self, s):

        # The text that we've accumulated, not including any tags.
        self.text = ""

        # The index in the produced string where each pause starts.
        self.pause_start = [ 0 ]

        # The index in the produced string where each pause ends.
        self.pause_end = [ ]

        # The time to delay for each pause. None to delay forever.
        self.pause_delay = [ ]

        # True if we've encountered the no-wait tag.
        self.no_wait = False

        i = iter(TAG_RE.split(s))

        while True:

            try:
                self.text += i.next()

                quoted = i.next()
                full_tag = i.next()
                tag = i.next()
                value = i.next()

                if value is not None:
                    value = float(value)

                if quoted is not None:
                    self.text += quoted
                    continue

                if tag == "p" or tag == "w":
                    self.pause_start.append(len(self.text))
                    self.pause_end.append(len(self.text))
                    self.pause_delay.append(value)

                elif tag == "nw":
                    self.no_wait = True

                elif tag == "fast":
                    self.pause_start = [ len(self.text) ]
                    self.pause_end = [ ]
                    self.pause_delay = [ ]
                    self.no_wait = False

                self.text += full_tag

            except StopIteration:
                break

        self.pause_end.append(len(self.text))

        if self.no_wait:
            self.pause_delay.append(0)
        else:
            self.pause_delay.append(None)


def predict_show_display_say(who, what, who_args, what_args, window_args, image=False, two_window=False, side_image=None, screen=None, **kwargs):
    """
    This is the default function used by Character to predict images that
    will be used by show_display_say. It's called with more-or-less the
    same parameters as show_display_say, and it's expected to return a
    list of images used by show_display_say.
    """

    if side_image:
        renpy.easy.predict(side_image)

    if renpy.store._side_image_attributes:
        renpy.easy.predict(renpy.display.image.ImageReference(("side",) + renpy.store._side_image_attributes))

    if image:
        if image != "<Dynamic>":
            renpy.easy.predict(who)

    if screen:
        props = compute_widget_properties(who_args, what_args, window_args)

        renpy.display.screen.predict_screen(
            screen,
            _widget_properties=props,
            who=who,
            what=what,
            image=image,
            two_window=two_window,
            side_image=side_image,
            **kwargs)

        return



def compute_widget_properties(who_args, what_args, window_args, variant=None):
    """
    Computes and returns the widget properties.
    """

    def style_args(d):

        if not "style" in d:
            return d

        in_rollback = renpy.exports.in_rollback()

        if (not in_rollback) and (not variant):
            return d

        d = d.copy()

        style = d["style"]

        if isinstance(style, basestring):
            style = getattr(renpy.store.style, style)

            if variant is not None:
                style = style[variant]

            if in_rollback:
                style = style["rollback"]

        d["style"] = style

        return d

    who_args = style_args(who_args)
    what_args = style_args(what_args)
    window_args = style_args(window_args)

    return {
        "window" : window_args,
        "what" : what_args,
        "who" : who_args,
        }


def show_display_say(who, what, who_args={}, what_args={}, window_args={},
                     image=False, side_image=None, two_window=False,
                     two_window_vbox_properties={},
                     who_window_properties={},
                     say_vbox_properties={},
                     transform=None,
                     variant=None,
                     screen=None,
                     layer=None,
                     **kwargs):
    """
    This is called (by default) by renpy.display_say to add the
    widgets corresponding to a screen of dialogue to the user. It is
    not expected to be called by the user, but instead to be called by
    display_say, or by a function passed as the show_function argument
    to Character or display_say.

    @param who: The name of the character that is speaking, or None to
    not show this name to the user.

    @param what: What that character is saying. Please not that this
    may not be a string, as it can also be a list containing both text
    and displayables, suitable for use as the first argument of ui.text().

    @param who_args: Additional keyword arguments intended to be
    supplied to the ui.text that creates the who widget of this dialogue.

    @param what_args: Additional keyword arguments intended to be
    supplied to the ui.text that creates the what widget of this dialogue.

    @param window_args: Additional keyword arguments intended to be
    supplied to the ui.window that creates the who widget of this
    dialogue.

    @param image: If True, then who should be interpreted as an image
    or displayable rather than a text string.

    @param kwargs: Additional keyword arguments should be ignored.

    This function is required to return the ui.text() widget
    displaying the what text.
    """

    props = compute_widget_properties(who_args, what_args, window_args, variant=variant)

    def handle_who():
        if who:
            if image:
                renpy.ui.add(renpy.display.im.image(who, loose=True, **props["who"]))
            else:
                renpy.ui.text(who, **who_args)

    def merge_style(style, properties):

        if isinstance(style, basestring):
            style = getattr(renpy.store.style, style)

        if variant is not None:
            style = style[variant]

        if renpy.exports.in_rollback():
            style = style["rollback"]

        rv = dict(style=style)
        rv.update(properties)
        return rv

    if screen and renpy.display.screen.has_screen(screen):

        if layer is None:
            layer = renpy.config.say_layer

        tag = screen
        index = 0

        while renpy.exports.showing(tag):
            index += 1
            tag = "%s%d" % (screen, index)

        renpy.display.screen.show_screen(
            screen,
            _widget_properties=props,
            _transient = True,
            _tag = tag,
            image=image,
            side_image=side_image,
            two_window=two_window,
            who=who,
            what=what,
            _layer=layer,
            **kwargs)

        renpy.exports.shown_window()

        return renpy.display.screen.get_widget(screen, "what", layer)


    # Apply the transform.
    if transform:
        renpy.ui.at(transform)

    if two_window:

        # Opens say_two_window_vbox.
        renpy.ui.vbox(**merge_style('say_two_window_vbox', two_window_vbox_properties))

        renpy.ui.window(**merge_style('say_who_window', who_window_properties))
        handle_who()

    renpy.ui.window(**props["window"])
    # Opens the say_vbox.
    renpy.ui.vbox(**merge_style('say_vbox', say_vbox_properties))

    if not two_window:
        handle_who()

    rv = renpy.ui.text(what, **props["what"])

    # Closes the say_vbox.
    renpy.ui.close()

    if two_window:
        # Closes the say_two_window_vbox.
        renpy.ui.close()

    if side_image:
        renpy.ui.image(side_image)

    renpy.exports.shown_window()

    return rv



class SlowDone(object):
    delay = None

    def __init__(self, ctc, ctc_position, callback, interact, type, cb_args, delay): #@ReservedAssignment
        self.ctc = ctc
        self.ctc_position = ctc_position
        self.callback = callback
        self.interact = interact
        self.type = type
        self.cb_args = cb_args
        self.delay = delay

    def __call__(self):

        if self.ctc and self.ctc_position == "fixed":
            renpy.display.screen.show_screen("_ctc", _transient=True, ctc=self.ctc)
            renpy.exports.restart_interaction()

        if self.delay is not None:
            renpy.ui.pausebehavior(self.delay, True)
            renpy.exports.restart_interaction()

        for c in self.callback:
            c("slow_done", interact=self.interact, type=self.type, **self.cb_args)


# This function takes care of repeatably showing the screen as part of
# an interaction.
def display_say(
    who,
    what,
    show_function,
    interact,
    slow,
    afm,
    ctc,
    ctc_pause,
    ctc_position,
    all_at_once,
    cb_args,
    with_none,
    callback,
    type, #@ReservedAssignment
    checkpoint=True,
    ctc_timedpause=None,
    ctc_force=False):

    if interact and (not renpy.game.preferences.skip_unseen) and (not renpy.game.context().seen_current(True)) and renpy.config.skipping == "fast":
        renpy.config.skipping = None

    # If we're in fast skipping mode, don't bother with say
    # statements at all.
    if interact and renpy.config.skipping == "fast":

        # Clears out transients.
        renpy.exports.with_statement(None)
        return

    # Figure out the callback(s) we want to use.
    if callback is None:
        if renpy.config.character_callback:
            callback = [ renpy.config.character_callback ]
        else:
            callback = [ ]

    if not isinstance(callback, list):
        callback = [ callback ]

    callback = renpy.config.all_character_callbacks + callback

    # Call the begin callback.
    for c in callback:
        c("begin", interact=interact, type=type, **cb_args)

    if renpy.exports.roll_forward_info():
        roll_forward = False
    else:
        roll_forward = None

    # If we're just after a rollback or roll_forward, disable slow.
    after_rollback = renpy.game.after_rollback
    if after_rollback:
        slow = False

    # If we're committed to skipping this statement, disable slow.
    elif (renpy.config.skipping and
          (renpy.game.preferences.skip_unseen or
           renpy.game.context().seen_current(True))):
        slow = False

    # Figure out which pause we're on. (Or set the pause to None in
    # order to put us in all-at-once mode.)
    if not interact:
        all_at_once = True

    dtt = DialogueTextTags(what)

    if all_at_once:
        pause_start = [ dtt.pause_start[0] ]
        pause_end = [ len(dtt.text) ]
        pause_delay = [ dtt.pause_delay[-1] ]
    else:
        pause_start = dtt.pause_start
        pause_end = dtt.pause_end
        pause_delay = dtt.pause_delay


    for i, (start, end, delay) in enumerate(zip(pause_start, pause_end, pause_delay)):

        last_pause = (i == len(pause_start) - 1)

        # If we're going to do an interaction, then saybehavior needs
        # to be here.
        if interact:
            behavior = renpy.ui.saybehavior(allow_dismiss=renpy.config.say_allow_dismiss)
        else:
            behavior = None


        # The string to show.
        what_string = dtt.text

        # Figure out the CTC to use, if any.
        if last_pause:
            what_ctc = ctc
        else:
            if delay is not None:
                what_ctc = ctc_timedpause or ctc_pause
            else:
                what_ctc = ctc_pause

        if not (interact or ctc_force):
            what_ctc = None

        what_ctc = renpy.easy.displayable_or_none(what_ctc)

        if what_ctc is not None:
            what_ctc = what_ctc.parameterize(('ctc',), ())

        if delay == 0:
            what_ctc = None

        # Create the callback that is called when the slow text is done.
        slow_done = SlowDone(what_ctc, ctc_position, callback, interact, type, cb_args, delay)

        # Run the show callback.
        for c in callback:
            c("show", interact=interact, type=type, **cb_args)

        # Show the text.
        what_text = show_function(who, what_string)

        if not isinstance(what_text, renpy.text.text.Text): #@UndefinedVariable
            raise Exception("The say screen (or show_function) must return a Text object.")

        if what_ctc and ctc_position == "nestled":
            what_text.set_ctc(what_ctc)

        # Update the properties of the what_text widget.
        what_text.start = start
        what_text.end = end
        what_text.slow = slow
        what_text.slow_done = slow_done

        for c in callback:
            c("show_done", interact=interact, type=type, **cb_args)

        if behavior and afm:
            behavior.set_afm_length(end - start)

        if not slow:
            slow_done()

        if interact:
            rv = renpy.ui.interact(mouse='say', type=type, roll_forward=roll_forward)

            # This is only the case if the user has rolled forward, {nw} happens, or
            # maybe in some other obscure cases.
            if rv is False:
                break

            if not last_pause:
                for i in renpy.config.say_sustain_callbacks:
                    i()

    # Do the checkpoint and with None.
    if interact:

        if not dtt.no_wait:
            if checkpoint:
                renpy.exports.checkpoint(True)
        else:
            renpy.game.after_rollback = after_rollback

        if with_none is None:
            with_none = renpy.config.implicit_with_none

        if with_none:
            renpy.game.interface.do_with(None, None)

    for c in callback:
        c("end", interact=interact, type=type, **cb_args)


# This is used to flag values that haven't been set by the user.
NotSet = renpy.object.Sentinel("NotSet")

class ADVCharacter(object):
    """
    The character object contains information about a character. When
    passed as the first argument to a say statement, it can control
    the name that is displayed to the user, and the style of the label
    showing the name, the text of the dialogue, and the window
    containing both the label and the dialogue.
    """

    # Properties beginning with what or window that are treated
    # specially.
    special_properties = [
        'what_prefix',
        'what_suffix',
        'who_prefix',
        'who_suffix',
        'show_function',
        ]

    voice_tag = None

    # When adding a new argument here, remember to add it to copy below.
    def __init__(
        self,
        name=NotSet,
        kind=None,
        **properties):

        if kind is None:
            kind = renpy.store.adv

        if name is not NotSet:
            properties["name"] = name

        # This grabs a value out of properties, and then grabs it out of
        # kind if it's not set.
        def v(n):
            if n in properties:
                return properties.pop(n)
            else:
                return getattr(kind, n)


        # Similar, but it grabs the value out of kind.display_args instead.
        def d(n):
            if n in properties:
                return properties.pop(n)
            else:
                return kind.display_args[n]

        self.name = v('name')
        self.who_prefix = v('who_prefix')
        self.who_suffix = v('who_suffix')
        self.what_prefix = v('what_prefix')
        self.what_suffix = v('what_suffix')

        self.show_function = v('show_function')
        self.predict_function = v('predict_function')

        self.condition = v('condition')
        self.dynamic = v('dynamic')
        self.screen = v('screen')
        self.mode = v('mode')

        self.voice_tag = v('voice_tag')

        if renpy.config.new_character_image_argument:
            if "image" in properties:
                self.image_tag = properties.pop("image")
            else:
                self.image_tag = kind.image_tag
        else:
            self.image_tag = None

        self.display_args = dict(
            interact = d('interact'),
            slow = d('slow'),
            afm = d('afm'),
            ctc = renpy.easy.displayable_or_none(d('ctc')),
            ctc_pause = renpy.easy.displayable_or_none(d('ctc_pause')),
            ctc_timedpause = renpy.easy.displayable_or_none(d('ctc_timedpause')),
            ctc_position = d('ctc_position'),
            all_at_once = d('all_at_once'),
            with_none = d('with_none'),
            callback = d('callback'),
            type = d('type'),
            )

        if kind:
            self.who_args = kind.who_args.copy()
            self.what_args = kind.what_args.copy()
            self.window_args = kind.window_args.copy()
            self.show_args = kind.show_args.copy()
            self.cb_args = kind.cb_args.copy()

        else:
            self.who_args = { "substitute" : False }
            self.what_args = { "substitute" : False }
            self.window_args = { }
            self.show_args = { }
            self.cb_args = { }

        if not renpy.config.new_character_image_argument:
            if "image" in properties:
                self.show_args["image"] = properties.pop("image")

        if "slow_abortable" in properties:
            self.what_args["slow_abortable"] = properties.pop("slow_abortable")

        for k in list(properties):

            if "_" in k:
                prefix, suffix = k.split("_", 1)

                if prefix == "show":
                    self.show_args[suffix] = properties[k]
                    continue
                elif prefix == "cb":
                    self.cb_args[suffix] = properties[k]
                    continue
                elif prefix == "what":
                    self.what_args[suffix] = properties[k]
                    continue
                elif prefix == "window":
                    self.window_args[suffix] = properties[k]
                    continue
                elif prefix == "who":
                    self.who_args[suffix] = properties[k]
                    continue

            self.who_args[k] = properties[k]

    def copy(self, name=NotSet, **properties):
        return type(self)(name, kind=self, **properties)

    # This is called before the interaction.
    def do_add(self, who, what):
        return

    # This is what shows the screen for a given interaction.
    def do_show(self, who, what):
        return self.show_function(
            who,
            what,
            who_args=self.who_args,
            what_args=self.what_args,
            window_args=self.window_args,
            screen=self.screen,
            **self.show_args)

    # This is called after the last interaction is done.
    def do_done(self, who, what):
        return

    # This is called when an extend occurs, before the usual add/show
    # cycel.
    def do_extend(self):
        return

    # This is called to actually do the displaying.
    def do_display(self, who, what, **display_args):
        display_say(who,
                    what,
                    self.do_show,
                    **display_args)


    # This is called to predict images that will be used by this
    # statement.
    def do_predict(self, who, what):
        return self.predict_function(
            who,
            what,
            who_args=self.who_args,
            what_args=self.what_args,
            window_args=self.window_args,
            screen=self.screen,
            **self.show_args)

    def resolve_say_attributes(self, predict):
        """
        Deals with image attributes associated with the current say
        statement.
        """

        attrs = renpy.exports.get_say_attributes()

        if not attrs:
            return

        if not self.image_tag:
            if not predict:
                raise Exception("Say has image attributes %r, but there's no image tag associated with the speaking character." % (attrs,))
            else:
                return

        tagged_attrs = (self.image_tag,) + attrs
        images = renpy.game.context().images

        # If image is showing already, resolve it, then show or predict it.
        if images.showing("master", (self.image_tag,)):

            new_image = images.apply_attributes("master", self.image_tag, tagged_attrs)

            if new_image is None:
                new_image = tagged_attrs

            if predict:
                images.predict_show(new_image)
            else:
                trans = renpy.config.say_attribute_transition

                if trans is not None:
                    renpy.exports.with_statement(None)

                renpy.exports.show(new_image)

                if trans is not None:
                    renpy.exports.with_statement(trans)

        else:

            # Otherwise, just record the attributes of the image.
            images.predict_show("master", tagged_attrs, show=False)

    def __str__(self):
        who = self.name

        # If dynamic is set, evaluate the name expression.
        if self.dynamic:
            who = renpy.python.py_eval(who)

        return who


    def __call__(self, what, interact=True, **kwargs):

        # Check self.condition to see if we should show this line at all.
        if not (self.condition is None or renpy.python.py_eval(self.condition)):
            return True

        self.resolve_say_attributes(False)

        old_side_image_attributes = renpy.store._side_image_attributes

        if self.image_tag:
            attrs = (self.image_tag,) + renpy.game.context().images.get_attributes("master", self.image_tag)
        else:
            attrs = None

        renpy.store._side_image_attributes = attrs

        if renpy.config.voice_tag_callback is not None:
            renpy.config.voice_tag_callback(self.voice_tag)

        try:

            if interact:
                renpy.exports.mode(self.mode)

            # Figure out the arguments to display.
            display_args = self.display_args.copy()
            display_args.update(kwargs)
            display_args["interact"] = display_args["interact"] and interact

            who = self.name

            # If dynamic is set, evaluate the name expression.
            if self.dynamic:
                who = renpy.python.py_eval(who)

            sub = renpy.substitutions.substitute

            if who is not None:
                if renpy.config.new_substitutions:
                    who_pattern = sub(self.who_prefix + "[[who]" + self.who_suffix)
                    who = who_pattern.replace("[who]", sub(who))
                else:
                    who = self.who_prefix + who + self.who_suffix

            ctx = renpy.game.context()

            if (ctx.translate_language is not None) and (ctx.translate_identifier is not None):
                translate = False
            else:
                translate = True

            if renpy.config.new_substitutions:
                what_pattern = sub(self.what_prefix + "[[what]" + self.what_suffix)
                what = what_pattern.replace("[what]", sub(what, translate=translate))
            else:
                what = self.what_prefix + what + self.what_suffix

            # Run the add_function, to add this character to the
            # things like NVL-mode.
            self.do_add(who, what)

            # Now, display the damned thing.
            self.do_display(who, what, cb_args=self.cb_args, **display_args)

            # Indicate that we're done.
            self.do_done(who, what)

            # Finally, log this line of dialogue.
            if who and isinstance(who, (str, unicode)):
                renpy.exports.log(who)
            renpy.exports.log(what)
            renpy.exports.log("")

        finally:

            if interact:
                renpy.store._side_image_attributes = old_side_image_attributes


    def predict(self, what):

        self.resolve_say_attributes(True)

        old_side_image_attributes = renpy.store._side_image_attributes

        if self.image_tag:
            attrs = ( self.image_tag, ) + renpy.game.context().images.get_attributes("master", self.image_tag)
        else:
            attrs = None

        renpy.store._side_image_attributes = attrs

        try:

            if self.dynamic:
                who = "<Dynamic>"
            else:
                who = self.name

            return self.do_predict(who, what)

        finally:
            renpy.store._side_image_attributes = old_side_image_attributes

    def will_interact(self):

        if not (self.condition is None or renpy.python.py_eval(self.condition)):
            return False

        return self.display_args['interact']


def Character(name=NotSet, kind=None, **properties):
    """
    :doc: character
    :args: (name, kind=adv, **args)
    :name: Character

    Creates and returns a Character object, which controls the look
    and feel of dialogue and narration.

    `name`
        If a string, the name of the character for dialogue. When
        `name` is ``None``, display of the name is omitted, as for
        narration.

    `kind`
        The Character to base this Character off of. When used, the
        default value of any argument not supplied to this Character
        is the value of that argument supplied to `kind`. This can
        be used to define a template character, and then copy that
        character with changes.

    **Linked Image**
    An image tag may be associated with a Character. This allows a
    say statement involving this character to display an image with
    the tag, and also allows Ren'Py to automatically select a side
    image to show when this character speaks.

    `image`
         A string giving the image tag that is linked with this
         character.

    **Voice Tag**
    If a voice tag is assign to a Character, the voice files that are
    associated with it, can be muted or played in the preference
    screen.

    `voice_tag`
        A String that enables the voice file assosiated with the
        Character to be muted or played in the 'voice' channel.

    **Prefixes and Suffixes.**
    These allow a prefix and suffix to be applied to the name of the
    character, and to the text being shown. This can be used, for
    example, to add quotes before and after each line of dialogue.

    `what_prefix`
        A string that is prepended to the dialogue being spoken before
        it is shown.

    `what_suffix`
        A string that is appended to the dialogue being spoken before
        it is shown.

    `who_prefix`
        A string that is prepended to the name of the character before
        it is shown.

    `who_suffix`
        A string that is appended to the name of the character before
        it is shown.

    **Changing Name Display.**
    These options help to control the display of the name.

    `dynamic`
        If true, then `name` should be a string containing a python
        expression. That string will be evaluated before each line
        of dialogue, and the result used as the name of the character.

    **Controlling Interactions.**
    These options control if the dialogue is displayed, if an
    interaction occurs, and the mode that is entered upon display.

    `condition`
        If given, this should be a string containing a python
        expression. If the expression is false, the dialogue
        does not occur, as if the say statement did not happen.

    `interact`
        If true, the default, an interaction occurs whenever the
        dialogue is shown. If false, an interaction will not occur,
        and additional elements can be added to the screen.

    `mode`
        A string giving the mode to enter when this character
        speaks. See the section on :ref:`modes <modes>` for more details.

    `callback`
        A function that is called when events occur while the
        character is speaking. See the section on
        :ref:`character-callbacks` fore more information.

    **Click-to-continue.**
    A click-to-continue indicator is displayed once all the text has
    finished displaying, to prompt the user to advance.

    `ctc`
        A Displayable to use as the click-to-continue indicator, unless
        a more specific indicator is used.

    `ctc_pause`
        A Displayable to use a the click-to-continue indicator when the
        display of text is paused by the {p} or {w} text tags.

    `ctc_timedpause`
        A Displayable to use a the click-to-continue indicator when the
        display of text is paused by the {p=} or {w=} text tags. When
        None, this takes its default from ctc_pause, use ``Null()``
        when you want a ctc_pause but no ctc_timedpause.

    `ctc_position`
        Controls the location of the click-to-continue indicator. If
        ``"nestled"``, the indicator is displayed as part of the text
        being shown, immediately after the last character. If ``"fixed"``,
        the indicator is added to the screen, and its position is
        controlled by the position style properties.


    **Screens.**
    The display of dialogue uses a :ref:`screen <screens>`. These arguments
    allow you to select that screen, and to provide arguments to it.

    `screen`
        The name of the screen that is used to display the dialogue.

    Keyword arguments beginning with ``show_`` have the prefix
    stripped off, and are passed to the screen as arguments. For
    example, the value of ``show_side_image`` will become the
    value of the ``side_image`` variable in the screen.

    Some useful ``show_`` variables implemented by the default screens are:

    `show_side_image`
        When given a Displayable, shows that displayable when the
        dialogue is shown. The position of that displayable is
        controlled by its position properties. This is often used
        to show an image of the speaking character to the side
        of the dialogue.

    `show_two_window`
        If true, restructures the layout so that the name of the
        character is placed in one window, and the dialogue text in a
        second window.

    `show_layer`
        If given, this should be a string giving the name of the layer
        to show the "say" screen on.

    **Styling Text and Windows.**
    Keyword arguments beginning with ``who_``, ``what_``, and
    `window_`` have their prefix stripped, and are used to :ref:`style
    <styles>` the character name, the spoken text, and the window
    containing both, respectively.

    For example, if a character is given the keyword argument
    ``who_color="#c8ffc8"``, the color of the character's name is
    changed, in this case to green. ``window_background="frame.png"``
    sets the background of the window containing this character's
    dialogue.

    The style applied to the character name, spoken text, and window
    can also be set this way, using the `who_style`, `what_style`, and
    `window_style` arguments, respectively.
     """

    if kind is None:
        kind = renpy.store.adv

    return type(kind)(name, kind=kind, **properties)


def DynamicCharacter(name_expr, **properties):
    return Character(name_expr, dynamic=True, **properties)


########NEW FILE########
__FILENAME__ = config
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This is the config module, where game configuration settings are stored.
# This includes both simple settings (like the screen dimensions) and
# methods that perform standard tasks, like the say and menu methods.

# This will be deleted by the end of this file.
import renpy.display #@UnusedImport
import os

# Can we add more config variables?
locked = False

# Contains help for config variables.
help = [ ] #@ReservedAssignment

# The title of the game window.
window_title = "A Ren'Py Game"

# An image file containing the window icon image.
window_icon = None

# The same, but only used on MS windows.
windows_icon = None

# The width and height of the drawable area of the screen.
screen_width = 800
screen_height = 600

# Should sound be enabled?
sound = True

# Turns recoverable errors into fatal ones, so that the user can know
# about and fix them.
debug = False

# Ditto, but for sound operations
debug_sound = None

# Is rollback enabled? (This only controls if the user-invoked
# rollback command does anything)
rollback_enabled = True

# If the rollback is longer than this, we may trim it.
rollback_length = 128

# If set to True, clicking while in rollback will keep the roll forward
# buffer if the data has not changed.
keep_rollback_data = False

# If set to true, menus in fixed rollback will not have clickable
# options and a click anywhere or mouse wheel will roll forward.
fix_rollback_without_choice = False

# The maximum number of steps the user can rollback the game,
# interactively.
hard_rollback_limit = 100

# A list of functions returning lists of displayables that will be
# added to the end of the display list.
overlay_functions = [ ]

# A list of Displayables that should always be added to the start
# of the scene list. (Mostly used for keymaps and the like.)
underlay = [ ]

# True to enable profiling.
profile = False

# The directory save files will be saved to.
savedir = None

# The number of screens worth of images that are allowed to
# live in the image cache at once.
image_cache_size = 8

# The number of statements we will analyze when doing predictive
# loading. Please note that this is a total number of statements in a
# BFS along all paths, rather than the depth along any particular
# path. The current node is counted in this number.
predict_statements = 16

# Causes the contents of the image cache to be printed to stdout when
# it changes.
debug_image_cache = False

# Should we allow skipping at all?
allow_skipping = True

# Should we allow fast skipping?
fast_skipping = False

# Are we currently skipping? If so, how fast?
# May be "slow", "fast", or None.
skipping = None

# The delay while we are skipping say statements.
skip_delay = 25

# basic: Archive files that are searched for images.
archives = [ ]

# Searchpath.
searchpath = [ ]

# If True, we will only try loading from archives.
# Only useful for debugging Ren'Py, don't document.
force_archives = False

# Used to control the software mouse cursor.
mouse = None

# The default sound playback sample rate.
sound_sample_rate = 44100

# The amount of time music is faded out between tracks.
fade_music = 0.0

# Should the at list be sticky?
sticky_positions = False

# A list of all of the layers that we know about.
layers = [ 'master', 'transient', 'screens', 'overlay' ]

# A list of layers that should be cleared when we replace
# transients.
transient_layers = [ 'transient' ]

# A list of layers that should be cleared when we recompute
# overlays.
overlay_layers = [ 'overlay' ]

# A list of layers that should be cleared whe we enter a
# new context.
context_clear_layers = [ 'screens' ]

# A list of layers that are displayed atop all other layers, and do
# not participate in transitions.
top_layers = [ ]

# True if we want to show overlays during wait statements, or
# false otherwise.
overlay_during_with = True

# True if we want to allow the fast dissolve.
enable_fast_dissolve = True

# When using the keyboard to navigate, how much we penalize
# distance out of the preferred direction.
focus_crossrange_penalty = 1024

# If True, then we force all loading to occur before transitions
# start.
load_before_transition = True

# The keymap that is used to change keypresses and mouse events.
keymap = { }

# Should we try to support joysticks?
joystick = True

# A list of functions that are called when an interaction is
# started or restarted.
interact_callbacks = [ ]

# A list of functions that are called when an interaction is started.
start_interact_callbacks = [ ]

# A list of functions that are called when a say statement
# is sustained.
say_sustain_callbacks = [ ]

# A function that is called to see if say should allow
# itself to be dismissed.
say_allow_dismiss = None

# A function that is called to tokenize text.
text_tokenizer = None

# The number of characters per AFM time period.
afm_characters = 250

# The number of bonus characters to add to a string for afm.
afm_bonus = 25

# A function that must return True for afm mode to forward.
afm_callback = None

# The amount of time we delay before making an automatic
# choice from a menu. This can be used for making a demo version of a
# game. It should be set to None in a deployed game.
auto_choice_delay = None

# A map from font, bold, italic to font, bold, italic. This is used
# to replace (say) the italic version of a regular font with the regular
# version of an italic font.
font_replacement_map = { }

# A callback that is called when a with statement (but not
# the with clause of a say or menu statement) executes. If not None,
# it's called with a single argument, the transition supplied to the
# with clause.
with_callback = None

# The framerate limit, in frames per second.
framerate = 100

# The number of frames that Ren'Py has shown.
frames = 0

# NOT USED: A text editor that is launched at the location of the current
# statement.
editor = None # os.environ.get('RENPY_EDITOR', None)

# NOT USED: Text editor, with arguments to reload or clobber the file - used,
# for example, to display traceback.txt.
editor_transient = None # os.environ.get('RENPY_EDITOR_TRANSIENT', editor)

# NOT USED: The separator used between files in the text editor.
editor_file_separator = None # os.environ.get('RENPY_EDITOR_FILE_SEPARATOR', '" "')

# Enable developer mode?
developer = False

# A logfile that logging messages are sent to.
log = None

# Lint hooks.
lint_hooks = [ ]

# Hyperlink styler.
hyperlink_styler = None

# Hyperlink callback.
hyperlink_callback = None

# Hyperlink focus.
hyperlink_focus = None

# Should SFonts be recolored? internal.
recolor_sfonts = True

# Function that is called to layout text.
text_layout = None

# A callback that is called 20 times a second.
periodic_callback = None

# Should we check that all style properties are in style_properties? (Internal)
check_properties = True

# If True, then we implicily do a with None after every interaction.
implicit_with_none = True

# A map from a layer to (x, y, w, h) tuples that the layer is clipped to.
layer_clipping = { }

# Should we disable the fullscreen optimization?
disable_fullscreen_opt = False

# Should we reject midi files?
reject_midi = True

# Default character callback.
character_callback = None

# Character callback list.
all_character_callbacks = [ ]

# The number of autosave slots we have.
autosave_slots = 10

# How often do we autosave. (Number of interactions, sort of.)
autosave_frequency = int(os.environ.get("RENPY_AUTOSAVE_FREQUENCY", "200"))

# The callback that is used by the scene statement.
scene = renpy.exports.scene

# The callback that is used by the show statement.
show = renpy.exports.show

# The callback that is used by the hide statement.
hide = renpy.exports.hide

# Should we use cPickle or pickle for load/save?
use_cpickle = True

# The function to call as the inspector.
inspector = None

# Should we reject backslashes in filenames?
reject_backslash = True

# Hide the mouse.
mouse_hide_time = 30

# Called when we can't load an image.
missing_image_callback = None

# Called to filter text in the say and menu statements.
say_menu_text_filter = None

# Used to replace one label with another.
label_overrides = { }

# Called to get the extra_info for an auto_save.
auto_save_extra_info = None

# The directory (underneath ~/RenPy, ~/Library/RenPy, or ~/.renpy) where the
# game-specific data is saved.
save_directory = None

# These are used to deal with the case where a picture is missing.
missing_scene = None
missing_show = None
missing_hide = None

# This is called when control is transferred to a label.
label_callback = None

# A function that is called when the window needs to be shown.
empty_window = None

# A list of functions that are called when the window is shown.
window_overlay_functions = [ ]

# Do we support right-to-left languages?
rtl = False

# A callback for file opening.
file_open_callback = None

# The size of screenshot thumbnails. (Redefined in common/)
thumbnail_width = None
thumbnail_height = None

# The end game transition.
end_game_transition = None

# The default transform.
default_transform = None

# Should we use the child position?
transform_uses_child_position = True

# The action to use when it's time to quit.
quit_action = None

# If not None, a rectangle giving the area of the screen to crop the
# screenshots to.
screenshot_crop = None

# Various directories.
gamedir = None
basedir = None
renpy_base = None
commondir = None
logdir = None # Where log and error files go.

# Should we enable OpenGL mode?
gl_enable = True

# A list of callbacks that are called by renpy.mode.
mode_callbacks = [ ]

# Should MoveTransition take offsets into account?
movetransition_respects_offsets = True

# Do we care about the pos and anchor attributes of an ImageReference's
# style?
imagereference_respects_position = False

# Do we want to try to pretend to be android?
simulate_android = False

# Do we want to enable imagemap caching?
imagemap_cache = True

# Callbacks that are called in order to predict images.
predict_callbacks = [ ]

# Should screens be predicted?
predict_screens = True

# Should we use the new choice screen format?
choice_screen_chosen = True

# Should the narrator speak menu labels?
narrator_menu = False

# A list of screen variants to use.
variants = [ None ]

# A function from (auto_parameter, variant) -> displayable.
imagemap_auto_function = None

# Should we keep the running transform when we merely change the image?
keep_running_transform = True

# Should we use image attributes?
image_attributes = True

# Should we use the new version of the character image argument?
new_character_image_argument = True

# A transition that is performed when a say statement has an image attribute
# corresponding to a shown image.
say_attribute_transition = None

# What is the name and version of this game?
name = ""
version = ""

# Should we log?
log_enable = True

# Should we log text overflows?
debug_text_overflow = False

# Should we save the window size in the preferences?
save_physical_size = True

# Do we use new text substitutions?
new_substitutions = True

# Do we use old text substitutions?
old_substitutions = True

# The graphics renderer we use. (Ren'Py sets this.)
renderer = "auto"

# The translator to use, if any. (Not used anymore.)
translator = None

# Should we use the old, broken line spacing code?
broken_line_spacing = False

# A list of callbacks that are called after each non-init-phase python
# block.
python_callbacks = [ ]

# If true, we dump information about a save upon save.
save_dump = False

# Can we resize a gl window?
gl_resize = True

# Called when we change the translation.
change_language_callbacks = [ ]

# The translation directory.
tl_directory = "tl"

# Key repeat timings. A tuple giving the initial delay and the delay between
# repeats, in seconds.
key_repeat = (.3, .03)

# A callback that is called with the character's voice_tag.
voice_tag_callback = None

# A list of callbacks that can be used to add JSON to save files.
save_json_callbacks = [ ]

# The duration of a longpress, in seconds.
longpress_duration = .5

# The radius the longpress has to remain within, in pixels.
longpress_radius = 15

# How long we vibrate the device upon a longpress.
longpress_vibrate = .1

# A list of callbacks that are called before each statement, with the name
# of the statement.
statement_callbacks = [ ]

# A list of file extensions that are blacklisted by autoreload.
autoreload_blacklist = [ ".rpyc", ".rpymc", ".rpyb", ".pyc", ".pyo" ]

# The layer dialogue is shown on.
say_layer = "screens"

# The layer the choice screen is shown on.
choice_layer = "screens"

# If true, we will not use the .report_traceback method to produced
# prettier tracebacks.
raw_tracebacks = ("RENPY_RAW_TRACEBACKS" in os.environ)

del renpy
del os

def init():
    pass

########NEW FILE########
__FILENAME__ = curry
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

class Curry(object):
    """
    Stores a callable and some arguments. When called, calls the
    callable with the stored arguments and the additional arguments
    supplied to the call.
    """


    def __init__(self, callable, *args, **kwargs): #@ReservedAssignment
        self.callable = callable
        self.args = args
        self.kwargs = kwargs
        self.__doc__ = getattr(self.callable, "__doc__", None)

    def __call__(self, *args, **kwargs):
        return self.callable(*(self.args + args),
                             **dict(self.kwargs.items() + kwargs.items()))
    def __repr__(self):
        return "<curry %s %r %r>" % (self.callable, self.args, self.kwargs)

    def __eq__(self, other):

        return (
            isinstance(other, Curry) and
            self.callable == other.callable and
            self.args == other.args and
            self.kwargs == other.kwargs)

    def __hash__(self):
        return hash(self.callable) ^ hash(self.args) ^ hash(self.kwargs)

def curry(fn):
    """
    Takes a callable, and returns something that, when called, returns
    something that when called again, calls the function. So
    basically, the thing returned from here when called twice does the
    same thing as the function called once.
    """

    rv = Curry(Curry, fn)
    rv.__doc__ = getattr(fn, "__doc__", None)
    return rv


def partial(function, *args, **kwargs):
    """
    Stores the arguments and keyword arguments of function, and
    returns something that, when called, calls the function with
    a combination of the supplied arguments and the arguments of
    the second call.
    """

    return Curry(function, *args, **kwargs)

########NEW FILE########
__FILENAME__ = defaultstore
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from renpy.minstore import *

# But please note that this will not be available in the body
# of user code, unless we re-import it.
import renpy.display
import renpy.text

import renpy.display.im as im
import renpy.display.anim as anim

_restart = None

# Used by the call/return mechanism.
_return = None
_args = None
_kwargs = None

# Should the in-game window be shown?
_window = False

# The window subtitle.
_window_subtitle = ''

# Should rollback be allowed?
_rollback = True

# config.
_config = renpy.config

# The special character used for name-only dialogue.
name_only = None

# Used by the ui functions.
_widget_by_id = None
_widget_properties = { }

class _Config(object):

    def __getstate__(self):
        return None

    def __setstate__(self, data):
        return

    def register(self, name, default, cat=None, help=None): #@ReservedAssignment
        setattr(self, name, default)
        _config.help.append((cat, name, help))

    def __getattr__(self, name):
        cvars = vars(_config)

        if name not in cvars:
            raise Exception('config.%s is not a known configuration variable.' % (name))

        return cvars[name]

    def __setattr__(self, name, value):
        cvars = vars(_config)

        if name not in cvars and renpy.config.locked:
            raise Exception('config.%s is not a known configuration variable.' % (name))

        if name == "script_version":
            renpy.store._set_script_version(value) # E1101 @UndefinedVariable

        cvars[name] = value

    def __delattr__(self, name):
        if renpy.config.locked:
            raise Exception('Deleting configuration variables is not supported.')
        else:
            delattr(renpy.config, name)

# The styles object.
style = None

config = _Config()
library = config

eval = renpy.python.py_eval #@ReservedAssignment

# Displayables.
Bar = renpy.display.behavior.Bar
Button = renpy.display.behavior.Button
Input = renpy.display.behavior.Input

ImageReference = renpy.display.image.ImageReference
Image = renpy.display.im.image

Frame = renpy.display.imagelike.Frame
Solid = renpy.display.imagelike.Solid
FileCurrentScreenshot = renpy.display.imagelike.FileCurrentScreenshot

LiveComposite = renpy.display.layout.LiveComposite
LiveCrop = renpy.display.layout.LiveCrop
LiveTile = renpy.display.layout.LiveTile
Flatten = renpy.display.layout.Flatten

Null = renpy.display.layout.Null
Window = renpy.display.layout.Window
Viewport = renpy.display.layout.Viewport
DynamicDisplayable = renpy.display.layout.DynamicDisplayable
ConditionSwitch = renpy.display.layout.ConditionSwitch
ShowingSwitch = renpy.display.layout.ShowingSwitch

Transform = renpy.display.motion.Transform

Animation = anim.Animation
Movie = renpy.display.video.Movie
Particles = renpy.display.particle.Particles
SnowBlossom = renpy.display.particle.SnowBlossom

Text = renpy.text.text.Text
ParameterizedText = renpy.text.extras.ParameterizedText
FontGroup = renpy.text.font.FontGroup

Drag = renpy.display.dragdrop.Drag
DragGroup = renpy.display.dragdrop.DragGroup

Sprite = renpy.display.particle.Sprite
SpriteManager = renpy.display.particle.SpriteManager


# Currying things.
Alpha = renpy.curry.curry(renpy.display.layout.Alpha)
Position = renpy.curry.curry(renpy.display.layout.Position)
Pan = renpy.curry.curry(renpy.display.motion.Pan)
Move = renpy.curry.curry(renpy.display.motion.Move)
Motion = renpy.curry.curry(renpy.display.motion.Motion)
Revolve = renpy.curry.curry(renpy.display.motion.Revolve)
Zoom = renpy.curry.curry(renpy.display.motion.Zoom)
RotoZoom = renpy.curry.curry(renpy.display.motion.RotoZoom)
FactorZoom = renpy.curry.curry(renpy.display.motion.FactorZoom)
SizeZoom = renpy.curry.curry(renpy.display.motion.SizeZoom)
Fade = renpy.curry.curry(renpy.display.transition.Fade)
Dissolve = renpy.curry.curry(renpy.display.transition.Dissolve)
ImageDissolve = renpy.curry.curry(renpy.display.transition.ImageDissolve)
AlphaDissolve = renpy.curry.curry(renpy.display.transition.AlphaDissolve)
CropMove = renpy.curry.curry(renpy.display.transition.CropMove)
Pixellate = renpy.curry.curry(renpy.display.transition.Pixellate)


OldMoveTransition = renpy.curry.curry(renpy.display.movetransition.OldMoveTransition)
MoveTransition = renpy.curry.curry(renpy.display.movetransition.MoveTransition)
MoveFactory = renpy.curry.curry(renpy.display.movetransition.MoveFactory)
MoveIn = renpy.curry.curry(renpy.display.movetransition.MoveIn)
MoveOut = renpy.curry.curry(renpy.display.movetransition.MoveOut)
ZoomInOut = renpy.curry.curry(renpy.display.movetransition.ZoomInOut)
RevolveInOut = renpy.curry.curry(renpy.display.movetransition.RevolveInOut)

MultipleTransition = renpy.curry.curry(renpy.display.transition.MultipleTransition)
ComposeTransition = renpy.curry.curry(renpy.display.transition.ComposeTransition)
Pause = renpy.curry.curry(renpy.display.transition.NoTransition)
SubTransition = renpy.curry.curry(renpy.display.transition.SubTransition)
# Misc.
ADVSpeaker = ADVCharacter = renpy.character.ADVCharacter
Speaker = Character = renpy.character.Character
DynamicCharacter = renpy.character.DynamicCharacter
MultiPersistent = renpy.persistent.MultiPersistent

Action = renpy.ui.Action
BarValue = renpy.ui.BarValue

# NOTE: When exporting something from here, decide if we need to add it to
# renpy.sl2.pyutil.pure_functions.

Style = renpy.style.Style # @UndefinedVariable

absolute = renpy.display.core.absolute

NoRollback = renpy.python.NoRollback


class _layout_class(__builtins__["object"]):
    """
    This is used to generate declarative versions of MultiBox and Grid.
    """

    def __init__(self, cls, doc, nargs=0, **extra_kwargs):
        self.cls = cls
        self.nargs = nargs
        self.extra_kwargs = extra_kwargs

        self.__doc__ = doc

    def __call__(self, *args, **properties):

        conargs = args[:self.nargs]
        kids = args[self.nargs:]

        kwargs = self.extra_kwargs.copy()
        kwargs.update(properties)

        rv = self.cls(*conargs, **kwargs)
        for i in kids:
            rv.add(renpy.easy.displayable(i))

        return rv

Fixed = _layout_class(renpy.display.layout.MultiBox, """
:doc: disp_box
:args: (*args, **properties)

A box that fills the screen. Its members are laid out
from back to front, with their position properties
controlling their position.
""", layout="fixed")

HBox = _layout_class(renpy.display.layout.MultiBox, """
:doc: disp_box
:args: (*args, **properties)

A box that lays out its members from left to right.
""", layout='horizontal')

VBox = _layout_class(renpy.display.layout.MultiBox, """
:doc: disp_box
:args: (*args, **properties)

A layout that lays out its members from top to bottom.
""", layout='vertical')

Grid = _layout_class(renpy.display.layout.Grid, """
:doc: disp_grid

Lays out displayables in a a grid. The first two positional arguments
are the number of columns and rows in the grid. This must be followed
by `columns * rows` positional arguments giving the displayables that
fill the grid.
""", nargs=2, layout='vertical')


def AlphaBlend(control, old, new, alpha=False):
    """
    :doc: disp_effects

    This transition uses a `control` displayable (almost always some sort of
    animated transform) to transition from one displayable to another. The
    transform is evaluated. The `new` displayable is used where the transform
    is opaque, and the `old` displayable is used when it is transparent.

    `alpha`
        If true, the image is composited with what's behind it. If false,
        the default, the image is opaque and overwrites what's behind it.
    """

    return renpy.display.transition.AlphaDissolve(control, 0.0, old_widget=old, new_widget=new, alpha=alpha)

def At(d, *args):
    """
    :doc: disp_at

    Given a displayable `d`, applies each of the transforms in `args`
    to it. The transforms are applied in left-to-right order, so that
    the outermost transform is the rightmost argument. ::

        transform birds_transform:
             xpos -200
             linear 10 xpos 800
             pause 20
             repeat

        image birds = At("birds.png", birds_transform)
        """

    rv = renpy.easy.displayable(d)

    for i in args:
        rv = i(rv)

    return rv


# The color function. (Moved, since text needs it, too.)
color = renpy.easy.color

# Conveniently get rid of all the packages we had imported before.
import renpy.exports as renpy #@Reimport

# The default menu functions.
menu = renpy.display_menu
predict_menu = renpy.predict_menu

# The default transition.
default_transition = None

# Is the mouse visible?
mouse_visible = True

# Is the overlay suppressed?
suppress_overlay = False

# The default ADVCharacter.
adv = ADVCharacter(None,
                   who_prefix='',
                   who_suffix='',
                   what_prefix='',
                   what_suffix='',

                   show_function=renpy.show_display_say,
                   predict_function=renpy.predict_show_display_say,

                   condition=None,
                   dynamic=False,
                   image=None,

                   interact=True,
                   slow=True,
                   slow_abortable=True,
                   afm=True,
                   ctc=None,
                   ctc_pause=None,
                   ctc_timedpause=None,
                   ctc_position="nestled",
                   all_at_once=False,
                   with_none=None,
                   callback=None,
                   type='say',

                   who_style='say_label',
                   what_style='say_dialogue',
                   window_style='say_window',
                   screen='say',
                   mode='say',
                   voice_tag=None,

                   kind=False)

def predict_say(who, what):
    who = Character(who, kind=name_only)
    try:
        who.predict(what)
    except:
        pass

def say(who, what, interact=True):
    who = Character(who, kind=name_only)
    who(what, interact=interact)

# Used by renpy.reshow_say.
_last_say_who = None
_last_say_what = None

# Used to store the things pinned into the cache.
_cache_pin_set = set()

# If we're in a replay, the label of the start of the replay.
_in_replay = None

# Used to store the side image attributes.
_side_image_attributes = None

# True if we're in the main_menu, False otherwise. This controls autosave,
# among other things.
main_menu = False

# Make these available to user code.
import sys
import os

def public_api():
    ui
    im
    object
    range
    sorted
    os
    sys

del public_api


########NEW FILE########
__FILENAME__ = anim
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains support for state-machine controlled animations.

import renpy.display
import random

class State(object):
    """
    This creates a state that can be used in a SMAnimation.
    """


    def __init__(self, name, image, *atlist, **properties):
        """
        @param name: A string giving the name of this state.

        @param image: The displayable that is shown to the user while
        we are in (entering) this state. For convenience, this can
        also be a string or tuple, which is interpreted with Image.

        image should be None when this State is used with motion,
        to indicate that the image will be replaced with the child of
        the motion.

        @param atlist: A list of functions to call on the image. (In
        general, if something can be used in an at clause, it can be
        used here as well.)

        If any keyword arguments are given, they are used to construct a
        Position object, that modifies the position of the image.
        """

        if image and not isinstance(image, renpy.display.core.Displayable):
            image = renpy.easy.displayable(image)

        self.name = name
        self.image = image
        self.atlist = atlist
        self.properties = properties


    def add(self, sma):
        sma.states[self.name] = self

    def get_image(self):
        rv = self.image

        for i in self.atlist:
            rv = i(rv)

        if self.properties:
            rv = renpy.display.layout.Position(rv, **self.properties)

        return rv

    def motion_copy(self, child):

        if self.image is not None:
            child = self.image

        return State(self.name, child, *self.atlist)


class Edge(object):
    """
    This creates an edge that can be used with a SMAnimation.
    """

    def __init__(self, old, delay, new, trans=None, prob=1):
        """
        @param old: The name (a string) of the state that this transition is from.

        @param delay: The number of seconds that this transition takes.

        @param new: The name (a string) of the state that this transition is to.

        @param trans: The transition that will be used to show the
        image found in the new state. If None, the image is show
        immediately.

        When used with an SMMotion, the transition should probably be
        move.

        @param prob: The number of times this edge is added. This can
        be used to make a transition more probable then others. For
        example, if one transition out of a state has prob=5, and the
        other has prob=1, then the one with prob=5 will execute 5/6 of
        the time, while the one with prob=1 will only occur 1/6 of the
        time. (Don't make this too large, as memory use is proportional to
        this value.)
        """

        self.old = old
        self.delay = delay
        self.new = new
        self.trans = trans
        self.prob = prob

    def add(self, sma):
        for _i in xrange(0, self.prob):
            sma.edges.setdefault(self.old, []).append(self)


class SMAnimation(renpy.display.core.Displayable):
    """
    This creates a state-machine animation. Such an animation is
    created by randomly traversing the edges between states in a
    defined state machine. Each state corresponds to an image shown to
    the user, with the edges corresponding to the amount of time an
    image is shown, and the transition it is shown with.

    Images are shown, perhaps with a transition, when we are
    transitioning into a state containing that image.
    """

    def __init__(self, initial, *args, **properties):
        """
        @param initial: The name (a string) of the initial state we
        start in.

        @param showold: If the keyword parameter showold is True, then
        the old image is shown instead of the new image when in an
        edge.

        @param anim_timebase: If True, we use the animation
        timebase. If False, we use the displayable timebase.

        This accepts as additional arguments the anim.State and
        anim.Edge objects that are used to make up this state
        machine.
        """

        if 'delay' in properties:
            self.delay = properties['delay']
            del properties['delay']
        else:
            self.delay = None

        if 'showold' in properties:
            self.showold = properties['showold']
            del properties['showold']
        else:
            self.showold = False

        if 'anim_timebase' in properties:
            self.anim_timebase = properties['anim_timebase']
            del properties['anim_timebase']
        else:
            self.anim_timebase = True

        super(SMAnimation, self).__init__(**properties)

        self.properties = properties

        # The initial state.
        self.initial = initial

        # A map from state name to State object.
        self.states = { }

        # A map from state name to list of Edge objects.
        self.edges = { }

        for i in args:
            i.add(self)

        # The time at which the current edge started. If None, will be
        # set to st by render.
        self.edge_start = None

        # A cache for what the current edge looks like when rendered.
        self.edge_cache = None

        # The current edge.
        self.edge = None

        # The state we're in.
        self.state = None

    def visit(self):
        return [ i.image for i in self.states.itervalues() ]

    def pick_edge(self, state):
        """
        This randomly picks an edge out of the given state, if
        one exists. It updates self.edge if a transition has
        been selected, or returns None if none can be found. It also
        updates self.image to be the new image on the selected edge.
        """

        if state not in self.edges:
            self.edge = None
            return

        edges = self.edges[state]
        self.edge = random.choice(edges)
        self.state = self.edge.new

    def update_cache(self):
        """
        Places the correct Displayable into the edge cache, based on
        what is contained in the given edge. This takes into account
        the old and new states, and any transition that is present.
        """


        if self.edge.trans:
            im = self.edge.trans(old_widget=self.states[self.edge.old].get_image(),
                                 new_widget=self.states[self.edge.new].get_image())
        elif self.showold:
            im = self.states[self.edge.old].get_image()
        else:
            im = self.states[self.edge.new].get_image()

        self.edge_cache = im

    def get_placement(self):

        if self.edge_cache:
            return self.edge_cache.get_placement()

        if self.state:
            return self.states[self.state].get_image().get_placement()

        return super(SMAnimation, self).get_placement()

    def render(self, width, height, st, at):

        if self.anim_timebase:
            t = at
        else:
            t = st

        if self.edge_start is None or t < self.edge_start:
            self.edge_start = t
            self.edge_cache = None
            self.pick_edge(self.initial)

        while self.edge and t > self.edge_start + self.edge.delay:
            self.edge_start += self.edge.delay
            self.edge_cache = None
            self.pick_edge(self.edge.new)

        # If edge is None, then we have a permanent, static picture. Deal
        # with that.

        if not self.edge:
            im = renpy.display.render.render(self.states[self.state].get_image(),
                                             width, height,
                                             st - self.edge_start, at)


        # Otherwise, we have another edge.

        else:
            if not self.edge_cache:
                self.update_cache()

            im = renpy.display.render.render(self.edge_cache, width, height, t - self.edge_start, at)

            if not renpy.game.less_updates:
                renpy.display.render.redraw(self.edge_cache, self.edge.delay - (t - self.edge_start))


        iw, ih = im.get_size()

        rv = renpy.display.render.Render(iw, ih)
        rv.blit(im, (0, 0))

        return rv

    def __call__(self, child=None, new_widget=None, old_widget=None):
        """
        Used when this SMAnimation is used as a SMMotion. This creates
        a duplicate of the animation, with all states containing None
        as the image having that None replaced with the image that is provided here.
        """

        if child is None:
            child = new_widget

        args = [ ]

        for state in self.states.itervalues():
            args.append(state.motion_copy(child))

        for edges in self.edges.itervalues():
            args.extend(edges)

        return SMAnimation(self.initial, delay=self.delay, *args, **self.properties)


# class Animation(renpy.display.core.Displayable):
#     """
#     A Displayable that draws an animation, which is a series of images
#     that are displayed with time delays between them.
#     """

#     def __init__(self, *args, **properties):
#         """
#         Odd (first, third, fifth, etc.) arguments to Animation are
#         interpreted as image filenames, while even arguments are the
#         time to delay between each image. If the number of arguments
#         is odd, the animation will stop with the last image (well,
#         actually delay for a year before looping). Otherwise, the
#         animation will restart after the final delay time.

#         @param anim_timebase: If True, the default, use the animation
#         timebase. Otherwise, use the displayable timebase.
#         """

#         properties.setdefault('style', 'animation')
#         self.anim_timebase = properties.pop('anim_timebase', True)

#         super(Animation, self).__init__(**properties)

#         self.images = [ ]
#         self.delays = [ ]

#         for i, arg in enumerate(args):

#             if i % 2 == 0:
#                 self.images.append(renpy.easy.displayable(arg))
#             else:
#                 self.delays.append(arg)

#         if len(self.images) > len(self.delays):
#             self.delays.append(365.25 * 86400.0) # One year, give or take.

#     def render(self, width, height, st, at):

#         if self.anim_timebase:
#             t = at % sum(self.delays)
#         else:
#             t = st % sum(self.delays)

#         for image, delay in zip(self.images, self.delays):
#             if t < delay:
#                 renpy.display.render.redraw(self, delay - t)

#                 im = renpy.display.render.render(image, width, height, t, at)
#                 width, height = im.get_size()
#                 rv = renpy.display.render.Render(width, height)
#                 rv.blit(im, (0, 0))

#                 return rv

#             else:
#                 t = t - delay

#     def visit(self):
#         return self.images

def Animation(*args, **kwargs):
    newargs = [ ]

    for i, a in enumerate(args):
        newargs.append(a)
        if i % 2 == 1:
            newargs.append(None)

    return TransitionAnimation(*newargs, **kwargs)


class TransitionAnimation(renpy.display.core.Displayable):
    """
    A displayable that draws an animation with each frame separated
    by a transition.
    """

    def __init__(self, *args, **properties):
        """
        This takes arguments such that the 1st, 4th, 7th, ...
        arguments are displayables, the 2nd, 5th, 8th, ... on arguments
        are times, and the 3rd, 6th, 9th, ... are transitions.

        This displays the first displayable for the given time, then
        transitions to the second displayable using the given
        transition, and shows it for the given time (the time of the
        transition is taken out of the time the frame is shown), and
        so on.

        The last argument may be a displayable (in which case that
        displayable is used to transition back to the first frame), or
        a displayable (which is shown forever).

        There is one keyword argument, apart from the style properties:

        @param anim_timebase: If True, the default, use the animation
        timebase. Otherwise, use the displayable timebase.
        """

        properties.setdefault('style', 'animation')
        self.anim_timebase = properties.pop('anim_timebase', True)

        super(TransitionAnimation, self).__init__(**properties)

        images = [ ]
        delays = [ ]
        transitions = [ ]

        for i, arg in enumerate(args):

            if i % 3 == 0:
                images.append(renpy.easy.displayable(arg))
            elif i % 3 == 1:
                delays.append(arg)
            else:
                transitions.append(arg)

        if len(images) > len(delays):
            delays.append(365.25 * 86400.0) # One year, give or take.
        if len(images) > len(transitions):
            transitions.append(None)

        self.images = images
        self.prev_images = [ images[-1] ] + images[:-1]
        self.delays = delays
        self.transitions = [ transitions[-1] ] + transitions[:-1]


    def render(self, width, height, st, at):

        if self.anim_timebase:
            orig_t = at
        else:
            orig_t = st

        t = orig_t % sum(self.delays)

        for image, prev, delay, trans in zip(self.images, self.prev_images, self.delays, self.transitions):
            if t < delay:
                if not renpy.game.less_updates:
                    renpy.display.render.redraw(self, delay - t)

                if trans and orig_t >= self.delays[0]:
                    image = trans(old_widget=prev, new_widget=image)

                im = renpy.display.render.render(image, width, height, t, at)
                width, height = im.get_size()
                rv = renpy.display.render.Render(width, height)
                rv.blit(im, (0, 0))

                return rv

            else:
                t = t - delay

    def visit(self):
        return self.images

class Blink(renpy.display.core.Displayable):
    """
    """

    def __init__(self, image, on=0.5, off=0.5, rise=0.5, set=0.5, #@ReservedAssignment
                 high=1.0, low=0.0, offset=0.0, anim_timebase=False, **properties):

        """
        This takes as an argument an image or widget, and blinks that image
        by varying its alpha. The sequence of phases is
        on - set - off - rise - on - ... All times are given in seconds, all
        alphas are fractions between 0 and 1.

        @param image: The image or widget that will be blinked.

        @param on: The amount of time the widget spends on, at high alpha.

        @param off: The amount of time the widget spends off, at low alpha.

        @param rise: The amount time the widget takes to ramp from low to high alpha.

        @param set: The amount of time the widget takes to ram from high to low.

        @param high: The high alpha.

        @param low: The low alpha.

        @param offset: A time offset, in seconds. Use this to have a
        blink that does not start at the start of the on phase.

        @param anim_timebase: If True, use the animation timebase, if false, the displayable timebase.
        """

        super(Blink, self).__init__(**properties)

        self.image = renpy.easy.displayable(image)
        self.on = on
        self.off = off
        self.rise = rise
        self.set = set
        self.high = high
        self.low = low
        self.offset = offset
        self.anim_timebase = anim_timebase

        self.cycle = on + set + off + rise


    def visit(self):
        return [ self.image ]

    def render(self, height, width, st, at):

        if self.anim_timebase:
            t = at
        else:
            t = st

        time = (self.offset + t) % self.cycle
        alpha = self.high

        if 0 <= time < self.on:
            delay = self.on - time
            alpha = self.high

        time -= self.on

        if 0 <= time < self.set:
            delay = 0
            frac = time / self.set
            alpha = self.low * frac + self.high * (1.0 - frac)

        time -= self.set

        if 0 <= time < self.off:
            delay = self.off - time
            alpha = self.low

        time -= self.off

        if 0 <= time < self.rise:
            delay = 0
            frac = time / self.rise
            alpha = self.high * frac + self.low * (1.0 - frac)


        rend = renpy.display.render.render(self.image, height, width, st, at)
        w, h = rend.get_size()
        rv = renpy.display.render.Render(w, h)

        rv.blit(rend, (0, 0))
        rv.alpha = alpha

        if not renpy.game.less_updates:
            renpy.display.render.redraw(self, delay)

        return rv



def Filmstrip(image, framesize, gridsize, delay, frames=None, loop=True, **properties):
    """
    This creates an animation from a single image. This image
    must consist of a grid of frames, with the number of columns and
    rows in the grid being taken from gridsize, and the size of each
    frame in the grid being taken from framesize. This takes frames
    and sticks them into an Animation, with the given delay between
    each frame. The frames are taken by going from left-to-right
    across the first row, left-to-right across the second row, and
    so on until all frames are consumed, or a specified number of
    frames are taken.

    @param image: The image that the frames must be taken from.

    @param framesize: A (width, height) tuple giving the size of
    each of the frames in the animation.

    @param gridsize: A (columns, rows) tuple giving the number of
    columns and rows in the grid.

    @param delay: The delay, in seconds, between frames.

    @param frames: The number of frames in this animation. If None,
    then this defaults to colums * rows frames, that is, taking
    every frame in the grid.

    @param loop: If True, loop at the end of the animation. If False,
    this performs the animation once, and then stops.

    Other keyword arguments are as for anim.SMAnimation.
    """

    width, height = framesize
    cols, rows = gridsize

    if frames is None:
        frames = cols * rows

    i = 0

    # Arguments to Animation
    args = [ ]

    for r in range(0, rows):
        for c in range(0, cols):

            x = c * width
            y = r * height

            args.append(renpy.display.im.Crop(image, x, y, width, height))
            args.append(delay)

            i += 1
            if i == frames:
                break

        if i == frames:
            break

    if not loop:
        args.pop()

    return Animation(*args, **properties)

########NEW FILE########
__FILENAME__ = behavior
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This contains various Displayables that handle events.


import renpy.display
import renpy.audio

from renpy.display.render import render, Render

import pygame

import math

def compile_event(key, keydown):
    """
    Compiles a keymap entry into a python expression.

    keydown determines if we are dealing with keys going down (press),
    or keys going up (release).
    """

    # Lists or tuples get turned into or expressions.
    if isinstance(key, (list, tuple)):
        if not key:
            return "(False)"

        return "(" + " or ".join([compile_event(i, keydown) for i in key]) + ")"

    # If it's in config.keymap, compile what's in config.keymap.
    if key in renpy.config.keymap:
        return compile_event(renpy.config.keymap[key], keydown)

    if key is None:
        return "(False)"

    part = key.split("_")

    # Deal with the mouse.
    if part[0] == "mousedown":
        if keydown:
            return "(ev.type == %d and ev.button == %d)" % (pygame.MOUSEBUTTONDOWN, int(part[1]))
        else:
            return "(False)"

    if part[0] == "mouseup":
        if keydown:
            return "(ev.type == %d and ev.button == %d)" % (pygame.MOUSEBUTTONUP, int(part[1]))
        else:
            return "(False)"

    # Deal with the Joystick.
    if part[0] == "joy":
        if keydown:
            return "(ev.type == %d and ev.press and ev.press == renpy.game.preferences.joymap.get(%r, None))" % (renpy.display.core.JOYEVENT, key)
        else:
            return "(ev.type == %d and ev.release and ev.release == renpy.game.preferences.joymap.get(%r, None))" % (renpy.display.core.JOYEVENT, key)

    # Otherwise, deal with it as a key.
    if keydown:
        rv = "(ev.type == %d" % pygame.KEYDOWN
    else:
        rv = "(ev.type == %d" % pygame.KEYUP

    if part[0] == "alt":
        part.pop(0)
        rv += " and (ev.mod & %d)" % pygame.KMOD_ALT
    else:
        rv += " and not (ev.mod & %d)" % pygame.KMOD_ALT

    if part[0] == "meta":
        part.pop(0)
        rv += " and (ev.mod & %d)" % pygame.KMOD_META
    else:
        rv += " and not (ev.mod & %d)" % pygame.KMOD_META

    if part[0] == "shift":
        part.pop(0)
        rv += " and (ev.mod & %d)" % pygame.KMOD_SHIFT

    if part[0] == "noshift":
        part.pop(0)
        rv += " and not (ev.mod & %d)" % pygame.KMOD_SHIFT

    if len(part) == 1:
        if len(part[0]) != 1:
            if renpy.config.developer:
                raise Exception("Invalid key specifier %s" % key)
            else:
                return "(False)"

        rv += " and ev.unicode == %r)" % part[0]

    else:
        if part[0] != "K":
            if renpy.config.developer:
                raise Exception("Invalid key specifier %s" % key)
            else:
                return "(False)"

        key = "_".join(part)

        rv += " and ev.key == %d)" % (getattr(pygame.constants, key))

    return rv


# These store a lambda for each compiled key in the system.
event_cache = { }
keyup_cache = { }


def clear_keymap_cache():
    """
    :doc: other

    Clears the keymap cache. This allows changes to :var:`config.keymap` to
    take effect without restarting Ren'Py.
    """

    event_cache.clear()
    keyup_cache.clear()


def queue_event(name, up=False):
    """
    :doc: other

    Queues an event with the given name. `Name` should be one of the event
    names in :var:`config.keymap`.

    `up`
        This should be false when the event begins (for example, when a keyboard
        button is pressed.) It should be true when the event ends (when the
        button is released.)

    The event is queued at the time this function is called. This function will
    not work to replace an event with another - doing so will change event order.
    (Use :var:`config.keymap` instead.)

    This method is threadsafe.
    """

    # Avoid queueing events before we're ready.
    if not renpy.display.interface:
        return

    ev = pygame.event.Event(renpy.display.core.EVENTNAME, { "eventname" : name, "up" : up })
    pygame.event.post(ev)

def map_event(ev, keysym):
    """
    :doc: udd_utility

    Returns true if the pygame event `ev` matches `keysym`

    `keysym`
        One of:

        * The name of a keybinding in :var:`config.keymap`.
        * A keysym, as documented in the :ref:`keymap` section.
        * A list containing one or more keysyms.
    """

    if ev.type == renpy.display.core.EVENTNAME:
        if ev.eventname == keysym and not ev.up:
            return True

        return False

    check_code = event_cache.get(keysym, None)
    if check_code is None:
        check_code = eval("lambda ev : " + compile_event(keysym, True), globals())
        event_cache[keysym] = check_code

    return check_code(ev)

def map_keyup(ev, name):
    """Returns true if the event matches the named keycode being released."""

    if ev.type == renpy.display.core.EVENTNAME:
        if ev.eventname == name and ev.up:
            return True

    check_code = keyup_cache.get(name, None)
    if check_code is None:
        check_code = eval("lambda ev : " + compile_event(name, False), globals())
        keyup_cache[name] = check_code

    return check_code(ev)


def skipping(ev):
    """
    This handles setting skipping in response to the press of one of the
    CONTROL keys. The library handles skipping in response to TAB.
    """

    if not renpy.config.allow_skipping:
        return

    if map_event(ev, "skip"):
        renpy.config.skipping = "slow"
        renpy.exports.restart_interaction()

    if map_keyup(ev, "skip"):
        renpy.config.skipping = None
        renpy.exports.restart_interaction()

    return


def inspector(ev):
    return map_event(ev, "inspector")


##############################################################################
# Utility functions for dealing with actions.

def predict_action(var):
    """
    Predicts some of the actions that may be caused by a variable.
    """

    if var is None:
        return

    if isinstance(var, renpy.ui.Action):
        var.predict()

    if isinstance(var, (list, tuple)):
        for i in var:
            predict_action(i)

def run(var, *args, **kwargs):
    """
    Runs a variable. This is done by calling all the functions, and
    iterating over the lists and tuples.
    """

    if var is None:
        return None

    if isinstance(var, (list, tuple)):
        rv = None

        for i in var:
            new_rv = run(i, *args, **kwargs)

            if new_rv is not None:
                rv = new_rv

        return rv

    return var(*args, **kwargs)

def run_unhovered(var):
    """
    Calls the unhovered method on the variable, if it exists.
    """

    if var is None:
        return None

    if isinstance(var, (list, tuple)):
        for i in var:
            run_unhovered(i)

        return

    f = getattr(var, "unhovered", None)
    if f is not None:
        f()

def run_periodic(var, st):

    if isinstance(var, (list, tuple)):
        rv = None

        for i in var:
            v = run_periodic(i, st)

            if rv is None or v < rv:
                rv = v

        return rv

    if isinstance(var, renpy.ui.Action):
        return var.periodic(st)


def is_selected(clicked):

    if isinstance(clicked, (list, tuple)):
        return any(is_selected(i) for i in clicked)

    elif isinstance(clicked, renpy.ui.Action):
        return clicked.get_selected()
    else:
        return False


def is_sensitive(clicked):

    if isinstance(clicked, (list, tuple)):
        return all(is_sensitive(i) for i in clicked)

    elif isinstance(clicked, renpy.ui.Action):
        return clicked.get_sensitive()
    else:
        return True


##############################################################################
# Special-Purpose Displayables

class Keymap(renpy.display.layout.Null):
    """
    This is a behavior that maps keys to actions that are called when
    the key is pressed. The keys are specified by giving the appropriate
    k_constant from pygame.constants, or the unicode for the key.
    """

    def __init__(self, replaces=None, **keymap):
        super(Keymap, self).__init__(style='default')
        self.keymap = keymap

    def event(self, ev, x, y, st):

        for name, action in self.keymap.iteritems():
            if map_event(ev, name):

                rv = run(action)

                if rv is not None:
                    return rv

                raise renpy.display.core.IgnoreEvent()

    def predict_one_action(self):
        for i in self.keymap.itervalues():
            predict_action(i)


class RollForward(renpy.display.layout.Null):
    """
    This behavior implements rollforward.
    """

    def __init__(self, value, **properties):
        super(RollForward, self).__init__(**properties)
        self.value = value


    def event(self, ev, x, y, st):

        if map_event(ev, "rollforward"):
            renpy.game.interface.suppress_transition = True
            renpy.game.after_rollback = True
            renpy.game.log.rolled_forward = True
            return self.value


class PauseBehavior(renpy.display.layout.Null):
    """
    This is a class implementing the Pause behavior, which is to
    return a value after a certain amount of time has elapsed.
    """

    def __init__(self, delay, result=False, **properties):
        super(PauseBehavior, self).__init__(**properties)

        self.delay = delay
        self.result = result

    def event(self, ev, x, y, st):

        if st >= self.delay:

            # If we have been drawn since the timeout, simply return
            # true. Otherwise, force a redraw, and return true when
            # it comes back.
            if renpy.game.interface.drawn_since(st - self.delay):
                return self.result
            else:
                renpy.game.interface.force_redraw = True


        renpy.game.interface.timeout(max(self.delay - st, 0))

class SoundStopBehavior(renpy.display.layout.Null):
    """
    This is a class implementing the sound stop behavior,
    which is to return False when a sound is no longer playing
    on the named channel.
    """

    def __init__(self, channel, result=False, **properties):
        super(SoundStopBehavior, self).__init__(**properties)

        self.channel = channel
        self.result = result


    def event(self, ev, x, y, st):

        if not renpy.audio.music.get_playing(self.channel):
            return self.result

        renpy.game.interface.timeout(.025)


class SayBehavior(renpy.display.layout.Null):
    """
    This is a class that implements the say behavior,
    which is to return True (ending the interaction) if
    the user presses space or enter, or clicks the left
    mouse button.
    """

    focusable = True

    def __init__(self, default=True, afm=None, dismiss=[ 'dismiss' ], allow_dismiss=None, **properties):
        super(SayBehavior, self).__init__(default=default, **properties)

        if not isinstance(dismiss, (list, tuple)):
            dismiss = [ dismiss ]

        if afm is not None:
            self.afm_length = len(afm)
        else:
            self.afm_length = None

        # What keybindings lead to dismissal?
        self.dismiss = dismiss

        self.allow_dismiss = allow_dismiss

    def set_afm_length(self, afm_length):
        self.afm_length = max(afm_length, 1)

    def event(self, ev, x, y, st):

        if self.afm_length and renpy.game.preferences.afm_time and renpy.game.preferences.afm_enable:

            afm_delay = ( 1.0 * ( renpy.config.afm_bonus + self.afm_length ) / renpy.config.afm_characters ) * renpy.game.preferences.afm_time

            if renpy.game.preferences.text_cps:
                afm_delay += 1.0 / renpy.game.preferences.text_cps * self.afm_length

            if st > afm_delay:
                if renpy.config.afm_callback:
                    if renpy.config.afm_callback():
                        return True
                    else:
                        renpy.game.interface.timeout(0.1)
                else:
                    return True
            else:
                renpy.game.interface.timeout(afm_delay - st)

        for dismiss in self.dismiss:

            if map_event(ev, dismiss) and self.is_focused():

                if renpy.config.skipping:
                    renpy.config.skipping = None
                    renpy.exports.restart_interaction()
                    raise renpy.display.core.IgnoreEvent()

                if renpy.game.preferences.using_afm_enable and \
                    renpy.game.preferences.afm_enable and \
                    not renpy.game.preferences.afm_after_click:

                    renpy.game.preferences.afm_enable = False
                    renpy.exports.restart_interaction()
                    raise renpy.display.core.IgnoreEvent()

                if self.allow_dismiss:
                    if not self.allow_dismiss():
                        raise renpy.display.core.IgnoreEvent()

                return True

        skip_delay = renpy.config.skip_delay / 1000.0

        if renpy.config.allow_skipping and renpy.config.skipping:

            if st >= skip_delay:
                if renpy.game.preferences.skip_unseen:
                    return True
                elif renpy.config.skipping == "fast":
                    return True
                elif renpy.game.context().seen_current(True):
                    return True
            else:
                renpy.game.interface.timeout(skip_delay - st)


        return None


##############################################################################
# Button

class Button(renpy.display.layout.Window):

    keymap = { }
    action = None
    alternate = None

    longpress_start = None
    longpress_x = None
    longpress_y = None

    role_parameter = None

    def __init__(self, child=None, style='button', clicked=None,
                 hovered=None, unhovered=None, action=None, role=None,
                 time_policy=None, keymap={}, alternate=None,
                 **properties):

        super(Button, self).__init__(child, style=style, **properties)

        if isinstance(clicked, renpy.ui.Action):
            action = clicked

        self.action = action
        self.clicked = clicked
        self.hovered = hovered
        self.unhovered = unhovered
        self.alternate = alternate

        self.focusable = clicked is not None
        self.role_parameter = role
        self.keymap = keymap

        self.time_policy_data = None

    def predict_one_action(self):
        predict_action(self.clicked)
        predict_action(self.hovered)
        predict_action(self.unhovered)
        predict_action(self.alternate)

        if self.keymap:
            for v in self.keymap.itervalues():
                predict_action(v)

    def render(self, width, height, st, at):

        if self.style.time_policy:
            st, self.time_policy_data = self.style.time_policy(st, self.time_policy_data, self.style)

        rv = super(Button, self).render(width, height, st, at)

        if self.clicked:

            rect = self.style.focus_rect
            if rect is not None:
                fx, fy, fw, fh = rect
            else:
                fx = self.style.left_margin
                fy = self.style.top_margin
                fw = rv.width - self.style.right_margin
                fh = rv.height - self.style.bottom_margin

            mask = self.style.focus_mask

            if mask is True:
                mask = rv
            elif mask is not None:
                try:
                    mask = renpy.easy.displayable(mask)
                    mask = renpy.display.render.render(mask, rv.width, rv.height, st, at)
                except:
                    if callable(mask):
                        mask = mask
                    else:
                        raise Exception("Focus_mask must be None, True, a displayable, or a callable.")

            if mask is not None:
                fmx = 0
                fmy = 0
            else:
                fmx = None
                fmy = None

            rv.add_focus(self, None,
                         fx, fy, fw, fh,
                         fmx, fmy, mask)

        return rv

    def focus(self, default=False):
        super(Button, self).focus(default)

        rv = None

        if not default:
            rv = run(self.hovered)

        self.set_transform_event(self.role + "hover")

        if self.child is not None:
            self.child.set_transform_event(self.role + "hover")

        return rv

    def unfocus(self, default=False):
        super(Button, self).unfocus(default)

        self.longpress_start = None

        if not default:
            run_unhovered(self.hovered)
            run(self.unhovered)

        self.set_transform_event(self.role + "idle")

        if self.child is not None:
            self.child.set_transform_event(self.role + "idle")


    def per_interact(self):

        if self.action is not None:
            if is_selected(self.action):
                role = 'selected_'
            else:
                role = ''

            if is_sensitive(self.action):
                clicked = self.action
            else:
                clicked = None

        else:
            role = ''
            clicked = self.clicked

        if self.role_parameter is not None:
            role = self.role_parameter

        if (role != self.role) or (clicked is not self.clicked):
            renpy.display.render.invalidate(self)
            self.role = role
            self.clicked = clicked

        if not self.clicked:
            self.set_style_prefix(self.role + "insensitive_", True)
        else:
            self.set_style_prefix(self.role + "idle_", True)

        super(Button, self).per_interact()

    def event(self, ev, x, y, st):

        def handle_click(action):
            if self.style.activate_sound:
                renpy.audio.music.play(self.style.activate_sound, channel="sound")

            rv = run(action)

            if rv is not None:
                return rv
            else:
                raise renpy.display.core.IgnoreEvent()

        # Call self.action.periodic()
        timeout = run_periodic(self.action, st)

        if timeout is not None:
            renpy.game.interface.timeout(timeout)

        # If we have a child, try passing the event to it. (For keyboard
        # events, this only happens if we're focused.)
        if self.is_focused() or not (ev.type == pygame.KEYDOWN or ev.type == pygame.KEYUP):
            rv = super(Button, self).event(ev, x, y, st)
            if rv is not None:
                return rv

        # If not focused, ignore all events.
        if not self.is_focused():
            return None

        # Check the keymap.
        for name, action in self.keymap.iteritems():
            if map_event(ev, name):
                return run(action)

        # Handle the longpress event, if necessary.
        if (self.alternate is not None) and renpy.display.touch:

            if ev.type == pygame.MOUSEBUTTONDOWN and ev.button == 1:
                self.longpress_start = st
                self.longpress_x = x
                self.longpress_y = y

                renpy.game.interface.timeout(renpy.config.longpress_duration)

            if self.longpress_start is not None:
                if math.hypot(x - self.longpress_x, y - self.longpress_y) > renpy.config.longpress_radius:
                    self.longpress_start = None
                elif st >= (self.longpress_start + renpy.config.longpress_duration):
                    renpy.exports.vibrate(renpy.config.longpress_vibrate)
                    renpy.display.interface.after_longpress()

                    return handle_click(self.alternate)

        # Ignore as appropriate:
        if (self.clicked is not None) and map_event(ev, "button_ignore"):
            raise renpy.display.core.IgnoreEvent()

        if (self.clicked is not None) and map_event(ev, "button_alternate_ignore"):
            raise renpy.display.core.IgnoreEvent()

        # If clicked,
        if (self.clicked is not None) and map_event(ev, "button_select"):
            return handle_click(self.clicked)

        if (self.alternate is not None) and map_event(ev, "button_alternate"):
            return handle_click(self.alternate)

        return None


    def set_style_prefix(self, prefix, root):
        if root:
            super(Button, self).set_style_prefix(prefix, root)


# Reimplementation of the TextButton widget as a Button and a Text
# widget.
def TextButton(text, style='button', text_style='button_text',
               clicked=None, **properties):

    text = renpy.text.text.Text(text, style=text_style) #@UndefinedVariable
    return Button(text, style=style, clicked=clicked, **properties)

class ImageButton(Button):
    """
    Used to implement the guts of an image button.
    """

    def __init__(self,
                 idle_image,
                 hover_image,
                 insensitive_image = None,
                 activate_image = None,
                 selected_idle_image = None,
                 selected_hover_image = None,
                 selected_insensitive_image = None,
                 selected_activate_image = None,
                 style='image_button',
                 clicked=None,
                 hovered=None,
                 **properties):

        insensitive_image = insensitive_image or idle_image
        activate_image = activate_image or hover_image

        selected_idle_image = selected_idle_image or idle_image
        selected_hover_image = selected_hover_image or hover_image
        selected_insensitive_image = selected_insensitive_image or insensitive_image
        selected_activate_image = selected_activate_image or activate_image

        self.state_children = dict(
            idle_ = renpy.easy.displayable(idle_image),
            hover_ = renpy.easy.displayable(hover_image),
            insensitive_ = renpy.easy.displayable(insensitive_image),
            activate_ = renpy.easy.displayable(activate_image),

            selected_idle_ = renpy.easy.displayable(selected_idle_image),
            selected_hover_ = renpy.easy.displayable(selected_hover_image),
            selected_insensitive_ = renpy.easy.displayable(selected_insensitive_image),
            selected_activate_ = renpy.easy.displayable(selected_activate_image),
            )

        super(ImageButton, self).__init__(None,
                                          style=style,
                                          clicked=clicked,
                                          hovered=hovered,
                                          **properties)

    def visit(self):
        return self.state_children.values()

    def get_child(self):
        return self.style.child or self.state_children[self.style.prefix]


# This is used for an input that takes its focus from a button.
class HoveredProxy(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __call__(self):
        self.a()
        if self.b:
            return self.b()


class Input(renpy.text.text.Text): #@UndefinedVariable
    """
    This is a Displayable that takes text as input.
    """

    changed = None
    prefix = ""
    suffix = ""
    caret_pos = 0
    old_caret_pos = 0
    pixel_width = None
    default = u""

    def __init__(self,
                 default="",
                 length=None,
                 style='input',
                 allow=None,
                 exclude=None,
                 prefix="",
                 suffix="",
                 changed=None,
                 button=None,
                 replaces=None,
                 editable=True,
                 pixel_width=None,
                 **properties):

        super(Input, self).__init__("", style=style, replaces=replaces, substitute=False, **properties)

        self.default = unicode(default)
        self.content = self.default

        self.length = length

        self.allow = allow
        self.exclude = exclude
        self.prefix = prefix
        self.suffix = suffix

        self.changed = changed

        self.editable = editable
        self.pixel_width = pixel_width

        caretprops = { 'color' : None }

        for i in properties:
            if i.endswith("color"):
                caretprops[i] = properties[i]

        self.caret = renpy.display.image.Solid(xmaximum=1, style=style, **caretprops)
        self.caret_pos = len(self.content)
        self.old_caret_pos = self.caret_pos

        if button:
            self.editable = False
            button.hovered = HoveredProxy(self.enable, button.hovered)
            button.unhovered = HoveredProxy(self.disable, button.unhovered)

        if isinstance(replaces, Input):
            self.content = replaces.content
            self.editable = replaces.editable
            self.caret_pos = replaces.caret_pos

        self.update_text(self.content, self.editable)


    def _show(self):
        if self.default != self.content:
            self.content = self.default
            self.caret_pos = len(self.content)
            self.update_text(self.content, self.editable)

    def update_text(self, new_content, editable, check_size=False):

        old_content = self.content

        if new_content != self.content or editable != self.editable:
            renpy.display.render.redraw(self, 0)

        self.editable = editable

        # Choose the caret.
        caret = self.style.caret
        if caret is None:
            caret = self.caret

        def set_content(content):

            if content == "":
                content = u"\u200b"

            if editable:
                l = len(content)
                self.set_text([self.prefix, content[0:self.caret_pos].replace("{", "{{"), caret,
                                            content[self.caret_pos:l].replace("{", "{{"), self.suffix])
            else:
                self.set_text([self.prefix, content.replace("{", "{{"), self.suffix ])

        set_content(new_content)

        if check_size and self.pixel_width:
            w, _h = self.size()
            if w > self.pixel_width:
                self.caret_pos = self.old_caret_pos
                set_content(old_content)
                return

        if new_content != old_content:
            self.content = new_content

            if self.changed:
                self.changed(new_content)

    # This is needed to ensure the caret updates properly.
    def set_style_prefix(self, prefix, root):
        if prefix != self.style.prefix:
            self.update_text(self.content, self.editable)

        super(Input, self).set_style_prefix(prefix, root)

    def enable(self):
        self.update_text(self.content, True)

    def disable(self):
        self.update_text(self.content, False)

    def event(self, ev, x, y, st):

        self.old_caret_pos = self.caret_pos

        if not self.editable:
            return None

        l = len(self.content)

        if map_event(ev, "input_backspace"):

            if self.content and self.caret_pos > 0:
                content = self.content[0:self.caret_pos-1] + self.content[self.caret_pos:l]
                self.caret_pos -= 1
                self.update_text(content, self.editable)

            renpy.display.render.redraw(self, 0)
            raise renpy.display.core.IgnoreEvent()

        elif map_event(ev, "input_enter"):
            if not self.changed:
                return self.content

        elif map_event(ev, "input_left"):
            if self.caret_pos > 0:
                self.caret_pos -= 1
                self.update_text(self.content, self.editable)

            renpy.display.render.redraw(self, 0)
            raise renpy.display.core.IgnoreEvent()

        elif map_event(ev, "input_right"):
            if self.caret_pos < l:
                self.caret_pos += 1
                self.update_text(self.content, self.editable)

            renpy.display.render.redraw(self, 0)
            raise renpy.display.core.IgnoreEvent()

        elif map_event(ev, "input_delete"):
            if self.caret_pos < l:
                content = self.content[0:self.caret_pos] + self.content[self.caret_pos+1:l]
                self.update_text(content, self.editable)

            renpy.display.render.redraw(self, 0)
            raise renpy.display.core.IgnoreEvent()

        elif ev.type == pygame.KEYDOWN and ev.unicode:
            if ord(ev.unicode[0]) < 32:
                return None

            if self.length and len(self.content) >= self.length:
                raise renpy.display.core.IgnoreEvent()

            if self.allow and ev.unicode not in self.allow:
                raise renpy.display.core.IgnoreEvent()

            if self.exclude and ev.unicode in self.exclude:
                raise renpy.display.core.IgnoreEvent()

            content = self.content[0:self.caret_pos] + ev.unicode + self.content[self.caret_pos:l]
            self.caret_pos += 1

            self.update_text(content, self.editable, check_size=True)

            raise renpy.display.core.IgnoreEvent()

# A map from adjustment to lists of displayables that want to be redrawn
# if the adjustment changes.
adj_registered = { }

# This class contains information about an adjustment that can change the
# position of content.
class Adjustment(renpy.object.Object):
    """
    :doc: ui
    :name: ui.adjustment class

    Adjustment objects represent a value that can be adjusted by a bar
    or viewport. They contain information about the value, the range
    of the value, and how to adjust the value in small steps and large
    pages.


    """

    def __init__(self, range=1, value=0, step=None, page=0, changed=None, adjustable=None, ranged=None): #@ReservedAssignment
        """
        The following parameters correspond to fields or properties on
        the adjustment object:

        `range`
            The range of the adjustment, a number.

        `value`
            The value of the adjustment, a number.

        `step`
            The step size of the adjustment, a number. If None, then
            defaults to 1/10th of a page, if set. Otherwise, defaults
            to the 1/20th of the range.

            This is used when scrolling a viewport with the mouse wheel.

        `page`
            The page size of the adjustment. If None, this is set
            automatically by a viewport. If never set, defaults to 1/10th
            of the range.

            It's can be used when clicking on a scrollbar.

        The following parameters control the behavior of the adjustment.

        `adjustable`
             If True, this adjustment can be changed by a bar. If False,
             it can't.

             It defaults to being adjustable if a `changed` function
             is given or if the adjustment is associated with a viewport,
             and not adjustable otherwise.

        `changed`
            This function is called with the new value when the value of
            the adjustment changes.

        `ranged`
            This function is called with the adjustment object when
            the range of the adjustment is set by a viewport.

        .. method:: change(value)

            Changes the value of the adjustment to `value`, updating
            any bars and viewports that use the adjustment.
         """


        super(Adjustment, self).__init__()

        if adjustable is None:
            if changed:
                adjustable = True

        self._value = value
        self._range = range
        self._page = page
        self._step = step
        self.changed = changed
        self.adjustable = adjustable
        self.ranged = ranged

    def get_value(self):
        if self._value > self._range:
            return self._range

        return self._value

    def set_value(self, v):
        self._value = v

    value = property(get_value, set_value)

    def get_range(self):
        return self._range

    def set_range(self, v):
        self._range = v
        if self.ranged:
            self.ranged(self)

    range = property(get_range, set_range) #@ReservedAssignment

    def get_page(self):
        if self._page is not None:
            return self._page

        return self._range / 10

    def set_page(self, v):
        self._page = v

    page = property(get_page, set_page)

    def get_step(self):
        if self._step is not None:
            return self._step

        if self._page is not None and self.page > 0:
            return self._page / 10

        if isinstance(self._range, float):
            return self._range / 10
        else:
            return 1

    def set_step(self, v):
        self._step = v

    step = property(get_step, set_step)

    # Register a displayable to be redrawn when this adjustment changes.
    def register(self, d):
        adj_registered.setdefault(self, [ ]).append(d)

    def change(self, value):

        if value < 0:
            value = 0
        if value > self._range:
            value = self._range

        if value != self._value:
            self._value = value
            for d in adj_registered.setdefault(self, [ ]):
                renpy.display.render.redraw(d, 0)
            if self.changed:
                return self.changed(value)

        return None

class Bar(renpy.display.core.Displayable):
    """
    Implements a bar that can display an integer value, and respond
    to clicks on that value.
    """

    __version__ = 2

    def after_upgrade(self, version):

        if version < 1:
            self.adjustment = Adjustment(self.range, self.value, changed=self.changed) # E1101
            self.adjustment.register(self)
            del self.range # E1101
            del self.value # E1101
            del self.changed # E1101

        if version < 2:
            self.value = None

    def __init__(self,
                 range=None, #@ReservedAssignment
                 value=None,
                 width=None,
                 height=None,
                 changed=None,
                 adjustment=None,
                 step=None,
                 page=None,
                 bar=None,
                 style=None,
                 vertical=False,
                 replaces=None,
                 hovered=None,
                 unhovered=None,
                 **properties):

        self.value = None

        if adjustment is None:
            if isinstance(value, renpy.ui.BarValue):

                if isinstance(replaces, Bar):
                    value.replaces(replaces.value)

                self.value = value
                adjustment = value.get_adjustment()
                renpy.game.interface.timeout(0)
            else:
                adjustment = Adjustment(range, value, step=step, page=page, changed=changed)

        if style is None:
            if self.value is not None:
                if vertical:
                    style = self.value.get_style()[1]
                else:
                    style = self.value.get_style()[0]
            else:
                if vertical:
                    style = 'vbar'
                else:
                    style = 'bar'

        if width is not None:
            properties['xmaximum'] = width

        if height is not None:
            properties['ymaximum'] = height

        super(Bar, self).__init__(style=style, **properties)

        self.adjustment = adjustment
        self.focusable = True

        # These are set when we are first rendered.
        self.thumb_dim = 0
        self.height = 0
        self.width = 0
        self.hidden = False

        self.hovered = hovered
        self.unhovered = unhovered

    def per_interact(self):
        if self.value is not None:
            adjustment = self.value.get_adjustment()

            if adjustment.value != self.value:
                renpy.display.render.invalidate(self)

            self.adjustment = adjustment

        self.focusable = self.adjustment.adjustable
        self.adjustment.register(self)

    def predict_one(self):
        pd = renpy.display.predict.displayable
        self.style._predict_window(pd)

    def render(self, width, height, st, at):

        # Handle redrawing.
        if self.value is not None:
            redraw = self.value.periodic(st)

            if redraw is not None:
                renpy.display.render.redraw(self, redraw)

        # Store the width and height for the event function to use.
        self.width = width
        self.height = height
        range = self.adjustment.range #@ReservedAssignment
        value = self.adjustment.value
        page = self.adjustment.page

        if range <= 0:
            if self.style.unscrollable == "hide":
                self.hidden = True
                return renpy.display.render.Render(width, height)
            elif self.style.unscrollable == "insensitive":
                self.set_style_prefix("insensitive_", True)

        self.hidden = False

        if self.style.bar_invert ^ self.style.bar_vertical:
            value = range - value

        bar_vertical = self.style.bar_vertical

        if bar_vertical:
            dimension = height
        else:
            dimension = width

        fore_gutter = self.style.fore_gutter
        aft_gutter = self.style.aft_gutter

        active = dimension - fore_gutter - aft_gutter
        if range:
            thumb_dim = active * page / (range + page)
        else:
            thumb_dim = active

        thumb_offset = abs(self.style.thumb_offset)

        if bar_vertical:
            thumb = render(self.style.thumb, width, thumb_dim, st, at)
            thumb_shadow = render(self.style.thumb_shadow, width, thumb_dim, st, at)
            thumb_dim = thumb.height
        else:
            thumb = render(self.style.thumb, thumb_dim, height, st, at)
            thumb_shadow = render(self.style.thumb_shadow, thumb_dim, height, st, at)
            thumb_dim = thumb.width

        # Remove the offset from the thumb.
        thumb_dim -= thumb_offset * 2
        self.thumb_dim = thumb_dim

        active -= thumb_dim

        if range:
            fore_size = active * value / range
        else:
            fore_size = active

        fore_size = int(fore_size)

        aft_size = active - fore_size

        fore_size += fore_gutter
        aft_size += aft_gutter

        rv = renpy.display.render.Render(width, height)

        if bar_vertical:

            if self.style.bar_resizing:
                foresurf = render(self.style.fore_bar, width, fore_size, st, at)
                aftsurf = render(self.style.aft_bar, width, aft_size, st, at)
                rv.blit(thumb_shadow, (0, fore_size - thumb_offset))
                rv.blit(foresurf, (0, 0), main=False)
                rv.blit(aftsurf, (0, height-aft_size), main=False)
                rv.blit(thumb, (0, fore_size - thumb_offset))

            else:
                foresurf = render(self.style.fore_bar, width, height, st, at)
                aftsurf = render(self.style.aft_bar, width, height, st, at)

                rv.blit(thumb_shadow, (0, fore_size - thumb_offset))
                rv.blit(foresurf.subsurface((0, 0, width, fore_size)), (0, 0), main=False)
                rv.blit(aftsurf.subsurface((0, height - aft_size, width, aft_size)), (0, height - aft_size), main=False)
                rv.blit(thumb, (0, fore_size - thumb_offset))

        else:
            if self.style.bar_resizing:
                foresurf = render(self.style.fore_bar, fore_size, height, st, at)
                aftsurf = render(self.style.aft_bar, aft_size, height, st, at)
                rv.blit(thumb_shadow, (fore_size - thumb_offset, 0))
                rv.blit(foresurf, (0, 0), main=False)
                rv.blit(aftsurf, (width-aft_size, 0), main=False)
                rv.blit(thumb, (fore_size - thumb_offset, 0))

            else:
                foresurf = render(self.style.fore_bar, width, height, st, at)
                aftsurf = render(self.style.aft_bar, width, height, st, at)

                rv.blit(thumb_shadow, (fore_size - thumb_offset, 0))
                rv.blit(foresurf.subsurface((0, 0, fore_size, height)), (0, 0), main=False)
                rv.blit(aftsurf.subsurface((width - aft_size, 0, aft_size, height)), (width-aft_size, 0), main=False)
                rv.blit(thumb, (fore_size - thumb_offset, 0))

        if self.focusable:
            rv.add_focus(self, None, 0, 0, width, height)

        return rv


    def focus(self, default=False):
        super(Bar, self).focus(default)
        self.set_transform_event("hover")

        if not default:
            run(self.hovered)


    def unfocus(self, default=False):
        super(Bar, self).unfocus()
        self.set_transform_event("idle")

        if not default:
            run_unhovered(self.hovered)
            run(self.unhovered)

    def event(self, ev, x, y, st):

        if not self.focusable:
            return None

        if not self.is_focused():
            return None

        if self.hidden:
            return None

        range = self.adjustment.range #@ReservedAssignment
        old_value = self.adjustment.value
        value = old_value

        vertical = self.style.bar_vertical
        invert = self.style.bar_invert ^ vertical
        if invert:
            value = range - value

        grabbed = (renpy.display.focus.get_grab() is self)
        just_grabbed = False

        if not grabbed and map_event(ev, "bar_activate"):
            renpy.display.focus.set_grab(self)
            self.set_style_prefix("selected_hover_", True)
            just_grabbed = True
            grabbed = True

        if grabbed:

            if vertical:
                increase = "bar_down"
                decrease = "bar_up"
            else:
                increase = "bar_right"
                decrease = "bar_left"

            if map_event(ev, decrease):
                value -= self.adjustment.step

            if map_event(ev, increase):
                value += self.adjustment.step

            if ev.type in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONUP, pygame.MOUSEBUTTONDOWN):

                if vertical:

                    tgutter = self.style.fore_gutter
                    bgutter = self.style.aft_gutter
                    zone_height = self.height - tgutter - bgutter - self.thumb_dim
                    if zone_height:
                        value = (y - tgutter - self.thumb_dim / 2) * range / zone_height
                    else:
                        value = 0

                else:
                    lgutter = self.style.fore_gutter
                    rgutter = self.style.aft_gutter
                    zone_width = self.width - lgutter - rgutter - self.thumb_dim
                    if zone_width:
                        value = (x - lgutter - self.thumb_dim / 2) * range / zone_width
                    else:
                        value = 0

            if isinstance(range, int):
                value = int(value)

            if value < 0:
                value = 0

            if value > range:
                value = range

        if invert:
            value = range - value

        if grabbed and not just_grabbed and map_event(ev, "bar_deactivate"):
            self.set_style_prefix("hover_", True)
            renpy.display.focus.set_grab(None)

        if value != old_value:
            return self.adjustment.change(value)

        return None


class Conditional(renpy.display.layout.Container):
    """
    This class renders its child if and only if the condition is
    true. Otherwise, it renders nothing. (Well, a Null).

    Warning: the condition MUST NOT update the game state in any
    way, as that would break rollback.
    """

    def __init__(self, condition, *args, **properties):
        super(Conditional, self).__init__(*args, **properties)

        self.condition = condition
        self.null = renpy.display.layout.Null()

        self.state = eval(self.condition, vars(renpy.store))

    def render(self, width, height, st, at):
        if self.state:
            return render(self.child, width, height, st, at)
        else:
            return render(self.null, width, height, st, at)

    def event(self, ev, x, y, st):

        state = eval(self.condition, vars(renpy.store))

        if state != self.state:
            renpy.display.render.redraw(self, 0)

        self.state = state

        if state:
            return self.child.event(ev, x, y, st)


class TimerState(renpy.python.RevertableObject):
    """
    Stores the state of the timer, which may need to be rolled back.
    """

    # Prevents us from having to worry about our initialization being
    # rolled back.
    started = False
    next_event = None

class Timer(renpy.display.layout.Null):

    __version__ = 1

    started = False

    def after_upgrade(self, version):
        if version < 1:
            self.state = TimerState()
            self.state.started = self.started
            self.state.next_event = self.next_event

    def __init__(self, delay, action=None, repeat=False, args=(), kwargs={}, replaces=None, **properties):
        super(Timer, self).__init__(**properties)

        if action is None:
            raise Exception("A timer must have an action supplied.")

        if delay <= 0:
            raise Exception("A timer's delay must be > 0.")

        # The delay.
        self.delay = delay

        # Should we repeat the event?
        self.repeat = repeat

        # The time the next event should occur.
        self.next_event = None

        # The function and its arguments.
        self.function = action
        self.args = args
        self.kwargs = kwargs

        # Did we start the timer?
        self.started = False

        if replaces is not None:
            self.state = replaces.state
        else:
            self.state = TimerState()


    def event(self, ev, x, y, st):

        state = self.state

        if not state.started:
            state.started = True
            state.next_event = st + self.delay

        if state.next_event is None:
            return

        if st < state.next_event:
            renpy.game.interface.timeout(state.next_event - st)
            return

        if not self.repeat:
            state.next_event = None
        else:
            state.next_event = state.next_event + self.delay
            if state.next_event < st:
                state.next_event = st + self.delay

            renpy.game.interface.timeout(state.next_event - st)

        return run(self.function, *self.args, **self.kwargs)


class MouseArea(renpy.display.core.Displayable):

    def __init__(self, hovered=None, unhovered=None, replaces=None, **properties):
        super(MouseArea, self).__init__(**properties)

        self.hovered = hovered
        self.unhovered = unhovered

        # Are we hovered right now?
        self.is_hovered = False

        if replaces is not None:
            self.is_hovered = replaces.is_hovered

        # Taken from the render.
        self.width = 0
        self.height = 0


    def render(self, width, height, st, at):
        self.width = width
        self.height = height

        return Render(width, height)

    def event(self, ev, x, y, st):

        if 0 <= x < self.width and 0 <= y < self.height:
            is_hovered = True
        else:
            is_hovered = False

        if is_hovered and not self.is_hovered:
            self.is_hovered = True

            return run(self.hovered)

        elif not is_hovered and self.is_hovered:
            self.is_hovered = False

            run_unhovered(self.hovered)
            run(self.unhovered)

########NEW FILE########
__FILENAME__ = core
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code for initializing and managing the display
# window.

import renpy.display
import renpy.audio
import renpy.text

import pygame #@UnusedImport

import sys
import os
import time
import cStringIO
import threading

try:
    import android #@UnresolvedImport @UnusedImport
    import android.sound #@UnresolvedImport
except:
    android = None

# Need to be +4, so we don't interfere with FFMPEG's events.
TIMEEVENT = pygame.USEREVENT
PERIODIC = pygame.USEREVENT + 1
JOYEVENT = pygame.USEREVENT + 2
REDRAW = pygame.USEREVENT + 3
EVENTNAME = pygame.USEREVENT + 4

# All events except for TIMEEVENT and REDRAW
ALL_EVENTS = [ i for i in range(0, REDRAW + 1) if i != TIMEEVENT and i != REDRAW ]

# The number of msec between periodic events.
PERIODIC_INTERVAL = 50

# Time management.
time_base = 0.0
time_mult = 1.0

def init_time():
    warp = os.environ.get("RENPY_TIMEWARP", "1.0")

    global time_base
    global time_mult

    time_base = time.time()
    time_mult = float(warp)

def get_time():
    t = time.time()
    return time_base + (t - time_base) * time_mult


def displayable_by_tag(layer, tag):
    """
    Get the displayable on the given layer with the given tag.
    """

    return renpy.game.context().scene_lists.get_displayable_by_tag(layer, tag)

class IgnoreEvent(Exception):
    """
    Exception that is raised when we want to ignore an event, but
    also don't want to return anything.
    """

    pass

class EndInteraction(Exception):
    """
    Exception that can be raised (for example, during the render method of
    a displayable) to end the current interaction immediately.
    """

    def __init__(self, value):
        self.value = value

class absolute(float):
    """
    This represents an absolute float coordinate.
    """
    __slots__ = [ ]


def place(width, height, sw, sh, placement):
    """
    Performs the Ren'Py placement algorithm.

    `width`, `height`
        The width and height of the area the image will be
        placed in.

    `size`
        The size of the image to be placed.

    `placement`
        The tuple returned by Displayable.get_placement().
    """

    xpos, ypos, xanchor, yanchor, xoffset, yoffset, _subpixel = placement

    if xpos is None:
        xpos = 0
    if ypos is None:
        ypos = 0
    if xanchor is None:
        xanchor = 0
    if yanchor is None:
        yanchor = 0
    if xoffset is None:
        xoffset = 0
    if yoffset is None:
        yoffset = 0

    # We need to use type, since isinstance(absolute(0), float).
    if xpos.__class__ is float:
        xpos *= width

    if xanchor.__class__ is float:
        xanchor *= sw

    x = xpos + xoffset - xanchor

    if ypos.__class__ is float:
        ypos *= height

    if yanchor.__class__ is float:
        yanchor *= sh

    y = ypos + yoffset - yanchor

    return x, y

class Displayable(renpy.object.Object):
    """
    The base class for every object in Ren'Py that can be
    displayed to the screen.

    Drawables will be serialized to a savegame file. Therefore, they
    shouldn't store non-serializable things (like pygame surfaces) in
    their fields.
    """

    # Some invariants about method call order:
    #
    # per_interact is called before render.
    # render is called before event.
    #
    # get_placement can be called at any time, so can't
    # assume anything.

    focusable = False
    full_focus_name = None
    role = ''

    # The event we'll pass on to our parent transform.
    transform_event = None

    # Can we change our look in response to transform_events?
    transform_event_responder = False

    # The main displayable, if this displayable is the root of a composite
    # displayable. (This is used by SL to figure out where to add children
    # to.) If None, it is itself.
    _main = None

    # The location the displayable was created at, if known.
    _location = None

    def __init__(self, focus=None, default=False, style='default', **properties):
        self.style = renpy.style.Style(style, properties) # @UndefinedVariable
        self.focus_name = focus
        self.default = default

    def _equals(self, o):
        """
        This is a utility method that can be called by a Displayable's
        __eq__ method, to compare displayables for type and displayable
        component equality.
        """

        if type(self) is not type(o):
            return False

        if self.focus_name != o.focus_name:
            return False

        if self.style != o.style:
            return False

        if self.default != o.default:
            return False

        return True

    def __unicode__(self):
        return self.__class__.__name__

    def __repr__(self):
        return "<{} at {:x}>".format(unicode(self).encode("utf-8"), id(self))

    def find_focusable(self, callback, focus_name):

        focus_name = self.focus_name or focus_name

        if self.focusable:
            callback(self, focus_name)

        for i in self.visit():
            if i is None:
                continue

            i.find_focusable(callback, focus_name)


    def focus(self, default=False):
        """
        Called to indicate that this widget has the focus.
        """

        self.set_style_prefix(self.role + "hover_", True)

        if not default:
            if self.style.hover_sound:
                renpy.audio.music.play(self.style.hover_sound, channel="sound")

    def unfocus(self, default=False):
        """
        Called to indicate that this widget has become unfocused.
        """

        self.set_style_prefix(self.role + "idle_", True)

    def is_focused(self):

        if renpy.display.focus.grab and renpy.display.focus.grab is not self:
            return

        return renpy.game.context().scene_lists.focused is self

    def set_style_prefix(self, prefix, root):
        """
        Called to set the style prefix of this widget and its child
        widgets, if any.

        `root` - True if this is the root of a style tree, False if this
        has been passed on to a child.
        """

        if prefix == self.style.prefix:
            return

        self.style.set_prefix(prefix)
        renpy.display.render.redraw(self, 0)

    def parameterize(self, name, parameters):
        """
        Called to parameterize this. By default, we don't take any
        parameters.
        """

        if parameters:
            raise Exception("Image '%s' can't take parameters '%s'. (Perhaps you got the name wrong?)" %
                            (' '.join(name), ' '.join(parameters)))

        return self

    def render(self, width, height, st, at):
        """
        Called to display this displayable. This is called with width
        and height parameters, which give the largest width and height
        that this drawable can be drawn to without overflowing some
        bounding box. It's also given two times. It returns a Surface
        that is the current image of this drawable.

        @param st: The time since this widget was first shown, in seconds.
        @param at: The time since a similarly named widget was first shown,
        in seconds.
        """

        raise Exception("Render not implemented.")

    def event(self, ev, x, y, st):
        """
        Called to report than an event has occured. Ev is the raw
        pygame event object representing that event. If the event
        involves the mouse, x and y are the translation of the event
        into the coordinates of this displayable. st is the time this
        widget has been shown for.

        @returns A value that should be returned from Interact, or None if
        no value is appropriate.
        """

        return None

    def get_placement(self):
        """
        Returns a style object containing placement information for
        this Displayable. Children are expected to overload this
        to return something more sensible.
        """

        return self.style.get_placement()

    def visit_all(self, callback):
        """
        Calls the callback on this displayable and all children of this
        displayable.
        """

        for d in self.visit():
            if not d:
                continue
            d.visit_all(callback)

        callback(self)

    def visit(self):
        """
        Called to ask the displayable to return a list of its children
        (including children taken from styles). For convenience, this
        list may also include None values.
        """

        return [ ]

    def per_interact(self):
        """
        Called once per widget per interaction.
        """

        return None

    def predict_one(self):
        """
        Called to ask this displayable to call the callback with all
        the images it may want to load.
        """

        return

    def predict_one_action(self):
        """
        Called to ask this displayable to cause image prediction
        to occur for images that may be loaded by its actions.
        """

        return

    def place(self, dest, x, y, width, height, surf, main=True):
        """
        This places a render (which must be of this displayable)
        within a bounding area. Returns an (x, y) tuple giving the location
        the displayable was placed at.

        `dest`
            If not None, the `surf` will be blitted to `dest` at the
            computed coordinates.

        `x`, `y`, `width`, `height`
            The bounding area.

        `surf`
            The render to place.

        `main`
            This is passed to Render.blit().
        """

        placement = self.get_placement()
        subpixel = placement[6]

        xpos, ypos = place(width, height, surf.width, surf.height, placement)

        xpos += x
        ypos += y

        pos = (xpos, ypos)

        if dest is not None:
            if subpixel:
                dest.subpixel_blit(surf, pos, main, main, None)
            else:
                dest.blit(surf, pos, main, main, None)

        return pos

    def set_transform_event(self, event):
        """
        Sets the transform event of this displayable to event.
        """

        if event == self.transform_event:
            return

        self.transform_event = event
        if self.transform_event_responder:
            renpy.display.render.redraw(self, 0)

    def _hide(self, st, at, kind):
        """
        Returns None if this displayable is ready to be hidden, or
        a replacement displayable if it doesn't want to be hidden
        quite yet. Kind is either "hide" or "replaced".
        """

        return None

    def _show(self):
        """
        Called when the displayable is added to a scene list.
        """

    def _get_parameterized(self):
        """
        If this is a ImageReference to a parameterized image, return
        the get_parameterized() of the parameterized image. Otherwise,
        return this displayable.
        """

        return self

    def _change_transform_child(self, child):
        """
        If this is a transform, makes a copy of the transform and sets
        the child of the innermost transform to this. Otherwise,
        simply returns child.
        """

        return child

    def _clear(self):
        """
        Clears out the children of this displayable, if any.
        """

        return



class SceneListEntry(renpy.object.Object):
    """
    Represents a scene list entry. Since this was replacing a tuple,
    it should be treated as immutable after its initial creation.
    """

    def __init__(self, tag, zorder, show_time, animation_time, displayable, name):
        self.tag = tag
        self.zorder = zorder
        self.show_time = show_time
        self.animation_time = animation_time
        self.displayable = displayable
        self.name = name

    def __iter__(self):
        return iter((self.tag, self.zorder, self.show_time, self.animation_time, self.displayable))

    def __getitem__(self, index):
        return (self.tag, self.zorder, self.show_time, self.animation_time, self.displayable)[index]

    def __repr__(self):
        return "<SLE: %r %r %r>" % (self.tag, self.name, self.displayable)

    def copy(self):
        return SceneListEntry(
            self.tag,
            self.zorder,
            self.show_time,
            self.animation_time,
            self.displayable,
            self.name)

    def update_time(self, time):

        rv = self

        if self.show_time is None or self.animation_time is None:
            rv = self.copy()
            rv.show_time = rv.show_time or time
            rv.animation_time = rv.animation_time or time

        return rv


class SceneLists(renpy.object.Object):
    """
    This stores the current scene lists that are being used to display
    things to the user.
    """

    __version__ = 6

    def after_setstate(self):
        for i in renpy.config.layers + renpy.config.top_layers:
            if i not in self.layers:
                self.layers[i] = [ ]
                self.at_list[i] = { }
                self.layer_at_list[i] = (None, [ ])

    def after_upgrade(self, version):

        if version < 1:

            self.at_list = { }
            self.layer_at_list = { }

            for i in renpy.config.layers + renpy.config.top_layers:
                self.at_list[i] = { }
                self.layer_at_list[i] = (None, [ ])

        if version < 3:
            self.shown_window = False

        if version < 4:
            for k in self.layers:
                self.layers[k] = [ SceneListEntry(*(i + (None,)) ) for i in self.layers[k] ]

            self.additional_transient = [ ]

        if version < 5:
            self.drag_group = None

        if version < 6:
            self.shown = self.image_predict_info

    def __init__(self, oldsl, shown):

        super(SceneLists, self).__init__()

        # Has a window been shown as part of these scene lists?
        self.shown_window = False

        # A map from layer name -> list(SceneListEntry)
        self.layers = { }

        # A map from layer name -> tag -> at_list associated with that tag.
        self.at_list = { }

        # A map from layer to (star time, at_list), where the at list has
        # been applied to the layer as a whole.
        self.layer_at_list = { }

        # The current shown images,
        self.shown = shown

        # A list of (layer, tag) pairs that are considered to be
        # transient.
        self.additional_transient = [ ]

        # Either None, or a DragGroup that's used as the default for
        # drags with names.
        self.drag_group = None

        if oldsl:

            for i in renpy.config.layers + renpy.config.top_layers:

                try:
                    self.layers[i] = oldsl.layers[i][:]
                except KeyError:
                    self.layers[i] = [ ]

                if i in oldsl.at_list:
                    self.at_list[i] = oldsl.at_list[i].copy()
                    self.layer_at_list[i] = oldsl.layer_at_list[i]
                else:
                    self.at_list[i] = { }
                    self.layer_at_list[i] = (None, [ ])

            for i in renpy.config.overlay_layers:
                self.clear(i)

            self.replace_transient()

            self.focused = None

            self.drag_group = oldsl.drag_group

        else:
            for i in renpy.config.layers + renpy.config.top_layers:
                self.layers[i] = [ ]
                self.at_list[i] = { }
                self.layer_at_list[i] = (None, [ ])

            self.music = None
            self.focused = None

    def replace_transient(self):
        """
        Replaces the contents of the transient display list with
        a copy of the master display list. This is used after a
        scene is displayed to get rid of transitions and interface
        elements.
        """

        for i in renpy.config.transient_layers:
            self.clear(i, True)

        for layer, tag in self.additional_transient:
            self.remove(layer, tag)

        self.additional_transient = [ ]

    def transient_is_empty(self):
        """
        This returns True if all transient layers are empty. This is
        used by the rollback code, as we can't start a new rollback
        if there is something in a transient layer (as things in the
        transient layer may contain objects that cannot be pickled,
        like lambdas.)
        """

        for i in renpy.config.transient_layers:
            if self.layers[i]:
                return False

        return True

    def transform_state(self, old_thing, new_thing):
        """
        If the old thing is a transform, then move the state of that transform
        to the new thing.
        """

        if old_thing is None:
            return new_thing

        # Don't bother wrapping screens, as they can't be transformed.
        if isinstance(new_thing, renpy.display.screen.ScreenDisplayable):
            return new_thing

        old_transform = old_thing._get_parameterized()
        if not isinstance(old_transform, renpy.display.motion.Transform):
            return new_thing

        new_transform = new_thing._get_parameterized()
        if not isinstance(new_transform, renpy.display.motion.Transform):
            new_thing = new_transform = renpy.display.motion.Transform(child=new_thing)

        new_transform.take_state(old_transform)
        return new_thing


    def find_index(self, layer, tag, zorder, behind):
        """
        This finds the spot in the named layer where we should insert the
        displayable. It returns two things: an index at which the new thing
        should be added, and an index at which the old thing should be hidden.
        (Note that the indexes are relative to the current state of the list,
        which may change on an add or remove.)
        """

        add_index = None
        remove_index = None


        for i, sle in enumerate(self.layers[layer]):

            if add_index is None:

                if sle.zorder == zorder:
                    if sle.tag and (sle.tag == tag or sle.tag in behind):
                        add_index = i

                elif sle.zorder > zorder:
                    add_index = i


            if remove_index is None:
                if (sle.tag and sle.tag == tag) or sle.displayable == tag:
                    remove_index = i


        if add_index is None:
            add_index = len(self.layers[layer])

        return add_index, remove_index


    def add(self,
            layer,
            thing,
            key=None,
            zorder=0,
            behind=[ ],
            at_list=[ ],
            name=None,
            atl=None,
            default_transform=None,
            transient=False):
        """
        Adds something to this scene list. Some of these names are quite a bit
        out of date.

        `thing` - The displayable to add.

        `key` - A string giving the tag associated with this thing.

        `zorder` - Where to place this thing in the zorder, an integer
        A greater value means closer to the user.

        `behind` - A list of tags to place the thing behind.

        `at_list` - The at_list associated with this
        displayable. Counterintunitively, this is not actually
        applied, but merely stored for future use.

        `name` - The full name of the image being displayed. This is used for
        image lookup.

        `atl` - If not None, an atl block applied to the thing. (This actually is
        applied here.)

        `default_transform` - The default transform that is used to initialized
        the values in the other transforms.
        """

        if not isinstance(thing, Displayable):
            raise Exception("Attempting to show something that isn't a displayable:" + repr(thing))

        if layer not in self.layers:
            raise Exception("Trying to add something to non-existent layer '%s'." % layer)

        if key:
            self.remove_hide_replaced(layer, key)
            self.at_list[layer][key] = at_list

        if key and name:
            self.shown.predict_show(layer, name)

        if transient:
            self.additional_transient.append((layer, key))

        l = self.layers[layer]

        if atl:
            thing = renpy.display.motion.ATLTransform(atl, child=thing)

        add_index, remove_index = self.find_index(layer, key, zorder, behind)

        at = None
        st = None

        if remove_index is not None:
            sle = l[remove_index]
            at = sle.animation_time
            old = sle.displayable

            if (not atl and
                not at_list and
                renpy.config.keep_running_transform and
                isinstance(old, renpy.display.motion.Transform)):

                thing = sle.displayable._change_transform_child(thing)
            else:
                thing = self.transform_state(l[remove_index].displayable, thing)

            thing.set_transform_event("replace")
            thing._show()

        else:

            if not isinstance(thing, renpy.display.motion.Transform):
                thing = self.transform_state(default_transform, thing)

            thing.set_transform_event("show")
            thing._show()

        sle = SceneListEntry(key, zorder, st, at, thing, name)
        l.insert(add_index, sle)

        if remove_index is not None:
            if add_index <= remove_index:
                remove_index += 1

            self.hide_or_replace(layer, remove_index, "replaced")

    def hide_or_replace(self, layer, index, prefix):
        """
        Hides or replaces the scene list entry at the given
        index. `prefix` is a prefix that is used if the entry
        decides it doesn't want to be hidden quite yet.
        """

        if index is None:
            return

        l = self.layers[layer]
        oldsle = l[index]

        now = get_time()

        st = oldsle.show_time or now
        at = oldsle.animation_time or now

        if oldsle.tag:

            d = oldsle.displayable._hide(now - st, now - at, prefix)

            # _hide can mutate the layers, so we need to recompute
            # index.
            index = l.index(oldsle)

            if d is not None:

                sle = SceneListEntry(
                    prefix + "$" + oldsle.tag,
                    oldsle.zorder,
                    st,
                    at,
                    d,
                    None)

                l[index] = sle

                return

        l.pop(index)

    def get_all_displayables(self):
        """
        Gets all displayables reachable from this scene list.
        """

        rv = [ ]
        for l in self.layers.itervalues():
            for sle in l:
                rv.append(sle.displayable)

        return rv

    def remove_above(self, layer, thing):
        """
        Removes everything on the layer that is closer to the user
        than thing, which may be either a tag or a displayable. Thing must
        be displayed, or everything will be removed.
        """

        for i in reversed(xrange(len(self.layers[layer]))):

            sle = self.layers[layer][i]

            if thing:
                if sle.tag == thing or sle.displayable == thing:
                    break

            if sle.tag and "$" in sle.tag:
                continue

            self.hide_or_replace(layer, i, "hide")

    def remove(self, layer, thing):
        """
        Thing is either a key or a displayable. This iterates through the
        named layer, searching for entries matching the thing.
        When they are found, they are removed from the displaylist.

        It's not an error to remove something that isn't in the layer in
        the first place.
        """

        if layer not in self.layers:
            raise Exception("Trying to remove something from non-existent layer '%s'." % layer)

        _add_index, remove_index = self.find_index(layer, thing, 0, [ ])

        if remove_index is not None:
            tag = self.layers[layer][remove_index].tag

            if tag:
                self.shown.predict_hide(layer, (tag,))
                self.at_list[layer].pop(tag, None)

            self.hide_or_replace(layer, remove_index, "hide")

    def clear(self, layer, hide=False):
        """
        Clears the named layer, making it empty.

        If hide is True, then objects are hidden. Otherwise, they are
        totally wiped out.
        """

        if not layer in self.layers:
            return

        if not hide:
            self.layers[layer] = [ ]

        else:

            # Have to iterate in reverse order, since otherwise
            # the indexes might change.
            for i in reversed(xrange(len(self.layers[layer]))):
                self.hide_or_replace(layer, i, hide)

        self.at_list[layer].clear()
        self.shown.predict_scene(layer)
        self.layer_at_list[layer] = (None, [ ])

    def set_layer_at_list(self, layer, at_list):
        self.layer_at_list[layer] = (None, list(at_list))

    def set_times(self, time):
        """
        This finds entries with a time of None, and replaces that
        time with the given time.
        """

        for l, (t, list) in self.layer_at_list.items(): #@ReservedAssignment
            self.layer_at_list[l] = (t or time, list)

        for l, ll in self.layers.iteritems():
            self.layers[l] = [ i.update_time(time) for i in ll ]

    def showing(self, layer, name):
        """
        Returns true if something with the prefix of the given name
        is found in the scene list.
        """

        return self.shown.showing(layer, name)

    def make_layer(self, layer, properties):
        """
        Creates a Fixed with the given layer name and scene_list.
        """

        rv = renpy.display.layout.MultiBox(layout='fixed', focus=layer, **properties)
        rv.append_scene_list(self.layers[layer])
        rv.layer_name = layer

        time, at_list = self.layer_at_list[layer]

        if at_list:

            for a in at_list:

                if isinstance(a, renpy.display.motion.Transform):
                    rv = a(child=rv)
                else:
                    rv = a(rv)

            f = renpy.display.layout.MultiBox(layout='fixed')
            f.add(rv, time, time)
            f.layer_name = layer

            rv = f


        return rv

    def remove_hide_replaced(self, layer, tag):
        """
        Removes things that are hiding or replaced, that have the given
        tag.
        """

        hide_tag = "hide$" + tag
        replaced_tag = "replaced$" + tag

        l = self.layers[layer]
        self.layers[layer] = [ i for i in l if i.tag != hide_tag and i.tag != replaced_tag ]

    def remove_hidden(self):
        """
        Goes through all of the layers, and removes things that are
        hidden and are no longer being kept alive by their hide
        methods.
        """

        now = get_time()

        for l in self.layers:
            newl = [ ]

            for sle in self.layers[l]:

                if sle.tag:

                    if sle.tag.startswith("hide$"):
                        d = sle.displayable._hide(now - sle.show_time, now - sle.animation_time, "hide")
                        if not d:
                            continue

                    elif sle.tag.startswith("replaced$"):
                        d = sle.displayable._hide(now - sle.show_time, now - sle.animation_time, "replaced")
                        if not d:
                            continue

                newl.append(sle)

            self.layers[l] = newl

    def get_displayable_by_tag(self, layer, tag):
        """
        Returns the displayable on the layer with the given tag, or None
        if no such displayable exists. Note that this will usually return
        a Transform.
        """

        if layer not in self.layers:
            raise Exception("Unknown layer %r." % layer)

        for sle in self.layers[layer]:
            if sle.tag == tag:
                return sle.displayable

        return None

    def get_displayable_by_name(self, layer, name):
        """
        Returns the displayable on the layer with the given name, or None
        if no such displayable exists. Note that this will usually return
        a Transform.
        """

        if layer not in self.layers:
            raise Exception("Unknown layer %r." % layer)

        for sle in self.layers[layer]:
            if sle.name == name:
                return sle.displayable

        return None

    def get_image_bounds(self, layer, tag, width, height):
        """
        Implements renpy.get_image_bounds().
        """

        if layer not in self.layers:
            raise Exception("Unknown layer %r." % layer)

        for sle in self.layers[layer]:
            if sle.tag == tag:
                break
        else:
            return None

        now = get_time()

        if sle.show_time is not None:
            st = now - sle.show_time
        else:
            st = 0

        if sle.animation_time is not None:
            at = now - sle.animation_time
        else:
            at = 0

        surf = renpy.display.render.render(sle.displayable, width, height, st, at)

        sw = surf.width
        sh = surf.height

        x, y = place(width, height, sw, sh, sle.displayable.get_placement())

        surf.kill()

        return (x, y, sw, sh)


def scene_lists(index=-1):
    """
    Returns either the current scenelists object, or the one for the
    context at the given index.
    """

    return renpy.game.context(index).scene_lists


class MouseMove(object):
    """
    This contains information about the current mouse move.
    """

    def __init__(self, x, y, duration):
        self.start = get_time()

        if duration is not None:
            self.duration = duration
        else:
            self.duration = 0

        self.start_x, self.start_y = renpy.display.draw.get_mouse_pos()

        self.end_x = x
        self.end_y = y

    def perform(self):
        """
        Performs the mouse move. Returns True if this should be called
        again, or False if the move has finished.
        """

        elapsed = get_time() - self.start

        if elapsed >= self.duration:
            renpy.display.draw.set_mouse_pos(self.end_x, self.end_y)
            return False

        done = 1.0 * elapsed / self.duration

        x = int(self.start_x + done * (self.end_x - self.start_x))
        y = int(self.start_y + done * (self.end_y - self.start_y))

        renpy.display.draw.set_mouse_pos(x, y)
        return True

def get_safe_mode():
    """
    Returns true if we should go into safe mode.
    """

    if not renpy.first_utter_start:
        return False


    try:
        if renpy.linux:
            if (pygame.key.get_mods() & pygame.KMOD_SHIFT):
                return True
            else:
                return False

        if renpy.windows:
            import ctypes

            VK_SHIFT      = 0x10

            ctypes.windll.user32.GetKeyState.restype = ctypes.c_ushort
            if ctypes.windll.user32.GetKeyState(VK_SHIFT) & 0x8000:
                return True
            else:
                return False

        # We don't need safe mode on mac or android, as those platforms
        # should always have OpenGL 2 or OpenGL ES 2.
        return False

    except:
        return False

class Interface(object):
    """
    This represents the user interface that interacts with the user.
    It manages the Display objects that display things to the user, and
    also handles accepting and responding to user input.

    @ivar display: The display that we used to display the screen.

    @ivar profile_time: The time of the last profiling.

    @ivar screenshot: A screenshot, or None if no screenshot has been
    taken.

    @ivar old_scene: The last thing that was displayed to the screen.

    @ivar transition: A map from layer name to the transition that will
    be applied the next time interact restarts.

    @ivar transition_time: A map from layer name to the time the transition
    involving that layer started.

    @ivar transition_from: A map from layer name to the scene that we're
    transitioning from on that layer.

    @ivar suppress_transition: If True, then the next transition will not
    happen.

    @ivar force_redraw: If True, a redraw is forced.

    @ivar restart_interaction: If True, the current interaction will
    be restarted.

    @ivar pushed_event: If not None, an event that was pushed back
    onto the stack.

    @ivar mouse: The name of the mouse cursor to use during the current
    interaction.

    @ivar ticks: The number of 20hz ticks.

    @ivar frame_time: The time at which we began drawing this frame.

    @ivar interact_time: The time of the start of the first frame of the current interact_core.

    @ivar time_event: A singleton ignored event.

    @ivar event_time: The time of the current event.

    @ivar timeout_time: The time at which the timeout will occur.
    """

    def __init__(self):

        # PNG data and the surface for the current file screenshot.
        self.screenshot = None
        self.screenshot_surface = None

        self.old_scene = { }
        self.transition = { }
        self.ongoing_transition = { }
        self.transition_time = { }
        self.transition_from = { }
        self.suppress_transition = False
        self.quick_quit = False
        self.force_redraw = False
        self.restart_interaction = False
        self.pushed_event = None
        self.ticks = 0
        self.mouse = 'default'
        self.timeout_time = None
        self.last_event = None
        self.current_context = None
        self.roll_forward = None

        # Things to be preloaded.
        self.preloads = [ ]

        # The time at which this draw occurs.
        self.frame_time = 0

        # The time when this interaction occured.
        self.interact_time = None

        # The time we last tried to quit.
        self.quit_time = 0

        # Are we currently processing the quit event?
        self.in_quit_event = False

        self.time_event = pygame.event.Event(TIMEEVENT)
        self.redraw_event = pygame.event.Event(REDRAW)

        # Are we focused?
        self.focused = True

        # Properties for each layer.
        self.layer_properties = { }

        # Have we shown the window this interaction?
        self.shown_window = False

        # Are we in fullscren mode?
        self.fullscreen = False

        # Should we ignore the rest of the current touch? Used to ignore the
        # rest of a mousepress after a longpress occurs.
        self.ignore_touch = False

        for layer in renpy.config.layers + renpy.config.top_layers:
            if layer in renpy.config.layer_clipping:
                x, y, w, h = renpy.config.layer_clipping[layer]
                self.layer_properties[layer] = dict(
                    xpos = x,
                    xanchor = 0,
                    ypos = y,
                    yanchor = 0,
                    xmaximum = w,
                    ymaximum = h,
                    xminimum = w,
                    yminimum = h,
                    clipping = True,
                    )

            else:
                self.layer_properties[layer] = dict()


        # A stack giving the values of self.transition and self.transition_time
        # for contexts outside the current one. This is used to restore those
        # in the case where nothing has changed in the new context.
        self.transition_info_stack = [ ]

        # The time when the event was dispatched.
        self.event_time = 0

        # The time we saw the last mouse event.
        self.mouse_event_time = None

        # Should we show the mouse?
        self.show_mouse = True

        # Should we reset the display?
        self.display_reset = False

        # The last size we were resized to. This lets us debounce the
        # VIDEORESIZE event.
        self.last_resize = None

        # The thread that can do display operations.
        self.thread = threading.current_thread()

        # Ensure that we kill off the presplash.
        renpy.display.presplash.end()

        # Initialize pygame.
        if pygame.version.vernum < (1, 8, 1):
            raise Exception("Ren'Py requires pygame 1.8.1 to run.")

        try:
            import pygame.macosx as macosx
            macosx.init() #@UndefinedVariable
        except:
            pass

        try:
            macosx.Video_AutoInit() #@UndefinedVariable
        except:
            pass

        # pygame.font.init()
        renpy.audio.audio.init()
        renpy.display.joystick.init()
        pygame.display.init()

        # Init timing.
        init_time()
        self.profile_time = get_time()
        self.mouse_event_time = get_time()

        # The current window caption.
        self.window_caption = None

        renpy.game.interface = self
        renpy.display.interface = self

        # Are we in safe mode, from holding down shift at start?
        self.safe_mode = get_safe_mode()

        # Setup the video mode.
        self.set_mode()

        # Double check, since at least on Linux, we can't set safe_mode until
        # the window maps.
        self.safe_mode = get_safe_mode()

        # Load the image fonts.
        renpy.text.font.load_image_fonts()

        # Setup the android keymap.
        if android is not None:
            android.map_key(android.KEYCODE_BACK, pygame.K_PAGEUP)
            android.map_key(android.KEYCODE_MENU, pygame.K_ESCAPE)

        # Setup periodic event.
        pygame.time.set_timer(PERIODIC, PERIODIC_INTERVAL)

        # Don't grab the screen.
        pygame.event.set_grab(False)

        # Do we need a background screenshot?
        self.bgscreenshot_needed = False

        # Event used to signal background screenshot taken.
        self.bgscreenshot_event = threading.Event()

        # The background screenshot surface.
        self.bgscreenshot_surface = None

        # Mouse move. If not None, information about the current mouse
        # move.
        self.mouse_move = None

        renpy.display.emulator.init_emulator()


    def post_init(self):
        # Setup.

        # Needed for Unity.
        wmclass = renpy.config.save_directory or os.path.basename(sys.argv[0])
        os.environ['SDL_VIDEO_X11_WMCLASS'] = wmclass

        self.set_window_caption(force=True)
        self.set_icon()

        if renpy.config.key_repeat is not None:
            delay, repeat_delay = renpy.config.key_repeat
            pygame.key.set_repeat(int(1000 * delay), int(1000 * repeat_delay))

    def set_icon(self):
        """
        This is called to set up the window icon.
        """

        # Window icon.
        icon = renpy.config.window_icon

        if renpy.windows and renpy.config.windows_icon:
            icon = renpy.config.windows_icon

        if icon:

            im = renpy.display.scale.image_load_unscaled(
                renpy.loader.load(icon),
                icon,
                convert=False,
                )

            # Convert the aspect ratio to be square.
            iw, ih = im.get_size()
            imax = max(iw, ih)
            square_im = renpy.display.pgrender.surface_unscaled((imax, imax), True)
            square_im.blit(im, ( (imax-iw)/2, (imax-ih)/2 ))
            im = square_im

            if renpy.windows and im.get_size() != (32, 32):
                im = renpy.display.scale.real_smoothscale(im, (32, 32))

            pygame.display.set_icon(im)


    def set_window_caption(self, force=False):
        caption = renpy.config.window_title + renpy.store._window_subtitle
        if not force and caption == self.window_caption:
            return

        self.window_caption = caption
        pygame.display.set_caption(caption.encode("utf-8"))

    def iconify(self):
        pygame.display.iconify()

    def get_draw_constructors(self):
        """
        Figures out the list of draw constructors to try.
        """

        renderer = renpy.game.preferences.renderer
        renderer = os.environ.get("RENPY_RENDERER", renderer)

        if self.safe_mode:
            renderer = "sw"

        renpy.config.renderer = renderer

        if renderer == "auto":
            if renpy.windows:
                renderers = [ "gl", "angle", "sw" ]
            else:
                renderers = [ "gl", "sw" ]
        else:
            renderers = [ renderer, "sw" ]

        draw_objects = { }

        def make_draw(name, mod, cls, *args):
            if name not in renderers:
                return False

            try:
                __import__(mod)
                module = sys.modules[mod]
                draw_class = getattr(module, cls)
                draw_objects[name] = draw_class(*args)
                return True

            except:
                renpy.display.log.write("Couldn't import {0} renderer:".format(name))
                renpy.display.log.exception()

                return False

        if renpy.windows:
            has_angle = make_draw("angle", "renpy.angle.gldraw", "GLDraw")
        else:
            has_angle = False

        make_draw("gl", "renpy.gl.gldraw", "GLDraw", not has_angle)
        make_draw("sw", "renpy.display.swdraw", "SWDraw")

        rv = [ ]

        def append_draw(name):
            if name in draw_objects:
                rv.append(draw_objects[name])
            else:
                renpy.display.log.write("Unknown renderer: {0}".format(name))

        for i in renderers:
            append_draw(i)

        return rv


    def kill_textures(self):
        renpy.display.render.free_memory()
        renpy.text.text.layout_cache_clear()

    def kill_textures_and_surfaces(self):
        """
        Kill all textures and surfaces that are loaded.
        """

        self.kill_textures()

        renpy.display.im.cache.clear()
        renpy.display.module.bo_cache = None

    def set_mode(self, physical_size=None):
        """
        This sets the video mode. It also picks the draw object.
        """

        # Ensure that we kill off the movie when changing screen res.
        if renpy.display.draw and renpy.display.draw.info["renderer"] == "sw":
            renpy.display.video.movie_stop(clear=False)

        if self.display_reset:
            renpy.display.draw.deinit()

            if renpy.display.draw.info["renderer"] == "angle":
                renpy.display.draw.quit()

                # This is necessary to fix a bug with restoring a window from
                # minimized state on windows.
                pygame.display.quit()

            renpy.display.render.free_memory()
            renpy.display.im.cache.clear()
            renpy.text.text.layout_cache_clear()

            renpy.display.module.bo_cache = None

            self.kill_textures_and_surfaces()

        self.display_reset = False

        virtual_size = (renpy.config.screen_width, renpy.config.screen_height)

        if physical_size is None:
            if renpy.android or renpy.game.preferences.physical_size is None: #@UndefinedVariable
                physical_size = (renpy.config.screen_width, renpy.config.screen_height)
            else:
                physical_size = renpy.game.preferences.physical_size

        # Setup screen.
        fullscreen = renpy.game.preferences.fullscreen

        # If we're in fullscreen mode, and changing to another mode, go to
        # windowed mode first.
        s = pygame.display.get_surface()
        if s and (s.get_flags() & pygame.FULLSCREEN):
            fullscreen = False

        old_fullscreen = self.fullscreen
        self.fullscreen = fullscreen

        if os.environ.get('RENPY_DISABLE_FULLSCREEN', False):
            fullscreen = False
            self.fullscreen = renpy.game.preferences.fullscreen

        if renpy.display.draw:
            draws = [ renpy.display.draw ]
        else:
            draws = self.get_draw_constructors()

        for draw in draws:
            if draw.set_mode(virtual_size, physical_size, fullscreen):
                renpy.display.draw = draw
                break
            else:
                # pygame.display.quit()
                pass
        else:
            # Ensure we don't get stuck in fullscreen.
            renpy.game.preferences.fullscreen = False
            raise Exception("Could not set video mode.")

        # Save the video size.
        if renpy.config.save_physical_size and not fullscreen and not old_fullscreen:
            renpy.game.preferences.physical_size = renpy.display.draw.get_physical_size()

        if android:
            android.init()

        # We need to redraw the (now blank) screen.
        self.force_redraw = True

        # Assume we have focus until told otherwise.
        self.focused = True

        # Assume we're not minimized.
        self.minimized = False

        # Force an interaction restart.
        self.restart_interaction = True

        # True if we're doing a one-time profile.
        self.profile_once = False


    def draw_screen(self, root_widget, fullscreen_video, draw):

        surftree = renpy.display.render.render_screen(
            root_widget,
            renpy.config.screen_width,
            renpy.config.screen_height,
            )

        if draw:
            renpy.display.draw.draw_screen(surftree, fullscreen_video)

        renpy.display.render.mark_sweep()
        renpy.display.focus.take_focuses()

        self.surftree = surftree
        self.fullscreen_video = fullscreen_video


    def take_screenshot(self, scale, background=False):
        """
        This takes a screenshot of the current screen, and stores it so
        that it can gotten using get_screenshot()

        `background`
           If true, we're in a background thread. So queue the request
           until it can be handled by the main thread.
        """

        if background:
            self.bgscreenshot_event.clear()
            self.bgscreenshot_needed = True

            if not self.bgscreenshot_event.wait(1.0):
                raise Exception("Screenshot timed out.")

            window = self.bgscreenshot_surface
            self.bgscreenshot_surface = None

        else:

            window = renpy.display.draw.screenshot(self.surftree, self.fullscreen_video)

        surf = renpy.display.pgrender.copy_surface(window, True)
        surf = renpy.display.scale.smoothscale(surf, scale)
        surf = surf.convert()

        renpy.display.render.mutated_surface(surf)

        self.screenshot_surface = surf

        sio = cStringIO.StringIO()
        renpy.display.module.save_png(surf, sio, 0)
        self.screenshot = sio.getvalue()
        sio.close()


    def check_background_screenshot(self):
        """
        Handles requests for a background screenshot.
        """

        if self.bgscreenshot_needed:
            self.bgscreenshot_needed = False
            self.bgscreenshot_surface = renpy.display.draw.screenshot(self.surftree, self.fullscreen_video)
            self.bgscreenshot_event.set()

    def get_screenshot(self):
        """
        Gets the current screenshot, as a string. Returns None if there isn't
        a current screenshot.
        """

        rv = self.screenshot

        if not rv:
            self.take_screenshot(
                (renpy.config.thumbnail_width, renpy.config.thumbnail_height),
                background=(threading.current_thread() is not self.thread),
                )
            rv = self.screenshot
            self.lose_screenshot()

        return rv


    def lose_screenshot(self):
        """
        This deallocates the saved screenshot.
        """

        self.screenshot = None
        self.screenshot_surface = None


    def save_screenshot(self, filename):
        """
        Saves a full-size screenshot in the given filename.
        """

        window = renpy.display.draw.screenshot(self.surftree, self.fullscreen_video)

        if renpy.config.screenshot_crop:
            window = window.subsurface(renpy.config.screenshot_crop)

        try:
            renpy.display.scale.image_save_unscaled(window, filename)
        except:
            if renpy.config.debug:
                raise
            pass



    def show_window(self):

        if not renpy.store._window:
            return

        if not renpy.game.preferences.show_empty_window:
            return

        if renpy.game.context().scene_lists.shown_window:
            return

        if renpy.config.empty_window:
            renpy.config.empty_window()

    def do_with(self, trans, paired, clear=False):

        if renpy.config.with_callback:
            trans = renpy.config.with_callback(trans, paired)

        if (not trans) or self.suppress_transition:
            self.with_none()
            return False
        else:
            self.set_transition(trans)
            return self.interact(trans_pause=True,
                                 suppress_overlay=not renpy.config.overlay_during_with,
                                 mouse='with',
                                 clear=clear)

    def with_none(self):
        """
        Implements the with None command, which sets the scene we will
        be transitioning from.
        """

        renpy.game.context().say_attributes = None

        # Show the window, if that's necessary.
        self.show_window()

        # Compute the overlay.
        self.compute_overlay()

        scene_lists = renpy.game.context().scene_lists

        # Compute the scene.
        self.old_scene = self.compute_scene(scene_lists)

        # Get rid of transient things.

        for i in renpy.config.overlay_layers:
            scene_lists.clear(i)

        scene_lists.replace_transient()
        scene_lists.shown_window = False


    def set_transition(self, transition, layer=None, force=False):
        """
        Sets the transition that will be performed as part of the next
        interaction.
        """

        if self.suppress_transition and not force:
            return

        if transition is None:
            self.transition.pop(layer, None)
        else:
            self.transition[layer] = transition


    def event_peek(self):
        """
        This peeks the next event. It returns None if no event exists.
        """

        if self.pushed_event:
            return self.pushed_event

        ev = pygame.event.poll()

        if ev.type == pygame.NOEVENT:
            # Seems to prevent the CPU from speeding up.
            renpy.display.draw.event_peek_sleep()
            return None

        self.pushed_event = ev

        return ev

    def event_poll(self):
        """
        Called to busy-wait for an event while we're waiting to
        redraw a frame.
        """

        if self.pushed_event:
            rv = self.pushed_event
            self.pushed_event = None
        else:
            rv = pygame.event.poll()

        self.last_event = rv

        return rv


    def event_wait(self):
        """
        This is in its own function so that we can track in the
        profiler how much time is spent in interact.
        """

        if self.pushed_event:
            rv = self.pushed_event
            self.pushed_event = None
            self.last_event = rv
            return rv

        self.check_background_screenshot()

        ev = pygame.event.wait()
        self.last_event = ev

        return ev

    def compute_overlay(self):

        if renpy.store.suppress_overlay:
            return

        # Figure out what the overlay layer should look like.
        renpy.ui.layer("overlay")

        for i in renpy.config.overlay_functions:
            i()

        if renpy.game.context().scene_lists.shown_window:
            for i in renpy.config.window_overlay_functions:
                i()

        renpy.ui.close()


    def compute_scene(self, scene_lists):
        """
        This converts scene lists into a dictionary mapping layer
        name to a Fixed containing that layer.
        """

        rv = { }

        for layer in renpy.config.layers + renpy.config.top_layers:
            rv[layer] = scene_lists.make_layer(layer, self.layer_properties[layer])

        root = renpy.display.layout.MultiBox(layout='fixed')
        root.layers = { }

        for layer in renpy.config.layers:
            root.layers[layer] = rv[layer]
            root.add(rv[layer])
        rv[None] = root

        return rv


    def quit_event(self):
        """
        This is called to handle the user invoking a quit.
        """

        if self.quit_time > (time.time() - .75):
            raise renpy.game.QuitException()

        if self.in_quit_event:
            raise renpy.game.QuitException()

        if renpy.config.quit_action is not None:
            self.quit_time = time.time()

            # Make the screen more suitable for interactions.
            renpy.exports.movie_stop(only_fullscreen=True)
            renpy.store.mouse_visible = True

            try:
                self.in_quit_event = True
                renpy.display.behavior.run(renpy.config.quit_action)
            finally:
                self.in_quit_event = False

        else:
            raise renpy.game.QuitException()


    def get_mouse_info(self):
        # Figure out if the mouse visibility algorithm is hiding the mouse.
        if self.mouse_event_time + renpy.config.mouse_hide_time < renpy.display.core.get_time():
            visible = False
        else:
            visible = renpy.store.mouse_visible and (not renpy.game.less_mouse)

        visible = visible and self.show_mouse

        # If not visible, hide the mouse.
        if not visible:
            return False, 0, 0, None

        # Deal with a hardware mouse, the easy way.
        if not renpy.config.mouse:
            return True, 0, 0, None

        # Deal with the mouse going offscreen.
        if not self.focused:
            return False, 0, 0, None

        mouse_kind = renpy.display.focus.get_mouse() or self.mouse

        # Figure out the mouse animation.
        if mouse_kind in renpy.config.mouse:
            anim = renpy.config.mouse[mouse_kind]
        else:
            anim = renpy.config.mouse[getattr(renpy.store, 'default_mouse', 'default')]

        img, x, y = anim[self.ticks % len(anim)]
        tex = renpy.display.im.load_image(img)

        return False, x, y, tex

    def set_mouse_pos(self, x, y, duration):
        """
        Sets the mouse position. Duration can be a number of seconds or
        None.
        """

        self.mouse_move = MouseMove(x, y, duration)
        self.force_redraw = True

    def drawn_since(self, seconds_ago):
        """
        Returns true if the screen has been drawn in the last `seconds_ago`,
        and false otherwise.
        """

        return (get_time() - self.frame_time) <= seconds_ago

    def android_check_suspend(self):

        if android.check_pause():

            android.sound.pause_all()

            pygame.time.set_timer(PERIODIC, 0)
            pygame.time.set_timer(REDRAW, 0)
            pygame.time.set_timer(TIMEEVENT, 0)

            # The game has to be saved.
            renpy.loadsave.save("_reload-1")

            # So does the persistent data.
            renpy.persistent.update(True)

            android.wait_for_resume()

            # Since we came back to life, we can get rid of the
            # auto-reload.
            renpy.loadsave.unlink_save("_reload-1")

            pygame.time.set_timer(PERIODIC, PERIODIC_INTERVAL)

            android.sound.unpause_all()

    def iconified(self):
        """
        Called when we become an icon.
        """

        if self.minimized:
            return

        self.minimized = True

        renpy.display.log.write("The window was minimized.")


    def restored(self):
        """
        Called when we are restored from being an icon.
        """

        # This is necessary on Windows/DirectX/Angle, as otherwise we get
        # a blank screen.

        if not self.minimized:
            return

        self.minimized = False

        renpy.display.log.write("The window was restored.")

        if renpy.windows:
            self.display_reset = True
            self.set_mode(self.last_resize)

    def enter_context(self):
        """
        Called when we enter a new context.
        """

        # Stop ongoing transitions.
        self.ongoing_transition.clear()
        self.transition_from.clear()
        self.transition_time.clear()

    def post_time_event(self):
        """
        Posts a time_event object to the queue.
        """

        try:
            pygame.event.post(self.time_event)
        except:
            pass

    def after_longpress(self):
        """
        Called after a longpress, to ignore the mouse button release.
        """

        self.ignore_touch = True
        renpy.display.focus.mouse_handler(None, -1, -1, default=False)


    def interact(self, clear=True, suppress_window=False, **kwargs):
        """
        This handles an interaction, restarting it if necessary. All of the
        keyword arguments are passed off to interact_core.
        """

        # Cancel magic error reporting.
        renpy.bootstrap.report_error = None

        context = renpy.game.context()

        if context.interacting:
            raise Exception("Cannot start an interaction in the middle of an interaction, without creating a new context.")

        context.interacting = True


        # Show a missing window.
        if not suppress_window:
            self.show_window()

        # These things can be done once per interaction.

        preloads = self.preloads
        self.preloads = [ ]

        try:
            for i in renpy.config.start_interact_callbacks:
                i()

            repeat = True

            while repeat:
                repeat, rv = self.interact_core(preloads=preloads, **kwargs)

            return rv

        finally:

            context.interacting = False

            # Clean out transient stuff at the end of an interaction.
            if clear:
                scene_lists = renpy.game.context().scene_lists
                scene_lists.replace_transient()

            self.ongoing_transition = { }
            self.transition_time = { }
            self.transition_from = { }

            self.restart_interaction = True

            renpy.game.context().scene_lists.shown_window = False

    def interact_core(self,
                      show_mouse=True,
                      trans_pause=False,
                      suppress_overlay=False,
                      suppress_underlay=False,
                      mouse='default',
                      preloads=[],
                      roll_forward=None,
                      ):

        """
        This handles one cycle of displaying an image to the user,
        and then responding to user input.

        @param show_mouse: Should the mouse be shown during this
        interaction? Only advisory, and usually doesn't work.

        @param trans_pause: If given, we must have a transition. Should we
        add a pause behavior during the transition?

        @param suppress_overlay: This suppresses the display of the overlay.
        @param suppress_underlay: This suppresses the display of the underlay.
        """

        self.roll_forward = roll_forward
        self.show_mouse = show_mouse

        suppress_transition = renpy.config.skipping or renpy.game.less_updates

        # The global one.
        self.suppress_transition = False

        # Figure out transitions.
        for k in self.transition:
            if k not in self.old_scene:
                continue

            self.ongoing_transition[k] = self.transition[k]
            self.transition_from[k] = self.old_scene[k]
            self.transition_time[k] = None

        self.transition.clear()

        if suppress_transition:
            self.ongoing_transition.clear()
            self.transition_from.clear()
            self.transition_time.clear()

        ## Safety condition, prevents deadlocks.
        if trans_pause:
            if not self.ongoing_transition:
                return False, None
            if None not in self.ongoing_transition:
                return False, None
            if suppress_transition:
                return False, None
            if not self.old_scene:
                return False, None

        # Check to see if the language has changed.
        renpy.translation.check_language()

        # We just restarted.
        self.restart_interaction = False

        # Setup the mouse.
        self.mouse = mouse

        # The start and end times of this interaction.
        start_time = get_time()
        end_time = start_time

        # frames = 0

        for i in renpy.config.interact_callbacks:
            i()

        # Set the window caption.
        self.set_window_caption()

        # Tick time forward.
        renpy.display.im.cache.tick()
        renpy.text.text.layout_cache_tick()
        renpy.display.predict.reset()

        # Clear the size groups.
        renpy.display.layout.size_groups.clear()

        # Clear the set of updated screens.
        renpy.display.screen.updated_screens.clear()

        # Clear some events.
        pygame.event.clear((pygame.MOUSEMOTION,
                            PERIODIC,
                            TIMEEVENT,
                            REDRAW))

        # Add a single TIMEEVENT to the queue.
        self.post_time_event()

        # Figure out the scene list we want to show.
        scene_lists = renpy.game.context().scene_lists

        # Remove the now-hidden things.
        scene_lists.remove_hidden()

        # Compute the overlay.
        if not suppress_overlay:
            self.compute_overlay()

        # The root widget of everything that is displayed on the screen.
        root_widget = renpy.display.layout.MultiBox(layout='fixed')
        root_widget.layers = { }

        # A list of widgets that are roots of trees of widgets that are
        # considered for focusing.
        focus_roots = [ ]

        # Add the underlay to the root widget.
        if not suppress_underlay:
            for i in renpy.config.underlay:
                root_widget.add(i)
                focus_roots.append(i)

            if roll_forward is not None:
                rfw = renpy.display.behavior.RollForward(roll_forward)
                root_widget.add(rfw)
                focus_roots.append(rfw)

        # Figure out the scene. (All of the layers, and the root.)
        scene = self.compute_scene(scene_lists)

        # If necessary, load all images here.
        for w in scene.itervalues():
            try:
                renpy.display.predict.displayable(w)
            except:
                pass

        # The root widget of all of the layers.
        layers_root = renpy.display.layout.MultiBox(layout='fixed')
        layers_root.layers = { }

        def add_layer(where, layer):

            scene_layer = scene[layer]
            focus_roots.append(scene_layer)

            if (self.ongoing_transition.get(layer, None) and
                not suppress_transition):

                trans = self.ongoing_transition[layer](
                    old_widget=self.transition_from[layer],
                    new_widget=scene_layer)

                if not isinstance(trans, Displayable):
                    raise Exception("Expected transition to be a displayable, not a %r" % trans)

                transition_time = self.transition_time.get(layer, None)

                where.add(trans, transition_time, transition_time)
                where.layers[layer] = trans

            else:
                where.layers[layer] = scene_layer
                where.add(scene_layer)

        # Add layers (perhaps with transitions) to the layers root.
        for layer in renpy.config.layers:
            add_layer(layers_root, layer)

        # Add layers_root to root_widget, perhaps through a transition.
        if (self.ongoing_transition.get(None, None) and
            not suppress_transition):

            old_root = renpy.display.layout.MultiBox(layout='fixed')
            old_root.layers = { }

            for layer in renpy.config.layers:
                d = self.transition_from[None].layers[layer]
                old_root.layers[layer] = d
                old_root.add(d)

            trans = self.ongoing_transition[None](
                old_widget=old_root,
                new_widget=layers_root)

            if not isinstance(trans, Displayable):
                raise Exception("Expected transition to be a displayable, not a %r" % trans)

            trans._show()

            transition_time = self.transition_time.get(None, None)
            root_widget.add(trans, transition_time, transition_time)

            if trans_pause:
                sb = renpy.display.behavior.SayBehavior()
                root_widget.add(sb)
                focus_roots.append(sb)

                pb = renpy.display.behavior.PauseBehavior(trans.delay)
                root_widget.add(pb, transition_time, transition_time)
                focus_roots.append(pb)

        else:
            root_widget.add(layers_root)

        # Add top_layers to the root_widget.
        for layer in renpy.config.top_layers:
            add_layer(root_widget, layer)

        for i in renpy.display.emulator.overlay:
            root_widget.add(i)

        del add_layer

        prediction_coroutine = renpy.display.predict.prediction_coroutine(root_widget)
        prediction_coroutine.send(None)

        # Clean out the registered adjustments.
        renpy.display.behavior.adj_registered.clear()

        # Clean up some movie-related things.
        renpy.display.video.early_interact()

        # Call per-interaction code for all widgets.
        root_widget.visit_all(lambda i : i.per_interact())

        # Now, update various things regarding scenes and transitions,
        # so we are ready for a new interaction or a restart.
        self.old_scene = scene

        # Okay, from here on we now have a single root widget (root_widget),
        # which we will try to show to the user.

        # Figure out what should be focused.
        renpy.display.focus.before_interact(focus_roots)

        # Redraw the screen.
        renpy.display.render.process_redraws()
        needs_redraw = True

        # First pass through the while loop?
        first_pass = True

        # We don't yet know when the interaction began.
        self.interact_time = None

        # We only want to do autosave once.
        did_autosave = False

        old_timeout_time = None
        old_redraw_time = None

        rv = None

        # Start sound.
        renpy.audio.audio.interact()

        # How long until we redraw.
        _redraw_in = 3600

        # Have we drawn a frame yet?
        video_frame_drawn = False

        # We're no longer after rollback.
        renpy.game.after_rollback = False

        # This try block is used to force cleanup even on termination
        # caused by an exception propagating through this function.
        try:

            while rv is None:

                # Check for a change in fullscreen preference.
                if self.fullscreen != renpy.game.preferences.fullscreen or self.display_reset:
                    self.set_mode()
                    needs_redraw = True

                # Check for suspend.
                if android:
                    self.android_check_suspend()

                # Check for autoreload.
                if renpy.loader.needs_autoreload:
                    renpy.loader.needs_autoreload = False
                    renpy.exports.reload_script()

                # Redraw the screen.
                if (self.force_redraw or
                    ((first_pass or not pygame.event.peek(ALL_EVENTS)) and
                     renpy.display.draw.should_redraw(needs_redraw, first_pass))):

                    self.force_redraw = False

                    # If we have a movie, start showing it.
                    fullscreen_video = renpy.display.video.interact()

                    # Clean out the redraws, if we have to.
                    # renpy.display.render.kill_redraws()

                    # Draw the screen.
                    self.frame_time = get_time()

                    if not self.interact_time:
                        self.interact_time = self.frame_time

                    self.draw_screen(root_widget, fullscreen_video, (not fullscreen_video) or video_frame_drawn)

                    if first_pass:
                        scene_lists.set_times(self.interact_time)
                        for k, v in self.transition_time.iteritems():
                            if v is None:
                                self.transition_time[k] = self.interact_time

                    renpy.config.frames += 1

                    # If profiling is enabled, report the profile time.
                    if renpy.config.profile or self.profile_once:
                        new_time = get_time()

                        if self.profile_once or (new_time - self.profile_time > .015):
                            print "Profile: Redraw took %.3f ms." % (1000 * (new_time - self.frame_time))
                            print "Profile: %.3f ms to complete event." % (1000 * (new_time - self.profile_time))

                        self.profile_once = False

                    if first_pass and self.last_event:
                        x, y = renpy.display.draw.get_mouse_pos()
                        ev, x, y = renpy.display.emulator.emulator(self.last_event, x, y)

                        if self.ignore_touch:
                            x = -1
                            y = -1

                        renpy.display.focus.mouse_handler(None, x, y, default=False)

                    needs_redraw = False
                    first_pass = False

                    pygame.time.set_timer(REDRAW, 0)
                    pygame.event.clear([REDRAW])
                    old_redraw_time = None

                # Move the mouse, if necessary.
                if self.mouse_move is not None:
                    if not self.mouse_move.perform():
                        self.mouse_move = None

                # Draw the mouse, if it needs drawing.
                renpy.display.draw.update_mouse()

                # See if we want to restart the interaction entirely.
                if self.restart_interaction:
                    return True, None

                # Determine if we need a redraw. (We want to run these
                # functions, so we put them first to prevent short-circuiting.)

                if renpy.display.video.frequent():
                    needs_redraw = True
                    video_frame_drawn = True

                needs_redraw = renpy.display.video.frequent() or needs_redraw
                needs_redraw = renpy.display.render.process_redraws() or needs_redraw

                # How many seconds until we timeout.
                _timeout_in = 3600

                # Handle the redraw timer.
                redraw_time = renpy.display.render.redraw_time()

                if (redraw_time is not None) and not needs_redraw:
                    if redraw_time != old_redraw_time:
                        time_left = redraw_time - get_time()
                        time_left = min(time_left, 3600)
                        _redraw_in = time_left

                        if time_left <= 0:
                            try:
                                pygame.event.post(self.redraw_event)
                            except:
                                pass
                            pygame.time.set_timer(REDRAW, 0)
                        else:
                            pygame.time.set_timer(REDRAW, max(int(time_left * 1000), 1))

                        old_redraw_time = redraw_time
                else:
                    _redraw_in = 3600
                    pygame.time.set_timer(REDRAW, 0)

                # Handle the timeout timer.
                if not self.timeout_time:
                    pygame.time.set_timer(TIMEEVENT, 0)
                else:
                    time_left = self.timeout_time - get_time()
                    time_left = min(time_left, 3600)
                    _timeout_in = time_left

                    if time_left <= 0:
                        self.timeout_time = None
                        pygame.time.set_timer(TIMEEVENT, 0)
                        self.post_time_event()
                    elif self.timeout_time != old_timeout_time:
                        # Always set to at least 1ms.
                        pygame.time.set_timer(TIMEEVENT, int(time_left * 1000 + 1))
                        old_timeout_time = self.timeout_time

                # Predict images, if we haven't done so already.
                while prediction_coroutine is not None:

                    # Can we do expensive prediction?
                    expensive_predict = not (needs_redraw or self.event_peek() or renpy.audio.music.is_playing("movie"))

                    result = prediction_coroutine.send(expensive_predict)

                    if not result:
                        prediction_coroutine = None
                        break

                    if not expensive_predict:
                        break

                # If we need to redraw again, do it if we don't have an
                # event going on.
                if needs_redraw and not self.event_peek():
                    self.profile_time = get_time()
                    continue

                # Handle autosaving and persistent checking, as necessary.
                if not did_autosave:
                    renpy.loadsave.autosave()
                    did_autosave = True

                renpy.persistent.check_update()

                if needs_redraw or self.mouse_move or renpy.display.video.playing():
                    ev = self.event_poll()
                else:
                    ev = self.event_wait()

                if ev.type == pygame.NOEVENT:
                    continue

                self.profile_time = get_time()

                # Try to merge an TIMEEVENT with other timeevents.
                if ev.type == TIMEEVENT:
                    old_timeout_time = None
                    pygame.event.clear([TIMEEVENT])

                # On Android, where we have multiple mouse buttons, we can
                # merge a mouse down and mouse up event with its successor. This
                # prevents us from getting overwhelmed with too many events on
                # a multitouch screen.
                if android and (ev.type == pygame.MOUSEBUTTONDOWN or ev.type == pygame.MOUSEBUTTONUP):
                    pygame.event.clear(ev.type)

                # Handle redraw timeouts.
                if ev.type == REDRAW:
                    pygame.event.clear([REDRAW])
                    old_redraw_time = None
                    continue

                # Handle periodic events. This includes updating the mouse timers (and through the loop,
                # the mouse itself), and the audio system periodic calls.
                if ev.type == PERIODIC:
                    events = 1 + len(pygame.event.get([PERIODIC]))
                    self.ticks += events

                    if renpy.config.periodic_callback:
                        renpy.config.periodic_callback()

                    renpy.audio.audio.periodic()
                    continue


                # Handle quit specially for now.
                if ev.type == pygame.QUIT:
                    self.quit_event()
                    continue

                # Handle videoresize.
                if ev.type == pygame.VIDEORESIZE:
                    evs = pygame.event.get([pygame.VIDEORESIZE])

                    if len(evs):
                        ev = evs[-1]

                    if self.last_resize is None and renpy.windows:
                        self.last_resize = ev.size

                    if self.last_resize != ev.size:
                        self.last_resize = ev.size
                        self.set_mode((ev.w, ev.h))

                    continue

                # If we're ignoring touch events, and get a mouse up, stop
                # ignoring those events.
                if self.ignore_touch and \
                    ev.type == pygame.MOUSEBUTTONUP and \
                    ev.button == 1:

                    self.ignore_touch = False
                    continue


                # Merge mousemotion events.
                if ev.type == pygame.MOUSEMOTION:
                    evs = pygame.event.get([pygame.MOUSEMOTION])
                    if len(evs):
                        ev = evs[-1]

                    if renpy.windows:
                        self.focused = True

                # Handle mouse event time, and ignoring touch.
                if ev.type == pygame.MOUSEMOTION or \
                        ev.type == pygame.MOUSEBUTTONDOWN or \
                        ev.type == pygame.MOUSEBUTTONUP:

                    self.mouse_event_time = renpy.display.core.get_time()

                    if self.ignore_touch:
                        renpy.display.focus.mouse_handler(None, -1, -1, default=False)

                # Handle focus notifications.
                if ev.type == pygame.ACTIVEEVENT:
                    if ev.state & 1:
                        self.focused = ev.gain

                    if ev.state & 4:
                        if ev.gain:
                            self.restored()
                        else:
                            self.iconified()

                    pygame.key.set_mods(0)

                # This returns the event location. It also updates the
                # mouse state as necessary.
                x, y = renpy.display.draw.mouse_event(ev)

                ev, x, y = renpy.display.emulator.emulator(ev, x, y)
                if ev is None:
                    continue

                if not self.focused or self.ignore_touch:
                    x = -1
                    y = -1

                # This can set the event to None, to ignore it.
                ev = renpy.display.joystick.event(ev)
                if not ev:
                    continue

                # Handle skipping.
                renpy.display.behavior.skipping(ev)

                self.event_time = end_time = get_time()

                try:

                    # Handle the event normally.
                    rv = renpy.display.focus.mouse_handler(ev, x, y)

                    if rv is None:
                        rv = root_widget.event(ev, x, y, 0)

                    if rv is None:
                        rv = renpy.display.focus.key_handler(ev)

                    if rv is not None:
                        break

                    # Handle displayable inspector.
                    if renpy.config.inspector and renpy.display.behavior.inspector(ev):
                        l = self.surftree.main_displayables_at_point(x, y, renpy.config.transient_layers + renpy.config.context_clear_layers + renpy.config.overlay_layers)
                        renpy.game.invoke_in_new_context(renpy.config.inspector, l)

                except IgnoreEvent:
                    # An ignored event can change the timeout. So we want to
                    # process an TIMEEVENT to ensure that the timeout is
                    # set correctly.
                    self.post_time_event()


                # Check again after handling the event.
                needs_redraw |= renpy.display.render.process_redraws()

                if self.restart_interaction:
                    return True, None

            # If we were trans-paused and rv is true, suppress
            # transitions up to the next interaction.
            if trans_pause and rv:
                self.suppress_transition = True

            # But wait, there's more! The finally block runs some cleanup
            # after this.
            return False, rv

        except EndInteraction as e:
            return False, e.value

        finally:

            renpy.game.context().say_attributes = None

            # Clean out the overlay layers.
            for i in renpy.config.overlay_layers:
                scene_lists.clear(i)

            # Stop ongoing preloading.
            renpy.display.im.cache.end_tick()

            # We no longer disable periodic between interactions.
            # pygame.time.set_timer(PERIODIC, 0)

            pygame.time.set_timer(TIMEEVENT, 0)
            pygame.time.set_timer(REDRAW, 0)

            renpy.game.context().runtime += end_time - start_time

            # Restart the old interaction, which also causes a
            # redraw if needed.
            self.restart_interaction = True

            # print "It took", frames, "frames."

    def timeout(self, offset):
        if offset < 0:
            return

        if self.timeout_time:
            self.timeout_time = min(self.event_time + offset, self.timeout_time)
        else:
            self.timeout_time = self.event_time + offset

    def finish_pending(self):
        """
        Called before a quit or restart to finish any pending work that might
        block other threads.
        """

        self.check_background_screenshot()

########NEW FILE########
__FILENAME__ = dragdrop
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# TODO: Use overlap (rather than simple pointer location) to determine
# drag and drop.

import renpy.display
from renpy.display.render import render, Render, redraw
from renpy.display.core import absolute
from renpy.display.behavior import map_event, run

import pygame

def default_drag_group():
    """
    Gets the default drag group. If it doesn't exist yet, creates it.
    """

    sls = renpy.game.context().scene_lists

    rv = sls.drag_group

    if rv is None:
        rv = DragGroup()
        sls.drag_group = rv

    return rv

def default_drag_joined(drag):
    return [ (drag, 0, 0) ]

class Drag(renpy.display.core.Displayable, renpy.python.RevertableObject):
    """
    :doc: drag_drop class
    :args: (d=None, drag_name=None, draggable=True, droppable=True, drag_raise=True, dragged=None, dropped=None, drag_handle=(0.0, 0.0, 1.0, 1.0), drag_joined=..., clicked=None, hovered=None, unhovered=None, **properties)

    A displayable that represents an object that can be dragged around
    its enclosing area. A Drag can also represent an area that
    other Drags can be dropped on.

    A Drag can be moved around inside is parent. Generally, its parent
    should be either a :func:`Fixed` or :class:`DragGroup`.

    A Drag has one child. The child's state reflects the status
    of the drag and drop operation:

    * ``selected_hover`` - when it is being dragged.
    * ``selected_idle`` - when it can be dropped on.
    * ``hover`` - when the draggable will be dragged when the mouse is
      clicked.
    * ``idle`` - otherwise.

    The drag handle is a rectangle inside the child. The mouse must be over
    a non-transparent pixel inside the drag handle for dragging or clicking
    to occur.

    A newly-created draggable is added to the default DragGroup. A draggable
    can only be in a single DragGroup - if it's added to a second group,
    it's removed from the first.

    When a Drag is first rendered, if it's position cannot be determined
    from the DragGroup it is in, the position of its upper-left corner
    is computed using the standard layout algorithm. Once that position


    `d`
        If present, the child of this Drag. Drags use the child style
        in preference to this, if it's not None.

    `drag_name`
        If not None, the name of this draggable. This is available
        as the `name` property of draggable objects. If a Drag
        with the same name is or was in the DragGroup, the starting
        position of this Drag is taken from that Draggable.

    `draggable`
        If true, the Drag can be dragged around the screen with
        the mouse.

    `droppable`
        If true, other Drags can be dropped on this Drag.

    `drag_raise`
        If true, this Drag is raised to the top when it is dragged. If
        it is joined to other Drags, all joined drags are raised.

    `dragged`
        A callback (or list of callbacks) that is called when the Drag
        has been dragged. It is called with two arguments. The first is
        a list of Drags that are being dragged. The second is either
        a Drag that is being dropped onto, or None of a drop did not
        occur. If the callback returns a value other than None, that
        value is returned as the result of the interaction.

    `dropped`
        A callback (or list of callbacks) that is called when this Drag
        is dropped onto. It is called with two arguments. The first
        is the Drag being dropped onto. The second is a list of Drags that
        are being dragged.  If the callback returns a value other than None,
        that value is returned as the result of the interaction.

        When a dragged and dropped callback are triggered for the same
        event, the dropped callback is only called if dragged returns
        None.

    `clicked`
        A callback this is called, with no arguments, when the Drag is
        clicked without being moved. A droppable can also be focused
        and clicked.  If the callback returns a value othe than None,
        that value is returned as the result of the interaction.

    `drag_handle`
        A (x, y, width, height) tuple, giving the position of the drag
        handle within the child. In this tuple, integers are considered
        to be a literal number of pixels, while floats are relative to
        the size of the child.

    `drag_joined`
        This is called with the current Drag as an argument. It's
        expected to return a list of [ (drag, x, y) ] tuples, giving
        the draggables to drag as a unit. `x` and `y` are the offsets
        of the drags relative to each other, they are not relative
        to the corner of this drag.

    Except for `d`, all of the parameters are available as fields (with
    the same name) on the Drag object. In addition, after the drag has
    been rendered, the following fields become available:

    `x`, `y`
         The position of the Drag relative to its parent, in pixels.

    `w`, `h`
         The width and height of the Drag's child, in pixels.
        """

    def __init__(self,
                 d=None,
                 drag_name=None,
                 draggable=True,
                 droppable=True,
                 drag_raise=True,
                 dragged=None,
                 dropped=None,
                 drag_handle=(0.0, 0.0, 1.0, 1.0),
                 drag_joined=default_drag_joined,
                 clicked=None,
                 hovered=None,
                 unhovered=None,
                 replaces=None,
                 **properties):

        super(Drag, self).__init__(self, **properties)

        self.drag_name = drag_name
        self.draggable = draggable
        self.droppable = droppable
        self.drag_raise = drag_raise
        self.dragged = dragged
        self.dropped = dropped
        self.drag_handle = drag_handle
        self.drag_joined = drag_joined
        self.clicked = clicked
        self.hovered = hovered
        self.unhovered = unhovered

        self.child = None

        # Add us to a drag group on creation.
        if drag_name:
            self.drag_group = default_drag_group()

        # The current x and y coordinates of this displayable.
        self.x = None
        self.y = None

        # The width and height of the child.
        self.w = None
        self.h = None

        # The width and height of our parent.
        self.parent_width = None
        self.parent_height = None

        # The target x and y coordinates of this displayable. (The
        # coordinates that we're snapping to.)
        self.target_x = None
        self.target_y = None

        # The offset from the location of the mouse to the "grab point",
        # which is where the things that are being moved are offset from.
        self.grab_x = None
        self.grab_y = None

        # x and y from the last time we rendered.
        self.last_x = None
        self.last_y = None

        # The abs_x and abs_y from when we started the grab.
        self.start_x = 0
        self.start_y = 0

        # The last time we were shown, using the animation timebases.
        self.at = 0

        # The (animation timebase) time at which we should reach
        # the target coordinates.
        self.target_at = 0

        # The displayable we were last dropping on.
        self.last_drop = None

        # Did we move over the course of this drag?
        self.drag_moved = False

        if replaces is not None:
            self.x = replaces.x
            self.y = replaces.y
            self.at = replaces.at
            self.target_x = replaces.target_x
            self.target_y = replaces.target_y
            self.target_at = replaces.target_at

        if d is not None:
            self.add(d)


    def snap(self, x, y, delay=0):
        """
        :doc: drag_drop method

        Changes the position of the drag. If the drag is not showing,
        then the position change is instantaneous. Otherwise, the
        position change takes `delay` seconds, and is animated as a
        linear move.
        """

        self.target_x = x
        self.target_y = y

        if self.x is not None:
            self.target_at = self.at + delay
        else:
            self.target_at = self.at
            self.x = x
            self.y = y

        redraw(self, 0)

    def set_style_prefix(self, prefix, root):
        super(Drag, self).set_style_prefix(prefix, root)

        if self.child is not None:
            self.child.set_style_prefix(prefix, False)

    def add(self, d):
        if self.child is not None:
            raise Exception("Drag expects either zero or one children.")

        self.child = renpy.easy.displayable(d)

    def _clear(self):
        self.child = None
        renpy.display.render.redraw(self, 0)

    def set_child(self, d):
        """
        :doc: drag_drop method

        Changes the child of this drag to `d`.
        """

        d.per_interact()
        self.child = renpy.easy.displayable(d)

    def top(self):
        """
        :doc: drag_drop method

        Raises this displayable to the top of its drag_group.
        """

        if self.drag_group is not None:
            self.drag_group.raise_children([ self ])

    def visit(self):
        return [ self.child ]

    def focus(self, default=False):
        super(Drag, self).focus(default)

        rv = None

        if not default:
            rv = run(self.hovered)

        return rv

    def unfocus(self, default=False):
        super(Drag, self).unfocus(default)

        if not default:
            run(self.unhovered)

    def render(self, width, height, st, at):

        child = self.style.child
        if child is None:
            child = self.child

        self.parent_width = width
        self.parent_height = height

        cr = render(child, width, height, st, at)
        cw, ch = cr.get_size()

        rv = Render(cw, ch)
        rv.blit(cr, (0, 0))

        self.w = cw
        self.h = ch

        # If we don't have a position, then look for it in a drag group.
        if (self.x is None) and (self.drag_group is not None) and (self.drag_name is not None):
            if self.drag_name in self.drag_group.positions:
                self.x, self.y = self.drag_group.positions[self.drag_name]

        # If we don't have a position, run the placement code and use
        # that to compute our placement.
        if self.x is None:
            self.x, self.y = self.place(None, 0, 0, width, height, rv)
            self.x = int(self.x)
            self.y = int(self.y)

        if self.target_x is None:
            self.target_x = self.x
            self.target_y = self.y
            self.target_at = at

        # Determine if we need to do the snap animation.
        if at >= self.target_at:
            self.x = self.target_x
            self.y = self.target_y
        else:
            done = (at - self.at) / (self.target_at - self.at)
            self.x = absolute(self.x + done * (self.target_x - self.x))
            self.y = absolute(self.y + done * (self.target_y - self.y))
            redraw(self, 0)

        if self.draggable or self.clicked is not None:

            fx, fy, fw, fh = self.drag_handle

            if isinstance(fx, float):
                fx = int(fx * cw)

            if isinstance(fy, float):
                fy = int(fy * ch)

            if isinstance(fw, float):
                fw = int(fw * cw)

            if isinstance(fh, float):
                fh = int(fh * ch)

            rv.add_focus(self, None, fx, fy, fw, fh, fx, fy, cr.subsurface((fx, fy, fw, fh)))

        self.last_x = self.x
        self.last_y = self.y
        self.at = at

        return rv

    def event(self, ev, x, y, st):

        if not self.is_focused():
            return self.child.event(ev, x, y, st)

        # if not self.draggable:
        #    return self.child.event(ev, x, y, st)

        # Mouse, in parent-relative coordinates.
        par_x = self.last_x + x
        par_y = self.last_y + y

        grabbed = (renpy.display.focus.get_grab() is self)

        if grabbed:
            joined_offsets = self.drag_joined(self)
            joined = [ i[0] for i in joined_offsets ]

        elif self.draggable and map_event(ev, "drag_activate"):

            joined_offsets = self.drag_joined(self)
            joined = [ i[0] for i in joined_offsets ]

            if not joined:
                raise renpy.display.core.IgnoreEvent()

            renpy.display.focus.set_grab(self)

            self.grab_x = x
            self.grab_y = y

            # If we're not the only thing we're joined with, we
            # might need to adjust our grab point.
            for i, xo, yo in joined_offsets:
                if i is self:
                    self.grab_x += xo
                    self.grab_y += yo
                    break

            self.drag_moved = False
            self.start_x = par_x
            self.start_y = par_y

            grabbed = True

        # Handle clicking on droppables.
        if not grabbed:
            if self.clicked is not None and map_event(ev, "drag_deactivate"):
                rv = run(self.clicked)
                if rv is not None:
                    return rv

                raise renpy.display.core.IgnoreEvent()

            return self.child.event(ev, x, y, st)

        # Handle moves by moving things relative to the grab point.
        if ev.type in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONUP, pygame.MOUSEBUTTONDOWN):

            if not self.drag_moved and (self.start_x != par_x or self.start_y != par_y):
                self.drag_moved = True

                # We may not be in the drag_joined group.
                self.set_style_prefix("idle_", True)

                # Set the style.
                for i in joined:
                    i.set_style_prefix("selected_hover_", True)

                # Raise the joined items.
                if self.drag_raise and self.drag_group is not None:
                    self.drag_group.raise_children(joined)

            if self.drag_moved:
                for i, xo, yo in joined_offsets:

                    new_x = par_x - self.grab_x + xo
                    new_y = par_y - self.grab_y + yo
                    new_x = max(new_x, 0)
                    new_x = min(new_x, int(i.parent_width - i.w))
                    new_y = max(new_y, 0)
                    new_y = min(new_y, int(i.parent_height - i.h))

                    if i.drag_group is not None and i.drag_name is not None:
                        i.drag_group.positions[i.drag_name] = (new_x, new_y)

                    i.x = new_x
                    i.y = new_y
                    i.target_x = new_x
                    i.target_y = new_y
                    i.target_at = self.at
                    redraw(i, 0)

        if (self.drag_group is not None) and self.drag_moved:
            drop = self.drag_group.get_best_drop(joined)
        else:
            drop = None

        if drop is not self.last_drop:

            if self.last_drop is not None:
                self.last_drop.set_style_prefix("idle_", True)

            if drop is not None:
                drop.set_style_prefix("selected_idle_", True)

            self.last_drop = drop

        if map_event(ev, 'drag_deactivate'):
            renpy.display.focus.set_grab(None)

            if drop is not None:
                drop.set_style_prefix("idle_", True)

            for i in joined:
                i.set_style_prefix("idle_", True)

            self.set_style_prefix("hover_", True)

            self.grab_x = None
            self.grab_y = None
            self.last_drop = None

            if self.drag_moved:

                # Call the drag callback.
                drag = joined[0]
                if drag.dragged is not None:
                    rv = run(drag.dragged, joined, drop)
                    if rv is not None:
                        return rv

                # Call the drop callback.
                if drop is not None and drop.dropped is not None:
                    rv = run(drop.dropped, drop, joined)
                    if rv is not None:
                        return rv

            else:

                # Call the clicked callback.
                if self.clicked:
                    rv = run(self.clicked)
                    if rv is not None:
                        return rv

        raise renpy.display.core.IgnoreEvent()


    def get_placement(self):

        if self.x is not None:
            return self.x, self.y, 0, 0, 0, 0, True
        else:
            return super(Drag, self).get_placement()

    def per_interact(self):
        self.set_style_prefix("idle_", True)
        super(Drag, self).per_interact()


class DragGroup(renpy.display.layout.MultiBox):
    """
    :doc: drag_drop class

    Represents a group of Drags. A Drag is limited to the boundary of
    its DragGroup. Dropping only works between Drags that are in the
    same DragGroup. Drags may only be raised when they are inside a
    DragGroup.

    A DragGroup is laid out like a :func:`Fixed`.

    All positional parameters to the DragGroup constructor should be
    Drags, that are added to the DragGroup.
    """

    _list_type = renpy.python.RevertableList

    def __init__(self, *children, **properties):
        properties.setdefault("style", "fixed")
        properties.setdefault("layout", "fixed")

        replaces = properties.pop("replaces", None)

        super(DragGroup, self).__init__(**properties)

        if replaces is not None:
            self.positions = renpy.python.RevertableDict(replaces.positions)
            self.sensitive = replaces.sensitive
        else:
            self.positions = renpy.python.RevertableDict()
            self.sensitive = True

        for i in children:
            self.add(i)


    def add(self, child):
        """
        :doc: drag_drop method

        Adds `child`, which must be a Drag, to this DragGroup.
        """

        if not isinstance(child, Drag):
            raise Exception("Only drags can be added to a drag group.")

        child.drag_group = self
        super(DragGroup, self).add(child)

    def remove(self, child):
        """
        :doc: drag_drop method

        Removes `child` from this DragGroup.
        """


        if not isinstance(child, Drag):
            raise Exception("Only drags can be removed from a drag group.")

        child.x = None
        super(DragGroup, self).remove(child)


    def event(self, ev, x, y, st):

        if not self.sensitive:
            return None

        return super(DragGroup, self).event(ev, x, y, st)

    def raise_children(self, l):
        """
        Raises the children in `l` to the top of this drag_group, using the
        order given in l for those children.
        """

        s = set(l)

        offset_map = { }

        children = [ ]
        offsets = [ ]

        for i, c in enumerate(self.children):
            if i < len(self.offsets):
                o = self.offsets[i]
            else:
                o = (0, 0)

            if c not in s:
                children.append(c)
                offsets.append(o)
            else:
                offset_map[c] = o

        for c in l:
            if c in offset_map:
                children.append(c)
                offsets.append(offset_map[c])

        self.children = self._list_type(children)
        self.offsets = self._list_type(offsets)


    def get_best_drop(self, joined):
        """
        Returns the droppable that the members of joined overlap the most.
        """

        max_overlap = 0
        rv = 0

        joined_set = set(joined)

        for d in joined:

            r1 = (d.x, d.y, d.w, d.h)

            for c in self.children:
                if c in joined_set:
                    continue

                if not c.droppable:
                    continue

                r2 = (c.x, c.y, c.w, c.h)

                overlap = rect_overlap_area(r1, r2)

                if overlap >= max_overlap:
                    rv = c
                    max_overlap = overlap

        if max_overlap <= 0:
            return None
        else:
            return rv

    def get_children(self):
        """
        Returns a list of Drags that are the children of
        this DragGroup.
        """

        return renpy.python.RevertableList(self.children)

    def get_child_by_name(self, name):
        """
        :doc: drag_drop method

        Returns the first child of this DragGroup that has a drag_name
        of name.
        """

        for i in self.children:
            if i.drag_name == name:
                return i

        return None


def rect_overlap_area(r1, r2):
    """
    Returns the number of pixels by which rectangles r1 and r2 overlap.
    """

    x1, y1, w1, h1 = r1
    x2, y2, w2, h2 = r2

    maxleft = max(x1, x2)
    minright = min(x1 + w1, x2 + w2)
    maxtop = max(y1, y2)
    minbottom = min(y1 + h1, y2 + h2)

    if minright < maxleft:
        return 0

    if minbottom < maxtop:
        return 0

    return (minright - maxleft) * (minbottom - maxtop)

########NEW FILE########
__FILENAME__ = emulator
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code to emulate various other devices on the PC.

import renpy.display

import os
import pygame

# The function that's called to perform the emulation. This function has
# the signature of null_emulator.
emulator = None

# An overlay that is placed over the screen to support the emulator.
overlay = [ ]

def null_emulator(ev, x, y):
    """
    This is used when emulation is not desired.
    """
    return ev, x, y

TOUCH_KEYS = [ pygame.K_ESCAPE, pygame.K_PAGEUP ]

def touch_emulator(ev, x, y):
    """
    This emulates a touch-screen device, like a tablet or smartphone.
    """

    if ev.type == pygame.MOUSEBUTTONDOWN:
        if ev.button != 1:
            return None, x, y

    elif ev.type == pygame.MOUSEBUTTONUP:
        if ev.button != 1:
            return None, x, y

        move = pygame.event.Event(pygame.MOUSEMOTION, { "pos" : (0, 0), "rel" : (0, 0), "buttons" : (0, 0, 0) })
        renpy.display.interface.pushed_event = move

    elif ev.type == pygame.MOUSEMOTION:
        if not ev.buttons[0]:
            x = 0
            y = 0

    elif ev.type == pygame.KEYDOWN:
        if not ev.key in TOUCH_KEYS:
            return None, x, y

    elif ev.type == pygame.KEYUP:
        if not ev.key in TOUCH_KEYS:
            return None, x, y

    return ev, x, y


TV_KEYS = [ pygame.K_LEFT, pygame.K_RIGHT, pygame.K_UP, pygame.K_DOWN, pygame.K_RETURN, pygame.K_ESCAPE, pygame.K_PAGEUP ]

def tv_emulator(ev, x, y):
    """
    This emulates a tv-based device, like the OUYA.
    """

    if ev.type == pygame.MOUSEBUTTONDOWN:
        return None, x, y
    elif ev.type == pygame.MOUSEBUTTONUP:
        return None, x, y
    elif ev.type == pygame.MOUSEMOTION:
        return None, x, y
    elif ev.type == pygame.KEYDOWN:
        if not ev.key in TV_KEYS:
            return None, x, y
    elif ev.type == pygame.KEYDOWN:
        if not ev.key in TV_KEYS:
            return None, x, y

    return ev, x, y


def init_emulator():
    """
    Sets up the emulator.
    """

    global emulator
    global overlay

    name = os.environ.get("RENPY_EMULATOR", "")

    if name == "touch":
        emulator = touch_emulator
        overlay = [ ]
    elif name == "tv":
        emulator = tv_emulator
        overlay = [ renpy.display.motion.Transform(
            "_tv_unsafe.png",
            xalign=0.5,
            yalign=0.5,
            size=(int(renpy.config.screen_height * 16.0 / 9.0), renpy.config.screen_height),
            ) ]
    else:
        emulator = null_emulator
        overlay = [ ]

########NEW FILE########
__FILENAME__ = error
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code to handle GUI-based error reporting.

import renpy.display
import os

error_handled = False

##############################################################################
# Initialized approach.

def call_exception_screen(screen_name, **kwargs):
    try:

        old_quit = renpy.config.quit_action
        renpy.config.quit_action = renpy.exports.quit

        for i in renpy.config.layers:
            renpy.game.context().scene_lists.clear(i)

        renpy.exports.show_screen(screen_name, _transient=True, **kwargs)
        return renpy.ui.interact(mouse="screen", type="screen", suppress_overlay=True, suppress_underlay=True)

    finally:
        renpy.config.quit_action = old_quit

def rollback_action():
    renpy.exports.rollback(force=True)

def init_display():
    """
    The minimum amount of code required to init the display.
    """

    if not renpy.game.interface:
        renpy.display.core.Interface()
        renpy.loader.index_archives()
        renpy.display.im.cache.init()

    renpy.ui.reset()

def error_dump():
    """
    Handles dumps in the case where an error occurs.
    """

    renpy.dump.dump(True)

def report_exception(short, full, traceback_fn):
    """
    Reports an exception to the user. Returns True if the exception should
    be raised by the normal reporting mechanisms. Otherwise, should raise
    the appropriate exception to cause a reload or quit or rollback.
    """

    global error_handled
    error_handled = True

    error_dump()

    if renpy.game.args.command != "run": #@UndefinedVariable
        return True

    if "RENPY_SIMPLE_EXCEPTIONS" in os.environ:
        return True

    if not renpy.exports.has_screen("_exception"):
        return True

    try:
        init_display()
    except:
        return True

    if renpy.display.draw is None:
        return True

    ignore_action = None
    rollback_action = None
    reload_action = None

    try:
        if not renpy.game.context().init_phase:

            if renpy.config.rollback_enabled:
                rollback_action = renpy.display.error.rollback_action

            reload_action = renpy.exports.curried_call_in_new_context("_save_reload_game")

        if renpy.game.context(-1).next_node is not None:
            ignore_action = renpy.ui.returns(False)
    except:
        pass

    renpy.game.invoke_in_new_context(
        call_exception_screen,
        "_exception",
        short=short, full=full,
        rollback_action=rollback_action,
        reload_action=reload_action,
        ignore_action=ignore_action,
        traceback_fn=traceback_fn,
        )


def report_parse_errors(errors, error_fn):
    """
    Reports an exception to the user. Returns True if the exception should
    be raised by the normal reporting mechanisms. Otherwise, should raise
    the appropriate exception.
    """

    global error_handled
    error_handled = True

    error_dump()

    if renpy.game.args.command != "run": #@UndefinedVariable
        return True

    if "RENPY_SIMPLE_EXCEPTIONS" in os.environ:
        return True

    if not renpy.exports.has_screen("_parse_errors"):
        return True

    init_display()

    reload_action = renpy.exports.utter_restart

    renpy.game.invoke_in_new_context(
        call_exception_screen,
        "_parse_errors",
        reload_action=reload_action,
        errors=errors,
        error_fn = error_fn,
        )


########NEW FILE########
__FILENAME__ = focus
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code to manage focus on the display.

import pygame
import renpy.display

class Focus(object):

    def __init__(self, widget, arg, x, y, w, h):

        self.widget = widget
        self.arg = arg
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def copy(self):
        return Focus(
            self.widget,
            self.arg,
            self.x,
            self.y,
            self.w,
            self.h)

    def __repr__(self):
        return "<Focus: %r %r (%r, %r, %r, %r)>" % (
            self.widget,
            self.arg,
            self.x,
            self.y,
            self.w,
            self.h)


# The current focus argument.
argument = None

# The widget currently grabbing the input, if any.
grab = None

# The default focus for the current screen.
default_focus = None

# Sets the currently focused widget.
def set_focused(widget, arg):
    global argument
    argument = arg
    renpy.game.context().scene_lists.focused = widget

# Gets the currently focused widget.
def get_focused():
    return renpy.game.context().scene_lists.focused

# Get the mouse cursor for the focused widget.
def get_mouse():
    focused = get_focused()
    if focused is None:
        return None
    else:
        return focused.style.mouse

def set_grab(widget):
    global grab
    grab = widget

def get_grab():
    return grab

# The current list of focuses that we know about.
focus_list = [ ]

# This takes in a focus list from the rendering system.
def take_focuses():
    global focus_list
    focus_list = [ ]

    renpy.display.render.take_focuses(focus_list)

    global default_focus
    default_focus = None

    for f in focus_list:
        if f.x is None:
            default_focus = f

def focus_coordinates():
    """
    :doc: other

    This attempts to find the coordinates of the currently-focused
    displayable. If it can, it will return them as a (x, y, w, h)
    tuple. If not, it will return a (None, None, None, None) tuple.
    """

    current = get_focused()

    for i in focus_list:
        if i.widget == current and i.arg == argument:
            return i.x, i.y, i.w, i.h

    return None, None, None, None


# This is called before each interaction. It's purpose is to choose
# the widget that is focused, and to mark it as focused and all of
# the other widgets as unfocused.

# The new grab widget. (The one that replaced the old grab widget at the start
# of the interaction.)
new_grab = None

def before_interact(roots):

    global new_grab
    global grab

    # a list of focusable, name tuples.
    fwn = [ ]

    def callback(f, n):
        fwn.append((f, n))

    for root in roots:
        root.find_focusable(callback, None)

    # Assign a full name to each focusable.

    namecount = { }

    for f, n in fwn:
        serial = namecount.get(n, 0)
        namecount[n] = serial + 1

        f.full_focus_name = n, serial

    # If there's something with the same full name as the current widget,
    # it becomes the new current widget.

    current = get_focused()

    if current is not None:
        current_name = current.full_focus_name

        for f, n in fwn:
            if f.full_focus_name == current_name:
                current = f
                set_focused(f, None)
                break
        else:
            current = None

    # Otherwise, focus the default widget, or nothing.
    if current is None:

        for f, n in fwn:
            if f.default:
                current = f
                set_focused(f, None)
                break
        else:
            set_focused(None, None)

    # Finally, mark the current widget as the focused widget, and
    # all other widgets as unfocused.
    for f, n in fwn:
        if f is not current:
            f.unfocus(default=True)

    if current:
        current.focus(default=True)

    grab = new_grab
    new_grab = None

# This changes the focus to be the widget contained inside the new
# focus object.
def change_focus(newfocus, default=False):
    rv = None

    if grab:
        return

    if newfocus is None:
        widget = None
    else:
        widget = newfocus.widget

    current = get_focused()

    # Nothing to do.
    if current is widget and (newfocus is None or newfocus.arg == argument):
        return rv

    if current is not None:
        current.unfocus(default=default)

    current = widget

    if newfocus is not None:
        arg = newfocus.arg
    else:
        arg = None

    set_focused(current, arg)

    if widget is not None:
        rv = widget.focus(default=default)

    return rv

# This handles mouse events, to see if they change the focus.
def mouse_handler(ev, x, y, default=False):
    """
    Handle mouse events, to see if they change the focus.

    `ev`
        If ev is not None, this function checks to see if it is a mouse event.
    """

    if ev is not None:
        if ev.type not in (pygame.MOUSEMOTION, pygame.MOUSEBUTTONUP, pygame.MOUSEBUTTONDOWN):
            return

    new_focus = renpy.display.render.focus_at_point(x, y)

    if new_focus is None:
        new_focus = default_focus

    return change_focus(new_focus, default=default)


# This focuses an extreme widget, which is one of the widgets that's
# at an edge. To do this, we multiply the x, y, width, and height by
# the supplied multiplers, add them all up, and take the focus with
# the largest value.
def focus_extreme(xmul, ymul, wmul, hmul):

    max_focus = None
    max_score = -(65536**2)

    for f in focus_list:

        if not f.x:
            continue

        score = (f.x * xmul +
                 f.y * ymul +
                 f.w * wmul +
                 f.h * hmul)

        if score > max_score:
            max_score = score
            max_focus = f

    if max_focus:
        return change_focus(max_focus)


# This calculates the distance between two points, applying
# the given fudge factors. The distance is left squared.
def points_dist(x0, y0, x1, y1, xfudge, yfudge):
    return (( x0 - x1 ) * xfudge ) ** 2 + \
           (( y0 - y1 ) * yfudge ) ** 2


# This computes the distance between two horizontal lines. (So the
# distance is either vertical, or has a vertical component to it.)
#
# The distance is left squared.
def horiz_line_dist(ax0, ay0, ax1, ay1, bx0, by0, bx1, by1):

    # The lines overlap in x.
    if bx0 <= ax0 <= ax1 <= bx1 or \
       ax0 <= bx0 <= bx1 <= ax1 or \
       ax0 <= bx0 <= ax1 <= bx1 or \
       bx0 <= ax0 <= bx1 <= ax1:
        return (ay0 - by0) ** 2

    # The right end of a is to the left of the left end of b.
    if ax0 <= ax1 <= bx0 <= bx1:
        return points_dist(ax1, ay1, bx0, by0, renpy.config.focus_crossrange_penalty, 1.0)
    else:
        return points_dist(ax0, ay0, bx1, by1, renpy.config.focus_crossrange_penalty, 1.0)


# This computes the distance between two vertical lines. (So the
# distance is either hortizontal, or has a horizontal component to it.)
#
# The distance is left squared.
def verti_line_dist(ax0, ay0, ax1, ay1, bx0, by0, bx1, by1):

    # The lines overlap in x.
    if by0 <= ay0 <= ay1 <= by1 or \
       ay0 <= by0 <= by1 <= ay1 or \
       ay0 <= by0 <= ay1 <= by1 or \
       by0 <= ay0 <= by1 <= ay1:
        return (ax0 - bx0) ** 2

    # The right end of a is to the left of the left end of b.
    if ay0 <= ay1 <= by0 <= by1:
        return points_dist(ax1, ay1, bx0, by0, 1.0, renpy.config.focus_crossrange_penalty)
    else:
        return points_dist(ax0, ay0, bx1, by1, 1.0, renpy.config.focus_crossrange_penalty)


# This focuses the widget that is nearest to the current widget. To
# determine nearest, we compute points on the widgets using the
# {from,to}_{x,y}off values. We pick the nearest, applying a fudge
# multiplier to the distances in each direction, that satisfies
# the condition (which is given a Focus object to evaluate).
#
# If no focus can be found matching the above, we look for one
# with an x of None, and make that the focus. Otherwise, we do
# nothing.
#
# If no widget is focused, we pick one and focus it.
#
# If the current widget has an x of None, we pass things off to
# focus_extreme to deal with.
def focus_nearest(from_x0, from_y0, from_x1, from_y1,
                  to_x0, to_y0, to_x1, to_y1,
                  line_dist,
                  condition,
                  xmul, ymul, wmul, hmul):

    if not focus_list:
        return

    # No widget focused.
    current = get_focused()

    if not current:
        change_focus(focus_list[0])
        return

    # Find the current focus.
    for f in focus_list:
        if f.widget is current and f.arg == argument:
            from_focus = f
            break
    else:
        # If we can't pick something.
        change_focus(focus_list[0])
        return

    # If placeless, focus_extreme.
    if from_focus.x is None:
        focus_extreme(xmul, ymul, wmul, hmul)
        return

    fx0 = from_focus.x + from_focus.w * from_x0
    fy0 = from_focus.y + from_focus.h * from_y0
    fx1 = from_focus.x + from_focus.w * from_x1
    fy1 = from_focus.y + from_focus.h * from_y1

    placeless = None
    new_focus = None

    # a really big number.
    new_focus_dist = (65536.0 * renpy.config.focus_crossrange_penalty) ** 2

    for f in focus_list:

        if f is from_focus:
            continue

        if f.x is None:
            placeless = f
            continue

        if not condition(from_focus, f):
            continue

        tx0 = f.x + f.w * to_x0
        ty0 = f.y + f.h * to_y0
        tx1 = f.x + f.w * to_x1
        ty1 = f.y + f.h * to_y1

        dist = line_dist(fx0, fy0, fx1, fy1,
                         tx0, ty0, tx1, ty1)

        if dist < new_focus_dist:
            new_focus = f
            new_focus_dist = dist

    # If we couldn't find anything, try the placeless focus.
    new_focus = new_focus or placeless

    # If we have something, switch to it.
    if new_focus:
        return change_focus(new_focus)

    # And, we're done.



def key_handler(ev):

    if renpy.display.behavior.map_event(ev, 'focus_right'):
        return focus_nearest(0.9, 0.1, 0.9, 0.9,
                             0.1, 0.1, 0.1, 0.9,
                             verti_line_dist,
                             lambda old, new : old.x + old.w <= new.x,
                             -1, 0, 0, 0)

    if renpy.display.behavior.map_event(ev, 'focus_left'):
        return focus_nearest(0.1, 0.1, 0.1, 0.9,
                             0.9, 0.1, 0.9, 0.9,
                             verti_line_dist,
                             lambda old, new : new.x + new.w <= old.x,
                             1, 0, 1, 0)

    if renpy.display.behavior.map_event(ev, 'focus_up'):
        return focus_nearest(0.1, 0.1, 0.9, 0.1,
                             0.1, 0.9, 0.9, 0.9,
                             horiz_line_dist,
                             lambda old, new : new.y + new.h <= old.y,
                             0, 1, 0, 1)

    if renpy.display.behavior.map_event(ev, 'focus_down'):
        return focus_nearest(0.1, 0.9, 0.9, 0.9,
                             0.1, 0.1, 0.9, 0.1,
                             horiz_line_dist,
                             lambda old, new : old.y + old.h <= new.y,
                             0, -1, 0, 0)

########NEW FILE########
__FILENAME__ = im
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains the new image code, which includes provisions for
# size-based caching and constructing images from operations (like
# cropping and scaling).

import renpy.display

import math
import zipfile
import cStringIO
import threading
import time


# This is an entry in the image cache.
class CacheEntry(object):

    def __init__(self, what, surf):

        # The object that is being cached (which needs to be
        # hashable and comparable).
        self.what = what

        # The pygame surface corresponding to the cached object.
        self.surf = surf

        # The size of this image.
        w, h = surf.get_size()
        self.size = w * h

        # The time when this cache entry was last used.
        self.time = 0

# This is the singleton image cache.
class Cache(object):

    def __init__(self):

        # The current arbitrary time. (Increments by one for each
        # interaction.)
        self.time = 0

        # A map from Image object to CacheEntry.
        self.cache = { }

        # A list of Image objects that we want to preload.
        self.preloads = [ ]

        # False if this is not the first preload in this tick.
        self.first_preload_in_tick = True

        # The total size of the current generation of images.
        self.size_of_current_generation = 0

        # The total size of everything in the cache.
        self.total_cache_size = 0

        # A lock that must be held when updating the cache.
        self.lock = threading.Condition()

        # A lock that mist be held to notify the preload thread.
        self.preload_lock = threading.Condition()

        # Is the preload_thread alive?
        self.keep_preloading = True

        # A map from image object to surface, only for objects that have
        # been pinned into memory.
        self.pin_cache = { }

        # Images that we tried, and failed, to preload.
        self.preload_blacklist = set()

        # The size of the cache, in pixels.
        self.cache_limit = 0

        # The preload thread.
        self.preload_thread = threading.Thread(target=self.preload_thread_main, name="preloader")
        self.preload_thread.setDaemon(True)
        self.preload_thread.start()

        # Have we been added this tick?
        self.added = set()

        # A list of (time, filename, preload) tuples. This is updated when
        # config.developer is True and an image is loaded. Preload is a
        # flag that is true if the image was loaded from the preload
        # thread. The log is limited to 100 entries, and the newest entry
        # is first.
        #
        # This is only updated when config.developer is True.
        self.load_log = [ ]


    def init(self):
        """
        Updates the cache object to make use of settings that might be provided
        by the game-maker.
        """

        self.cache_limit = renpy.config.image_cache_size * renpy.config.screen_width * renpy.config.screen_height

    def quit(self): #@ReservedAssignment
        if not self.preload_thread.isAlive():
            return

        with self.preload_lock:
            self.keep_preloading = False
            self.preload_lock.notify()

        self.preload_thread.join()

        self.clear()


    # Clears out the cache.
    def clear(self):

        self.lock.acquire()

        self.preloads = [ ]
        self.pin_cache = { }
        self.cache = { }
        self.first_preload_in_tick = True
        self.size_of_current_generation = 0
        self.total_cache_size = 0

        self.added.clear()

        self.lock.release()

    # Increments time, and clears the list of images to be
    # preloaded.
    def tick(self):

        with self.lock:
            self.time += 1
            self.preloads = [ ]
            self.first_preload_in_tick = True
            self.size_of_current_generation = 0
            self.added.clear()

        if renpy.config.debug_image_cache:
            renpy.display.ic_log.write("----")
            filename, line = renpy.exports.get_filename_line()
            renpy.display.ic_log.write("%s %d", filename, line)

    # The preload thread can deal with this update, so we don't need
    # to lock things.
    def end_tick(self):
        self.preloads = [ ]


    # This returns the pygame surface corresponding to the provided
    # image. It also takes care of updating the age of images in the
    # cache to be current, and maintaining the size of the current
    # generation of images.
    def get(self, image, predict=False):

        if not isinstance(image, ImageBase):
            raise Exception("Expected an image of some sort, but got" + str(image) + ".")

        if not image.cache:
            surf = image.load()
            renpy.display.render.mutated_surface(surf)
            return surf

        # First try to grab the image out of the cache without locking it.
        ce = self.cache.get(image, None)

        # Otherwise, we load the image ourselves.
        if ce is None:

            try:
                if image in self.pin_cache:
                    surf = self.pin_cache[image]
                else:
                    surf = image.load()

            except:
                raise

            with self.lock:

                ce = CacheEntry(image, surf)

                if image not in self.cache:
                    self.total_cache_size += ce.size

                self.cache[image] = ce

                # Indicate that this surface had changed.
                renpy.display.render.mutated_surface(ce.surf)

                if renpy.config.debug_image_cache:
                    if predict:
                        renpy.display.ic_log.write("Added %r (%.02f%%)", ce.what, 100.0 * self.total_cache_size / self.cache_limit)
                    else:
                        renpy.display.ic_log.write("Total Miss %r", ce.what)

                renpy.display.draw.load_texture(ce.surf)


        # Move it into the current generation. This isn't protected by
        # a lock, so in certain circumstances we could have an
        # inaccurate size - but that will be cured at the end of the
        # current generation.

        if ce.time != self.time:
            ce.time = self.time
            self.size_of_current_generation += ce.size

        # Done... return the surface.
        return ce.surf


    # This kills off a given cache entry.
    def kill(self, ce):

        # Should never happen... but...
        if ce.time == self.time:
            self.size_of_current_generation -= ce.size

        self.total_cache_size -= ce.size
        del self.cache[ce.what]

        if renpy.config.debug_image_cache:
            renpy.display.ic_log.write("Removed %r", ce.what)

    def cleanout(self):
        """
        Cleans out the cache, if it's gotten too large. Returns True
        if the cache is smaller than the size limit, or False if it's
        bigger and we don't want to continue preloading.
        """

        # If we're within the limit, return.
        if self.total_cache_size <= self.cache_limit:
            return True

        # If we're outside the cache limit, we need to go and start
        # killing off some of the entries until we're back inside it.

        for ce in sorted(self.cache.itervalues(), key=lambda a : a.time):

            if ce.time == self.time:
                # If we're bigger than the limit, and there's nothing
                # to remove, we should stop the preloading right away.
                return False

            # Otherwise, kill off the given cache entry.
            self.kill(ce)

            # If we're in the limit, we're done.
            if self.total_cache_size <= self.cache_limit:
                break

        return True


    # Called to report that a given image would like to be preloaded.
    def preload_image(self, im):

        if not isinstance(im, ImageBase):
            return

        with self.lock:

            if im in self.added:
                return

            self.added.add(im)

            if im in self.cache:
                self.get(im)
                in_cache = True
            else:
                self.preloads.append(im)
                in_cache = False

        if not in_cache:

            with self.preload_lock:
                self.preload_lock.notify()

        if in_cache and renpy.config.debug_image_cache:
            renpy.display.ic_log.write("Kept %r", im)


    def start_prediction(self):
        """
        Called at the start of prediction, to ensure the thread runs
        at least once to clean out the cache.
        """

        with self.preload_lock:
            self.preload_lock.notify()

    def preload_thread_main(self):

        while self.keep_preloading:

            self.preload_lock.acquire()
            self.preload_lock.wait()
            self.preload_lock.release()

            while self.preloads and self.keep_preloading:

                # If the size of the current generation is bigger than the
                # total cache size, stop preloading.
                with self.lock:

                    # If the cache is overfull, clean it out.
                    if not self.cleanout():

                        if renpy.config.debug_image_cache:
                            for i in self.preloads:
                                renpy.display.ic_log.write("Overfull %r", i)

                        self.preloads = [ ]

                        break

                try:
                    image = self.preloads.pop(0)

                    if image not in self.preload_blacklist:
                        try:
                            self.get(image, True)
                        except:
                            self.preload_blacklist.add(image)
                except:
                    pass

            with self.lock:
                self.cleanout()

            # If we have time, preload pinned images.
            if self.keep_preloading and not renpy.game.less_memory:

                workset = set(renpy.store._cache_pin_set)

                # Remove things that are not in the workset from the pin cache,
                # and remove things that are in the workset from pin cache.
                for i in self.pin_cache.keys():

                    if i in workset:
                        workset.remove(i)
                    else:
                        surf = self.pin_cache[i]

                        del self.pin_cache[i]


                # For each image in the worklist...
                for image in workset:

                    if image in self.preload_blacklist:
                        continue

                    # If we have normal preloads, break out.
                    if self.preloads:
                        break

                    try:
                        surf = image.load()
                        self.pin_cache[image] = surf
                        renpy.display.draw.load_texture(surf)
                    except:
                        self.preload_blacklist.add(image)

    def add_load_log(self, filename):

        if not renpy.config.developer:
            return

        preload = (threading.current_thread() is self.preload_thread)

        self.load_log.insert(0, (time.time(), filename, preload))

        while len(self.load_log) > 100:
            self.load_log.pop()



# The cache object.
cache = Cache()

def free_memory():
    """
    Frees some memory.
    """

    renpy.display.draw.free_memory()
    cache.clear()


class ImageBase(renpy.display.core.Displayable):
    """
    This is the base class for all of the various kinds of images that
    we can possibly have.
    """

    __version__ = 1

    def after_upgrade(self, version):
        if version < 1:
            self.cache = True

    def __init__(self, *args, **properties):

        self.rle = properties.pop('rle', None)
        self.cache = properties.pop('cache', True)

        properties.setdefault('style', 'image')

        super(ImageBase, self).__init__(**properties)
        self.identity = (type(self).__name__, ) + args


    def __hash__(self):
        return hash(self.identity)

    def __eq__(self, other):

        if not isinstance(other, ImageBase):
            return False

        return self.identity == other.identity

    def __repr__(self):
        return "<" + " ".join([repr(i) for i in self.identity]) + ">"

    def load(self):
        """
        This function is called by the image cache code to cause this
        image to be loaded. It's expected that children of this class
        would override this.
        """

        raise Exception("load method not implemented.")

    def render(self, w, h, st, at):

        im = cache.get(self)
        texture = renpy.display.draw.load_texture(im)

        w, h = im.get_size()
        rv = renpy.display.render.Render(w, h)
        rv.blit(texture, (0, 0))
        return rv

    def predict_one(self):
        renpy.display.predict.image(self)

    def predict_files(self):
        """
        Returns a list of files that will be accessed when this image
        operation is performed.
        """

        return [ ]

class Image(ImageBase):
    """
    This image manipulator loads an image from a file.
    """

    def __init__(self, filename, **properties):
        """
        @param filename: The filename that the image will be loaded from.
        """

        super(Image, self).__init__(filename, **properties)
        self.filename = filename

    def get_mtime(self):
        return renpy.loader.get_mtime(self.filename)

    def load(self, unscaled=False):

        cache.add_load_log(self.filename)

        try:

            if unscaled:
                surf = renpy.display.pgrender.load_image_unscaled(renpy.loader.load(self.filename), self.filename)
            else:
                surf = renpy.display.pgrender.load_image(renpy.loader.load(self.filename), self.filename)

            return surf

        except Exception, e:

            if renpy.config.missing_image_callback:
                im = renpy.config.missing_image_callback(self.filename)
                if im is None:
                    raise e

                return im.load()

            raise

    def predict_files(self):

        if renpy.loader.loadable(self.filename):
            return [ self.filename ]
        else:
            if renpy.config.missing_image_callback:
                im = renpy.config.missing_image_callback(self.filename)
                if im is not None:
                    return im.predict_files()

            return [ self.filename ]

class ZipFileImage(ImageBase):

    def __init__(self, zipfilename, filename, mtime=0, **properties):
        super(ZipFileImage, self).__init__(zipfilename, filename, mtime, **properties)

        self.zipfilename = zipfilename
        self.filename = filename

    def load(self):
        try:
            zf = zipfile.ZipFile(self.zipfilename, 'r')
            data = zf.read(self.filename)
            sio = cStringIO.StringIO(data)
            rv = renpy.display.pgrender.load_image(sio, self.filename)
            zf.close()
            return rv
        except:
            return renpy.display.pgrender.surface((2, 2), True)



    def predict_files(self):
        return [ ]



class Composite(ImageBase):
    """
    :doc: im_im

    This image manipulator composites multiple images together to
    form a single image.

    The `size` should be a (width, height) tuple giving the size
    of the composed image.

    The remaining positional arguments are interpreted as groups of
    two. The first argument in a group should be an (x, y) tuple,
    while the second should be an image manipulator. The image
    produced by the image manipulator is composited at the location
    given by the tuple.

    ::

        image girl clothed happy = im.Composite(
            (300, 600),
            (0, 0), "girl_body.png",
            (0, 0), "girl_clothes.png",
            (100, 100), "girl_happy.png"
            )

    """

    def __init__(self, size, *args, **properties):

        super(Composite, self).__init__(size, *args, **properties)

        if len(args) % 2 != 0:
            raise Exception("Composite requires an odd number of arguments.")

        self.size = size
        self.positions = args[0::2]
        self.images = [ image(i) for i in args[1::2] ]

    def get_mtime(self):
        return min(i.get_mtime() for i in self.images)

    def load(self):

        if self.size:
            size = self.size
        else:
            size = cache.get(self.images[0]).get_size()

        rv = renpy.display.pgrender.surface(size, True)

        for pos, im in zip(self.positions, self.images):
            rv.blit(cache.get(im), pos)

        return rv

    def predict_files(self):

        rv = [ ]

        for i in self.images:
            rv.extend(i.predict_files())

        return rv

class Scale(ImageBase):
    """
    :doc: im_im

    An image manipulator that scales `im` (an image manipulator) to
    `width` and `height`.

    If `bilinear` is true, then bilinear interpolation is used for
    the scaling. Otherwise, nearest neighbor interpolation is used.

    ::

        image logo scale = im.Scale("logo.png", 100, 150)
    """

    def __init__(self, im, width, height, bilinear=True, **properties):

        im = image(im)
        super(Scale, self).__init__(im, width, height, bilinear, **properties)

        self.image = im
        self.width = int(width)
        self.height = int(height)
        self.bilinear = bilinear

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        child = cache.get(self.image)

        if self.bilinear:
            try:
                renpy.display.render.blit_lock.acquire()
                rv = renpy.display.scale.smoothscale(child, (self.width, self.height))
            finally:
                renpy.display.render.blit_lock.release()
        else:
            try:
                renpy.display.render.blit_lock.acquire()
                rv = renpy.display.pgrender.transform_scale(child, (self.width, self.height))
            finally:
                renpy.display.render.blit_lock.release()

        return rv

    def predict_files(self):
        return self.image.predict_files()

class FactorScale(ImageBase):
    """
    :doc: im_im

    An image manipulator that scales `im` (a second image manipulator)
    to `width` times its original `width`, and `height` times its
    original height. If `height` is ommitted, it defaults to `width`.

    If `bilinear` is true, then bilinear interpolation is used for
    the scaling. Otherwise, nearest neighbor interpolation is used.

    ::

        image logo doubled = im.FactorScale("logo.png", 1.5)
    """


    def __init__(self, im, width, height=None, bilinear=True, **properties):

        if height is None:
            height = width

        im = image(im)
        super(FactorScale, self).__init__(im, width, height, bilinear, **properties)

        self.image = im
        self.width = width
        self.height = height
        self.bilinear = bilinear

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        surf = cache.get(self.image)
        width, height = surf.get_size()

        width = int(width * self.width)
        height = int(height * self.height)

        if self.bilinear:
            try:
                renpy.display.render.blit_lock.acquire()
                rv = renpy.display.scale.smoothscale(surf, (width, height))
            finally:
                renpy.display.render.blit_lock.release()

        else:
            try:
                renpy.display.render.blit_lock.acquire()
                rv = renpy.display.pgrender.transform_scale(surf, (width, height))
            finally:
                renpy.display.render.blit_lock.release()

        return rv

    def predict_files(self):
        return self.image.predict_files()


class Flip(ImageBase):
    """
    :doc: im_im

    An image manipulator that flips `im` (an image manipulator)
    vertically or horizontally.  `vertical` and `horizontal` control
    the directions in which the image is flipped.

    ::

        image eileen flip = im.Flip("eileen_happy.png", vertical=True)
    """

    def __init__(self, im, horizontal=False, vertical=False, **properties):

        if not (horizontal or vertical):
            raise Exception("im.Flip must be called with a true value for horizontal or vertical.")

        im = image(im)
        super(Flip, self).__init__(im, horizontal, vertical, **properties)

        self.image = im
        self.horizontal = horizontal
        self.vertical = vertical


    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        child = cache.get(self.image)

        try:
            renpy.display.render.blit_lock.acquire()
            rv = renpy.display.pgrender.flip(child, self.horizontal, self.vertical)
        finally:
            renpy.display.render.blit_lock.release()

        return rv


    def predict_files(self):
        return self.image.predict_files()



class Rotozoom(ImageBase):
    """
    This is an image manipulator that is a smooth rotation and zoom of another image manipulator.
    """

    def __init__(self, im, angle, zoom, **properties):
        """
        @param im: The image to be rotozoomed.

        @param angle: The number of degrees counterclockwise the image is
        to be rotated.

        @param zoom: The zoom factor. Numbers that are greater than 1.0
        lead to the image becoming larger.
        """

        im = image(im)
        super(Rotozoom, self).__init__(im, angle, zoom, **properties)

        self.image = im
        self.angle = angle
        self.zoom = zoom

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        child = cache.get(self.image)

        try:
            renpy.display.render.blit_lock.acquire()
            rv = renpy.display.pgrender.rotozoom(child, self.angle, self.zoom)
        finally:
            renpy.display.render.blit_lock.release()

        return rv

    def predict_files(self):
        return self.image.predict_files()



class Crop(ImageBase):
    """
    :doc: im_im
    :args: (im, rect)

    An image manipulator that crops `rect`, a (x, y, width, height) tuple,
    out of `im`, an image manipulator.

    ::

        image logo crop = im.Crop("logo.png", (0, 0, 100, 307))
    """

    def __init__(self, im, x, y=None, w=None, h=None, **properties):

        im = image(im)

        if y is None:
            (x, y, w, h) = x

        super(Crop, self).__init__(im, x, y, w, h, **properties)

        self.image = im
        self.x = x
        self.y = y
        self.w = w
        self.h = h

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):
        return cache.get(self.image).subsurface((self.x, self.y,
                                                 self.w, self.h))

    def predict_files(self):
        return self.image.predict_files()


ramp_cache = { }


def ramp(start, end):
    """
    Returns a 256 character linear ramp, where the first character has
    the value start and the last character has the value end. Such a
    ramp can be used as a map argument of im.Map.
    """

    rv = ramp_cache.get((start, end), None)
    if rv is None:

        chars = [ ]

        for i in range(0, 256):
            i = i / 255.0
            chars.append(chr(int( end * i + start * (1.0 - i) ) ) )

        rv = "".join(chars)
        ramp_cache[start, end] = rv

    return rv

identity = ramp(0, 255)

class Map(ImageBase):
    """
    This adjusts the colors of the image that is its child. It takes
    as arguments 4 256 character strings. If a pixel channel has a
    value of 192, then the value of the 192nd character in the string
    is used for the mapped pixel component.
    """

    def __init__(self, im, rmap=identity, gmap=identity, bmap=identity,
                 amap=identity, force_alpha=False, **properties):

        im = image(im)

        super(Map, self).__init__(im, rmap, gmap, bmap, amap, force_alpha, **properties)

        self.image = im
        self.rmap = rmap
        self.gmap = gmap
        self.bmap = bmap
        self.amap = amap

        self.force_alpha = force_alpha

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        surf = cache.get(self.image)

        rv = renpy.display.pgrender.surface(surf.get_size(), True)

        renpy.display.module.map(surf, rv,
                                 self.rmap, self.gmap, self.bmap, self.amap)

        return rv

    def predict_files(self):
        return self.image.predict_files()

class Twocolor(ImageBase):
    """
    This takes as arguments two colors, white and black. The image is
    mapped such that pixels in white have the white color, pixels in
    black have the black color, and shades of gray are linearly
    interpolated inbetween.  The alpha channel is mapped linearly
    between 0 and the alpha found in the white color, the black
    color's alpha is ignored.
    """

    def __init__(self, im, white, black, force_alpha=False, **properties):

        white = renpy.easy.color(white)
        black = renpy.easy.color(black)

        im = image(im)

        super(Twocolor, self).__init__(im, white, black, force_alpha, **properties)

        self.image = im
        self.white = white
        self.black = black

        self.force_alpha = force_alpha

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        surf = cache.get(self.image)

        rv = renpy.display.pgrender.surface(surf.get_size(), True)

        renpy.display.module.twomap(surf, rv,
                                    self.white, self.black)

        return rv

    def predict_files(self):
        return self.image.predict_files()


class Recolor(ImageBase):
    """
    This adjusts the colors of the image that is its child. It takes as an
    argument 4 numbers between 0 and 255, and maps each channel of the image
    linearly between 0 and the supplied color.
    """

    def __init__(self, im, rmul=255, gmul=255, bmul=255,
                 amul=255, force_alpha=False, **properties):

        im = image(im)

        super(Recolor, self).__init__(im, rmul, gmul, bmul, amul, force_alpha, **properties)

        self.image = im
        self.rmul = rmul + 1
        self.gmul = gmul + 1
        self.bmul = bmul + 1
        self.amul = amul + 1

        self.force_alpha = force_alpha

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        surf = cache.get(self.image)

        rv = renpy.display.pgrender.surface(surf.get_size(), True)

        renpy.display.module.linmap(surf, rv,
                                    self.rmul, self.gmul, self.bmul, self.amul)

        return rv

    def predict_files(self):
        return self.image.predict_files()

class MatrixColor(ImageBase):
    """
    :doc: im_matrixcolor

    An image operator that uses `matrix` to linearly transform the
    image manipulator `im`.

    `Matrix` should be a list, tuple, or :func:`im.matrix` that is 20
    or 25 elements long. If the object has 25 elements, then elements
    past the 20th are ignored.

    When the four components of the source color are R, G, B, and A,
    which range from 0.0 to 1.0; the four components of the transformed
    color are R', G', B', and A', with the same range; and the elements
    of the matrix are named::

        [ a, b, c, d, e,
          f, g, h, i, j,
          k, l, m, n, o,
          p, q, r, s, t ]

    the transformed colors can be computed with the formula::

        R' = (a * R) + (b * G) + (c * B) + (d * A) + e
        G' = (f * R) + (g * G) + (h * B) + (i * A) + j
        B' = (k * R) + (l * G) + (m * B) + (n * A) + o
        A' = (p * R) + (q * G) + (r * B) + (s * A) + t

    The components of the transformed color are clamped to the
    range [0.0, 1.0].
    """

    def __init__(self, im, matrix, **properties):

        im = image(im)

        if len(matrix) != 20 and len(matrix) != 25:
            raise Exception("ColorMatrix expects a 20 or 25 element matrix, got %d elements." % len(matrix))

        matrix = tuple(matrix)
        super(MatrixColor, self).__init__(im, matrix, **properties)

        self.image = im
        self.matrix = matrix

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        surf = cache.get(self.image)

        rv = renpy.display.pgrender.surface(surf.get_size(), True)

        renpy.display.module.colormatrix(surf, rv, self.matrix)

        return rv

    def predict_files(self):
        return self.image.predict_files()

class matrix(tuple):
    """
    :doc: im_matrixcolor

    Constructs an im.matrix object from `matrix`. im.matrix objects
    support The operations supported are matrix multiplication, scalar
    multiplication, element-wise addition, and element-wise
    subtraction. These operations are invoked using the standard
    mathematical operators (\\*, \\*, +, and -, respectively). If two
    im.matrix objects are multiplied, matrix multiplication is
    performed, otherwise scalar multiplication is used.

    `matrix` is a 20 or 25 element list or tuple. If it is 20 elements
    long, it is padded with (0, 0, 0, 0, 1) to make a 5x5 matrix,
    suitable for multiplication.
    """

    def __new__(cls, *args):

        if len(args) == 1:
            args = tuple(args[0])

        if len(args) == 20:
            args = args + (0, 0, 0, 0, 1)

        if len(args) != 25:
            raise Exception("Matrix expects to be given 20 or 25 entries, not %d." % len(args))

        return tuple.__new__(cls, args)

    def mul(self, a, b):

        if not isinstance(a, matrix):
            a = matrix(a)

        if not isinstance(b, matrix):
            b = matrix(b)

        result = [ 0 ] * 25
        for y in range(0, 5):
            for x in range(0, 5):
                for i in range(0, 5):
                    result[x + y * 5] += a[x + i * 5] * b[i + y * 5]

        return matrix(result)

    def scalar_mul(self, other):
        other = float(other)
        return matrix([ i * other for i in self ])

    def vector_mul(self, o):

        return (o[0]*self[0] + o[1]*self[1] + o[2]*self[2] + o[3]*self[3] + self[4],
                o[0]*self[5] + o[1]*self[6] + o[2]*self[7] + o[3]*self[8] + self[9],
                o[0]*self[10] + o[1]*self[11] + o[2]*self[12] + o[3]*self[13] + self[14],
                o[0]*self[15] + o[1]*self[16] + o[2]*self[17] + o[3]*self[18] + self[19],
                1)


    def __add__(self, other):
        if isinstance(other, (int, float)):
            other = float(other)
            return matrix([ i + other for i in self ])

        other = matrix(other)
        return matrix([ i + j for i, j in zip(self, other)])

    __radd__ = __add__

    def __sub__(self, other):
        return self + other * -1

    def __rsub__(self, other):
        return self * -1 + other

    def __mul__(self, other):
        if isinstance(other, (int, float)):
            return self.scalar_mul(other)

        return self.mul(self, other)

    def __rmul__(self, other):
        if isinstance(other, (int, float)):
            return self.scalar_mul(other)

        return self.mul(other, self)

    def __repr__(self):
        return """\
im.matrix(%f, %f, %f, %f, %f.
          %f, %f, %f, %f, %f,
          %f, %f, %f, %f, %f,
          %f, %f, %f, %f, %f,
          %f, %f, %f, %f, %f)""" % self


    @staticmethod
    def identity():
        """
        :doc: im_matrixcolor
        :name: im.matrix.identity

        Returns an identity matrix, one that does not change color or
        alpha.
        """

        return matrix(1, 0, 0, 0, 0,
                      0, 1, 0, 0, 0,
                      0, 0, 1, 0, 0,
                      0, 0, 0, 1, 0)
    @staticmethod
    def saturation(level, desat=(0.2126, 0.7152, 0.0722)):
        """
        :doc: im_matrixcolor
        :name: im.matrix.saturation

        Returns an im.matrix that alters the saturation of an
        image. The alpha channel is untouched.

        `level`
            The amount of saturation in the resulting image. 1.0 is
            the unaltered image, while 0.0 is grayscale.

        `desat`
            This is a 3-element tuple that controls how much of the
            red, green, and blue channels will be placed into all
            three channels of a fully desaturated image. The default
            is based on the constants used for the luminance channel
            of an NTSC television signal. Since the human eye is
            mostly sensitive to green, more of the green channel is
            kept then the other two channels.
        """

        r, g, b = desat

        def I(a, b):
            return a + (b - a) * level

        return matrix(I(r, 1), I(g, 0), I(b, 0), 0, 0,
                      I(r, 0), I(g, 1), I(b, 0), 0, 0,
                      I(r, 0), I(g, 0), I(b, 1), 0, 0,
                      0, 0, 0, 1, 0)

    @staticmethod
    def desaturate():
        """
        :doc: im_matrixcolor
        :name: im.matrix.desaturate

        Returns an im.matrix that desaturates the image (makes it
        grayscale). This is equivalent to calling
        im.matrix.saturation(0).
        """

        return matrix.saturation(0.0)

    @staticmethod
    def tint(r, g, b):
        """
        :doc: im_matrixcolor
        :name: im.matrix.tint

        Returns an im.matrix that tints an image, without changing
        the alpha channel. `r`, `g`, and `b` should be numbers between
        0 and 1, and control what fraction of the given channel is
        placed into the final image. (For example, if `r` is .5, and
        the value of the red channel is 100, the transformed color
        will have a red value of 50.)
        """

        return matrix(r, 0, 0, 0, 0,
                      0, g, 0, 0, 0,
                      0, 0, b, 0, 0,
                      0, 0, 0, 1, 0)

    @staticmethod
    def invert():
        """
        :doc: im_matrixcolor
        :name: im.matrix.invert

        Returns an im.matrix that inverts the red, green, and blue
        channels of the image without changing the alpha channel.
        """

        return matrix(-1, 0, 0, 0, 1,
                      0, -1, 0, 0, 1,
                      0, 0, -1, 0, 1,
                      0, 0, 0, 1, 0)

    @staticmethod
    def brightness(b):
        """
        :doc: im_matrixcolor
        :name: im.matrix.brightness

        Returns an im.matrix that alters the brightness of an image.

        `b`
            The amount of change in image brightness. This should be
            a number between -1 and 1, with -1 the darkest possible
            image and 1 the brightest.
        """

        return matrix(1, 0, 0, 0, b,
                      0, 1, 0, 0, b,
                      0, 0, 1, 0, b,
                      0, 0, 0, 1, 0)

    @staticmethod
    def opacity(o):
        """
        :doc: im_matrixcolor
        :name: im.matrix.opacity

        Returns an im.matrix that alters the opacity of an image. An
        `o` of 0.0 is fully transparent, while 1.0 is fully opaque.
        """

        return matrix(1, 0, 0, 0, 0,
                      0, 1, 0, 0, 0,
                      0, 0, 1, 0, 0,
                      0, 0, 0, o, 0)

    @staticmethod
    def contrast(c):
        """
        :doc: im_matrixcolor
        :name: im.matrix.contrast

        Returns an im.matrix that alters the contrast of an image. `c` should
        be greater than 0.0, with values between 0.0 and 1.0 decreasing contrast, and
        values greater than 1.0 increasing contrast.
        """

        return matrix.brightness(-.5) * matrix.tint(c, c, c) * matrix.brightness(.5)

    # from http://www.gskinner.com/blog/archives/2005/09/flash_8_source.html
    @staticmethod
    def hue(h):
        """
        :doc: im_matrixcolor
        :name: im.matrix.hue

        Returns an im.matrix that rotates the hue by `h` degrees, while
        preserving luminosity.
        """

        h = h * math.pi / 180
        cosVal = math.cos(h)
        sinVal = math.sin(h)
        lumR = 0.213
        lumG = 0.715
        lumB = 0.072
        return matrix(
            lumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,
            lumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,
            lumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,
            0,0,0,1,0,
            0,0,0,0,1
            )

    @staticmethod
    def colorize(black_color, white_color):
        """
        :doc: im_matrixcolor
        :name: im.matrix.colorize

        Returns an im.matrix that colorizes a black and white image.
        `black_color` and `white_color` are Ren'Py style colors, so
        they may be specfied as strings or tuples of (0-255) color
        values. ::

            # This makes black colors red, and white colors blue.
            image logo colored = im.MatrixColor(
                "bwlogo.png",
                im.matrix.colorize("#f00", "#00f"))

        """

        (r0, g0, b0, _a0) = renpy.easy.color(black_color)
        (r1, g1, b1, _a1) = renpy.easy.color(white_color)

        r0 /= 255.0
        g0 /= 255.0
        b0 /= 255.0
        r1 /= 255.0
        g1 /= 255.0
        b1 /= 255.0

        return matrix((r1-r0), 0, 0, 0, r0,
                      0, (g1-g0), 0, 0, g0,
                      0, 0, (b1-b0), 0, b0,
                      0, 0, 0, 1, 0)



def Grayscale(im, desat=(0.2126, 0.7152, 0.0722), **properties):
    """
    :doc: im_im
    :args: (im, **properties)

    An image manipulator that creats a desaturated version of the image
    manipulator `im`.
    """

    return MatrixColor(im, matrix.saturation(0.0, desat), **properties)


def Sepia(im, tint=(1.0, .94, .76), desat=(0.2126, 0.7152, 0.0722), **properties):
    """
    :doc: im_im
    :args: (im, **properties)

    An image manipulator that creates a sepia-toned version of the image
    manipulator `im`.
    """

    return MatrixColor(im, matrix.saturation(0.0, desat) * matrix.tint(tint[0], tint[1], tint[2]), **properties)


def Color(im, color):
    """
    This recolors the supplied image, mapping colors such that black is
    black and white is the supplied color.
    """

    r, g, b, a = renpy.easy.color(color)

    return Recolor(im, r, g, b, a)


def Alpha(image, alpha, **properties):
    """
    Returns an alpha-mapped version of the image. Alpha is the maximum
    alpha that this image can have, a number between 0.0 (fully
    transparent) and 1.0 (opaque).

    If an image already has an alpha channel, values in that alpha
    channel are reduced as appropriate.
    """

    return Recolor(image, 255, 255, 255, int(255 * alpha), force_alpha=True, **properties)

class Tile(ImageBase):
    """
    :doc: im_im

    An image manipulator that tiles the image manipulator `im`, until
    it is `size`.

    `size`
        If not None, a (width, height) tuple. If None, this defaults to
        (:var:`config.screen_width`, :var:`config.screen_height`).
    """

    def __init__(self, im, size=None, **properties):

        im = image(im)

        super(Tile, self).__init__(im, size, **properties)
        self.image = im
        self.size = size

    def get_mtime(self):
        return self.image.get_mtime()

    def load(self):

        size = self.size

        if size is None:
            size = (renpy.config.screen_width, renpy.config.screen_height)

        surf = cache.get(self.image)

        rv = renpy.display.pgrender.surface(size, True)

        width, height = size
        sw, sh = surf.get_size()

        for y in range(0, height, sh):
            for x in range(0, width, sw):
                rv.blit(surf, (x, y))

        return rv

    def predict_files(self):
        return self.image.predict_files()

class AlphaMask(ImageBase):
    """
    :doc: im_im

    An image manipulator that takes two image manipulators, `base` and
    `mask`, as arguments. It replaces the alpha channel of `base` with
    the red channel of `mask`.

    This is used to provide an image's alpha channel in a second
    image, like having one jpeg for color data, and a second one
    for alpha. In some cases, two jpegs can be smaller than a
    single png file.
    """

    def __init__(self, base, mask, **properties):
        super(AlphaMask, self).__init__(base, mask, **properties)

        self.base = image(base)
        self.mask = image(mask)

    def get_mtime(self):
        return max(self.base.get_mtime(), self.image.get_mtime())

    def load(self):

        basesurf = cache.get(self.base)
        masksurf = cache.get(self.mask)

        if basesurf.get_size() != masksurf.get_size():
            raise Exception("AlphaMask surfaces must be the same size.")

        # Used to copy the surface.
        rv = renpy.display.pgrender.copy_surface(basesurf)
        renpy.display.module.alpha_munge(masksurf, rv, identity)

        return rv

    def predict_files(self):
        return self.base.predict_files() + self.mask.predict_files()

def image(arg, loose=False, **properties):
    """
    :doc: im_image
    :name: Image
    :args: (filename, **properties)

    Loads an image from a file. `filename` is a
    string giving the name of the file.

    `filename` should be a JPEG or PNG file with an appropriate
    extension.
    """

    """
    (Actually, the user documentation is a bit misleading, as
     this tries for compatibility with several older forms of
     image specification.)

    If the loose argument is False, then this will report an error if an
    arbitrary argument is given. If it's True, then the argument is passed
    through unchanged.
    """

    if isinstance(arg, ImageBase):
        return arg

    elif isinstance(arg, basestring):
        return Image(arg, **properties)

    elif isinstance(arg, renpy.display.image.ImageReference):
        arg.find_target()
        return image(arg.target, loose=loose, **properties)

    elif isinstance(arg, tuple):
        params = [ ]

        for i in arg:
            params.append((0, 0))
            params.append(i)

        return Composite(None, *params)

    elif loose:
        return arg

    if isinstance(arg, renpy.display.core.Displayable):
        raise Exception("Expected an image, but got a general displayable.")
    else:
        raise Exception("Could not construct image from argument.")


def load_image(fn):
    """
    This loads an image from the given filename, using the cache.
    """

    surf = cache.get(image(fn))
    return renpy.display.draw.load_texture(surf)

def reset_module():
    print "Resetting cache."

    global cache
    cache = Cache()

########NEW FILE########
__FILENAME__ = image
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains some miscellaneous displayables that involve images.
# Most of the guts of this file have been moved into im.py, with only some
# of the stuff thar uses images remaining.

import renpy.display
import renpy.text
from renpy.display.render import render, Render

import collections

# A map from image name to the displayable object corresponding to that
# image.
images = { }

# A map from image tag to lists of possible attributes for images with that
# tag.
image_attributes = collections.defaultdict(list)


def register_image(name, d):
    """
    Registers the existence of an image with `name`, and that the image
    used displayable d.

    `name`
        A tuple of strings.
    """

    tag = name[0]
    rest = name[1:]

    images[name] = d
    image_attributes[tag].append(rest)


def image_exists(name):
    """
    :doc: image

    Return true if an image with `name` exists, and false if no such image
    exists.

    `name`
        Either a string giving an image name, or a tuple of strings giving
        the name components.
    """

    if not isinstance(name, tuple):
        name = tuple(name.split())

    while name:
        if name in images:
            return True

        name = name[:-1]

    return False


def wrap_render(child, w, h, st, at):
    rend = render(child, w, h, st, at)
    rv = Render(rend.width, rend.height)
    rv.blit(rend, (0, 0))
    return rv

class ImageReference(renpy.display.core.Displayable):
    """
    ImageReference objects are used to reference images by their name,
    which is a tuple of strings corresponding to the name used to define
    the image in an image statment.
    """

    nosave = [ 'target' ]
    target = None
    param_target = None

    def __init__(self, name, **properties):
        """
        @param name: A tuple of strings, the name of the image. Or else
        a displayable, containing the image directly.
        """

        super(ImageReference, self).__init__(**properties)

        self.name = name

    def __eq__(self, o):
        if self is o:
            return True

        if not self._equals(o):
            return False

        if self.name != o.name:
            return False

        return True

    def _get_parameterized(self):
        if self.param_target:
            return self.param_target._get_parameterized()

        return self

    def find_target(self):

        if self.param_target:
            self.target = self.param_target
            return None

        name = self.name

        if isinstance(name, renpy.display.core.Displayable):
            self.target = name
            return True

        if not isinstance(name, tuple):
            name = tuple(name.split())

        parameters = [ ]

        def error(msg):
            self.target = renpy.text.text.Text(msg, color=(255, 0, 0, 255), xanchor=0, xpos=0, yanchor=0, ypos=0)

            if renpy.config.debug:
                raise Exception(msg)


        # Scan through, searching for an image (defined with an
        # input statement) that is a prefix of the given name.
        while name:
            if name in images:
                target = images[name]

                try:
                    self.target = target.parameterize(name, parameters)
                    if self.target is not target:
                        self.param_target = self.target

                except Exception, e:
                    if renpy.config.debug:
                        raise

                    error(str(e))

                return True

            else:
                parameters.insert(0, name[-1])
                name = name[:-1]

        error("Image '%s' not found." % ' '.join(self.name))
        return False

    def parameterize(self, name, parameters):
        if not self.target:
            self.find_target()

        return self.target.parameterize(name, parameters)

    def _hide(self, st, at, kind):
        if not self.target:
            self.find_target()

        return self.target._hide(st, at, kind)

    def set_transform_event(self, event):
        if not self.target:
            self.find_target()

        return self.target.set_transform_event(event)

    def event(self, ev, x, y, st):
        if not self.target:
            self.find_target()

        return self.target.event(ev, x, y, st)

    def render(self, width, height, st, at):
        if not self.target:
            self.find_target()

        return wrap_render(self.target, width, height, st, at)

    def get_placement(self):
        if not self.target:
            self.find_target()

        if not renpy.config.imagereference_respects_position:
            return self.target.get_placement()

        xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel = self.target.get_placement()

        if xpos is None:
            xpos = self.style.xpos

        if ypos is None:
            ypos = self.style.ypos

        if xanchor is None:
            xanchor = self.style.xanchor

        if yanchor is None:
            yanchor = self.style.yanchor

        return xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel

    def visit(self):
        if not self.target:
            self.find_target()

        return [ self.target ]



class ShownImageInfo(renpy.object.Object):
    """
    This class keeps track of which images are being shown right now,
    and what the attributes of those images are. (It's used for a similar
    purpose during prediction, regarding the state in the future.)
    """

    __version__ = 2

    def __init__(self, old=None):
        """
        Creates a new object. If `old` is given, copies the default state
        from old, otherwise initializes the object to a default state.
        """

        if old is None:

            # A map from (layer, tag) -> tuple of attributes
            # This doesn't necessarily correspond to something that is
            # currently showing, as we can remember the state of a tag
            # for use in SideImage.
            self.attributes = { }

            # A set of (layer, tag) pairs that are being shown on the
            # screen right now.
            self.shown = set()

        else:
            self.attributes = old.attributes.copy()
            self.shown = old.shown.copy()


    def after_upgrade(self, version):
        if version < 2:

            self.attributes = { }
            self.shown = set()

            for layer in self.images:
                for tag in self.images[layer]:
                    self.attributes[layer, tag] = self.images[layer][tag][1:]
                    self.shown.add((layer, tag))

    def get_attributes(self, layer, tag):
        """
        Get the attributes associated the image with tag on the given
        layer.
        """

        return self.attributes.get((layer, tag), ())

    def showing(self, layer, name):
        """
        Returns true if name is the prefix of an image that is showing
        on layer, or false otherwise.
        """

        tag = name[0]
        rest = name[1:]

        if (layer, tag) not in self.shown:
            return None

        shown = self.attributes[layer, tag]

        if len(shown) < len(rest):
            return False

        for a, b in zip(shown, rest):
            if a != b:
                return False

        return True

    def predict_scene(self, layer):
        """
        Predicts the scene statement being called on layer.
        """

        for l, t in self.attributes.keys():
            if l == layer:
                del self.attributes[l, t]

        self.shown = set((l, t) for l, t in self.shown if l != layer)

    def predict_show(self, layer, name, show=True):
        """
        Predicts name being shown on layer.

        `show`
            If True, the image will be flagged as being shown to the user. If
            False, only the attributes will be updated.
        """

        tag = name[0]
        rest = name[1:]

        self.attributes[layer, tag] = rest

        if show:
            self.shown.add((layer, tag))

    def predict_hide(self, layer, name):
        tag = name[0]

        if (layer, tag) in self.attributes:
            del self.attributes[layer, tag]

        self.shown.discard((layer, tag))


    def apply_attributes(self, layer, tag, name):
        """
        Given a layer, tag, and an image name (with attributes),
        returns the canonical name of an image, if one exists. Raises
        an exception if it's ambiguious, and returns None if an image
        with that name couldn't be found.
        """

        # If the name matches one that exactly exists, return it.
        if name in images:
            return name

        nametag = name[0]

        # The set of attributes a matching image must have.
        required = set(name[1:])

        # The set of attributes a matching image may have.
        optional = set(self.attributes.get((layer, tag), [ ]))

        # Deal with banned attributes..
        for i in name[1:]:
            if i[0] == "-":
                optional.discard(i[1:])
                required.discard(i)

        return self.choose_image(nametag, required, optional, name)

    def choose_image(self, tag, required, optional, exception_name):
        """
        """

        # The longest length of an image that matches.
        max_len = 0

        # The list of matching images.
        matches = None

        for attrs in image_attributes[tag]:

            num_required = 0

            for i in attrs:
                if i in required:
                    num_required += 1
                    continue

                elif i not in optional:
                    break

            else:

                # We don't have any not-found attributes. But we might not
                # have all of the attributes.

                if num_required != len(required):
                    continue

                len_attrs = len(attrs)

                if len_attrs < max_len:
                    continue

                if len_attrs > max_len:
                    max_len = len_attrs
                    matches = [ ]

                matches.append((tag, ) + attrs)

        if matches is None:
            return None

        if len(matches) == 1:
            return matches[0]

        if exception_name:
            raise Exception("Showing '" + " ".join(exception_name) + "' is ambiguous, possible images include: " + ", ".join(" ".join(i) for i in matches))
        else:
            return None

renpy.display.core.ImagePredictInfo = ShownImageInfo


# Functions that have moved from this module to other modules,
# that live here for the purpose of backward-compatibility.
Image = renpy.display.im.image
Solid = renpy.display.imagelike.Solid
Frame = renpy.display.imagelike.Frame
ImageButton = renpy.display.behavior.ImageButton


########NEW FILE########
__FILENAME__ = imagelike
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
from renpy.display.render import render, Render, Matrix2D

# This file contains displayables that are image-like, because they take
# up a rectangular area of the screen, and do not respond to input.

class Solid(renpy.display.core.Displayable):
    """
    :doc: disp_imagelike

    A displayable that fills the area its assigned with `color`.

    ::

        image white = Solid("#fff")

    """

    def __init__(self, color, **properties):

        super(Solid, self).__init__(**properties)

        if color is not None:
            self.color = renpy.easy.color(color)
        else:
            self.color = None

    def __eq__(self, o):
        if not self._equals(o):
            return False

        return (self.color == o.color)

    def visit(self):
        return [ ]

    def render(self, width, height, st, at):

        color = self.color or self.style.color

        rv = Render(width, height)

        if color is None or width <= 0 or height <= 0:
            return rv

        SIZE = 10

        if width < SIZE or height < SIZE:
            tex = renpy.display.draw.solid_texture(width, height, color)
        else:
            tex = renpy.display.draw.solid_texture(SIZE, SIZE, color)
            rv.forward = Matrix2D(1.0 * SIZE / width, 0, 0, 1.0 * SIZE / height)
            rv.reverse = Matrix2D(1.0 * width / SIZE, 0, 0, 1.0 * height / SIZE)

        rv.blit(tex, (0, 0))

        return rv

class Frame(renpy.display.core.Displayable):
    """
    :doc: disp_imagelike
    :args: (image, left, top, right=None, bottom=None, tile=False, **properties)

    A displayable that resizes an image to fill the available area,
    while preserving the width and height of its borders.  is often
    used as the background of a window or button.

    .. figure:: frame_example.png

        Using a frame to resize an image to double its size.

    `image`
        An image manipulator that will be resized by this frame.

    `left`
        The size of the border on the left side.

    `top`
        The size of the border on the top.

    `right`
        The size of the border on the right side. If None, defaults
        to `left`.

    `bottom`
        The side of the border on the bottom. If None, defaults to `top`.

    `tile`
        If true, tiling is used to resize sections of the image,
        rather than scaling.

    ::

         # Resize the background of the text window if it's too small.
         init python:
             style.window.background = Frame("frame.png", 10, 10)
        """

    __version__ = 1

    def after_upgrade(self, version):
        if version < 2:
            self.left = self.xborder
            self.right = self.xborder
            self.top = self.yborder
            self.bottom = self.yborder

    def __init__(self, image, left=None, top=None, right=None, bottom=None, xborder=None, yborder=None, bilinear=True, tile=False, **properties):
        super(Frame, self).__init__(**properties)

        self.image = renpy.easy.displayable(image)
        self.tile = tile

        # Compat for old argument names.
        if left is None:
            left = xborder
        if top is None:
            top= yborder

        if right is None:
            right = left
        if bottom is None:
            bottom = top

        self.left = left
        self.top = top
        self.right = right
        self.bottom = bottom

    def __eq__(self, o):
        if not self._equals(o):
            return False

        if self.image != o.image:
            return False

        if self.left != o.left:
            return False
        if self.top != o.top:
            return False
        if self.right != o.right:
            return False
        if self.bottom != o.bottom:
            return False

        if self.tile != o.tile:
            return False

    def render(self, width, height, st, at):

        crend = render(self.image, width, height, st, at)

        sw, sh = crend.get_size()
        sw = int(sw)
        sh = int(sh)

        dw = int(width)
        dh = int(height)

        bw = self.left + self.right
        bh = self.top + self.bottom

        xborder = min(bw, sw - 2, dw)
        if xborder:
            left = self.left * xborder / bw
            right = self.right * xborder / bw
        else:
            left = 0
            right = 0

        yborder = min(bh, sh - 2, dh)
        if yborder:
            top = self.top * yborder / bh
            bottom = self.bottom * yborder / bh
        else:
            top = 0
            bottom = 0

        if renpy.display.draw.info["renderer"] == "sw":
            return self.sw_render(crend, dw, dh, left, top, right, bottom)

        def draw(x0, x1, y0, y1):

            # Compute the coordinates of the left, right, top, and
            # bottom sides of the region, for both the source and
            # destination surfaces.

            # left side.
            if x0 >= 0:
                dx0 = x0
                sx0 = x0
            else:
                dx0 = dw + x0
                sx0 = sw + x0

            # right side.
            if x1 > 0:
                dx1 = x1
                sx1 = x1
            else:
                dx1 = dw + x1
                sx1 = sw + x1

            # top side.
            if y0 >= 0:
                dy0 = y0
                sy0 = y0
            else:
                dy0 = dh + y0
                sy0 = sh + y0

            # bottom side
            if y1 > 0:
                dy1 = y1
                sy1 = y1
            else:
                dy1 = dh + y1
                sy1 = sh + y1

            # Quick exit.
            if sx0 == sx1 or sy0 == sy1:
                return

            # Compute sizes.
            csw = sx1 - sx0
            csh = sy1 - sy0
            cdw = dx1 - dx0
            cdh = dy1 - dy0

            if csw <= 0 or csh <= 0 or cdh <= 0 or cdw <= 0:
                return

            # Get a subsurface.
            cr = crend.subsurface((sx0, sy0, csw, csh))

            # Scale or tile if we have to.
            if csw != cdw or csh != cdh:

                if self.tile:
                    newcr = Render(cdw, cdh)
                    newcr.clipping = True

                    for x in xrange(0, cdw, csw):
                        for y in xrange(0, cdh, csh):
                            newcr.blit(cr, (x, y))

                    cr = newcr

                else:

                    newcr = Render(cdw, cdh)
                    newcr.forward = Matrix2D(1.0 * csw / cdw, 0, 0, 1.0 * csh / cdh)
                    newcr.reverse = Matrix2D(1.0 * cdw / csw, 0, 0, 1.0 * cdh / csh)
                    newcr.blit(cr, (0, 0))

                    cr = newcr

            # Blit.
            rv.blit(cr, (dx0, dy0))
            return

        rv = Render(dw, dh)

        self.draw_pattern(draw, left, top, right, bottom)

        return rv

    def draw_pattern(self, draw, left, top, right, bottom):
        # Top row.
        if top:

            if left:
                draw(0, left, 0, top)

            draw(left, -right, 0, top)

            if right:
                draw(-right, 0, 0, top)

        # Middle row.
        if left:
            draw(0, left, top, -bottom)

        draw(left, -right, top, -bottom)

        if right:
            draw(-right, 0, top, -bottom)

        # Bottom row.
        if bottom:
            if left:
                draw(0, left, -bottom, 0)

            draw(left, -right, -bottom, 0)

            if right:
                draw(-right, 0, -bottom, 0)



    def sw_render(self, crend, dw, dh, left, top, right, bottom):

        source = crend.render_to_texture(True)
        sw, sh = source.get_size()

        dest = renpy.display.swdraw.surface(dw, dh, True)
        rv = dest

        def draw(x0, x1, y0, y1):

            # Compute the coordinates of the left, right, top, and
            # bottom sides of the region, for both the source and
            # destination surfaces.

            # left side.
            if x0 >= 0:
                dx0 = x0
                sx0 = x0
            else:
                dx0 = dw + x0
                sx0 = sw + x0

            # right side.
            if x1 > 0:
                dx1 = x1
                sx1 = x1
            else:
                dx1 = dw + x1
                sx1 = sw + x1

            # top side.
            if y0 >= 0:
                dy0 = y0
                sy0 = y0
            else:
                dy0 = dh + y0
                sy0 = sh + y0

            # bottom side
            if y1 > 0:
                dy1 = y1
                sy1 = y1
            else:
                dy1 = dh + y1

                sy1 = sh + y1

            # Quick exit.
            if sx0 == sx1 or sy0 == sy1 or dx1 <= dx0 or dy1 <= dy0:
                return

            # Compute sizes.
            srcsize = (sx1 - sx0, sy1 - sy0)
            dstsize = (int(dx1 - dx0), int(dy1 - dy0))

            # Get a subsurface.
            surf = source.subsurface((sx0, sy0, srcsize[0], srcsize[1]))

            # Scale or tile if we have to.
            if dstsize != srcsize:
                if self.tile:
                    tilew, tileh = srcsize
                    dstw, dsth = dstsize

                    surf2 = renpy.display.pgrender.surface_unscaled(dstsize, surf)

                    for y in range(0, dsth, tileh):
                        for x in range(0, dstw, tilew):
                            surf2.blit(surf, (x, y))

                    surf = surf2

                else:
                    surf2 = renpy.display.scale.real_transform_scale(surf, dstsize)
                    surf = surf2

            # Blit.
            dest.blit(surf, (dx0, dy0))

        self.draw_pattern(draw, left, top, right, bottom)

        rrv = renpy.display.render.Render(dw, dh)
        rrv.blit(rv, (0, 0))
        rrv.depends_on(crend)

        # And, finish up.
        return rrv

    def visit(self):
        return [ self.image ]


class FileCurrentScreenshot(renpy.display.core.Displayable):
    """
    :doc: file_action_function

    A displayable that shows the screenshot that will be saved with the current
    file, if a screenshot has been taken when entering a menu or with
    :func:`FileTakeScreenshot`.

    If there is no current screenshot, `empty` is shown in its place. (If `empty` is
    None, it defaults to :func:`Null`.)
    """

    def __init__(self, empty=None, **properties):

        super(FileCurrentScreenshot, self).__init__(**properties)

        if empty is None:
            empty = renpy.display.layout.Null()

        self.empty = empty


    def render(self, width, height, st, at):

        ss = renpy.display.interface.screenshot_surface

        if ss is None:
            return renpy.display.render.render(self.empty, width, height, st, at)

        tex = renpy.display.draw.load_texture(ss)
        w, h = tex.get_size()

        rv = renpy.display.render.Render(w, h)
        rv.blit(tex, (0, 0))

        return rv


########NEW FILE########
__FILENAME__ = imagemap
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file handles imagemap caching.

import pygame
import renpy.display

from renpy.display.render import render

import hashlib
import os

# A list of cache images we've already written.
cached = set()

class ImageMapCrop(renpy.display.core.Displayable):
    """
    This handles the cropping of uncached imagemap components.
    """

    def __init__(self, child, rect):
        super(ImageMapCrop, self).__init__()

        self.child = child
        self.rect = rect

    def visit(self):
        return [ self.child ]

    def render(self, width, height, st, at):
        cr = render(self.child, width, height, st, at)
        return cr.subsurface(self.rect)


class ImageCacheCrop(renpy.display.core.Displayable):
    """
    This handles the cropping of an imagemap component.
    """

    def __init__(self, cache, index):
        super(ImageCacheCrop, self).__init__()

        # The cache object we're associated with.
        self.cache = cache

        # The index of
        self.index = index

    def visit(self):
        return self.cache.visit(self.index)

    def render(self, width, height, st, at):
        return self.cache.render(self.index, width, height, st, at)

class ImageMapCache(renpy.object.Object):

    def __init__(self, enable):
        self.md5 = hashlib.md5()

        # A list of (image, rect) tuples. The index in this list is used
        # as a unique identifier for an ImageCacheCrop object.
        self.imagerect = [ ]

        # A map from (image, rect) to ImageCacheCrop object.
        self.hotspots = { }

        # A list of (width, height, index) tuples.
        self.areas = [ ]

        # The image containing our children.
        self.cache = None

        # A list that, for each hotspot, gives the rectangle in the cache
        # image corresponding to that hotspot.
        self.cache_rect = None

        # The size of the cache.
        self.cache_width = None
        self.cache_height = None

        self.enable = enable

    def visit(self, index):
        if self.cache is not None:
            return [ self.cache ]
        else:
            return [ self.imagerect[index][0] ]

    def crop(self, d, rect):
        if not isinstance(d, renpy.display.im.ImageBase) or \
                not renpy.config.imagemap_cache or \
                not self.enable:
            return ImageMapCrop(d, rect)

        key = (d, rect)
        rv = self.hotspots.get(key, None)
        if rv is not None:
            return rv

        self.md5.update(repr(d.identity))
        self.md5.update(repr(d.identity))

        index = len(self.imagerect)
        rv = ImageCacheCrop(self, index)

        self.imagerect.append(key)
        self.hotspots[key] = rv
        self.areas.append((rect[2] + 2, rect[3] + 2, index))

        return rv

    def layout(self):
        self.areas.sort()
        self.areas.reverse()
        self.cache_rect = [ None ] * len(self.areas)

        # The width of the cache image.
        width = self.areas[0][0]

        x = 0
        y = 0
        line_height = 0

        for w, h, i in self.areas:

            if x + w > width:
                y += line_height
                line_height = 0
                x = 0

            self.cache_rect[i] = (x+1, y+1, w-2, h-2)

            x += w
            if line_height < h:
                line_height = h

        self.cache_width = width
        self.cache_height = y + line_height

    def write_cache(self, filename):

        if filename in cached:
            return

        cached.add(filename)

        # If all of our dependencies are of the same age or less,
        # we don't need to rebuild the cache.

        if renpy.loader.loadable(filename):
            d_set = set()
            mtime = 0

            for i, rect in self.imagerect:
                if i in d_set:
                    continue

                d_set.add(i)
                mtime = max(i.get_mtime(), mtime)

            if renpy.loader.get_mtime(filename) >= mtime:
                return

        fn = os.path.join(renpy.config.gamedir, filename)
        dir = os.path.dirname(fn) #@ReservedAssignment

        if not os.path.exists(dir):
            os.makedirs(dir)

        cache = pygame.Surface((self.cache_width, self.cache_height), pygame.SRCALPHA, 32)

        for i, (d, rect) in enumerate(self.imagerect):
            x, y, _w, _h = self.cache_rect[i]

            surf = renpy.display.im.cache.get(d).subsurface(rect)
            cache.blit(surf, (x, y))

        pygame.image.save(cache, renpy.exports.fsencode(fn))

    def finish(self):
        if not self.areas:
            return

        filename = "im-%s.png" % (self.md5.hexdigest())

        if renpy.game.preferences.language:
            filename = renpy.game.preferences.language + "-" + filename

        filename = "cache/" + filename

        self.md5 = None

        self.layout()

        if renpy.config.developer:
            try:
                self.write_cache(filename)
            except:
                pass

        if renpy.loader.loadable(filename):
            self.cache = renpy.display.im.Image(filename)


    def render(self, index, width, height, st, at):
        if self.cache is None:
            d, rect = self.imagerect[index]
            return render(d, width, height, st, at).subsurface(rect)

        return render(self.cache, width, height, st, at).subsurface(self.cache_rect[index])

########NEW FILE########
__FILENAME__ = joystick
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file is responsible for joystick support in Ren'Py.

import os
import pygame

import renpy.display

# Do we have a joystick enabled?
enabled = False

# The old states for each axis.
old_axis_states = { }

def init():
    """
    Initialize the joystick system.
    """

    global enabled

    if not renpy.config.joystick:
        return

    if 'RENPY_DISABLE_JOYSTICK' in os.environ:
        return

    try:
        pygame.joystick.init()

        for i in range(0, pygame.joystick.get_count()):
            pygame.joystick.Joystick(i).init()
            enabled = True
    except:
        if renpy.config.debug:
            raise

def event(ev):

    if not enabled:
        return ev

    if ev.type == pygame.JOYAXISMOTION:

        if not renpy.display.interface.focused:
            return None

        if ev.value >= 0.5:
            state = "Positive"
        elif ev.value <= -0.5:
            state = "Negative"
        else:
            state = None

        oldstate = old_axis_states.get((ev.joy, ev.axis), None)

        if state == oldstate:
            return None

        if oldstate:
            release = "Axis %d.%d %s" % (ev.joy, ev.axis, oldstate)
        else:
            release = None

        old_axis_states[ev.joy, ev.axis] = state

        if state:
            press = "Axis %d.%d %s" % (ev.joy, ev.axis, state)
        else:
            press = None

        if not press and not release:
            return None

        return pygame.event.Event(renpy.display.core.JOYEVENT,
                                  press=press, release=release)

    if ev.type == pygame.JOYBUTTONDOWN:

        if not renpy.display.interface.focused:
            return None

        return pygame.event.Event(renpy.display.core.JOYEVENT,
                                  press="Button %d.%d" % (ev.joy, ev.button),
                                  release=None)
    if ev.type == pygame.JOYBUTTONUP:

        if not renpy.display.interface.focused:
            return None

        return pygame.event.Event(renpy.display.core.JOYEVENT,
                                  press=None,
                                  release="Button %d.%d" % (ev.joy, ev.button))

    return ev

class JoyBehavior(renpy.display.layout.Null):
    """
    This is a behavior intended for joystick calibration. If a joystick
    event occurs, this returns it as a string.
    """

    def event(self, ev, x, y, st):
        if ev.type == renpy.display.core.JOYEVENT:
            return ev.press


########NEW FILE########
__FILENAME__ = layout
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains classes that handle layout of displayables on
# the screen.

from renpy.display.render import render, Render
import renpy.display


def scale(num, base):
    """
    If num is a float, multiplies it by base and returns that. Otherwise,
    returns num unchanged.
    """

    if isinstance(num, float):
        return num * base
    else:
        return num

class Null(renpy.display.core.Displayable):
    """
    :doc: disp_imagelike

    A displayable that creates an empty box on the screen. The size
    of the box is controlled by `width` and `height`. This can be used
    when a displayable requires a child, but no child is suitable, or
    as a spacer inside a box.

    ::

        image logo spaced = HBox("logo.png", Null(width=100), "logo.png")

    """

    def __init__(self, width=0, height=0, **properties):
        super(Null, self).__init__(**properties)
        self.width = width
        self.height = height

    def render(self, width, height, st, at):
        rv = renpy.display.render.Render(self.width, self.height)

        if self.focusable:
            rv.add_focus(self, None, None, None, None, None)

        return rv


class Container(renpy.display.core.Displayable):
    """
    This is the base class for containers that can have one or more
    children.

    @ivar children: A list giving the children that have been added to
    this container, in the order that they were added in.

    @ivar child: The last child added to this container. This is also
    used to access the sole child in containers that can only hold
    one child.

    @ivar offsets: A list giving offsets for each of our children.
    It's expected that render will set this up each time it is called.

    @ivar sizes: A list giving sizes for each of our children. It's
    also expected that render will set this each time it is called.

    """

    # We indirect all list creation through this, so that we can
    # use RevertableLists if we want.
    _list_type = list

    def __init__(self, *args, **properties):

        self.children = self._list_type()
        self.child = None
        self.offsets = self._list_type()

        for i in args:
            self.add(i)

        super(Container, self).__init__(**properties)

    def set_style_prefix(self, prefix, root):
        super(Container, self).set_style_prefix(prefix, root)

        for i in self.children:
            i.set_style_prefix(prefix, False)

    def add(self, d):
        """
        Adds a child to this container.
        """

        child = renpy.easy.displayable(d)

        self.children.append(child)

        self.child = child
        self.offsets = self._list_type()

    def _clear(self):
        self.child = None
        self.children = self._list_type()
        self.offsets = self._list_type()

        renpy.display.render.redraw(self, 0)

    def remove(self, d):
        """
        Removes the first instance of child from this container. May
        not work with all containers.
        """

        for i, c in enumerate(self.children):
            if c is d:
                break
        else:
            return

        self.children.pop(i) # W0631
        self.offsets = self._list_type()

        if self.children:
            self.child = self.children[-1]
        else:
            self.child = None


    def update(self):
        """
        This should be called if a child is added to this
        displayable outside of the render function.
        """

        renpy.display.render.invalidate(self)


    def render(self, width, height, st, at):

        rv = Render(width, height)
        self.offsets = self._list_type()

        for c in self.children:
            cr = render(c, width, height, st, at)
            offset = c.place(rv, 0, 0, width, height, cr)
            self.offsets.append(offset)

        return rv


    def event(self, ev, x, y, st):

        children = self.children
        offsets = self.offsets

        for i in xrange(len(offsets) - 1, -1, -1):

            d = children[i]
            xo, yo = offsets[i]

            rv = d.event(ev, x - xo, y - yo, st)
            if rv is not None:
                return rv

        return None

    def visit(self):
        return self.children

    # These interact with the ui functions to allow use as a context
    # manager.

    def __enter__(self):

        renpy.ui.context_enter(self)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):

        renpy.ui.context_exit(self)
        return False




def LiveComposite(size, *args, **properties):
    """
    :args: disp_imagelike

    This creates a new displayable of `size`, by compositing other
    displayables. `size` is a (width, height) tuple.

    The remaining positional arguments are used to place images inside
    the LiveComposite. The remaining positional arguments should come
    in groups of two, with the first member of each group an (x, y)
    tuple, and the second member of a group is a displayable that
    is composited at that position.

    Displayables are composited from back to front.

    ::

       image eileen composite = LiveComposite(
           (300, 600),
           (0, 0), "body.png",
           (0, 0), "clothes.png",
           (50, 50), "expression.png")
    """

    properties.setdefault('style', 'image_placement')

    width, height = size

    rv = Fixed(xmaximum=width, ymaximum=height, xminimum=width, yminimum=height, **properties)

    if len(args) % 2 != 0:
        raise Exception("LiveComposite requires an odd number of arguments.")

    for pos, widget in zip(args[0::2], args[1::2]):
        xpos, ypos = pos
        rv.add(Position(renpy.easy.displayable(widget),
                        xpos=xpos, xanchor=0, ypos=ypos, yanchor=0))

    return rv

class Position(Container):
    """
    Controls the placement of a displayable on the screen, using
    supplied position properties. This is the non-curried form of
    Position, which should be used when the user has directly created
    the displayable that will be shown on the screen.
    """

    def __init__(self, child, style='image_placement', **properties):
        """
        @param child: The child that is being laid out.

        @param style: The base style of this position.

        @param properties: Position properties that control where the
        child of this widget is placed.
        """

        super(Position, self).__init__(style=style, **properties)
        self.add(child)

    def render(self, width, height, st, at):

        surf = render(self.child, width, height, st, at)

        self.offsets = [ (0, 0) ]

        rv = renpy.display.render.Render(surf.width, surf.height)
        rv.blit(surf, (0, 0))

        return rv

    def get_placement(self):

        xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel = self.child.get_placement()

        v = self.style.xpos
        if v is not None:
            xpos = v

        v = self.style.ypos
        if v is not None:
            ypos = v

        v = self.style.xanchor
        if v is not None:
            xanchor = v

        v = self.style.yanchor
        if v is not None:
            yanchor = v

        v = self.style.xoffset
        if v is not None:
            xoffset = v

        v = self.style.yoffset
        if v is not None:
            yoffset = v

        v = self.style.subpixel
        if v is not None:
            subpixel = v

        return xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel


class Grid(Container):
    """
    A grid is a widget that evenly allocates space to its children.
    The child widgets should not be greedy, but should instead be
    widgets that only use part of the space available to them.
    """

    def __init__(self, cols, rows, padding=None,
                 transpose=False,
                 style='grid', **properties):
        """
        @param cols: The number of columns in this widget.

        @params rows: The number of rows in this widget.

        @params transpose: True if the grid should be transposed.
        """

        if padding is not None:
            properties.setdefault('spacing', padding)

        super(Grid, self).__init__(style=style, **properties)

        cols = int(cols)
        rows = int(rows)

        self.cols = cols
        self.rows = rows

        self.transpose = transpose

    def render(self, width, height, st, at):

        # For convenience and speed.
        padding = self.style.spacing
        cols = self.cols
        rows = self.rows

        if len(self.children) != cols * rows:
            if len(self.children) < cols * rows:
                raise Exception("Grid not completely full.")
            else:
                raise Exception("Grid overfull.")

        # If necessary, transpose the grid (kinda hacky, but it works here.)
        if self.transpose:
            self.transpose = False

            old_children = self.children[:]

            for y in range(0, rows):
                for x in range(0, cols):
                    self.children[x + y * cols] = old_children[ y + x * rows ]


        # Now, start the actual rendering.

        renwidth = width
        renheight = height

        if self.style.xfill:
            renwidth = (width - (cols - 1) * padding) / cols
        if self.style.yfill:
            renheight = (height - (rows - 1) * padding) / rows

        renders = [ render(i, renwidth, renheight, st, at) for i in self.children ]
        sizes = [ i.get_size() for i in renders ]

        cwidth = 0
        cheight = 0

        for w, h in sizes:
            cwidth = max(cwidth, w)
            cheight = max(cheight, h)

        if self.style.xfill:
            cwidth = renwidth

        if self.style.yfill:
            cheight = renheight

        width = cwidth * cols + padding * (cols - 1)
        height = cheight * rows + padding * (rows - 1)

        rv = renpy.display.render.Render(width, height)

        self.offsets = [ ]

        for y in range(0, rows):
            for x in range(0, cols):

                child = self.children[ x + y * cols ]
                surf = renders[x + y * cols]

                xpos = x * (cwidth + padding)
                ypos = y * (cheight + padding)

                offset = child.place(rv, xpos, ypos, cwidth, cheight, surf)
                self.offsets.append(offset)

        return rv

class IgnoreLayers(Exception):
    """
    Raise this to have the event ignored by layers, but reach the
    underlay.
    """

    pass

class MultiBox(Container):

    layer_name = None
    first = True
    order_reverse = False

    def __init__(self, spacing=None, layout=None, style='default', **properties):

        if spacing is not None:
            properties['spacing'] = spacing

        super(MultiBox, self).__init__(style=style, **properties)

        self.default_layout = layout

        # The start and animation times for children of this
        # box.
        self.start_times = [ ]
        self.anim_times = [ ]

        # A map from layer name to the widget corresponding to
        # that layer.
        self.layers = None

        # The scene list for this widget.
        self.scene_list = None

    def _clear(self):
        super(MultiBox, self)._clear()

        self.start_times = [ ]
        self.anim_times = [ ]
        self.layers = None
        self.scene_list = None

    def __unicode__(self):
        layout = self.style.box_layout

        if layout is None:
            layout = self.default_layout

        if layout == "fixed":
            return "Fixed"
        elif layout == "horizontal":
            return "HBox"
        elif layout == "vertical":
            return "VBox"
        else:
            return "MultiBox"

    def add(self, widget, start_time=None, anim_time=None): # W0221
        super(MultiBox, self).add(widget)
        self.start_times.append(start_time)
        self.anim_times.append(anim_time)

    def append_scene_list(self, l):

        for sle in l:
            self.add(sle.displayable, sle.show_time, sle.animation_time)

        if self.scene_list is None:
            self.scene_list = [ ]

        self.scene_list.extend(l)

    def render(self, width, height, st, at):

        # Do we need to adjust the child times due to our being a layer?
        if self.layer_name or (self.layers is not None):
            adjust_times = True
        else:
            adjust_times = False

        xminimum = self.style.xminimum
        if xminimum is not None:
            width = max(width, scale(xminimum, width))

        yminimum = self.style.yminimum
        if yminimum is not None:
            height = max(height, scale(yminimum, height))

        if self.first:

            self.first = False

            if adjust_times:

                it = renpy.game.interface.interact_time

                self.start_times = [ i or it for i in self.start_times ]
                self.anim_times = [ i or it for i in self.anim_times ]

            layout = self.style.box_layout

            if layout is None:
                layout = self.default_layout

            self.layout = layout # W0201

        else:
            layout = self.layout


        # Handle time adjustment, store the results in csts and cats.
        if adjust_times:
            t = renpy.game.interface.frame_time

            csts = [ t - start for start in self.start_times ]
            cats = [ t - anim for anim in self.anim_times ]

        else:
            csts = [ st ] * len(self.children)
            cats = [ at ] * len(self.children)

        offsets = [ ]

        if layout == "fixed":

            rv = None

            if self.style.order_reverse:
                iterator = zip(reversed(self.children), reversed(csts), reversed(cats))
            else:
                iterator = zip(self.children, csts, cats)

            for child, cst, cat in iterator:

                surf = render(child, width, height, cst, cat)

                if rv is None:

                    if self.style.fit_first:
                        width, height = surf.get_size()

                    rv = renpy.display.render.Render(width, height, layer_name=self.layer_name)

                if surf:
                    offset = child.place(rv, 0, 0, width, height, surf)
                    offsets.append(offset)
                else:
                    offsets.append((0, 0))

            if rv is None:
                rv = renpy.display.render.Render(width, height, layer_name=self.layer_name)

            if self.style.order_reverse:
                offsets.reverse()

            self.offsets = offsets

            return rv

        # If we're here, we have a box, either horizontal or vertical. Which is good,
        # as we can share some code between boxes.


        spacing = self.style.spacing
        first_spacing = self.style.first_spacing

        if first_spacing is None:
            first_spacing = spacing

        spacings = [ first_spacing ] + [ spacing ] * (len(self.children) - 1)

        box_wrap = self.style.box_wrap

        xfill = self.style.xfill
        yfill = self.style.yfill

        # The shared height and width of the current line. The line_height must
        # be 0 for a vertical box, and the line_width must be 0 for a horizontal
        # box.
        line_width = 0
        line_height = 0

        # The children to layout.
        children = list(self.children)
        if self.style.box_reverse:
            children.reverse()
            spacings.reverse()

        # a list of (child, x, y, w, h, surf) tuples that are turned into
        # calls to child.place().
        placements = [ ]

        # The maximum x and y.
        maxx = 0
        maxy = 0

        def layout_line(line, xfill, yfill):
            """
            Lays out a single line.

            `line` a list of (child, x, y, surf) tuples.
            `xfill` the amount of space to add in the x direction.
            `yfill` the amount of space to add in the y direction.
            """

            xfill = max(0, xfill)
            yfill = max(0, yfill)

            if line:
                xperchild = xfill / len(line)
                yperchild = yfill / len(line)
            else:
                xperchild = 0
                yperchild = 0

            maxxout = maxx
            maxyout = maxy

            for i, (child, x, y, surf) in enumerate(line):
                sw, sh = surf.get_size()
                sw = max(line_width, sw)
                sh = max(line_height, sh)

                x += i * xperchild
                y += i * yperchild

                sw += xperchild
                sh += yperchild

                placements.append((child, x, y, sw, sh, surf))

                maxxout = max(maxxout, x + sw)
                maxyout = max(maxyout, y + sh)

            return maxxout, maxyout

        x = 0
        y = 0

        full_width = False
        full_height = False

        if layout == "horizontal":

            full_height = yfill

            line_height = 0
            line = [ ]
            remwidth = width

            for d, padding, cst, cat in zip(children, spacings, csts, cats):

                if box_wrap:
                    rw = width
                else:
                    rw = remwidth

                surf = render(d, rw, height - y, cst, cat)
                sw, sh = surf.get_size()

                if box_wrap and remwidth - sw - padding <= 0 and line:
                    maxx, maxy = layout_line(line, remwidth if xfill else 0, 0)

                    y += line_height
                    x = 0
                    line_height = 0
                    remwidth = width
                    line = [ ]


                line.append((d, x, y, surf))
                line_height = max(line_height, sh)
                x += sw + padding
                remwidth -= (sw + padding)

            maxx, maxy = layout_line(line, remwidth if xfill else 0, 0)


        elif layout == "vertical":

            full_width = xfill

            line_width = 0
            line = [ ]
            remheight = height

            for d, padding, cst, cat in zip(children, spacings, csts, cats):

                if box_wrap:
                    rh = height
                else:
                    rh = remheight

                surf = render(d, width - x, rh, cst, cat)
                sw, sh = surf.get_size()

                if box_wrap and remheight - sh - padding <= 0:
                    maxx, maxy = layout_line(line, 0, remheight if yfill else 0)

                    x += line_width
                    y = 0
                    line_width = 0
                    remheight = height
                    line = [ ]

                line.append((d, x, y, surf))
                line_width = max(line_width, sw)
                y += sh + padding
                remheight -= (sh + padding)

            maxx, maxy = layout_line(line, 0, remheight if yfill else 0)

        # Back to the common for vertical and horizontal.

        if not xfill:
            width = maxx

        if not yfill:
            height = maxy

        rv = renpy.display.render.Render(width, height)

        if self.style.box_reverse ^ self.style.order_reverse:
            placements.reverse()

        for child, x, y, w, h, surf in placements:
            if full_width:
                w = width
            if full_height:
                h = height

            offset = child.place(rv, x, y, w, h, surf)
            offsets.append(offset)

        if self.style.order_reverse:
            offsets.reverse()

        self.offsets = offsets

        return rv


    def event(self, ev, x, y, st):


        children_offsets = zip(self.children, self.offsets, self.start_times)

        if not self.style.order_reverse:
            children_offsets.reverse()

        try:

            for i, (xo, yo), t in children_offsets:

                if t is None:
                    cst = st
                else:
                    cst = renpy.game.interface.event_time - t

                rv = i.event(ev, x - xo, y - yo, cst)
                if rv is not None:
                    return rv

        except IgnoreLayers:
            if self.layers:
                return None
            else:
                raise

        return None

def Fixed(**properties):
    return MultiBox(layout='fixed', **properties)

class SizeGroup(renpy.object.Object):

    def __init__(self):

        super(SizeGroup, self).__init__()

        self.members = [ ]
        self._width = None
        self.computing_width = False

    def width(self, width, height, st, at):
        if self._width is not None:
            return self._width

        if self.computing_width:
            return 0

        self.computing_width = True

        maxwidth = 0

        for i in self.members:
            rend = renpy.display.render.render(i, width, height, st, at)
            maxwidth = max(rend.width, maxwidth)
            renpy.display.render.invalidate(i)

        self._width = maxwidth
        self.computing_width = False

        return maxwidth


size_groups = dict()

class Window(Container):
    """
    A window that has padding and margins, and can place a background
    behind its child. `child` is the child added to this
    displayable. All other properties are as for the :ref:`Window`
    screen language statement.
    """

    def __init__(self, child=None, style='window', **properties):
        super(Window, self).__init__(style=style, **properties)
        if child is not None:
            self.add(child)

    def visit(self):
        return [ self.style.background ] + self.children

    def get_child(self):
        return self.style.child or self.child

    def per_interact(self):
        size_group = self.style.size_group

        if size_group:
            group = size_groups.get(size_group, None)
            if group is None:
                group = size_groups[size_group] = SizeGroup()

            group.members.append(self)

    def predict_one(self):
        pd = renpy.display.predict.displayable
        self.style._predict_window(pd)

    def render(self, width, height, st, at):

        # save some typing.
        style = self.style

        xminimum = scale(style.xminimum, width)
        yminimum = scale(style.yminimum, height)

        size_group = self.style.size_group
        if size_group and size_group in size_groups:
            xminimum = max(xminimum, size_groups[size_group].width(width, height, st, at))

        left_margin = scale(style.left_margin, width)
        left_padding = scale(style.left_padding, width)

        right_margin = scale(style.right_margin, width)
        right_padding = scale(style.right_padding, width)

        top_margin = scale(style.top_margin, height)
        top_padding = scale(style.top_padding, height)

        bottom_margin = scale(style.bottom_margin, height)
        bottom_padding = scale(style.bottom_padding, height)

        # c for combined.
        cxmargin = left_margin + right_margin
        cymargin = top_margin + bottom_margin

        cxpadding = left_padding + right_padding
        cypadding = top_padding + bottom_padding

        child = self.get_child()

        # Render the child.
        surf = render(child,
                      width  - cxmargin - cxpadding,
                      height - cymargin - cypadding,
                      st, at)

        sw, sh = surf.get_size()

        # If we don't fill, shrink our size to fit.

        if not style.xfill:
            width = max(cxmargin + cxpadding + sw, xminimum)

        if not style.yfill:
            height = max(cymargin + cypadding + sh, yminimum)

        rv = renpy.display.render.Render(width, height)

        # Draw the background. The background should render at exactly the
        # requested size. (That is, be a Frame or a Solid).
        if style.background:
            bw = width - cxmargin
            bh = height - cymargin

            back = render(style.background, bw, bh, st, at)

            style.background.place(rv, left_margin, top_margin, bw, bh, back, main=False)

        offsets = child.place(rv,
                              left_margin + left_padding,
                              top_margin + top_padding,
                              width  - cxmargin - cxpadding,
                              height - cymargin - cypadding,
                              surf)

        # Draw the foreground. The background should render at exactly the
        # requested size. (That is, be a Frame or a Solid).
        if style.foreground:
            bw = width  - cxmargin
            bh = height - cymargin

            back = render(style.foreground, bw, bh, st, at)

            style.foreground.place(rv, left_margin, top_margin, bw, bh, back, main=False)

        if self.child:
            self.offsets = [ offsets ]

        self.window_size = width, height # W0201

        return rv


def dynamic_displayable_compat(st, at, expr):
    child = renpy.python.py_eval(expr)
    return child, None

class DynamicDisplayable(renpy.display.core.Displayable):
    """
    :doc: disp_dynamic

    A displayable that can change its child based on a Python
    function, over the course of an interaction.

    `function`
        A function that is called with the arguments:

        * The amount of time the displayable has been shown for.
        * The amount of time any displayable with the same tag has been shown for.
        * Any positional or keyword arguments supplied to DynamicDisplayable.

        and should return a (d, redraw) tuple, where:

        * `d` is a displayable to show.
        * `redraw` is the amount of time to wait before calling the
          function again, or None to not call the function again
          before the start of the next interaction.

        `function` is called at the start of every interaction.

    As a special case, `function` may also be a python string that evaluates
    to a displayable. In that case, function is run once per interaction.

    ::

        # If tooltip is not empty, shows it in a text. Otherwise,
        # show Null. Checks every tenth of a second to see if the
        # tooltip has been updated.
        init python:
             def show_tooltip(st, at):
                 if tooltip:
                     return tooltip, .1
                 else:
                     return Null()

        image tooltipper = DynamicDisplayable(show_tooltip)

    """

    nosave = [ 'child' ]

    def after_setstate(self):
        self.child = None

    def __init__(self, function, *args, **kwargs):

        super(DynamicDisplayable, self).__init__()
        self.child = None

        if isinstance(function, basestring):
            args = ( function, )
            kwargs = { }
            function = dynamic_displayable_compat

        self.predict_function = kwargs.pop("_predict_function", None)
        self.function = function
        self.args = args
        self.kwargs = kwargs
        self.st = 0
        self.at = 0

    def visit(self):
        return [ ]

    def per_interact(self):
        child, _ = self.function(self.st, self.at, *self.args, **self.kwargs)
        child = renpy.easy.displayable(child)
        child.visit_all(lambda a : a.per_interact())

        if child is not self.child:
            renpy.display.render.redraw(self, 0)
            self.child = child

    def render(self, w, h, st, at):

        self.st = st
        self.at = at

        child, redraw = self.function(st, at, *self.args, **self.kwargs)
        child = renpy.easy.displayable(child)
        child.visit_all(lambda c : c.per_interact())

        self.child = child

        if redraw is not None:
            renpy.display.render.redraw(self, redraw)

        return renpy.display.render.render(self.child, w, h, st, at)

    def predict_one(self):
        if not self.predict_function:
            return

        for i in self.predict_function(*self.args, **self.kwargs):
            if i is not None:
                renpy.display.predict.displayable(i)

    def get_placement(self):
        if not self.child:
            self.per_interact()

        return self.child.get_placement()


    def event(self, ev, x, y, st):
        if self.child:
            return self.child.event(ev, x, y, st)

# A cache of compiled conditions used by ConditionSwitch.
cond_cache = { }

# This chooses the first member of switch that's being shown on the
# given layer.
def condition_switch_pick(switch):
    for cond, d in switch:

        if cond is None:
            return d

        if cond in cond_cache:
            code = cond_cache[cond]
        else:
            code = renpy.python.py_compile(cond, 'eval')
            cond_cache[cond] = code

        if renpy.python.py_eval_bytecode(code):
            return d

    raise Exception("Switch could not choose a displayable.")

def condition_switch_show(st, at, switch):
    return condition_switch_pick(switch), None

def condition_switch_predict(switch):

    if renpy.game.lint:
        return [ d for _cond, d in switch ]

    return [ condition_switch_pick(switch) ]

def ConditionSwitch(*args, **kwargs):
    """
    :doc: disp_dynamic

    This is a displayable that changes what it is showing based on
    python conditions. The positional argument should be given in
    groups of two, where each group consists of:

    * A string containing a python condition.
    * A displayable to use if the condition is true.

    The first true condition has its displayable shown, at least
    one condition should always be true.

    ::

        image jill = ConditionSwitch(
            "jill_beers > 4", "jill_drunk.png",
            "True", "jill_sober.png")
    """

    kwargs.setdefault('style', 'default')

    switch = [ ]

    if len(args) % 2 != 0:
        raise Exception('ConditionSwitch takes an even number of arguments')

    for cond, d in zip(args[0::2], args[1::2]):

        if cond not in cond_cache:
            code = renpy.python.py_compile(cond, 'eval')
            cond_cache[cond] = code

        d = renpy.easy.displayable(d)
        switch.append((cond, d))

    rv = DynamicDisplayable(condition_switch_show,
                            switch,
                            _predict_function=condition_switch_predict)

    return Position(rv, **kwargs)


def ShowingSwitch(*args, **kwargs):
    """
    :doc: disp_dynamic

    This is a displayable that changes what it is showing based on the
    images are showing on the screen. The positional argument should
    be given in groups of two, where each group consists of:

    * A string giving an image name, or None to indicate the default.
    * A displayable to use if the condition is true.

    A default image should be specified.

    One use of ShowingSwitch is to have side images change depending on
    the current emotion of a character. For example::

       define e = Character("Eileen",
           show_side_image=ShowingSwitch(
               "eileen happy", Image("eileen_happy_side.png", xalign=1.0, yalign=1.0),
               "eileen vhappy", Image("eileen_vhappy_side.png", xalign=1.0, yalign=1.0),
               None, Image("eileen_happy_default.png", xalign=1.0, yalign=1.0),
               )
           )
    """

    layer = kwargs.pop('layer', 'master')

    if len(args) % 2 != 0:
        raise Exception('ShowingSwitch takes an even number of positional arguments')

    condargs = [ ]


    for name, d in zip(args[0::2], args[1::2]):
        if name is not None:
            if not isinstance(name, tuple):
                name = tuple(name.split())
            cond = "renpy.showing(%r, layer=%r)" % (name, layer)
        else:
            cond = None


        condargs.append(cond)
        condargs.append(d)

    return ConditionSwitch(*condargs, **kwargs)


class IgnoresEvents(Container):

    def __init__(self, child, **properties):
        super(IgnoresEvents, self).__init__(**properties)
        self.add(child)

    def render(self, w, h, st, at):
        cr = renpy.display.render.render(self.child, w, h, st, at)
        cw, ch = cr.get_size()
        rv = renpy.display.render.Render(cw, ch)
        rv.blit(cr, (0, 0), focus=False)

        return rv

    def get_placement(self):
        return self.child.get_placement()

    # Ignores events.
    def event(self, ev, x, y, st):
        return None

def edgescroll_proportional(n):
    """
    An edgescroll function that causes the move speed to be proportional
    from the edge distance.
    """
    return n

class Viewport(Container):

    __version__ = 3

    def after_upgrade(self, version):
        if version < 1:
            self.xadjustment = renpy.display.behavior.Adjustment(1, 0)
            self.yadjustment = renpy.display.behavior.Adjustment(1, 0)
            self.set_adjustments = False
            self.mousewheel = False
            self.draggable = False
            self.width = 0
            self.height = 0

        if version < 2:
            self.drag_position = None

        if version < 3:
            self.edge_size = False
            self.edge_speed = False
            self.edge_function = None
            self.edge_xspeed = 0
            self.edge_yspeed = 0
            self.edge_last_st = None

        if version < 4:
            self.xadjustment_param = None
            self.yadjustment_param = None
            self.offsets_param = (None, None)
            self.set_adjustments_param = True
            self.xinitial_param = None
            self.yinitial_param = None


    def __init__(self,
                 child=None,
                 child_size=(None, None),
                 offsets=(None, None),
                 xadjustment=None,
                 yadjustment=None,
                 set_adjustments=True,
                 mousewheel=False,
                 draggable=False,
                 edgescroll=None,
                 style='viewport',
                 xinitial=None,
                 yinitial=None,
                 replaces=None,
                 **properties):

        super(Viewport, self).__init__(style=style, **properties)
        if child is not None:
            self.add(child)

        self.xadjustment_param = xadjustment
        self.yadjustment_param = yadjustment
        self.offsets_param = offsets
        self.set_adjustments_param = set_adjustments
        self.xinitial_param = xinitial
        self.yinitial_param = yinitial

        self._show()

        if isinstance(replaces, Viewport):
            self.xadjustment.range = replaces.xadjustment.range
            self.yadjustment.range = replaces.yadjustment.range
            self.xadjustment.value = replaces.xadjustment.value
            self.yadjustment.value = replaces.yadjustment.value
            self.xoffset = replaces.xoffset
            self.yoffset = replaces.yoffset
            self.drag_position = replaces.drag_position
        else:
            self.drag_position = None

        self.child_width, self.child_height = child_size

        self.mousewheel = mousewheel
        self.draggable = draggable

        self.width = 0
        self.height = 0

        # The speed at which we scroll in the x and y directions, in pixels
        # per second.
        self.edge_xspeed = 0
        self.edge_yspeed = 0

        # The last time we edgescrolled.
        self.edge_last_st = None

        if edgescroll is not None:

            # The size of the edges that trigger scrolling.
            self.edge_size = edgescroll[0]

            # How far from the edge we can scroll.
            self.edge_speed = edgescroll[1]

            if len(edgescroll) >= 3:
                self.edge_function = edgescroll[2]
            else:
                self.edge_function = edgescroll_proportional

        else:
            self.edge_size = 0
            self.edge_speed = 0
            self.edge_function = edgescroll_proportional

    def _show(self):
        if self.xadjustment_param is None:
            self.xadjustment = renpy.display.behavior.Adjustment(1, 0)
        else:
            self.xadjustment = self.xadjustment_param

        if self.yadjustment_param is None:
            self.yadjustment = renpy.display.behavior.Adjustment(1, 0)
        else:
            self.yadjustment = self.yadjustment_param

        if self.xadjustment.adjustable is None:
            self.xadjustment.adjustable = True

        if self.yadjustment.adjustable is None:
            self.yadjustment.adjustable = True

        self.set_adjustments = self.set_adjustments_param

        offsets = self.offsets_param
        self.xoffset = offsets[0] if (offsets[0] is not None) else self.xinitial_param
        self.yoffset = offsets[1] if (offsets[1] is not None) else self.yinitial_param

    def per_interact(self):
        self.xadjustment.register(self)
        self.yadjustment.register(self)

    def render(self, width, height, st, at):

        self.width = width
        self.height = height

        child_width = self.child_width or width
        child_height = self.child_height or height

        surf = render(self.child, child_width, child_height, st, at)

        cw, ch = surf.get_size()

        if not self.style.xfill:
            width = min(cw, width)

        if not self.style.yfill:
            height = min(ch, height)

        if self.set_adjustments:
            self.xadjustment.range = max(cw - width, 0)
            self.xadjustment.page = width
            self.yadjustment.range = max(ch - height, 0)
            self.yadjustment.page = height

        if self.xoffset is not None:
            if isinstance(self.xoffset, int):
                value = self.xoffset
            else:
                value = max(cw - width, 0) * self.xoffset

            self.xadjustment.value = value

        if self.yoffset is not None:
            if isinstance(self.yoffset, int):
                value = self.yoffset
            else:
                value = max(ch - height, 0) * self.yoffset

            self.yadjustment.value = value

        if self.edge_size and self.edge_last_st and (self.edge_xspeed or self.edge_yspeed):

            duration = max(st - self.edge_last_st, 0)
            self.xadjustment.change(self.xadjustment.value + duration * self.edge_xspeed)
            self.yadjustment.change(self.yadjustment.value + duration * self.edge_yspeed)

            self.check_edge_redraw()

        self.edge_last_st = st

        cxo = -int(self.xadjustment.value)
        cyo = -int(self.yadjustment.value)

        self.offsets = [ (cxo, cyo) ]

        rv = renpy.display.render.Render(width, height)
        rv.blit(surf, (cxo, cyo))

        return rv

    def check_edge_redraw(self):
        redraw = False

        if (self.edge_xspeed > 0) and (self.xadjustment.value < self.xadjustment.range):
            redraw = True
        if (self.edge_xspeed < 0) and (self.xadjustment.value > 0):
            redraw = True

        if (self.edge_yspeed > 0) and (self.yadjustment.value < self.yadjustment.range):
            redraw = True
        if (self.edge_yspeed < 0) and (self.yadjustment.value > 0):
            redraw = True

        if redraw:
            renpy.display.render.redraw(self, 0)


    def event(self, ev, x, y, st):

        self.xoffset = None
        self.yoffset = None

        rv = super(Viewport, self).event(ev, x, y, st)
        if rv is not None:
            return rv

        if self.draggable and renpy.display.focus.get_grab() == self:

            oldx, oldy = self.drag_position
            dx = x - oldx
            dy = y - oldy

            self.xadjustment.change(self.xadjustment.value - dx)
            self.yadjustment.change(self.yadjustment.value - dy)

            self.drag_position = (x, y) # W0201

            if renpy.display.behavior.map_event(ev, 'viewport_drag_end'):
                renpy.display.focus.set_grab(None)
                raise renpy.display.core.IgnoreEvent()

        if not ((0 <= x < self.width) and (0 <= y <= self.height)):
            return

        if self.mousewheel:

            if renpy.display.behavior.map_event(ev, 'viewport_up'):
                rv = self.yadjustment.change(self.yadjustment.value - self.yadjustment.step)
                if rv is not None:
                    return rv
                else:
                    raise renpy.display.core.IgnoreEvent()

            if renpy.display.behavior.map_event(ev, 'viewport_down'):
                rv = self.yadjustment.change(self.yadjustment.value + self.yadjustment.step)
                if rv is not None:
                    return rv
                else:
                    raise renpy.display.core.IgnoreEvent()

        if self.draggable:

            if renpy.display.behavior.map_event(ev, 'viewport_drag_start'):
                self.drag_position = (x, y)
                renpy.display.focus.set_grab(self)
                raise renpy.display.core.IgnoreEvent()

        if self.edge_size:

            def speed(n, zero, one):
                """
                Given a position `n`, computes the speed. The speed is 0.0
                when `n` == `zero`, 1.0 when `n` == `one`, and linearly
                interpolated when between.

                Returns 0.0 when outside the bounds - in either direction.
                """

                n = 1.0 * (n - zero) / (one - zero)
                if n < 0.0:
                    return 0.0
                if n > 1.0:
                    return 0.0

                return n

            xspeed = speed(x, self.width - self.edge_size, self.width)
            xspeed -= speed(x, self.edge_size, 0)
            self.edge_xspeed = self.edge_speed * self.edge_function(xspeed)

            yspeed = speed(y, self.height - self.edge_size, self.height)
            yspeed -= speed(y, self.edge_size, 0)
            self.edge_yspeed = self.edge_speed * self.edge_function(yspeed)

            if xspeed or yspeed:
                self.check_edge_redraw()
                if self.edge_last_st is None:
                    self.edge_last_st = st
            else:
                self.edge_last_st = None

        return None

    def set_xoffset(self, offset):
        self.xoffset = offset
        renpy.display.render.redraw(self, 0)

    def set_yoffset(self, offset):
        self.yoffset = offset
        renpy.display.render.redraw(self, 0)

def LiveCrop(rect, child, **properties):
    """
    :doc: disp_imagelike

    This created a displayable by cropping `child` to `rect`, where
    `rect` is an (x, y, width, height) tuple. ::

        image eileen cropped = LiveCrop((0, 0, 300, 300), "eileen happy")
    """

    x, y, w, h = rect

    return Viewport(child, offsets=(x, y), xmaximum=w, ymaximum=h, **properties)

class Side(Container):

    possible_positions = set([ 'tl', 't', 'tr', 'r', 'br', 'b', 'bl', 'l', 'c'])

    def after_setstate(self):
        self.sized = False

    def __init__(self, positions, style='side', **properties):

        super(Side, self).__init__(style=style, **properties)

        if isinstance(positions, basestring):
            positions = positions.split()

        for i in positions:
            if not i in Side.possible_positions:
                raise Exception("Side used with impossible position '%s'." % (i,))

        self.positions = tuple(positions)
        self.sized = False

    def _clear(self):
        super(Side, self)._clear()
        self.sized = False

    def render(self, width, height, st, at):

        pos_d = { }
        pos_i = { }

        for i, (pos, d) in enumerate(zip(self.positions, self.children)):
            pos_d[pos] = d
            pos_i[pos] = i

        # Figure out the size of each widget (and hence where the
        # widget needs to be placed).

        if not self.sized:
            self.sized = True

            # Deal with various spacings.
            spacing = self.style.spacing

            def spacer(a, b, c, axis):
                if (a in pos_d) or (b in pos_d) or (c in pos_d):
                    return spacing, axis - spacing
                else:
                    return 0, axis

            self.left_space, width = spacer('tl', 'l', 'bl', width) # W0201
            self.right_space, width = spacer('tr', 'r', 'br', width) # W0201
            self.top_space, height = spacer('tl', 't', 'tr', height) # W0201
            self.bottom_space, height = spacer('bl', 'b', 'br', height) # W0201

            # The sizes of the various borders.
            left = 0
            right = 0
            top = 0
            bottom = 0
            cwidth = 0
            cheight = 0

            def sizeit(pos, width, height, owidth, oheight):
                if pos not in pos_d:
                    return owidth, oheight

                rend = render(pos_d[pos], width, height, st, at)
                rv = max(owidth, rend.width), max(oheight, rend.height)
                rend.kill()
                return rv

            cwidth, cheight = sizeit('c', width, height, 0, 0)
            cwidth, top = sizeit('t', cwidth, height, cwidth, top)
            cwidth, bottom = sizeit('b', cwidth, height, cwidth, bottom)
            left, cheight = sizeit('l', width, cheight, left, cheight)
            right, cheight = sizeit('r', width, cheight, right, cheight)

            left, top = sizeit('tl', left, top, left, top)
            left, bottom = sizeit('bl', left, bottom, left, bottom)
            right, top = sizeit('tr', right, top, right, top)
            right, bottom = sizeit('br', right, bottom, right, bottom)

            self.cwidth = cwidth # W0201
            self.cheight = cheight # W0201

            self.top = top # W0201
            self.bottom = bottom # W0201
            self.left = left # W0201
            self.right = right # W0201

        else:
            cwidth = self.cwidth
            cheight = self.cheight
            top = self.top
            bottom = self.bottom
            left = self.left
            right = self.right

        # Now, place everything onto the render.

        self.offsets = [ None ] * len(self.children)

        lefts = self.left_space
        rights = self.right_space
        tops = self.top_space
        bottoms = self.bottom_space


        cwidth = min(cwidth, width - left - lefts - right - rights)
        cheight = min(cheight, height - top - tops - bottom - bottoms)

        rv = renpy.display.render.Render(left + lefts + cwidth + rights + right,
                                         top + tops + cheight + bottoms + bottom)

        def place(pos, x, y, w, h):

            if pos not in pos_d:
                return

            d = pos_d[pos]
            i = pos_i[pos]
            rend = render(d, w, h, st, at)
            self.offsets[i] = pos_d[pos].place(rv, x, y, w, h, rend)

        col1 = 0
        col2 = left + lefts
        col3 = left + lefts + cwidth + rights

        row1 = 0
        row2 = top + tops
        row3 = top + tops + cheight + bottoms

        place('c', col2, row2, cwidth, cheight)

        place('t', col2, row1, cwidth, top)
        place('r', col3, row2, right, cheight)
        place('b', col2, row3, cwidth, bottom)
        place('l', col1, row2, left, cheight)

        place('tl', col1, row1, left, top)
        place('tr', col3, row1, right, top)
        place('br', col3, row3, right, bottom)
        place('bl', col1, row3, left, bottom)

        return rv

class Alpha(renpy.display.core.Displayable):
    def __init__(self, start, end, time, child=None, repeat=False, bounce=False,
                 anim_timebase=False, time_warp=None, **properties):

        super(Alpha, self).__init__(**properties)

        self.start = start
        self.end = end
        self.time = time
        self.child = renpy.easy.displayable(child)
        self.repeat = repeat
        self.anim_timebase = anim_timebase
        self.time_warp = time_warp

    def visit(self):
        return [ self.child ]

    def render(self, height, width, st, at):
        if self.anim_timebase:
            t = at
        else:
            t = st

        if self.time:
            done = min(t / self.time, 1.0)
        else:
            done = 1.0

        if renpy.game.less_updates:
            done = 1.0
        elif self.repeat:
            done = done % 1.0
            renpy.display.render.redraw(self, 0)
        elif done != 1.0:
            renpy.display.render.redraw(self, 0)

        if self.time_warp:
            done = self.time_warp(done)

        alpha = self.start + done * (self.end - self.start)

        rend = renpy.display.render.render(self.child, height, width, st, at)

        w, h = rend.get_size()
        rv = renpy.display.render.Render(w, h)
        rv.blit(rend, (0, 0))
        rv.alpha = alpha

        return rv


class AdjustTimes(Container):

    def __init__(self, child, start_time, anim_time, **properties):
        super(AdjustTimes, self).__init__(**properties)

        self.start_time = start_time
        self.anim_time = anim_time

        self.add(child)

    def render(self, w, h, st, at):

        if self.start_time is None:
            self.start_time = renpy.game.interface.frame_time

        if self.anim_time is None:
            self.anim_time = renpy.game.interface.frame_time

        st = renpy.game.interface.frame_time - self.start_time
        at = renpy.game.interface.frame_time - self.anim_time

        cr = renpy.display.render.render(self.child, w, h, st, at)
        cw, ch = cr.get_size()
        rv = renpy.display.render.Render(cw, ch)
        rv.blit(cr, (0, 0))

        self.offsets = [ (0, 0) ]

        return rv

    def get_placement(self):
        return self.child.get_placement()


class LiveTile(Container):
    """
    :doc: disp_imagelike

    Tiles `child` until it fills the area allocated to this displayable.

    ::

        image bg tile = LiveTile("bg.png")

    """

    def __init__(self, child, style='tile', **properties):
        super(LiveTile, self).__init__(style=style, **properties)

        self.add(child)

    def render(self, width, height, st, at):

        cr = renpy.display.render.render(self.child, width, height, st, at)
        cw, ch = cr.get_size()
        rv = renpy.display.render.Render(width, height)

        width = int(width)
        height = int(height)
        cw = int(cw)
        ch = int(ch)

        for y in range(0, height, ch):
            for x in range(0, width, cw):
                rv.blit(cr, (x, y), focus=False)

        return rv


class Flatten(Container):
    """
    :doc: disp_imagelike

    This flattens `child`, which may be made up of multiple textures, into
    a single texture.

    Certain operations, like the alpha transform property, apply to every
    texture making up a displayable, which can yield incorrect results
    when the textures overlap on screen. Flatten creates a single texture
    from multiple textures, which can prevent this problem.

    Flatten is a relatively expensive operation, and so should only be used
    when absolutely required.
    """


    def __init__(self, child, **properties):
        super(Flatten, self).__init__(**properties)

        self.add(child)

    def render(self, width, height, st, at):
        cr = renpy.display.render.render(self.child, width, height, st, at)
        cw, ch = cr.get_size()

        tex = cr.render_to_texture(True)

        rv = renpy.display.render.Render(cw, ch)
        rv.blit(tex, (0, 0))
        rv.depends_on(cr, focus=True)

        return rv

########NEW FILE########
__FILENAME__ = minigame
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


def Minigame(*args, **kwargs):
    raise Exception("Minigame is no longer implemented.")


########NEW FILE########
__FILENAME__ = module
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file mediates access to the _renpy module, which is a C module that
# allows us to enhance the feature set of pygame in a renpy specific way.

import pygame; pygame
import renpy.display
import _renpy

import sys

def convert_and_call(function, src, dst, *args):
    """
    This calls the function with the source and destination
    surface. The surfaces must have the same alpha.

    If the surfaces are not 24 or 32 bits per pixel, or don't have the
    same format, they are converted and then converted back.
    """

    # Now that all surfaces are 32bpp, this function doesn't do much
    # of anything anymore.

    if (dst.get_masks()[3] != 0) != (src.get_masks()[3] != 0):
        raise Exception("Surface alphas do not match.")

    function(src, dst, *args)


def pixellate(src, dst, avgwidth, avgheight, outwidth, outheight):
    """
    This pixellates the source surface. First, every pixel in the
    source surface is projected onto a virtual surface, such that
    the average value of every avgwidth x avgheight pixels becomes
    one virtual pixel. It then gets projected back onto the
    destination surface at a ratio of one virtual pixel to every
    outwidth x outheight destination pixels.

    If either src or dst is not a 24 or 32 bit surface, they are
    converted... but that may be a significant performance hit.

    The two surfaces must either have the same alpha or no alpha.
    """

    convert_and_call(_renpy.pixellate,
                     src, dst,
                     avgwidth, avgheight,
                     outwidth, outheight)


def scale(s, size):
    """
    Scales down the supplied pygame surface by the given X and Y
    factors.

    Always works, but may not be high quality.
    """

    d = renpy.display.pgrender.surface(size, True)

    bilinear_scale(s, d)

    return d


# What we have here are a pair of tables mapping masks to byte offsets
# for 24 and 32 bpp modes. We represent 0xff000000 as positive and negative
# numbers so that it doesn't yield a warning, and so that it works on
# 32 and 64 bit platforms.
if sys.byteorder == 'big':
    bo32 = { 255 : 3, 65280 : 2, 16711680 : 1, 4278190080 : 0, -16777216 : 0, }
else:
    bo32 = { 255 : 0, 65280 : 1, 16711680 : 2, 4278190080 : 3, -16777216 : 3, }

bo_cache = None

def byte_offset(src):
    """
    Given the surface src, returns a 4-tuple giving the byte offsets
    for the red, green, blue, and alpha components of the pixels in
    the surface. If a component doesn't exist, None is returned.
    """

    global bo_cache

    if bo_cache is None:
        bo_cache = [ bo32[i] for i in src.get_masks() ]

    return bo_cache

def endian_order(src, r, g, b, a):

    if bo_cache is None:
        byte_offset(src)

    rv = [ a, a, a, a ]

    for i, index_i in zip((r, g, b, a), bo_cache):
        rv[index_i] = i

    return rv



def linmap(src, dst, rmap, gmap, bmap, amap):
    """
    This maps the colors between two surfaces. The various map
    parameters should be fixed-point integers, with 1.0 == 256.
    """

    convert_and_call(_renpy.linmap,
                     src, dst,
                     *endian_order(dst, rmap, gmap, bmap, amap))


save_png = _renpy.save_png

def map(src, dst, rmap, gmap, bmap, amap): #@ReservedAssignment
    """
    This maps the colors between two surfaces. The various map
    parameters must be 256 character long strings, with the value
    of a character at a given offset being what a particular pixel
    component value is mapped to.
    """

    convert_and_call(_renpy.map,
                     src, dst,
                     *endian_order(dst, rmap, gmap, bmap, amap))



def twomap(src, dst, white, black):
    """
    Given colors for white and black, linearly maps things
    appropriately, taking the alpha channel from white.
    """

    wr = white[0]
    wg = white[1]
    wb = white[2]
    wa = white[3]

    br = black[0]
    bg = black[1]
    bb = black[2]

    ramp = renpy.display.im.ramp

    if br == 0 and bg == 0 and bb == 0:
        linmap(src, dst,
               wr + 1,
               wg + 1,
               wb + 1,
               wa + 1)
    else:
        map(src, dst,
            ramp(br, wr),
            ramp(bg, wg),
            ramp(bb, wb),
            ramp(0, wa))


def alpha_munge(src, dst, amap):
    """
    This samples the red channel from src, maps it through amap, and
    place it into the alpha channel of amap.
    """

    if src.get_size() != dst.get_size():
        return

    red = byte_offset(src)[0]
    alpha = byte_offset(dst)[3]

    if red is not None and alpha is not None:
        _renpy.alpha_munge(src, dst, red, alpha, amap)


def bilinear_scale(src, dst, sx=0, sy=0, sw=None, sh=None, dx=0, dy=0, dw=None, dh=None, precise=0):

    if sw is None:
        sw, sh = src.get_size()
    if dw is None:
        dw, dh = dst.get_size()

    while True:

        if sw <= dw * 2 and sh <= dh * 2:
            break

        nsw = max(sw / 2, dw)
        nsh = max(sh / 2, dh)

        nsrc = renpy.display.pgrender.surface((nsw, nsh), src.get_masks()[3])

        _renpy.bilinear(src, nsrc, sx, sy, sw, sh, precise=precise)

        sx = 0
        sy = 0
        sw = nsw
        sh = nsh
        src = nsrc

    _renpy.bilinear(src, dst, sx, sy, sw, sh, dx, dy, dw, dh, precise=precise)


transform = _renpy.transform

# Note: Blend requires all surfaces to be the same size.
blend = _renpy.blend

def imageblend(a, b, dst, img, amap):
    alpha = byte_offset(img)[3]
    _renpy.imageblend(a, b, dst, img, alpha, amap)


def colormatrix(src, dst, matrix):
    c = [ matrix[0:5], matrix[5:10], matrix[10:15], matrix[15:20] ]
    offs = byte_offset(src)

    o = [ None ] * 4
    for i in range(0, 4):
        o[offs[i]] = i

    _renpy.colormatrix(src, dst,
                       c[o[0]][o[0]], c[o[0]][o[1]], c[o[0]][o[2]], c[o[0]][o[3]], c[o[0]][4],
                       c[o[1]][o[0]], c[o[1]][o[1]], c[o[1]][o[2]], c[o[1]][o[3]], c[o[1]][4],
                       c[o[2]][o[0]], c[o[2]][o[1]], c[o[2]][o[2]], c[o[2]][o[3]], c[o[2]][4],
                       c[o[3]][o[0]], c[o[3]][o[1]], c[o[3]][o[2]], c[o[3]][o[3]], c[o[3]][4])


def subpixel(src, dst, x, y):

    shift = src.get_shifts()[3]
    _renpy.subpixel(src, dst, x, y, shift)

########NEW FILE########
__FILENAME__ = motion
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains displayables that move, zoom, rotate, or otherwise
# transform displayables. (As well as displayables that support them.)
import math
import types #@UnresolvedImport

import renpy.display #@UnusedImport
from renpy.display.render import render
from renpy.display.layout import Container

import renpy.display.accelerator

# The null object that's used if we don't have a defined child.
null = None

def get_null():
    global null

    if null is None:
        null = renpy.display.layout.Null()

    return null

# Convert a position from cartesian to polar coordinates.
def cartesian_to_polar(x, y, xaround, yaround):
    """
    Converts cartesian coordinates to polar coordinates.
    """

    dx = x - xaround
    dy = y - yaround

    radius = math.hypot(dx, dy)
    angle = math.atan2(dx, -dy) / math.pi * 180

    if angle < 0:
        angle += 360

    return angle, radius

def polar_to_cartesian(angle, radius, xaround, yaround):
    """
    Converts polart coordinates to cartesian coordinates.
    """

    angle = angle * math.pi / 180

    dx = radius * math.sin(angle)
    dy = -radius * math.cos(angle)

    x = type(xaround)(xaround + dx)
    y = type(yaround)(yaround + dy)

    return x, y

def first_not_none(*args):
    """
    Returns the first argument that is not None.
    """

    for i in args:
        if i is not None:
            return i
    return i


class TransformState(renpy.object.Object):

    xoffset = None
    yoffset = None
    default_xpos = None
    default_ypos = None
    default_xanchor = None
    default_yanchor = None
    default_xoffset = None
    default_yoffset = None
    transform_anchor = False
    additive = 0.0
    debug = None

    def __init__(self): # W0231
        self.alpha = 1
        self.additive = 0.0
        self.rotate = None
        self.rotate_pad = True
        self.transform_anchor = False
        self.zoom = 1
        self.xzoom = 1
        self.yzoom = 1

        self.xpos = None
        self.ypos = None
        self.xanchor = None
        self.yanchor = None
        self.xoffset = 0
        self.yoffset = 0

        self.xaround = 0.0
        self.yaround = 0.0
        self.xanchoraround = 0.0
        self.yanchoraround = 0.0

        self.subpixel = False

        self.crop = None
        self.corner1 = None
        self.corner2 = None
        self.size = None

        self.delay = 0

        self.debug = None

        # Note: When adding a new property, we need to add it to:
        # - take_state
        # - diff
        # - renpy.atl.PROPERTIES
        # - Proxies in Transform

        # Default values for various properties, taken from our
        # parent.
        self.default_xpos = None
        self.default_ypos = None
        self.default_xanchor = None
        self.default_yanchor = None

    def take_state(self, ts):

        self.alpha = ts.alpha
        self.additive = ts.additive
        self.rotate = ts.rotate
        self.rotate_pad = ts.rotate_pad
        self.transform_anchor = ts.transform_anchor
        self.zoom = ts.zoom
        self.xzoom = ts.xzoom
        self.yzoom = ts.yzoom

        self.xaround = ts.xaround
        self.yaround = ts.yaround
        self.xanchoraround = ts.xanchoraround
        self.yanchoraround = ts.yanchoraround

        self.subpixel = ts.subpixel

        self.crop = ts.crop
        self.corner1 = ts.corner1
        self.corner2 = ts.corner2
        self.size = ts.size

        self.debug = ts.debug

        # Take the computed position properties, not the
        # raw ones.
        (self.default_xpos,
         self.default_ypos,
         self.default_xanchor,
         self.default_yanchor,
         self.xoffset,
         self.yoffset,
         self.subpixel) = ts.get_placement()

    # Returns a dict, with p -> (old, new) where p is a property that
    # has changed between this object and the new object.
    def diff(self, newts):

        rv = { }

        def diff2(prop, new, old):
            if new != old:
                rv[prop] = (old, new)

        def diff4(prop, new, default_new, old, default_old):
            if new is None:
                new_value = default_new
            else:
                new_value = new

            if old is None:
                old_value = default_old
            else:
                old_value = old

            if new_value != old_value:
                rv[prop] = (old_value, new_value)

        diff2("alpha", newts.alpha, self.alpha)
        diff2("additive", newts.additive, self.additive)
        diff2("rotate", newts.rotate, self.rotate)
        diff2("rotate_pad", newts.rotate_pad, self.rotate_pad)
        diff2("transform_anchor", newts.transform_anchor, self.transform_anchor)
        diff2("zoom", newts.zoom, self.zoom)
        diff2("xzoom", newts.xzoom, self.xzoom)
        diff2("yzoom", newts.yzoom, self.yzoom)

        diff2("xaround", newts.xaround, self.xaround)
        diff2("yaround", newts.yaround, self.yaround)
        diff2("xanchoraround", newts.xanchoraround, self.xanchoraround)
        diff2("yanchoraround", newts.yanchoraround, self.yanchoraround)

        diff2("subpixel", newts.subpixel, self.subpixel)

        diff2("crop", newts.crop, self.crop)
        diff2("corner1", newts.corner1, self.corner1)
        diff2("corner2", newts.corner2, self.corner2)
        diff2("size", newts.size, self.size)

        diff4("xpos", newts.xpos, newts.default_xpos, self.xpos, self.default_xpos)

        diff4("xanchor", newts.xanchor, newts.default_xanchor, self.xanchor, self.default_xanchor)
        diff2("xoffset", newts.xoffset, self.xoffset)

        diff4("ypos", newts.ypos, newts.default_ypos, self.ypos, self.default_ypos)
        diff4("yanchor", newts.yanchor, newts.default_yanchor, self.yanchor, self.default_yanchor)
        diff2("yoffset", newts.yoffset, self.yoffset)

        return rv

    def get_placement(self, cxoffset=0, cyoffset=0):

        return (
            first_not_none(self.xpos, self.default_xpos),
            first_not_none(self.ypos, self.default_ypos),
            first_not_none(self.xanchor, self.default_xanchor),
            first_not_none(self.yanchor, self.default_yanchor),
            self.xoffset + cxoffset,
            self.yoffset + cyoffset,
            self.subpixel,
            )

    # These update various properties.
    def get_xalign(self):
        return self.xpos

    def set_xalign(self, v):
        self.xpos = v
        self.xanchor = v

    xalign = property(get_xalign, set_xalign)

    def get_yalign(self):
        return self.ypos

    def set_yalign(self, v):
        self.ypos = v
        self.yanchor = v

    yalign = property(get_yalign, set_yalign)

    def get_around(self):
        return (self.xaround, self.yaround)

    def set_around(self, value):
        self.xaround, self.yaround = value
        self.xanchoraround, self.yanchoraround = None, None

    def set_alignaround(self, value):
        self.xaround, self.yaround = value
        self.xanchoraround, self.yanchoraround = value

    around = property(get_around, set_around)
    alignaround = property(get_around, set_alignaround)

    def get_angle(self):
        xpos = first_not_none(self.xpos, self.default_xpos, 0)
        ypos = first_not_none(self.ypos, self.default_ypos, 0)
        angle, _radius = cartesian_to_polar(xpos, ypos, self.xaround, self.yaround)
        return angle

    def get_radius(self):
        xpos = first_not_none(self.xpos, self.default_xpos, 0)
        ypos = first_not_none(self.ypos, self.default_ypos, 0)
        _angle, radius = cartesian_to_polar(xpos, ypos, self.xaround, self.yaround)
        return radius

    def set_angle(self, value):
        xpos = first_not_none(self.xpos, self.default_xpos, 0)
        ypos = first_not_none(self.ypos, self.default_ypos, 0)
        _angle, radius = cartesian_to_polar(xpos, ypos, self.xaround, self.yaround)
        angle = value
        self.xpos, self.ypos = polar_to_cartesian(angle, radius, self.xaround, self.yaround)

        if self.xanchoraround:
            self.xanchor, self.yanchor = polar_to_cartesian(angle, radius, self.xaround, self.yaround)

    def set_radius(self, value):
        xpos = first_not_none(self.xpos, self.default_xpos, 0)
        ypos = first_not_none(self.ypos, self.default_ypos, 0)
        angle, _radius = cartesian_to_polar(xpos, ypos, self.xaround, self.yaround)
        radius = value
        self.xpos, self.ypos = polar_to_cartesian(angle, radius, self.xaround, self.yaround)

        if self.xanchoraround:
            self.xanchor, self.yanchor = polar_to_cartesian(angle, radius, self.xaround, self.yaround)

    angle = property(get_angle, set_angle)
    radius = property(get_radius, set_radius)

    def get_pos(self):
        return self.xpos, self.ypos

    def set_pos(self, value):
        self.xpos, self.ypos = value

    pos = property(get_pos, set_pos)

    def get_anchor(self):
        return self.xanchor, self.yanchor

    def set_anchor(self, value):
        self.xanchor, self.yanchor = value

    anchor = property(get_anchor, set_anchor)

    def get_align(self):
        return self.xpos, self.ypos

    def set_align(self, value):
        self.xanchor, self.yanchor = value
        self.xpos, self.ypos = value

    align = property(get_align, set_align)

    def get_offset(self):
        return self.xoffset, self.yoffset

    def set_offset(self, value):
        self.xoffset, self.yoffset = value

    offset = property(get_offset, set_offset)

    def set_xcenter(self, value):
        self.xpos = value
        self.xanchor = 0.5

    def get_xcenter(self):
        return self.xpos

    def set_ycenter(self, value):
        self.ypos = value
        self.yanchor = 0.5

    def get_ycenter(self):
        return self.ypos

    xcenter = property(get_xcenter, set_xcenter)
    ycenter = property(get_ycenter, set_ycenter)

class Proxy(object):
    """
    This class proxies a field from the transform to its state.
    """

    def __init__(self, name):
        self.name = name

    def __get__(self, instance, owner):
        return getattr(instance.state, self.name)

    def __set__(self, instance, value):
        return setattr(instance.state, self.name, value)

class Transform(Container):
    """
    Documented in sphinx, because we can't scan this object.
    """

    __version__ = 5
    transform_event_responder = True

    # Proxying things over to our state.
    alpha = Proxy("alpha")
    additive = Proxy("additive")
    rotate = Proxy("rotate")
    rotate_pad = Proxy("rotate_pad")
    transform_anchor = Proxy("rotate_pad")
    zoom = Proxy("zoom")
    xzoom = Proxy("xzoom")
    yzoom = Proxy("yzoom")

    xpos = Proxy("xpos")
    ypos = Proxy("ypos")
    xanchor = Proxy("xanchor")
    yanchor = Proxy("yanchor")

    xalign = Proxy("xalign")
    yalign = Proxy("yalign")

    around = Proxy("around")
    alignaround = Proxy("alignaround")
    angle = Proxy("angle")
    radius = Proxy("radius")

    xaround = Proxy("xaround")
    yaround = Proxy("yaround")
    xanchoraround = Proxy("xanchoraround")
    yanchoraround = Proxy("yanchoraround")

    pos = Proxy("pos")
    anchor = Proxy("anchor")
    align = Proxy("align")

    crop = Proxy("crop")
    corner1 = Proxy("corner1")
    corner2 = Proxy("corner2")
    size = Proxy("size")

    delay = Proxy("delay")

    xoffset = Proxy("xoffset")
    yoffset = Proxy("yoffset")
    offset = Proxy("offset")

    subpixel = Proxy("subpixel")

    xcenter = Proxy("xcenter")
    ycenter = Proxy("ycenter")

    debug = Proxy("debug")

    def after_upgrade(self, version):

        if version < 1:
            self.active = False
            self.state = TransformState()

            self.state.xpos = self.xpos or 0
            self.state.ypos = self.ypos or 0
            self.state.xanchor = self.xanchor or 0
            self.state.yanchor = self.yanchor or 0
            self.state.alpha = self.alpha
            self.state.rotate = self.rotate
            self.state.zoom = self.zoom
            self.state.xzoom = self.xzoom
            self.state.yzoom = self.yzoom

            self.hide_request = False
            self.hide_response = True

        if version < 2:
            self.st = 0
            self.at = 0

        if version < 3:
            self.st_offset = 0
            self.at_offset = 0
            self.child_st_base = 0

        if version < 4:
            self.style_arg = 'transform'

        if version < 5:
            self.replaced_request = False
            self.replaced_response = True

    DEFAULT_ARGUMENTS = {
            "selected_activate" : { },
            "selected_hover" : { },
            "selected_idle" : { },
            "selected_insensitive" : { },
            "activate" : { },
            "hover" : { },
            "idle" : { },
            "insensitive" : { },
            "" : { },
            }

    # Compatibility with old versions of the class.
    active = False
    children = False
    arguments = DEFAULT_ARGUMENTS

    # Default before we set this.
    child_size = (0, 0)

    def __init__(self,
                 child=None,
                 function=None,

                 style='transform',
                 focus=None,
                 default=False,

                 **kwargs):

        self.kwargs = kwargs
        self.style_arg = style

        super(Transform, self).__init__(style=style, focus=focus, default=default)

        self.function = function

        child = renpy.easy.displayable_or_none(child)
        if child is not None:
            self.add(child)

        self.state = TransformState()

        self.arguments = dict((k, {}) for k in self.DEFAULT_ARGUMENTS)

        # Split up the keyword arguments.
        for k, v in kwargs.iteritems():
            if "_" in k:
                prefix, prop = k.rsplit("_", 1)
            else:
                prefix = ""
                prop = k

            if prefix not in self.arguments:
                raise Exception("Unknown transform property prefix: %r" % prefix)

            if prop not in renpy.atl.PROPERTIES:
                raise Exception("Unknown transform property: %r" % prop)

            self.arguments[prefix][prop] = v


        # Apply the keyword arguments.
        for k, v in kwargs.iteritems():
            setattr(self.state, k, v)

        # This is the matrix transforming our coordinates into child coordinates.
        self.forward = None

        # Have we called the function at least once?
        self.active = False

        # Have we been requested to hide?
        self.hide_request = False

        # True if it's okay for us to hide.
        self.hide_response = True

        # Have we been requested to replaced?
        self.replaced_request = False

        # True if it's okay for us to replaced.
        self.replaced_response = True

        self.st = 0
        self.at = 0
        self.st_offset = 0
        self.at_offset = 0

        self.child_st_base = 0

    def visit(self):
        if self.child is None:
            return [ ]
        else:
            return [ self.child ]

    # The default function chooses entries from self.arguments that match
    # the style prefix, and applies them to the state.
    def default_function(self, state, st, at):

        prefix = self.style.prefix.strip("_")
        prefixes = [ ]

        while prefix:
            prefixes.insert(0, prefix)
            _, _, prefix = prefix.partition("_")

        prefixes.insert(0, "")

        for i in prefixes:
            for k, v in self.arguments[i].iteritems():
                setattr(state, k, v)

        return None

    def set_transform_event(self, event):
        if self.child is not None:
            self.child.set_transform_event(event)

        super(Transform, self).set_transform_event(event)


    def take_state(self, t):
        """
        Takes the transformation state from object t into this object.
        """

        self.state.take_state(t.state)

        # The arguments will be applied when the default function is
        # called.


    def take_execution_state(self, t):
        """
        Takes the execution state from object t into this object. This is
        overridden by renpy.atl.TransformBase.
        """

        self.hide_request = t.hide_request
        self.replaced_request = t.replaced_request

        self.state.xpos = t.state.xpos
        self.state.ypos = t.state.ypos
        self.state.xanchor = t.state.xanchor
        self.state.yanchor = t.state.yanchor

        self.child_st_base = t.child_st_base

        if isinstance(self.child, Transform) and isinstance(t.child, Transform):
            self.child.take_execution_state(t.child)


    def copy(self):
        """
        Makes a copy of this transform.
        """

        d = self()
        d.kwargs = { }
        d.take_state(self)
        d.take_execution_state(self)
        d.st = self.st
        d.at = self.at

        return d

    def _change_transform_child(self, child):
        rv = self.copy()

        if self.child is not None:
            rv.set_child(self.child._change_transform_child(child))

        return rv

    def _hide(self, st, at, kind):

        if not self.child:
            return None

        if not (self.hide_request or self.replaced_request):
            d = self.copy()
        else:
            d = self

        d.st_offset = self.st_offset
        d.at_offset = self.at_offset

        if kind == "hide":
            d.hide_request = True
        else:
            d.replaced_request = True

        d.hide_response = True
        d.replaced_response = True

        if d.function is not None:
            d.function(d, st + d.st_offset, at + d.at_offset)

        new_child = d.child._hide(st, at, kind)

        if new_child is not None:
            d.child = new_child
            d.hide_response = False
            d.replaced_response = False

        if (not d.hide_response) or (not d.replaced_response):
            renpy.display.render.redraw(d, 0)
            return d

        return None

    def set_child(self, child):

        child = renpy.easy.displayable(child)

        self.child = child
        self.child_st_base = self.st

        child.per_interact()

        renpy.display.render.redraw(self, 0)

    def update_state(self):
        """
        This updates the state to that at self.st, self.at.
        """

        # If we have to, call the function that updates this transform.
        if self.function is not None:
            fr = self.function(self, self.st, self.at)
        else:
            fr = self.default_function(self, self.st, self.at)

        # Order a redraw, if necessary.
        if fr is not None:
            renpy.display.render.redraw(self, fr)

        state = self.state

        self.active = True

        # Use non-None elements of the child placement as defaults.
        child = self.child
        if child is not None and renpy.config.transform_uses_child_position:

            pos = child.get_placement()

            if pos[0] is not None:
                state.default_xpos = pos[0]
            if pos[2] is not None:
                state.default_xanchor = pos[2]
            if pos[1] is not None:
                state.default_ypos = pos[1]
            if pos[3] is not None:
                state.default_yanchor = pos[3]

            state.subpixel |= pos[6]

    # The render method is now defined in accelerator.pyx.

    def event(self, ev, x, y, st):

        if self.hide_request:
            return None

        children = self.children
        offsets = self.offsets

        if not offsets:
            return None

        for i in xrange(len(self.children)-1, -1, -1):

            d = children[i]
            xo, yo = offsets[i]

            cx = x - xo
            cy = y - yo

            # Transform screen coordinates to child coordinates.
            cx, cy = self.forward.transform(cx, cy)

            rv = d.event(ev, cx, cy, st)
            if rv is not None:
                return rv

        return None

    def __call__(self, child=None, take_state=True):

        if child is None:
            child = self.child

        # If we don't have a child for some reason, set it to null.
        if child is None:
            child = get_null()

        rv = Transform(
            child=child,
            function=self.function,
            style=self.style_arg,
            **self.kwargs)

        rv.take_state(self)

        return rv

    def get_placement(self):

        if not self.active:
            self.update_state()

        if self.child is not None:
            _cxpos, _cypos, _cxanchor, _cyanchor, cxoffset, cyoffset, _csubpixel = self.child.get_placement()
        else:
            cxoffset = 0
            cyoffset = 0

        cxoffset = cxoffset or 0
        cyoffset = cyoffset or 0

        rv = self.state.get_placement(cxoffset, cyoffset)

        if self.state.transform_anchor:

            xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel = rv
            if (xanchor is not None) and (yanchor is not None):

                cw, ch = self.child_size
                rw, rh = self.render_size

                if xanchor.__class__ is float:
                    xanchor *= cw
                if yanchor.__class__ is float:
                    yanchor *= ch

                xanchor -= cw / 2.0
                yanchor -= ch / 2.0

                xanchor, yanchor = self.reverse.transform(xanchor, yanchor)

                xanchor += rw / 2.0
                yanchor += rh / 2.0

                xanchor = renpy.display.core.absolute(xanchor)
                yanchor = renpy.display.core.absolute(yanchor)

                rv = (xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel)

        return rv

    def update(self):
        """
        This should be called when a transform property field is updated outside
        of the callback method, to ensure that the change takes effect.
        """

        renpy.display.render.invalidate(self)

    def parameterize(self, name, parameters):
        if parameters:
            raise Exception("Image '%s' can't take parameters '%s'. (Perhaps you got the name wrong?)" %
                            (' '.join(name), ' '.join(parameters)))

        # Note the call here.
        return self()

    def _show(self):
        self.update_state()

Transform.render = types.MethodType(renpy.display.accelerator.transform_render, None, Transform)

class ATLTransform(renpy.atl.ATLTransformBase, Transform):

    def __init__(self, atl, child=None, context={}, parameters=None, **properties):
        renpy.atl.ATLTransformBase.__init__(self, atl, context, parameters)
        Transform.__init__(self, child=child, function=self.execute, **properties)

        self.raw_child = self.child

    def _show(self):
        super(ATLTransform, self)._show()
        self.execute(self, self.st, self.at)


class Motion(Container):
    """
    This is used to move a child displayable around the screen. It
    works by supplying a time value to a user-supplied function,
    which is in turn expected to return a pair giving the x and y
    location of the upper-left-hand corner of the child, or a
    4-tuple giving that and the xanchor and yanchor of the child.

    The time value is a floating point number that ranges from 0 to
    1. If repeat is True, then the motion repeats every period
    sections. (Otherwise, it stops.) If bounce is true, the
    time value varies from 0 to 1 to 0 again.

    The function supplied needs to be pickleable, which means it needs
    to be defined as a name in an init block. It cannot be a lambda or
    anonymous inner function. If you can get away with using Pan or
    Move, use them instead.

    Please note that floats and ints are interpreted as for xpos and
    ypos, with floats being considered fractions of the screen.
    """

    def __init__(self, function, period, child=None, new_widget=None, old_widget=None, repeat=False, bounce=False, delay=None, anim_timebase=False, tag_start=None, time_warp=None, add_sizes=False, style='motion', **properties):
        """
        @param child: The child displayable.

        @param new_widget: If child is None, it is set to new_widget,
        so that we can speak the transition protocol.

        @param old_widget: Ignored, for compatibility with the transition protocol.

        @param function: A function that takes a floating point value and returns
        an xpos, ypos tuple.

        @param period: The amount of time it takes to go through one cycle, in seconds.

        @param repeat: Should we repeat after a period is up?

        @param bounce: Should we bounce?

        @param delay: How long this motion should take. If repeat is None, defaults to period.

        @param anim_timebase: If True, use the animation timebase rather than the shown timebase.

        @param time_warp: If not None, this is a function that takes a
        fraction of the period (between 0.0 and 1.0), and returns a
        new fraction of the period. Use this to warp time, applying
        acceleration and deceleration to motions.

        This can also be used as a transition. When used as a
        transition, the motion is applied to the new_widget for delay
        seconds.
        """

        if child is None:
            child = new_widget

        if delay is None and not repeat:
            delay = period

        super(Motion, self).__init__(style=style, **properties)

        if child is not None:
            self.add(child)

        self.function = function
        self.period = period
        self.repeat = repeat
        self.bounce = bounce
        self.delay = delay
        self.anim_timebase = anim_timebase
        self.time_warp = time_warp
        self.add_sizes = add_sizes

        self.position = None


    def get_placement(self):

        if self.position is None:
            return super(Motion, self).get_placement()
        else:
            return self.position + (self.style.xoffset, self.style.yoffset, self.style.subpixel)

    def render(self, width, height, st, at):

        if self.anim_timebase:
            t = at
        else:
            t = st

        if renpy.game.less_updates:
            if self.delay:
                t = self.delay
                if self.repeat:
                    t = t % self.period
            else:
                t = self.period
        elif self.delay and t >= self.delay:
            t = self.delay
            if self.repeat:
                t = t % self.period
        elif self.repeat:
            t = t % self.period
            renpy.display.render.redraw(self, 0)
        else:
            if t > self.period:
                t = self.period
            else:
                renpy.display.render.redraw(self, 0)

        if self.period > 0:
            t /= self.period
        else:
            t = 1

        if self.time_warp:
            t = self.time_warp(t)

        if self.bounce:
            t = t * 2
            if t > 1.0:
                t = 2.0 - t

        child = render(self.child, width, height, st, at)
        cw, ch = child.get_size()

        if self.add_sizes:
            res = self.function(t, (width, height, cw, ch))
        else:
            res = self.function(t)

        res = tuple(res)

        if len(res) == 2:
            self.position = res + (self.style.xanchor, self.style.yanchor)
        else:
            self.position = res

        rv = renpy.display.render.Render(cw, ch)
        rv.blit(child, (0, 0))

        self.offsets = [ (0, 0) ]

        return rv


class Interpolate(object):

    anchors = {
        'top' : 0.0,
        'center' : 0.5,
        'bottom' : 1.0,
        'left' : 0.0,
        'right' : 1.0,
        }

    def __init__(self, start, end):

        if len(start) != len(end):
            raise Exception("The start and end must have the same number of arguments.")

        self.start = [ self.anchors.get(i, i) for i in start ]
        self.end = [ self.anchors.get(i, i) for i in end ]

    def __call__(self, t, sizes=(None, None, None, None)):

        def interp(a, b, c):

            if c is not None:
                if type(a) is float:
                    a = a * c
                if type(b) is float:
                    b = b * c

            rv = a + t * (b - a)

            return renpy.display.core.absolute(rv)

        return [ interp(a, b, c) for a, b, c in zip(self.start, self.end, sizes) ]


def Pan(startpos, endpos, time, child=None, repeat=False, bounce=False,
        anim_timebase=False, style='motion', time_warp=None, **properties):
    """
    This is used to pan over a child displayable, which is almost
    always an image. It works by interpolating the placement of the
    upper-left corner of the screen, over time. It's only really
    suitable for use with images that are larger than the screen,
    and we don't do any cropping on the image.

    @param startpos: The initial coordinates of the upper-left
    corner of the screen, relative to the image.

    @param endpos: The coordinates of the upper-left corner of the
    screen, relative to the image, after time has elapsed.

    @param time: The time it takes to pan from startpos to endpos.

    @param child: The child displayable.

    @param repeat: True if we should repeat this forever.

    @param bounce: True if we should bounce from the start to the end
    to the start.

    @param anim_timebase: True if we use the animation timebase, False to use the
    displayable timebase.

    @param time_warp: If not None, this is a function that takes a
    fraction of the period (between 0.0 and 1.0), and returns a
    new fraction of the period. Use this to warp time, applying
    acceleration and deceleration to motions.

    This can be used as a transition. See Motion for details.
    """

    x0, y0 = startpos
    x1, y1 = endpos

    return Motion(Interpolate((-x0, -y0), (-x1, -y1)),
                  time,
                  child,
                  repeat=repeat,
                  bounce=bounce,
                  style=style,
                  anim_timebase=anim_timebase,
                  time_warp=time_warp,
                  add_sizes=True,
                  **properties)

def Move(startpos, endpos, time, child=None, repeat=False, bounce=False,
         anim_timebase=False, style='motion', time_warp=None, **properties):
    """
    This is used to pan over a child displayable relative to
    the containing area. It works by interpolating the placement of the
    the child, over time.

    @param startpos: The initial coordinates of the child
    relative to the containing area.

    @param endpos: The coordinates of the child at the end of the
    move.

    @param time: The time it takes to move from startpos to endpos.

    @param child: The child displayable.

    @param repeat: True if we should repeat this forever.

    @param bounce: True if we should bounce from the start to the end
    to the start.

    @param anim_timebase: True if we use the animation timebase, False to use the
    displayable timebase.

    @param time_warp: If not None, this is a function that takes a
    fraction of the period (between 0.0 and 1.0), and returns a
    new fraction of the period. Use this to warp time, applying
    acceleration and deceleration to motions.

    This can be used as a transition. See Motion for details.
    """

    return Motion(Interpolate(startpos, endpos),
                  time,
                  child,
                  repeat=repeat,
                  bounce=bounce,
                  anim_timebase=anim_timebase,
                  style=style,
                  time_warp=time_warp,
                  add_sizes=True,
                  **properties)


class Revolver(object):

    def __init__(self, start, end, child, around=(0.5, 0.5), cor=(0.5, 0.5), pos=None):
        self.start = start
        self.end = end
        self.around = around
        self.cor = cor
        self.pos = pos
        self.child = child

    def __call__(self, t, (w, h, cw, ch)):

        # Converts a float to an integer in the given range, passes
        # integers through unchanged.
        def fti(x, r):
            if x is None:
                x = 0

            if isinstance(x, float):
                return int(x * r)
            else:
                return x

        if self.pos is None:
            pos = self.child.get_placement()
        else:
            pos = self.pos

        xpos, ypos, xanchor, yanchor, _xoffset, _yoffset, _subpixel = pos

        xpos = fti(xpos, w)
        ypos = fti(ypos, h)
        xanchor = fti(xanchor, cw)
        yanchor = fti(yanchor, ch)

        xaround, yaround = self.around

        xaround = fti(xaround, w)
        yaround = fti(yaround, h)

        xcor, ycor = self.cor

        xcor = fti(xcor, cw)
        ycor = fti(ycor, ch)

        angle = self.start + (self.end - self.start) * t
        angle *= math.pi / 180

        # The center of rotation, relative to the xaround.
        x = xpos - xanchor + xcor - xaround
        y = ypos - yanchor + ycor - yaround

        # Rotate it.
        nx = x * math.cos(angle) - y * math.sin(angle)
        ny = x * math.sin(angle) + y * math.cos(angle)

        # Project it back.
        nx = nx - xcor + xaround
        ny = ny - ycor + yaround

        return (renpy.display.core.absolute(nx), renpy.display.core.absolute(ny), 0, 0)


def Revolve(start, end, time, child, around=(0.5, 0.5), cor=(0.5, 0.5), pos=None, **properties):

    return Motion(Revolver(start, end, child, around=around, cor=cor, pos=pos),
                  time,
                  child,
                  add_sizes=True,
                  **properties)



def zoom_render(crend, x, y, w, h, zw, zh, bilinear):
    """
    This creates a render that zooms its child.

    `crend` - The render of the child.
    `x`, `y`, `w`, `h` - A rectangle inside the child.
    `zw`, `zh` - The size the rectangle is rendered to.
    `bilinear` - Should we be rendering in bilinear mode?
    """

    rv = renpy.display.render.Render(zw, zh)

    if zw == 0 or zh == 0 or w == 0 or h == 0:
        return rv


    rv.forward = renpy.display.render.Matrix2D(w / zw, 0, 0, h / zh)
    rv.reverse = renpy.display.render.Matrix2D(zw / w, 0, 0, zh / h)

    rv.clipping = True

    rv.blit(crend, rv.reverse.transform(-x, -y))

    return rv


class ZoomCommon(renpy.display.core.Displayable):
    def __init__(self,
                 time, child,
                 end_identity=False,
                 after_child=None,
                 time_warp=None,
                 bilinear=True,
                 opaque=True,
                 anim_timebase=False,
                 repeat=False,
                 style='motion',
                 **properties):
        """
        @param time: The amount of time it will take to
        interpolate from the start to the end rectange.

        @param child: The child displayable.

        @param after_child: If present, a second child
        widget. This displayable will be rendered after the zoom
        completes. Use this to snap to a sharp displayable after
        the zoom is done.

        @param time_warp: If not None, this is a function that takes a
        fraction of the period (between 0.0 and 1.0), and returns a
        new fraction of the period. Use this to warp time, applying
        acceleration and deceleration to motions.
        """

        super(ZoomCommon, self).__init__(style=style, **properties)

        child = renpy.easy.displayable(child)

        self.time = time
        self.child = child
        self.repeat = repeat

        if after_child:
            self.after_child = renpy.easy.displayable(after_child)
        else:
            if end_identity:
                self.after_child = child
            else:
                self.after_child = None

        self.time_warp = time_warp
        self.bilinear = bilinear
        self.opaque = opaque
        self.anim_timebase = anim_timebase


    def visit(self):
        return [ self.child, self.after_child ]

    def render(self, width, height, st, at):

        if self.anim_timebase:
            t = at
        else:
            t = st

        if self.time:
            done = min(t / self.time, 1.0)
        else:
            done = 1.0

        if self.repeat:
            done = done % 1.0

        if renpy.game.less_updates:
            done = 1.0

        self.done = done

        if self.after_child and done == 1.0:
            return renpy.display.render.render(self.after_child, width, height, st, at)

        if self.time_warp:
            done = self.time_warp(done)

        rend = renpy.display.render.render(self.child, width, height, st, at)

        rx, ry, rw, rh, zw, zh = self.zoom_rectangle(done, rend.width, rend.height)

        if rx < 0 or ry < 0 or rx + rw > rend.width or ry + rh > rend.height:
            raise Exception("Zoom rectangle %r falls outside of %dx%d parent surface." % ((rx, ry, rw, rh), rend.width, rend.height))

        rv = zoom_render(rend, rx, ry, rw, rh, zw, zh, self.bilinear)

        if self.done < 1.0:
            renpy.display.render.redraw(self, 0)

        return rv

    def event(self, ev, x, y, st):

        if not self.time:
            done = 1.0
        else:
            done = min(st / self.time, 1.0)

        if done == 1.0 and self.after_child:
            return self.after_child.event(ev, x, y, st)
        else:
            return None


class Zoom(ZoomCommon):

    def __init__(self, size, start, end, time, child, **properties):

        end_identity = (end == (0.0, 0.0) + size)

        super(Zoom, self).__init__(time, child, end_identity=end_identity, **properties)

        self.size = size
        self.start = start
        self.end = end

    def zoom_rectangle(self, done, width, height):

        rx, ry, rw, rh = [ (a + (b - a) * done) for a, b in zip(self.start, self.end) ]

        return rx, ry, rw, rh, self.size[0], self.size[1]


class FactorZoom(ZoomCommon):

    def __init__(self, start, end, time, child, **properties):

        end_identity = (end == 1.0)

        super(FactorZoom, self).__init__(time, child, end_identity=end_identity, **properties)

        self.start = start
        self.end = end

    def zoom_rectangle(self, done, width, height):

        factor = self.start + (self.end - self.start) * done

        return 0, 0, width, height, factor * width, factor * height



class SizeZoom(ZoomCommon):

    def __init__(self, start, end, time, child, **properties):

        end_identity = False

        super(SizeZoom, self).__init__(time, child, end_identity=end_identity, **properties)

        self.start = start
        self.end = end

    def zoom_rectangle(self, done, width, height):

        sw, sh = self.start
        ew, eh = self.end

        zw = sw + (ew - sw) * done
        zh = sh + (eh - sh) * done

        return 0, 0, width, height, zw, zh


class RotoZoom(renpy.display.core.Displayable):

    transform = None

    def __init__(self,
                 rot_start,
                 rot_end,
                 rot_delay,
                 zoom_start,
                 zoom_end,
                 zoom_delay,
                 child,
                 rot_repeat=False,
                 zoom_repeat=False,
                 rot_bounce=False,
                 zoom_bounce=False,
                 rot_anim_timebase=False,
                 zoom_anim_timebase=False,
                 rot_time_warp=None,
                 zoom_time_warp=None,
                 opaque=False,
                 style='motion',
                 **properties):

        super(RotoZoom, self).__init__(style=style, **properties)

        self.rot_start = rot_start
        self.rot_end = rot_end
        self.rot_delay = rot_delay

        self.zoom_start = zoom_start
        self.zoom_end = zoom_end
        self.zoom_delay = zoom_delay

        self.child = renpy.easy.displayable(child)

        self.rot_repeat = rot_repeat
        self.zoom_repeat = zoom_repeat

        self.rot_bounce = rot_bounce
        self.zoom_bounce = zoom_bounce

        self.rot_anim_timebase = rot_anim_timebase
        self.zoom_anim_timebase = zoom_anim_timebase

        self.rot_time_warp = rot_time_warp
        self.zoom_time_warp = zoom_time_warp

        self.opaque = opaque


    def visit(self):
        return [ self.child ]


    def render(self, width, height, st, at):

        if self.rot_anim_timebase:
            rot_time = at
        else:
            rot_time = st

        if self.zoom_anim_timebase:
            zoom_time = at
        else:
            zoom_time = st

        if self.rot_delay == 0:
            rot_time = 1.0
        else:
            rot_time /= self.rot_delay

        if self.zoom_delay == 0:
            zoom_time = 1.0
        else:
            zoom_time /= self.zoom_delay

        if self.rot_repeat:
            rot_time %= 1.0

        if self.zoom_repeat:
            zoom_time %= 1.0

        if self.rot_bounce:
            rot_time *= 2
            rot_time = min(rot_time, 2.0 - rot_time)

        if self.zoom_bounce:
            zoom_time *= 2
            zoom_time = min(zoom_time, 2.0 - zoom_time)

        if renpy.game.less_updates:
            rot_time = 1.0
            zoom_time = 1.0

        rot_time = min(rot_time, 1.0)
        zoom_time = min(zoom_time, 1.0)

        if self.rot_time_warp:
            rot_time = self.rot_time_warp(rot_time)

        if self.zoom_time_warp:
            zoom_time = self.zoom_time_warp(zoom_time)


        angle = self.rot_start + (1.0 * self.rot_end - self.rot_start) * rot_time
        zoom = self.zoom_start + (1.0 * self.zoom_end - self.zoom_start) * zoom_time
        # angle = -angle * math.pi / 180

        zoom = max(zoom, 0.001)

        if self.transform is None:
            self.transform = Transform(self.child)

        self.transform.rotate = angle
        self.transform.zoom = zoom

        rv = renpy.display.render.render(self.transform, width, height, st, at)

        if rot_time <= 1.0 or zoom_time <= 1.0:
            renpy.display.render.redraw(self.transform, 0)

        return rv


# For compatibility with old games.
renpy.display.layout.Transform = Transform
renpy.display.layout.RotoZoom = RotoZoom
renpy.display.layout.SizeZoom = SizeZoom
renpy.display.layout.FactorZoom = FactorZoom
renpy.display.layout.Zoom = Zoom
renpy.display.layout.Revolver = Revolver
renpy.display.layout.Motion = Motion
renpy.display.layout.Interpolate = Interpolate

# Leave these functions around - they might have been pickled somewhere.
renpy.display.layout.Revolve = Revolve # function
renpy.display.layout.Move = Move # function
renpy.display.layout.Pan = Pan # function

########NEW FILE########
__FILENAME__ = movetransition
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# NOTE:
# Transitions need to be able to work even when old_widget and new_widget
# are None, at least to the point of making it through __init__. This is
# so that prediction of images works.

import renpy.display

# Utility function used by MoveTransition et al.
def position(d):

    xpos, ypos, xanchor, yanchor, _xoffset, _yoffset, _subpixel = d.get_placement()

    if xpos is None:
        xpos = 0
    if ypos is None:
        ypos = 0
    if xanchor is None:
        xanchor = 0
    if yanchor is None:
        yanchor = 0

    return xpos, ypos, xanchor, yanchor

def offsets(d):

    _xpos, _ypos, _xanchor, _yanchor, xoffset, yoffset, _subpixel = d.get_placement()

    if renpy.config.movetransition_respects_offsets:
        return { 'xoffset' : xoffset, 'yoffset' : yoffset }
    else:
        return { }


# These are used by MoveTransition.
def MoveFactory(pos1, pos2, delay, d, **kwargs):
    if pos1 == pos2:
        return d

    return renpy.display.motion.Move(pos1, pos2, delay, d, **kwargs)

def default_enter_factory(pos, delay, d, **kwargs):
    return d

def default_leave_factory(pos, delay, d, **kwargs):
    return None

# These can be used to move things in and out of the screen.
def MoveIn(pos, pos1, delay, d, **kwargs):

    def aorb(a, b):
        if a is None:
            return b
        return a

    pos = tuple([aorb(a, b) for a, b in zip(pos, pos1)])
    return renpy.display.motion.Move(pos, pos1, delay, d, **kwargs)

def MoveOut(pos, pos1, delay, d, **kwargs):

    def aorb(a, b):
        if a is None:
            return b
        return a

    pos = tuple([aorb(a, b) for a, b in zip(pos, pos1)])
    return renpy.display.motion.Move(pos1, pos, delay, d, **kwargs)

def ZoomInOut(start, end, pos, delay, d, **kwargs):

    xpos, ypos, xanchor, yanchor = pos

    FactorZoom = renpy.display.motion.FactorZoom

    if end == 1.0:
        return FactorZoom(start, end, delay, d, after_child=d, opaque=False,
                          xpos=xpos, ypos=ypos, xanchor=xanchor, yanchor=yanchor, **kwargs)
    else:
        return FactorZoom(start, end, delay, d, opaque=False,
                          xpos=xpos, ypos=ypos, xanchor=xanchor, yanchor=yanchor, **kwargs)

def RevolveInOut(start, end, pos, delay, d, **kwargs):
    return renpy.display.motion.Revolve(start, end, delay, d, pos=pos, **kwargs)


def OldMoveTransition(delay, old_widget=None, new_widget=None, factory=None, enter_factory=None, leave_factory=None, old=False, layers=[ 'master' ]):
    """
    Returns a transition that attempts to find images that have changed
    position, and moves them from the old position to the new transition, taking
    delay seconds to complete the move.

    If `factory` is given, it is expected to be a function that takes as
    arguments: an old position, a new position, the delay, and a
    displayable, and to return a displayable as an argument. If not
    given, the default behavior is to move the displayable from the
    starting to the ending positions. Positions are always given as
    (xpos, ypos, xanchor, yanchor) tuples.

    If `enter_factory` or `leave_factory` are given, they are expected
    to be functions that take as arguments a position, a delay, and a
    displayable, and return a displayable. They are applied to
    displayables that are entering or leaving the scene,
    respectively. The default is to show in place displayables that
    are entering, and not to show those that are leaving.

    If `old` is True, then factory moves the old displayable with the
    given tag. Otherwise, it moves the new displayable with that
    tag.

    `layers` is a list of layers that the transition will be applied
    to.

    Images are considered to be the same if they have the same tag, in
    the same way that the tag is used to determine which image to
    replace or to hide. They are also considered to be the same if
    they have no tag, but use the same displayable.

    Computing the order in which images are displayed is a three-step
    process. The first step is to create a list of images that
    preserves the relative ordering of entering and moving images. The
    second step is to insert the leaving images such that each leaving
    image is at the lowest position that is still above all images
    that were below it in the original scene. Finally, the list
    is sorted by zorder, to ensure no zorder violations occur.

    If you use this transition to slide an image off the side of the
    screen, remember to hide it when you are done. (Or just use
    a leave_factory.)
    """

    if factory is None:
        factory = MoveFactory

    if enter_factory is None:
        enter_factory = default_enter_factory

    if leave_factory is None:
        leave_factory = default_leave_factory

    use_old = old

    def merge_slide(old, new):

        # If new does not have .layers or .scene_list, then we simply
        # insert a move from the old position to the new position, if
        # a move occured.

        if (not isinstance(new, renpy.display.layout.MultiBox)
            or (new.layers is None and new.layer_name is None)):

            if use_old:
                child = old
            else:
                child = new

            old_pos = position(old)
            new_pos = position(new)

            if old_pos != new_pos:
                return factory(old_pos,
                               new_pos,
                               delay,
                               child,
                               **offsets(child)
                               )

            else:
                return child

        # If we're in the layers_root widget, merge the child widgets
        # for each layer.
        if new.layers:

            rv = renpy.display.layout.MultiBox(layout='fixed')
            rv.layers = { }

            for layer in renpy.config.layers:

                f = new.layers[layer]

                if (isinstance(f, renpy.display.layout.MultiBox)
                    and layer in layers
                    and f.scene_list is not None):

                    f = merge_slide(old.layers[layer], new.layers[layer])

                rv.layers[layer] = f
                rv.add(f)

            return rv

        # Otherwise, we recompute the scene list for the two widgets, merging
        # as appropriate.

        # Wraps the displayable found in SLE so that the various timebases
        # are maintained.
        def wrap(sle):
            return renpy.display.layout.AdjustTimes(sle.displayable, sle.show_time, sle.animation_time)

        def tag(sle):
            return sle.tag or sle.displayable

        def merge(sle, d):
            rv = sle.copy()
            rv.show_time = 0
            rv.displayable = d
            return rv

        def entering(sle):
            new_d = wrap(new_sle)
            move = enter_factory(position(new_d), delay, new_d, **offsets(new_d))

            if move is None:
                return

            rv_sl.append(merge(new_sle, move))

        def leaving(sle):
            old_d = wrap(sle)
            move = leave_factory(position(old_d), delay, old_d, **offsets(old_d))

            if move is None:
                return

            move = renpy.display.layout.IgnoresEvents(move)
            rv_sl.append(merge(old_sle, move))


        def moving(old_sle, new_sle):
            old_d = wrap(old_sle)
            new_d = wrap(new_sle)

            if use_old:
                child = old_d
            else:
                child = new_d

            move = factory(position(old_d), position(new_d), delay, child, **offsets(child))
            if move is None:
                return

            rv_sl.append(merge(new_sle, move))


        # The old, new, and merged scene_lists.
        old_sl = old.scene_list[:]
        new_sl = new.scene_list[:]
        rv_sl = [ ]


        # A list of tags in old_sl, new_sl, and rv_sl.
        old_map = dict((tag(i), i) for i in old_sl if i is not None)
        new_tags = set(tag(i) for i in new_sl if i is not None)
        rv_tags = set()

        while old_sl or new_sl:

            # If we have something in old_sl, then
            if old_sl:

                old_sle = old_sl[0]
                old_tag = tag(old_sle)

                # If the old thing has already moved, then remove it.
                if old_tag in rv_tags:
                    old_sl.pop(0)
                    continue

                # If the old thing does not match anything in new_tags,
                # have it enter.
                if old_tag not in new_tags:
                    leaving(old_sle)
                    rv_tags.add(old_tag)
                    old_sl.pop(0)
                    continue


            # Otherwise, we must have something in new_sl. We want to
            # either move it or have it enter.

            new_sle = new_sl.pop(0)
            new_tag = tag(new_sle)

            # If it exists in both, move.
            if new_tag in old_map:
                old_sle = old_map[new_tag]

                moving(old_sle, new_sle)
                rv_tags.add(new_tag)
                continue

            else:
                entering(new_sle)
                rv_tags.add(new_tag)
                continue

        # Sort everything by zorder, to ensure that there are no zorder
        # violations in the result.
        rv_sl.sort(key=lambda a : a.zorder)

        layer = new.layer_name
        rv = renpy.display.layout.MultiBox(layout='fixed', focus=layer, **renpy.game.interface.layer_properties[layer])
        rv.append_scene_list(rv_sl)
        rv.layer_name = layer

        return rv


    # This calls merge_slide to actually do the merging.

    rv = merge_slide(old_widget, new_widget)
    rv.delay = delay # W0201

    return rv

##############################################################################
# New Move Transition (since 6.14)


class MoveInterpolate(renpy.display.core.Displayable):
    """
    This displayable has two children. It interpolates between the positions
    of its two children to place them on the screen.
    """

    def __init__(self, delay, old, new, use_old, time_warp):
        super(MoveInterpolate, self).__init__()

        # The old and new displayables.
        self.old = old
        self.new = new

        # Should we display the old displayable?
        self.use_old = False

        # Time warp function or None.
        self.time_warp = time_warp

        # The width of the screen.
        self.screen_width = 0
        self.screen_height = 0

        # The width of the selected child.
        self.child_width = 0
        self.child_height = 0

        # The delay and st.
        self.delay = delay
        self.st = 0

    def render(self, width, height, st, at):
        self.screen_width = width
        self.screen_height = height

        old_r = renpy.display.render.render(self.old, width, height, st, at)
        new_r = renpy.display.render.render(self.new, width, height, st, at)

        if self.use_old:
            cr = old_r
        else:
            cr = new_r

        self.child_width, self.child_height = cr.get_size()
        self.st = st

        if self.st < self.delay:
            renpy.display.render.redraw(self, 0)

        return cr

    def child_placement(self, child):

        def based(v, base):
            if v is None:
                return 0
            elif isinstance(v, int):
                return v
            elif isinstance(v, renpy.display.core.absolute):
                return v
            else:
                return v * base

        xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel = child.get_placement()

        xpos = based(xpos, self.screen_width)
        ypos = based(ypos, self.screen_height)
        xanchor = based(xanchor, self.child_width)
        yanchor = based(yanchor, self.child_height)

        return xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel

    def get_placement(self):

        if self.st > self.delay:
            done = 1.0
        else:
            done = self.st / self.delay

        if self.time_warp is not None:
            done = self.time_warp(done)

        absolute = renpy.display.core.absolute

        def I(a, b):
            return absolute(a + done * (b - a))

        old_xpos, old_ypos, old_xanchor, old_yanchor, old_xoffset, old_yoffset, old_subpixel = self.child_placement(self.old)
        new_xpos, new_ypos, new_xanchor, new_yanchor, new_xoffset, new_yoffset, new_subpixel = self.child_placement(self.new)

        xpos = I(old_xpos, new_xpos)
        ypos = I(old_ypos, new_ypos)
        xanchor = I(old_xanchor, new_xanchor)
        yanchor = I(old_yanchor, new_yanchor)
        xoffset = I(old_xoffset, new_xoffset)
        yoffset = I(old_yoffset, new_yoffset)
        subpixel = old_subpixel or new_subpixel

        return xpos, ypos, xanchor, yanchor, xoffset, yoffset, subpixel


def MoveTransition(delay, old_widget=None, new_widget=None, enter=None, leave=None, old=False, layers=[ 'master' ], time_warp=None, enter_time_warp=None, leave_time_warp=None):
    """
    :doc: transition function
    :args: (delay, enter=None, leave=None, old=False, layers=['master'], time_warp=None, enter_time_warp=None, leave_time_warp=None)
    :name: MoveTransition

    Returns a transition that interpolates the position of images (with the
    same tag) in the old and new scenes.

    `delay`
        The time it takes for the interpolation to finish.

    `enter`
        If not None, images entering the scene will also be moved. The value
        of `enter` should be a transform that is applied to the image to
        get its starting position.

    `leave`
        If not None, images leaving the scene will also be move. The value
        of `leave` should be a transform that is applied to the image to
        get its ending position.

    `old`
        If true, the old image will be used in preference to the new one.

    `layers`
        A list of layers that moves are applied to.

    `time_warp`
        A time warp function that's applied to the interpolation. This
        takes a number between 0.0 and 1.0, and should return a number in
        the same range.

    `enter_time_warp`
        A time warp function that's applied to images entering the scene.

    `enter_time_warp`
        A time warp function that's applied to images leaving the scene.

    """

    use_old = old

    def merge_slide(old, new):

        # If new does not have .layers or .scene_list, then we simply
        # insert a move from the old position to the new position, if
        # a move occured.

        if (not isinstance(new, renpy.display.layout.MultiBox)
            or (new.layers is None and new.layer_name is None)):

            if old is new:
                return new
            else:
                return MoveInterpolate(delay, old, new, use_old, time_warp)


        # If we're in the layers_root widget, merge the child widgets
        # for each layer.
        if new.layers:

            rv = renpy.display.layout.MultiBox(layout='fixed')

            for layer in renpy.config.layers:

                f = new.layers[layer]

                if (isinstance(f, renpy.display.layout.MultiBox)
                    and layer in layers
                    and f.scene_list is not None):

                    f = merge_slide(old.layers[layer], new.layers[layer])

                rv.add(f)

            return rv

        # Otherwise, we recompute the scene list for the two widgets, merging
        # as appropriate.

        # Wraps the displayable found in SLE so that the various timebases
        # are maintained.
        def wrap(sle):
            return renpy.display.layout.AdjustTimes(sle.displayable, sle.show_time, sle.animation_time)

        def tag(sle):
            return sle.tag or sle.displayable

        def merge(sle, d):
            rv = sle.copy()
            rv.show_time = 0
            rv.displayable = d
            return rv

        def entering(sle):

            if not enter:
                return

            new_d = wrap(new_sle)
            move = MoveInterpolate(delay, enter(new_d), new_d, False, enter_time_warp)
            rv_sl.append(merge(new_sle, move))

        def leaving(sle):

            if not leave:
                return

            old_d = wrap(sle)
            move = MoveInterpolate(delay, old_d, leave(old_d), True, leave_time_warp)
            move = renpy.display.layout.IgnoresEvents(move)
            rv_sl.append(merge(old_sle, move))


        def moving(old_sle, new_sle):

            if old_sle.displayable is new_sle.displayable:
                rv_sl.append(new_sle)
                return

            old_d = wrap(old_sle)
            new_d = wrap(new_sle)

            move = MoveInterpolate(delay, old_d, new_d, use_old, time_warp)

            rv_sl.append(merge(new_sle, move))


        # The old, new, and merged scene_lists.
        old_sl = old.scene_list[:]
        new_sl = new.scene_list[:]
        rv_sl = [ ]

        # A list of tags in old_sl, new_sl, and rv_sl.
        old_map = dict((tag(i), i) for i in old_sl if i is not None)
        new_tags = set(tag(i) for i in new_sl if i is not None)
        rv_tags = set()

        while old_sl or new_sl:

            # If we have something in old_sl, then
            if old_sl:

                old_sle = old_sl[0]
                old_tag = tag(old_sle)

                # If the old thing has already moved, then remove it.
                if old_tag in rv_tags:
                    old_sl.pop(0)
                    continue

                # If the old thing does not match anything in new_tags,
                # have it enter.
                if old_tag not in new_tags:
                    leaving(old_sle)
                    rv_tags.add(old_tag)
                    old_sl.pop(0)
                    continue


            # Otherwise, we must have something in new_sl. We want to
            # either move it or have it enter.

            new_sle = new_sl.pop(0)
            new_tag = tag(new_sle)

            # If it exists in both, move.
            if new_tag in old_map:
                old_sle = old_map[new_tag]

                moving(old_sle, new_sle)
                rv_tags.add(new_tag)
                continue

            else:
                entering(new_sle)
                rv_tags.add(new_tag)
                continue

        # Sort everything by zorder, to ensure that there are no zorder
        # violations in the result.
        rv_sl.sort(key=lambda a : a.zorder)

        layer = new.layer_name
        rv = renpy.display.layout.MultiBox(layout='fixed', focus=layer, **renpy.game.interface.layer_properties[layer])
        rv.append_scene_list(rv_sl)

        return rv

    # Call merge_slide to actually do the merging.
    rv = merge_slide(old_widget, new_widget)
    rv.delay = delay

    return rv


########NEW FILE########
__FILENAME__ = particle
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This code supports sprite and particle animation.

from renpy.display.render import render, BLIT

import renpy.display
import random


class SpriteCache(renpy.object.Object):
    """
    This stores information about a displayble, including the identity
    of the displayable, and when it was first displayed. It is also
    responsible for caching the displayable surface, so it doesn't
    need to be re-rendered.
    """

    # Private Fields:
    #
    # child - The child displayable.
    #
    # st - The shown time when this was first displayed, or None if it hasn't
    # been rendered.
    #
    # render - The render of child.
    #
    # If true, then the render is simple enough it can just be appended to
    # the manager's render's children list.

class Sprite(renpy.object.Object):
    """
    :doc: sprites class

    This represents a sprite that is managed by the SpriteManager. It contains
    fields that control the placement of the sprite on the screen. Sprites
    should not be created directly. Instead, they should be created by
    calling :meth:`SpriteManager.create`.

    The fields of a sprite object are:

    `x`, `y`
        The x and y coordinates of the upper-left corner of the sprite,
        relative to the SpriteManager.

    `zorder`
        An integer that's used to control the order of this sprite in the
        relative to the other sprites in the SpriteManager. The larger the
        number is, the closer to the viewer the sprite is.

    `events`
        If True, then events are passed to child. If False, the default,
        the children igore events (and hence don't spend time processing
        them).

    The methods of a Sprite object are:
        """

    # Fields:
    #
    # child - the displayable that is the child of this sprite.
    # cache - the SpriteCache of child.
    # live - True if this sprite is still alive.
    # manager - A reference to the SpriteManager.

    def set_child(self, d):
        """
        :doc: sprites method

        Changes the Displayable associated with this sprite to `d`.
        """

        id_d = id(d)

        sc = self.manager.displayable_map.get(id_d, None)
        if sc is None:
            d = renpy.easy.displayable(d)

            sc = SpriteCache()
            sc.render = None
            sc.child = d
            sc.st = None

            self.manager.displayable_map[id_d] = sc

        self.cache = sc

    def destroy(self):
        """
        :doc: sprites method

        Destroys this sprite, preventing it from being displayed and
        removing it from the SpriteManager.
        """

        self.manager.dead_child = True
        self.live = False
        self.events = False



class SpriteManager(renpy.display.core.Displayable):
    """
    :doc: sprites class

    This displayable manages a collection of sprites, and displays
    them at the fastest speed possible.
    """

    def __init__(self, update=None, event=None, predict=None, ignore_time=False, **properties):
        """
        `update`
            If not None, a function that is called each time a sprite
            is rendered by this sprite manager. It is called with one
            argument, the time in seconds since this sprite manager
            was first displayed.  It is expected to return the number
            of seconds until the function is called again, and the
            SpriteManager is rendered again.

        `event`
            If not None, a function that is called when an event occurs.
            It takes as arguments:
            * A pygame event object.
            * The x coordinate of the event.
            * The y coordinate of the event.
            * The time since the sprite manager was first shown.
            If it returns a non-None value, the interaction ends, and
            that value is returned.

        `predict`
            If not None, a function that returns a list of
            displayables. These displayables are predicted when the
            sprite manager is.

        `ignore_time`
            If True, then time is ignored when rendering displayables. This
            should be used when the sprite manager is used with a relatively
            small pool of images, and those images do not change over time.
            This should only be used with a small number of displayables, as
            it will keep all displayables used in memory for the life of the
            SpriteManager.

        After being rendered once (before the `update` function is called),
        SpriteManagers have the following fields:

        `width`, `height`

             The width and height of this SpriteManager, in pixels.


        SpriteManagers have the following methods:
        """

        super(SpriteManager, self).__init__(self, **properties)

        self.update_function = update
        self.event_function = event
        self.predict_function = predict
        self.ignore_time = ignore_time

        # A map from a displayable to the SpriteDisplayable object
        # representing that displayable.
        self.displayable_map = { }

        # A list of children of this displayable, in zorder. (When sorted.)
        # This is a list of Sprites.
        self.children = [ ]

        # True if at least one child has been killed.
        self.dead_child = False

        # True if at least one child responds to events.
        self.events = False

        # The width and height.
        self.width = None
        self.height = None

    def create(self, d):
        """
        :doc: sprites method

        Creates a new Sprite for the displayable `d`, and adds it to this
        SpriteManager.
        """

        id_d = id(d)

        sc = self.displayable_map.get(id_d, None)
        if sc is None:
            d = renpy.easy.displayable(d)

            sc = SpriteCache()
            sc.render = None
            sc.child = d
            sc.st = None
            self.displayable_map[id_d] = sc

        s = Sprite()
        s.x = 0
        s.y = 0
        s.zorder = 0
        s.cache = sc
        s.live = True
        s.manager = self
        s.events = False

        self.children.append(s)

        return s

    def predict_one(self):
        if self.predict_function is not None:
            for i in self.predict_function():
                renpy.display.predict.displayable(i)


    def redraw(self, delay=0):
        """
        :doc: sprites method

        Causes this SpriteManager to be redrawn in `delay` seconds.
        """

        renpy.display.render.redraw(self, delay)

    def render(self, width, height, st, at):

        self.width = width
        self.height = height

        if self.update_function is not None:

            redraw = self.update_function(st)

            if redraw is not None:
                renpy.display.render.redraw(self, redraw)

        if not self.ignore_time:
            self.displayable_map.clear()

        if self.dead_child:
            self.children = [ i for i in self.children if i.live ]

        self.children.sort(key=lambda sc:sc.zorder)

        caches = [ ]

        rv = renpy.display.render.Render(width, height)

        events = False

        for i in self.children:

            events |= i.events

            cache = i.cache
            r = i.cache.render
            if cache.render is None:
                if cache.st is None:
                    cache.st = st

                cst = st - cache.st

                cache.render = r = render(cache.child, width, height, cst, cst)
                cache.fast = (r.operation == BLIT) and (r.forward is None) and (r.alpha == 1.0) and (r.over == 1.0)
                rv.depends_on(r)

                caches.append(cache)


            if cache.fast:
                for child, xo, yo, _focus, _main in r.children:
                    rv.children.append((child,
                                        xo + i.x,
                                        yo + i.y,
                                        False,
                                        False))

            else:
                rv.subpixel_blit(r, (i.x, i.y))

        for i in caches:
            i.render = None

        return rv

    def event(self, ev, x, y, st):
        for i in xrange(len(self.children) -1, -1, -1):
            s = self.children[i]

            if s.events:
                rv = s.cache.child.event(ev, x - s.x, y - s.y, st - s.cache.st)
                if rv is not None:
                    return rv

        if self.event_function is not None:
            return self.event_function(ev, x, y, st)
        else:
            return None

    def visit(self):
        rv = [ ]

        try:
            if self.predict_function:
                pl = self.predict_function()
                for i in pl:
                    i = renpy.easy.displayable(i)
                    rv.append(i)
        except:
            pass

        return rv

    def destroy_all(self):
        self.children = [ ]


class Particles(renpy.display.core.Displayable, renpy.python.NoRollback):
    """
    Supports particle motion, using the old API.
    """

    __version__ = 1

    nosave = [ 'particles' ]

    def after_upgrade(self, version):
        if version < 1:
            self.sm = SpriteManager(update=self.update_callback, predict=self.predict_callback)

    def after_setstate(self):
        self.particles = None

    def __init__(self, factory, **properties):
        """
        @param factory: A factory object.
        """

        super(Particles, self).__init__(**properties)

        self.sm = SpriteManager(update=self.update_callback, predict=self.predict_callback)

        self.factory = factory
        self.particles = None

    def update_callback(self, st):

        particles = self.particles

        if st == 0 or particles is None:
            self.sm.destroy_all()
            particles = [ ]

        add_parts = self.factory.create(particles, st)

        new_particles = [ ]

        for sprite, p in particles:
            update = p.update(st)

            if update is None:
                sprite.destroy()
                continue

            x, y, _t, d = update

            if d is not sprite.cache.child:
                sprite.set_child(d)

            sprite.x = x
            sprite.y = y

            new_particles.append((sprite, p))

        if add_parts:
            for p in add_parts:
                update = p.update(st)

                if update is None:
                    continue

                x, y, _t, d = update

                if d is None:
                    continue

                sprite = self.sm.create(d)
                sprite.x = x
                sprite.y = y

                new_particles.append((sprite, p))

        self.particles = new_particles

        return 0

    def predict_callback(self):
        return self.factory.predict()

    def render(self, w, h, st, at):
        return renpy.display.render.render(self.sm, w, h, st, at)

class SnowBlossomFactory(renpy.python.NoRollback):

    rotate = False

    def __setstate__(self, state):
        self.start = 0
        vars(self).update(state)
        self.init()

    def __init__(self, image, count, xspeed, yspeed, border, start, fast, rotate=False):
        self.image = renpy.easy.displayable(image)
        self.count = count
        self.xspeed = xspeed
        self.yspeed = yspeed
        self.border = border
        self.start = start
        self.fast = fast
        self.rotate = rotate
        self.init()

    def init(self):
        self.starts = [ random.uniform(0, self.start) for _i in xrange(0, self.count) ] # W0201
        self.starts.append(self.start)
        self.starts.sort()

    def create(self, particles, st):

        def ranged(n):
            if isinstance(n, tuple):
                return random.uniform(n[0], n[1])
            else:
                return n

        if not particles and self.fast:
            rv = [ ]

            for _i in xrange(0, self.count):
                rv.append(SnowBlossomParticle(self.image,
                                              ranged(self.xspeed),
                                              ranged(self.yspeed),
                                              self.border,
                                              st,
                                              random.uniform(0, 100),
                                              fast=True,
                                              rotate=self.rotate))
            return rv


        if particles is None or len(particles) < self.count:

            # Check to see if we have a particle ready to start. If not,
            # don't start it.
            if particles and st < self.starts[len(particles)]:
                return None

            return [ SnowBlossomParticle(self.image,
                                         ranged(self.xspeed),
                                         ranged(self.yspeed),
                                         self.border,
                                         st,
                                         random.uniform(0, 100),
                                         fast=False,
                                         rotate=self.rotate) ]

    def predict(self):
        return [ self.image ]


class SnowBlossomParticle(renpy.python.NoRollback):

    def __init__(self, image, xspeed, yspeed, border, start, offset, fast, rotate):

        # safety.
        if yspeed == 0:
            yspeed = 1

        self.image = image
        self.xspeed = xspeed
        self.yspeed = yspeed
        self.border = border
        self.start = start
        self.offset = offset
        self.rotate = rotate


        if not rotate:
            sh = renpy.config.screen_height
            sw = renpy.config.screen_width
        else:
            sw = renpy.config.screen_height
            sh = renpy.config.screen_width


        if self.yspeed > 0:
            self.ystart = -border
        else:
            self.ystart = sh + border


        travel_time = (2.0 * border + sh) / abs(yspeed)

        xdist = xspeed * travel_time

        x0 = min(-xdist, 0)
        x1 = max(sw + xdist, sw)

        self.xstart = random.uniform(x0, x1)

        if fast:
            self.ystart = random.uniform(-border, sh + border)
            self.xstart = random.uniform(0, sw)

    def update(self, st):
        to = st - self.start

        xpos = self.xstart + to * self.xspeed
        ypos = self.ystart + to * self.yspeed

        if not self.rotate:
            sh = renpy.config.screen_height
        else:
            sh = renpy.config.screen_width

        if ypos > sh + self.border:
            return None

        if ypos < -self.border:
            return None

        if not self.rotate:
            return int(xpos), int(ypos), to + self.offset, self.image
        else:
            return int(ypos), int(xpos), to + self.offset, self.image

def SnowBlossom(d,
                count=10,
                border=50,
                xspeed=(20, 50),
                yspeed=(100, 200),
                start=0,
                fast=False,
                horizontal=False):

    """
    :doc: sprites_extra

    The snowblossom effect moves multiple instances of a sprite up,
    down, left or right on the screen. When a sprite leaves the screen, it
    is returned to the start.

    `d`
        The displayable to use for the sprites.

    `border`
        The size of the border of the screen. The sprite is considered to be
        on the screen until it clears the border, ensuring that sprites do
        not disappear abruptly.

    `xspeed`, `yspeed`
        The speed at which the sprites move, in the horizontal and vertical
        directions, respectively. These can be a single number or a tuple of
        two numbers. In the latter case, each particle is assigned a random
        speed between the two numbers. The speeds can be positive or negative,
        as long as the second number in a tuple is larger than the first.

    `start`
        The delay, in seconds, before each particle is added. This can be
        allows the particles to start at the top of the screen, while not
        looking like a "wave" effect.

    `fast`
        If true, particles start in the center of the screen, rather than
        only at the edges.

    `horizontal`
        If true, particles appear on the left or right side of the screen,
        rather than the top or bottom.
        """

    # If going horizontal, swap the xspeed and the yspeed.
    if horizontal:
        xspeed, yspeed = yspeed, xspeed

    return Particles(SnowBlossomFactory(image=d,
                                        count=count,
                                        border=border,
                                        xspeed=xspeed,
                                        yspeed=yspeed,
                                        start=start,
                                        fast=fast,
                                        rotate=horizontal))


########NEW FILE########
__FILENAME__ = pgrender
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This module wraps the pygame surface class (and associated functions). It
# ensures that returned surfaces have a 2px border around them.

import sys
import pygame
import renpy.display

# Sample surfaces, with and without alpha.
sample_alpha = None
sample_noalpha = None

def set_rgba_masks():
    """
    This rebuilds the sample surfaces, to ones that use the given
    masks.
    """

    # Annoyingly, the value for the big mask seems to vary from
    # platform to platform. So we read it out of a surface.

    global sample_alpha
    global sample_noalpha

    # Create a sample surface.
    s = pygame.Surface((10, 10), 0, 32)
    sample_alpha = s.convert_alpha()

    # Sort the components by absolute value.
    masks = list(sample_alpha.get_masks())
    masks.sort(key=lambda a : abs(a))

    # Choose the masks.
    if sys.byteorder == 'big':
        masks = ( masks[3], masks[2], masks[1], masks[0] )
    else:
        masks = ( masks[0], masks[1], masks[2], masks[3] )

    # Create the sample surface.
    sample_alpha = pygame.Surface((10, 10), 0, 32, masks)
    sample_noalpha = pygame.Surface((10, 10), 0, 32, masks[:3] + (0,))


class Surface(pygame.Surface):
    """
    This allows us to wrap around pygame's surface, to change
    its mode, as necessary.
    """

    opaque = False

    def is_opaque(self):
        return self.opaque

    def convert_alpha(self, surface=None):
        return copy_surface_unscaled(self, True)

    def convert(self, surface=None):
        return copy_surface(self, False)

    def copy(self):
        return copy_surface(self, self)

    def subsurface(self, rect):
        rv = pygame.Surface.subsurface(self, rect)
        return rv

def surface((width, height), alpha):
    """
    Constructs a new surface. The allocated surface is actually a subsurface
    of a surface that has a 2 pixel border in all directions.

    `alpha` - True if the new surface should have an alpha channel.
    """

    if isinstance(alpha, pygame.Surface):
        alpha = alpha.get_masks()[3]

    if alpha:
        sample = sample_alpha
    else:
        sample = sample_noalpha

    # We might not have initialized properly yet. This is enough
    # to get us underway.
    if sample is None:
        sample = pygame.Surface((4, 4), pygame.SRCALPHA, 32)

    surf = Surface((width + 4, height + 4), 0, sample)
    return surf.subsurface((2, 2, width, height)) # E1101

surface_unscaled = surface

def copy_surface(surf, alpha=True):
    """
    Creates a copy of the surface.
    """

    rv = surface_unscaled(surf.get_size(), alpha)
    renpy.display.accelerator.nogil_copy(surf, rv) # @UndefinedVariable
    return rv

copy_surface_unscaled = copy_surface


# Wrapper around image loading.

def load_image(f, filename):
    surf = pygame.image.load(f, renpy.exports.fsencode(filename))
    rv = copy_surface_unscaled(surf)
    return rv

load_image_unscaled = load_image


# Wrapper around functions we use from pygame.surface.

def flip(surf, horizontal, vertical):
    surf = pygame.transform.flip(surf, horizontal, vertical)
    return copy_surface_unscaled(surf)

flip_unscaled = flip


def rotozoom(surf, angle, zoom):

    surf = pygame.transform.rotozoom(surf, angle, zoom)
    return copy_surface_unscaled(surf)

rotozoom_unscaled = rotozoom


def transform_scale(surf, size):
    surf = pygame.transform.scale(surf, size)
    return copy_surface_unscaled(surf, surf)

transform_scale_unscaled = transform_scale


def transform_rotate(surf, angle):
    surf = pygame.transform.rotate(surf, angle)
    return copy_surface(surf)

transform_rotate_unscaled = transform_rotate

########NEW FILE########
__FILENAME__ = predict
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains the routines that manage image prediction.

import renpy.display

# Called to indicate an image should be loaded or preloaded. This is
# a function that takes an image manipulator, set by reset and predict,
# and winds up bound to either im.cache.get or im.cache.preload_image
image = None

# The set of displayables we've predicted since reset was last called.
predicted = set()

# A flag that indicates if we're currently predicting.
predicting = False

# A list of (screen name, argument dict) tuples, giving the screens we'd
# like to predict.
screens = [ ]

def displayable(d):
    """
    Called to predict that the displayable `d` will be shown.
    """

    if d is None:
        return

    if d not in predicted:
        predicted.add(d)
        d.visit_all(lambda i : i.predict_one())

def screen(_screen_name, *args, **kwargs):
    """
    Called to predict that the named screen is about to be shown
    with the given arguments.
    """

    screens.append((_screen_name, args, kwargs))


def reset():
    global image
    image = renpy.display.im.cache.get
    predicted.clear()
    del screens[:]


def prediction_coroutine(root_widget):
    """
    The image prediction co-routine. This predicts the images that can
    be loaded in the near future, and passes them to the image cache's
    preload_image method to be queued up for loading.

    The .send should be called with True to do a expensive prediction,
    and with False to either do an inexpensive prediction or no
    prediction at all.

    Returns True if there's more predicting to be done, or False
    if there's no more predicting worth doing.
    """

    global predicting

    # Wait to be told to start.
    yield True

    # Start the prediction thread (to clean out the cache).
    renpy.display.im.cache.start_prediction()

    # Set up the image prediction method.
    global image
    image = renpy.display.im.cache.preload_image

    # Predict images that are going to be reached in the next few
    # clicks.
    predicting = True

    for _i in renpy.game.context().predict():

        predicting = False
        yield True
        predicting = True

    # If there's a parent context, predict we'll be returning to it
    # shortly. Otherwise, call the functions in
    # config.predict_callbacks.

    if len(renpy.game.contexts) >= 2:
        sls = renpy.game.contexts[-2].scene_lists

        for l in sls.layers.itervalues():
            for sle in l:
                try:
                    displayable(sle.displayable)
                except:
                    pass

    else:
        for i in renpy.config.predict_callbacks:
            i()

    predicting = False

    while not (yield True):
        continue

    # Predict things (especially screens) that are reachable through
    # an action.
    predicting = True

    try:
        root_widget.visit_all(lambda i : i.predict_one_action())
    except:
        pass

    predicting = False

    predicted_screens = set()

    # Predict the screens themselves.
    for name, args, kwargs in screens:
        while not (yield True):
            continue

        if name in predicted_screens:
            continue

        predicted_screens.add(name)

        predicting = True

        try:
            renpy.display.screen.predict_screen(name, *args, **kwargs)
        except:
            if renpy.config.debug_image_cache:
                renpy.display.ic_log.write("While predicting screen %s %r", name, kwargs)
                renpy.display.ic_log.exception()

        predicting = False

    yield False


########NEW FILE########
__FILENAME__ = presplash
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Pre-splash code. The goal of this code is to try to get a pre-splash
# screen up as soon as possible, to let the user know something is
# going on.

# The presplash process, if any.
proc = None

# Called from the main process. This determines if
# we're even doing presplash, and if so what will be shown to the
# user. If it decides to show something to the user, uses subprocess
# to actually handle the showing.
def start(basedir, gamedir):
    import os.path

    if "RENPY_LESS_UPDATES" in os.environ:
        return

    global proc

    filenames = [ "/presplash.png", "/presplash.jpg" ]
    for fn in filenames:
        fn = gamedir + fn
        if os.path.exists(fn):
            break
    else:
        return

    try:
        import subprocess
        import sys

        cmd = [sys.executable, "-EO", sys.argv[0], "show", "presplash", fn]

        def fsencode(s):
            if isinstance(s, str):
                return s

            return s.encode(sys.getfilesystemencoding() or "utf-8", "replace")

        proc = subprocess.Popen([ fsencode(i) for i in cmd ], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    except:
        pass


# Called just before we initialize the display for real, to
# hide the splash, and terminate window centering.
def end():

    global proc

    if not proc:
        return

    proc.stdin.close()
    proc.wait()

    proc = None

# Called in the presplash process, to actually display the presplash.
def show(fn):

    import pygame.display
    import pygame.constants
    import sys
    import os

    os.environ['SDL_VIDEO_CENTERED'] = "1"

    try:
        import pygame.macosx
        pygame.macosx.init() #@UndefinedVariable
    except:
        pass

    try:
        import pygame.macosx #@Reimport
        pygame.macosx.Video_AutoInit()
    except:
        pass

    pygame.display.init()

    img = pygame.image.load(fn, fn)
    screen = pygame.display.set_mode(img.get_size(), pygame.constants.NOFRAME)
    screen.blit(img, (0, 0))
    pygame.display.update()

    sys.stdout.write("READY\r\n")
    sys.stdout.flush()
    sys.stdin.read()

    sys.exit(0)

########NEW FILE########
__FILENAME__ = scale
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This used to hack pygame to support resolution-scaling. Now it just kinda
# sits here, to provide compatibility with what it used to be.

import pygame
import renpy.display
import renpy.display.pgrender as pgrender

import _renpy

##############################################################################
# The scaling API that's used if we don't enable scaling.

# Gets the real pygame surface.
def real(s):
    return s

# Scales the number, n.
def scale(n):
    return n

def real_bilinear(src, size):
    rv = pgrender.surface_unscaled(size, src)
    renpy.display.module.bilinear_scale(src, rv)
    return rv

# Does pygame.transform.scale.
def real_transform_scale(surf, size):
    return pgrender.transform_scale_unscaled(surf, size)

# Loads an image, without scaling it.
def image_load_unscaled(f, hint, convert=True):
    rv = pgrender.load_image_unscaled(f, hint)
    return rv

# Saves an image without rescaling.
def image_save_unscaled(surf, filename):
    pygame.image.save(surf, renpy.exports.fsencode(filename))

# Scales down a surface.
def surface_scale(full):
    return full

real_renpy_pixellate = _renpy.pixellate
real_renpy_transform = _renpy.transform

def real_smoothscale(src, size, dest=None):
    """
    This scales src up or down to size. This uses both the pixellate
    and the transform operations to handle the scaling.
    """

    width, height = size
    srcwidth, srcheight = src.get_size()
    iwidth, iheight = srcwidth, srcheight

    if dest is None:
        dest = pgrender.surface_unscaled(size, src)

    if width == 0 or height == 0:
        return dest

    xshrink = 1
    yshrink = 1

    while iwidth >= width * 2:
        xshrink *= 2
        iwidth /= 2

    while iheight >= height * 2:
        yshrink *= 2
        iheight /= 2

    if iwidth != srcwidth or iheight != srcheight:
        inter = pgrender.surface_unscaled((iwidth, iheight), src)
        real_renpy_pixellate(src, inter, xshrink, yshrink, 1, 1)
        src = inter

    real_renpy_transform(src, dest,
                         0, 0,
                         1.0 * iwidth / width , 0,
                         0, 1.0 * iheight / height,
                         precise=1,
                         )

    return dest

smoothscale = real_smoothscale


########NEW FILE########
__FILENAME__ = screen
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import os
import time

PROFILE = set(i.strip() for i in os.environ.get("RENPY_PROFILE_SCREENS", "").split(","))

if "cprofile" in PROFILE:
    import cProfile
    cprof = cProfile.Profile()

    import atexit

    def cprof_atexit():
        cprof.dump_stats("/tmp/profile")

    atexit.register(cprof_atexit)
else:
    cprof = None

class Screen(renpy.object.Object):
    """
    A screen is a collection of widgets that are displayed together.
    This class stores information about the screen.
    """

    def __init__(self,
                 name,
                 function,
                 modal="False",
                 zorder="0",
                 tag=None,
                 predict=None,
                 variant=None,
                 parameters=False):

        # The name of this screen.
        if isinstance(name, basestring):
            name = tuple(name.split())

        self.name = name

        screens[name[0], variant] = self

        # A function that can be called to display the screen.
        self.function = function

        # If this is a SL2 screen, the SLScreen node at the root of this
        # screen.
        if isinstance(function, renpy.sl2.slast.SLScreen): # @UndefinedVariable
            self.ast = function
        else:
            self.ast = None

        # Expression: Are we modal? (A modal screen ignores screens under it.)
        self.modal = modal

        # Expression: Our zorder.
        self.zorder = zorder

        # The tag associated with the screen.
        self.tag = tag or name[0]

        # Can this screen be predicted?
        if predict is None:
            predict = renpy.config.predict_screens

        self.predict = predict

        # True if this screen takes parameters via _args and _kwargs.
        self.parameters = parameters


class ScreenDisplayable(renpy.display.layout.Container):
    """
    A screen is a collection of widgets that are displayed together. This
    class is responsible for managing the display of a screen.
    """

    nosave = [ 'screen', 'child', 'transforms', 'widgets', 'old_widgets', 'old_transforms', "cache" ]

    restarting = False

    def after_setstate(self):
        self.screen = get_screen_variant(self.screen_name[0])
        self.child = None
        self.transforms = { }
        self.widgets = { }
        self.old_widgets = None
        self.old_transforms = None
        self.cache = { }
        self.uses = 0

    def __init__(self, screen, tag, layer, widget_properties={}, scope={}, **properties):

        super(ScreenDisplayable, self).__init__(**properties)

        # Stash the properties, so we can re-create the screen.
        self.properties = properties

        # The screen, and it's name. (The name is used to look up the
        # screen on save.)
        self.screen = screen
        self.screen_name = screen.name

        # The tag and layer screen was displayed with.
        self.tag = tag
        self.layer = layer

        # The scope associated with this statement. This is passed in
        # as keyword arguments to the displayable.
        self.scope = renpy.python.RevertableDict(scope)

        # The child associated with this screen.
        self.child = None

        # Widget properties given to this screen the last time it was
        # shown.
        self.widget_properties = widget_properties

        # A map from name to the widget with that name.
        self.widgets = { }

        # The persistent cache.
        self.cache = { }

        if tag and layer:
            old_screen = get_screen(tag, layer)
        else:
            old_screen = None

        # A map from name to the transform with that name. (This is
        # taken from the old version of the screen, if it exists.
        if old_screen is not None:
            self.transforms = old_screen.transforms
        else:
            self.transforms = { }

        # What widgets and transforms were the last time this screen was
        # updated. Used to communicate with the ui module, and only
        # valid during an update - not used at other times.
        self.old_widgets = None
        self.old_transforms = None

        # Should we transfer data from the old_screen? This becomes
        # true once this screen finishes updating for the first time,
        # and also while we're using something.
        self.old_transfers = (old_screen and old_screen.screen_name == self.screen_name)

        # The current transform event, and the last transform event to
        # be processed.
        self.current_transform_event = None

        # A dict-set of widgets (by id) that have been hidden from us.
        self.hidden_widgets = { }

        # Are we hiding?
        self.hiding = False

        # Are we restarting?
        self.restarting = False

        # Modal and zorder.
        self.modal = renpy.python.py_eval(self.screen.modal, locals=self.scope)
        self.zorder = renpy.python.py_eval(self.screen.zorder, locals=self.scope)

        # The number of times this screen has been shown.
        self.uses = 0

    def __unicode__(self):
        return "Screen {}".format(" ".join(self.screen_name))

    def visit(self):
        return [ self.child ]

    def per_interact(self):
        renpy.display.render.redraw(self, 0)
        self.update()

    def set_transform_event(self, event):
        super(ScreenDisplayable, self).set_transform_event(event)
        self.current_transform_event = event

    def find_focusable(self, callback, focus_name):
        if self.child and not self.hiding:
            self.child.find_focusable(callback, focus_name)

    def _hide(self, st, at, kind):

        if self.hiding:
            hid = self
        else:
            hid = ScreenDisplayable(self.screen, self.tag, self.layer, self.widget_properties, self.scope, **self.properties)
            hid.transforms = self.transforms.copy()
            hid.widgets = self.widgets.copy()
            hid.old_transfers = True

        hid.hiding = True

        hid.current_transform_event = kind
        hid.update()

        renpy.display.render.redraw(hid, 0)

        rv = None

        # Compute the reverse of transforms and widgets.
        reverse_transforms = dict((id(v), k) for k, v in hid.transforms.iteritems())
        reverse_widgets = dict((id(v), k) for k, v in hid.widgets.iteritems())

        # Assumption: the only displayables that can keep us around
        # are Transforms that handle hide.

        # Iterate over our immediate children, trying to hide them.
        for d in list(hid.child.children):

            id_d = id(d)

            # If we have a transform, call its _hide method. If that comes
            # back non-None, store the new transform, and keep us alive.
            #
            # Otherwise, remove the child.
            name = reverse_transforms.get(id_d, None)

            if name is not None:
                c = d._hide(st, at, kind)

                if c is not None:
                    hid.transforms[name] = c
                    rv = hid
                else:
                    hid.hidden_widgets[name] = True
                    hid.child.remove(d)

                continue

            # Remove any non-transform children.
            name = reverse_widgets.get(id_d, None)

            if name is not None:
                hid.hidden_widgets[name] = True
                hid.child.remove(d)

        return rv

    def update(self):

        if self in updated_screens:
            return

        updated_screens.add(self)

        if self.screen is None:
            self.child = renpy.display.layout.Null()
            return { }

        # If we're restarting, do not update - the update can use variables
        # that are no longer in scope.
        if self.restarting:
            if not self.child:
                self.child = renpy.display.layout.Null()

            return self.widgets

        if PROFILE:
            start = time.time()

            if cprof:
                cprof.enable()

        # Update _current_screen
        global _current_screen
        old_screen = _current_screen
        _current_screen = self

        # Cycle widgets and transforms.
        self.old_widgets = self.widgets
        self.old_transforms = self.transforms
        self.widgets = { }
        self.transforms = { }

        # Render the child.
        old_ui_screen = renpy.ui.screen
        renpy.ui.screen = self

        renpy.ui.detached()
        self.child = renpy.ui.fixed(focus="_screen_" + "_".join(self.screen_name))
        self.children = [ self.child ]

        self.scope["_scope"] = self.scope
        self.scope["_name"] = 0

        self.screen.function(**self.scope)

        renpy.ui.close()

        renpy.ui.screen = old_ui_screen
        _current_screen = old_screen

        # Visit all the children, to get them started.
        self.child.visit_all(lambda c : c.per_interact())

        # Finish up.
        self.old_widgets = None
        self.old_transforms = None
        self.old_transfers = True

        if self.current_transform_event:

            for i in self.child.children:
                i.set_transform_event(self.current_transform_event)

            self.current_transform_event = None

        if PROFILE:

            if cprof:
                cprof.disable()

            profile = False

            if self.uses == 0 and ("predict" in PROFILE):
                profile = True
            elif self.uses == 1 and ("show" in PROFILE):
                profile = True
            elif self.uses >= 2 and ("update" in PROFILE):
                profile = True

            if self.uses:
                self.uses += 1

            if profile:

                end = time.time()
                if isinstance(self.screen.function, renpy.screenlang.ScreenLangScreen):
                    slversion = 1
                else:
                    slversion = 2

                if renpy.display.predict.predicting:
                    predict = "predict "
                else:
                    predict = ""

                print "{}screen {} took {:.3f}ms ({})".format(
                    predict,
                    " ".join(self.screen_name).encode("utf-8"),
                    1000.0 * (end - start), slversion)

        return self.widgets

    def render(self, w, h, st, at):

        if not self.child:
            self.update()

        child = renpy.display.render.render(self.child, w, h, st, at)

        rv = renpy.display.render.Render(w, h)

        rv.blit(child, (0, 0), focus=not self.hiding, main=not self.hiding)
        rv.modal = self.modal and not self.hiding

        return rv

    def get_placement(self):
        if not self.child:
            self.update()

        return self.child.get_placement()

    def event(self, ev, x, y, st):

        if self.hiding:
            return

        global _current_screen
        old_screen = _current_screen
        _current_screen = self

        rv = self.child.event(ev, x, y, st)

        _current_screen = old_screen

        if rv is not None:
            return rv

        if self.modal:
            raise renpy.display.layout.IgnoreLayers()


# The name of the screen that is currently being displayed, or
# None if no screen is being currently displayed.
_current_screen = None

# A map from (screen_name, variant) tuples to screen.
screens = { }

# The screens that were updated during the current interaction.
updated_screens = set()

def get_screen_variant(name):
    """
    Get a variant screen object for `name`.
    """

    for i in renpy.config.variants:
        rv = screens.get((name, i), None)
        if rv is not None:
            return rv

    return None

def prepare_screens():
    """
    Prepares all screens for use.
    """

    predict_cache.clear()

    for s in screens.values():
        if s.ast is None:
            continue

        s.ast.unprepare()

    for s in screens.values():
        if s.ast is None:
            continue

        s.ast.prepare()

def define_screen(*args, **kwargs):
    """
    :doc: screens
    :args: (name, function, modal="False", zorder="0", tag=None, variant=None)

    Defines a screen with `name`, which should be a string.

    `function`
        The function that is called to display the screen. The
        function is called with the screen scope as keyword
        arguments. It should ignore additional keyword arguments.

        The function should call the ui functions to add things to the
        screen.

    `modal`
        A string that, when evaluated, determines of the created
        screen should be modal. A modal screen prevents screens
        underneath it from receiving input events.

    `zorder`
        A string that, when evaluated, should be an integer. The integer
        controls the order in which screens are displayed. A screen
        with a greater zorder number is displayed above screens with a
        lesser zorder number.

    `tag`
        The tag associated with this screen. When the screen is shown,
        it replaces any other screen with the same tag. The tag
        defaults to the name of the screen.

    `predict`
        If true, this screen can be loaded for image prediction. If false,
        it can't. Defaults to true.

    `variant`
        String. Gives the variant of the screen to use.

    """

    Screen(*args, **kwargs)



def get_screen(name, layer="screens"):
    """
    :doc: screens

    Returns the ScreenDisplayable with the given `tag`, on
    `layer`. If no displayable with the tag is not found, it is
    interpreted as screen name. If it's still not found, None is returned.
     """

    if isinstance(name, basestring):
        name = tuple(name.split())

    tag = name[0]

    sl = renpy.exports.scene_lists()

    sd = sl.get_displayable_by_tag(layer, tag)

    if sd is None:
        sd = sl.get_displayable_by_name(layer, name)

    return sd

def has_screen(name):
    """
    Returns true if a screen with the given name exists.
    """

    if not isinstance(name, tuple):
        name = tuple(name.split())

    if not name:
        return False

    if get_screen_variant(name[0]):
        return True
    else:
        return False

# A map from screen to the cache from the last time the screen was
# predicted.
predict_cache = { }

def show_screen(_screen_name, *_args, **kwargs):
    """
    :doc: screens

    The programmatic equivalent of the show screen statement.

    Shows the named screen. This takes the following keyword arguments:

    `_screen_name`
        The name of the  screen to show.
    `_layer`
        The layer to show the screen on.
    `_tag`
        The tag to show the screen with. If not specified, defaults to
        the tag associated with the screen. It that's not specified,
        defaults to the name of the screen.,
    `_widget_properties`
        A map from the id of a widget to a property name -> property
        value map. When a widget with that id is shown by the screen,
        the specified properties are added to it.
    `_transient`
        If true, the screen will be automatically hidden at the end of
        the current interaction.

    Keyword arguments not beginning with underscore (_) are used to
    initialize the screen's scope.
    """

    _layer = kwargs.pop("_layer", "screens")
    _tag = kwargs.pop("_tag", None)
    _widget_properties = kwargs.pop("_widget_properties", {})
    _transient = kwargs.pop("_transient", False)

    name = _screen_name

    if not isinstance(name, tuple):
        name = tuple(name.split())

    screen = get_screen_variant(name[0])

    if screen is None:
        raise Exception("Screen %s is not known.\n" % (name[0],))

    if _tag is None:
        _tag = screen.tag

    scope = { }

    if screen.parameters:
        scope["_kwargs" ] = kwargs
        scope["_args"] = _args
    else:
        scope.update(kwargs)

    d = ScreenDisplayable(screen, _tag, _layer, _widget_properties, scope)

    if screen in predict_cache:
        d.cache = predict_cache.pop(screen)

    d.uses = 1

    renpy.exports.show(name, tag=_tag, what=d, layer=_layer, zorder=d.zorder, transient=_transient, munge_name=False)


PREDICT = "RENPY_NO_PREDICT_SCREENS" not in os.environ

def predict_screen(_screen_name, *_args, **kwargs):
    """
    Predicts the displayables that make up the given screen.

    `_screen_name`
        The name of the  screen to show.
    `_widget_properties`
        A map from the id of a widget to a property name -> property
        value map. When a widget with that id is shown by the screen,
        the specified properties are added to it.

    Keyword arguments not beginning with underscore (_) are used to
    initialize the screen's scope.
    """

    if not PREDICT:
        return

    _widget_properties = kwargs.pop("_widget_properties", {})
    _scope = kwargs.pop

    kwargs["_kwargs" ] = kwargs.copy()
    kwargs["_args"] = _args

    name = _screen_name

    if renpy.config.debug_image_cache:
        renpy.display.ic_log.write("Predict screen %s", name)

    if not isinstance(name, tuple):
        name = tuple(name.split())

    screen = get_screen_variant(name[0])

    scope = { }

    if screen.parameters:
        scope["_kwargs" ] = kwargs
        scope["_args"] = _args
    else:
        scope.update(kwargs)

    try:

        if screen is None:
            raise Exception("Screen %s is not known.\n" % (name[0],))

        if not screen.predict:
            return

        d = ScreenDisplayable(screen, None, None, _widget_properties, scope)

        if screen in predict_cache:
            d.cache = predict_cache[screen]

        d.update()
        predict_cache[screen] = d.cache

        renpy.display.predict.displayable(d)

    except:
        if renpy.config.debug_image_cache:
            import traceback

            print "While predicting screen", screen
            traceback.print_exc()

    renpy.ui.reset()


def hide_screen(tag, layer='screens'):
    """
    :doc: screens

    The programmatic equivalent of the hide screen statement.

    Hides the screen with `tag` on `layer`.
    """

    screen = get_screen(tag, layer)

    if screen is not None:
        renpy.exports.hide(screen.tag, layer=layer)

def use_screen(_screen_name, *_args, **kwargs):

    _name = kwargs.pop("_name", ())
    _scope = kwargs.pop("_scope", { })

    name = _screen_name

    if not isinstance(name, tuple):
        name = tuple(name.split())

    screen = get_screen_variant(name[0])

    if screen is None:
        raise Exception("Screen %r is not known." % (name,))

    old_transfers = _current_screen.old_transfers
    _current_screen.old_transfers = True

    scope = _scope.copy()

    if screen.parameters:
        scope["_kwargs"] = kwargs
        scope["_args"] = _args
    else:
        scope.update(kwargs)

    scope["_scope"] = scope
    scope["_name"] = (_name, name)

    screen.function(**scope)

    _current_screen.old_transfers = old_transfers

def current_screen():
    return _current_screen

def get_widget(screen, id, layer='screens'): #@ReservedAssignment
    """
    :doc: screens

    From the `screen` on `layer`, returns the widget with
    `id`. Returns None if the screen doesn't exist, or there is no
    widget with that id on the screen.
    """

    if isinstance(screen, ScreenDisplayable):
        screen = screen.screen_name

    if screen is None:
        screen = current_screen()
    else:
        screen = get_screen(screen, layer)

    if not isinstance(screen, ScreenDisplayable):
        return None

    if screen.child is None:
        screen.update()

    rv = screen.widgets.get(id, None)
    return rv

def before_restart():
    """
    This is called before Ren'Py restarts to put the screens into restart
    mode, which prevents crashes due to variables being used that are no
    longer defined.
    """

    for k, layer in renpy.display.interface.old_scene.iteritems():
        if k is None:
            continue

        for i in layer.children:
            if isinstance(i, ScreenDisplayable):
                i.restarting = True


########NEW FILE########
__FILENAME__ = swdraw
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import pygame
import math
import weakref
import time
import os

from renpy.display.render import blit_lock, IDENTITY, BLIT, DISSOLVE, IMAGEDISSOLVE, PIXELLATE

# A map from cached surface to rle version of cached surface.
rle_cache = weakref.WeakKeyDictionary()

class Clipper(object):
    """
    This is used to calculate the clipping rectangle and update rectangles
    used for a particular draw of the screen.
    """

    def __init__(self):

        # Lists of (x0, y0, x1, y1, clip, surface, transform) tuples,
        # representing how a displayable is drawn to the screen.
        self.blits = [ ]
        self.old_blits = [ ]

        # Sets of (x0, y0, x1, y1) tuples, representing areas that
        # aren't part of any displayable.
        self.forced = set()
        self.old_forced = set()

        # The set of surfaces that have been mutated recently.
        self.mutated = set()

    def compute(self, full_redraw):
        """
        This returns a clipping rectangle, and a list of update rectangles
        that cover the changes between the old and new frames.
        """

        # First, get things out of the fields, and update them. This
        # allows us to just return without having to do any cleanup
        # code.
        bl0 = self.old_blits
        bl1 = self.blits
        old_forced = self.old_forced
        forced = self.forced
        mutated = self.mutated

        self.old_blits = bl1
        self.blits = [ ]
        self.old_forced = forced
        self.forced = set()
        self.mutated = set()

        sw = renpy.config.screen_width
        sh = renpy.config.screen_height
        sa = sw * sh

        # A tuple representing the size of the fullscreen.
        fullscreen = (0, 0, sw, sh)

        # Check to see if a full redraw has been forced, and return
        # early.
        if full_redraw:
            return fullscreen, [ fullscreen ]

        # Quick checks to see if a dissolve is happening, or something like
        # that.
        changes = forced | old_forced

        if fullscreen in changes:
            return fullscreen, [ fullscreen ]

        # Compute the differences between the two sets, and add those
        # to changes.
        i0 = 0
        i1 = 0
        bl1set = set(bl1)

        while True:
            if i0 >= len(bl0) or i1 >= len(bl1):
                break

            b0 = bl0[i0]
            b1 = bl1[i1]

            if b0 == b1:
                if id(b0[5]) in mutated:
                    changes.add(b0[:5])

                i0 += 1
                i1 += 1

            elif b0 not in bl1set:
                changes.add(b0[:5])
                i0 += 1

            else:
                changes.add(b1[:5])
                i1 += 1

        changes.update(i[:5] for i in bl0[i0:])
        changes.update(i[:5] for i in bl1[i1:])

        # No changes? Quit.
        if not changes:
            return None, [ ]

        # Compute the sizes of the updated rectangles.
        sized = [ ]

        for x0, y0, x1, y1, (sx0, sy0, sx1, sy1) in changes:

            # Round up by a pixel, to prevent visual artifacts when scaled down.
            x1 += 1
            y1 += 1

            if x0 < sx0:
                x0 = sx0
            if y0 < sy0:
                y0 = sy0
            if x1 > sx1:
                x1 = sx1
            if y1 > sy1:
                y1 = sy1

            w = x1 - x0
            h = y1 - y0

            if w <= 0 or h <= 0:
                continue

            area = w * h

            if area >= sa:
                return fullscreen, [ fullscreen ]

            sized.append((area, x0, y0, x1, y1))

        sized.sort()

        # The list of non-contiguous updates.
        noncont = [ ]

        # The total area of noncont.
        nca = 0

        # Pick the largest area, merge with all overlapping smaller areas, repeat
        # until no merge possible.
        while sized:
            area, x0, y0, x1, y1 = sized.pop()


            merged = False

            if nca + area >= sa:
                return (0, 0, sw, sh), [ (0, 0, sw, sh) ]

            i = 0

            while i < len(sized):
                _iarea, ix0, iy0, ix1, iy1 = sized[i]

                if (x0 <= ix0 <= x1 or x0 <= ix1 <= x1) and \
                   (y0 <= iy0 <= y1 or y0 <= iy1 <= y1):

                    merged = True
                    x0 = min(x0, ix0)
                    x1 = max(x1, ix1)
                    y0 = min(y0, iy0)
                    y1 = max(y1, iy1)

                    area = (x1 - x0) * (y1 - y0)

                    sized.pop(i)

                else:
                    i += 1

            if merged:
                sized.append((area, x0, y0, x1, y1))
            else:
                noncont.append((x0, y0, x1, y1))
                nca += area

        if not noncont:
            return None, [ ]

        x0, y0, x1, y1 = noncont.pop()
        x0 = int(x0)
        y0 = int(y0)
        x1 = int(math.ceil(x1))
        y1 = int(math.ceil(y1))

        # A list of (x, y, w, h) tuples for each update.
        updates = [ (x0, y0, x1 - x0, y1 - y0) ]

        for ix0, iy0, ix1, iy1 in noncont:

            ix0 = int(ix0)
            iy0 = int(iy0)
            ix1 = int(math.ceil(ix1))
            iy1 = int(math.ceil(iy1))

            x0 = min(x0, ix0)
            y0 = min(y0, iy0)
            x1 = max(x1, ix1)
            y1 = max(y1, iy1)

            updates.append((ix0, iy0, ix1 - ix0, iy1 - iy0))

        return (x0, y0, x1 - x0, y1 - y0), updates

clippers = [ Clipper() ]

def surface(w, h, alpha):
    """
    Creates a surface that shares a pixel format with the screen. The created
    surface will
    """

    if alpha:
        rv = pygame.Surface((w + 4, h + 4), pygame.SRCALPHA)
    else:
        rv = pygame.Surface((w + 4, h + 4), 0)

    return rv.subsurface((2, 2, w, h))

def copy_surface(surf):
    w, h = surf.get_size()
    rv = surface(w, h, True)

    renpy.display.accelerator.nogil_copy(surf, rv) # @UndefinedVariable
    return rv

def draw_special(what, dest, x, y):
    """
    This handles the special drawing operations, such as dissolve and
    image dissolve. `x` and `y` are the offsets of the thing to be drawn
    relative to the destination rectangle, and are always negative.
    """

    dw, dh = dest.get_size()

    w = min(dw, what.width + x)
    h = min(dh, what.height + y)

    if w <= 0 or h <= 0:
        return

    if what.operation == DISSOLVE:

        bottom = what.children[0][0].render_to_texture(True)
        top = what.children[1][0].render_to_texture(True)

        if what.operation_alpha:
            target = surface(w, h, True)
        else:
            target = dest.subsurface((0, 0, w, h))

        renpy.display.module.blend(
            bottom.subsurface((-x, -y, w, h)),
            top.subsurface((-x, -y, w, h)),
            target,
            int(what.operation_complete * 255))

        if what.operation_alpha:
            dest.blit(target, (0, 0))

    elif what.operation == IMAGEDISSOLVE:

        image = what.children[0][0].render_to_texture(True)
        bottom = what.children[1][0].render_to_texture(True)
        top = what.children[2][0].render_to_texture(True)

        if what.operation_alpha:
            target = surface(w, h, True)
        else:
            target = dest.subsurface((0, 0, w, h))

        ramplen = what.operation_parameter

        ramp = "\x00" * 256

        for i in xrange(0, ramplen):
            ramp += chr(255 * i / ramplen)

        ramp += "\xff" * 256

        step = int( what.operation_complete * (256 + ramplen) )
        ramp = ramp[step:step+256]

        renpy.display.module.imageblend(
            bottom.subsurface((-x, -y, w, h)),
            top.subsurface((-x, -y, w, h)),
            target,
            image.subsurface((-x, -y, w, h)),
            ramp)

        if what.operation_alpha:
            dest.blit(target, (0, 0))

    elif what.operation == PIXELLATE:

        surf = what.children[0][0].render_to_texture(False)

        px = what.operation_parameter

        renpy.display.module.pixellate(
            surf.subsurface((-x, -y, w, h)),
            dest.subsurface((0, 0, w, h)),
            px, px, px, px)

    else:
        raise Exception("Unknown operation: %d" % what.operation)


def draw(dest, clip, what, xo, yo, screen):
    """
    This is the simple draw routine, which only works when alpha is 1.0
    and the matrices are None. If those aren't the case, draw_complex
    is used instead.

    `dest` - Either a destination surface, or a clipper.
    `clip` - If None, we should draw. Otherwise we should clip, and this is
    the rectangle to clip to.
    `what` - The Render or Surface we're drawing to.
    `xo` - The X offset.
    `yo` - The Y offset.
    `screen` - True if this is a blit to the screen, False otherwise.
    """

    if not isinstance(what, renpy.display.render.Render):

        # Pixel-Aligned blit.
        if isinstance(xo, int) and isinstance(yo, int):
            if screen:
                what = rle_cache.get(what, what)

            if clip:
                w, h = what.get_size()
                dest.blits.append((xo, yo, xo + w, yo + h, clip, what, None))
            else:
                try:
                    blit_lock.acquire()
                    dest.blit(what, (xo, yo))
                finally:
                    blit_lock.release()

        # Subpixel blit.
        else:
            if clip:
                w, h = what.get_size()
                dest.blits.append((xo, yo, xo + w, yo + h, clip, what, None))
            else:
                renpy.display.module.subpixel(what, dest, xo, yo)

        return

    # Deal with draw functions.
    if what.operation != BLIT:

        xo = int(xo)
        yo = int(yo)

        if clip:
            dx0, dy0, dx1, dy1 = clip
            dw = dx1 - dx0
            dh = dy1 - dy0
        else:
            dw, dh = dest.get_size()

        if xo >= 0:
            newx = 0
            subx = xo
        else:
            newx = xo
            subx = 0

        if yo >= 0:
            newy = 0
            suby = yo
        else:
            newy = yo
            suby = 0

        if subx >= dw or suby >= dh:
            return

        # newx and newy are the offset of this render relative to the
        # subsurface. They can only be negative or 0, as otherwise we
        # would make a smaller subsurface.

        subw = min(dw - subx, what.width + newx)
        subh = min(dh - suby, what.height + newy)

        if subw <= 0 or subh <= 0:
            return

        if clip:
            dest.forced.add((subx, suby, subx + subw, suby + subh, clip))
        else:
            newdest = dest.subsurface((subx, suby, subw, subh))
            # what.draw_func(newdest, newx, newy)
            draw_special(what, newdest, newx, newy)


        return

    # Deal with clipping, if necessary.
    if what.clipping:

        if clip:
            cx0, cy0, cx1, cy1 = clip

            cx0 = max(cx0, xo)
            cy0 = max(cy0, yo)
            cx1 = min(cx1, xo + what.width)
            cy1 = min(cy1, yo + what.height)

            if cx0 > cx1 or cy0 > cy1:
                return

            clip = (cx0, cy0, cx1, cy1)

            dest.forced.add(clip + (clip,))
            return

        else:

            # After this code, x and y are the coordinates of the subsurface
            # relative to the destination. xo and yo are the offset of the
            # upper-left corner relative to the subsurface.

            if xo >= 0:
                x = xo
                xo = 0
            else:
                x = 0
                # xo = xo

            if yo >= 0:
                y = yo
                yo = 0
            else:
                y = 0
                # yo = yo

            dw, dh = dest.get_size()

            width = min(dw - x, what.width + xo)
            height = min(dh - y, what.height + yo)

            if width < 0 or height < 0:
                return

            dest = dest.subsurface((x, y, width, height))

    # Deal with alpha and transforms by passing them off to draw_transformed.
    if what.alpha != 1 or what.over != 1.0 or (what.forward is not None and what.forward is not IDENTITY):
        for child, cxo, cyo, _focus, _main in what.visible_children:
            draw_transformed(dest, clip, child, xo + cxo, yo + cyo,
                             what.alpha * what.over, what.forward, what.reverse)
        return

    for child, cxo, cyo, _focus, _main in what.visible_children:
        draw(dest, clip, child, xo + cxo, yo + cyo, screen)

def draw_transformed(dest, clip, what, xo, yo, alpha, forward, reverse):

    # If our alpha has hit 0, don't do anything.
    if alpha <= 0.003: # (1 / 256)
        return

    if forward is None:
        forward = IDENTITY
        reverse = IDENTITY

    if not isinstance(what, renpy.display.render.Render):

        # Figure out where the other corner of the transformed surface
        # is on the screen.
        sw, sh = what.get_size()
        if clip:

            dx0, dy0, dx1, dy1 = clip
            dw = dx1 - dx0
            dh = dy1 - dy0

        else:
            dw, dh = dest.get_size()

        x0, y0 = 0.0, 0.0
        x1, y1 = reverse.transform(sw, 0.0)
        x2, y2 = reverse.transform(sw, sh)
        x3, y3 = reverse.transform(0.0, sh)

        minx = math.floor(min(x0, x1, x2, x3) + xo)
        maxx = math.ceil(max(x0, x1, x2, x3) + xo)
        miny = math.floor(min(y0, y1, y2, y3) + yo)
        maxy = math.ceil(max(y0, y1, y2, y3) + yo)

        if minx < 0:
            minx = 0
        if miny < 0:
            miny = 0

        if maxx > dw:
            maxx = dw
        if maxy > dh:
            maxy = dh

        if minx > dw or miny > dh or maxx < 0 or maxy < 0:
            return

        cx, cy = forward.transform(minx - xo, miny - yo)

        if clip:

            dest.blits.append(
                (minx, miny, maxx + dx0, maxy + dy0, clip, what,
                 (cx, cy,
                  forward.xdx, forward.ydx,
                  forward.xdy, forward.ydy,
                  alpha)))

        else:

            dest = dest.subsurface((minx, miny, maxx - minx, maxy - miny))

            renpy.display.module.transform(
                what, dest,
                cx, cy,
                forward.xdx, forward.ydx,
                forward.xdy, forward.ydy,
                alpha, True)

        return

    if what.clipping:

        if reverse.xdy or reverse.ydx:
            draw_transformed(dest, clip, what.pygame_surface(True), xo, yo, alpha, forward, reverse)
            return

        width = what.width * reverse.xdx
        height = what.height * reverse.ydy

        if clip:
            cx0, cy0, cx1, cy1 = clip

            cx0 = max(cx0, xo)
            cy0 = max(cy0, yo)
            cx1 = min(cx1, xo + width)
            cy1 = min(cy1, yo + height)

            if cx0 > cx1 or cy0 > cy1:
                return

            clip = (cx0, cy0, cx1, cy1)

            dest.forced.add(clip + (clip,))
            return

        else:

            # After this code, x and y are the coordinates of the subsurface
            # relative to the destination. xo and yo are the offset of the
            # upper-left corner relative to the subsurface.

            if xo >= 0:
                x = xo
                xo = 0
            else:
                x = 0
                # xo = xo

            if yo >= 0:
                y = yo
                yo = 0
            else:
                y = 0
                # yo = yo

            dw, dh = dest.get_size()

            width = min(dw - x, width + xo)
            height = min(dh - y, height + yo)

            if width < 0 or height < 0:
                return

            dest = dest.subsurface((x, y, width, height))

    if what.draw_func or what.operation != BLIT:
        child = what.pygame_surface(True)
        draw_transformed(dest, clip, child, xo, yo, alpha, forward, reverse)
        return

    for child, cxo, cyo, _focus, _main in what.visible_children:

        cxo, cyo = reverse.transform(cxo, cyo)

        if what.forward:
            child_forward = forward * what.forward
            child_reverse = what.reverse * reverse
        else:
            child_forward = forward
            child_reverse = reverse

        draw_transformed(dest, clip, child, xo + cxo, yo + cyo, alpha * what.alpha * what.over, child_forward, child_reverse)



def do_draw_screen(screen_render, full_redraw, swdraw):
    """
    Draws the render produced by render_screen to the screen.
    """

    yoffset = xoffset = 0

    screen_render.is_opaque()

    clip = (xoffset, yoffset, xoffset + screen_render.width, yoffset + screen_render.height)
    clipper = clippers[0]

    draw(clipper, clip, screen_render, xoffset, yoffset, True)

    cliprect, updates = clipper.compute(full_redraw)

    if cliprect is None:
        return [ ]

    x, y, _w, _h = cliprect

    dest = swdraw.window.subsurface(cliprect)
    draw(dest, None, screen_render, -x, -y, True)

    return updates


class SWDraw(object):
    """
    This uses the software renderer to draw to the screen.
    """

    def __init__(self):
        self.display_info = None

        self.reset()

    def reset(self):

        # Should we draw the screen?
        self.suppressed_blit = False

        # The earliest time at which the next frame can be redrawn.
        self.next_frame = 0

        # Mouse re-drawing.
        self.mouse_location = None
        self.mouse_backing = None
        self.mouse_backing_pos = None
        self.mouse_info = None


        # Is the mouse currently visible?
        self.mouse_old_visible = None

        # This is used to cache the surface->texture operation.
        self.texture_cache = weakref.WeakKeyDictionary()

        # This is used to display video to the screen.
        self.fullscreen_surface = None

        # Info.
        self.info = { "renderer" : "sw", "resizable" : False, "additive" : False }

        pygame.display.init()
        renpy.display.interface.post_init()

        if self.display_info is None:
            self.display_info = renpy.display.get_info()

        # The scale factor we use for this display.
        self.scale_factor = 1.0

        # Should we scale fast, or scale good-looking?
        self.scale_fast = "RENPY_SCALE_FAST" in os.environ

        # The screen returned to us from pygame.
        self.screen = None

        # The window that we render into, if not the screen. This has a
        # 1px border around it iff we're scaling.
        self.window = None

    def set_mode(self, virtual_size, physical_size, fullscreen):

        # Reset before resize.
        renpy.display.interface.kill_textures_and_surfaces()
        self.reset()

        width, height = virtual_size

        # Set up scaling, if necessary.
        screen_width = self.display_info.current_w
        screen_height = self.display_info.current_h

        if not fullscreen:
            screen_height -= 102
            screen_width -= 102

        scale_factor = min(1.0 * screen_width / width, 1.0 * screen_height / height, 1.0)
        if "RENPY_SCALE_FACTOR" in os.environ:
            scale_factor = float(os.environ["RENPY_SCALE_FACTOR"])
        self.scale_factor = scale_factor

        # Figure out the fullscreen info.
        if fullscreen:
            fsflag = pygame.FULLSCREEN
        else:
            fsflag = 0

        # If a window exists of the right size and flags, use it. Otherwise,
        # make our own window.
        old_screen = pygame.display.get_surface()

        scaled_width = int(width * scale_factor)
        scaled_height = int(height * scale_factor)

        if ((old_screen is not None) and
            (old_screen.get_size() == (scaled_width, scaled_height)) and
            (old_screen.get_flags() & pygame.FULLSCREEN == fsflag) and
            not (old_screen.get_flags() & pygame.OPENGL)
            ):

            self.screen = old_screen

        else:
            self.screen = pygame.display.set_mode((scaled_width, scaled_height), fsflag, 32)

        if scale_factor != 1.0:
            self.window = surface(width, height, True)
        else:
            self.window = self.screen

        renpy.display.pgrender.set_rgba_masks()

        # Should we redraw the screen from scratch?
        self.full_redraw = True

        # The surface used to display fullscreen video.
        self.fullscreen_surface = self.screen

        # Reset this on a mode change.
        self.mouse_location = None
        self.mouse_backing = None
        self.mouse_backing_pos = None
        self.mouse_info = None

        return True

    # private
    def show_mouse(self, pos, info):
        """
        Actually shows the mouse.
        """

        self.mouse_location = pos
        self.mouse_info = info

        mxo, myo, tex = info

        mx, my = pos
        mw, mh = tex.get_size()

        bx = mx - mxo
        by = my - myo

        self.mouse_backing_pos = (bx, by)
        self.mouse_backing = surface(mw, mh, False)
        self.mouse_backing.blit(self.window, (0, 0), (bx, by, mw, mh))

        self.screen.blit(tex, (bx, by))

        return bx, by, mw, mh

    # private
    def hide_mouse(self):
        """
        Actually hides the mouse.
        """

        size = self.mouse_backing.get_size()
        self.screen.blit(self.mouse_backing, self.mouse_backing_pos)

        rv = self.mouse_backing_pos + size

        self.mouse_backing = None
        self.mouse_backing_pos = None
        self.mouse_location = None

        return rv

    # private
    def draw_mouse(self, show_mouse):
        """
        This draws the mouse to the screen, if necessary. It uses the
        buffer to minimize the amount of the screen that needs to be
        drawn, and only redraws if the mouse has actually been moved.
        """

        hardware, x, y, tex = renpy.game.interface.get_mouse_info()

        if self.mouse_old_visible != hardware:
            pygame.mouse.set_visible(hardware)
            self.mouse_old_visible = hardware

        # The rest of this is for the software mouse.

        if self.suppressed_blit:
            return [ ]

        if not show_mouse:
            tex = None

        info = (x, y, tex)
        pos = pygame.mouse.get_pos()

        if (pos == self.mouse_location and tex and info == self.mouse_info):
            return [ ]

        updates = [ ]

        if self.mouse_location:
            updates.append(self.hide_mouse())

        if tex and pos and renpy.game.interface.focused:
            updates.append(self.show_mouse(pos, info))

        return updates

    def update_mouse(self):
        """
        Draws the mouse, and then updates the screen.
        """

        updates = self.draw_mouse(True)

        if updates:
            pygame.display.update(updates)

    def mouse_event(self, ev):
        x, y = getattr(ev, 'pos', pygame.mouse.get_pos())

        x /= self.scale_factor
        y /= self.scale_factor

        return x, y

    def get_mouse_pos(self):
        x, y = pygame.mouse.get_pos()

        x /= self.scale_factor
        y /= self.scale_factor

        return x, y

    def set_mouse_pos(self, x, y):

        x *= self.scale_factor
        y *= self.scale_factor

        return pygame.mouse.set_pos([x, y])


    def screenshot(self, surftree, fullscreen_video):
        """
        Returns a pygame surface containing a screenshot.
        """

        return self.window

    def should_redraw(self, needs_redraw, first_pass):
        """
        Uses the framerate to determine if we can and should redraw.
        """

        if not needs_redraw:
            return False

        framerate = renpy.config.framerate

        if framerate is None:
            return True

        next_frame = self.next_frame
        now = pygame.time.get_ticks()

        frametime = 1000.0 / framerate

        # Handle timer rollover.
        if next_frame > now + frametime:
            next_frame = now

        # It's not yet time for the next frame.
        if now < next_frame and not first_pass:
            return False

        # Otherwise, it is. Schedule the next frame.
        # if next_frame + frametime < now:
        next_frame = now + frametime
        # else:
        #    next_frame += frametime

        self.next_frame = next_frame

        return True


    def draw_screen(self, surftree, fullscreen_video):
        """
        Draws the screen.
        """

        if not fullscreen_video:

            updates = [ ]

            updates.extend(self.draw_mouse(False))

            damage = do_draw_screen(surftree, self.full_redraw, self)

            if damage:
                updates.extend(damage)

            self.full_redraw = False

            if self.window is self.screen:

                updates.extend(self.draw_mouse(True))
                pygame.display.update(updates)

            else:

                if self.scale_fast:
                    pygame.transform.scale(self.window, self.screen.get_size(), self.screen)
                else:
                    renpy.display.scale.smoothscale(self.window, self.screen.get_size(), self.screen)

                self.draw_mouse(True)
                pygame.display.flip()

        else:
            pygame.display.flip()
            self.full_redraw = True

        self.suppressed_blit = fullscreen_video


    def render_to_texture(self, render, alpha):

        rv = surface(render.width, render.height, alpha)
        draw(rv, None, render, 0, 0, False)

        return rv

    def is_pixel_opaque(self, what, x, y):

        if x < 0 or y < 0 or x >= what.width or y >= what.height:
            return 0

        for (child, xo, yo, _focus, _main) in what.visible_children:
            cx = x - xo
            cy = y - yo

            if what.forward:
                cx, cy = what.forward.transform(cx, cy)


            if isinstance(child, renpy.display.render.Render):
                if self.is_pixel_opaque(child, x, y):
                    return True

            else:
                cx = int(cx)
                cy = int(cy)

                cw, ch = child.get_size()
                if cx >= cw or cy >= ch:
                    return False



                if not child.get_masks()[3] or child.get_at((cx, cy))[3]:
                    return True

        return False


    def mutated_surface(self, surf):
        """
        Called to indicate that the given surface has changed.
        """

        for i in clippers:
            i.mutated.add(id(surf))

        if surf in rle_cache:
            del rle_cache[surf]


    def load_texture(self, surf, transient=False):
        """
        Creates a texture from the surface. In the software implementation,
        the only difference between a texture and a surface is that a texture
        is in the RLE cache.
        """

        surf = copy_surface(surf)
        self.mutated_surface(surf)

        if transient:
            return surf

        if renpy.game.less_memory:
            return surf

        if surf not in rle_cache:
            rle_surf = copy_surface(surf)
            rle_surf.set_alpha(255, pygame.RLEACCEL)
            self.mutated_surface(rle_surf)

            rle_cache[surf] = rle_surf

        return surf

    def solid_texture(self, w, h, color):
        """
        Creates a texture filled to the edges with color.
        """

        surf = surface(w + 4, h + 4, True)
        surf.fill(color)
        self.mutated_surface(surf)

        surf = surf.subsurface((2, 2, w, h))

        self.mutated_surface(surf)
        return surf


    def free_memory(self):
        """
        Frees up memory.
        """

        rle_cache.clear()

    def deinit(self):
        """
        Called when we're restarted.
        """

        renpy.display.render.free_memory()

        return

    def quit(self): #@ReservedAssignment
        """
        Shuts down the drawing system.
        """

        pygame.display.quit()

        return

    def event_peek_sleep(self):
        """
        Wait a little bit so the CPU doesn't speed up.
        """

        time.sleep(.0001)

    def get_physical_size(self):
        """
        Return the physical width and height of the screen.
        """
        return renpy.config.screen_width, renpy.config.screen_height

########NEW FILE########
__FILENAME__ = transition
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# NOTE:
# Transitions need to be able to work even when old_widget and new_widget
# are None, at least to the point of making it through __init__. This is
# so that prediction of images works.

import renpy.display
from renpy.display.render import render


class Transition(renpy.display.core.Displayable):
    """
    This is the base class of most transitions. It takes care of event
    dispatching.
    """

    def __init__(self, delay, **properties):
        super(Transition, self).__init__(**properties)
        self.delay = delay
        self.events = True

    def event(self, ev, x, y, st):

        if self.events or ev.type == renpy.display.core.TIMEEVENT:
            return self.new_widget.event(ev, x, y, st) # E1101
        else:
            return None

    def visit(self):
        return [ self.new_widget, self.old_widget ] # E1101


def null_render(d, width, height, st, at):

    d.events = True
    surf = renpy.display.render.render(d.new_widget,
                                       width,
                                       height,
                                       st, at)

    rv = renpy.display.render.Render(surf.width, surf.height)
    rv.blit(surf, (0, 0))

    return rv

class NoTransition(Transition):
    """
    :doc: transition function
    :args: (delay)

    Returns a transition that only displays the new screen for `delay` seconds.
    It can be useful as part of a MultipleTransition.
    """

    def __init__(self, delay, old_widget=None, new_widget=None, **properties):
        super(NoTransition, self).__init__(delay, **properties)

        self.old_widget = old_widget
        self.new_widget = new_widget
        self.events = True

    def render(self, width, height, st, at):
        return null_render(self, width, height, st, at)


class MultipleTransition(Transition):
    """
    :doc: transition function
    :args: (args)

    Returns a transition that allows multiple transitions to be displayed, one
    after the other.

    `args`
        A *list* containing an odd number of items. The first, third, and
        other odd-numbered items must be scenes, and the even items
        must be transitions. A scene can be one of:

        * A displayable.
        * False, to use the old scene.
        * True, to use the new scene.

        Almost always, the first argument will be False and the last True.

    The transitions in `args` are applied in order. For each transition,
    the old scene is the screen preceding it, and the new scene is the
    scene following it. For example::

        define logodissolve = MultipleTransition([
            False, Dissolve(0.5)
            "logo.jpg", NoTransition(1.0),
            "logo.jpg", dissolve,
            True])

    This example will dissolve to logo.jpg, wait 1 second, and then
    dissolve to the new scene.
    """

    def __init__(self, args, old_widget=None, new_widget=None, **properties):

        if len(args) % 2 != 1 or len(args) < 3:
            raise Exception("MultipleTransition requires an odd number of arguments, and at least 3 arguments.")

        self.transitions = [ ]

        # The screens that we use for the transition.
        self.screens = [ renpy.easy.displayable(i) for i in args[0::2] ]

        def oldnew(w):
            if w is False:
                return old_widget
            if w is True:
                return new_widget

            return w

        for old, trans, new in zip(self.screens[0:], args[1::2], self.screens[1:]):
            old = oldnew(old)
            new = oldnew(new)

            self.transitions.append(trans(old_widget=old, new_widget=new))

        super(MultipleTransition, self).__init__(sum([i.delay for i in self.transitions]), **properties)

        self.new_widget = self.transitions[-1]
        self.events = False

    def visit(self):
        return [ i for i in self.screens if isinstance(i, renpy.display.core.Displayable)] + self.transitions

    def event(self, ev, x, y, st):

        if self.events or ev.type == renpy.display.core.TIMEEVENT:
            return self.transitions[-1].event(ev, x, y, st)
        else:
            return None

    def render(self, width, height, st, at):

        if renpy.game.less_updates:
            return null_render(self, width, height, st, at)

        for trans in self.transitions[:-1]:

            if trans.delay > st:
                break

            st -= trans.delay

        else:

            trans = self.transitions[-1]
            self.events = True

        if trans is not self.transitions[-1]:
            renpy.display.render.render(self.transitions[-1], width, height, 0, 0)

        surf = renpy.display.render.render(trans, width, height, st, at)
        width, height = surf.get_size()
        rv = renpy.display.render.Render(width, height)
        rv.blit(surf, (0, 0))

        if st < trans.delay:
            renpy.display.render.redraw(self, trans.delay - st)

        return rv


def Fade(out_time,
         hold_time,
         in_time,
         old_widget=None,
         new_widget=None,
         color=None,
         widget=None,
         alpha=False,
         ):

    """
    :doc: transition function
    :args: (out_time, hold_time, in_time, color="#000")
    :name: Fade

    Returns a transition that takes `out_time` seconds to fade to
    a screen filled with `color`, holds at that screen for `hold_time`
    seconds, and then takes `in_time` to fade to then new screen.

    ::

        # Fade to black and back.
        define fade = Fade(0.5, 0.0, 0.5)

        # Hold at black for a bit.
        define fadehold = Fade(0.5, 1.0, 0.5)

        # Camera flash - quickly fades to white, then back to the scene.
        define flash = Fade(0.1, 0.0, 0.5, color="#fff")
    """

    dissolve = renpy.curry.curry(Dissolve)
    notrans = renpy.curry.curry(NoTransition)

    widget = renpy.easy.displayable_or_none(widget)

    if color:
        widget = renpy.display.image.Solid(color)

    if not widget:
        widget = renpy.display.image.Solid((0, 0, 0, 255))

    args = [ False, dissolve(out_time, alpha=alpha), widget ]

    if hold_time:
        args.extend([ notrans(hold_time), widget, ])

    args.extend([dissolve(in_time, alpha=alpha), True ])

    return MultipleTransition(args, old_widget=old_widget, new_widget=new_widget)


class Pixellate(Transition):
    """
    :doc: transition function
    :args: (time, steps)
    :name: Pixellate

    Returns a transition that pixellates out the old screen, and then
    pixellates in the new screen.

    `time`
        The total time the transition will take, in seconds.

    `steps`
        The number of steps that will occur, in each direction. Each step
        creates pixels about twice the size of those in the previous step,
        so a 5-step pixellation will create 32x32 pixels.
    """

    def __init__(self, time, steps, old_widget=None, new_widget=None, **properties):

        time = float(time)

        super(Pixellate, self).__init__(time, **properties)

        self.time = time
        self.steps = steps

        self.old_widget = old_widget
        self.new_widget = new_widget

        self.events = False

        self.quantum = time / (2 * steps)

    def render(self, width, height, st, at):

        if renpy.game.less_updates:
            return null_render(self, width, height, st, at)

        if st >= self.time:
            self.events = True
            return render(self.new_widget, width, height, st, at)

        step = st // self.quantum + 1
        visible = self.old_widget

        if step > self.steps:
            step = (self.steps * 2) - step + 1
            visible = self.new_widget
            self.events = True


        rdr = render(visible, width, height, st, at)
        rv = renpy.display.render.Render(rdr.width, rdr.height)

        rv.blit(rdr, (0, 0))

        rv.operation = renpy.display.render.PIXELLATE
        rv.operation_parameter = 2 ** step

        renpy.display.render.redraw(self, 0)

        return rv


class Dissolve(Transition):
    """
    :doc: transition function
    :args: (time, alpha=False, time_warp=None)
    :name: Dissolve

    Returns a transition that dissolves from the old scene to the new scene.

    `time`
        The time the dissolve will take.

    `alpha`
        If true, the dissolve will alpha-composite the the result of the
        transition with the screen. If false, the result of the transition
        will replace the screen, which is more efficient.

    `time_warp`
        A function that adjusts the timeline. If not None, this should be a
        function that takes a fractional time between 0.0 and 1.0, and returns
        a number in the same range.
    """

    __version__ = 1

    def after_upgrade(self, version):
        if version < 1:
            self.alpha = False

    time_warp = None

    def __init__(self, time, old_widget=None, new_widget=None, alpha=False, time_warp=None, **properties):
        super(Dissolve, self).__init__(time, **properties)

        self.time = time
        self.old_widget = old_widget
        self.new_widget = new_widget
        self.events = False
        self.alpha = alpha
        self.time_warp = time_warp


    def render(self, width, height, st, at):

        if renpy.game.less_updates:
            return null_render(self, width, height, st, at)

        if st >= self.time:
            self.events = True
            return render(self.new_widget, width, height, st, at)

        complete = min(1.0, st / self.time)

        if self.time_warp is not None:
            complete = self.time_warp(complete)

        bottom = render(self.old_widget, width, height, st, at)
        top = render(self.new_widget, width, height, st, at)

        width = min(top.width, bottom.width)
        height = min(top.height, bottom.height)

        rv = renpy.display.render.Render(width, height, opaque=not self.alpha)

        rv.operation = renpy.display.render.DISSOLVE
        rv.operation_alpha = self.alpha
        rv.operation_complete = complete

        rv.blit(bottom, (0, 0), focus=False, main=False)
        rv.blit(top, (0, 0), focus=True, main=True)

        renpy.display.render.redraw(self, 0)

        return rv


class ImageDissolve(Transition):
    """
    :doc: transition function
    :args: (image, time, ramplen=8, reverse=False, alpha=True, time_warp=None)
    :name: ImageDissolve

    Returns a transition that dissolves the old scene into the new scene, using
    an image to control the dissolve process. This means that white pixels will
    dissolve in first, and black pixels will dissolve in last.

    `image`
        A control image to use. This must be either an image file or
        image manipulator. The control image should be the size of
        the scenes being dissolved.

    `time`
        The time the dissolve will take.

    `ramplen`
        The length of the ramp to use. This must be an integer power
        of 2. When this is the default value of 8, when a white pixel
        is fully dissolved, a pixel 8 shades of gray darker will have
        completed one step of dissolving in.

    `reverse`
        If true, black pixels will dissolve in before white pixels.

    `alpha`
        If true, the dissolve will alpha-composite the the result of the
        transition with the screen. If false, the result of the transition
        will replace the screen, which is more efficient.

    `time_warp`
        A function that adjusts the timeline. If not None, this should be a
        function that takes a fractional time between 0.0 and 1.0, and returns
        a number in the same range.

    ::

        define circirisout = ImageDissolve("circiris.png", 1.0)
        define circirisin = ImageDissolve("circiris.png", 1.0, reverse=True)
        define circiristbigramp = ImageDissolve("circiris.png", 1.0, ramplen=256)
    """

    __version__ = 1

    def after_upgrade(self, version):
        if version < 1:
            self.alpha = False

    time_warp = None

    def __init__(
        self,
        image,
        time,
        ramplen=8,
        ramptype='linear',
        ramp=None,
        reverse=False,
        alpha=False,
        old_widget=None,
        new_widget=None,
        time_warp=None,
        **properties):

        # ramptype and ramp are now unused, but are kept for compatbility with
        # older code.

        super(ImageDissolve, self).__init__(time, **properties)

        self.old_widget = old_widget
        self.new_widget = new_widget
        self.events = False
        self.alpha = alpha
        self.time_warp = time_warp

        if not reverse:

            # Copies red -> alpha
            matrix = renpy.display.im.matrix(
                0, 0, 0, 0, 1,
                0, 0, 0, 0, 1,
                0, 0, 0, 0, 1,
                1, 0, 0, 0, 0)

        else:

            # Copies 1-red -> alpha
            matrix = renpy.display.im.matrix(
                0, 0, 0, 0, 1,
                0, 0, 0, 0, 1,
                0, 0, 0, 0, 1,
                - 1, 0, 0, 0, 1)

        self.image = renpy.display.im.MatrixColor(image, matrix)

        if ramp is not None:
            ramplen = len(ramp)

        # The length of the ramp.
        self.ramplen = max(ramplen, 1)


    def visit(self):
        return super(ImageDissolve, self).visit() + [ self.image ]


    def render(self, width, height, st, at):

        if renpy.game.less_updates or renpy.display.less_imagedissolve:
            return null_render(self, width, height, st, at)

        if st >= self.delay:
            self.events = True
            return render(self.new_widget, width, height, st, at)

        image = render(self.image, width, height, st, at)
        bottom = render(self.old_widget, width, height, st, at)
        top = render(self.new_widget, width, height, st, at)

        width = min(bottom.width, top.width, image.width)
        height = min(bottom.height, top.height, image.height)

        rv = renpy.display.render.Render(width, height, opaque=not self.alpha)

        complete = st / self.delay

        if self.time_warp is not None:
            complete = self.time_warp(complete)

        rv.operation = renpy.display.render.IMAGEDISSOLVE
        rv.operation_alpha = self.alpha
        rv.operation_complete = complete
        rv.operation_parameter = self.ramplen

        rv.blit(image, (0, 0), focus=False, main=False)
        rv.blit(bottom, (0, 0), focus=False, main=False)
        rv.blit(top, (0, 0), focus=True, main=True)

        renpy.display.render.redraw(self, 0)

        return rv


class AlphaDissolve(Transition):
    """
    :doc: transition function
    :args: (control, delay=0.0, alpha=False, reverse=False)

    Returns a transition that uses a control displayable (almost always some
    sort of animated transform) to transition from one screen to another. The
    transform is evaluated. The new screen is used where the transform is
    opaque, and the old image is used when it is transparent.

    `control`
        The control transform.

    `delay`
        The time the transition takes, before ending.

    `alpha`
        If true, the image is composited with what's behind it. If false,
        the default, the image is opaque and overwrites what's behind it.

    `reverse`
        If true, the alpha channel is reversed. Opaque areas are taken
        from the old image, while transparent areas are taken from the
        new image.
     """

    def __init__(
        self,
        control,
        delay=0.0,
        old_widget=None,
        new_widget=None,
        alpha=False,
        reverse=False,
        **properties):

        super(AlphaDissolve, self).__init__(delay, **properties)

        self.control = renpy.display.layout.Fixed()
        self.control.add(control)

        self.old_widget = renpy.easy.displayable(old_widget)
        self.new_widget = renpy.easy.displayable(new_widget)
        self.events = False

        self.alpha = alpha
        self.reverse = reverse

    def visit(self):
        return super(AlphaDissolve, self).visit() + [ self.control ]

    def render(self, width, height, st, at):

        if renpy.game.less_updates or renpy.display.less_imagedissolve:
            return null_render(self, width, height, st, at)

        if st >= self.delay:
            self.events = True

        bottom = render(self.old_widget, width, height, st, at)
        top = render(self.new_widget, width, height, st, at)

        width = min(bottom.width, top.width)
        height = min(bottom.height, top.height)

        control = render(self.control, width, height, st, at)

        rv = renpy.display.render.Render(width, height, opaque=not self.alpha)

        rv.operation = renpy.display.render.IMAGEDISSOLVE
        rv.operation_alpha = self.alpha
        rv.operation_complete = 256.0 / (256.0 + 256.0)
        rv.operation_parameter = 256

        rv.blit(control, (0, 0), focus=False, main=False)

        if not self.reverse:
            rv.blit(bottom, (0, 0), focus=False, main=False)
            rv.blit(top, (0, 0), focus=True, main=True)
        else:
            rv.blit(top, (0, 0), focus=True, main=True)
            rv.blit(bottom, (0, 0), focus=False, main=False)

        return rv


class CropMove(Transition):
    """
    :doc: transition function
    :args: (time, mode="slideright", startcrop=(0.0, 0.0, 0.0, 1.0), startpos=(0.0, 0.0), endcrop=(0.0, 0.0, 1.0, 1.0), endpos=(0.0, 0.0), topnew=True)
    :name: CropMove

    Returns a transition that works by cropping a scene and positioning it on the
    screen. This can be used to implement a variety of effects, all of which
    involved changing rectangular slices of scenes.

    `time`
        The time the transition takes.

    `mode`
        The name of the mode of the transition. There are three groups
        of modes: wipes, slides, and other. This can also be "custom",
        to allow a custom mode to be defined.

        In a wipe, the image stays fixed, and more of it is revealed as
        the transition progresses. For example, in "wiperight", a wipe from left to right, first the left edge of the image is
        revealed at the left edge of the screen, then the center of the image,
        and finally the right side of the image at the right of the screen.
        Other supported wipes are "wipeleft", "wipedown", and "wipeup".

        In a slide, the image moves. So in a "slideright", the right edge of the
        image starts at the left edge of the screen, and moves to the right
        as the transition progresses. Other slides are "slideleft", "slidedown",
        and "slideup".

        There are also slideaways, in which the old image moves on top of
        the new image. Slideaways include "slideawayright", "slideawayleft",
        "slideawayup", and "slideawaydown".

        We also support a rectangular iris in with "irisin" and a
        rectangular iris out with "irisout".

    The following parameters are only respected if the mode is "custom". Positions
    are relative to the size of the screen, while the crops are relative to the
    size of the image. So a crop of (0.25, 0.0, 0.5, 1.0) takes the middle
    half of an image.

    `startcrop`
        The starting rectangle that is cropped out of the
        top image. A 4-element tuple containing x, y, width, and height.

    `startpos`
        The starting place that the top image is drawn
        to the screen at, a 2-element tuple containing x and y.

    `endcrop`
        The ending rectangle that is cropped out of the
        top image. A 4-element tuple containing x, y, width, and height.

    `endpos`
        The ending place that the top image is drawn
        to the screen at, a 2-element tuple containing x and y.

    `topnew`
        If true, the scene that is cropped and moved (and is on top of
        the other scene) is the new scene. If false, it is the old scene.

    ::

        define wiperight = CropMove(1.0, "wiperight")
        define wipeleft = CropMove(1.0, "wipeleft")
        define wipeup = CropMove(1.0, "wipeup")
        define wipedown = CropMove(1.0, "wipedown")

        define slideright = CropMove(1.0, "slideright")
        define slideleft = CropMove(1.0, "slideleft")
        define slideup = CropMove(1.0, "slideup")
        define slidedown = CropMove(1.0, "slidedown")

        define slideawayright = CropMove(1.0, "slideawayright")
        define slideawayleft = CropMove(1.0, "slideawayleft")
        define slideawayup = CropMove(1.0, "slideawayup")
        define slideawaydown = CropMove(1.0, "slideawaydown")

        define irisout = CropMove(1.0, "irisout")
        define irisin = CropMove(1.0, "irisin")
    """

    def __init__(self, time,
                 mode="slideright",
                 startcrop=(0.0, 0.0, 0.0, 1.0),
                 startpos=(0.0, 0.0),
                 endcrop=(0.0, 0.0, 1.0, 1.0),
                 endpos=(0.0, 0.0),
                 topnew=True,
                 old_widget=None,
                 new_widget=None,
                 **properties):

        super(CropMove, self).__init__(time, **properties)
        self.time = time

        if mode == "wiperight":
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 0.0, 1.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "wipeleft":
            startpos = (1.0, 0.0)
            startcrop = (1.0, 0.0, 0.0, 1.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "wipedown":
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 1.0, 0.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "wipeup":
            startpos = (0.0, 1.0)
            startcrop = (0.0, 1.0, 1.0, 0.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "slideright":
            startpos = (0.0, 0.0)
            startcrop = (1.0, 0.0, 0.0, 1.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "slideleft":
            startpos = (1.0, 0.0)
            startcrop = (0.0, 0.0, 0.0, 1.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "slideup":
            startpos = (0.0, 1.0)
            startcrop = (0.0, 0.0, 1.0, 0.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "slidedown":
            startpos = (0.0, 0.0)
            startcrop = (0.0, 1.0, 1.0, 0.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "slideawayleft":
            endpos = (0.0, 0.0)
            endcrop = (1.0, 0.0, 0.0, 1.0)
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = False

        elif mode == "slideawayright":
            endpos = (1.0, 0.0)
            endcrop = (0.0, 0.0, 0.0, 1.0)
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = False

        elif mode == "slideawaydown":
            endpos = (0.0, 1.0)
            endcrop = (0.0, 0.0, 1.0, 0.0)
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = False

        elif mode == "slideawayup":
            endpos = (0.0, 0.0)
            endcrop = (0.0, 1.0, 1.0, 0.0)
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = False

        elif mode == "irisout":
            startpos = (0.5, 0.5)
            startcrop = (0.5, 0.5, 0.0, 0.0)
            endpos = (0.0, 0.0)
            endcrop = (0.0, 0.0, 1.0, 1.0)
            topnew = True

        elif mode == "irisin":
            startpos = (0.0, 0.0)
            startcrop = (0.0, 0.0, 1.0, 1.0)
            endpos = (0.5, 0.5)
            endcrop = (0.5, 0.5, 0.0, 0.0)
            topnew = False


        elif mode == "custom":
            pass
        else:
            raise Exception("Invalid mode %s passed into CropMove." % mode)

        self.delay = time
        self.time = time

        self.startpos = startpos
        self.endpos = endpos

        self.startcrop = startcrop
        self.endcrop = endcrop

        self.topnew = topnew

        self.old_widget = old_widget
        self.new_widget = new_widget

        self.events = False

        if topnew:
            self.bottom = old_widget
            self.top = new_widget
        else:
            self.bottom = new_widget
            self.top = old_widget

    def render(self, width, height, st, at):

        if renpy.game.less_updates:
            return null_render(self, width, height, st, at)

        time = 1.0 * st / self.time

        # Done rendering.
        if time >= 1.0:
            self.events = True
            return render(self.new_widget, width, height, st, at)

        # How we scale each element of a tuple.
        scales = (width, height, width, height)

        def interpolate_tuple(t0, t1):
            return tuple([ int(s * (a * (1.0 - time) + b * time))
                           for a, b, s in zip(t0, t1, scales) ])

        crop = interpolate_tuple(self.startcrop, self.endcrop)
        pos = interpolate_tuple(self.startpos, self.endpos)


        top = render(self.top, width, height, st, at)
        bottom = render(self.bottom, width, height, st, at)

        width = min(bottom.width, width)
        height = min(bottom.height, height)
        rv = renpy.display.render.Render(width, height)

        rv.blit(bottom, (0, 0), focus=not self.topnew)

        ss = top.subsurface(crop, focus=self.topnew)
        rv.blit(ss, pos, focus=self.topnew)

        renpy.display.render.redraw(self, 0)
        return rv


def ComposeTransition(trans, before=None, after=None, new_widget=None, old_widget=None):
    """
    :doc: transition function
    :args: (trans, before, after)

    Returns a transition that composes up to three transitions. If not None,
    the `before` and `after` transitions are applied to the old and new
    scenes, respectively. These updated old and new scenes are then supplied
    to the `trans` transition.

    ::

        # Move the images in and out while dissolving. (This is a fairly expensive transition.)
        define moveinoutdissolve = ComposeTransition(dissolve, before=moveoutleft, after=moveinright)
    """

    if before is not None:
        old = before(new_widget=new_widget, old_widget=old_widget)
    else:
        old = old_widget

    if after is not None:
        new = after(new_widget=new_widget, old_widget=old_widget)
    else:
        new = new_widget

    return trans(new_widget=new, old_widget=old)


def SubTransition(rect, trans, old_widget=None, new_widget=None, **properties):
    """
    Applies a transition to a subset of the screen. Not documented.
    """

    x, y, _w, _h = rect

    old = renpy.display.layout.LiveCrop(rect, old_widget)
    new = renpy.display.layout.LiveCrop(rect, new_widget)

    inner = trans(old_widget=old, new_widget=new)
    delay = inner.delay
    inner = renpy.display.layout.Position(inner, xpos=x, ypos=y, xanchor=0, yanchor=0)

    f = renpy.display.layout.MultiBox(layout='fixed')
    f.add(new_widget)
    f.add(inner)

    return NoTransition(delay, old_widget=f, new_widget=f)


########NEW FILE########
__FILENAME__ = video
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import renpy.audio

# The movie displayable that's currently being shown on the screen.
current_movie = None

# True if the movie that is currently displaying is in fullscreen mode,
# False if it's a smaller size.
fullscreen = False

# The size of a Movie object that hasn't had an explicit size set.
default_size = (400, 300)

# The file we allocated the surface for.
surface_file = None

# The surface to display the movie on, if not fullscreen.
surface = None

def movie_stop(clear=True, only_fullscreen=False):
    """
    Stops the currently playing movie.
    """

    if (not fullscreen) and only_fullscreen:
        return

    renpy.audio.music.stop(channel='movie')


def movie_start(filename, size=None, loops=0):
    """
    This starts a movie playing.
    """

    if renpy.game.less_updates:
        return

    global default_size

    if size is not None:
        default_size = size

    filename = [ filename ]

    if loops == -1:
        loop = True
    else:
        loop = False
        filename = filename * (loops + 1)

    renpy.audio.music.play(filename, channel='movie', loop=loop)

movie_start_fullscreen = movie_start
movie_start_displayable = movie_start

def early_interact():
    """
    Called early in the interact process, to clear out the fullscreen
    flag.
    """

    global fullscreen
    global current_movie

    fullscreen = True
    current_movie = None


def interact():
    """
    This is called each time the screen is redrawn. It helps us decide if
    the movie should be displayed fullscreen or not.
    """

    global surface
    global surface_file

    if not renpy.audio.music.get_playing("movie"):
        surface = None
        surface_file = None
        return False

    if fullscreen:
        return True
    else:
        return False

def get_movie_texture():
    """
    Gets a movie texture we can draw to the screen.
    """

    global surface
    global surface_file

    playing = renpy.audio.music.get_playing("movie")

    pss = renpy.audio.audio.pss

    if pss:
        size = pss.movie_size()
    else:
        size = (64, 64)

    if (surface is None) or (surface.get_size() != size) or (surface_file != playing):
        surface = renpy.display.pgrender.surface(size, False)
        surface_file = playing
        surface.fill((0, 0, 0, 255))

    tex = None

    if playing is not None:
        renpy.display.render.mutated_surface(surface)
        tex = renpy.display.draw.load_texture(surface, True)

    return tex


def render_movie(width, height):
    tex = get_movie_texture()

    if tex is None:
        return None

    sw, sh = tex.get_size()

    scale = min(1.0 * width / sw, 1.0 * height / sh)

    dw = scale * sw
    dh = scale * sh

    rv = renpy.display.render.Render(width, height, opaque=True)
    rv.forward = renpy.display.render.Matrix2D(1.0 / scale, 0.0, 0.0, 1.0 / scale)
    rv.reverse = renpy.display.render.Matrix2D(scale, 0.0, 0.0, scale)
    rv.blit(tex, (int((width - dw) / 2), int((height - dh) / 2)))

    return rv

class Movie(renpy.display.core.Displayable):
    """
    :doc: movie

    This is a displayable that shows the current movie.

    `fps`
        The framerate that the movie should be shown at. (This is currently
        ignored, but the parameter is kept for backwards compatibility.
        The framerate is auto-detected.)

    `size`
        This should always be specified. A tuple giving the width and height
        of the movie.

    The contents of this displayable when a movie is not playing are undefined.
    (And may change when a rollback occurs.) 
    """

    fullscreen = False

    def __init__(self, fps=24, size=None, **properties):
        super(Movie, self).__init__(**properties)
        self.size = size

    def render(self, width, height, st, at):

        size = self.size

        if size is None:
            size = default_size

        width, height = size

        rv = render_movie(width, height)

        if rv is None:
            rv = renpy.display.render.Render(0, 0)

        # Usually we get redrawn when the frame is ready - but we want
        # the movie to disappear if it's ended, or if it hasn't started
        # yet.
        renpy.display.render.redraw(self, 0.1)

        return rv


    def per_interact(self):
        global fullscreen
        fullscreen = False

        global current_movie
        current_movie = self


def playing():
    return renpy.audio.music.get_playing("movie")

def frequent():
    """
    Called to update the video playback. Returns true if a video refresh is
    needed, false otherwise.
    """

    if not playing():
        return 0

    pss = renpy.audio.audio.pss

    if pss.needs_alloc():

        if renpy.display.video.fullscreen and renpy.display.draw.fullscreen_surface:
            surf = renpy.display.draw.fullscreen_surface
        else:
            get_movie_texture()
            surf = renpy.display.scale.real(surface)

        pss.alloc_event(surf)

    rv = pss.refresh_event()

    if rv and current_movie is not None:
        renpy.display.render.redraw(current_movie, 0)

    return rv

########NEW FILE########
__FILENAME__ = dump
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code to write the reflect.json file. This file contains
# information about the game that's used to reflect on the contents,
# including how to navigate around the game.

import inspect
import json
import sys
import os

import renpy


# A list of (name, filename, linenumber) tuples, for various types of
# name. These are added to as the definitions occur.
definitions = [ ]
transforms = [ ]
screens = [ ]


# Does a file exist? We cache the result here.
file_exists_cache = { }

def file_exists(fn):
    rv = file_exists_cache.get(fn, None)

    if rv is None:
        fullfn = renpy.parser.unelide_filename(fn)

        rv = os.path.exists(fullfn)
        file_exists_cache[fn] = rv

    return rv


# Did we do a dump?
completed_dump = False

def dump(error):
    """
    Causes a JSON dump file to be written, if the user has requested it.

    `error`
        An error flag that is added to the written file.
    """


    global completed_dump

    args = renpy.game.args

    if completed_dump:
        return

    completed_dump = True

    if not args.json_dump:
        return

    def filter(name, filename): #@ReservedAssignment
        """
        Returns true if the name is included by the filter, or false if it is excluded.
        """

        filename = filename.replace("\\", "/")

        if name.startswith("_") and not args.json_dump_private:
            if name.startswith("__") and name.endswith("__"):
                pass
            else:
                return False

        if not file_exists(filename):
            return False

        if filename.startswith("common/") or filename.startswith("renpy/common/"):
            return args.json_dump_common

        if not filename.startswith("game/"):
            return False

        return True

    result = { }

    # Error flag.
    result["error"] = error

    # The JSON object we return.
    location = { }
    result["location"] = location

    # Labels.
    label = location["label"] = { }

    for name, n in renpy.game.script.namemap.iteritems():
        filename = n.filename
        line = n.linenumber

        if not isinstance(name, basestring):
            continue

        if not filter(name, filename):
            continue

        label[name] = [ filename, line ]


    # Definitions.
    define = location["define"] = { }

    for name, filename, line in definitions:
        if not filter(name, filename):
            continue

        define[name] = [ filename, line ]

    # Screens.
    screen = location["screen"] = { }

    for name, filename, line in screens:
        if not filter(name, filename):
            continue

        screen[name] = [ filename, line ]

    # Transforms.
    transform = location["transform"] = { }

    for name, filename, line in transforms:
        if not filter(name, filename):
            continue

        transform[name] = [ filename, line ]


    # Code.

    def get_line(o):
        """
        Returns the filename and the first line number of the class or function o. Returns
        None, None if unknown.

        For a class, this doesn't return the first line number of the class, but rather
        the line number of the first method in the class - hopefully.
        """

        if inspect.isfunction(o):
            return inspect.getfile(o), o.func_code.co_firstlineno

        if inspect.ismethod(o):
            return get_line(o.im_func)

        return None, None

    code = location["callable"] = { }

    for modname, mod in sys.modules.items():

        if mod is None:
            continue

        if modname == "store":
            prefix = ""
        elif modname.startswith("store."):
            prefix = modname[6:] + "."
        else:
            continue

        for name, o in mod.__dict__.items():

            if inspect.isfunction(o):
                try:
                    if inspect.getmodule(o) != mod:
                        continue

                    filename, line = get_line(o)

                    if filename is None:
                        continue

                    if not filter(name, filename):
                        continue

                    code[prefix + name] = [ filename, line ]
                except:
                    continue

            if inspect.isclass(o):

                for methname, method in o.__dict__.iteritems():

                    try:
                        if inspect.getmodule(method) != mod:
                            continue

                        filename, line = get_line(method)

                        if filename is None:
                            continue

                        if not filter(name, filename):
                            continue

                        if not filter(methname, filename):
                            continue

                        code[prefix + name + "." + methname] = [ filename, line ]
                    except:
                        continue

    # Add the build info from 00build.rpy, if it's available.
    try:
        result["build"] = renpy.store.build.dump() #@UndefinedVariable
    except:
        pass

    if args.json_dump != "-":
        with file(args.json_dump, "w") as f:
            json.dump(result, f)
    else:
        json.dump(result, sys.stdout, indent=2)

########NEW FILE########
__FILENAME__ = easy
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Functions that make the user's life easier.

import renpy.display
import contextlib
import time

def color(c):
    """
    This function returns a color tuple, from a hexcode string or a
    color tuple.
    """

    if isinstance(c, tuple) and len(c) == 4:
        return c

    if c is None:
        return c

    if isinstance(c, basestring):
        if c[0] == '#':
            c = c[1:]

        if len(c) == 6:
            r = int(c[0]+c[1], 16)
            g = int(c[2]+c[3], 16)
            b = int(c[4]+c[5], 16)
            a = 255
        elif len(c) == 8:
            r = int(c[0]+c[1], 16)
            g = int(c[2]+c[3], 16)
            b = int(c[4]+c[5], 16)
            a = int(c[6]+c[7], 16)
        elif len(c) == 3:
            r = int(c[0], 16) * 0x11
            g = int(c[1], 16) * 0x11
            b = int(c[2], 16) * 0x11
            a = 255
        elif len(c) == 4:
            r = int(c[0], 16) * 0x11
            g = int(c[1], 16) * 0x11
            b = int(c[2], 16) * 0x11
            a = int(c[3], 16) * 0x11
        else:
            raise Exception("Color string must be 3, 4, 6, or 8 hex digits long.")

        return (r, g, b, a)

    raise Exception("Not a color: %r" % (c,))

def displayable_or_none(d):

    if isinstance(d, renpy.display.core.Displayable):
        return d

    if d is None:
        return d

    if isinstance(d, basestring):
        if d[0] == '#':
            return renpy.store.Solid(d)
        elif "." in d:
            return renpy.store.Image(d)
        elif not d:
            raise Exception("Displayable cannot be an empty string.")
        else:
            return renpy.store.ImageReference(tuple(d.split()))

    # We assume the user knows what he's doing in this case.
    if hasattr(d, 'parameterize'):
        return d

    if d is True or d is False:
        return d

    raise Exception("Not a displayable: %r" % (d,))

def displayable(d):
    """
    :doc: udd_utility
    :name: renpy.displayable

    This takes `d`, which may be a displayable object or a string. If it's
    a string, it converts that string into a displayable using the usual
    rules.
    """


    if isinstance(d, renpy.display.core.Displayable):
        return d

    if isinstance(d, basestring):
        if not d:
            raise Exception("An empty string cannot be used as a displayable.")
        elif d[0] == '#':
            return renpy.store.Solid(d)
        elif "." in d:
            return renpy.store.Image(d)
        else:
            return renpy.store.ImageReference(tuple(d.split()))

    # We assume the user knows what he's doing in this case.
    if hasattr(d, 'parameterize'):
        return d

    if d is True or d is False:
        return d

    raise Exception("Not a displayable: %r" % (d,))

def predict(d):
    d = renpy.easy.displayable_or_none(d)

    if d is not None:
        renpy.display.predict.displayable(d)

@contextlib.contextmanager
def timed(name):
    start = time.time()
    yield
    print "{0}: {1:.2f} ms".format(name, (time.time() - start) * 1000.0)


########NEW FILE########
__FILENAME__ = editor
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os
import renpy
import traceback
import subprocess

class Editor(object):
    """
    This class is intended to be subclassed by editor subclasses. It provides a
    number of editor related operations, which are called by Ren'Py (including
    the Ren'Py Launcher).

    Editor operations are grouped into transactions. An editor transaction
    starts with a call to the begin() method. Ren'Py will then call some number
    of command methods, each causing an operation to occur in the editor. Ren'Py
    will call end() at the end of the transaction.

    Although not required, it's reasonable than an implementation of this class
    will batch the files together and send them to the editor at once. It's also
    reasonable that an implementation will send the operations one at a time (and
    do little-to-nothing in begin() and end().

    Each operation takes a path to operate on. If the editor has a buffer
    corresponding to that path, that buffer is used. Otherwise, the editor
    is implicitly opened.

    We reserve the right to add new keyword arguments to methods of this class,
    so please ensure that subclasses accept and ignore unknown keyword
    arguments.
    """

    def begin(self, new_window=False, **kwargs):
        """
        Begins an editor transaction.

        `new_window`
            If True, a new editor window will be created and presented to the
            user. Otherwise, and existing editor window will be used.
        """

    def end(self, **kwargs):
        """
        Ends an editor transaction.
        """

    def open(self, filename, line=None, **kwargs): #@ReservedAssignment
        """
        Ensures `path` is open in the editor. This may be called multiple
        times per transaction.

        `line`
            If not None, this should be a line number to open in the
            editor.

        The first open call in a transaction is somewhat special - that file
        should be given focus in a tabbed editor environment.
        """


class SystemEditor(Editor):

    def open(self, filename, line=None, **kwargs): #@ReservedAssignment

        filename = renpy.exports.fsencode(filename)

        try:
            if renpy.windows:
                os.startfile(filename) #@UndefinedVariable
            elif renpy.macintosh:
                subprocess.call([ "open", filename ]) #@UndefinedVariable
            elif renpy.linux:
                subprocess.call([ "xdg-open", filename ]) #@UndefinedVariable
        except:
            traceback.print_exc()



# The editor that Ren'Py is using. It should be a subclass of the Editor
# class.
editor = None

def init():
    """
    Creates the editor object, based on the contents of the RENPY_EDIT_PY
    file.
    """

    global editor
    editor = SystemEditor()

    path = os.environ.get("RENPY_EDIT_PY", None)

    if path is None:
        return

    scope = { "__file__" : path }
    execfile(path, scope, scope)

    if "Editor" in scope:
        editor = scope["Editor"]()
        return

    raise Exception("{0} did not define an Editor class.".format(path))

def launch_editor(filenames, line=1, transient=False):
    """
    Causes the editor to be launched.
    """

    # On android, we will never be able to launch the editor.
    if renpy.android:
        return True

    if editor is None:
        init()

    if editor is None:
        return False

    filenames = [ renpy.parser.unelide_filename(i) for i in filenames ]

    try:
        editor.begin(new_window=transient)

        for i in filenames:
            editor.open(i, line)
            line = None # The line number only applies to the first filename.

        editor.end()

        return True

    except:
        traceback.print_exc()
        return False

########NEW FILE########
__FILENAME__ = error
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code for formatting tracebacks.

import traceback
import sys
import cStringIO
import platform
import linecache

import renpy
import os

FSENCODING = sys.getfilesystemencoding() or "utf-8"


def write_utf8_traceback_list(out, l):
    """
    Given the traceback list l, writes it to out as utf-8.
    """

    ul = [ ]

    for filename, line, what, text in l:

        # Filename is either unicode or an fsecoded string.
        if not isinstance(filename, unicode):
            filename = unicode(filename, FSENCODING, "replace")

        # Line is a number.

        # Assume what is in a unicode encoding, since it is either python,
        # or comes from inside Ren'Py.

        if isinstance(text, str):
            text = text.decode("utf-8", "replace")

        ul.append((filename, line, what, text))

    for t in traceback.format_list(ul):
        out.write(t.encode("utf-8", "replace"))


def traceback_list(tb):
    """
    Given `tb`, returns a list of (filename, line_number, function, line_text)
    tuples.
    """

    l = [ ]

    while tb:
        frame = tb.tb_frame
        line_number = tb.tb_lineno
        code = frame.f_code
        filename = code.co_filename
        name = code.co_name

        tb = tb.tb_next

        if (tb is not None) and ('self' in frame.f_locals) and (not renpy.config.raw_tracebacks):
            obj = frame.f_locals['self']

            try:
                l.extend(obj.report_traceback(name))
                continue
            except:
                pass

        l.append((filename, line_number, name, None))

    rv = [ ]

    for filename, line_number, name, line in l:
        if line is None:
            line = linecache.getline(filename, line_number)

        rv.append((filename, line_number, name, line))

    return rv

def filter_traceback_list(tl):
    """
    Returns the subset of `tl` that originates in creator-written files, as
    opposed to those portions that come from Ren'Py itself.
    """

    rv = [ ]

    for t in tl:
        filename = t[0]
        if filename.endswith(".rpy") and not filename.replace("\\", "/").startswith("common/"):
            rv.append(t)

    return rv


def open_error_file(fn, mode):
    """
    Opens an error/log/file. Returns the open file, and the filename that
    was opened.
    """

    try:
        f = file(os.path.join(renpy.config.logdir, fn), mode)
        return f, fn
    except:
        pass

    try:
        f = file(fn, mode)
        return f, fn
    except:
        pass

    import tempfile

    fn = os.path.join(tempfile.gettempdir(), "renpy-" + fn)
    return file(fn, mode), fn

def report_exception(e, editor=True):
    """
    Reports an exception by writing it to standard error and
    traceback.txt. If `editor` is True, opens the traceback
    up in a text editor.

    Returns a two-unicode tuple, with the first item being
    a simple message, and the second being a full traceback.
    """

    import codecs

    type, _value, tb = sys.exc_info() #@ReservedAssignment

    def safe_utf8(e):
        try:
            m = unicode(e)
        except:
            m = str(e)

        if isinstance(m, unicode):
            return m.encode("utf-8", "replace")
        else:
            return m

    # Return values - which can be displayed to the user.
    simple = cStringIO.StringIO()
    full = cStringIO.StringIO()

    full_tl = traceback_list(tb)
    simple_tl = filter_traceback_list(full_tl)

    print >>simple, renpy.game.exception_info
    write_utf8_traceback_list(simple, simple_tl)
    print >>simple, type.__name__ + ":",
    print >>simple, safe_utf8(e)

    print >>full, "Full traceback:"
    write_utf8_traceback_list(full, full_tl)
    print >>full, type.__name__ + ":",
    print >>full, safe_utf8(e)

    # Write to stdout/stderr.
    sys.stdout.write("\n")
    sys.stdout.write(full.getvalue())
    sys.stdout.write("\n")
    sys.stdout.write(simple.getvalue())

    print >>full
    try:
        print >>full, platform.platform()
        print >>full, renpy.version
        print >>full, renpy.config.name + " " + renpy.config.version
    except:
        pass


    simple = simple.getvalue()
    full = full.getvalue()

    # Inside of the file, which may not be openable.
    try:

        f, traceback_fn = open_error_file("traceback.txt", "w")

        f.write(codecs.BOM_UTF8)

        print >>f, "I'm sorry, but an uncaught exception occurred."
        print >>f

        f.write(simple)

        print >>f
        print >>f, "-- Full Traceback ------------------------------------------------------------"
        print >>f

        f.write(full)
        f.close()

        try:
            if editor and renpy.game.args.command == "run": #@UndefinedVariable
                renpy.exports.launch_editor([ traceback_fn ], 1, transient=1)
        except:
            pass

    except:
        pass

    try:
        renpy.display.log.exception() #@UndefinedVariable
    except:
        pass

    return simple.decode("utf-8", "replace"), full.decode("utf-8", "replace"), traceback_fn



########NEW FILE########
__FILENAME__ = execution
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code responsible for managing the execution of a
# renpy object, as well as the context object.

import sys
import renpy.display

class Delete(object):
    pass

class PredictInfo(renpy.object.Object):
    """
    Not used anymore, but needed for backwards compatibility.
    """

class Context(renpy.object.Object):
    """
    This is the context object which stores the current context
    of the game interpreter.

    @ivar current: The name of the node that is currently being
    executed.

    @ivar return_stack: A list of names of nodes that should be
    returned to when the return statement executes. (When a return
    occurs, the name is looked up, and name.text is then executed.)

    @ivar scene_lists: The scene lists associated with the current
    context.

    @ivar rollback: True if this context participates in rollbacks.

    @ivar runtime: The time spent in this context, in milliseconds.

    @ivar info: An object that is made available to user code. This object
    does participates in rollback.
    """

    __version__ = 11

    def after_upgrade(self, version):
        if version < 1:
            self.scene_lists.image_predict_info = self.predict_info.images

        if version < 2:
            self.abnormal = False
            self.last_abnormal = False

        if version < 3:
            self.music = { }

        if version < 4:
            self.interacting = False

        if version < 5:
            self.modes = renpy.python.RevertableList([ "start" ])
            self.use_modes = True

        if version < 6:
            self.images = self.predict_info.images

        if version < 7:
            self.init_phase = False
            self.next_node = None

        if version < 8:
            self.defer_rollback = None

        if version < 9:
            self.translate_language = None
            self.translate_identifier = None

        if version < 10:
            self.exception_handler = None

        if version < 11:
            self.say_attributes = None

    def __init__(self, rollback, context=None, clear=False):
        """
        `clear`
            True if we should clear out the context_clear_layers.
        """

        super(Context, self).__init__()

        self.current = None
        self.call_location_stack = [ ]
        self.return_stack = [ ]

        # Two deeper then the return stack and call location stack.
        # 1 deeper is for the context top-level, 2 deeper is for
        # _args, _kwargs, and _return.
        self.dynamic_stack = [ { } ]

        self.rollback = rollback
        self.runtime = 0
        self.info = renpy.python.RevertableObject()
        self.seen = False

        # True if there has just been an abnormal transfer of control,
        # like the start of a context, a jump, or a call. (Returns are
        # considered to be normal.)
        #
        # Set directly by ast.Call and ast.Jump.
        self.abnormal = True

        # True if the last statement caused an abnormal transfer of
        # control.
        self.last_abnormal = False

        # A map from the name of a music channel to the MusicContext
        # object corresponding to that channel.
        self.music = renpy.python.RevertableDict()

        # True if we're in the middle of a call to ui.interact. This
        # will cause Ren'Py to generate an error if we call ui.interact
        # again.
        self.interacting = False

        # True if we're in the init phase. (Isn't inherited.)
        self.init_phase = False

        # When deferring a rollback, the arguments to pass to renpy.exports.rollback.
        self.defer_rollback = None

        # The exception handler that is called when an exception occurs while executing
        # code. If None, a default handler is used. This is reset when run is called.
        self.exception_handler = None

        # The attributes that are used by the current say statement.
        self.say_attributes = None

        if context:
            oldsl = context.scene_lists
            self.runtime = context.runtime

            vars(self.info).update(vars(context.info))

            for k, v in context.music.iteritems():
                self.music[k] = v.copy()

            self.images = renpy.display.image.ShownImageInfo(context.images)

        else:
            oldsl = None
            self.images = renpy.display.image.ShownImageInfo(None)

        self.scene_lists = renpy.display.core.SceneLists(oldsl, self.images)

        self.make_dynamic([ "_return", "_args", "_kwargs", "mouse_visible", "suppress_overlay", "_side_image_attributes" ])
        self.dynamic_stack.append({ })

        if clear:
            for i in renpy.config.context_clear_layers:
                self.scene_lists.clear(layer=i)

        # A list of modes that the context has been in.
        self.modes = renpy.python.RevertableList([ "start" ])
        self.use_modes = True

        self.translate_language = None
        self.translate_identifier = None


    def make_dynamic(self, names, context=False):
        """
        Makes the variable names listed in names dynamic, by backing up
        their current value (if not already dynamic in the current call).
        """

        store = renpy.store.__dict__

        if context:
            index = 0
        else:
            index = -1

        for i in names:

            if i in self.dynamic_stack[index]:
                continue

            if i in store:
                self.dynamic_stack[index][i] = store[i]
            else:
                self.dynamic_stack[index][i] = Delete()


    def pop_dynamic(self):
        """
        Pops one level of the dynamic stack. Called when the return
        statement is run.
        """

        store = renpy.store.__dict__

        dynamic = self.dynamic_stack.pop()

        for k, v in dynamic.iteritems():
            if isinstance(v, Delete):
                del store[k]
            else:
                store[k] = v

    def pop_all_dynamic(self):
        """
        Pops all levels of the dynamic stack. Called when we jump
        out of a context.
        """

        while self.dynamic_stack:
            self.pop_dynamic()


    def goto_label(self, node_name):
        """
        Sets the name of the node that will be run when this context
        next executes.
        """

        self.current = node_name

    def report_traceback(self, name):

        rv = [ ]

        for i in self.call_location_stack:
            try:
                node = renpy.game.script.lookup(i)
                if not node.filename.replace("\\", "/").startswith("common/"):
                    rv.append((node.filename, node.linenumber, "script call", None))
            except:
                pass

        try:
            node = renpy.game.script.lookup(self.current)
            if not node.filename.replace("\\", "/").startswith("common/"):
                rv.append((node.filename, node.linenumber, "script", None))
        except:
            pass

        return rv

    def run(self, node=None):
        """
        Executes as many nodes as possible in the current context. If the
        node argument is given, starts executing from that node. Otherwise,
        looks up the node given in self.current, and executes from there.
        """

        self.exception_handler = None

        self.abnormal = True

        if node is None:
            node = renpy.game.script.lookup(self.current)

        while node:

            self.current = node.name
            self.last_abnormal = self.abnormal
            self.abnormal = False
            self.defer_rollback = None

            if self.rollback and renpy.game.log:
                renpy.game.log.begin()

            self.seen = False

            try:
                try:
                    self.next_node = None
                    node.execute()

                except renpy.game.CONTROL_EXCEPTIONS, e:

                    # An exception ends the current translation.
                    self.translate_interaction = None

                    raise

                except Exception, e:
                    self.translate_interaction = None

                    exc_info = sys.exc_info()
                    short, full, traceback_fn = renpy.error.report_exception(e, editor=False)

                    try:
                        if self.exception_handler is not None:
                            self.exception_handler(short, full, traceback_fn)
                        elif renpy.display.error.report_exception(short, full, traceback_fn):
                            raise
                    except renpy.game.CONTROL_EXCEPTIONS, ce:
                        raise ce
                    except Exception, ce:
                        raise exc_info[0], exc_info[1], exc_info[2]

                node = self.next_node

            except renpy.game.JumpException, e:
                node = renpy.game.script.lookup(e.args[0])
                self.abnormal = True

            except renpy.game.CallException, e:

                if self.next_node is None:
                    raise Exception("renpy.call can't be used when the next node is undefined.")

                node = self.call(e.label, return_site=self.next_node.name)
                self.abnormal = True
                renpy.store._args = e.args
                renpy.store._kwargs = e.kwargs

            if self.seen:
                renpy.game.persistent._seen_ever[self.current] = True  # @UndefinedVariable
                renpy.game.seen_session[self.current] = True

            if self.rollback and renpy.game.log:
                renpy.game.log.complete()


    def mark_seen(self):
        """
        Marks the current statement as one that has been seen by the user.
        """

        self.seen = True

    def call(self, label, return_site=None):
        """
        Calls the named label.
        """

        if not self.current:
            raise Exception("Context not capable of executing Ren'Py code.")

        if return_site is None:
            return_site = self.current

        self.call_location_stack.append(self.current)

        self.return_stack.append(return_site)
        self.dynamic_stack.append({ })
        self.current = label

        self.make_dynamic([ "_args", "_kwargs" ])
        renpy.store._args = None
        renpy.store._kwargs = None

        return renpy.game.script.lookup(label)

    def lookup_return(self, pop=True):
        """
        Returns the node to return to, or None if there is no
        such node.
        """

        if len(self.return_stack) == 0:
            return None

        if pop:
            label = self.return_stack.pop()
            self.call_location_stack.pop()
        else:
            label = self.return_stack[-1]

        return renpy.game.script.lookup(label)

    def rollback_copy(self):
        """
        Makes a copy of this object, suitable for rolling back to.
        """

        rv = Context(self.rollback, self)
        rv.call_location_stack = self.call_location_stack[:]
        rv.return_stack = self.return_stack[:]
        rv.dynamic_stack = [ i.copy() for i in self.dynamic_stack ]
        rv.current = self.current

        rv.runtime = self.runtime
        rv.info = self.info

        rv.translate_language = self.translate_language
        rv.translate_identifier = self.translate_identifier

        return rv

    def predict(self):
        """
        Performs image prediction, calling the given callback with each
        images that we predict to be loaded, in the rough order that
        they will be potentially loaded.
        """

        if not self.current:
            return

        old_images = self.images

        nodes = [ (renpy.game.script.lookup(self.current), self.images) ]
        node_set = set()

        for i in range(0, renpy.config.predict_statements):

            if i >= len(nodes):
                break

            node, images = nodes[i]

            self.images = renpy.display.image.ShownImageInfo(images)

            # Ignore exceptions in prediction, so long as
            # prediction is not needed.

            try:
                for n in node.predict():
                    if n is None:
                        continue

                    if n not in node_set:
                        nodes.append((n, self.images))
                        node_set.add(n)
            except:

                if renpy.config.debug_image_cache:
                    import traceback

                    print
                    traceback.print_exc()
                    print "While predicting images."

                # We accept that sometimes prediction won't work.

            self.images = old_images

            yield True

        yield False


    def seen_current(self, ever):
        """
        Returns a true value if we have finshed the current statement
        at least once before.

        @param ever: If True, we're checking to see if we've ever
        finished this statement. If False, we're checking to see if
        we've finished this statement in the current session.
        """

        if not self.current:
            return False

        if ever:
            seen = renpy.game.persistent._seen_ever  # @UndefinedVariable
        else:
            seen = renpy.game.seen_session

        return self.current in seen

    def do_deferred_rollback(self):
        """
        Called to cause deferred rollback to occur.
        """

        if not self.defer_rollback:
            return

        force, checkpoints = self.defer_rollback

        self.defer_rollback = None

        renpy.exports.rollback(force, checkpoints)


def run_context(top):
    """
    Runs the current context until it can't be run anymore, while handling
    the RestartContext and RestartTopContext exceptions.
    """

    label = None

    while True:

        try:

            context = renpy.game.context()

            if label and renpy.game.script.has_label(label):
                context.call(label)
            label = None

            context.run()

            rv = renpy.store._return

            context.pop_all_dynamic()

            return rv

        except renpy.game.RestartContext as e:

            if e.label:
                label = e.label

            continue

        except renpy.game.RestartTopContext as e:
            if top:

                if e.label:
                    label = e.label

                continue

            else:
                raise

        except:
            context.pop_all_dynamic()
            raise

########NEW FILE########
__FILENAME__ = exports
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains functions that are exported to the script namespace.
# Functions defined in this file can be updated by the user to change
# their behavior, while functions imported in are probably best left
# alone as part of the api.

# Remember the real file.
_file = file

import renpy.display
import renpy.audio

from renpy.text.extras import ParameterizedText
from renpy.text.font import register_sfont, register_mudgefont, register_bmfont
from renpy.text.text import language_tailor
from renpy.display.behavior import Keymap
from renpy.display.behavior import run as run_action, run_unhovered, run_periodic
from renpy.display.behavior import map_event, queue_event, clear_keymap_cache

from renpy.display.minigame import Minigame
from renpy.display.screen import define_screen, show_screen, hide_screen, use_screen, current_screen, has_screen, get_screen, get_widget
from renpy.display.focus import focus_coordinates
from renpy.display.predict import screen as predict_screen
from renpy.display.image import image_exists

from renpy.curry import curry, partial
from renpy.audio.sound import play
from renpy.display.video import movie_start_fullscreen, movie_start_displayable, movie_stop

from renpy.loadsave import load, save, list_saved_games, can_load, rename_save, unlink_save, scan_saved_game
from renpy.loadsave import list_slots, newest_slot, slot_mtime, slot_json, slot_screenshot

from renpy.python import py_eval as eval
from renpy.python import rng as random
from renpy.atl import atl_warper
from renpy.easy import predict, displayable
from renpy.parser import unelide_filename, get_parse_errors
from renpy.translation import change_language, known_languages

from renpy.persistent import register_persistent

from renpy.character import show_display_say, predict_show_display_say, display_say

import renpy.audio.sound as sound
import renpy.audio.music as music

from renpy.statements import register as register_statement
from renpy.text.extras import check_text_tags

from renpy.sl2.pyutil import const, pure

import time
import sys

def public_api():
    """
    :undocumented:

    This does nothing, except to make the pyflakes warnings about
    unused imports go away.
    """
    ParameterizedText
    register_sfont, register_mudgefont, register_bmfont
    Keymap
    run_action, run_unhovered, run_periodic, map_event
    Minigame
    curry, partial
    play
    movie_start_fullscreen, movie_start_displayable, movie_stop
    load, save, list_saved_games, can_load, rename_save, unlink_save, scan_saved_game
    list_slots, newest_slot, slot_mtime, slot_json, slot_screenshot
    eval
    random
    atl_warper
    show_display_say, predict_show_display_say, display_say
    sound
    music
    time
    define_screen, show_screen, hide_screen, use_screen, has_screen
    current_screen, get_screen, get_widget
    focus_coordinates
    predict, predict_screen
    displayable
    unelide_filename, get_parse_errors
    change_language, known_languages
    language_tailor
    register_persistent
    register_statement
    check_text_tags
    map_event, queue_event, clear_keymap_cache
    const, pure
    image_exists

del public_api

def roll_forward_info():
    """
    :doc: rollback

    When in rollback, returns the data that was supplied to :func:`renpy.checkpoint`
    the last time this statement executed. Outside of rollback, returns None.
    """

    if not renpy.game.context().rollback:
        return None

    return renpy.game.log.forward_info()

def in_rollback():
    """
    :doc: rollback

    Returns true if the game has been rolled back.
    """

    return renpy.game.log.in_rollback()

def can_rollback():
    """
    :doc: rollback

    Returns true if we can rollback.
    """

    return renpy.game.log.can_rollback()

def in_fixed_rollback():
    """
    :doc: blockrollback

    Returns true if rollback is currently occurring and the current
    context is before an executed renpy.fix_rollback() statement.
    """

    return renpy.game.log.in_fixed_rollback()

def checkpoint(data=None, keep_rollback=None):
    """
    :doc: rollback
    :args: (data=None)

    Makes the current statement a checkpoint that the user can rollback to. Once
    this function has been called, there should be no more interaction with the
    user in the current statement.

    `data`
        This data is returned by :func:`renpy.roll_forward_info` when the
        game is being rolled back.
    """

    if renpy.store._rollback:
        if keep_rollback is None:
            keep_rollback = renpy.config.keep_rollback_data

        renpy.game.log.checkpoint(data, keep_rollback=keep_rollback)

def block_rollback():
    """
    :doc: blockrollback

    Prevents the game from rolling back to before the current
    statement.
    """

    renpy.game.log.block()

def fix_rollback():
    """
    :doc: blockrollback

    Prevents the user from changing decisions made before the current
    statement.
    """
    renpy.game.log.fix_rollback()

def retain_after_load():
    """
    :doc: retain_after_load

    Causes data modified between the current statement and the statement
    containing the next checkpoint to be retained when a load occurs.
    """

    renpy.game.log.retain_after_load()


scene_lists = renpy.display.core.scene_lists

def count_displayables_in_layer(layer):
    """
    Returns how many displayables are in the supplied layer.
    """

    sls = scene_lists()

    return len(sls.layers[layer])

def image(name, d):
    """
    :doc: se_images

    Defines an image. This function is the python equivalent of the
    image statement.

    `name`
        The name of the image to display, a string.

    `d`
        The displayable to associate with that image name.

    This function may only be run from inside an init block. It is an
    error to run this function once the game has started.
    """

    if d is None:
        raise Exception("Images may not be declared to be None.")

    if not renpy.game.context().init_phase:
        raise Exception("Images may only be declared inside init blocks.")

    if not isinstance(name, tuple):
        name = tuple(name.split())

    d = renpy.easy.displayable(d)
    renpy.display.image.register_image(name, d)

def copy_images(old, new):
    """
    :doc: image_func

    Copies images beginning with one prefix to images beginning with
    another. For example::

        renpy.copy_images("eileen", "eileen2")

    will create an image beginning with "eileen2" for every image beginning
    with "eileen". If "eileen happy" exists, "eileen2 happy" will be
    created.

    `old`
        A space-separated string giving the components of the old image
        name.

    `new`
        A space-separated string giving the components of the new image
        name.

    """

    if not isinstance(old, tuple):
        old = tuple(old.split())

    if not isinstance(new, tuple):
        new = tuple(new.split())

    lenold = len(old)

    for k, v in renpy.display.image.images.items():
        if len(k) < lenold:
            continue

        if k[:lenold] == old:
            renpy.display.image.register_image(new + k[lenold:], v)

def showing(name, layer='master'):
    """
    :doc: image_func

    Returns true if an image with the same tag as `name` is showing on
    `layer`

    `image`
        May be a string giving the image name or a tuple giving each
        component of the image name. It may also be a string giving
        only the image tag.
    """

    if not isinstance(name, tuple):
        name = tuple(name.split())

    return renpy.game.context().images.showing(layer, name)

def predict_show(name, layer='master', what=None, tag=None, at_list=[ ]):
    """
    :undocumented:

    Predicts a scene or show statement.

    `name`
        The name of the image to show, a string.

    `layer`
        The layer the image is being show non.

    `what`
        What is being show - if given, overrides `name`.

    `tag`
        The tag of the thing being shown.

    `at_list`
        A list of transforms to apply to the displayable.
    """

    key = tag or name[0]

    if what is None:
        what = name
    elif isinstance(what, basestring):
        what = tuple(what.split())

    if isinstance(what, renpy.display.core.Displayable):
        base = img = what

    else:
        if renpy.config.image_attributes:

            new_what = renpy.game.context().images.apply_attributes(layer, key, name)
            if new_what is not None:
                what = new_what
                name = (key,) + new_what[1:]

        base = img = renpy.display.image.ImageReference(what, style='image_placement')

        if not base.find_target():
            return

    for i in at_list:
        if isinstance(i, renpy.display.motion.Transform):
            img = i(child=img)
        else:
            img = i(img)

    renpy.game.context().images.predict_show(layer, name, True)
    renpy.display.predict.displayable(img)




def show(name, at_list=[ ], layer='master', what=None, zorder=0, tag=None, behind=[ ], atl=None, transient=False, munge_name=True):
    """
    :doc: se_images
    :args: (name, at_list=[ ], layer='master', what=None, zorder=0, tag=None, behind=[ ])

    Shows an image on a layer. This is the programmatic equivalent of the show
    statement.

    `name`
        The name of the image to show, a string.

    `at_list`
        A list of transforms that are applied to the image.
        The equivalent of the ``at`` property.

    `layer`
        A string, giving the name of the layer on which the image will be shown.
        The equivalent of the ``onlayer`` property.

    `what`
        If not None, this is a displayable that will be shown in lieu of
        looking on the image. (This is the equivalent of the show expression
        statement.) When a `what` parameter is given, `name` can be used to
        associate a tag with the image.

    `zorder`
        An integer, the equivalent of the ``zorder`` property.

    `tag`
        A string, used to specify the the image tag of the shown image. The
        equivalent of the ``as`` property.

    `behind`
        A list of strings, giving image tags that this image is shown behind.
        The equivalent of the ``behind`` property.
    """

    if renpy.game.context().init_phase:
        raise Exception("Show may not run while in init phase.")

    if not isinstance(name, tuple):
        name = tuple(name.split())

    sls = scene_lists()
    key = tag or name[0]

    if renpy.config.sticky_positions:
        if not at_list and key in sls.at_list[layer]:
            at_list = sls.at_list[layer][key]

    if what is None:
        what = name
    elif isinstance(what, basestring):
        what = tuple(what.split())

    if isinstance(what, renpy.display.core.Displayable):
        base = img = what

    else:

        if renpy.config.image_attributes:
            new_what = renpy.game.context().images.apply_attributes(layer, key, name)
            if new_what is not None:
                what = new_what
                name = (key,) + new_what[1:]

        base = img = renpy.display.image.ImageReference(what, style='image_placement')

        if not base.find_target() and renpy.config.missing_show:
            if renpy.config.missing_show(name, what, layer):
                return

    for i in at_list:
        if isinstance(i, renpy.display.motion.Transform):
            img = i(child=img)
        else:
            img = i(img)

    # Update the list of images we have ever seen.
    renpy.game.persistent._seen_images[name] = True  # @UndefinedVariable

    if tag and munge_name:
        name = (tag,) + name[1:]


    if renpy.config.missing_hide:
        renpy.config.missing_hide(name, layer)

    sls.add(layer, img, key, zorder, behind, at_list=at_list, name=name, atl=atl, default_transform=renpy.config.default_transform, transient=transient)


def hide(name, layer='master'):
    """
    :doc: se_images

    Hides an image from a layer. The python equivalent of the hide statement.

    `name`
         The name of the image to hide. Only the image tag is used, and
         any image with the tag is hidden (the precise name does not matter).

    `layer`
         The layer on which this function operates.
    """

    if renpy.game.context().init_phase:
        raise Exception("Hide may not run while in init phase.")

    if not isinstance(name, tuple):
        name = tuple(name.split())

    sls = scene_lists()
    key = name[0]
    sls.remove(layer, key)

    if renpy.config.missing_hide:
        renpy.config.missing_hide(name, layer)


def scene(layer='master'):
    """
    :doc: se_images

    Removes all displayables from `layer`. This is equivalent to the scene
    statement, when the scene statement is not given an image to show.

    A full scene statement is equivalent to a call to renpy.scene followed by a
    call to :func:`renpy.show`. For example::

        scene bg beach

    is equivalent to::

        $ renpy.scene()
        $ renpy.show("bg beach")
    """

    if renpy.game.context().init_phase:
        raise Exception("Scene may not run while in init phase.")

    sls = scene_lists()
    sls.clear(layer)

    if renpy.config.missing_scene:
        renpy.config.missing_scene(layer)

def watch(expression, style='default', **properties):
    """
    :doc: debug

    This watches the given python expression, by displaying it in the
    upper-left corner of the screen (although position properties
    can change that). The expression should always be
    defined, never throwing an exception.

    A watch will not persist through a save or restart.
    """

    def overlay_func():
        renpy.ui.text(unicode(renpy.python.py_eval(expression)),
                      style=style, **properties)

    renpy.config.overlay_functions.append(overlay_func)

def input(prompt, default='', allow=None, exclude='{}', length=None, with_none=None, pixel_width=None): #@ReservedAssignment
    """
    :doc: input

    Calling this function pops up a window asking the player to enter some
    text. It returns the entered text.

    `prompt`
        A string giving a prompt to display to the player.

    `default`
        A string giving the initial text that will be edited by the player.

    `allow`
        If not None, a string giving a list of characters that will
        be allowed in the text.

    `exclude`
        If not None, if a character is present in this string, it is not
        allowed in the text.

    `length`
        If not None, this must be an integer giving the maximum length
        of the input string.

    `pixel_width`
        If not None, the input is limited to being this many pixels wide,
        in the font used by the input to display text.
    """

    renpy.exports.mode('input')

    roll_forward = renpy.exports.roll_forward_info()
    if not isinstance(roll_forward, basestring):
        roll_forward = None

    # use previous data in rollback
    if roll_forward is not None:
        default = roll_forward

    fixed = in_fixed_rollback();

    if has_screen("input"):
        widget_properties = { }
        widget_properties["input"] = dict(default=default, length=length, allow=allow, exclude=exclude, editable=not fixed, pixel_width=pixel_width)

        show_screen("input", _transient=True, _widget_properties=widget_properties, prompt=prompt)

    else:

        renpy.ui.window(style='input_window')
        renpy.ui.vbox()

        renpy.ui.text(prompt, style='input_prompt')

        inputwidget = renpy.ui.input(default, length=length, style='input_text', allow=allow, exclude=exclude)

        # disable input in fixed rollback
        if fixed:
            inputwidget.disable()

        renpy.ui.close()

    renpy.exports.shown_window()

    if not renpy.game.after_rollback:
        renpy.loadsave.force_autosave(True)

    # use normal "say" click behavior if input can't be changed
    if fixed:
        renpy.ui.saybehavior()

    rv = renpy.ui.interact(mouse='prompt', type="input", roll_forward=roll_forward)
    renpy.exports.checkpoint(rv)

    if with_none is None:
        with_none = renpy.config.implicit_with_none

    if with_none:
        renpy.game.interface.do_with(None, None)

    return rv

def menu(items, set_expr):
    """
    :undocumented:

    Displays a menu, and returns to the user the value of the selected
    choice. Also handles conditions and the menuset.
    """

    if renpy.config.old_substitutions:
        def substitute(s):
            return s % tag_quoting_dict
    else:
        def substitute(s):
            return s


    # Filter the list of items to only include ones for which the
    # condition is true.
    items = [ (substitute(label), value)
              for label, condition, value in items
              if renpy.python.py_eval(condition) ]

    # Filter the list of items on the set_expr:
    if set_expr:
        set = renpy.python.py_eval(set_expr) #@ReservedAssignment
        items = [ (label, value)
                  for label, value in items
                  if label not in set ]
    else:
        set = None #@ReservedAssignment

    # Check to see if there's at least one choice in set of items:
    choices = [ value for label, value in items if value is not None ]

    # If not, bail out.
    if not choices:
        return None

    # Show the menu.
    rv = renpy.store.menu(items)

    # If we have a set, fill it in with the label of the chosen item.
    if set is not None and rv is not None:
        for label, value in items:
            if value == rv:
                try:
                    set.append(label)
                except AttributeError:
                    set.add(label)
    return rv

def choice_for_skipping():
    """
    :doc: other

    Tells Ren'Py that a choice is coming up soon. This currently has
    two effects:

    * If Ren'Py is skipping, and the Skip After Choices preferences is set
      to stop skipping, skipping is terminated.

    * An auto-save is triggered.
    """

    if renpy.config.skipping and not renpy.game.preferences.skip_after_choices:
        renpy.config.skipping = None

    if not renpy.game.after_rollback:
        renpy.loadsave.force_autosave(True)



def predict_menu():
    """
    :undocumented:

    Predicts widgets that are used by the menu.
    """

    # This only makes sense for non-NVL menus. But when we have
    # NVL menus, they're likely to have already been predicted.
    #
    # An item lets us load imagebuttons as necessary.

    if not renpy.config.choice_screen_chosen:
        return

    items = [ ("Menu Prediction", True, False) ]

    predict_screen(
        "choice",
        items=items,
        )


def display_menu(items,
                 window_style='menu_window',
                 interact=True,
                 with_none=None,
                 caption_style='menu_caption',
                 choice_style='menu_choice',
                 choice_chosen_style='menu_choice_chosen',
                 choice_button_style='menu_choice_button',
                 choice_chosen_button_style='menu_choice_chosen_button',
                 scope={ },
                 widget_properties=None,
                 screen="choice",
                 type="menu", #@ReservedAssignment
                 predict_only=False,
                 **kwargs):
    """
    :doc: se_menu
    :args: (items, interact=True, screen="choice")

    This displays a menu to the user. `items` should be a list of 2-item tuples.
    In each tuple, the first item is a textual label, and the second item is
    the value to be returned if that item is selected. If the value is None,
    the first item is used as a menu caption.

    This function takes many arguments, of which only a few are documented.
    Except for `items`, all arguments should be given as keyword arguments.

    `interact`
        If false, the menu is displayed, but no interaction is performed.

    `screen`
        The name of the screen used to display the menu.

    """

    if interact:
        renpy.exports.mode(type)
        choice_for_skipping()

    # The possible choices in the menu.
    choices = [ val for label, val in items ]
    while None in choices:
        choices.remove(None)

    # Roll forward.
    roll_forward = renpy.exports.roll_forward_info()

    if roll_forward not in choices:
        roll_forward = None

    # Auto choosing.
    if renpy.config.auto_choice_delay:

        renpy.ui.pausebehavior(renpy.config.auto_choice_delay,
                               random.choice(choices))

    # The location
    location=renpy.game.context().current

    # change behavior for fixed rollback
    if in_fixed_rollback() and renpy.config.fix_rollback_without_choice:
        renpy.ui.saybehavior()

    # Show the menu.
    if has_screen(screen):

        item_actions = [ ]

        if widget_properties is None:
            props = { }
        else:
            props = widget_properties

        for (label, value) in items:

            if not label:
                value = None

            if value is not None:
                action = renpy.ui.ChoiceReturn(label, value, location)
            else:
                action = None

            if renpy.config.choice_screen_chosen:
                if action is not None:
                    item_actions.append((label, action, action.get_chosen()))
                else:
                    item_actions.append((label, action, False))
            else:
                item_actions.append((label, action))

            show_screen(screen, items=item_actions, _widget_properties=props, _transient=True, _layer=renpy.config.choice_layer, **scope)

    else:
        renpy.ui.window(style=window_style, focus="menu")
        renpy.ui.menu(items,
                      location=renpy.game.context().current,
                      focus="choices",
                      default=True,
                      caption_style=caption_style,
                      choice_style=choice_style,
                      choice_chosen_style=choice_chosen_style,
                      choice_button_style=choice_button_style,
                      choice_chosen_button_style=choice_chosen_button_style,
                      **kwargs)

    renpy.exports.shown_window()

    # Log the chosen choice.
    for label, val in items:
        if val is not None:
            log("Choice: " + label)
        else:
            log(label)

    log("")

    if interact:

        rv = renpy.ui.interact(mouse='menu', type=type, roll_forward=roll_forward)

        for label, val in items:
            if rv == val:
                log("User chose: " + label)
                break
        else:
            log("No choice chosen.")

        log("")

        checkpoint(rv)

        if with_none is None:
            with_none = renpy.config.implicit_with_none

        if with_none:
            renpy.game.interface.do_with(None, None)

        return rv

    return None

class TagQuotingDict(object):
    def __getitem__(self, key):

        store = renpy.store.__dict__

        if key in store:
            rv = store[key]

            if isinstance(rv, (str, unicode)):
                rv = rv.replace("{", "{{")

            return rv
        else:
            if renpy.config.debug:
                raise Exception("During an interpolation, '%s' was not found as a variable." % key)
            return "<" + key + " unbound>"

tag_quoting_dict = TagQuotingDict()

def predict_say(who, what):
    """
    :undocumented:

    This is called to predict the results of a say command.
    """

    if who is None:
        who = renpy.store.narrator # E1101 @UndefinedVariable

    if isinstance(who, (str, unicode)):
        return renpy.store.predict_say(who, what)

    predict = getattr(who, 'predict', None)
    if predict:
        predict(what)

def scry_say(who, scry):
    """
    :undocumented:

    Called when scry is called on a say statement. Needs to set
    the interacts field.
    """

    try:
        scry.interacts = who.will_interact()
    except:
        scry.interacts = True

def say(who, what, interact=True):
    """
    :doc: se_say

    The equivalent of the say statement.

    `who`
        Either the character that will say something, None for the narrator,
        or a string giving the character name. In the latter case, the
        :func:`say` is used to create the speaking character.

    `what`
        A string giving the line to say. Percent-substitutions are performed
        in this string.

    `interact`
        If true, Ren'Py waits for player input when displaying the dialogue. If
        false, Ren'Py shows the dialogue, but does not perform an interaction.

    This function is rarely necessary, as the following three lines are
    equivalent. ::

        e "Hello, world."
        $ renpy.say(e, "Hello, world.")
        $ e("Hello, world.")
    """

    if renpy.config.old_substitutions:
        # Interpolate variables.
        what = what % tag_quoting_dict

    if who is None:
        who = renpy.store.narrator # E1101 @UndefinedVariable

    if isinstance(who, (str, unicode)):
        renpy.store.say(who, what, interact=interact)
    else:
        who(what, interact=interact)


def imagemap(ground, selected, hotspots, unselected=None, overlays=False,
             style='imagemap', mouse='imagemap', with_none=None, **properties):
    """
    :undocumented: Use screens already.

    Displays an imagemap. An image map consists of two images and a
    list of hotspots that are defined on that image. When the user
    clicks on a hotspot, the value associated with that hotspot is
    returned.

    @param ground: The name of the file containing the ground
    image. The ground image is displayed for areas that are not part
    of any hotspots.

    @param selected: The name of the file containing the selected
    image. This image is displayed in hotspots when the mouse is over
    them.

    @param hotspots: A list of tuples defining the hotspots in this
    image map. Each tuple has the format (x0, y0, x1, y1, result).
    (x0, y0) gives the coordinates of the upper-left corner of the
    hotspot, (x1, y1) gives the lower-right corner, and result gives
    the value returned from this function if the mouse is clicked in
    the hotspot.

    @param unselected: If provided, then it is the name of a file
    containing the image that's used to fill in hotspots that are not
    selected as part of any image. If not provided, the ground image
    is used instead.

    @param overlays: If True, overlays are displayed when this imagemap
    is active. If False, the overlays are suppressed.

    @param with_none: If True, performs a with None after the input. If None,
    takes the value from config.implicit_with_none.
    """

    renpy.exports.mode('imagemap')

    renpy.ui.imagemap_compat(ground, selected, hotspots, unselected=unselected,
                             style=style, **properties)

    roll_forward = renpy.exports.roll_forward_info()
    if roll_forward not in [ result for _x0, _y0, _x1, _y1, result in hotspots]:
        roll_forward = None

    if in_fixed_rollback() and renpy.config.fix_rollback_without_choice:
        renpy.ui.saybehavior()

    rv = renpy.ui.interact(suppress_overlay=(not overlays),
                           type='imagemap',
                           mouse=mouse,
                           roll_forward=roll_forward)

    renpy.exports.checkpoint(rv)

    if with_none is None:
        with_none = renpy.config.implicit_with_none

    if with_none:
        renpy.game.interface.do_with(None, None)

    return rv


def pause(delay=None, music=None, with_none=None, hard=False, checkpoint=None):
    """
    :doc: other

    Causes Ren'Py to pause. Returns true if the user clicked to end the pause,
    or false if the pause timed out or was skipped.

    `delay`
        If given, the number of seconds Ren'Py should pause for.

    `music`
        Retained for compatibility purposes.

    `with_none`
        Determines if a with None clause is executed at the end of the pause.

    `hard`
        If true, a click will not interrupt the pause. Use this sparingly,
        as it's hard to distinguish a hard pause from a crashing game.

    `checkpoint`
        If true, a checkpoint will be set, and players will be able to roll
        back to this statement. If false, no checkpoint will be set. If None,
        a checkpoint will only be set if display is set.
    """


    if checkpoint is None:
        if delay is not None:
            checkpoint = False
        else:
            checkpoint = True

    if renpy.config.skipping == "fast":
        return False

    roll_forward = renpy.exports.roll_forward_info()
    if roll_forward not in [ True, False ]:
        roll_forward = None

    renpy.exports.mode('pause')

    if music is not None:
        newdelay = renpy.audio.music.get_delay(music)

        if newdelay is not None:
            delay = newdelay

    if renpy.game.after_rollback and roll_forward is None:
        delay = 0

    if hard:
        renpy.ui.saybehavior(dismiss='dismiss_hard_pause')
    else:
        renpy.ui.saybehavior()

    if delay is not None:
        renpy.ui.pausebehavior(delay, False)

    rv = renpy.ui.interact(mouse='pause', type='pause', roll_forward=roll_forward)

    if checkpoint:
        renpy.exports.checkpoint(rv, keep_rollback=True)

    if with_none is None:
        with_none = renpy.config.implicit_with_none

    if with_none:
        renpy.game.interface.do_with(None, None)

    return rv


def movie_cutscene(filename, delay=None, loops=0, stop_music=True):
    """
    :doc: movie_cutscene

    This displays an MPEG-1 cutscene for the specified number of
    seconds. The user can click to interrupt the cutscene.
    Overlays and Underlays are disabled for the duration of the cutscene.

    `filename`
        The name of a file containing an MPEG-1 movie.

    `delay`
        The number of seconds to wait before ending the cutscene.
        Normally the length of the movie, in seconds. If None, then the
        delay is computed from the number of loops (that is, loops + 1) *
        the length of the movie. If -1, we wait until the user clicks.

    `loops`
        The number of extra loops to show, -1 to loop forever.

    Returns True if the movie was terminated by the user, or False if the
    given delay elapsed uninterrupted.
    """

    renpy.exports.mode('movie')

    if stop_music:
        renpy.audio.audio.set_force_stop("music", True)

    movie_start_fullscreen(filename, loops=loops)

    renpy.ui.saybehavior()

    if delay is None or delay < 0:
        renpy.ui.soundstopbehavior("movie")
    else:
        renpy.ui.pausebehavior(delay, False)

    if renpy.game.log.forward:
        roll_forward = True
    else:
        roll_forward = None

    rv = renpy.ui.interact(suppress_overlay=True,
                           show_mouse=False,
                           roll_forward=roll_forward)

    # We don't want to put a checkpoint here, as we can't roll back while
    # playing a cutscene.

    movie_stop()

    if stop_music:
        renpy.audio.audio.set_force_stop("music", False)

    return rv


def with_statement(trans, always=False, paired=None, clear=True):
    """
    :doc: se_with
    :name: renpy.with_statement
    :args: (trans, always=False)

    Causes a transition to occur. This is the python equivalent of the
    with statement.

    `trans`
        The transition.

    `always`
        If True, the transition will always occur, even if the user has
        disabled transitions.

    This function returns true if the user chose to interrupt the transition,
    and false otherwise.
    """

    if renpy.game.context().init_phase:
        raise Exception("With statements may not run while in init phase.")

    if renpy.config.skipping:
        trans = None

    if not (renpy.game.preferences.transitions or always):
        trans = None

    renpy.exports.mode('with')

    return renpy.game.interface.do_with(trans, paired, clear=clear)

globals()["with"] = with_statement

def rollback(force=False, checkpoints=1, defer=False, greedy=True, label=None):
    """
    :doc: rollback

    Rolls the state of the game back to the last checkpoint.

    `force`
        If true, the rollback will occur in all circumstances. Otherwise,
        the rollback will only occur if rollback is enabled in the store,
        context, and config.

    `checkpoints`
        Ren'Py will roll back through this many calls to renpy.checkpoint. It
        will roll back as far as it can, subject to this condition.

    `defer`
        If true, the call will be deferred until code from the main context is
        executed.

    `greedy`
        If true, rollback will occur just before the previous checkpoint.
        If false, rollback occurs to just before the current checkpoint.

    `label`
        If not None, a label that is called when rollback completes.
    """

    if defer and len(renpy.game.contexts) > 1:
        renpy.game.contexts[0].defer_rollback = (force, checkpoints)
        return

    if not force:

        if not renpy.store._rollback:
            return

        if not renpy.game.context().rollback:
            return

        if not renpy.config.rollback_enabled:
            return

    renpy.config.skipping = None
    renpy.game.log.complete()
    renpy.game.log.rollback(checkpoints, greedy=greedy, label=label, force=force)

def toggle_fullscreen():
    """
    :undocumented:
    Toggles the fullscreen mode.
    """

    renpy.game.preferences.fullscreen = not renpy.game.preferences.fullscreen

def toggle_music():
    """
    :undocumented:
    Does nothing.
    """

def has_label(name):
    """
    :doc: label

    Returns true if name is a valid label in the program, or false
    otherwise.
    """

    return renpy.game.script.has_label(name)

def get_all_labels():
    """
    :doc: label

    Returns the set of all labels defined in the program, including labels
    defined for internal use in the libraries.
    """
    rv = [ ]

    for i in renpy.game.script.namemap.iterkeys():
        if isinstance(i, basestring):
            rv.append(i)

    return renpy.python.RevertableSet(rv)


def take_screenshot(scale=None, background=False):
    """
    :doc: loadsave

    Causes a screenshot to be taken. This screenshot will be saved as part of
    a save game.
    """

    if scale is None:
        scale = (renpy.config.thumbnail_width, renpy.config.thumbnail_height)

    renpy.game.interface.take_screenshot(scale, background=background)

def full_restart(transition=False, label="_invoke_main_menu", target="_main_menu"):
    """
    :doc: other

    Causes Ren'Py to restart, returning the user to the main menu.

    `transition`
        If given, the transition to run, or None to not run a transition.
        False uses :var:`config.end_game_transition`.
    """

    if transition is False:
        transition = renpy.config.end_game_transition

    raise renpy.game.FullRestartException((transition, label, target))

def utter_restart():
    """
    :undocumented: Used in the implementation of shift+R.

    Causes an utter restart of Ren'Py. This reloads the script and
    re-runs initialization.
    """

    raise renpy.game.UtterRestartException()

def reload_script():
    """
    :doc: other

    Causes Ren'Py to save the game, reload the script, and then load the
    save.
    """

    renpy.game.call_in_new_context("_save_reload_game")

def quit(relaunch=False, status=0): #@ReservedAssignment
    """
    :doc: other

    This causes Ren'Py to exit entirely.

    `relaunch`
        If true, Ren'Py will run a second copy of itself before quitting.

    `status`
        The status code Ren'Py will return to the operating system.
        Generally, 0 is success, and positive integers are failure.
    """

    raise renpy.game.QuitException(relaunch=relaunch, status=status)

def jump(label):
    """
    :doc: se_jump

    Causes the current statement to end, and control to jump to the given
    label.
    """

    raise renpy.game.JumpException(label)

def jump_out_of_context(label):
    """
    :doc: label

    Causes control to leave the current context, and then to be
    transferred in the parent context to the given label.
    """

    raise renpy.game.JumpOutException(label)

def call(label, *args, **kwargs):
    """
    :doc: se_call

    Causes the current Ren'Py statement to terminate, and a jump to a
    `label` to occur. When the jump returns, control will be passed
    to the statement following the current statement.
    """

    raise renpy.game.CallException(label, args, kwargs)

def screenshot(filename):
    """
    :doc: other

    Saves a screenshot in `filename`.
    """

    renpy.game.interface.save_screenshot(filename)

def version(tuple=False): #@ReservedAssignment
    """
    :doc: other

    If `tuple` is false, returns a string containing "Ren'Py ", followed by
    the current version of Ren'Py.

    If `tuple` is true, returns a tuple giving each component of the
    version as an integer.
    """

    if tuple:
        return renpy.version_tuple

    return renpy.version

def transition(trans, layer=None, always=False, force=False):
    """
    :doc: other
    :args: (trans, layer=None, always=False)

    Sets the transition that will be used during the next interaction.

    `layer`
        The layer the transition applies to. If None, the transition
        applies to the entire scene.

    `always`
        If false, this respects the transition preference. If true, the
        transition is always run.
    """

    if not always and not renpy.game.preferences.transitions:
        trans = None

    renpy.game.interface.set_transition(trans, layer, force=force)

def get_transition(layer=None):
    """
    :doc: other

    Gets the transition for `layer`, or the entire scene if
    `layer` is None. This returns the transition that is queued up
    to run during the next interaction, or None if no such
    transition exists.
    """

    return renpy.game.interface.transition.get(layer, None)

def clear_game_runtime():
    """
    :doc: other

    Resets the game runtime counter.
    """

    renpy.game.contexts[0].runtime = 0

def get_game_runtime():
    """
    :doc: other

    Returns the game runtime counter.

    The game runtime counter counts the number of seconds that have
    elapsed while waiting for user input in the top-level context.
    (It does not count time spent in the main or game menus.)
    """

    return renpy.game.contexts[0].runtime

def loadable(filename):
    """
    :doc: file

    Returns True if the given filename is loadable, meaning that it
    can be loaded from the disk or from inside an archive. Returns
    False if this is not the case.
    """

    return renpy.loader.loadable(filename)

def exists(filename):
    """
    :doc: file_rare

    Returns true if the given filename can be found in the
    searchpath. This only works if a physical file exists on disk. It
    won't find the file if it's inside of an archive.

    You almost certainly want to use :func:`renpy.loadable` in preference
    to this function.
    """

    try:
        renpy.loader.transfn(filename)
        return True
    except:
        return False

def restart_interaction():
    """
    :doc: other

    Restarts the current interaction. Among other things, this displays
    images added to the scene, re-evaluates screens, and starts any
    queued transitions.

    This only does anything when called from within an interaction (for
    example, from an action). Outside an interaction, this function has
    no effect.
    """

    try:
        renpy.game.interface.restart_interaction = True
    except:
        pass

def context():
    """
    :doc: context

    Returns an object that is unique to the current context. The object
    is copied when entering a new context, but changes to the copy do
    not change the original.

    The object is saved and participates in rollback.
    """

    return renpy.game.context().info

def context_nesting_level():
    """
    :doc: context

    Returns the nesting level of the current context. This is 0 for the
    outermost context (the context that is saved, loaded, and rolled-back),
    and is non-zero in other contexts, such as menu and replay contexts.
    """

    return len(renpy.game.contexts) - 1

def music_start(filename, loops=True, fadeout=None, fadein=0):
    """
    Deprecated music start function, retained for compatibility. Use
    renpy.music.play() or .queue() instead.
    """

    renpy.audio.music.play(filename, loop=loops, fadeout=fadeout, fadein=fadein)

def music_stop(fadeout=None):
    """
    Deprecated music start function, retained for compatibility. Use
    renpy.music.play() or .queue() instead.
    """

    renpy.audio.music.stop(fadeout=fadeout)

def get_filename_line():
    """
    :doc: debug

    Returns a pair giving the filename and line number of the current
    statement.
    """

    n = renpy.game.script.namemap.get(renpy.game.context().current, None)

    if n is None:
        return "unknown", 0
    else:
        return n.filename, n.linenumber

# A file that log logs to.
logfile = None

def log(msg):
    """
    :doc: debug

    If :var:`config.log` is not set, this does nothing. Otherwise, it opens
    the logfile (if not already open), formats the message to 70
    columns, and prints it to the logfile.
    """

    global logfile

    if not renpy.config.log:
        return

    if msg is None:
        return

    if not logfile:
        import codecs

        logfile = _file(renpy.config.log, "a")
        if not logfile.tell():
            logfile.write(codecs.BOM_UTF8)

    import textwrap

    print >>logfile, textwrap.fill(msg).encode("utf-8")
    logfile.flush()

def force_full_redraw():
    """
    :doc: other

    Forces the screen to be redrawn in full. Call this after using pygame
    to redraw the screen directly.
    """

    renpy.game.interface.full_redraw = True

def do_reshow_say(who, what, interact=False):

    if who is not None:
        who = renpy.python.py_eval(who)

    say(who, what, interact=interact)

curried_do_reshow_say = curry(do_reshow_say)

def get_reshow_say(**kwargs):
    return curried_do_reshow_say(
        renpy.store._last_say_who,
        renpy.store._last_say_what,
        **kwargs)

def reshow_say(**kwargs):
    get_reshow_say()(**kwargs)

def current_interact_type():
    return getattr(renpy.game.context().info, "_current_interact_type", None)

def last_interact_type():
    return getattr(renpy.game.context().info, "_last_interact_type", None)

def dynamic(*vars): #@ReservedAssignment
    """
    :doc: other

    This can be given one or more variable names as arguments. This makes
    the variables dynamically scoped to the current call. The variables will
    be reset to their original value when the call returns.

    An example call is::

        $ renpy.dynamic("x", "y", "z")
    """

    renpy.game.context().make_dynamic(vars)

def context_dynamic(*vars): #@ReservedAssignment
    """
    :doc: other

    This can be given one or more variable names as arguments. This makes
    the variables dynamically scoped to the current context. The variables will
    be reset to their original value when the call returns.

    An example call is::

        $ renpy.context_dynamic("x", "y", "z")
    """

    renpy.game.context().make_dynamic(vars, context=True)

def seen_label(label):
    """
    :doc: label

    Returns true if the named label has executed at least once on the current user's
    system, and false otherwise. This can be used to unlock scene galleries, for
    example.
    """
    return label in renpy.game.persistent._seen_ever  # @UndefinedVariable

def seen_audio(filename):
    """
    :doc: audio

    Returns True if the given filename has been played at least once on the current
    user's system.
    """
    return filename in renpy.game.persistent._seen_audio  # @UndefinedVariable

def seen_image(name):
    """
    :doc: image_func

    Returns True if the named image has been seen at least once on the user's
    system. An image has been seen if it's been displayed using the show statement,
    scene statement, or :func:`renpy.show` function. (Note that there are cases
    where the user won't actually see the image, like a show immediately followed by
    a hide.)
    """
    if not isinstance(name, tuple):
        name = tuple(name.split())

    return name in renpy.game.persistent._seen_images  # @UndefinedVariable

def file(fn): #@ReservedAssignment
    """
    :doc: file

    Returns a read-only file-like object that accesses the file named `fn`. The file is
    accessed using Ren'Py's standard search method, and may reside in an RPA archive.
    or as an Android asset.

    The object supports a wide subset of the fields and methods found on python's
    standard file object, opened in binary mode. (Basically, all of the methods that
    are sensible for a read-only file.)
    """
    return renpy.loader.load(fn)

def image_size(im):
    """
    :doc: file_rare

    Given an image manipulator, loads it and returns a (``width``,
    ``height``) tuple giving its size.

    This reads the image in from disk and decompresses it, without
    using the image cache. This can be slow.
    """

    # Index the archives, if we haven't already.
    renpy.loader.index_archives()

    im = renpy.easy.displayable(im)

    if not isinstance(im, renpy.display.im.Image):
        raise Exception("renpy.image_size expects it's argument to be an image.")

    surf = im.load()
    return surf.get_size()

def get_at_list(name, layer='master'):
    """
    :undocumented:

    Returns the list of transforms being applied to a layer.
    """

    if isinstance(name, basestring):
        name = tuple(name.split())

    tag = name[0]

    return renpy.game.context().scene_lists.at_list[layer].get(tag, None)

def show_layer_at(at_list, layer='master'):
    """
    :doc: se_images

    The python equivalent of the ``show layer`` `layer` ``at`` `at_list`
    statement.
    """

    if not isinstance(at_list, list):
        at_list = [ at_list ]

    renpy.game.context().scene_lists.set_layer_at_list(layer, at_list)

layer_at_list = show_layer_at

def free_memory():
    """
    :doc: other

    Attempts to free some memory. Useful before running a renpygame-based
    minigame.
    """
    force_full_redraw()
    renpy.display.interface.kill_textures_and_surfaces()

def easy_displayable(d, none=False):
    """
    :undocumented:
    """

    if none:
        return renpy.easy.displayable(d)
    else:
        return renpy.easy.displayable_or_none(d)

def quit_event():
    """
    :doc: other

    Triggers a quit event, as if the player clicked the quit button in the
    window chrome.
    """

    renpy.game.interface.quit_event()

def iconify():
    """
    :doc: other

    Iconifies the game.
    """

    renpy.game.interface.iconify()

# New context stuff.
call_in_new_context = renpy.game.call_in_new_context
curried_call_in_new_context = renpy.curry.curry(renpy.game.call_in_new_context)
invoke_in_new_context = renpy.game.invoke_in_new_context
curried_invoke_in_new_context = renpy.curry.curry(renpy.game.invoke_in_new_context)
call_replay = renpy.game.call_replay

# Error handling stuff.
def _error(msg):
    raise Exception(msg)

_error_handlers = [ _error ]

def push_error_handler(eh):
    _error_handlers.append(eh)

def pop_error_handler():
    _error_handlers.pop()

def error(msg):
    _error_handlers[-1](msg)

def timeout(seconds):
    """
    :doc: udd_utility

    Causes an event to be generated before `seconds` seconds have elapsed.
    This ensures that the event method of a user-defined displayable will be
    called.
    """

    renpy.game.interface.timeout(seconds)

def end_interaction(value):
    """
    :doc: udd_utility

    If `value` is not None, immediately ends the current interaction, causing
    the interaction to return `value`. If `value` is None, does nothing.

    This can be called from inside the render and event methods of a
    creator-defined displayable.
    """

    if value is None:
        return

    raise renpy.display.core.EndInteraction(value)

def scry():
    """
    :doc: other

    Returns the scry object for the current statement.

    The scry object tells Ren'Py about things that must be true in the
    future of the current statement. Right now, the scry object has one
    field:

    ``nvl_clear``
        Is true if an ``nvl clear`` statement will execute before the
        next interaction.
    """

    name = renpy.game.context().current
    node = renpy.game.script.lookup(name)
    return node.scry()

def munged_filename():
    return renpy.parser.munge_filename(get_filename_line()[0])

# Module loading stuff.

loaded_modules = set()

def load_module(name, **kwargs):
    """
    :doc: other

    This loads the Ren'Py module named name. A Ren'Py module consists of Ren'Py code
    that is loaded into the usual (store) namespace, contained in a file named
    name.rpym or name.rpymc. If a .rpym file exists, and is newer than the
    corresponding .rpymc file, it is loaded and a new .rpymc file is created.

    All init code in the module is run before this function returns. An error is
    raised if the module name cannot be found, or is ambiguous.

    Module loading may only occur from inside an init block.
    """

    if not renpy.game.context().init_phase:
        raise Exception("Module loading is only allowed in init code.")

    if name in loaded_modules:
        return

    loaded_modules.add(name)

    old_locked = renpy.config.locked
    renpy.config.locked = False

    initcode = renpy.game.script.load_module(name)

    context = renpy.execution.Context(False)
    context.init_phase = True
    renpy.game.contexts.append(context)

    context.make_dynamic(kwargs)
    renpy.store.__dict__.update(kwargs) #@UndefinedVariable

    for prio, node in initcode: #@UnusedVariable
        renpy.game.context().run(node)

    context.pop_all_dynamic()

    renpy.game.contexts.pop()

    renpy.config.locked = old_locked

def load_string(s, filename="<string>"):
    """
    :doc: other

    Loads `s` as Ren'Py script that can be called.

    Returns the name of the first statement in s.

    `filename` is the name of the filename that statements in the string will
    appear to be from.
    """

    old_exception_info = renpy.game.exception_info

    try:

        old_locked = renpy.config.locked
        renpy.config.locked = False

        stmts, initcode = renpy.game.script.load_string(filename, unicode(s))

        if stmts is None:
            return None

        context = renpy.execution.Context(False)
        context.init_phase = True
        renpy.game.contexts.append(context)

        for prio, node in initcode: #@UnusedVariable
            renpy.game.context().run(node)

        context.pop_all_dynamic()
        renpy.game.contexts.pop()

        renpy.config.locked = old_locked

        return stmts[0].name

    finally:
        renpy.game.exception_info = old_exception_info

def pop_call():
    """
    :doc: other

    Pops the current call from the call stack, without returning to
    the location.

    This can be used if a label that is called decides not to return
    to its caller.
    """

    renpy.game.context().pop_dynamic()
    renpy.game.context().lookup_return(pop=True)

pop_return = pop_call

def call_stack_depth():
    """
    :doc: other

    Returns the depth of the call stack of the current context - the number
    of calls that have run without being returned from or popped from the
    call stack.
    """

    return len(renpy.game.context().return_stack)

def game_menu(screen=None):
    """
    :undocumented: Probably not what we want in the presence of
    screens.
    """

    if screen is None:
        call_in_new_context("_game_menu")
    else:
        call_in_new_context("_game_menu", screen)

def shown_window():
    """
    :doc: other

    Call this to indicate that the window has been shown. This interacts
    with the "window show" statement, which shows an empty window whenever
    this functions has not been called during an interaction.
    """

    renpy.game.context().scene_lists.shown_window = True

class placement(renpy.python.RevertableObject):
    def __init__(self, p):
        super(placement, self).__init__()

        self.xpos = p[0]
        self.ypos = p[1]
        self.xanchor = p[2]
        self.yanchor = p[3]
        self.xoffset = p[4]
        self.yoffset = p[5]
        self.subpixel = p[6]

def get_placement(d):
    """
    :doc: image_func

    This gets the placement of displayable d. There's very little warranty on this
    information, as it might change when the displayable is rendered, and might not
    exist until the displayable is first rendered.

    This returns an object with the following fields, each corresponding to a style
    property:

        * xpos
        * xanchor
        * xoffset
        * ypos
        * yanchor
        * yoffset
        * subpixel
    """
    p = d.get_placement()

    return placement(p)

def get_image_bounds(tag, width=None, height=None, layer='master'):
    """
    :doc: image_func

    If an image with `tag` exists on `layer`, returns the bounding box of
    that image. Returns None if the image is not found.

    The bounding box is an (x, y, width, height) tuple. The components of
    the tuples are expressed in pixels, and may be floating point numbers.

    `width`, `height`
        The width and height of the area that contains the image. If None,
        defaults the width and height of the screen, respectively.
    """

    tag = tag.split()[0]

    if width is None:
        width = renpy.config.screen_width
    if height is None:
        height = renpy.config.screen_height

    return scene_lists().get_image_bounds(layer, tag, width, height)

# User-Defined Displayable stuff.

Render = renpy.display.render.Render
render = renpy.display.render.render
IgnoreEvent = renpy.display.core.IgnoreEvent
redraw = renpy.display.render.redraw

class Displayable(renpy.display.core.Displayable, renpy.python.RevertableObject):
    pass

class Container(renpy.display.core.Displayable, renpy.python.RevertableObject):
    _list_type = renpy.python.RevertableList

def get_roll_forward():
    return renpy.game.interface.shown_window

def cache_pin(*args):
    """
    :undocumented: Cache pin is deprecated.
    """

    new_pins = renpy.python.RevertableSet()

    for i in args:

        im = renpy.easy.displayable(i)

        if not isinstance(im, renpy.display.im.ImageBase):
            raise Exception("Cannot pin non-image-manipulator %r" % im)

        new_pins.add(im)

    renpy.store._cache_pin_set = new_pins | renpy.store._cache_pin_set


def cache_unpin(*args):
    """
    :undocumented: Cache pin is deprecated.
    """

    new_pins = renpy.python.RevertableSet()

    for i in args:

        im = renpy.easy.displayable(i)

        if not isinstance(im, renpy.display.im.ImageBase):
            raise Exception("Cannot unpin non-image-manipulator %r" % im)

        new_pins.add(im)

    renpy.store._cache_pin_set = renpy.store._cache_pin_set - new_pins


def call_screen(_screen_name, *args, **kwargs):
    """
    :doc: screens

    The programmatic equivalent of the show screen statement.

    This shows `_screen_name` as a screen, then causes an interaction
    to occur. The screen is hidden at the end of the interaction, and
    the result of the interaction is returned.

    Keyword arguments not beginning with _ are passed to the scope of
    the screen.

    If the keyword argument `_with_none` is false, "with None" is not
    run at the end of end of the interaction.
    """

    renpy.exports.mode('screen')

    show_screen(_screen_name, _transient=True, *args, **kwargs)

    roll_forward = renpy.exports.roll_forward_info()

    try:
        rv = renpy.ui.interact(mouse="screen", type="screen", roll_forward=roll_forward)
    except (renpy.game.JumpException, renpy.game.CallException), e:
        rv = e

    renpy.exports.checkpoint(rv)

    with_none = renpy.config.implicit_with_none

    if "_with_none" in kwargs:
        with_none = kwargs.pop("_with_none")

    if with_none:
        renpy.game.interface.do_with(None, None)

    if isinstance(rv, (renpy.game.JumpException, renpy.game.CallException)):
        raise rv

    return rv


def list_files(common=False):
    """
    :doc: file

    Lists the files in the game directory and archive files. Returns
    a list of files, with / as the directory separator.

    `common`
        If true, files in the common directory are included in the
        listing.
    """

    rv = [ ]

    for dir, fn in renpy.loader.listdirfiles(common): #@ReservedAssignment
        rv.append(fn)

    return rv

def get_renderer_info():
    """
    :doc: other

    Returns a dictionary, giving information about the renderer Ren'Py is
    currently using. The dictionary has one required key:

    ``"renderer"``
        One of ``"gl"`` or ``"sw"``, corresponding to the OpenGL and
        software renderers, respectively.

    ``"resizable"``
        True if and only if the window is resizable.

    ``"additive"``
        True if and only if the renderer supports additive blending.

    Other, renderer-specific, keys may also exist. The dictionary should
    be treated as immutable. This should only be called once the display
    has been started (that is, after the init code is finished).
    """

    return renpy.display.draw.info

def display_reset():
    """
    :undocumented: Used internally.

    Causes the display to be restarted at the start of the next interaction.
    """

    renpy.display.interface.display_reset = True

def mode(mode):
    """
    :doc: modes

    Causes Ren'Py to enter the named mode, or stay in that mode if it's
    already in it.
    """

    ctx = renpy.game.context()

    if not ctx.use_modes:
        return

    modes = ctx.modes

    try:
        ctx.use_modes = False

        if mode != modes[0]:
            for c in renpy.config.mode_callbacks:
                c(mode, modes)

    finally:
        ctx.use_modes = True

    if mode in modes:
        modes.remove(mode)
    modes.insert(0, mode)

def notify(message):
    """
    :doc: other

    Causes Ren'Py to display the `message` using the notify screen. By
    default, this will cause the message to be dissolved in, displayed
    for two seconds, and dissolved out again.

    This is useful for actions that otherwise wouldn't produce feedback,
    like screenshots or quicksaves.

    Only one notification is displayed at a time. If a second notification
    is displayed, the first notification is replaced.
    """

    hide_screen('notify')
    show_screen('notify', message=message)
    restart_interaction()

def variant(name):
    """
    :doc: screens

    Returns true if a `name` is a screen variant that can be chosen
    by Ren'Py. See :ref:`screen-variants` for more details. This function
    can be used as the condition in a python if statement to set up the
    appropriate styles for the selected screen variant.

    `name` can also be a list of variants, in which case this function
    returns True if any of the variants is selected.
    """

    if isinstance(name, basestring):
        return name in renpy.config.variants
    else:
        for n in name:
            if n in renpy.config.variants:
                return True

        return False


def vibrate(duration):
    """
    :doc: other

    Causes the device to vibrate for `duration` seconds. Currently, this
    is only supported on Android.
    """

    try:
        import android #@UnresolvedImport
        android.vibrate(duration)
    except:
        pass


def get_say_attributes():
    """
    :doc: other

    Gets the attributes associated with the current say statement, or
    None if no attributes are associated with this statement.

    This is only valid when executing or predicting a say statement.
    """

    return renpy.game.context().say_attributes


def get_side_image(prefix_tag, image_tag=None, not_showing=True, layer='master'):
    """
    :doc: other

    This attempts to find an image to show as the side image.

    It begins by determining a set of image attributes. If `image_tag` is
    given, it gets the image attributes from the tag. Otherwise, it gets
    them from the currently showing character.

    It then looks up an image with the tag `prefix_tag` and those attributes,
    and returns it if it exists.

    If not_showing is True, this only returns a side image if the image the
    attributes are taken from is not on the screen.
    """

    images = renpy.game.context().images

    if image_tag is not None:
        attrs = (image_tag,) + images.get_attributes(layer, image_tag)
    else:
        attrs = renpy.store._side_image_attributes

    if not attrs:
        return None

    if not_showing and images.showing(layer, (attrs[0], )):
        return None

    required = set()
    optional = set(attrs)

    return images.choose_image(prefix_tag, required, optional, None)

def get_physical_size():
    """
    :doc: other

    Returns the size of the physical window.
    """

    return renpy.display.draw.get_physical_size()

def set_physical_size(size):
    """
    :doc: other

    Attempts to set the size of the physical window to `size`. This has the
    side effect of taking the screen out of fullscreen mode.
    """

    renpy.game.preferences.fullscreen = False

    if get_renderer_info()["resizable"]:
        renpy.display.draw.quit()
        renpy.display.interface.set_mode(size)

def fsencode(s):
    """
    :doc: file_rare
    :name: renpy.fsencode

    Converts s from unicode to the filesystem encoding.
    """

    if not isinstance(s, unicode):
        return s

    fsencoding = sys.getfilesystemencoding() or "utf-8"
    return s.encode(fsencoding, "replace")

def fsdecode(s):
    """
    :doc: file_rare
    :name: renpy.fsdecode

    Converts s from filesystem encoding to unicode.
    """

    if not isinstance(s, str):
        return s

    fsencoding = sys.getfilesystemencoding() or "utf-8"
    return s.decode(fsencoding)

from renpy.editor import launch_editor #@UnusedImport

def get_image_load_log(age=None):
    """
    :doc: other

    A generator that yields a log of image loading activity. For the last 100
    image loads, this returns:

    * The time the image was loaded (in seconds since the epoch).
    * The filename of the image that was loaded.
    * A boolean that is true if the image was preloaded, and false if the
      game stalled to load it.

    The entries are ordered from newest to oldest.

    `age`
        If not None, only images that have been loaded in the past `age`
        seconds are included.

    The image load log is only kept if config.developer = True.
    """

    if age is not None:
        deadline = time.time() - age
    else:
        deadline = 0


    for i in renpy.display.im.cache.load_log:
        if i[0] < deadline:
            break

        yield i

def end_replay():
    """
    :doc: replay

    If we're in a replay, ends the replay immediately. Otherwise, does
    nothing.
    """

    if renpy.store._in_replay:
        raise renpy.game.EndReplay()


def save_persistent():
    """
    :doc: persistent

    Saves the persistent data to disk.
    """

    renpy.persistent.update(True)

def is_seen(ever=True):
    """
    :doc: other

    Returns true if the current line has been seen by the player.

    If `ever` is true, we check to see if the line has ever been seen by the
    player. If false, we check if the line has been seen in the current
    play-through.
    """

    return renpy.game.context().seen_current(ever)

def get_mouse_pos():
    """
    :doc: other

    Returns an (x, y) tuple giving the location of the mouse pointer or the
    current touch location. If the device does not support a mouse and is not
    currently being touched, x and y are numbers, but not meaningful.
    """
    return renpy.display.draw.get_mouse_pos()

def set_mouse_pos(x, y, duration=0):
    """
    :doc: other

    Jump the mouse pointer to the location given by arguments x and y.
    If the device does not have a mouse pointer, this does nothing.

    `duration`
        The time it will take to perform the move, in seconds.
        During this time, the mouse may be unresponsive.
    """

    renpy.display.interface.set_mouse_pos(x, y, duration)

def set_autoreload(autoreload):
    """
    :doc: other

    Sets the autoreload flag, which determines if the game will be
    automatically reloaded after file changes. Autoreload will not be
    fully enabled until the game is reloaded with :func:`renpy.utter_restart`.
    """

    renpy.autoreload = autoreload

def get_autoreload():
    """
    :doc: other

    Gets the autoreload flag.
    """

    return renpy.autoreload



########NEW FILE########
__FILENAME__ = game
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This module is intended to be used as a singleton object.
# It's purpose is to store in one global all of the data that would
# be to annoying to lug around otherwise.

import renpy.display

# The basepath.
basepath = None

# A list of paths that we search to load things. This is searched for
# everything that can be loaded, before archives are used.
searchpath = [ ]

# The options that were read off the command line.
args = None

# The game's script.
script = None

# A stack of execution contexts.
contexts = [ ]

# The interface that the game uses to interact with the user.
interface = None

# Are we inside lint?
lint = False

# The RollbackLog that keeps track of changes to the game state
# and to the store.
log = None

# Some useful additional information about program execution that
# can be added to the exception.
exception_info = ''

# Used to store style information.
style = None

# The set of statements we've seen in this session.
seen_session = { }

# True if we're in the first interaction after a rollback or rollforward.
after_rollback = False

# Code that's run after the init code.
post_init = [ ]

# Should we attempt to run in a mode that uses less memory?
less_memory = False

# Should we attempt to run in a mode that minimizes the number
# of screen updates?
less_updates = False

# Should we never show the mouse?
less_mouse = False

# Should we not imagedissiolve?
less_imagedissolve = False

# The persistent data that's kept from session to session
persistent = None

# The current preferences.
preferences = None

class RestartContext(Exception):
    """
    Restarts the current context. If `label` is given, calls that label
    in the restarted context.
    """

    def __init__(self, label):
        self.label = label

class RestartTopContext(Exception):
    """
    Restarts the top context. If `label` is given, calls that label
    in the restarted context.
    """

    def __init__(self, label):
        self.label = label

class FullRestartException(Exception):
    """
    An exception of this type forces a hard restart, completely
    destroying the store and config and so on.
    """

    def __init__(self, reason="end_game"): # W0231
        self.reason = reason

class UtterRestartException(Exception):
    """
    An exception of this type forces an even harder restart, causing
    Ren'Py and the script to be reloaded.
    """

class QuitException(Exception):
    """
    An exception of this class will let us force a safe quit, from
    anywhere in the program.

    `relaunch`
        If given, the program will run another copy of itself, with the
        same arguments.

    `status`
        The status code Ren'Py will return to the operating system.
    """

    def __init__(self, relaunch=False, status=0):
        Exception.__init__(self)
        self.relaunch = relaunch
        self.status = status

class JumpException(Exception):
    """
    This should be raised with a label as the only argument. This causes
    the current statement to terminate, and execution to be transferred
    to the named label.
    """

class JumpOutException(Exception):
    """
    This should be raised with a label as the only argument. This exits
    the current context, and then raises a JumpException.
    """

class CallException(Exception):
    """
    Raise this exception to cause the current statement to terminate,
    and control to be transferred to the named label.
    """

    def __init__(self, label, args, kwargs):
        Exception.__init__(self)

        self.label = label
        self.args = args
        self.kwargs = kwargs

class EndReplay(Exception):
    """
    Raise this exception to end the current replay (the current call to
    call_replay).
    """

class ParseErrorException(Exception):
    """
    This is raised when a parse error occurs, after it has been
    reported to the user.
    """

# A tuple of exceptions that should not be caught by the
# exception reporting mechanism.
CONTROL_EXCEPTIONS = (
    RestartContext,
    RestartTopContext,
    FullRestartException,
    UtterRestartException,
    QuitException,
    JumpException,
    JumpOutException,
    CallException,
    EndReplay,
    ParseErrorException,
    KeyboardInterrupt,
    )


def context(index=-1):
    """
    Return the current execution context, or the context at the
    given index if one is specified.
    """

    return contexts[index]

def invoke_in_new_context(callable, *args, **kwargs): #@ReservedAssignment
    """
    :doc: label

    This pushes the current context, and invokes the given python
    function in a new context. When that function returns or raises an
    exception, it removes the new context, and restores the current
    context.

    Additional arguments and keyword arguments are passed to the
    callable.

    Please note that the context so created cannot execute renpy
    code. So exceptions that change the flow of renpy code (like
    the one created by renpy.jump) cause this context to terminate,
    and are handled by the next higher context.

    If you want to execute renpy code from the function, you can call
    it with renpy.call_in_new_context.

    Use this to begin a second interaction with the user while
    inside an interaction.
    """

    context = renpy.execution.Context(False, contexts[-1], clear=True)
    contexts.append(context)

    if renpy.display.interface is not None:
        renpy.display.interface.enter_context()

    try:

        return callable(*args, **kwargs)

    except renpy.game.JumpOutException, e:

        raise renpy.game.JumpException(e.args[0])

    finally:

        contexts.pop()
        contexts[-1].do_deferred_rollback()

        if interface.restart_interaction and contexts:
            contexts[-1].scene_lists.focused = None



def call_in_new_context(label, *args, **kwargs):
    """
    :doc: label

    This code creates a new context, and starts executing code from
    that label in the new context. Rollback is disabled in the
    new context. (Actually, it will just bring you back to the
    real context.)

    Use this to begin a second interaction with the user while
    inside an interaction.
    """

    context = renpy.execution.Context(False, contexts[-1], clear=True)
    contexts.append(context)

    if renpy.display.interface is not None:
        renpy.display.interface.enter_context()

    if args:
        renpy.store._args = args
    else:
        renpy.store._args = None

    if kwargs:
        renpy.store._kwargs = renpy.python.RevertableDict(kwargs)
    else:
        renpy.store._kwargs = None

    try:

        context.goto_label(label)
        return renpy.execution.run_context(False)

    except renpy.game.JumpOutException, e:

        raise renpy.game.JumpException(e.args[0])

    finally:

        contexts.pop()
        contexts[-1].do_deferred_rollback()

        if interface.restart_interaction and contexts:
            contexts[-1].scene_lists.focused = None

def call_replay(label, scope={}):
    """
    :doc: replay

    Calls a label as a memory.

    Keyword arguments are used to set the initial values of variables in the
    memory context.
    """

    renpy.game.log.complete()

    old_log = renpy.game.log
    renpy.game.log = renpy.python.RollbackLog()

    sb = renpy.python.StoreBackup()
    renpy.python.clean_stores()

    context = renpy.execution.Context(True)
    contexts.append(context)

    if renpy.display.interface is not None:
        renpy.display.interface.enter_context()

    for k, v in scope.iteritems():
        setattr(renpy.store, k, v)

    renpy.store._in_replay = label

    try:

        context.goto_label("_start_replay")
        renpy.execution.run_context(False)

    except EndReplay:
        pass

    finally:
        contexts.pop()
        renpy.game.log = old_log
        sb.restore()

        if interface.restart_interaction and contexts:
            contexts[-1].scene_lists.focused = None


# Type information.
if False:
    script = renpy.script.Script()
    interface = renpy.display.core.Interface()
    log = renpy.python.RollbackLog()
    preferences = renpy.preferences.Preferences()

########NEW FILE########
__FILENAME__ = glblacklist
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


# The blacklist of OpenGL cards. Fields are:
# - A substring of the Renderer.
# - A substring of the Version.
# - True to allow shader rendering.
# - True to allow fixed-function rendering.

# If both of the last two entries are false, GL refuses to
# start.

BLACKLIST = [

    # Crashes for Mugenjohncel.
    ("S3 Graphics DeltaChrome", "1.4 20.00", False, False),

    # A bug in Mesa 7.9 and 7.10 (before 7.10.3) causes the system to
    # fail to initialize the GLSL compiler.
    # https://bugs.freedesktop.org/show_bug.cgi?id=35603
    ("Mesa", "Mesa 7.9", False, True),
    ("Mesa", "Mesa 7.10.3", True, True),
    ("Mesa", "Mesa 7.10", False, True),

    # Default to allowing everything.
    ("", "", True, True),
    ]

########NEW FILE########
__FILENAME__ = lint
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import renpy.text
import codecs
import time
import re
import sys
import collections
import textwrap

image_prefixes = None

# Things to check in lint.
#
# Image files exist, and are of the right case.
# Jump/Call targets defined.
# Say whos can evaluate.
# Call followed by say.
# Show/Scene valid.
# At valid.
# With valid.
# Hide maybe valid.
# Expressions can compile.

# The node the report will be about:
report_node = None

# Reports a message to the user.
def report(msg, *args):
    if report_node:
        out = u"%s:%d " % (renpy.parser.unicode_filename(report_node.filename), report_node.linenumber)
    else:
        out = ""

    out += msg % args
    print
    print out.encode('utf-8')

added = { }

# Reports additional information about a message, the first time it
# occurs.
def add(msg):
    if not msg in added:
        added[msg] = True
        print unicode(msg).encode('utf-8')


# Trys to evaluate an expression, announcing an error if it fails.
def try_eval(where, expr, additional=None):

    # Make sure the expression compiles.
    try_compile(where, expr)

    # Simply look up the first component of the python expression, and
    # see if it exists in the store.
    m = re.match(r'\s*([a-zA-Z_]\w*)', expr)

    if not m:
        return

    if hasattr(renpy.store, m.group(1)):
        return

    if m.group(1) in __builtins__:
        return

    report( "Could not evaluate '%s', in %s.", expr, where)
    if additional:
        add(additional)

# Returns True of the expression can be compiled as python, False
# otherwise.
def try_compile(where, expr, additional=None):

    try:
        renpy.python.py_compile_eval_bytecode(expr)
    except:
        report("'%s' could not be compiled as a python expression, %s.", expr, where)
        if additional:
            add(additional)


# The sets of names + attributes that
imprecise_cache = set()

def image_exists_imprecise(name):
    if name in imprecise_cache:
        return True

    nametag = name[0]

    required = set()
    banned = set()

    for i in name[1:]:
        if i[0] == "-":
            banned.add(i[1:])
        else:
            required.add(i)

    for im in renpy.display.image.images:

        if im[0] != nametag:
            continue

        attrs = set(im[1:])

        if [ i for i in required if i not in attrs ]:
            continue

        if [ i for i in banned if i in attrs ]:
            continue

        imprecise_cache.add(name)
        return True

    return False



# This reports an error if we're sure that the image with the given name
# does not exist.
def image_exists(name, expression, tag, precise=True):
    """
    Checks a scene or show statement for image existence.
    """


    # Add the tag to the set of known tags.
    tag = tag or name[0]
    image_prefixes[tag] = True

    if expression:
        return

    namelist = list(name)
    names = " ".join(namelist)

    # Look for the precise name.
    while namelist:
        if tuple(namelist) in renpy.display.image.images:
            return

        namelist.pop()

    # If we're not precise, then we have to start looking for images
    # that we can possibly match.
    if not precise and image_exists_imprecise(name):
        return

    report("The image named '%s' was not declared.", names)




# Only check each file once.
check_file_cache = { }

def check_file(what, fn):

    present = check_file_cache.get(fn, None)
    if present is True:
        return
    if present is False:
        report("%s uses file '%s', which is not loadable.", what.capitalize(), fn)
        return

    if not renpy.loader.loadable(fn):
        report("%s uses file '%s', which is not loadable.", what.capitalize(), fn)
        check_file_cache[fn] = False
        return

    check_file_cache[fn] = True


def check_displayable(what, d):

    def predict_image(img):
        files.extend(img.predict_files())

    renpy.display.predict.image = predict_image

    files = [ ]

    if isinstance(d, renpy.display.core.Displayable):
        d.visit_all(lambda a : a.predict_one())

    for fn in files:
        check_file(what, fn)


# Lints ast.Image nodes.
def check_image(node):

    name = " ".join(node.imgname)

    check_displayable('image %s' % name, renpy.display.image.images[node.imgname])

def imspec(t):
    if len(t) == 3:
        return t[0], None, None, t[1], t[2], 0
    if len(t) == 6:
        return t[0], t[1], t[2], t[3], t[4], t[5], None
    else:
        return t


# Lints ast.Show and ast.Scene nodets.
def check_show(node, precise):

    # A Scene may have an empty imspec.
    if not node.imspec:
        return

    name, expression, tag, at_list, layer, _zorder, _behind = imspec(node.imspec)

    if layer not in renpy.config.layers and layer not in renpy.config.top_layers:
        report("Uses layer '%s', which is not in config.layers.", layer)

    image_exists(name, expression, tag, precise=precise)

    for i in at_list:
        try_eval("the at list of a scene or show statment", i, "Perhaps you forgot to declare, or misspelled, a position?")


# Lints ast.Hide.

def check_hide(node):

    name, _expression, tag, _at_list, layer, _zorder, _behind = imspec(node.imspec)

    tag = tag or name[0]

    if layer not in renpy.config.layers and layer not in renpy.config.top_layers:
        report("Uses layer '%s', which is not in config.layers.", layer)

    if tag not in image_prefixes:
        report("The image tag '%s' is not the prefix of a declared image, nor was it used in a show statement before this hide statement.", tag)

    # for i in at_list:
    #    try_eval(node, "at list of hide statment", i)

def check_with(node):
    try_eval("a with statement or clause", node.expr, "Perhaps you forgot to declare, or misspelled, a transition?")

def check_user(node):

    def error(msg):
        report("%s", msg)

    renpy.exports.push_error_handler(error)
    try:
        node.call("lint")
    finally:
        renpy.exports.pop_error_handler()

    try:
        node.get_next()
    except:
        report("Didn't properly report what the next statement should be.")

def text_checks(s):
    msg = renpy.text.extras.check_text_tags(s)
    if msg:
        report("%s (in %s)", msg, repr(s)[1:])

    if "%" in s:

        state = 0
        pos = 0
        fmt = ""
        while pos < len(s):
            c = s[pos]
            pos += 1

            # Not in a format.
            if state == 0:
                if c == "%":
                    state = 1
                    fmt = "%"

            # In a format.
            elif state == 1:
                fmt += c
                if c == "(":
                    state = 2
                elif c in "#0123456780- +hlL":
                    state = 1
                elif c in "diouxXeEfFgGcrs%":
                    state = 0
                else:
                    report("Unknown string format code '%s' (in %s)", fmt, repr(s)[1:])
                    state = 0

            # In a mapping key.
            elif state == 2:
                fmt += c
                if c == ")":
                    state = 1

        if state != 0:
            report("Unterminated string format code '%s' (in %s)", fmt, repr(s)[1:])

def check_say(node):

    if node.who:
        try_eval("the who part of a say statement", node.who, "Perhaps you forgot to declare a character?")

    if node.with_:
        try_eval("the with clause of a say statement", node.with_, "Perhaps you forgot to declare, or misspelled, a transition?")

    text_checks(node.what)

    if not node.who_fast:
        return

    # Code to check image attributes. (If we're lucky.)
    if node.who is None:
        return

    char = getattr(renpy.store, node.who, None)

    if not isinstance(char, renpy.character.ADVCharacter):
        return

    if node.attributes is None:
        return

    if char.image_tag is None:
        return

    name = (char.image_tag,) + node.attributes

    if not image_exists_imprecise(name):
        report("Could not find image (%s) corresponding to attributes on say statement.", " ".join(name))



def check_menu(node):

    if node.with_:
        try_eval("the with clause of a menu statement", node.with_, "Perhaps you forgot to declare, or misspelled, a transition?")

    if not [ (l, c, b) for l, c, b in node.items if b ]:
        report("The menu does not contain any selectable choices.")

    for l, c, b in node.items:
        if c:
            try_compile("in the if clause of a menuitem", c)

        text_checks(l)

def check_jump(node):

    if node.expression:
        return

    if not renpy.game.script.has_label(node.target):
        report("The jump is to nonexistent label '%s'.", node.target)

def check_call(node):

    if node.expression:
        return

    if not renpy.game.script.has_label(node.label):
        report("The call is to nonexistent label '%s'.", node.label)

def check_while(node):
    try_compile("in the condition of the while statement", node.condition)

def check_if(node):

    for condition, _block in node.entries:
        try_compile("in a condition of the if statement", condition)

def check_style(name, s):

    for p in s.properties:
        for k, v in p.iteritems():

            kname = name + ", property " + k

            # Treat font specially.
            if k.endswith("font"):
                check_file(name, v)

            if isinstance(v, renpy.display.core.Displayable):
                check_displayable(kname, v)

def check_label(node):

    def add_arg(n):
        if n is None:
            return

        if not hasattr(renpy.store, n):
            setattr(renpy.store, n, None)

    pi = node.parameters

    if pi is not None:

        for i in pi.positional:
            add_arg(i)
        add_arg(pi.extrapos)
        add_arg(pi.extrakw)


def check_styles():
    for name, s in renpy.style.styles.iteritems(): # @UndefinedVariable
        name = "style." + name[0]
        for i in name[1:]:
            name += "[{!r}]".format(i)

        check_style("Style " + name, s)

def humanize(n):
    s = str(n)

    rv = []

    for i, c in enumerate(reversed(s)):
        if i and not (i % 3):
            rv.insert(0, ',')

        rv.insert(0, c)

    return ''.join(rv)

def check_filename_encodings():
    """
    Checks files to ensure that they are displayable in unicode.
    """

    for _dirname, filename in renpy.loader.listdirfiles():
        try:
            filename.encode("ascii")
            continue
        except:
            pass

        report("%s contains non-ASCII characters in its filename.", filename)
        add("(ZIP file distributions can only reliably include ASCII filenames.)")

class Count(object):
    """
    Stores information about the word count.
    """

    def __init__(self):
        # The number of blocks of text.
        self.blocks = 0

        # The number of whitespace-separated words.
        self.words = 0

        # The number of characters.
        self.characters = 0

    def add(self, s):
        self.blocks += 1
        self.words += len(s.split())
        self.characters += len(s)

def common(n):
    """
    Returns true if the node is in the common directory.
    """

    filename = n.filename.replace("\\", "/")

    if filename.startswith("common/") or filename.startswith("renpy/common/"):
        return True
    else:
        return False

def lint():
    """
    The master lint function, that's responsible for staging all of the
    other checks.
    """

    ap = renpy.arguments.ArgumentParser(description="Checks the script for errors and prints script statistics.", require_command=False)
    ap.add_argument("filename", nargs='?', action="store", help="The file to write to.")

    args = ap.parse_args()

    if args.filename:
        f = open(args.filename, "w")
        sys.stdout = f

    renpy.game.lint = True

    print codecs.BOM_UTF8
    print unicode(renpy.version + " lint report, generated at: " + time.ctime()).encode("utf-8")

    # This supports check_hide.
    global image_prefixes
    image_prefixes = { }

    for k in renpy.display.image.images:
        image_prefixes[k[0]] = True

    # Iterate through every statement in the program, processing
    # them. We sort them in filename, linenumber order.

    all_stmts = [ (i.filename, i.linenumber, i) for i in renpy.game.script.all_stmts ]
    all_stmts.sort()

    # The current count.
    counts = collections.defaultdict(Count)

    # The current language.
    language = None

    menu_count = 0
    screen_count = 0
    image_count = 0

    global report_node

    for _fn, _ln, node in all_stmts:

        if common(node):
            continue

        report_node = node

        if isinstance(node, renpy.ast.Image):
            image_count += 1
            check_image(node)

        elif isinstance(node, renpy.ast.Show):
            check_show(node, True)

        elif isinstance(node, renpy.ast.Scene):
            check_show(node, False)

        elif isinstance(node, renpy.ast.Hide):
            check_hide(node)

        elif isinstance(node, renpy.ast.With):
            check_with(node)

        elif isinstance(node, renpy.ast.Say):
            check_say(node)

            counts[language].add(node.what)


        elif isinstance(node, renpy.ast.Menu):
            check_menu(node)
            menu_count += 1

        elif isinstance(node, renpy.ast.Jump):
            check_jump(node)

        elif isinstance(node, renpy.ast.Call):
            check_call(node)

        elif isinstance(node, renpy.ast.While):
            check_while(node)

        elif isinstance(node, renpy.ast.If):
            check_if(node)

        elif isinstance(node, renpy.ast.UserStatement):
            check_user(node)

        elif isinstance(node, renpy.ast.Label):
            check_label(node)

        elif isinstance(node, renpy.ast.Translate):
            language = node.language

        elif isinstance(node, renpy.ast.EndTranslate):
            language = None

        elif isinstance(node, renpy.ast.Screen):
            screen_count += 1

    report_node = None

    check_styles()
    check_filename_encodings()

    for f in renpy.config.lint_hooks:
        f()


    lines = [ ]

    def report_language(language):

        count = counts[language]

        if count.blocks <= 0:
            return

        if language is None:
            s = "The game"
        else:
            s = "The {0} translation".format(language)

        s += """ contains {0} dialogue blocks, containing {1} words
and {2} characters, for an average of {3:.1f} words and {4:.0f}
characters per block. """.format(
            humanize(count.blocks),
            humanize(count.words),
            humanize(count.characters),
            1.0 * count.words / count.blocks,
            1.0 * count.characters / count.blocks)

        lines.append(s)


    print
    print
    print "Statistics:"
    print

    languages = list(counts)
    languages.sort()
    for i in languages:
        report_language(i)

    lines.append("The game contains {0} menus, {1} images, and {2} screens.".format(
        humanize(menu_count), humanize(image_count), humanize(screen_count)))

    for l in lines:
        for ll in textwrap.wrap(l, 78):
            print ll.encode("utf-8")

        print

    print
    if renpy.config.developer:
        print "Remember to set config.developer to False before releasing."
        print

    print "Lint is not a substitute for thorough testing. Remember to update Ren'Py"
    print "before releasing. New releases fix bugs and improve compatibility."

    return False


########NEW FILE########
__FILENAME__ = loader
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy
import os.path
from pickle import loads
from cStringIO import StringIO
import sys
import types
import threading

# Ensure the utf-8 codec is loaded, to prevent recursion when we use it
# to look up filenames.
u"".encode("utf-8")

################################################################## Asset Loading

try:
    import android.apk

    expansion = os.environ.get("ANDROID_EXPANSION", None)
    if expansion is not None:
        print "Using expansion file", expansion

        apks = [
            android.apk.APK(apk=expansion, prefix='assets/x-game/'),
            android.apk.APK(apk=expansion, prefix='assets/x-renpy/x-common/'),
            ]

        game_apks = [ apks[0] ]

    else:
        print "Not using expansion file."

        apks = [
            android.apk.APK(prefix='assets/x-game/'),
            android.apk.APK(prefix='assets/x-renpy/x-common/'),
            ]

        game_apks = [ apks[0] ]

except ImportError:
    apks = [ ]
    game_apks = [ ]

# Files on disk should be checked before archives. Otherwise, among
# other things, using a new version of bytecode.rpyb will break.
archives = [ ]

# The value of renpy.config.archives the last time index_archives was
# run.
old_config_archives = None

# A map from lower-case filename to regular-case filename.
lower_map = { }

def index_archives():
    """
    Loads in the indexes for the archive files. Also updates the lower_map.
    """

    # Update lower_map.
    lower_map.clear()

    for dir, fn in listdirfiles(): #@ReservedAssignment
        lower_map[fn.lower()] = fn

    # Index the archives.

    global old_config_archives

    if old_config_archives == renpy.config.archives:
        return

    old_config_archives = renpy.config.archives[:]

    global archives
    archives = [ ]

    for prefix in renpy.config.archives:

        try:
            fn = transfn(prefix + ".rpa")
            f = file(fn, "rb")
            l = f.readline()

            # 3.0 Branch.
            if l.startswith("RPA-3.0 "):
                offset = int(l[8:24], 16)
                key = int(l[25:33], 16)
                f.seek(offset)
                index = loads(f.read().decode("zlib"))

                # Deobfuscate the index.

                for k in index.keys():

                    if len(index[k][0]) == 2:
                        index[k] = [ (offset ^ key, dlen ^ key) for offset, dlen in index[k] ]
                    else:
                        index[k] = [ (offset ^ key, dlen ^ key, start) for offset, dlen, start in index[k] ]

                archives.append((prefix, index))

                f.close()
                continue

            # 2.0 Branch.
            if l.startswith("RPA-2.0 "):
                offset = int(l[8:], 16)
                f.seek(offset)
                index = loads(f.read().decode("zlib"))
                archives.append((prefix, index))
                f.close()
                continue

            # 1.0 Branch.
            f.close()

            fn = transfn(prefix + ".rpi")
            index = loads(file(fn, "rb").read().decode("zlib"))
            archives.append((prefix, index))
        except:
            raise

def walkdir(dir): #@ReservedAssignment
    rv = [ ]

    if not os.path.exists(dir) and not renpy.config.developer:
        return rv

    for i in os.listdir(dir):
        if i[0] == ".":
            continue

        if os.path.isdir(dir + "/" + i):
            for fn in walkdir(dir + "/" + i):
                rv.append(i + "/" + fn)
        else:
            rv.append(i)

    return rv


def listdirfiles(common=True):
    """
    Returns a list of directory, file tuples known to the system. If
    the file is in an archive, the directory is None.
    """

    rv = [ ]

    seen = set()

    if common:
        list_apks = apks
    else:
        list_apks = game_apks

    for apk in list_apks:

        for f in apk.list():

            # Strip off the "x-" in front of each filename, which is there
            # to ensure that aapt actually includes every file.
            f = "/".join(i[2:] for i in f.split("/"))

            if f not in seen:
                rv.append((None, f))
                seen.add(f)

    for i in renpy.config.searchpath:

        if (not common) and (renpy.config.commondir) and (i == renpy.config.commondir):
            continue

        i = os.path.join(renpy.config.basedir, i)
        for j in walkdir(i):
            if j not in seen:
                rv.append((i, j))
                seen.add(j)

    for _prefix, index in archives:
        for j in index.iterkeys():
            if j not in seen:
                rv.append((None, j))
                seen.add(j)


    return rv


class SubFile(object):

    def __init__(self, f, base, length, start):
        self.f = f
        self.base = base
        self.offset = 0
        self.length = length
        self.start = start

        if start is None:
            self.name = self.f.name
        else:
            self.name = None

        self.f.seek(self.base)

    def read(self, length=None):

        maxlength = self.length - self.offset

        if length is not None:
            length = min(length, maxlength)
        else:
            length = maxlength

        rv1 = self.start[self.offset:self.offset + length]
        length -= len(rv1)
        self.offset += len(rv1)

        if length:
            rv2 = self.f.read(length)
            self.offset += len(rv2)
        else:
            rv2 = ""

        return (rv1 + rv2)

    def readline(self, length=None):

        maxlength = self.length - self.offset
        if length is not None:
            length = min(length, maxlength)
        else:
            length = maxlength

        # If we're in the start, then read the line ourselves.
        if self.offset < len(self.start):
            rv = ''

            while length:
                c = self.read(1)
                rv += c
                if c == '\n':
                    break
                length -= 1

            return rv

        # Otherwise, let the system read the line all at once.
        rv = self.f.readline(length)

        self.offset += len(rv)

        return rv

    def readlines(self, length=None):
        rv = [ ]

        while True:
            l = self.readline(length)

            if not l:
                break

            if length is not None:
                length -= len(l)
                if l < 0:
                    break

            rv.append(l)

        return rv

    def xreadlines(self):
        return self

    def __iter__(self):
        return self

    def next(self): #@ReservedAssignment
        rv = self.readline()

        if not rv:
            raise StopIteration()

        return rv

    def flush(self):
        return


    def seek(self, offset, whence=0):

        if whence == 0:
            offset = offset
        elif whence == 1:
            offset = self.offset + offset
        elif whence == 2:
            offset = self.length + offset

        if offset > self.length:
            offset = self.length

        self.offset = offset

        offset = offset - len(self.start)
        if offset < 0:
            offset = 0

        self.f.seek(offset + self.base)

    def tell(self):
        return self.offset

    def close(self):
        self.f.close()

    def write(self, s):
        raise Exception("Write not supported by SubFile")


def load_core(name):
    """
    Returns an open python file object of the given type.
    """

    name = lower_map.get(name.lower(), name)

    if renpy.config.file_open_callback:
        rv = renpy.config.file_open_callback(name)
        if rv is not None:
            return rv

    # Look for the file in the apk.
    for apk in apks:
        prefixed_name = "/".join("x-" + i for i in name.split("/"))

        try:
            return apk.open(prefixed_name)
        except IOError:
            pass

    # Look for the file directly.
    if not renpy.config.force_archives:
        try:
            fn = transfn(name)
            return file(fn, "rb")
        except:
            pass

    # Look for it in archive files.
    for prefix, index in archives:
        if not name in index:
            continue

        f = file(transfn(prefix + ".rpa"), "rb")

        data = [ ]

        # Direct path.
        if len(index[name]) == 1:

            t = index[name][0]
            if len(t) == 2:
                offset, dlen = t
                start = ''
            else:
                offset, dlen, start = t

            rv = SubFile(f, offset, dlen, start)

        # Compatibility path.
        else:
            for offset, dlen in index[name]:
                f.seek(offset)
                data.append(f.read(dlen))

            rv = StringIO(''.join(data))
            f.close()

        return rv

    return None

def get_prefixes():
    """
    Returns a list of prefixes to search for files.
    """

    rv = [ ]

    language = renpy.game.preferences.language

    if language is not None:
        rv.append(renpy.config.tl_directory + "/" + language + "/")

    rv.append("")

    return rv

def load(name):

    if renpy.config.reject_backslash and "\\" in name:
        raise Exception("Backslash in filename, use '/' instead: %r" % name)

    for p in get_prefixes():
        rv = load_core(p + name)
        if rv is not None:
            return rv

    raise IOError("Couldn't find file '%s'." % name)


loadable_cache = { }

def loadable_core(name):
    """
    Returns True if the name is loadable with load, False if it is not.
    """

    name = lower_map.get(name.lower(), name)

    if name in loadable_cache:
        return loadable_cache[name]

    for apk in apks:
        prefixed_name = "/".join("x-" + i for i in name.split("/"))
        if prefixed_name in apk.info:
            return True

    try:
        transfn(name)
        loadable_cache[name] = True
        return True
    except:
        pass

    for _prefix, index in archives:
        if name in index:
            loadable_cache[name] = True
            return True

    loadable_cache[name] = False
    return False

def loadable(name):

    for p in get_prefixes():
        if loadable_core(p + name):
            return True

    return False


def transfn(name):
    """
    Tries to translate the name to a file that exists in one of the
    searched directories.
    """

    name = lower_map.get(name.lower(), name)

    if renpy.config.reject_backslash and "\\" in name:
        raise Exception("Backslash in filename, use '/' instead: %r" % name)

    if isinstance(name, str):
        name = name.decode("utf-8")

    for d in renpy.config.searchpath:
        fn = os.path.join(renpy.config.basedir, d, name)

        add_auto(fn)

        if os.path.exists(fn):
            return fn

    raise Exception("Couldn't find file '%s'." % name)


def get_mtime(name):
    """
    Returns the time the file m was last modified, or 0 if it
    doesn't exist or is archived.
    """

    for p in get_prefixes():
        try:
            fn = transfn(p + name)
            return os.path.getmtime(fn)
        except:
            pass

    return 0

################################################################# Module Loading

class RenpyImporter(object):
    """
    An importer, that tries to load modules from the places where Ren'Py
    searches for data files.
    """

    def __init__(self, prefix=""):
        self.prefix = ""

    def translate(self, fullname, prefix=""):

        try:
            fn = (prefix + fullname.replace(".", "/")).decode("utf8")
        except:
            # raise Exception("Could importer-translate %r + %r" % (prefix, fullname))
            return None

        if loadable(fn + ".py"):
            return fn + ".py"

        if loadable(fn + "/__init__.py"):
            return fn + "/__init__.py"

        return None

    def find_module(self, fullname, path=None):
        if path is not None:
            for i in path:
                if self.translate(fullname, i):
                    return RenpyImporter(i)

        if self.translate(fullname):
            return self

    def load_module(self, fullname):

        filename = self.translate(fullname, self.prefix)

        mod = sys.modules.setdefault(fullname, types.ModuleType(fullname))
        mod.__name__ = fullname
        mod.__file__ = filename
        mod.__loader__ = self

        if filename.endswith("__init__.py"):
            mod.__path__ = [ filename[:-len("__init__.py")] ]

        source = load(filename).read().decode("utf8")
        if source and source[0] == u'\ufeff':
            source = source[1:]
        source = source.encode("raw_unicode_escape")

        source = source.replace("\r", "")
        code = compile(source, filename, 'exec')
        exec code in mod.__dict__
        return mod

    def get_data(self, filename):
        return load(filename).read()

def init_importer():
    sys.meta_path.append(RenpyImporter())

def quit_importer():
    sys.meta_path.pop()

#################################################################### Auto-Reload

# This is set to True if autoreload hads detected an autoreload is needed.
needs_autoreload = False

# A map from filename to mtime, or None if the file doesn't exist.
auto_mtimes = { }

# The thread used for autoreload.
auto_thread = None

# True if auto_thread should run. False if it should quit.
auto_quit_flag = True

# The lock used by auto_thread.
auto_lock = threading.Condition()

# Used to indicate that this file is blacklisted.
auto_blacklisted = renpy.object.Sentinel("auto_blacklisted")

def auto_mtime(fn):
    """
    Gets the mtime of fn, or None if the file does not exist.
    """

    try:
        return os.path.getmtime(fn)
    except:
        return None

def add_auto(fn):
    """
    Adds fn as a file we watch for changes. If it's mtime changes or the file
    starts/stops existing, we trigger a reload.
    """

    if not renpy.autoreload:
        return

    if fn in auto_mtimes:
        return

    for e in renpy.config.autoreload_blacklist:
        if fn.endswith(e):
            with auto_lock:
                auto_mtimes[fn] = auto_blacklisted
            return

    mtime = auto_mtime(fn)

    with auto_lock:
        auto_mtimes[fn] = mtime

def auto_thread_function():
    """
    This thread sets need_autoreload when necessary.
    """

    global needs_autoreload

    while True:

        with auto_lock:

            auto_lock.wait(1.5)

            if auto_quit_flag:
                return

            items = auto_mtimes.items()

        for fn, mtime in items:

            if mtime is auto_blacklisted:
                continue

            if auto_mtime(fn) != mtime:
                needs_autoreload = True

def auto_init():
    """
    Starts the autoreload thread.
    """

    global auto_thread
    global auto_quit_flag
    global needs_autoreload

    needs_autoreload = False

    if not renpy.autoreload:
        return

    auto_quit_flag = False

    auto_thread = threading.Thread(target=auto_thread_function)
    auto_thread.daemon = True
    auto_thread.start()

def auto_quit():
    """
    Terminates the autoreload thread.
    """
    global auto_quit_flag

    if auto_thread is None:
        return

    auto_quit_flag = True

    with auto_lock:
        auto_lock.notify_all()

    auto_thread.join()

########NEW FILE########
__FILENAME__ = loadsave
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains functions that load and save the game state.

import pickle
import cPickle

from cStringIO import StringIO

import zipfile
import re
import threading
import types
import shutil
import os

import renpy

from json import dumps as json_dumps

# Dump that chooses which pickle to use:
def dump(o, f):
    if renpy.config.use_cpickle:
        cPickle.dump(o, f, cPickle.HIGHEST_PROTOCOL)
    else:
        pickle.dump(o, f, pickle.HIGHEST_PROTOCOL)

def loads(s):
    if renpy.config.use_cpickle:
        return cPickle.loads(s)
    else:
        return pickle.loads(s)

# This is used as a quick and dirty way of versioning savegame
# files.
savegame_suffix = renpy.savegame_suffix

def save_dump(roots, log):
    """
    Dumps information about the save to save_dump.txt. We dump the size
    of the object (including unique children), the path to the object,
    and the type or repr of the object.
    """

    o_repr_cache = { }


    def visit(o, path):
        ido = id(o)

        if ido in o_repr_cache:
            f.write("{0: 7d} {1} = alias {2}\n".format(0, path, o_repr_cache[ido]))
            return 0

        if isinstance(o, (int, float, types.NoneType, types.ModuleType, types.ClassType)):
            o_repr = repr(o)

        elif isinstance(o, (str, unicode)):
            if len(o) <= 80:
                o_repr = repr(o).encode("utf-8")
            else:
                o_repr = repr(o[:80] + "...").encode("utf-8")

        elif isinstance(o, (tuple, list)):
            o_repr = "<" + o.__class__.__name__ + ">"

        elif isinstance(o, dict):
            o_repr = "<" + o.__class__.__name__ + ">"

        elif isinstance(o, types.MethodType):
            o_repr = "<method {0}.{1}>".format(o.im_class.__name__, o.im_func.__name__)

        elif isinstance(o, object):
            o_repr = "<{0}>".format(type(o).__name__)

        else:
            o_repr = "BAD TYPE <{0}>".format(type(o).__name__)


        o_repr_cache[ido] = o_repr

        if isinstance(o, (int, float, types.NoneType, types.ModuleType, types.ClassType)):
            size = 1

        elif isinstance(o, (str, unicode)):
            size = len(o) / 40 + 1

        elif isinstance(o, (tuple, list)):
            size = 1
            for i, oo in enumerate(o):
                size += 1
                size += visit(oo, "{0}[{1!r}]".format(path, i))

        elif isinstance(o, dict):
            size = 2
            for k, v in o.iteritems():
                size += 2
                size += visit(v, "{0}[{1!r}]".format(path, k))

        elif isinstance(o, types.MethodType):
            size = 1 + visit(o.im_self, path + ".im_self")

        else:

            try:
                reduction = o.__reduce_ex__(2)
            except:
                reduction = [ ]
                o_repr = "BAD REDUCTION " + o_repr

            # Gets an element from the reduction, or o if we don't have
            # such an element.
            def get(idx, default):
                if idx < len(reduction) and reduction[idx] is not None:
                    return reduction[idx]
                else:
                    return default

            # An estimate of the size of the object, in arbitrary units. (These units are about 20-25 bytes on
            # my computer.)
            size = 1

            state = get(2, { })
            if isinstance(state, dict):
                for k, v in state.iteritems():
                    size += 2
                    size += visit(v, path + "." + k)
            else:
                size += visit(state, path + ".__getstate__()")

            for i, oo in enumerate(get(3, [])):
                size += 1
                size += visit(oo, "{0}[{1}]".format(path, i))

            for i in get(4, []):

                if len(i) != 2:
                    continue

                k, v = i

                size += 2
                size += visit(v, "{0}[{1!r}]".format(path, k))


        f.write("{0: 7d} {1} = {2}\n".format(size, path, o_repr_cache[ido]))

        return size

    f = file("save_dump.txt", "w")

    visit(roots, "roots")
    visit(log, "log")

    f.close()

################################################################################
# Saving
################################################################################

# Used to indicate an aborted save, due to the game being mutated
# while the save is in progress.
class SaveAbort(Exception):
    pass

def safe_rename(old, new):
    """
    Safely rename old to new.
    """

    if os.path.exists(new):
        os.unlink(new)

    os.rename(old, new)

class SaveRecord(object):
    """
    This is passed to the save locations. It contains the information that
    goes into a save file in uncompressed form, and the logic to save that
    information to a Ren'Py-standard format save file.
    """

    def __init__(self, screenshot, extra_info, json, log):
        self.screenshot = screenshot
        self.extra_info = extra_info
        self.json = json
        self.log = log

        self.first_filename = None

    def write_file(self, filename):
        """
        This writes a standard-format savefile to `filename`.
        """

        filename_new = filename + ".new"

        # For speed, copy the file after we've written it at least once.
        if self.first_filename is not None:
            shutil.copy(self.first_filename, filename_new)
            safe_rename(filename_new, filename)
            return

        zf = zipfile.ZipFile(filename_new, "w", zipfile.ZIP_DEFLATED)

        # Screenshot.
        zf.writestr("screenshot.png", self.screenshot)

        # Extra info.
        zf.writestr("extra_info", self.extra_info.encode("utf-8"))

        # Json
        zf.writestr("json", self.json)

        # Version.
        zf.writestr("renpy_version", renpy.version)

        # The actual game.
        zf.writestr("log", self.log)

        zf.close()

        safe_rename(filename_new, filename)

        self.first_filename = filename



def save(slotname, extra_info='', mutate_flag=False):
    """
    :doc: loadsave
    :args: (filename, extra_info='')

    Saves the game state to a save slot.

    `filename`
        A string giving the name of a save slot. Despite the variable name,
        this corresponds only loosely to filenames.

    `extra_info`
        An additional string that should be saved to the save file. Usually,
        this is the value of :var:`save_name`.

    :func:`renpy.take_screenshot` should be called before this function.
    """

    if mutate_flag:
        renpy.python.mutate_flag = False

    roots = renpy.game.log.freeze(None)

    logf = StringIO()
    dump((roots, renpy.game.log), logf)

    if mutate_flag and renpy.python.mutate_flag:
        raise SaveAbort()

    if renpy.config.save_dump:
        save_dump(roots, renpy.game.log)

    screenshot = renpy.game.interface.get_screenshot()

    json = { "_save_name" : extra_info }

    for i in renpy.config.save_json_callbacks:
        i(json)

    json = json_dumps(json)

    sr = SaveRecord(screenshot, extra_info, json, logf.getvalue())
    location.save(slotname, sr)

    location.scan()
    clear_slot(slotname)



# Flag that lets us know if an autosave is in progress.
autosave_not_running = threading.Event()
autosave_not_running.set()

# The number of times autosave has been called without a save occuring.
autosave_counter = 0

def autosave_thread(take_screenshot):

    global autosave_counter

    try:

        try:

            cycle_saves("auto-", renpy.config.autosave_slots)

            if renpy.config.auto_save_extra_info:
                extra_info = renpy.config.auto_save_extra_info()
            else:
                extra_info = ""

            if take_screenshot:
                renpy.exports.take_screenshot(background=True)

            save("auto-1", mutate_flag=True, extra_info=extra_info)
            autosave_counter = 0

        except:
            pass

    finally:
        autosave_not_running.set()



def autosave():
    global autosave_counter

    if not renpy.config.autosave_frequency:
        return

    # That is, autosave is running.
    if not autosave_not_running.isSet():
        return

    if renpy.config.skipping:
        return

    if len(renpy.game.contexts) > 1:
        return

    autosave_counter += 1

    if autosave_counter < renpy.config.autosave_frequency:
        return

    if renpy.store.main_menu:
        return

    force_autosave(True)


# This assumes a screenshot has already been taken.
def force_autosave(take_screenshot=False):

    # That is, autosave is running.
    if not autosave_not_running.isSet():
        return

    # Do not save if we're in the main menu.
    if renpy.store.main_menu:
        return

    # Do not save if we're in a replay.
    if renpy.store._in_replay:
        return

    autosave_not_running.clear()
    t = threading.Thread(target=autosave_thread, args=(take_screenshot,))
    t.daemon = True
    t.start()


################################################################################
# Loading and Slot Manipulation
################################################################################

def scan_saved_game(slotname):

    c = get_cache(slotname)

    mtime = c.get_mtime()

    if mtime is None:
        return None

    json = c.get_json()
    if json is None:
        return None

    extra_info = json.get("_save_name", "")

    screenshot = c.get_screenshot()

    if screenshot is None:
        return None

    return extra_info, screenshot, mtime


def list_saved_games(regexp=r'.', fast=False):
    """
    :doc: loadsave

    Lists the save games. For each save game, returns a tuple containing:

    * The filename of the save.
    * The extra_info that was passed in.
    * A displayable that, when displayed, shows the screenshot that was
      used when saving the game.
    * The time the game was stayed at, in seconds since the UNIX epoch.

    `regexp`
        A regular expression that is matched against the start of the
        filename to filter the list.

    `fast`
        If fast is true, the filename is returned instead of the
        tuple.
    """

    # A list of save slots.
    slots = location.list()

    if regexp is not None:
        slots = [ i for i in slots if re.match(regexp, i) ]

    slots.sort()

    if fast:
        return slots

    rv = [ ]

    for s in slots:

        c = get_cache(s)

        extra_info = c.get_json().get("_save_name", "")
        screenshot = c.get_screenshot()
        mtime = c.get_mtime()

        rv.append((s, extra_info, screenshot, mtime))

    return rv


def list_slots(regexp=None):
    """
    :doc: loadsave

    Returns a list of non-empty save slots. If `regexp` exists, only slots
    that begin with `regexp` are returned. The slots are sorted in
    string-order.
    """

    # A list of save slots.
    slots = location.list()

    if regexp is not None:
        slots = [ i for i in slots if re.match(regexp, i) ]

    slots.sort()

    return slots

# A cache for newest slot info.
newest_slot_cache = { }

def newest_slot(regexp=None):
    """
    :doc: loadsave

    Returns the name of the newest save slot (the save slot with the most
    recent modification time), or None if there are no (matching) saves.

    If `regexp` exists, only slots that begin with `regexp` are returned.
    """

    rv = newest_slot_cache.get(regexp, unknown)
    if rv is unknown:

        max_mtime = 0
        rv = None

        slots = location.list()

        for i in slots:

            if (regexp is not None) and (not re.match(regexp, i)):
                continue

            mtime = get_cache(i).get_mtime()
            if mtime is None:
                continue

            if mtime >= max_mtime:
                rv = i
                max_mtime = mtime

    newest_slot_cache[regexp] = rv
    return rv


def slot_mtime(slotname):
    """
    :doc: loadsave

    Returns the modification time for `slot`, or None if the slot is empty.
    """

    return get_cache(slotname).get_mtime()

def slot_json(slotname):
    """
    :doc: loadsave

    Returns the json information for `slotname`, or None if the slot is
    empty.
    """

    return get_cache(slotname).get_json()

def slot_screenshot(slotname):
    """
    :doc: loadsave

    Returns a display that can be used as the screenshot for `slotname`,
    or None if the slot is empty.
    """

    return get_cache(slotname).get_screenshot()

def can_load(filename, test=False):
    """
    :doc: loadsave

    Returns true if `filename` exists as a save slot, and False otherwise.
    """

    c = get_cache(filename)

    if c.get_mtime():
        return True
    else:
        return False

def load(filename):
    """
    :doc: loadsave

    Loads the game state from the save slot `filename`. If the file is loaded
    successfully, this function never returns.
    """

    roots, log = loads(location.load(filename))
    log.unfreeze(roots, label="_after_load")

def unlink_save(filename):
    """
    :doc: loadsave

    Deletes the save slot with the given name.
    """

    location.unlink(filename)
    clear_slot(filename)


def rename_save(old, new):
    """
    :doc: loadsave

    Renames a save from `old` to `new`. (Does nothing if `old` does not
    exist.)
    """

    location.rename(old, new)

    clear_slot(old)
    clear_slot(new)


def cycle_saves(name, count):
    """
    :doc: loadsave

    Rotates the first `count` saves beginning with `name`.

    For example, if the name is auto- and the count is 10, then
    auto-9 will be renamed to auto-10, auto-8 will be renamed to auto-9,
    and so on until auto-1 is renamed to auto-2.
    """

    for i in range(count - 1, 0, -1):
        rename_save(name + str(i), name + str(i + 1))

################################################################################
# Cache
################################################################################

# None is a possible value for some of the attributes.
unknown = renpy.object.Sentinel("unknown")

class Cache(object):
    """
    This represents cached information about a save slot.
    """

    def __init__(self, slotname):
        self.slotname = slotname
        self.clear()

    def clear(self):
        # The time the save was created.
        self.mtime = unknown

        # The json object loaded from the save slot.
        self.json = unknown

        # The screenshot associated with the save slot.
        self.screenshot = unknown

    def get_mtime(self):

        rv = self.mtime

        if rv is unknown:
            rv = self.mtime = location.mtime(self.slotname)

        return rv

    def get_json(self):

        rv = self.json

        if rv is unknown:
            rv = self.json = location.json(self.slotname)

        return rv

    def get_screenshot(self):

        rv = self.screenshot

        if rv is unknown:
            rv = self.screenshot = location.screenshot(self.slotname)

        return self.screenshot

# A map from slotname to cache object. This is used to cache savegame scan
# data until the slot changes.
cache = { }

def get_cache(slotname):

    rv = cache.get(slotname, None)

    if rv is None:
        rv = cache[slotname] = Cache(slotname)

    return rv


def clear_slot(slotname):
    """
    Clears a single slot in the cache.
    """

    get_cache(slotname).clear()

    newest_slot_cache.clear()

    renpy.exports.restart_interaction()

def clear_cache():
    """
    Clears the entire cache.
    """

    for c in cache.values():
        c.clear()

    newest_slot_cache.clear()

    renpy.exports.restart_interaction()


# Save locations are places where saves are saved to or loaded from, or a
# collection of such locations. This is the default save location.
location = None

if False:
    location = renpy.savelocation.FileLocation("blah")




########NEW FILE########
__FILENAME__ = log
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This module handles the logging of messages to a file.

import os.path
import codecs
import traceback
import platform
import time
import tempfile

import renpy

# The file events are logged to.
log_file = None

class LogFile(object):
    """
    This manages one of our logfiles.
    """

    def __init__(self, name, append=False, developer=False):
        """
        `name`
            The name of the logfile, without the .txt extension.
        `append`
            If true, we will append to the logfile. If false, we will truncate
            it to an empty file the first time we write to it.
        `developer`
            If true, nothing happens if config.developer is not set to True.
        """

        self.name = name
        self.append = append
        self.developer = developer
        self.file = None

        # File-like attributes.
        self.softspace = 0
        self.newlines = None

        # Should we emulate file's write method? We do so if this is True.
        self.raw_write = False

    def open(self): #@ReservedAssignment

        if self.file:
            return True

        if self.developer and not renpy.config.developer:
            return False

        if not renpy.config.log_enable:
            return False

        try:
            base = os.environ.get("RENPY_LOG_BASE", renpy.config.logdir)
            fn = os.path.join(base, self.name + ".txt")

            altfn = os.path.join(tempfile.gettempdir(), "renpy-" + self.name + ".txt")


            if renpy.android:
                print "Logging to", fn

            if self.append:
                mode = "a"
            else:
                mode = "w"

            try:
                self.file = codecs.open(fn, mode, "utf-8")
            except:
                self.file = codecs.open(altfn, mode, "utf-8")

            if self.append:
                self.write('')
                self.write('=' * 78)
                self.write('')

            self.write("%s", time.ctime())
            self.write("%s", platform.platform())
            self.write("%s", renpy.version)
            self.write("%s %s", renpy.config.name, renpy.config.version)
            self.write("")

            return True

        except:
            return False

    def write(self, s, *args):
        """
        Formats `s` with args, and writes it to the logfile.
        """

        if self.open():

            if not self.raw_write:
                s = s % args
                s += "\n"

            if not isinstance(s, unicode):
                s = s.decode("latin-1")

            s = s.replace("\n", "\r\n")

            self.file.write(s)
            self.file.flush()

    def exception(self):
        """
        Writes the exception to the logfile.
        """

        self.raw_write = True
        traceback.print_exc(None, self)
        self.raw_write = False

# A map from the log name to a log object.
log_cache = { }

def open(name, append=False, developer=False): #@ReservedAssignment
    rv = log_cache.get(name, None)

    if rv is None:
        rv = LogFile(name, append=append, developer=developer)
        log_cache[name] = rv

    return rv

########NEW FILE########
__FILENAME__ = main
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import renpy.style
import renpy.sl2
import renpy.game as game
import os
import sys
import time
import zipfile
import __main__


def run(restart):
    """
    This is called during a single run of the script. Restarting the script
    will cause this to change.
    """

    # Reset the store to a clean version of itself.
    renpy.python.clean_stores()

    # Re-Initialize the log.
    game.log = renpy.python.RollbackLog()

    # Switch contexts, begin logging.
    game.contexts = [ renpy.execution.Context(True) ]

    # Jump to an appropriate start label.
    if game.script.has_label("_start"):
        start_label = '_start'
    else:
        start_label = 'start'

    game.context().goto_label(start_label)

    # Perhaps warp.
    warp_label = renpy.warp.warp()

    if warp_label is not None:

        game.context().goto_label(warp_label)
        game.context().call('_after_warp')

        renpy.config.skipping = None

    try:
        renpy.exports.log("--- " + time.ctime())
        renpy.exports.log("")
    except:
        pass

    # Note if this is a restart.
    renpy.store._restart = restart

    # We run until we get an exception.
    renpy.display.interface.enter_context()
    renpy.execution.run_context(True)


def load_rpe(fn):

    zfn = zipfile.ZipFile(fn)
    autorun = zfn.read("autorun.py")
    zfn.close()

    sys.path.insert(0, fn)
    exec autorun in dict()

def choose_variants():

    if "RENPY_VARIANT" in os.environ:
        renpy.config.variants = list(os.environ["RENPY_VARIANT"].split()) + [ None ]
        return

    renpy.config.variants = [ None ]

    if renpy.android: #@UndefinedVariable

        renpy.config.variants.insert(0, 'android')

        import android #@UnresolvedImport
        import math
        import pygame

        from jnius import autoclass  # @UnresolvedImport


        # Manufacturer/Model-specific variants.
        try:
            Build = autoclass("android.os.Build")

            manufacturer = Build.MANUFACTURER
            model = Build.MODEL

            print "Manufacturer", manufacturer, "model", model

            if manufacturer == "Amazon" and model.startswith("AFT"):
                print "Running on a Fire TV."
                renpy.config.variants.insert(0, "firetv")
        except:
            pass

        # Are we running on an OUYA?
        try:
            OuyaFacade = autoclass("tv.ouya.console.api.OuyaFacade")
            of = OuyaFacade.getInstance()

            if of.isRunningOnOUYAHardware():
                print "Running on an OUYA."
                renpy.config.variants.insert(0, "ouya")
        except:
            pass


        # Are we running on OUYA or Google TV or something similar?
        PythonActivity = autoclass('org.renpy.android.PythonActivity')
        mActivity = PythonActivity.mActivity
        package_manager = mActivity.getPackageManager()

        if package_manager.hasSystemFeature("android.hardware.type.television"):
            print "Running on a television."
            renpy.config.variants.insert(0, "tv")
            renpy.config.variants.insert(0, "small")
            return

        # Otherwise, a phone or tablet.
        renpy.config.variants.insert(0, 'touch')

        pygame.display.init()

        info = renpy.display.get_info()
        diag = math.hypot(info.current_w, info.current_h) / android.get_dpi()
        print "Screen diagonal is", diag, "inches."

        if diag >= 6:
            renpy.config.variants.insert(0, 'tablet')
            renpy.config.variants.insert(0, 'medium')
        else:
            renpy.config.variants.insert(0, 'phone')
            renpy.config.variants.insert(0, 'small')

    else:
        renpy.config.variants.insert(0, 'pc')
        renpy.config.variants.insert(0, 'large')


def main():

    renpy.game.exception_info = 'Before loading the script.'

    # Get ready to accept new arguments.
    renpy.arguments.pre_init()

    # Init the screen language parser.
    renpy.sl2.slparser.init()

    # Init the config after load.
    renpy.config.init()

    # Set up variants.
    choose_variants()
    renpy.display.touch = "touch" in renpy.config.variants

    # Note the game directory.
    game.basepath = renpy.config.gamedir
    renpy.config.searchpath = [ renpy.config.gamedir ]

    # Find the common directory.
    commondir = __main__.path_to_common(renpy.config.renpy_base) # E1101 @UndefinedVariable

    if os.path.isdir(commondir):
        renpy.config.searchpath.append(commondir)
        renpy.config.commondir = commondir
    else:
        renpy.config.commondir = None

    if renpy.android:
        renpy.config.searchpath = [ ]
        renpy.config.commondir = None

    # Load Ren'Py extensions.
    for dir in renpy.config.searchpath: #@ReservedAssignment
        for fn in os.listdir(dir):
            if fn.lower().endswith(".rpe"):
                load_rpe(dir + "/" + fn)


    # The basename is the final component of the path to the gamedir.
    for i in sorted(os.listdir(renpy.config.gamedir)):

        if not i.endswith(".rpa"):
            continue

        i = i[:-4]
        renpy.config.archives.append(i)

    renpy.config.archives.reverse()

    # Initialize archives.
    renpy.loader.index_archives()

    # Start auto-loading.
    renpy.loader.auto_init()

    # Initialize the log.
    game.log = renpy.python.RollbackLog()

    # Initialize the store.
    renpy.store.store = sys.modules['store']

    # Set up styles.
    game.style = renpy.style.StyleManager() # @UndefinedVariable
    renpy.store.style = game.style

    # Run init code in its own context. (Don't log.)
    game.contexts = [ renpy.execution.Context(False) ]
    game.contexts[0].init_phase = True

    # Load the script.
    renpy.game.exception_info = 'While loading the script.'
    renpy.game.script = renpy.script.Script()

    # Set up error handling.
    renpy.exports.load_module("_errorhandling")
    renpy.style.build_styles() # @UndefinedVariable
    renpy.display.screen.prepare_screens()

    # Load all .rpy files.
    renpy.game.script.load_script() # sets renpy.game.script.

    renpy.game.exception_info = 'After loading the script.'

    # Find the save directory.
    if renpy.config.savedir is None:
        renpy.config.savedir = __main__.path_to_saves(renpy.config.gamedir) # E1101 @UndefinedVariable

    if renpy.game.args.savedir: #@UndefinedVariable
        renpy.config.savedir = renpy.game.args.savedir #@UndefinedVariable

    # Init preferences.
    game.persistent = renpy.persistent.init()
    game.preferences = game.persistent._preferences

    # Init save locations.
    renpy.savelocation.init()

    # We need to be 100% sure we kill the savelocation thread.
    try:

        # Load persistent data from all save locations.
        renpy.persistent.update()

        # Clear the list of seen statements in this game.
        game.seen_session = { }

        # Initialize persistent variables.
        renpy.store.persistent = game.persistent
        renpy.store._preferences = game.preferences

        if renpy.parser.report_parse_errors():
            raise renpy.game.ParseErrorException()

        renpy.game.exception_info = 'While executing init code:'

        for _prio, node in game.script.initcode:
            game.context().run(node)

        renpy.game.exception_info = 'After initialization, but before game start.'

        # Save the bytecode in a cache.
        renpy.game.script.save_bytecode()

        # Check if we should simulate android.
        renpy.android = renpy.android or renpy.config.simulate_android #@UndefinedVariable

        # Run the post init code, if any.
        for i in renpy.game.post_init:
            i()

        # Init translation.
        renpy.translation.init_translation()

        # Rebuild the various style caches.
        renpy.style.build_styles() # @UndefinedVariable

        # Prepare the screens.
        renpy.display.screen.prepare_screens()

        # Index the archive files. We should not have loaded an image
        # before this point. (As pygame will not have been initialized.)
        # We need to do this again because the list of known archives
        # may have changed.
        renpy.loader.index_archives()

        # Check some environment variables.
        renpy.game.less_memory = "RENPY_LESS_MEMORY" in os.environ
        renpy.game.less_mouse = "RENPY_LESS_MOUSE" in os.environ
        renpy.game.less_updates = "RENPY_LESS_UPDATES" in os.environ

        renpy.dump.dump(False)

        # Handle arguments and commands.
        if not renpy.arguments.post_init():
            return

        # Remove the list of all statements from the script.
        game.script.all_stmts = None

        # Make a clean copy of the store.
        renpy.python.make_clean_stores()

        # Initialize image cache.
        renpy.display.im.cache.init()

        # (Perhaps) Initialize graphics.
        if not game.interface:
            renpy.display.core.Interface()

        # Start things running.
        restart = None

        renpy.game.exception_info = 'While running game code:'
        renpy.first_utter_start = False


        while True:

            if restart:
                renpy.display.screen.before_restart()

            try:
                try:
                    run(restart)
                finally:
                    restart = (renpy.config.end_game_transition, "_invoke_main_menu", "_main_menu")
                    renpy.persistent.update(True)

            except game.FullRestartException, e:
                restart = e.reason

            finally:

                # Flush any pending interface work.
                renpy.display.interface.finish_pending()

                # Give Ren'Py a couple of seconds to finish saving.
                renpy.loadsave.autosave_not_running.wait(3.0)

    finally:

        renpy.loader.auto_quit()
        renpy.savelocation.quit()
        renpy.translation.write_updated_strings()

    # This is stuff we do on a normal, non-error return.
    if not renpy.display.error.error_handled:
        renpy.display.render.check_at_shutdown()


########NEW FILE########
__FILENAME__ = memory
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains functions used to help debug memory leaks. They aren't
# called by default, but can be used when problems occur.

import time
import threading
import weakref

old_memory = { }

def memory_profile():
    """
    Calling this function displays the change in the number of instances of
    each type of object.
    """

    print "- Memory Profile ---------------------------------------------------"

    import gc
    gc.collect()

    objs = gc.get_objects()

    c = { } # count

    for i in objs:
        t = type(i)
        c[t] = c.get(t, 0) + 1

    results = [ (count, ty) for ty, count in c.iteritems() ]
    results.sort()

    for count, ty in results:
        diff = count - old_memory.get(ty, 0)
        old_memory[ty] = count
        if diff:
            print diff, ty

    del objs


def find_parents(cls):
    """
    Finds the parents of every object of type `cls`.
    """

    # GC to save memory.
    import gc
    import types
    gc.collect()

    objs = gc.get_objects()

    def print_path(o):

        prefix = ""

        seen = set()
        queue = [ ]
        objects = [ ]


        for _i in range(30):

            objects.append(o)

            print prefix + str(id(o)), type(o),

            try:
                if isinstance(o, dict) and "__name__" in o:
                    print "with name", o["__name__"]
                else:
                    print repr(o)#[:1000]
            except:
                print "Bad repr."

            found = False

            if isinstance(o, types.ModuleType):
                if not queue:
                    break

                o, prefix = queue.pop()
                continue

            if isinstance(o, weakref.WeakKeyDictionary):
                for k, v in o.data.items():
                    if v is objects[-4]:
                        k = k()
                        seen.add(id(k))
                        queue.append((k, prefix + " (key) "))

            for i in gc.get_referrers(o):

                if i is objs or i is objects:
                    continue

                if id(i) in seen:
                    continue

                if isinstance(i, types.FrameType):
                    continue

                seen.add(id(i))
                queue.append((i, prefix + "  "))
                found = True
                break

            if not queue:
                break

            if not found:
                print "<no parent, popping>"

            o, prefix = queue.pop()

    for o in objs:
        if isinstance(o, cls):
            import random
            if random.random() < .1:

                print
                print "==================================================="
                print

                print_path(o)

def memory_thread():

    import sys
    TextureGrid = sys.modules['renpy.gl.gltexture'].TextureGrid

    while True:
        print "==================================================="
        print "==================================================="
        find_parents(TextureGrid)
        sys.stderr.write("Wrote textures.\n")
        time.sleep(5)

def start_memory_thread():
    t = threading.Thread(target=memory_thread)
    t.daemon = True
    t.start()

########NEW FILE########
__FILENAME__ = minstore
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

python_list = _list = list
python_dict = _dict = dict
python_object = _object = object
python_set = _set = set

from renpy.python import RevertableList as __renpy__list__
list = __renpy__list__ #@ReservedAssignment

from renpy.python import RevertableDict as __renpy__dict__
dict = __renpy__dict__ #@ReservedAssignment

from renpy.python import RevertableSet as set
Set = set

from renpy.python import RevertableObject as object #@UnusedImport

from renpy.python import revertable_range as range #@UnusedImport
from renpy.python import revertable_sorted as sorted #@UnusedImport

import renpy.ui as ui #@UnusedImport
import renpy.exports as renpy #@Reimport @UnusedImport
from renpy.translation import translate_string as __ # @UnusedImport

def _(s):
    """
    :undocumented: Documented directly in the .rst.

    Flags a string as translatable, and returns it immediately. The string
    will be translated when text displays it.
    """

    return s


########NEW FILE########
__FILENAME__ = object
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

class Object(object):
    """
    Our own base class. Contains methods to simplify serialization.
    """

    __version__ = 0

    nosave = [ ]

    def __getstate__(self):
        rv = vars(self).copy()

        for f in self.nosave:
            if f in rv:
                del rv[f]


        rv["__version__"] = self.__version__

        return rv


    # None, to prevent this from being called when unnecessary.
    after_setstate = None

    def __setstate__(self, new_dict):

        version = new_dict.pop("__version__", 0)

        self.__dict__.update(new_dict)

        if version != self.__version__:
            self.after_upgrade(version) # E1101

        if self.after_setstate:
            self.after_setstate() # E1102

# We don't handle slots with this mechanism, since the call to vars should
# throw an error.

sentinels = { }

class Sentinel(object):
    """
    This is used to represent a sentinel object. There will be exactly one
    sentinel object with a name existing in the system at any time.
    """

    def __new__(cls, name):
        rv = sentinels.get(name, None)

        if rv is None:
            rv = object.__new__(cls, name)
            sentinels[name] = rv

        return rv

    def __init__(self, name):
        self.name = name

    def __reduce__(self):
        return (Sentinel, (self.name, ))


########NEW FILE########
__FILENAME__ = parser

# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This module contains the parser for the Ren'Py script language. It's
# called when parsing is necessary, and creates an AST from the script.

import codecs
import re
import os

import renpy.display
import renpy.ast as ast
import renpy.sl2

# A list of parse error messages.
parse_errors = [ ]

class ParseError(Exception):

    def __init__(self, filename, number, msg, line=None, pos=None, first=False):
        message = u"File \"%s\", line %d: %s" % (unicode_filename(filename), number, msg)

        if line:
            lines = line.split('\n')

            if len(lines) > 1:
                open_string = None
                i = 0

                while i < len(lines[0]):
                    c = lines[0][i]

                    if c == "\\":
                        i += 1
                    elif c == open_string:
                        open_string = None
                    elif open_string:
                        pass
                    elif c == '`' or c == '\'' or c == '"':
                        open_string = c

                    i += 1

                if open_string:
                    message += "\n(Perhaps you left out a %s at the end of the first line.)" % open_string

            for l in lines:
                message += "\n    " + l

                if pos is not None:
                    if pos <= len(l):
                        message += "\n    " + " " * pos + "^"
                        pos = None
                    else:
                        pos -= len(l)

                if first:
                    break

        self.message = message

        Exception.__init__(self, message)

    def __unicode__(self):
        return self.message

# Something to hold the expected line number.
class LineNumberHolder(object):
    """
    Holds the expected line number.
    """

    def __init__(self):
        self.line = 0

def unicode_filename(fn):
    """
    Converts the supplied filename to unicode.
    """

    if isinstance(fn, unicode):
        return fn

    # Windows.
    try:
        return fn.decode("mbcs")
    except:
        pass

    # Mac and (sane) Unix
    try:
        return fn.decode("utf-8")
    except:
        pass

    # Insane systems, mojibake.
    return fn.decode("latin-1")

# Matches either a word, or something else. Most magic is taken care of
# before this.
lllword = re.compile(r'__(\w+)|\w+| +|.', re.S)

def munge_filename(fn):
    # The prefix that's used when __ is found in the file.
    rv = os.path.basename(fn)
    rv = os.path.splitext(rv)[0]
    rv = rv.replace(" ", "_")

    def munge_char(m):
        return hex(ord(m.group(0)))

    rv = re.sub(r'[^a-zA-Z0-9_]', munge_char, rv)

    return "_m1_" + rv + "__"

def elide_filename(fn):
    """
    Returns a version of fn that is either relative to the base directory,
    or relative to the Ren'Py directory.
    """

    fn = os.path.abspath(fn)
    basedir = os.path.abspath(renpy.config.basedir)
    renpy_base = os.path.abspath(renpy.config.renpy_base)

    if fn.startswith(basedir):
        return os.path.relpath(fn, basedir).replace("\\", "/")
    elif fn.startswith(renpy_base):
        return os.path.relpath(fn, renpy_base).replace("\\", "/")
    else:
        return fn.replace("\\", "/")

def unelide_filename(fn):
    fn1 = os.path.join(renpy.config.basedir, fn)
    if os.path.exists(fn1):
        return fn1

    fn2 = os.path.join(renpy.config.basedir, fn)
    if os.path.exists(fn2):
        return fn2

    return fn

def list_logical_lines(filename, filedata=None):
    """
    Reads `filename`, and divides it into logical lines.

    Returns a list of (filename, line number, line text) triples.

    If `filedata` is given, it should be a unicode string giving the file
    contents. In that case, `filename` need not exist.
    """

    if filedata:
        data = filedata
    else:
        f = codecs.open(filename, "r", "utf-8")
        data = f.read()
        f.close()

    data = data.replace("\r\n", "\n")
    data = data.replace("\r", "\n")

    filename = elide_filename(filename)
    prefix = munge_filename(filename)

    # Add some newlines, to fix lousy editors.
    data += "\n\n"

    # The result.
    rv = []

    # The line number in the physical file.
    number = 1

    # The current position we're looking at in the buffer.
    pos = 0

    # Skip the BOM, if any.
    if len(data) and data[0] == u'\ufeff':
        pos += 1

    # Looping over the lines in the file.
    while pos < len(data):

        # The line number of the start of this logical line.
        start_number = number

        # The line that we're building up.
        line = ""

        # The number of open parenthesis there are right now.
        parendepth = 0

        # Looping over the characters in a single logical line.
        while pos < len(data):

            c = data[pos]

            if c == '\t':
                raise ParseError(filename, number, "Tab characters are not allowed in Ren'Py scripts.")

            if c == '\n':
                number += 1

            if c == '\n' and not parendepth:
                # If not blank...
                if not re.match("^\s*$", line):

                    # Add to the results.
                    rv.append((filename, start_number, line))

                pos += 1
                # This helps out error checking.
                line = ""
                break

            # Backslash/newline.
            if c == "\\" and data[pos+1] == "\n":
                pos += 2
                number += 1
                line += "\\\n"
                continue

            # Parenthesis.
            if c in ('(', '[', '{'):
                parendepth += 1

            if c in ('}', ']', ')') and parendepth:
                parendepth -= 1

            # Comments.
            if c == '#':
                while data[pos] != '\n':
                    pos += 1

                continue

            # Strings.
            if c in ('"', "'", "`"):
                delim = c
                line += c
                pos += 1

                escape = False

                while pos < len(data):

                    c = data[pos]

                    if c == '\n':
                        number += 1

                    if escape:
                        escape = False
                        pos += 1
                        line += c
                        continue

                    if c == delim:
                        pos += 1
                        line += c
                        break

                    if c == '\\':
                        escape = True

                    line += c
                    pos += 1

                    continue

                continue

            m = lllword.match(data, pos)

            word = m.group(0)
            rest = m.group(1)

            if rest and "__" not in rest:
                word = prefix + rest

            line += word

            if len(line) > 65536:
                raise ParseError(filename, start_number, "Overly long logical line. (Check strings and parenthesis.)", line=line, first=True)

            pos = m.end(0)

            # print repr(data[pos:])


    if not line == "":
        raise ParseError(filename, start_number, "is not terminated with a newline. (Check strings and parenthesis.)", line=line, first=True)

    return rv



def group_logical_lines(lines):
    """
    This takes as input the list of logical line triples output from
    list_logical_lines, and breaks the lines into blocks. Each block
    is represented as a list of (filename, line number, line text,
    block) triples, where block is a block list (which may be empty if
    no block is associated with this line.)
    """

    # Returns the depth of a line, and the rest of the line.
    def depth_split(l):

        depth = 0
        index = 0

        while True:
            if l[index] == ' ':
                depth += 1
                index += 1
                continue

            # if l[index] == '\t':
            #    index += 1
            #    depth = depth + 8 - (depth % 8)
            #    continue

            break

        return depth, l[index:]

    # i, min_depth -> block, new_i
    def gll_core(i, min_depth):

        rv = []
        depth = None

        while i < len(lines):

            filename, number, text = lines[i]

            line_depth, rest = depth_split(text)

            # This catches a block exit.
            if line_depth < min_depth:
                break

            if depth is None:
                depth = line_depth

            if depth != line_depth:
                raise ParseError(filename, number, "indentation mismatch.")

            # Advance to the next line.
            i += 1

            # Try parsing a block associated with this line.
            block, i = gll_core(i, depth + 1)

            rv.append((filename, number, rest, block))

        return rv, i

    return gll_core(0, 0)[0]

# A list of keywords which should not be parsed as names, because
# there is a huge chance of confusion.
#
# Note: We need to be careful with what's in here, because thse
# are banned in simple_expressions, where we might want to use
# some of them.
KEYWORDS = set([
            '$',
            'as',
            'at',
            'behind',
            'call',
            'expression',
            'hide',
            'if',
            'in',
            'image',
            'init',
            'jump',
            'menu',
            'onlayer',
            'python',
            'return',
            'scene',
            'set',
            'show',
            'with',
            'while',
            'zorder',
            'transform',
            ])

OPERATORS = [
        'or\b',
        'and\b',
        'not\b',
        'in\b',
        'is\b',
        '<',
        '<=',
        '>',
        '>=',
        '<>',
        '!=',
        '==',
        '|',
        '^',
        '&',
        '<<',
        '>>',
        '+',
        '-',
        '*',
        '/',
        '//',
        '%',
        '~',
        '**',
        ]

operator_regexp = "|".join(re.escape(i) for i in OPERATORS)

word_regexp = ur'[a-zA-Z_\u00a0-\ufffd][0-9a-zA-Z_\u00a0-\ufffd]*'

class Lexer(object):
    """
    The lexer that is used to lex script files. This works on the idea
    that we want to lex each line in a block individually, and use
    sub-lexers to lex sub-blocks.
    """

    def __init__(self, block, init=False):

        # Are we underneath an init block?
        self.init = init

        self.block = block
        self.eob = False

        self.line = -1

        # These are set by advance.
        self.filename = ""
        self.text = ""
        self.number = 0
        self.subblock = [ ]
        self.pos = 0
        self.word_cache_pos = -1
        self.word_cache_newpos = -1
        self.word_cache = ""


    def advance(self):
        """
        Advances this lexer to the next line in the block. The lexer
        starts off before the first line, so advance must be called
        before any matching can be done. Returns True if we've
        successfully advanced to a line in the block, or False if we
        have advanced beyond all lines in the block. In general, once
        this method has returned False, the lexer is in an undefined
        state, and it doesn't make sense to call any method other than
        advance (which will always return False) on the lexer.
        """

        self.line += 1

        if self.line >= len(self.block):
            self.eob = True
            return False

        self.filename, self.number, self.text, self.subblock = self.block[self.line]
        self.pos = 0
        self.word_cache_pos = -1

        return True

    def match_regexp(self, regexp):
        """
        Tries to match the given regexp at the current location on the
        current line. If it succeds, it returns the matched text (if
        any), and updates the current position to be after the
        match. Otherwise, returns None and the position is unchanged.
        """

        if self.eob:
            return None

        if self.pos == len(self.text):
            return None

        m = re.compile(regexp, re.DOTALL).match(self.text, self.pos)

        if not m:
            return None

        self.pos = m.end()

        return m.group(0)

    def skip_whitespace(self):
        """
        Advances the current position beyond any contiguous whitespace.
        """

        # print self.text[self.pos].encode('unicode_escape')

        self.match_regexp(ur"(\s+|\\\n)+")

    def match(self, regexp):
        """
        Matches something at the current position, skipping past
        whitespace. Even if we can't match, the current position is
        still skipped past the leading whitespace.
        """

        self.skip_whitespace()
        return self.match_regexp(regexp)


    def keyword(self, word):
        """
        Matches a keyword at the current position. A keyword is a word
        that is surrounded by things that aren't words, like
        whitespace. (This prevents a keyword from matching a prefix.)
        """

        oldpos = self.pos
        if self.word() == word:
            return word

        self.pos = oldpos
        return ''


    def error(self, msg):
        """
        Convenience function for reporting a parse error at the current
        location.
        """

        raise ParseError(self.filename, self.number, msg, self.text, self.pos)

    def eol(self):
        """
        Returns True if, after skipping whitespace, the current
        position is at the end of the end of the current line, or
        False otherwise.
        """

        self.skip_whitespace()
        return self.pos >= len(self.text)

    def expect_eol(self):
        """
        If we are not at the end of the line, raise an error.
        """

        if not self.eol():
            self.error('end of line expected.')

    def expect_noblock(self, stmt):
        """
        Called to indicate this statement does not expect a block.
        If a block is found, raises an error.
        """

        if self.subblock:
            ll = self.subblock_lexer()
            ll.advance()
            ll.error("Line is indented, but the preceding %s statement does not expect a block. Please check this line's indentation." % stmt)

    def expect_block(self, stmt):
        """
        Called to indicate that the statement requires that a non-empty
        block is present.
        """

        if not self.subblock:
            self.error('%s expects a non-empty block.' % stmt)


    def subblock_lexer(self, init=False):
        """
        Returns a new lexer object, equiped to parse the block
        associated with this line.
        """

        init = self.init or init

        return Lexer(self.subblock, init=init)

    def string(self):
        """
        Lexes a string, and returns the string to the user, or none if
        no string could be found. This also takes care of expanding
        escapes and collapsing whitespace.

        Be a little careful, as this can return an empty string, which is
        different than None.
        """

        s = self.match(r'r?"([^\\"]|\\.)*"')

        if s is None:
            s = self.match(r"r?'([^\\']|\\.)*'")

        if s is None:
            s = self.match(r"r?`([^\\`]|\\.)*`")

        if s is None:
            return None

        if s[0] == 'r':
            raw = True
            s = s[1:]
        else:
            raw = False

        # Strip off delimiters.
        s = s[1:-1]

        if not raw:

            # Collapse runs of whitespace into single spaces.
            s = re.sub(r'\s+', ' ', s)

            s = s.replace("\\n", "\n")
            s = s.replace("\\{", "{{")
            s = s.replace("\\%", "%%")
            s = re.sub(r'\\u([0-9a-fA-F]{1,4})',
                       lambda m : unichr(int(m.group(1), 16)), s)
            s = re.sub(r'\\(.)', r'\1', s)

        return s

    def integer(self):
        """
        Tries to parse an integer. Returns a string containing the
        integer, or None.
        """

        return self.match(r'(\+|\-)?\d+')

    def float(self): #@ReservedAssignment
        """
        Tries to parse a number (float). Returns a string containing the
        number, or None.
        """

        return self.match(r'(\+|\-)?(\d+\.?\d*|\.\d+)([eE][-+]?\d+)?')

    def hash(self):
        """
        Matches the chatacters in an md5 hash, and then some.
        """

        return self.match(r'\w+')

    def word(self):
        """
        Parses a name, which may be a keyword or not.
        """

        if self.pos == self.word_cache_pos:
            self.pos = self.word_cache_newpos
            return self.word_cache

        self.word_cache_pos = self.pos
        rv = self.match(word_regexp)
        self.word_cache = rv
        self.word_cache_newpos = self.pos

        return rv


    def name(self):
        """
        This tries to parse a name. Returns the name or None.
        """

        oldpos = self.pos
        rv = self.word()

        if rv in KEYWORDS:
            self.pos = oldpos
            return None

        return rv

    def python_string(self):
        """
        This tries to match a python string at the current
        location. If it matches, it returns True, and the current
        position is updated to the end of the string. Otherwise,
        returns False.
        """

        if self.eol():
            return False

        c = self.text[self.pos]

        # Allow unicode strings.
        if c == 'u':
            self.pos += 1

            if self.pos == len(self.text):
                self.pos -= 1
                return False

            c = self.text[self.pos]

            if c not in ('"', "'"):
                self.pos -= 1
                return False

        elif c not in ('"', "'"):
            return False

        delim = c

        while True:
            self.pos += 1

            if self.eol():
                self.error("end of line reached while parsing string.")

            c = self.text[self.pos]

            if c == delim:
                break

            if c == '\\':
                self.pos += 1

        self.pos += 1
        return True


    def dotted_name(self):
        """
        This tries to match a dotted name, which is one or more names,
        separated by dots. Returns the dotted name if it can, or None
        if it cannot.

        Once this sees the first name, it commits to parsing a
        dotted_name. It will report an error if it then sees a dot
        without a name behind it.
        """

        rv = self.name()

        if not rv:
            return None

        while self.match(r'\.'):
            n = self.name()
            if not n:
                self.error('expecting name.')

            rv += "." + n

        return rv

    def delimited_python(self, delim):
        """
        This matches python code up to, but not including, the non-whitespace
        delimiter characters. Returns a string containing the matched code,
        which may be empty if the first thing is the delimiter. Raises an
        error if EOL is reached before the delimiter.
        """

        start = self.pos

        while not self.eol():

            c = self.text[self.pos]

            if c in delim:
                return renpy.ast.PyExpr(self.text[start:self.pos], self.filename, self.number)

            if c == '"' or c == "'":
                self.python_string()
                continue

            if self.parenthesised_python():
                continue

            self.pos += 1

        self.error("reached end of line when expecting '%s'." % delim)

    def python_expression(self):
        """
        Returns a python expression, which is arbitrary python code
        extending to a colon.
        """

        pe = self.delimited_python(':')

        if not pe:
            self.error("expected python_expression")

        rv = renpy.ast.PyExpr(pe.strip(), pe.filename, pe.linenumber) # E1101

        return rv

    def parenthesised_python(self):
        """
        Tries to match a parenthesised python expression. If it can,
        returns true and updates the current position to be after the
        closing parenthesis. Returns False otherewise.
        """

        c = self.text[self.pos]

        if c == '(':
            self.pos += 1
            self.delimited_python(')')
            self.pos += 1
            return True

        if c == '[':
            self.pos += 1
            self.delimited_python(']')
            self.pos += 1
            return True


        if c == '{':
            self.pos += 1
            self.delimited_python('}')
            self.pos += 1
            return True

        return False


    def simple_expression(self, comma=False):
        """
        Tries to parse a simple_expression. Returns the text if it can, or
        None if it cannot.
        """

        start = self.pos

        # Operator.
        while True:

            while self.match(operator_regexp):
                pass

            if self.eol():
                break

            # We start with either a name, a python_string, or parenthesized
            # python
            if not (self.python_string() or
                self.name() or
                self.float() or
                self.parenthesised_python()):

                break

            while True:
                self.skip_whitespace()

                if self.eol():
                    break

                # If we see a dot, expect a dotted name.
                if self.match(r'\.'):
                    n = self.word()
                    if not n:
                        self.error("expecting name after dot.")

                    continue

                # Otherwise, try matching parenthesised python.
                if self.parenthesised_python():
                    continue

                break

            if self.match(operator_regexp):
                continue

            if comma and self.match(r','):
                continue

            break

        text = self.text[start:self.pos].strip()

        if not text:
            return None

        return renpy.ast.PyExpr(self.text[start:self.pos].strip(), self.filename, self.number)

    def comma_expression(self):
        """
        One or more simple expressions, separated by commas, including an
        optional trailing comma.
        """

        return self.simple_expression(comma=True)


    def checkpoint(self):
        """
        Returns an opaque representation of the lexer state. This can be
        passed to revert to back the lexer up.
        """

        return self.line, self.filename, self.number, self.text, self.subblock, self.pos

    def revert(self, state):
        """
        Reverts the lexer to the given state. State must have been returned
        by a previous checkpoint operation on this lexer.
        """

        self.line, self.filename, self.number, self.text, self.subblock, self.pos = state
        self.word_cache_pos = -1

    def get_location(self):
        """
        Returns a (filename, line number) tuple representing the current
        physical location of the start of the current logical line.
        """

        return self.filename, self.number

    def require(self, thing, name=None):
        """
        Tries to parse thing, and reports an error if it cannot be done.

        If thing is a string, tries to parse it using
        self.match(thing). Otherwise, thing must be a method on this lexer
        object, which is called directly.
        """

        if isinstance(thing, str):
            name = name or thing
            rv = self.match(thing)
        else:
            name = name or thing.im_func.func_name
            rv = thing()

        if rv is None:
            self.error("expected '%s' not found." % name)

        return rv

    def rest(self):
        """
        Skips whitespace, then returns the rest of the current
        line, and advances the current position to the end of
        the current line.
        """

        self.skip_whitespace()

        pos = self.pos
        self.pos = len(self.text)
        return renpy.ast.PyExpr(self.text[pos:].strip(), self.filename, self.number)

    def python_block(self):
        """
        Returns the subblock of this code, and subblocks of that
        subblock, as indented python code. This tries to insert
        whitespace to ensure line numbers match up.
        """

        rv = [ ]

        o = LineNumberHolder()
        o.line = self.number

        def process(block, indent):

            for _fn, ln, text, subblock in block:

                while o.line < ln:
                    rv.append(indent + '\n')
                    o.line += 1

                linetext = indent + text + '\n'

                rv.append(linetext)
                o.line += linetext.count('\n')

                process(subblock, indent + '    ')

        process(self.subblock, '')
        return ''.join(rv)

def parse_image_name(l):
    """
    This parses an image name, and returns it as a tuple. It requires
    that the image name be present.
    """

    rv = [ l.require(l.name) ]

    while True:
        n = l.simple_expression()
        if not n:
            break

        rv.append(n.strip())

    return tuple(rv)

def parse_simple_expression_list(l):
    """
    This parses a comma-separated list of simple_expressions, and
    returns a list of strings. It requires at least one
    simple_expression be present.
    """

    rv = [ l.require(l.simple_expression) ]

    while True:
        if not l.match(','):
            break

        e = l.simple_expression()

        if not e:
            break

        rv.append(e)

    return rv

def parse_image_specifier(l):
    """
    This parses an image specifier.
    """

    tag = None
    layer = None
    at_list = [ ]
    zorder = None
    behind = [ ]

    if l.keyword("expression") or l.keyword("image"):
        expression = l.require(l.simple_expression)
        image_name = ( expression.strip(), )
    else:
        image_name = parse_image_name(l)
        expression = None

    while True:

        if l.keyword("onlayer"):
            if layer:
                l.error("multiple onlayer clauses are prohibited.")
            else:
                layer = l.require(l.name)

            continue

        if l.keyword("at"):

            if at_list:
                l.error("multiple at clauses are prohibited.")
            else:
                at_list = parse_simple_expression_list(l)

            continue

        if l.keyword("as"):

            if tag:
                l.error("multiple as clauses are prohibited.")
            else:
                tag = l.require(l.name)

            continue

        if l.keyword("zorder"):

            if zorder is not None:
                l.error("multiple zorder clauses are prohibited.")
            else:
                zorder = l.require(l.simple_expression)

            continue

        if l.keyword("behind"):

            if behind:
                l.error("multiple behind clauses are prohibited.")

            while True:
                bhtag = l.require(l.name)
                behind.append(bhtag)
                if not l.match(','):
                    break

            continue

        break

    if layer is None:
        layer = 'master'



    return image_name, expression, tag, at_list, layer, zorder, behind

def parse_with(l, node):
    """
    Tries to parse the with clause associated with this statement. If
    one exists, then the node is wrapped in a list with the
    appropriate pair of With nodes. Otherwise, just returns the
    statement by itself.
    """

    loc = l.get_location()

    if not l.keyword('with'):
        return node

    expr = l.require(l.simple_expression)

    return [ ast.With(loc, "None", expr),
             node,
             ast.With(loc, expr) ]


def parse_menu(stmtl, loc):

    l = stmtl.subblock_lexer()

    has_choice = False

    has_say = False
    has_caption = False

    with_ = None
    set = None #@ReservedAssignment

    say_who = None
    say_what = None

    # Tuples of (label, condition, block)
    items = [ ]

    l.advance()

    while not l.eob:

        if l.keyword('with'):
            with_ = l.require(l.simple_expression)
            l.expect_eol()
            l.expect_noblock('with clause')
            l.advance()

            continue

        if l.keyword('set'):
            set = l.require(l.simple_expression) #@ReservedAssignment
            l.expect_eol()
            l.expect_noblock('set menuitem')
            l.advance()

            continue

        # Try to parse a say menuitem.
        state = l.checkpoint()

        who = l.simple_expression()
        what = l.string()

        if who is not None and what is not None:

            l.expect_eol()
            l.expect_noblock("say menuitem")

            if has_caption:
                l.error("Say menuitems and captions may not exist in the same menu.")

            if has_say:
                l.error("Only one say menuitem may exist per menu.")

            has_say = True
            say_who = who
            say_what = what

            l.advance()

            continue

        l.revert(state)


        label = l.string()

        if label is None:
            l.error('expected menuitem')

        # A string on a line by itself is a caption.
        if l.eol():

            if l.subblock:
                l.error("Line is followed by a block, despite not being a menu choice. Did you forget a colon at the end of the line?")

            if label and has_say:
                l.error("Captions and say menuitems may not exist in the same menu.")

            # Only set this if the caption is not "".
            if label:
                has_caption = True

            items.append((label, "True", None))
            l.advance()

            continue

        # Otherwise, we have a choice.
        has_choice = True

        condition = "True"

        if l.keyword('if'):
            condition = l.require(l.python_expression)

        l.require(':')
        l.expect_eol()
        l.expect_block('choice menuitem')

        block = parse_block(l.subblock_lexer())

        items.append((label, condition, block))
        l.advance()

    if not has_choice:
        stmtl.error("Menu does not contain any choices.")

    rv = [ ]
    if has_say:
        rv.append(ast.Say(loc, say_who, say_what, None, interact=False))

    rv.append(ast.Menu(loc, items, set, with_))

    return rv


def parse_parameters(l):

    parameters = [ ]
    positional = [ ]
    extrapos = None
    extrakw = None

    add_positional = True

    names = set()

    if not l.match(r'\('):
        return None

    while True:

        if l.match('\)'):
            break

        if l.match(r'\*\*'):

            if extrakw is not None:
                l.error('a label may have only one ** parameter')

            extrakw = l.require(l.name)

            if extrakw in names:
                l.error('parameter %s appears twice.' % extrakw)

            names.add(extrakw)


        elif l.match(r'\*'):

            if not add_positional:
                l.error('a label may have only one * parameter')

            add_positional = False

            extrapos = l.name()

            if extrapos is not None:

                if extrapos in names:
                    l.error('parameter %s appears twice.' % extrapos)

                names.add(extrapos)

        else:

            name = l.require(l.name)

            if name in names:
                l.error('parameter %s appears twice.' % name)

            names.add(name)

            if l.match(r'='):
                l.skip_whitespace()
                default = l.delimited_python("),")
            else:
                default = None

            parameters.append((name, default))

            if add_positional:
                positional.append(name)

        if l.match(r'\)'):
            break

        l.require(r',')

    return renpy.ast.ParameterInfo(parameters, positional, extrapos, extrakw)


def parse_arguments(l):
    """
    Parse a list of arguments, if one is present.
    """

    arguments = [ ]
    extrakw = None
    extrapos = None

    if not l.match(r'\('):
        return None

    while True:

        if l.match('\)'):
            break

        if l.match(r'\*\*'):

            if extrakw is not None:
                l.error('a call may have only one ** argument')

            extrakw = l.delimited_python("),")


        elif l.match(r'\*'):
            if extrapos is not None:
                l.error('a call may have only one * argument')

            extrapos = l.delimited_python("),")

        else:

            state = l.checkpoint()

            name = l.name()
            if not (name and l.match(r'=')):
                l.revert(state)
                name = None

            l.skip_whitespace()
            arguments.append((name, l.delimited_python("),")))

        if l.match(r'\)'):
            break

        l.require(r',')

    return renpy.ast.ArgumentInfo(arguments, extrapos, extrakw)


##############################################################################
# The parse trie.

class ParseTrie(object):
    """
    This is a trie of words, that's used to pick a parser function.
    """

    def __init__(self):
        self.default = None
        self.words = { }

    def add(self, name, function):

        if not name:
            self.default = function
            return

        first = name[0]
        rest = name[1:]

        if first not in self.words:
            self.words[first] = ParseTrie()

        self.words[first].add(rest, function)

    def parse(self, l):
        old_pos = l.pos

        word = l.word() or l.match(r'\$')

        if not word in self.words:
            l.pos = old_pos
            return self.default

        return self.words[word].parse(l)


# The root of the parse trie.
statements = ParseTrie()


def statement(keywords):
    """
    A function decorator used to declare a statement. Keywords is a string
    giving the keywords that precede the statement.
    """

    keywords = keywords.split()

    def wrap(f):
        statements.add(keywords, f)
        return f

    return wrap


##############################################################################
# Statement functions.

@statement("if")
def if_statement(l, loc):

    entries = [ ]

    condition = l.require(l.python_expression)
    l.require(':')
    l.expect_eol()
    l.expect_block('if statement')

    block = parse_block(l.subblock_lexer())

    entries.append((condition, block))

    l.advance()

    while l.keyword('elif'):

        condition = l.require(l.python_expression)
        l.require(':')
        l.expect_eol()
        l.expect_block('elif clause')

        block = parse_block(l.subblock_lexer())

        entries.append((condition, block))

        l.advance()

    if l.keyword('else'):
        l.require(':')
        l.expect_eol()
        l.expect_block('else clause')

        block = parse_block(l.subblock_lexer())

        entries.append(('True', block))

        l.advance()

    return ast.If(loc, entries)


@statement("while")
def while_statement(l, loc):
    condition = l.require(l.python_expression)
    l.require(':')
    l.expect_eol()
    l.expect_block('while statement')
    block = parse_block(l.subblock_lexer())
    l.advance()

    return ast.While(loc, condition, block)


@statement("pass")
def pass_statement(l, loc):
    l.expect_noblock('pass statement')
    l.expect_eol()
    l.advance()

    return ast.Pass(loc)


@statement("menu")
def menu_statement(l, loc):
    l.expect_block('menu statement')
    label = l.name()
    l.require(':')
    l.expect_eol()

    menu = parse_menu(l, loc)

    l.advance()

    rv = [ ]

    if label:
        rv.append(ast.Label(loc, label, [], None))

    rv.extend(menu)

    return rv


@statement("return")
def return_statement(l, loc):
    l.expect_noblock('return statement')

    rest = l.rest()
    if not rest:
        rest = None

    l.expect_eol()
    l.advance()

    return ast.Return(loc, rest)


@statement("jump")
def jump_statement(l, loc):
    l.expect_noblock('jump statement')

    if l.keyword('expression'):
        expression = True
        target = l.require(l.simple_expression)
    else:
        expression = False
        target = l.require(l.name)

    l.expect_eol()
    l.advance()

    return ast.Jump(loc, target, expression)


@statement("call")
def call_statement(l, loc):
    l.expect_noblock('call statment')

    if l.keyword('expression'):
        expression = True
        target = l.require(l.simple_expression)

    else:
        expression = False
        target = l.require(l.name)

    # Optional pass, to let someone write:
    # call expression foo pass (bar, baz)
    l.keyword('pass')

    arguments = parse_arguments(l)

    rv = [ ast.Call(loc, target, expression, arguments) ]

    if l.keyword('from'):
        name = l.require(l.name)
        rv.append(ast.Label(loc, name, [], None))
    else:
        rv.append(ast.Pass(loc))

    l.expect_eol()
    l.advance()

    return rv


@statement("scene")
def scene_statement(l, loc):
    if l.keyword('onlayer'):
        layer = l.require(l.name)
    else:
        layer = "master"

    # Empty.
    if l.eol():
        l.advance()
        return ast.Scene(loc, None, layer)

    imspec = parse_image_specifier(l)
    stmt = ast.Scene(loc, imspec, imspec[4])
    rv = parse_with(l, stmt)

    if l.match(':'):
        stmt.atl = renpy.atl.parse_atl(l.subblock_lexer())
    else:
        l.expect_noblock('scene statement')

    l.expect_eol()
    l.advance()

    return rv


@statement("show")
def show_statement(l, loc):
    imspec = parse_image_specifier(l)
    stmt = ast.Show(loc, imspec)
    rv = parse_with(l, stmt)

    if l.match(':'):
        stmt.atl = renpy.atl.parse_atl(l.subblock_lexer())
    else:
        l.expect_noblock('show statement')

    l.expect_eol()
    l.advance()

    return rv

@statement("show layer")
def show_layer_statement(l, loc):

    layer = l.require(l.name)

    if l.keyword("at"):
        at_list = parse_simple_expression_list(l)
    else:
        at_list = [ ]

    if l.match(':'):
        atl = renpy.atl.parse_atl(l.subblock_lexer())
    else:
        atl = None
        l.expect_noblock('show layer statement')

    l.expect_eol()
    l.advance()

    rv = ast.ShowLayer(loc, layer, at_list, atl)

    return rv


@statement("hide")
def hide_statement(l, loc):
    imspec = parse_image_specifier(l)
    rv = parse_with(l, ast.Hide(loc, imspec))

    l.expect_eol()
    l.expect_noblock('hide statement')
    l.advance()

    return rv


@statement("with")
def with_statement(l, loc):
    expr = l.require(l.simple_expression)
    l.expect_eol()
    l.expect_noblock('with statement')
    l.advance()

    return ast.With(loc, expr)


@statement("image")
def image_statement(l, loc):
    name = parse_image_name(l)

    if l.match(':'):
        l.expect_eol()
        expr = None
        atl = renpy.atl.parse_atl(l.subblock_lexer())
    else:
        l.require('=')
        expr = l.rest()
        atl = None
        l.expect_noblock('image statement')

    rv = ast.Image(loc, name, expr, atl)

    if not l.init:
        rv = ast.Init(loc, [ rv ], 990)

    l.advance()

    return rv


@statement("define")
def define_statement(l, loc):

    priority = l.integer()
    if priority:
        priority = int(priority)
    else:
        priority = 0

    name = l.require(l.name)
    l.require('=')
    expr = l.rest()

    l.expect_noblock('define statement')

    rv = ast.Define(loc, name, expr)

    if not l.init:
        rv = ast.Init(loc, [ rv ], priority)

    l.advance()

    return rv


@statement("transform")
def transform_statement(l, loc):

    priority = l.integer()
    if priority:
        priority = int(priority)
    else:
        priority = 0

    name = l.require(l.name)
    parameters = parse_parameters(l)

    if parameters and (parameters.extrakw or parameters.extrapos):
        l.error('transform statement does not take a variable number of parameters')

    l.require(':')
    l.expect_eol()

    atl = renpy.atl.parse_atl(l.subblock_lexer())

    rv = ast.Transform(loc, name, atl, parameters)

    if not l.init:
        rv = ast.Init(loc, [ rv ], priority)

    l.advance()

    return rv


@statement("$")
def one_line_python(l, loc):
    python_code = l.rest()
    l.expect_noblock('one-line python statement')
    l.advance()

    return ast.Python(loc, python_code, store="store")


@statement("python")
def python_statement(l, loc):
    hide = False
    early = False
    store = 'store'

    if l.keyword('early'):
        early = True

    if l.keyword('hide'):
        hide = True

    if l.keyword('in'):
        store = "store." + l.require(l.name)

    l.require(':')
    l.expect_block('python block')

    python_code = l.python_block()

    l.advance()

    if early:
        return ast.EarlyPython(loc, python_code, hide, store=store)
    else:
        return ast.Python(loc, python_code, hide, store=store)


@statement("label")
def label_statement(l, loc):
    name = l.require(l.name)

    parameters = parse_parameters(l)

    if l.keyword('hide'):
        hide = True
    else:
        hide = False

    l.require(':')
    l.expect_eol()

    # Optional block here. It's empty if no block is associated with
    # this statement.
    block = parse_block(l.subblock_lexer())

    l.advance()
    return ast.Label(loc, name, block, parameters, hide=hide)


@statement("init")
def init_statement(l, loc):

    p = l.integer()

    if p:
        priority = int(p)
    else:
        priority = 0

    if l.match(':'):

        l.expect_eol()
        l.expect_block('init statement')

        block = parse_block(l.subblock_lexer(True))

        l.advance()

    else:

        try:
            old_init = l.init
            l.init = True

            block = [ parse_statement(l) ]

        finally:
            l.init = old_init

    return ast.Init(loc, block, priority)


@statement("screen1")
def screen1_statement(l, loc):

    # The guts of screen language parsing is in screenlang.py. It
    # assumes we ate the "screen" keyword before it's called.
    screen = renpy.screenlang.parse_screen(l)

    l.advance()

    if not screen:
        return [ ]

    rv = ast.Screen(loc, screen)

    if not l.init:
        rv = ast.Init(loc, [ rv ], -500)

    return rv


@statement("screen2")
def screen2_statement(l, loc):

    # The guts of screen language parsing is in screenlang.py. It
    # assumes we ate the "screen" keyword before it's called.
    screen = renpy.sl2.slparser.parse_screen(l, loc)

    l.advance()

    rv = ast.Screen(loc, screen)

    if not l.init:
        rv = ast.Init(loc, [ rv ], -500)

    return rv

# The version of screen language to use by default.
screen_language = int(os.environ.get("RENPY_SCREEN_LANGUAGE", "1"))

@statement("screen")
def screen_statement(l, loc):
    if screen_language == 1:
        return screen1_statement(l, loc)
    elif screen_language == 2:
        return screen2_statement(l, loc)
    else:
        l.error("Bad screen language version.")


def translate_strings(init_loc, language, l):
    l.require(':')
    l.expect_eol()
    l.expect_block('translate strings statement')

    ll = l.subblock_lexer()

    block = [ ]

    old = None
    loc = None

    def parse_string(s):
        s = s.strip()
        s = 'u' + s

        try:
            return eval(s)
        except:
            ll.error('could not parse string')

    while ll.advance():

        if ll.keyword('old'):

            if old is not None:
                ll.error("previous string is missing a translation")

            loc = ll.get_location()
            old = parse_string(ll.rest())

        elif ll.keyword('new'):

            if old is None:
                ll.error('no string to translate')

            new = parse_string(ll.rest())

            block.append(renpy.ast.TranslateString(loc, language, old, new))

            old = None
            new = None
            loc = None

        else:
            ll.error('unknown statement')

    if old:
        ll.error('final string is missing a translation')

    l.advance()

    if l.init:
        return block

    return ast.Init(init_loc, block, 0)

@statement("translate")
def translate_statement(l, loc):

    language = l.require(l.name)

    if language == "None":
        language = None

    identifier = l.require(l.hash)

    if identifier == "strings":
        return translate_strings(loc, language, l)

    elif identifier == "python":
        try:
            old_init = l.init
            l.init = True

            block = [ python_statement(l, loc) ]
            return [ ast.TranslateBlock(loc, language, block) ]
        finally:
            l.init = old_init

    elif identifier == "style":
        try:
            old_init = l.init
            l.init = True

            block = [ style_statement(l, loc) ]
            return [ ast.TranslateBlock(loc, language, block) ]
        finally:
            l.init = old_init


    l.require(':')
    l.expect_eol()

    l.expect_block("translate statement")

    block = parse_block(l.subblock_lexer())

    l.advance()

    return [ ast.Translate(loc, identifier, language, block), ast.EndTranslate(loc) ]


@statement("style")
def style_statement(l, loc):

    # Parse priority and name.
    name = l.require(l.word)
    parent = None

    rv = ast.Style(loc, name)

    # Function that parses a clause. This returns true if a clause has been
    # parsed, False otherwise.
    def parse_clause(l):

        if l.keyword("is"):
            if parent is not None:
                l.error("parent clause appears twice.")

            rv.parent = l.require(l.word)
            return True

        if l.keyword("clear"):
            rv.clear = True
            return True

        if l.keyword("take"):
            if rv.take is not None:
                l.error("take clause appears twice.")

            rv.take = l.require(l.name)
            return True

        if l.keyword("del"):
            propname = l.require(l.name)

            if propname not in renpy.style.prefixed_all_properties: # @UndefinedVariable
                l.error("style property %s is not known." % propname)

            rv.delattr.append(propname)
            return True

        if l.keyword("variant"):
            if rv.variant is not None:
                l.error("variant clause appears twice.")

            rv.variant = l.require(l.simple_expression)

            return True

        propname = l.name()

        if propname is not None:
            if propname not in renpy.style.prefixed_all_properties: # @UndefinedVariable
                l.error("style property %s is not known." % propname)

            if propname in rv.properties:
                l.error("style property %s appears twice." % propname)

            rv.properties[propname] = l.require(l.simple_expression)

            return True

        return False

    while parse_clause(l):
        pass

    if not l.match(':'):
        l.expect_noblock("style statement")
        l.expect_eol()
    else:
        l.expect_block("style statement")
        l.expect_eol()

        ll = l.subblock_lexer()

        while ll.advance():

            while parse_clause(ll):
                pass

            ll.expect_eol()

    if not l.init:
        rv = ast.Init(loc, [ rv ], 0)

    l.advance()

    return rv


@statement("")
def say_statement(l, loc):

    state = l.checkpoint()

    # Try for a single-argument say statement.
    what = l.string()

    if l.keyword('with'):
        with_ = l.require(l.simple_expression)
    else:
        with_ = None

    if what is not None and l.eol():
        # We have a one-argument say statement.
        l.expect_noblock('say statement')
        l.advance()
        return ast.Say(loc, None, what, with_)

    l.revert(state)

    # Try for a two-argument say statement.
    who = l.simple_expression()

    attributes = [ ]
    while True:
        prefix = l.match(r'-')
        if not prefix:
            prefix = ""

        component = l.word()

        if component is None:
            break

        attributes.append(prefix + component)

    if attributes:
        attributes = tuple(attributes)
    else:
        attributes = None

    what = l.string()

    if l.keyword('nointeract'):
        interact = False
    else:
        interact = True

    if l.keyword('with'):
        with_ = l.require(l.simple_expression)
    else:
        with_ = None

    if who and what is not None:
        l.expect_eol()
        l.expect_noblock('say statement')
        l.advance()
        return ast.Say(loc, who, what, with_, attributes=attributes, interact=interact)

    # This reports a parse error for any bad statement.
    l.error('expected statement.')


##############################################################################
# Functions called to parse things.

def parse_statement(l):
    """
    This parses a Ren'Py statement. l is expected to be a Ren'Py lexer
    that has been advanced to a logical line. This function will
    advance l beyond the last logical line making up the current
    statement, and will return an AST object representing this
    statement, or a list of AST objects representing this statement.
    """

    # Store the current location.
    loc = l.get_location()

    pf = statements.parse(l)

    if pf is None:
        l.error("expected statement.")

    return pf(l, loc)



def parse_block(l):
    """
    This parses a block of Ren'Py statements. It returns a list of the
    statements contained within the block. l is a new Lexer object, for
    this block.
    """

    l.advance()
    rv = [ ]

    while not l.eob:
        try:

            stmt = parse_statement(l)

            if isinstance(stmt, list):
                rv.extend(stmt)
            else:
                rv.append(stmt)

        except ParseError, e:
            parse_errors.append(e.message)
            l.advance()

    return rv

def parse(fn, filedata=None):
    """
    Parses a Ren'Py script contained within the file `fn`.

    Returns a list of AST objects representing the statements that were found
    at the top level of the file.

    If `filedata` is given, it should be a unicode string giving the file
    contents.
    """

    renpy.game.exception_info = 'While parsing ' + fn + '.'

    try:
        lines = list_logical_lines(fn, filedata)
        nested = group_logical_lines(lines)
    except ParseError, e:
        parse_errors.append(e.message)
        return None

    l = Lexer(nested)

    rv = parse_block(l)

    if parse_errors:
        return None

    return rv

def get_parse_errors():
    global parse_errors
    rv = parse_errors
    parse_errors = [ ]
    return rv

def report_parse_errors():

    if not parse_errors:
        return False

    full_text = ""

    f, error_fn = renpy.error.open_error_file("errors.txt", "w")
    f.write(codecs.BOM_UTF8)

    print >>f, "I'm sorry, but errors were detected in your script. Please correct the"
    print >>f, "errors listed below, and try again."
    print >>f

    for i in parse_errors:

        full_text += i
        full_text += "\n\n"

        try:
            i = i.encode("utf-8")
        except:
            pass

        print
        print >>f
        print i
        print >>f, i


    print >>f
    print >>f, "Ren'Py Version:", renpy.version

    f.close()

    renpy.display.error.report_parse_errors(full_text, error_fn)

    try:
        if renpy.game.args.command == "run": #@UndefinedVariable
            renpy.exports.launch_editor([ error_fn ], 1, transient=1)
    except:
        pass

    return True

########NEW FILE########
__FILENAME__ = persistent
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os
import copy
import time

import renpy

from renpy.loadsave import dump, loads
from cPickle import dumps

# The class that's used to hold the persistent data.
class Persistent(object):

    def __init__(self):
        self._update()

    def __setstate__(self, data):
        vars(self).update(data)

    def __getstate__(self):
        return vars(self)

    # Undefined attributes return None.
    def __getattr__(self, attr):
        return None

    def _clear(self, progress=False):
        """
        Resets the persistent data.

        `progress`
            If true, also resets progress data that Ren'Py keeps.
        """


        keys = list(self.__dict__)

        for i in keys:
            if i[0] == "_":
                continue

            del self.__dict__[i]

        if progress:
            self._seen_ever.clear()
            self._seen_images.clear()
            self._chosen.clear()
            self._seen_audio.clear()

    def _update(self):
        """
        Updates the persistent data to be the latest version of
        the persistent data.
        """

        if self._preferences is None:
            self._preferences = renpy.preferences.Preferences()

        # Initialize the set of statements seen ever.
        if not self._seen_ever:
            self._seen_ever = { }

        # Initialize the set of images seen ever.
        if not self._seen_images:
            self._seen_images = { }

        # Initialize the set of chosen menu choices.
        if not self._chosen:
            self._chosen = { }

        if not self._seen_audio:
            self._seen_audio = { }

        # A map from the name of a field to the time that field was last
        # changed at.
        if self._changed is None:
            self._changed = { }



renpy.game.Persistent = Persistent
renpy.game.persistent = Persistent()


def safe_deepcopy(o):
    """
    A "safe" version of deepcopy. If an object doesn't implement __eq__
    correctly, we replace it with its original.

    This tries to ensure we don't constantly find changes in the same
    field.
    """

    rv = copy.deepcopy(o)

    if not (o == rv):

        if renpy.config.developer:
            raise Exception("To be persisted, %r must support equality comparison." % o)
        else:
            rv = o

    return rv


# A map from field names to a backup of the field names in the persistent
# object.
backup = { }

def find_changes():
    """
    This finds changes in the persistent object. When it finds a change, it
    backs up that changed, and puts the current time for that field into
    persistent._changed.

    This returns True if there was at least one change, and False
    otherwise.
    """

    rv = False

    now = time.time()

    persistent = renpy.game.persistent
    pvars = vars(persistent)

    fields = set(backup.keys()) | set(pvars.keys())

    for f in fields:

        if f == "_changed":
            continue

        old = backup.get(f, None)
        new = pvars.get(f, None)

        if not (new == old):

            persistent._changed[f] = now
            backup[f] = safe_deepcopy(new)

            rv = True

    return rv


def load(filename):
    """
    Loads persistence data from `filename`. Returns None if the data
    could not be loaded, or a Persistent object if it could be
    loaded.
    """

    # Unserialize the persistent data.
    try:
        f = file(filename, "rb")
        s = f.read().decode("zlib")
        f.close()
        persistent = loads(s)
    except:
        return None

    persistent._update()

    return persistent


def init():
    """
    Loads the persistent data from disk.

    This performs the initial load of persistent data from the local
    disk, so that we can configure the savelocation system.
    """

    filename = os.path.join(renpy.config.savedir, "persistent")
    persistent = load(filename)

    if persistent is None:
        persistent = Persistent()

    # Create the backup of the persistent data.
    v = vars(persistent)

    for k, v in vars(persistent).iteritems():
        backup[k] = safe_deepcopy(v)

    return persistent


# A map from field name to merge function.
registry = { }

def register_persistent(field, func):
    """
    :doc: persistent

    Registers a function that is used to merge values of a persistent field
    loaded from disk with values of current persistent object.

    `field`
        The name of a field on the persistent object.

    `function`
        A function that is called with three parameters, `old`, `new`, and
        `current`:

        `old`
            The value of the field in the older object.

        `new`
            The value of the field in the newer object.

        `current`
            The value of the field in the current persistent object. This is
            provided for cases where the identity of the object referred to
            by the field can't change.

        The function is expected to return the new value of the field in the
        persistent object.
    """

    registry[field] = func

def default_merge(old, new, current):
    return new

def dictset_merge(old, new, current):
    current.update(old)
    current.update(new)
    return current

register_persistent("_seen_ever", dictset_merge)
register_persistent("_seen_images", dictset_merge)
register_persistent("_seen_audio", dictset_merge)
register_persistent("_chosen", dictset_merge)

def merge(other):
    """
    Merges `other` (which must be a persistent object) into the
    current persistent object. This updates deep
    """

    now = time.time()

    persistent = renpy.game.persistent

    pvars = vars(persistent)
    ovars = vars(other)

    fields = set(pvars.keys()) | set(ovars.keys())

    for f in fields:
        pval = pvars.get(f, None)
        oval = ovars.get(f, None)

        if pval == oval:
            continue

        ptime = persistent._changed.get(f, 0)

        otime = other._changed.get(f, 0)
        otime = min(now, otime)

        if ptime >= otime:
            new = pval
            old = oval
            t = ptime
        else:
            new = oval
            old = pval
            t = otime

        merge_func = registry.get(f, default_merge)

        val = merge_func(old, new, pval)
        pvars[f] = val
        backup[f] = safe_deepcopy(val)
        persistent._changed[f] = t

# The mtime of the most recently processed savefile.
persistent_mtime = None


def check_update():
    """
    Checks to see if we need to run update. If we do, runs update and
    restarts the interaction.
    """

    for mtime, _data in renpy.loadsave.location.load_persistent():
        if mtime > persistent_mtime:
            break
    else:
        return

    update()
    renpy.exports.restart_interaction()


def update(force_save=False):
    """
    Loads the persistent data from persistent files that are newer than
    persistent_mtime, and merges it into the persistent object.
    """

    need_save = find_changes()
    need_save = need_save or force_save

    global persistent_mtime

    # A list of (mtime, other) pairs, where other is a persistent file
    # we might want to merge in.
    pairs = renpy.loadsave.location.load_persistent()
    pairs.sort()

    # Deals with the case where we don't have any persistent data for
    # some reason.
    mtime = persistent_mtime

    for mtime, other in pairs:

        if mtime <= persistent_mtime:
            continue

        if other is None:
            continue

        merge(other)

    persistent_mtime = mtime

    if need_save:
        save()


def save():
    """
    Saves the persistent data to disk.
    """

    try:
        data = dumps(renpy.game.persistent).encode("zlib")
        renpy.loadsave.location.save_persistent(data)
    except:
        if renpy.config.developer:
            raise


################################################################################
# MultiPersistent
################################################################################


class _MultiPersistent(object):

    def __getstate__(self):
        state = self.__dict__.copy()
        del state['_filename']
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)

    def __getattr__(self, name):

        if name.startswith("__") and name.endswith("__"):
            raise AttributeError()

        return None

    def save(self):

        fn = self._filename
        f = file(fn + ".new", "wb")
        dump(self, f)
        f.close()

        try:
            os.rename(fn + ".new", fn)
        except:
            os.unlink(fn)
            os.rename(fn + ".new", fn)


def MultiPersistent(name):

    if not renpy.game.context().init_phase:
        raise Exception("MultiPersistent objects must be created during the init phase.")

    if renpy.windows:
        files = [ os.path.expanduser("~/RenPy/Persistent") ]

        if 'APPDATA' in os.environ:
            files.append(os.environ['APPDATA'] + "/RenPy/persistent")

    elif renpy.macintosh:
        files = [ os.path.expanduser("~/.renpy/persistent"),
                  os.path.expanduser("~/Library/RenPy/persistent") ]
    else:
        files = [ os.path.expanduser("~/.renpy/persistent") ]

    # Make the new persistent directory, why not?
    try:
        os.makedirs(files[-1])
    except:
        pass

    fn = "" # prevent a warning from happening.

    # Find the first file that actually exists. Otherwise, use the last
    # file.
    for fn in files:
        fn = fn + "/" + name
        if os.path.exists(fn):
            break

    try:
        rv = loads(file(fn).read())
    except:
        rv = _MultiPersistent()

    rv._filename = fn # W0201
    return rv

renpy.loadsave._MultiPersistent = _MultiPersistent
renpy.loadsave.MultiPersistent = MultiPersistent

########NEW FILE########
__FILENAME__ = preferences
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE

import renpy

class Preferences(renpy.object.Object):
    """
    Stores preferences that will one day be persisted.
    """
    __version__ = 11

    def after_upgrade(self, version):
        if version < 1:
            self.mute_volumes = 0
        if version < 2:
            self.using_afm_enable = False
        if version < 3:
            self.physical_size = None
        if version < 4:
            self.renderer = "auto"
            self.performance_test = True
        if version < 5:
            self.language = None
        if version < 6:
            self.wait_voice = True
        if version < 7:
            self.voice_sustain = False
        if version < 8:
            self.mouse_move = False
        if version < 9:
            self.afm_after_click = False
        if version < 11:
            self.show_empty_window = True

    def __init__(self):
        self.fullscreen = False
        self.skip_unseen = False
        self.text_cps = 0
        self.afm_time = 0
        self.afm_enable = True
        self.voice_sustain = False
        self.mouse_move = False
        self.show_empty_window = True

        # Should we wait for the voice to stop?
        self.wait_voice = True

        # Should we disengage auto-forward mode after a click?
        self.afm_after_click = False

        # 2 - All transitions.
        # 1 - Only non-default transitions.
        # 0 - No transitions.
        self.transitions = 2

        self.skip_after_choices = False

        # Mixer channel info.

        # A map from channel name to the current volume (between 0 and 1).
        self.volumes = { }

        # True if the channel should not play music. False
        # otherwise. (Not used anymore.)
        self.mute = { }

        # Joystick mappings.
        self.joymap = dict(
            joy_left="Axis 0.0 Negative",
            joy_right="Axis 0.0 Positive",
            joy_up="Axis 0.1 Negative",
            joy_down="Axis 0.1 Positive",
            joy_dismiss="Button 0.0")

        # The size of the window, or None if we don't know it yet.
        self.physical_size = None

        # The graphics renderer we use.
        self.renderer = "auto"

        # Should we do a performance test on startup?
        self.performance_test = True

        # The language we use for translations.
        self.language = None

    def set_volume(self, mixer, volume):
        self.volumes[mixer] = volume

    def get_volume(self, mixer):
        return self.volumes.get(mixer, 0)

    def set_mute(self, mixer, mute):
        self.mute[mixer] = mute

    def get_mute(self, mixer):
        return self.mute[mixer]

    def __eq__(self, other):
        return True

renpy.game.Preferences = Preferences
renpy.game.preferences = Preferences()

########NEW FILE########
__FILENAME__ = python
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code that handles the execution of python code
# contained within the script file. It also handles rolling back the
# game state to some time in the past.

# Import the python ast module, not ours.
ast = __import__("ast", { })

import marshal
import random
import weakref
import re
import sets
import sys

import renpy.audio

##############################################################################
# Code that implements the store.

# Deleted is a singleton object that's used to represent an object that has
# been deleted from the store.

class StoreDeleted(object):
    def __reduce__(self):
        return "deleted"

deleted = StoreDeleted()

class StoreModule(object):
    """
    This class represents one of the modules containing the store of data.
    """

    # Set our dict to be the StoreDict. Then proxy over setattr and delattr,
    # since Python won't call them by default.

    def __reduce__(self):
        return (get_store_module, (self.__name__,))

    def __init__(self, d):
        object.__setattr__(self, "__dict__", d)

    def __setattr__(self, key, value):
        self.__dict__[key] = value

    def __delattr__(self, key):
        del self.__dict__[key]

# Used to unpickle a store module.
def get_store_module(name):
    return sys.modules[name]

class StoreDict(dict):
    """
    This class represents the dictionary of a store module. It logs
    sets and deletes.
    """

    def __reduce__(self):
        raise Exception("Cannot pickle a reference to a store dictionary.")

    def __init__(self):

        # The value of this dictionary at the start of the current
        # rollback period (when begin() was last called).
        self.old = { }

        # The set of variables in this StoreDict that changed since the
        # end of the init phase.
        self.ever_been_changed = set()

    def reset(self):
        """
        Called to reset this to its initial conditions.
        """

        self.old = { }
        self.ever_been_changed = set()
        self.clear()

    def begin(self):
        """
        Called to mark the start of a rollback period.
        """

        self.old = dict(self)

    def get_changes(self):
        """
        For every key that has changed since begin() was called, returns a
        dictionary mapping the key to its value when begin was called, or
        deleted if it did not exist when begin was called.

        As a side-effect, updates self.ever_been_changed.
        """

        rv = { }

        for k in self:
            if k not in self.old:
                rv[k] = deleted

        for k, v in self.old.iteritems():

            new_v = self.get(k, deleted)

            if new_v is not v:
                rv[k] = v

        for k in rv:
            self.ever_been_changed.add(k)

        return rv


# A map from the name of a store dict to the corresponding StoreDict object.
store_dicts = { }

def create_store(name):
    """
    Creates the store with `name`.
    """

    name = str(name)

    if name in store_dicts:
        return

    # Create the dict.
    d = StoreDict()
    store_dicts[name] = d

    # Set the name.
    d["__name__"] = name
    d["__package__"] = name

    # Set up the default contents of the store.
    eval("1", d)

    for k, v in renpy.minstore.__dict__.iteritems():
        if k not in d:
            d[k] = v

    # Create the corresponding module.
    sys.modules[name] = StoreModule(d)

    # If we're a module in the store, add us to the store.
    if name.startswith("store."):
        store_dicts["store"][name[6:]] = sys.modules[name]

class StoreBackup():
    """
    This creates a copy of the current store, as it was at the start of
    the current statement.
    """

    def __init__(self):

        # The contents of the store for each store.
        self.store = { }

        # The contents of old for each store.
        self.old = { }

        # The contents of ever_been_changed for each store.
        self.ever_been_changed = { }


        for k, v in store_dicts.iteritems():
            self.store[k] = dict(v)
            self.old[k] = dict(v.old)
            self.ever_been_changed[k] = set(v.ever_been_changed)

    def restore(self):

        for k, sd in store_dicts.iteritems():

            sd.clear()
            sd.update(self.store[k])

            sd.old.clear()
            sd.old.update(self.old[k])

            sd.ever_been_changed.clear()
            sd.ever_been_changed.update(self.ever_been_changed[k])



clean_store_backup = None

def make_clean_stores():
    """
    Copy the clean stores.
    """

    global clean_store_backup

    for _k, v in store_dicts.iteritems():

        v.old.clear()
        v.ever_been_changed.clear()

    clean_store_backup = StoreBackup()

def clean_stores():
    """
    Revert the store to the clean copy.
    """

    clean_store_backup.restore()

##### Code that computes reachable objects, which is used to filter
##### the rollback list before rollback or serialization.

class NoRollback(object):
    """
    :doc: norollback class

    Instances of classes inheriting from this class do not participate in
    rollback. Objects reachable through an instance of a NoRollback class
    only participate in rollback if they are reachable through other paths.
    """

    pass


# parents = [ ]

def reached(obj, reachable, wait):
    """
    @param obj: The object that was reached.
    @param path: The path from the store via which it was reached.

    `reachable`
        A map from id(obj) to int. The int is 1 if the object was reached
        normally, and 0 if it was reached, but inherits from NoRollback.

    """

    if wait:
        wait()

    idobj = id(obj)

    if idobj in reachable:
        return

    if isinstance(obj, NoRollback):
        reachable[idobj] = 0
        return

    reachable[idobj] = 1

    # Since the store module is the roots, there's no need to
    # look into it.
    if isinstance(obj, StoreModule):
        return

    # parents.append(obj)

    try:
        # Treat as fields, indexed by strings.
        for v in vars(obj).itervalues():
            reached(v, reachable, wait)
    except:
        pass

    try:
        # Treat as iterable
        if not isinstance(obj, basestring):
            for v in obj.__iter__():
                reached(v, reachable, wait)
    except:
        pass

    try:
        # Treat as dict.
        for v in obj.itervalues():
            reached(v, reachable, wait)
    except:
        pass

    # parents.pop()

def reached_vars(store, reachable, wait):
    """
    Marks everything reachable from the variables in the store
    or from the context info objects as reachable.

    @param store: A map from variable name to variable value.
    @param reachable: A dictionary mapping reached object ids to
    the path by which the object was reached.
    """

    for v in store.itervalues():
        reached(v, reachable, wait)

    for c in renpy.game.contexts:
        reached(c.info, reachable, wait)
        reached(c.music, reachable, wait)
        for d in c.dynamic_stack:
            for v in d.itervalues():
                reached(v, reachable, wait)


##### Code that replaces literals will calls to magic constructors.

class WrapNode(ast.NodeTransformer):

    def visit_ListComp(self, n):
        return ast.Call(
            func = ast.Name(
                id="__renpy__list__",
                ctx=ast.Load()
                ),
            args = [ self.generic_visit(n) ],
            keywords = [ ],
            starargs = None,
            kwargs = None)

    def visit_List(self, n):
        if not isinstance(n.ctx, ast.Load):
            return self.generic_visit(n)

        return ast.Call(
            func = ast.Name(
                id="__renpy__list__",
                ctx=ast.Load()
                ),
            args = [ self.generic_visit(n) ],
            keywords = [ ],
            starargs = None,
            kwargs = None)

    def visit_Dict(self, n):

        return ast.Call(
            func = ast.Name(
                id="__renpy__dict__",
                ctx=ast.Load()
                ),
            args = [ self.generic_visit(n) ],
            keywords = [ ],
            starargs = None,
            kwargs = None)

wrap_node = WrapNode()


def set_filename(filename, offset, tree):
    """Set the filename attribute to filename on every node in tree"""
    worklist = [tree]
    while worklist:
        node = worklist.pop(0)
        node.filename = filename

        lineno = getattr(node, 'lineno', None)
        if lineno is not None:
            node.lineno = lineno + offset

        worklist.extend(node.getChildNodes())


unicode_re = re.compile(ur'[\u0080-\uffff]')

def unicode_sub(m):
    """
    If the string s contains a unicode character, make it into a
    unicode string.
    """

    s = m.group(0)

    if not unicode_re.search(s):
        return s

    prefix = m.group(1)
    sep = m.group(2)
    body = m.group(3)

    if "u" not in prefix and "U" not in prefix:
        prefix = 'u' + prefix

    rv = prefix + sep + body + sep

    return rv


string_re = re.compile(r'([uU]?[rR]?)("""|"|\'\'\'|\')((\\.|.)*?)\2')

def escape_unicode(s):
    if unicode_re.search(s):
        s = string_re.sub(unicode_sub, s)

    return s

def py_compile(source, mode, filename='<none>', lineno=1, ast_node=False):
    """
    Compiles the given source code using the supplied codegenerator.
    Lists, List Comprehensions, and Dictionaries are wrapped when
    appropriate.

    `source`
        The source code, as a either a string, pyexpr, or ast module
        node.

    `mode`
        One of "exec" or "eval".

    `filename`
        The filename the source comes from. If a pyexpr is given, the
        filename embedded in the pyexpr is used.

    `lineno`
        The line number of the first line of source code. If a pyexpr is
        given, the filename embedded in the pyexpr is used.

    `ast_node`
        Rather than returning compiled bytecode, returns the AST object
        that would be used.
    """

    if isinstance(source, ast.Module):
        return compile(source, filename, mode)

    if isinstance(source, renpy.ast.PyExpr):
        filename = source.filename
        lineno = source.linenumber

    source = unicode(source)
    source = source.replace("\r", "")
    source = escape_unicode(source)

    try:
        line_offset = lineno - 1

        tree = ast.parse(source, filename, mode)

        tree = wrap_node.visit(tree)

        ast.fix_missing_locations(tree)
        ast.increment_lineno(tree, lineno - 1)

        line_offset = 0

        if ast_node:
            return tree.body

        return compile(tree, filename, mode)

    except SyntaxError, e:

        if e.lineno is not None:
            e.lineno += line_offset

        raise e


def py_compile_exec_bytecode(source, **kwargs):
    code = py_compile(source, 'exec', **kwargs)
    return marshal.dumps(code)


def py_compile_eval_bytecode(source, **kwargs):
    source = source.strip()
    code = py_compile(source, 'eval', **kwargs)
    return marshal.dumps(code)



##### Classes that are exported in place of the normal list, dict, and
##### object.

# This is set to True whenever a mutation occurs. The save code uses
# this to check to see if a background-save is valid.
mutate_flag = True

def mutator(method):

    def do_mutation(self, *args, **kwargs):

        global mutate_flag

        mutated = renpy.game.log.mutated #@UndefinedVariable

        if id(self) not in mutated:
            mutated[id(self)] = ( weakref.ref(self), self.get_rollback())
            mutate_flag = True

        return method(self, *args, **kwargs)

    return do_mutation

class RevertableList(list):

    def __init__(self, *args):
        log = renpy.game.log

        if log is not None:
            log.mutated[id(self)] = None

        list.__init__(self, *args)

    __delitem__ = mutator(list.__delitem__)
    __delslice__ = mutator(list.__delslice__)
    __setitem__ = mutator(list.__setitem__)
    __iadd__ = mutator(list.__iadd__)
    __imul__ = mutator(list.__imul__)
    append = mutator(list.append)
    extend = mutator(list.extend)
    insert = mutator(list.insert)
    pop = mutator(list.pop)
    remove = mutator(list.remove)
    reverse = mutator(list.reverse)
    sort = mutator(list.sort)

    def wrapper(method): # E0213 @NoSelf
        def newmethod(*args, **kwargs):
            return RevertableList(method(*args, **kwargs)) # E1102

        return newmethod

    __add__ = wrapper(list.__add__)
    __getslice__ = wrapper(list.__getslice__)
    __mul__ = wrapper(list.__mul__)
    __rmul__ = wrapper(list.__rmul__)

    del wrapper

    def get_rollback(self):
        return self[:]

    def rollback(self, old):
        self[:] = old

def revertable_range(*args):
    return RevertableList(range(*args))

def revertable_sorted(*args, **kwargs):
    return RevertableList(sorted(*args, **kwargs))

class RevertableDict(dict):

    def __init__(self, *args, **kwargs):
        log = renpy.game.log

        if log is not None:
            log.mutated[id(self)] = None

        dict.__init__(self, *args, **kwargs)

    __delitem__ = mutator(dict.__delitem__)
    __setitem__ = mutator(dict.__setitem__)
    clear = mutator(dict.clear)
    pop = mutator(dict.pop)
    popitem = mutator(dict.popitem)
    setdefault = mutator(dict.setdefault)

    def list_wrapper(method): # E0213 @NoSelf
        def newmethod(*args, **kwargs):
            return RevertableList(method(*args, **kwargs)) # E1102

        return newmethod

    keys = list_wrapper(dict.keys)
    values = list_wrapper(dict.values)
    items = list_wrapper(dict.items)

    del list_wrapper

    def copy(self):
        rv = RevertableDict()
        rv.update(self)
        return rv

    def get_rollback(self):
        return self.items()

    def rollback(self, old):
        self.clear()

        for k, v in old:
            self[k] = v

class RevertableSet(sets.Set):

    def __init__(self, *args):
        log = renpy.game.log

        if log is not None:
            log.mutated[id(self)] = None

        sets.Set.__init__(self, *args)

    __iand__ = mutator(sets.Set.__iand__)
    __ior__ = mutator(sets.Set.__ior__)
    __isub__ = mutator(sets.Set.__isub__)
    __ixor__ = mutator(sets.Set.__ixor__)
    add = mutator(sets.Set.add)
    clear = mutator(sets.Set.clear)
    difference_update = mutator(sets.Set.difference_update)
    discard = mutator(sets.Set.discard)
    intersection_update = mutator(sets.Set.intersection_update)
    pop = mutator(sets.Set.pop)
    remove = mutator(sets.Set.remove)
    symmetric_difference_update = mutator(sets.Set.symmetric_difference_update)
    union_update = mutator(sets.Set.union_update)
    update = mutator(sets.Set.update)

    def wrapper(method): # E0213 @NoSelf
        def newmethod(*args, **kwargs):
            rv = method(*args, **kwargs) # E1102
            if isinstance(rv, sets.Set):
                return RevertableSet(rv)
            else:
                return rv

        return newmethod

    __and__ = wrapper(sets.Set.__and__)
    __copy__ = wrapper(sets.Set.__copy__)
    __deepcopy__ = wrapper(sets.Set.__deepcopy__)
    __sub__ = wrapper(sets.Set.__sub__)
    __xor__ = wrapper(sets.Set.__xor__)
    __or__ = wrapper(sets.Set.__or__)
    copy = wrapper(sets.Set.copy)
    difference = wrapper(sets.Set.difference)
    intersection = wrapper(sets.Set.intersection)
    symmetric_difference = wrapper(sets.Set.symmetric_difference)
    union = wrapper(sets.Set.union)

    del wrapper

    def get_rollback(self):
        return list(self)

    def rollback(self, old):
        sets.Set.clear(self)
        sets.Set.update(self, old)


class RevertableObject(object):

    def __new__(cls, *args, **kwargs):
        self = super(RevertableObject, cls).__new__(cls)

        log = renpy.game.log
        if log is not None:
            log.mutated[id(self)] = None

        return self

    def __setattr__(self, attr, value):
        object.__setattr__(self, attr, value)

    def __delattr__(self, attr):
        object.__delattr__(self, attr)

    __setattr__ = mutator(__setattr__)
    __delattr__ = mutator(__delattr__)

    def get_rollback(self):
        return self.__dict__.copy()

    def rollback(self, old):
        self.__dict__.clear()
        self.__dict__.update(old)


##### An object that handles deterministic randomness, or something.

class DetRandom(random.Random):

    def __init__(self):
        super(DetRandom, self).__init__()
        self.stack = [ ]

    def random(self):

        if self.stack:
            rv = self.stack.pop()
        else:
            rv = super(DetRandom, self).random()

        renpy.game.log.current.random.append(rv)
        return rv

    def pushback(self, l):
        """
        Pushes the random numbers in l onto the stack so they will be generated
        in the order given.
        """

        ll = l[:]
        ll.reverse()

        self.stack.extend(ll)

    def reset(self):
        """
        Resets the RNG, removing all of the pushbacked numbers.
        """

        self.stack = [ ]

rng = DetRandom()

##### This is the code that actually handles the logging and managing
##### of the rollbacks.

class Rollback(renpy.object.Object):
    """
    Allows the state of the game to be rolled back to the point just
    before a node began executing.

    @ivar context: A shallow copy of the context we were in before
    we started executing the node. (Shallow copy also includes
    a copy of the associated SceneList.)

    @ivar objects: A list of tuples, each containing an object and a
    token of information that, when passed to the rollback method on
    that object, causes that object to rollback.

    @ivar store: A list of updates to store that will cause the state
    of the store to be rolled back to the start of node
    execution. This is a list of tuples, either (key, value) tuples
    representing a value that needs to be assigned to a key, or (key,)
    tuples that mean the key should be deleted.

    @ivar checkpoint: True if this is a user-visible checkpoint,
    false otherwise.

    @ivar purged: True if purge_unreachable has already been called on
    this Rollback, False otherwise.

    @ivar random: A list of random numbers that were generated during the
    execution of this element.
    """

    __version__ = 3

    def __init__(self):

        super(Rollback, self).__init__()

        self.context = renpy.game.context().rollback_copy()
        self.objects = [ ]
        self.checkpoint = False
        self.purged = False
        self.random = [ ]
        self.forward = None

        # A map of maps name -> (variable -> value)
        self.stores = { }

        # If true, we retain the data in this rollback when a load occurs.
        self.retain_after_load = False

    def after_upgrade(self, version):

        if version < 2:
            self.stores = { "store" : { } }

            for i in self.store:
                if len(i) == 2:
                    k, v = i
                    self.stores["store"][k] = v
                else:
                    k, = i
                    self.stores["store"][k] = deleted

        if version < 3:
            self.retain_after_load = False


    def purge_unreachable(self, reachable, wait):
        """
        Adds objects that are reachable from the store of this
        rollback to the set of reachable objects, and purges
        information that is stored about totally unreachable objects.

        Returns True if this is the first time this method has been
        called, or False if it has already been called once before.
        """

        if self.purged:
            return False

        self.purged = True

        # Add objects reachable from the stores. (Objects that might be
        # unreachable at the moment.)
        for changes in self.stores.itervalues():
            for _k, v in changes.iteritems():
                if v is not deleted:
                    reached(v, reachable, wait)

        # Add in objects reachable through the context.
        reached(self.context.info, reachable, wait)
        for d in self.context.dynamic_stack:
            for v in d.itervalues():
                reached(v, reachable, wait)

        # Add in objects reachable through displayables.
        reached(self.context.scene_lists.get_all_displayables(), reachable, wait)

        # Purge object update information for unreachable objects.
        new_objects = [ ]

        for o, rb in self.objects:
            if reachable.get(id(o), 0):
                new_objects.append((o, rb))
                reached(rb, reachable, wait)
            else:
                if renpy.config.debug:
                    print "Removing unreachable:", o

                    pass

        self.objects = new_objects

        return True


    def rollback(self):
        """
        Reverts the state of the game to what it was at the start of the
        previous checkpoint.
        """

        for obj, roll in reversed(self.objects):
            if roll is not None:
                obj.rollback(roll)

        for name, changes in self.stores.iteritems():
            store = store_dicts.get(name, None)
            if store is None:
                return

            for name, value in changes.iteritems():
                if value is deleted:
                    if name in store:
                        del store[name]
                else:
                    store[name] = value

        rng.pushback(self.random)

        renpy.game.contexts.pop()
        renpy.game.contexts.append(self.context)

    def rollback_control(self):
        """
        This rolls back only the control information, while leaving
        the data information intact.
        """

        renpy.game.contexts.pop()
        renpy.game.contexts.append(self.context)



class RollbackLog(renpy.object.Object):
    """
    This class manages the list of Rollback objects.

    @ivar log: The log of rollback objects.

    @ivar current: The current rollback object. (Equivalent to
    log[-1])

    @ivar rollback_limit: The number of steps left that we can
    interactively rollback.

    Not serialized:

    @ivar mutated: A dictionary that maps object ids to a tuple of
    (weakref to object, information needed to rollback that object)
    """

    __version__ = 4


    nosave = [ 'old_store', 'mutated' ]

    def __init__(self):

        super(RollbackLog, self).__init__()

        self.log = [ ]
        self.current = None
        self.mutated = { }
        self.rollback_limit = 0
        self.rollback_is_fixed = False
        self.fixed_rollback_boundary = None
        self.forward = [ ]
        self.old_store = { }

        # Did we just do a roll forward?
        self.rolled_forward = False

        # Reset the RNG on the creation of a new game.
        rng.reset()

        # True if we should retain data from here to the next checkpoint
        # on load.
        self.retain_after_load_flag = False


    def after_setstate(self):
        self.mutated = { }
        self.rolled_forward = False

    def after_upgrade(self, version):
        if version < 2:
            self.ever_been_changed = { "store" : set(self.ever_been_changed) }
        if version < 3:
            self.rollback_is_fixed = False
            self.fixed_rollback_boundary = None
        if version < 4:
            self.retain_after_load_flag = False

    def begin(self):
        """
        Called before a node begins executing, to indicate that the
        state needs to be saved for rollbacking.
        """

        context = renpy.game.context()
        if not context.rollback:
            return

        # If the transient scene list is not empty, then we do
        # not begin a new rollback, as the TSL will be purged
        # after a rollback is complete.
        if not context.scene_lists.transient_is_empty():
            return

        # If the log is too long, prune it.
        if len(self.log) > renpy.config.rollback_length:
            self.log = self.log[-renpy.config.rollback_length:]

        # check for the end of fixed rollback
        if self.log and self.log[-1] == self.current:

            if self.current.context.current == self.fixed_rollback_boundary:
                self.rollback_is_fixed = False

            elif self.rollback_is_fixed and not self.forward:
                # A lack of rollback data in fixed rollback mode ends rollback.
                self.fixed_rollback_boundary = self.current.context.current
                self.rollback_is_fixed = False

        self.current = Rollback()
        self.current.retain_after_load = self.retain_after_load_flag

        self.log.append(self.current)

        self.mutated = { }

        # Flag a mutation as having happened. This is used by the
        # save code.
        global mutate_flag
        mutate_flag = True

        self.rolled_forward = False

        # Reset the point that changes are relative to.
        for sd in store_dicts.itervalues():
            sd.begin()

    def complete(self):
        """
        Called after a node is finished executing, before a save
        begins, or right before a rollback is attempted. This may be
        called more than once between calls to begin, and should always
        be called after an update to the store but before a rollback
        occurs.
        """

        # Update self.current.stores with the changes from each store.
        # Also updates .ever_been_changed.
        for name, sd in store_dicts.iteritems():
            self.current.stores[name] = sd.get_changes()

        # Update the list of mutated objects and what we need to do to
        # restore them.

        for _i in xrange(4):

            self.current.objects = [ ]

            try:
                for _k, v in self.mutated.iteritems():

                    if v is None:
                        continue

                    (ref, roll) = v

                    obj = ref()
                    if obj is None:
                        continue

                    self.current.objects.append((obj, roll))

                break

            except RuntimeError:
                # This can occur when self.mutated is changed as we're
                # iterating over it.
                pass



    def get_roots(self):
        """
        Return a map giving the current roots of the store. This is a
        map from a variable name in the store to the value of that
        variable. A variable is only in this map if it has ever been
        changed since the init phase finished.
        """

        rv = { }

        for store_name, sd in store_dicts.iteritems():
            for name in sd.ever_been_changed:
                if name in sd:
                    rv[store_name + "." + name] = sd[name]
                else:
                    rv[store_name + "." + name] = deleted

        return rv

    def purge_unreachable(self, roots, wait=None):
        """
        This is called to purge objects that are unreachable from the
        roots from the object rollback lists inside the Rollback entries.

        This should be called immediately after complete(), so that there
        are no changes queued up.
        """

        reachable = { }

        reached_vars(roots, reachable, wait)

        revlog = self.log[:]
        revlog.reverse()

        for i in revlog:
            if not i.purge_unreachable(reachable, wait):
                break

    def in_rollback(self):
        if self.forward:
            return True
        else:
            return False

    def in_fixed_rollback(self):
        return self.rollback_is_fixed

    def forward_info(self):
        """
        Returns the current forward info, if any.
        """

        if self.forward:

            name, data = self.forward[0]

            if self.current.context.current == name:
                return data

        return None

    def checkpoint(self, data=None, keep_rollback=False):
        """
        Called to indicate that this is a checkpoint, which means
        that the user may want to rollback to just before this
        node.
        """

        self.retain_after_load_flag = False

        if self.current.checkpoint:
            return

        if not renpy.game.context().rollback:
            return

        if self.rollback_limit < renpy.config.hard_rollback_limit:
            self.rollback_limit += 1

        self.current.checkpoint = True

        if self.in_fixed_rollback() and self.forward:
            # use data from the forward stack
            fwd_name, fwd_data = self.forward[0]
            if self.current.context.current == fwd_name:
                self.current.forward = fwd_data
                self.forward.pop(0)
            else:
                self.current.forward = data
                self.forward = [ ]

        elif data is not None:
            if self.forward:
                # If the data is the same, pop it from the forward stack.
                # Otherwise, clear the forward stack.
                fwd_name, fwd_data = self.forward[0]

                if (self.current.context.current == fwd_name
                    and data == fwd_data
                    and (keep_rollback or self.rolled_forward)
                    ):
                    self.forward.pop(0)
                else:
                    self.forward = [ ]

            # Log the data in case we roll back again.
            self.current.forward = data

    def block(self):
        """
        Called to indicate that the user should not be able to rollback
        through this checkpoint.
        """

        self.rollback_limit = 0

    def retain_after_load(self):
        """
        Called to return data from this statement until the next checkpoint
        when the game is loaded.
        """

        self.retain_after_load_flag = True
        self.current.retain_after_load = True

    def fix_rollback(self):
        if not self.rollback_is_fixed and len(self.log) > 1:
            self.fixed_rollback_boundary = self.log[-2].context.current

    def can_rollback(self):
        """
        Returns True if we can rollback.
        """

        return self.rollback_limit > 0

    def rollback(self, checkpoints, force=False, label=None, greedy=True, on_load=False):
        """
        This rolls the system back to the first valid rollback point
        after having rolled back past the specified number of checkpoints.

        If we're currently executing code, it's expected that complete()
        will be called before a rollback is attempted.

        force makes us throw an exception if we can't find a place to stop
        rolling back, otherwise if we run out of log this call has no
        effect.

        `label`
            A label that is called after rollback has finished, if the
            label exists.

        `greedy`
            If true, rollback will keep going until just after the last
            checkpoint. If False, it will stop immediately before the
            current statement.

        `on_load`
            Should be true if this rollback is being called in response to a
            load. Used to implement .retain_after_load()
        """

        # If we have exceeded the rollback limit, and don't have force,
        # give up.
        if checkpoints and not self.rollback_limit > 0 and not force:
            return

        self.purge_unreachable(self.get_roots())

        revlog = [ ]

        # Find the place to roll back to.
        while self.log:
            rb = self.log.pop()
            revlog.append(rb)

            if rb.checkpoint:
                checkpoints -= 1
                self.rollback_limit -= 1

            if checkpoints <= 0:
                if renpy.game.script.has_label(rb.context.current):
                    break

        else:
            if force:
                raise Exception("Couldn't find a place to stop rolling back. Perhaps the script changed in an incompatible way?")

            # Otherwise, just give up.

            print "Can't find a place to rollback to. Not rolling back."

            revlog.reverse()
            self.log = self.log + revlog
            return

        # Try to rollback to just after the previous checkpoint.
        while greedy and self.log:

            rb = self.log[-1]

            if rb.checkpoint:
                break

            if not renpy.game.script.has_label(rb.context.current):
                break

            if self.rollback_limit <= 0:
                break

            revlog.append(self.log.pop())

        # Decide if we're replacing the current context (rollback command),
        # or creating a new set of contexts (loading).
        if renpy.game.context().rollback:
            replace_context = False
            other_contexts = [ ]
        else:
            replace_context = True
            other_contexts = renpy.game.contexts[1:]
            renpy.game.contexts = renpy.game.contexts[0:1]

        if on_load and revlog[-1].retain_after_load:
            retained = revlog.pop()
        else:
            retained = None

        # Actually roll things back.
        for rb in revlog:
            rb.rollback()

            if rb.context.current == self.fixed_rollback_boundary:
                self.rollback_is_fixed = True

            if rb.forward is not None:
                self.forward.insert(0, (rb.context.current, rb.forward))

        if retained is not None:
            retained.rollback_control()
            self.log.append(retained)

        # Disable the next transition, as it's pointless. (Only when not used with a label.)
        renpy.game.interface.suppress_transition = True

        # If necessary, reset the RNG.
        if force:
            rng.reset()
            self.forward = [ ]

        # Flag that we're in the transition immediately after a rollback.
        renpy.game.after_rollback = True

        # Stop the sounds.
        renpy.audio.audio.rollback()

        renpy.game.contexts.extend(other_contexts)

        # Restart the context or the top context.
        if replace_context:
            raise renpy.game.RestartTopContext(label)
        else:
            raise renpy.game.RestartContext(label)


    def freeze(self, wait=None):
        """
        This is called to freeze the store and the log, in preparation
        for serialization. The next call on log should either be
        unfreeze (called after a serialization reload) or discard_freeze()
        (called after the save is complete).
        """

        # Purge unreachable objects, so we don't save them.
        self.complete()
        roots = self.get_roots()
        self.purge_unreachable(roots, wait=wait)

        # The current is not purged.
        self.current.purged = False

        return roots

    def discard_freeze(self):
        """
        Called to indicate that we will not be restoring from the
        frozen state.
        """

    def unfreeze(self, roots, label=None):
        """
        Used to unfreeze the game state after a load of this log
        object. This call will always throw an exception. If we're
        lucky, it's the one that indicates load was successful.

        @param roots: The roots returned from freeze.

        @param label: The label that is jumped to in the game script
        after rollback has finished, if it exists.
        """

        # Fix up old screens.
        renpy.display.screen.before_restart() # @UndefinedVariable

        # Set us up as the game log.
        renpy.game.log = self

        clean_stores()

        for name, value in roots.iteritems():

            if "." in name:
                store_name, name = name.rsplit(".", 1)
            else:
                store_name = "store"

            if store_name not in store_dicts:
                continue

            store = store_dicts[store_name]
            store.ever_been_changed.add(name)

            if value is deleted:
                if name in store:
                    del store[name]
            else:
                store[name] = value

        # Now, rollback to an acceptable point.
        self.rollback(0, force=True, label=label, greedy=False, on_load=True)

        # Because of the rollback, we never make it this far.


def py_exec_bytecode(bytecode, hide=False, globals=None, locals=None, store="store"): #@ReservedAssignment

    if hide:
        locals = { } #@ReservedAssignment

    if globals is None:
        globals = store_dicts[store] #@ReservedAssignment

    if locals is None:
        locals = globals #@ReservedAssignment

    exec bytecode in globals, locals


def py_exec(source, hide=False, store=None):

    if store is None:
        store = store_dicts["store"]

    if hide:
        locals = { } #@ReservedAssignment
    else:
        locals = store #@ReservedAssignment

    exec py_compile(source, 'exec') in store, locals


def py_eval_bytecode(bytecode, globals=None, locals=None): #@ReservedAssignment

    if globals is None:
        globals = store_dicts["store"] #@ReservedAssignment

    if locals is None:
        locals = globals #@ReservedAssignment

    return eval(bytecode, globals, locals)

def py_eval(source, globals=None, locals=None): #@ReservedAssignment

    if globals is None:
        globals = store_dicts["store"] #@ReservedAssignment

    if locals is None:
        locals = globals #@ReservedAssignment

    return eval(py_compile(source, 'eval'), globals, locals)


def raise_at_location(e, loc):
    """
    Raises `e` (which must be an Exception object) at location `loc`.

    `loc`
        A location, which should be a (filename, line_number) tuple.
    """

    filename, line = loc

    node = ast.parse("raise e", filename)
    ast.increment_lineno(node, line - 1)
    code = compile(node, filename, 'exec')

    # PY3 - need to change to exec().
    exec code in { "e" : e }


# This was used to proxy accesses to the store. Now it's kept around to deal
# with cases where it might have leaked into a pickle.
class StoreProxy(object):

    def __getattr__(self, k):
        return getattr(renpy.store, k) #@UndefinedVariable

    def __setattr__(self, k, v):
        setattr(renpy.store, k, v) #@UndefinedVariable

    def __delattr__(self, k):
        delattr(renpy.store, k) #@UndefinedVariable


# Code for pickling bound methods.
def method_pickle(method):
    name = method.im_func.__name__

    obj = method.im_self

    if obj is None:
        obj = method.im_class

    return method_unpickle, (obj, name)

def method_unpickle(obj, name):
    return getattr(obj, name)

import copy_reg
import types
copy_reg.pickle(types.MethodType, method_pickle, method_unpickle)

########NEW FILE########
__FILENAME__ = savelocation
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This contains code for different save locations. A save location is a place
# where we store save data, and can retrieve it from.
#
# The current save location is stored in the location variable in loadsave.py.

import os
import zipfile
import json

import renpy.display
import threading

from renpy.loadsave import clear_slot, safe_rename

disk_lock = threading.RLock()

class FileLocation(object):
    """
    A location that saves files to a directory on disk.
    """

    def __init__(self, directory):
        self.directory = directory

        # Make the save directory.
        try:
            os.makedirs(self.directory)
        except:
            pass

        # Try to write a test file.
        try:
            fn = os.path.join(self.directory, "text.txt")

            with open(fn, "w") as f:
                f.write("Test.")

            os.unlink(fn)

            self.active = True
        except:
            self.active = False

        # A map from slotname to the mtime of that slot.
        self.mtimes = { }

        # The persistent file.
        self.persistent = os.path.join(self.directory, "persistent")

        # The mtime of the persistent file.
        self.persistent_mtime = 0

        # The data loaded from the persistent file.
        self.persistent_data = None


    def filename(self, slotname):
        """
        Given a slot name, returns a filename.
        """

        return os.path.join(self.directory, slotname + renpy.savegame_suffix)


    def scan(self):
        """
        Scan for files that are added or removed.
        """

        if not self.active:
            return

        with disk_lock:

            old_mtimes = self.mtimes
            new_mtimes = { }

            suffix = renpy.savegame_suffix
            suffix_len = len(suffix)

            for fn in os.listdir(self.directory):
                if not fn.endswith(suffix):
                    continue

                slotname = fn[:-suffix_len]

                try:
                    new_mtimes[slotname] = os.path.getmtime(os.path.join(self.directory, fn))
                except:
                    pass

            self.mtimes = new_mtimes

            for slotname, mtime in new_mtimes.iteritems():
                if old_mtimes.get(slotname, None) != mtime:
                    clear_slot(slotname)

            for slotname in old_mtimes:
                if slotname not in new_mtimes:
                    clear_slot(slotname)

            if os.path.exists(self.persistent):
                mtime = os.path.getmtime(self.persistent)

                if mtime != self.persistent_mtime:
                    data = renpy.persistent.load(self.persistent)
                    self.persistent_mtime = mtime
                    self.persistent_data = data


    def save(self, slotname, record):
        """
        Saves the save record in slotname.
        """

        filename = self.filename(slotname)

        with disk_lock:
            record.write_file(filename)

        self.scan()

    def list(self):
        """
        Returns a list of all slots with savefiles in them, in arbitrary
        order.
        """

        return list(self.mtimes)


    def mtime(self, slotname):
        """
        For a slot, returns the time the object was saved in that
        slot.

        Returns None if the slot is empty.
        """

        return self.mtimes.get(slotname, None)


    def json(self, slotname):
        """
        Returns the JSON data for slotname.

        Returns None if the slot is empty.
        """

        with disk_lock:

            try:
                filename = self.filename(slotname)
                zf = zipfile.ZipFile(filename, "r")
            except:
                return None

            try:

                try:
                    data = zf.read("json")
                    data = json.loads(data)
                    return data
                except:
                    pass

                try:
                    extra_info = zf.read("extra_info").decode("utf-8")
                    return { "_save_name" : extra_info }
                except:
                    pass

                return { }

            finally:
                zf.close()


    def screenshot(self, slotname):
        """
        Returns a displayable that show the screenshot for this slot.

        Returns None if the slot is empty.
        """

        with disk_lock:

            mtime = self.mtime(slotname)

            if mtime is None:
                return None

            try:
                filename = self.filename(slotname)
                zf = zipfile.ZipFile(filename, "r")
            except:
                return None

            try:
                png = False
                zf.getinfo('screenshot.tga')
            except:
                png = True
                zf.getinfo('screenshot.png')

            zf.close()

            if png:
                screenshot = renpy.display.im.ZipFileImage(filename, "screenshot.png", mtime)
            else:
                screenshot = renpy.display.im.ZipFileImage(filename, "screenshot.tga", mtime)

            return screenshot

    def load(self, slotname):
        """
        Returns the log component of the file found in `slotname`, so it
        can be loaded.
        """

        with disk_lock:

            filename = self.filename(slotname)

            zf = zipfile.ZipFile(filename, "r")
            rv = zf.read("log")
            zf.close()

            return rv

    def unlink(self, slotname):
        """
        Deletes the file in slotname.
        """

        with disk_lock:

            filename = self.filename(slotname)
            if os.path.exists(filename):
                os.unlink(filename)

            self.scan()


    def rename(self, old, new):
        """
        If old exists, renames it to new.
        """

        with disk_lock:

            old = self.filename(old)
            new = self.filename(new)

            if not os.path.exists(old):
                return

            if os.path.exists(new):
                os.unlink(new)

            os.rename(old, new)

            self.scan()


    def load_persistent(self):
        """
        Returns a list of (mtime, persistent) tuples loaded from the
        persistent file. This should return quickly, with the actual
        load occuring in the scan thread.
        """

        if self.persistent_data:
            return [ (self.persistent_mtime, self.persistent_data) ]
        else:
            return [ ]

    def save_persistent(self, data):
        """
        Saves `data` as the persistent data. Data is a binary string giving
        the persistent data in python format.
        """

        with disk_lock:

            if not self.active:
                return

            fn = self.persistent
            fn_new = fn + ".new"

            with open(fn_new, "wb") as f:
                f.write(data)

            safe_rename(fn_new, fn)

    def unlink_persistent(self):

        if not self.active:
            return

        try:
            os.unlink(self.persistent)
        except:
            pass

    def __eq__(self, other):
        if not isinstance(other, FileLocation):
            return False

        return self.directory == other.directory

class MultiLocation(object):
    """
    A location that saves in multiple places. When loading or otherwise
    accessing a file, it loads the newest file found for the given slotname.
    """

    def __init__(self):
        self.locations = [ ]

    def active_locations(self):
        return [ i for i in self.locations if i.active ]

    def newest(self, slotname):
        """
        Returns the location containing the slotname with the newest
        mtime. Returns None of the slot is empty.
        """

        mtime = -1
        location = None

        for l in self.locations:
            if not l.active:
                continue

            slot_mtime = l.mtime(slotname)

            if slot_mtime > mtime:
                mtime = slot_mtime
                location = l

        return location

    def add(self, location):
        """
        Adds a new location.
        """

        if location in self.locations:
            return

        self.locations.append(location)

    def save(self, slotname, record):

        saved = False

        for l in self.active_locations():
            l.save(slotname, record)
            saved = True

        if not saved:
            raise Exception("Not saved - no valid save locations.")

    def list(self):
        rv = set()

        for l in self.active_locations():
            rv.update(l.list())

        return list(rv)

    def mtime(self, slotname):
        l = self.newest(slotname)

        if l is None:
            return None

        return l.mtime(slotname)

    def json(self, slotname):
        l = self.newest(slotname)

        if l is None:
            return None

        return l.json(slotname)


    def screenshot(self, slotname):
        l = self.newest(slotname)

        if l is None:
            return None

        return l.screenshot(slotname)

    def load(self, slotname):
        l = self.newest(slotname)
        return l.load(slotname)

    def unlink(self, slotname):
        for l in self.active_locations():
            l.unlink(slotname)

    def rename(self, old, new):
        for l in self.active_locations():
            l.rename(old, new)


    def load_persistent(self):
        rv = [ ]

        for l in self.active_locations():
            rv.extend(l.load_persistent())

        return rv

    def save_persistent(self, data):

        for l in self.active_locations():
            l.save_persistent(data)


    def unlink_persistent(self):

        for l in self.active_locations():
            l.unlink_persistent()

    def scan(self):
        # This should scan everything, as a scan can help decide if a
        # location should become active or inactive.

        for l in self.locations:
            l.scan()

    def __eq__(self, other):
        if not isinstance(other, MultiLocation):
            return False

        return self.locations == other.locations


# The thread that scans locations every few seconds.
scan_thread = None

# True if we should quit the scan thread.
quit_scan_thread = False

# The condition we wait on.
scan_thread_condition = threading.Condition()

def run_scan_thread():
    global quit_scan_thread

    quit_scan_thread = False

    while not quit_scan_thread:

        try:
            renpy.loadsave.location.scan()  # @UndefinedVariable
        except:
            pass

        with scan_thread_condition:
            scan_thread_condition.wait(5.0)

def quit():  # @ReservedAssignment
    global quit_scan_thread

    with scan_thread_condition:
        quit_scan_thread = True
        scan_thread_condition.notifyAll()

    scan_thread.join()

def init():
    global scan_thread

    location = MultiLocation()

    # 1. User savedir.
    location.add(FileLocation(renpy.config.savedir))

    # 2. Game-local savedir. (TODO: Check to see if writable.)
    path = os.path.join(renpy.config.gamedir, "saves")
    location.add(FileLocation(path))

    # Scan the location once.
    location.scan()

    renpy.loadsave.location = location

    scan_thread = threading.Thread(target=run_scan_thread)
    scan_thread.start()


########NEW FILE########
__FILENAME__ = screenlang
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display
import contextlib

# Grab the python versions of the parser and ast modules.
ast = __import__("ast")

# The filename of the file we're parsing.
filename = None

new_variable_serial = 0

# Returns the name of a new variable.
@contextlib.contextmanager
def new_variable():
    global new_variable_serial

    new_variable_serial += 1
    yield "_%d" % new_variable_serial
    new_variable_serial -= 1

def increment_lineno(node, amount):
    for node in ast.walk(node):
        if hasattr(node, 'lineno'):
            node.lineno += amount

class LineNumberNormalizer(ast.NodeVisitor):

    def __init__(self):
        self.last_line = 1

    def generic_visit(self, node):

        if hasattr(node, 'lineno'):
            self.last_line = max(self.last_line, node.lineno)
            node.lineno = self.last_line

        super(LineNumberNormalizer, self).generic_visit(node)


##############################################################################
# Parsing.

# The parser that things are being added to.
parser = None

class Positional(object):
    """
    This represents a positional parameter to a function.
    """

    def __init__(self, name):
        self.name = name

        if parser:
            parser.add(self)

# Used to generate the documentation
all_keyword_names = set()

class Keyword(object):
    """
    This represents an optional keyword parameter to a function.
    """

    def __init__(self, name):
        self.name = name

        all_keyword_names.add(self.name)

        if parser:
            parser.add(self)

STYLE_PREFIXES = [
    '',
    'insensitive_',
    'hover_',
    'idle_',
    'activate_',
    'selected_',
    'selected_insensitive_',
    'selected_hover_',
    'selected_idle_',
    'selected_activate_',
]

class Style(object):
    """
    This represents a style parameter to a function.
    """

    def __init__(self, name):
        self.name = name

        for j in STYLE_PREFIXES:
            all_keyword_names.add(j + self.name)

        if parser:
            parser.add(self)


class PrefixStyle(object):
    """
    This represents a prefixed style parameter to a function.
    """

    def __init__(self, prefix, name):
        self.prefix = prefix
        self.name = name

        for j in STYLE_PREFIXES:
            all_keyword_names.add(prefix + j + self.name)

        if parser:
            parser.add(self)


class Parser(object):

    def __init__(self, name):

        # The name of this object.
        self.name = name

        # The positional arguments, keyword arguments, and child
        # statements of this statement.
        self.positional = [ ]
        self.keyword = { }
        self.children = { }

        all_statements.append(self)

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.name)

    def add(self, i):
        """
        Adds a clause to this parser.
        """

        if isinstance(i, list):
            for j in i:
                self.add(j)

            return

        if isinstance(i, Positional):
            self.positional.append(i)

        elif isinstance(i, Keyword):
            self.keyword[i.name] = i

        elif isinstance(i, Style):
            for j in STYLE_PREFIXES:
                self.keyword[j + i.name] = i

        elif isinstance(i, PrefixStyle):
            for j in STYLE_PREFIXES:
                self.keyword[i.prefix + j + i.name] = i

        elif isinstance(i, Parser):
            self.children[i.name] = i

    def parse_statement(self, l, name, layout_mode=False):
        word = l.word() or l.match(r'\$')

        if word and word in self.children:
            if layout_mode:
                c = self.children[word].parse_layout(l, name)
            else:
                c = self.children[word].parse(l, name)

            return c
        else:
            return None

    def parse_layout(self, l, name):
        l.error("The %s statement cannot be used as a container for the has statement." % self.name)

    def parse_children(self, stmt, l, name):
        l.expect_block(stmt)

        l = l.subblock_lexer()

        rv = [ ]

        with new_variable() as child_name:

            count = 0

            while l.advance():

                if len(l.block) != 1:
                    rv.extend(self.parse_exec("%s = (%s, %d)" % (child_name, name, count), l.number))
                else:
                    child_name = name

                c = self.parse_statement(l, child_name)
                if c is None:
                    l.error('Expected screen language statement.')

                rv.extend(c)
                count += 1


        return rv

    def parse_eval(self, expr, lineno=1):
        """
        Parses an expression for eval, and then strips off the module
        and expr instances, and adjusts the line number.
        """

        if isinstance(expr, unicode):
            expr = renpy.python.escape_unicode(expr)

        try:
            rv = ast.parse(expr, 'eval').body[0].value
        except SyntaxError, e:
            raise renpy.parser.ParseError(
                filename,
                lineno + e[1][1] - 1,
                "Syntax error while parsing python expression.",
                e[1][3],
                e[1][2])

        increment_lineno(rv, lineno-1)

        return rv

    def parse_exec(self, code, lineno=1):
        """
        Parses an expression for exec, then strips off the module and
        adjusts the line number. Returns a list of statements.
        """

        if isinstance(code, unicode):
            code = renpy.python.escape_unicode(code)

        try:
            rv = ast.parse(code, 'exec')
        except SyntaxError, e:

            raise renpy.parser.ParseError(
                filename,
                lineno + e[1][1] - 1,
                "Syntax error while parsing python code.",
                e[1][3],
                e[1][2])

        increment_lineno(rv, lineno-1)

        return rv.body

    def parse_simple_expression(self, l):
        lineno = l.number
        expr = l.require(l.simple_expression)

        return self.parse_eval(expr, lineno)

    def parse_comma_expression(self, l):
        lineno = l.number
        expr = l.require(l.comma_expression)

        return self.parse_eval(expr, lineno)

    def parse(self, l, name):
        """
        This is expected to parse a function statement, and to return
        a list of python ast statements.

        `l` the lexer.

        `name` the name of the variable containing the name of the
        current statement.
        """

        raise Exception("Not Implemented")


# A singleton value.
many = renpy.object.Sentinel("many")

class FunctionStatementParser(Parser):
    """
    This is responsible for parsing function statements.
    """

    def __init__(self, name, function, nchildren=0, unevaluated=False, scope=False):

        super(FunctionStatementParser, self).__init__(name)

        # Functions that are called when this statement runs.
        self.function = function

        # The number of children we have.
        self.nchildren = nchildren

        # True if we should evaluate arguments and children. False
        # if we should just pass them into our child.
        self.unevaluated = unevaluated

        # Add us to the appropriate lists.
        global parser
        parser = self

        if nchildren != 0:
            childbearing_statements.append(self)

        self.scope = scope

    def parse_layout(self, l, name):
        return self.parse(l, name, True)

    def parse(self, l, name, layout_mode=False):

        # The list of nodes this function returns.
        rv = [ ]

        # The line number of the current node.
        lineno = l.number

        if layout_mode and self.nchildren == 0:
            l.error("The %s statement cannot be used as a layout." % self.name)

        func = self.parse_eval(self.function, lineno)

        call_node = ast.Call(
            lineno=lineno,
            col_offset=0,
            func=func,
            args=[ ],
            keywords=[ ],
            starargs=None,
            kwargs=None,
            )

        seen_keywords = set()

        # Parses a keyword argument from the lexer.
        def parse_keyword(l, expect):
            name = l.word()

            if name is None:
                l.error(expect)

            if name not in self.keyword:
                l.error('%r is not a keyword argument or valid child for the %s statement.' % (name, self.name))

            if name in seen_keywords:
                l.error('keyword argument %r appears more than once in a %s statement.' % (name, self.name))

            seen_keywords.add(name)

            expr = self.parse_comma_expression(l)

            call_node.keywords.append(
                ast.keyword(arg=str(name), value=expr),
                )

        # We assume that the initial keyword has been parsed already,
        # so we start with the positional arguments.

        for _i in self.positional:
            call_node.args.append(self.parse_simple_expression(l))

        # Next, we allow keyword arguments on the starting line.
        while True:
            if l.match(':'):
                l.expect_eol()
                l.expect_block(self.name)
                block = True
                break

            if l.eol():
                l.expect_noblock(self.name)
                block = False
                break

            parse_keyword(l, "expected a keyword argument, colon, or end of line.")

        rv.append(ast.Expr(value=call_node))

        if self.nchildren == 1:
            rv.extend(self.parse_exec('ui.child_or_fixed()'))

        needs_close = (self.nchildren != 0)

        # The index of the child we're adding to this statement.
        child_index = 0

        # A list of lexers we need to parse the contents of.
        lexers = [ ]

        if block:
            lexers.append(l.subblock_lexer())

        if layout_mode:
            lexers.append(l)

        # The variable we store the child's name in.
        with new_variable() as child_name:

            # If we have a block, parse it. This also takes care of parsing the
            # block of a has clause.

            for l in lexers:

                while l.advance():

                    state = l.checkpoint()

                    if l.keyword(r'has'):
                        if self.nchildren != 1:
                            l.error("The %s statement does not take a layout." % self.name)

                        if child_index != 0:
                            l.error("The has statement may not be given after a child has been supplied.")

                        c = self.parse_statement(l, child_name, layout_mode=True)

                        if c is None:
                            l.error('Has expects a child statement.')

                        # Remove the call to child_or_fixed.
                        rv.pop()

                        rv.extend(self.parse_exec("%s = (%s, %d)" % (child_name, name, child_index)))
                        rv.extend(c)

                        needs_close = False

                        continue

                    c = self.parse_statement(l, child_name)

                    if c is not None:

                        rv.extend(self.parse_exec("%s = (%s, %d)" % (child_name, name, child_index)))
                        rv.extend(c)

                        child_index += 1

                        continue

                    l.revert(state)

                    if not l.eol():
                        parse_keyword(l, "expected a keyword argument or child statement.")

                    while not l.eol():
                        parse_keyword(l, "expected a keyword argument or end of line.")

        if needs_close:
            rv.extend(self.parse_exec("ui.close()"))

        if "id" not in seen_keywords:
            call_node.keywords.append(ast.keyword(arg="id", value=self.parse_eval(name, lineno)))

        if "scope" not in seen_keywords and self.scope:
            call_node.keywords.append(ast.keyword(arg="scope", value=self.parse_eval("_scope", lineno)))

        return rv


##############################################################################
# Definitions of screen language statements.

# Used to allow statements to take styles.
styles = [ ]

# All statements defined, and statements that take children.
all_statements = [ ]
childbearing_statements = [ ]

position_property_names = [
        "anchor",
        "xanchor",
        "yanchor",
        "pos",
        "xpos",
        "ypos",
        "align",
        "xalign",
        "yalign",
        "xoffset",
        "yoffset",
        "maximum",
        "xmaximum",
        "ymaximum",
        "area",
        "clipping",
        "xfill",
        "yfill",
        # no center, since it can conflict with the center transform.
        "xcenter",
        "ycenter",
        "xsize",
        "ysize",
        "xysize",
        ]

position_properties = [ Style(i) for i in position_property_names ]
text_position_properties = [ PrefixStyle("text_", i) for i in position_property_names ]
side_position_properties = [ PrefixStyle("side_", i) for i in position_property_names ]

text_property_names = [
        "antialias",
        "vertical",
        "black_color",
        "bold",
        "color",
        "drop_shadow",
        "drop_shadow_color",
        "first_indent",
        "font",
        "size",
        "hyperlink_functions",
        "italic",
        "justify",
        "kerning",
        "language",
        "layout",
        "line_leading",
        "line_spacing",
        "minwidth",
        "min_width",
        "newline_indent",
        "outlines",
        "rest_indent",
        "ruby_style",
        "slow_cps",
        "slow_cps_multiplier",
        "slow_abortable",
        "strikethrough",
        "text_align",
        "text_y_fudge",
        "underline",
        "minimum",
        "xminimum",
        "yminimum",
        ]

text_properties = [ Style(i) for i in text_property_names ]
text_text_properties = [ PrefixStyle("text_", i) for i in text_property_names ]

window_properties = [ Style(i) for i in [
        "background",
        "foreground",
        "left_margin",
        "right_margin",
        "bottom_margin",
        "top_margin",
        "xmargin",
        "ymargin",
        "left_padding",
        "right_padding",
        "top_padding",
        "bottom_padding",
        "xpadding",
        "ypadding",
        "size_group",
        "minimum",
        "xminimum",
        "yminimum",
        ] ]

button_properties = [ Style(i) for i in [
        "sound",
        "mouse",
        "focus_mask",
        "child",
        ] ]

bar_properties = [ Style(i) for i in [
        "bar_vertical",
        "bar_invert",
        "bar_resizing",
        "left_gutter",
        "right_gutter",
        "top_gutter",
        "bottom_gutter",
        "left_bar",
        "right_bar",
        "top_bar",
        "bottom_bar",
        "thumb",
        "thumb_shadow",
        "thumb_offset",
        "mouse",
        "unscrollable",
        ] ]

box_properties = [ Style(i) for i in [
        "box_layout",
        "box_wrap",
        "box_reverse",
        "order_reverse",
        "spacing",
        "first_spacing",
        "fit_first",
        "minimum",
        "xminimum",
        "yminimum",
        ] ]

ui_properties = [
    Keyword("at"),
    Keyword("id"),
    Keyword("style"),
    Keyword("style_group"),
    Keyword("focus"),
    Keyword("default"),
    ]


def add(thing):
    parser.add(thing)


##############################################################################
# UI statements.

FunctionStatementParser("null", "ui.null", 0)
Keyword("width")
Keyword("height")
add(ui_properties)
add(position_properties)


FunctionStatementParser("text", "ui.text", 0, scope=True)
Positional("text")
Keyword("slow")
Keyword("slow_done")
Keyword("substitute")
Keyword("scope")
add(ui_properties)
add(position_properties)
add(text_properties)

FunctionStatementParser("hbox", "ui.hbox", many)
add(ui_properties)
add(position_properties)
add(box_properties)

FunctionStatementParser("vbox", "ui.vbox", many)
add(ui_properties)
add(position_properties)
add(box_properties)

FunctionStatementParser("fixed", "ui.fixed", many)
add(ui_properties)
add(position_properties)
add(box_properties)

FunctionStatementParser("grid", "ui.grid", many)
Positional("cols")
Positional("rows")
Keyword("transpose")
Style("spacing")
add(ui_properties)
add(position_properties)

FunctionStatementParser("side", "ui.side", many)
Positional("positions")
Style("spacing")
add(ui_properties)
add(position_properties)

# Omit sizer, as we can always just put an xmaximum and ymaximum on an item.

for name in [ "window", "frame" ]:
    FunctionStatementParser(name, "ui." + name, 1)
    add(ui_properties)
    add(position_properties)
    add(window_properties)

FunctionStatementParser("key", "ui.key", 0)
Positional("key")
Keyword("action")

FunctionStatementParser("timer", "ui.timer", 0)
Positional("delay")
Keyword("action")
Keyword("repeat")

# Omit behaviors.
# Omit menu as being too high-level.

FunctionStatementParser("input", "ui.input", 0)
Keyword("default")
Keyword("length")
Keyword("allow")
Keyword("exclude")
Keyword("prefix")
Keyword("suffix")
Keyword("changed")
Keyword("pixel_width")
add(ui_properties)
add(position_properties)
add(text_properties)

FunctionStatementParser("image", "ui.image", 0)
Positional("im")

# Omit imagemap_compat for being too high level (and obsolete).

FunctionStatementParser("button", "ui.button", 1)
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Keyword("alternate")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)

FunctionStatementParser("imagebutton", "ui.imagebutton", 0)
Keyword("auto")
Keyword("idle")
Keyword("hover")
Keyword("insensitive")
Keyword("selected_idle")
Keyword("selected_hover")
Keyword("selected_insensitive")
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Keyword("alternate")
Keyword("image_style")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)

FunctionStatementParser("textbutton", "ui.textbutton", 0, scope=True)
Positional("label")
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Keyword("alternate")
Keyword("text_style")
Keyword("substitute")
Keyword("scope")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)
add(text_position_properties)
add(text_text_properties)

FunctionStatementParser("label", "ui.label", 0, scope=True)
Positional("label")
Keyword("text_style")
add(ui_properties)
add(position_properties)
add(window_properties)
add(text_position_properties)
add(text_text_properties)

for name in [ "bar", "vbar" ]:
    FunctionStatementParser(name, "ui." + name, 0)
    Keyword("adjustment")
    Keyword("range")
    Keyword("value")
    Keyword("changed")
    Keyword("hovered")
    Keyword("unhovered")
    add(ui_properties)
    add(position_properties)
    add(bar_properties)

# Omit autobar. (behavior)

FunctionStatementParser("viewport", "ui.viewport", 1)
Keyword("child_size")
Keyword("mousewheel")
Keyword("draggable")
Keyword("edgescroll")
Keyword("xadjustment")
Keyword("yadjustment")
Keyword("xinitial")
Keyword("yinitial")
Keyword("scrollbars")
PrefixStyle("side_", "spacing")
add(ui_properties)
add(position_properties)
add(side_position_properties)

# Omit conditional. (behavior)

FunctionStatementParser("imagemap", "ui.imagemap", many)
Keyword("ground")
Keyword("hover")
Keyword("insensitive")
Keyword("idle")
Keyword("selected_hover")
Keyword("selected_idle")
Keyword("selected_insensitive")
Keyword("auto")
Keyword("alpha")
Keyword("cache")
add(ui_properties)
add(position_properties)

FunctionStatementParser("hotspot", "ui.hotspot_with_child", 1)
Positional("spot")
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)

FunctionStatementParser("hotbar", "ui.hotbar", 0)
Positional("spot")
Keyword("adjustment")
Keyword("range")
Keyword("value")
add(ui_properties)
add(position_properties)
add(bar_properties)


FunctionStatementParser("transform", "ui.transform", 1)
Keyword("at")
Keyword("id")
for i in renpy.atl.PROPERTIES:
    Style(i)

FunctionStatementParser("add", "ui.add", 0)
Positional("im")
Keyword("at")
Keyword("id")
for i in renpy.atl.PROPERTIES:
    Style(i)

FunctionStatementParser("on", "ui.on", 0)
Positional("event")
Keyword("action")

FunctionStatementParser("drag", "ui.drag", 1)
Keyword("drag_name")
Keyword("draggable")
Keyword("droppable")
Keyword("drag_raise")
Keyword("dragged")
Keyword("dropped")
Keyword("drag_handle")
Keyword("drag_joined")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Style("child")
add(ui_properties)
add(position_properties)

FunctionStatementParser("draggroup", "ui.draggroup", many)
add(ui_properties)
add(position_properties)

FunctionStatementParser("mousearea", "ui.mousearea", 0)
Keyword("hovered")
Keyword("unhovered")
add(ui_properties)
add(position_properties)


##############################################################################
# Control-flow statements.

class PassParser(Parser):

    def __init__(self, name):
        super(PassParser, self).__init__(name)

    def parse(self, l, name):
        return self.parse_exec("pass", l.number)

PassParser("pass")


class DefaultParser(Parser):

    def __init__(self, name):
        super(DefaultParser, self).__init__(name)

    def parse(self, l, name):

        name = l.require(l.word)
        l.require(r'=')
        rest = l.rest()

        code = "_scope.setdefault(%r, (%s))" % (name, rest)

        return self.parse_exec(code, l.number)

DefaultParser("default")


class UseParser(Parser):

    def __init__(self, name):
        super(UseParser, self).__init__(name)
        childbearing_statements.append(self)

    def parse(self, l, name):

        lineno = l.number

        target_name = l.require(l.word)

        code = "renpy.use_screen(%r" % target_name

        args = renpy.parser.parse_arguments(l)

        if args:

            for k, v in args.arguments:
                if k is None:
                    code += ", (%s)" % v
                else:
                    code += ", %s=(%s)" % (k, v)

        code += ", _name=%s, _scope=_scope" % name

        if args:

            if args.extrapos:
                code += ", *(%s)" % args.extrapos

            if args.extrakw:
                code += ", **(%s)" % args.extrakw

        code += ")"

        return self.parse_exec(code, lineno)

UseParser("use")


class IfParser(Parser):

    def __init__(self, name):
        super(IfParser, self).__init__(name)
        childbearing_statements.append(self)

    def parse(self, l, name):

        with new_variable() as child_name:

            count = 0

            lineno = l.number
            condition = self.parse_eval(l.require(l.python_expression), lineno)

            l.require(':')
            l.expect_eol()

            body = self.parse_exec("%s = (%s, %d)" % (child_name, name, count))
            body.extend(self.parse_children('if', l, child_name))

            orelse = [ ]

            rv = ast.If(test=condition, body=body, orelse=orelse, lineno=lineno, col_offset=0)

            count += 1

            state = l.checkpoint()

            while l.advance():

                old_orelse = orelse
                lineno = l.number

                if l.keyword("elif"):
                    condition = self.parse_eval(l.require(l.python_expression), lineno)

                    body = self.parse_exec("%s = (%s, %d)" % (child_name, name, count))
                    body.extend(self.parse_children('if', l, child_name))

                    orelse = [ ]
                    old_orelse.append(ast.If(test=condition, body=body, orelse=orelse, lineno=lineno, col_offset=0))

                    count += 1

                    state = l.checkpoint()

                elif l.keyword("else"):

                    old_orelse.extend(self.parse_exec("%s = (%s, %d)" % (child_name, name, count)))
                    old_orelse.extend(self.parse_children('if', l, child_name))

                    break

                else:
                    l.revert(state)
                    break

        return [ rv ]

IfParser("if")


class ForParser(Parser):

    def __init__(self, name):
        super(ForParser, self).__init__(name)
        childbearing_statements.append(self)

    def parse_tuple_pattern(self, l):

        is_tuple = False
        pattern = [ ]

        while True:

            lineno = l.number

            if l.match(r"\("):
                p = self.parse_tuple_pattern(l)
            else:
                p = l.name().encode("utf-8")

            if not p:
                break

            pattern.append(ast.Name(id=p, ctx=ast.Store(), lineno=lineno, col_offset=0))

            if l.match(r","):
                is_tuple = True
            else:
                break

        if not pattern:
            l.error("Expected tuple pattern.")

        if not is_tuple:
            return pattern[0]
        else:
            return ast.Tuple(elts=pattern, ctx=ast.Store())

    def parse(self, l, name):

        lineno = l.number

        pattern = self.parse_tuple_pattern(l)

        l.require('in')

        expression = self.parse_eval(l.require(l.python_expression), l.number)

        l.require(':')
        l.expect_eol()

        with new_variable() as counter_name:

            with new_variable() as child_name:

                children = self.parse_exec("%s = (%s, %s)" % (child_name, name, counter_name))
                children.extend(self.parse_children('for', l, child_name))
                children.extend(self.parse_exec("%s += 1" % counter_name))

            rv = self.parse_exec("%s = 0" % counter_name)

            rv.append(ast.For(
                    target=pattern,
                    iter=expression,
                    body=children,
                    orelse=[],
                    lineno=lineno,
                    col_offset=0))

        return rv

ForParser("for")


class PythonParser(Parser):

    def __init__(self, name, one_line):
        super(PythonParser, self).__init__(name)

        self.one_line = one_line

    def parse(self, l, name):
        lineno = l.number

        if self.one_line:
            python_code = l.rest()
            l.expect_noblock('one-line python statement')
        else:
            l.require(':')
            l.expect_block('python block')

            python_code = l.python_block()
            lineno += 1

        return self.parse_exec(python_code, lineno)

PythonParser("$", True)
PythonParser("python", False)


##############################################################################
# Add all_statements to the statements that take children.

for i in childbearing_statements:
    i.add(all_statements)

##############################################################################
# Definition of the screen statement.

# class ScreenFunction(renpy.object.Object):

#     def __init__(self, children):
#         self.children = children

#     def __call__(self, _name=(), _scope=None, **kwargs):

#         for i, child in enumerate(self.children):
#             child.evaluate(_name + (i,), _scope)

# def screen_function(positional, keyword, children):
#     name = renpy.python.py_eval(positional[0].source)
#     function = ScreenFunction(children)

#     values = {
#         "name" : name,
#         "function" : function,
#         }

#     for k, v in keyword.iteritems():
#         values[k] = renpy.python.py_eval(v.source)

#     return values


# screen_stmt = FunctionStatementParser("screen", screen_function, unevaluated=True)
# Positional("name", Word)
# Keyword("modal", Expression)
# Keyword("zorder", Expression)
# Keyword("tag", Word)
# add(all_statements)

class ScreenLangScreen(renpy.object.Object):
    """
    This represents a screen defined in the screen language.
    """

    __version__ = 1

    variant = "None"

    # Predict should be false for screens created before
    # prediction existed.
    predict = "False"

    parameters = None

    def __init__(self):

        # The name of the screen.
        self.name = name

        # Should this screen be declared as modal?
        self.modal = "False"

        # The screen's zorder.
        self.zorder = "0"

        # The screen's tag.
        self.tag = None

        # The PyCode object containing the screen's code.
        self.code = None

        # The variant of screen we're defining.
        self.variant = "None" # expr.

        # Should we predict this screen?
        self.predict = "None" # expr.

        # The parameters this screen takes.
        self.parameters = None

    def after_upgrade(self, version):
        if version < 1:
            self.modal = "False"
            self.zorder = "0"

    def define(self):
        """
        Defines a screen.
        """

        renpy.display.screen.define_screen(
            self.name,
            self,
            modal=self.modal,
            zorder=self.zorder,
            tag=self.tag,
            variant=renpy.python.py_eval(self.variant),
            predict=renpy.python.py_eval(self.predict),
            parameters=self.parameters,
            )

    def __call__(self, *args, **kwargs):
        scope = kwargs["_scope"]

        if self.parameters:

            args = scope.get("_args", ())
            kwargs = scope.get("_kwargs", { })

            values = renpy.ast.apply_arguments(self.parameters, args, kwargs)
            scope.update(values)

        renpy.python.py_exec_bytecode(self.code.bytecode, locals=scope)



class ScreenParser(Parser):

    def __init__(self):
        super(ScreenParser, self).__init__("screen")

    def parse(self, l, name="_name"):

        location = l.get_location()
        screen = ScreenLangScreen()

        def parse_keyword(l):
            if l.match('modal'):
                screen.modal = l.require(l.simple_expression)
                return True

            if l.match('zorder'):
                screen.zorder = l.require(l.simple_expression)
                return True

            if l.match('tag'):
                screen.tag = l.require(l.word)
                return True

            if l.match('variant'):
                screen.variant = l.require(l.simple_expression)
                return True

            if l.match('predict'):
                screen.predict = l.require(l.simple_expression)
                return True

            return False

        lineno = l.number

        screen.name = l.require(l.word)
        screen.parameters = renpy.parser.parse_parameters(l)

        while parse_keyword(l):
            continue

        l.require(':')
        l.expect_eol()
        l.expect_block('screen statement')

        l = l.subblock_lexer()

        rv = [ ]
        count = 0

        with new_variable() as child_name:

            while l.advance():

                if parse_keyword(l):
                    while parse_keyword(l):
                        continue

                    l.expect_eol()
                    continue

                rv.extend(self.parse_exec("%s = (%s, %d)" % (child_name, name, count), l.number))

                c = self.parse_statement(l, child_name)

                if c is None:
                    l.error('Expected a screen language statement.')

                rv.extend(c)
                count += 1

        node = ast.Module(body=rv, lineno=lineno, col_offset=0)
        ast.fix_missing_locations(node)
        LineNumberNormalizer().visit(node)

        # Various bits of debugging code:

        # print ast.dump(node, True, True)

        # a = compile(node, 'foo', 'exec')
        # import dis
        # dis.dis(a)

#        import unparse
#        print
#        print screen.name, "-----------------------------------------"
#        unparse.Unparser(node)

        screen.code = renpy.ast.PyCode(node, location, 'exec')

        return screen

screen_parser = ScreenParser()
screen_parser.add(all_statements)

def parse_screen(l):
    """
    Parses the screen statement.
    """

    global filename

    filename = l.filename

    screen = screen_parser.parse(l)
    return screen

########NEW FILE########
__FILENAME__ = script
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains code that is responsible for storing and executing a
# Ren'Py script.

import renpy

import os
import imp
import difflib
import md5
import time
import marshal

from cPickle import loads, dumps

# The version of the dumped script.
script_version = renpy.script_version

# The version of the bytecode cache.
BYTECODE_VERSION = 1

# The python magic code.
MAGIC = imp.get_magic()

class ScriptError(Exception):
    """
    Exception that is raised if the script is somehow inconsistent,
    or otherwise wrong.
    """

def collapse_stmts(stmts):
    """
    Returns a flat list containing every statement in the tree
    stmts.
    """

    all_stmts = [ ]

    def extend_all(block_list):
        for i in block_list:
            all_stmts.append(i)
            extend_all(i.get_children())


    extend_all(stmts)

    return all_stmts


class Script(object):
    """
    This class represents a Ren'Py script, which is parsed out of a
    collection of script files. Once parsing and initial analysis is
    complete, this object can be serialized out and loaded back in,
    so it shouldn't change at all after that has happened.

    @ivar namemap: A map from the name of an AST node to the AST node
    itself.  This is used for jumps, calls, and to find the current
    node when loading back in a save. The names may be strings or
    integers, strings being explicit names provided by the user, and
    integers being names synthesised by renpy.

    @ivar initcode: A list of priority, Node tuples that should be
    executed in ascending priority order at init time.

    @ivar all_stmts: A list of all statements, that have been found
    in every file. Useful for lint, but tossed if lint is not performed
    to save memory.

    """

    def __init__(self):
        """
        Loads the script by parsing all of the given files, and then
        walking the various ASTs to initialize this Script object.
        """

        # Set us up as renpy.game.script, so things can use us while
        # we're loading.
        renpy.game.script = self

        if os.path.exists(renpy.config.renpy_base + "/lock.txt"):
            self.key = file(renpy.config.renpy_base + "/lock.txt", "rb").read()
        else:
            self.key = None

        self.namemap = { }
        self.all_stmts = [ ]
        self.all_pycode = [ ]
        self.record_pycode = True

        # Bytecode caches.
        self.bytecode_oldcache = { }
        self.bytecode_newcache = { }
        self.bytecode_dirty = False

        self.translator = renpy.translation.ScriptTranslator()

        self.init_bytecode()
        self.scan_script_files()

        self.translator.chain_translates()

        self.serial = 0

    def scan_script_files(self):
        """
        Scan the directories for script files.
        """

        # A list of all files in the search directories.
        dirlist = renpy.loader.listdirfiles()

        # A list of directory, filename w/o extension pairs. This is
        # what we will load immediately.
        self.script_files = [ ]

        # Similar, but for modules:
        self.module_files = [ ]

        for dir, fn in dirlist: #@ReservedAssignment

            if fn.endswith(".rpy"):
                if dir is None:
                    continue

                fn = fn[:-4]
                target = self.script_files
            elif fn.endswith(".rpyc"):
                fn = fn[:-5]
                target = self.script_files
            elif fn.endswith(".rpym"):
                if dir is None:
                    continue

                fn = fn[:-5]
                target = self.module_files
            elif fn.endswith(".rpymc"):
                fn = fn[:-6]
                target = self.module_files
            else:
                continue

            if (fn, dir) not in target:
                target.append((fn, dir))

    def load_script(self):

        script_files = self.script_files

        # Sort script files by filename.
        script_files.sort()

        initcode = [ ]

        for fn, dir in script_files: #@ReservedAssignment
            self.load_appropriate_file(".rpyc", ".rpy", dir, fn, initcode)

        # Make the sort stable.
        initcode = [ (prio, index, code) for index, (prio, code) in
                     enumerate(initcode) ]

        initcode.sort()

        self.initcode = [ (prio, code) for prio, index, code in initcode ]


    def load_module(self, name):

        files = [ (fn, dir) for fn, dir in self.module_files if fn == name ] #@ReservedAssignment

        if not files:
            raise Exception("Module %s could not be loaded." % name)

        if len(files) > 2:
            raise Exception("Module %s ambiguous, multiple variants exist." % name)

        fn, dir = files[0] #@ReservedAssignment
        initcode = [ ]

        self.load_appropriate_file(".rpymc", ".rpym", dir, fn, initcode)

        if renpy.parser.report_parse_errors():
            raise SystemExit(-1)

        self.translator.chain_translates()

        return initcode

    def assign_names(self, stmts, fn):
        # Assign names to statements that don't have one already.

        all_stmts = collapse_stmts(stmts)

        version = int(time.time())

        for s in all_stmts:
            if s.name is None:
                s.name = (fn, version, self.serial)
                self.serial += 1


    def merge_names(self, old_stmts, new_stmts):

        old_stmts = collapse_stmts(old_stmts)
        new_stmts = collapse_stmts(new_stmts)

        old_info = [ i.diff_info() for i in old_stmts ]
        new_info = [ i.diff_info() for i in new_stmts ]

        sm = difflib.SequenceMatcher(None, old_info, new_info)

        for oldl, newl, count in sm.get_matching_blocks():
            for i in range(count):
                old = old_stmts[oldl + i]
                new = new_stmts[newl + i]

                if new.name is None:
                    new.name = old.name

    def load_file_core(self, dir, fn): #@ReservedAssignment

        if fn.endswith(".rpy") or fn.endswith(".rpym"):

            if not dir:
                raise Exception("Cannot load rpy/rpym file %s from inside an archive." % fn)

            fullfn = dir + "/" + fn

            stmts = renpy.parser.parse(fullfn)

            data = { }
            data['version'] = script_version
            data['key'] = self.key or 'unlocked'

            if stmts is None:
                return data, [ ]

            # See if we have a corresponding .rpyc file. If so, then
            # we want to try to upgrade our .rpy file with it.
            try:
                self.record_pycode = False
                old_data, old_stmts = self.load_file_core(dir, fn + "c")
                self.merge_names(old_stmts, stmts)
                del old_data
                del old_stmts
            except:
                pass
            finally:
                self.record_pycode = True

            self.assign_names(stmts, fullfn)

            try:
                rpydigest = md5.md5(file(fullfn, "rU").read()).digest()
                f = file(dir + "/" + fn + "c", "wb")
                f.write(dumps((data, stmts), 2).encode('zlib'))
                f.write(rpydigest)
                f.close()
            except:
                pass

        elif fn.endswith(".rpyc") or fn.endswith(".rpymc"):

            f = renpy.loader.load(fn)

            try:
                data, stmts = loads(f.read().decode('zlib'))
            except:
                raise

            if not isinstance(data, dict):
                return None, None

            if self.key and data.get('key', 'unlocked') != self.key:
                return None, None

            if data['version'] != script_version:
                return None, None

            f.close()
        else:
            return None, None

        return data, stmts

    def load_file(self, dir, fn, initcode): #@ReservedAssignment

        # Actually do the loading.
        data, stmts = self.load_file_core(dir, fn)
        if data is None:
            return False

        # Check the key.
        if self.key is None:
            self.key = data['key']
        elif self.key != data['key']:
            raise Exception( fn + " does not share a key with at least one .rpyc file. To fix, delete all .rpyc files, or rerun Ren'Py with the --lock option.")

        self.finish_load(stmts, initcode)
        return True

    def load_string(self, filename, filedata):
        """
        Loads Ren'Py script from a string.

        `filename`
            The filename that's assigned to the data.

        `filedata`
            A unicode string to be loaded.

        Return the list of statements making up the root block, and a
        list of init statements that need to be run.
        """

        stmts = renpy.parser.parse(filename, filedata)

        if stmts is None:
            return None, None

        self.assign_names(stmts, filename)

        initcode = [ ]
        stmts = self.finish_load(stmts, initcode, False)

        return stmts, initcode


    def finish_load(self, stmts, initcode, check_names=True):
        """
        Given `stmts`, a list of AST nodes comprising the root block,
        finishes loading it (this includes chaining statements and
        adding them to the name map.)

        `initcode`
            A list we append init statements to.

        `check_names`
            If true, produce duplicate name errors.

        Returns a list of statements that corresponds to the top-level block
        in initcode after transformation.
        """

        # Generate translate nodes.
        renpy.translation.restructure(stmts)

        # All of the statements found in file, regardless of nesting
        # depth.
        all_stmts = collapse_stmts(stmts)

        # Take the translations.
        self.translator.take_translates(all_stmts)

        # Chain together the statements in the file.
        renpy.ast.chain_block(stmts, None)

        # Check each node individually.
        for node in all_stmts:

            # Check to see if the name is defined twice. If it is,
            # report the error.
            name = node.name

            if name in self.namemap and check_names:
                old = self.namemap[name]

                raise ScriptError("Name %s is defined twice: at %s:%d and %s:%d." %
                                  (repr(name),
                                   old.filename, old.linenumber,
                                   node.filename, node.linenumber))

            # Otherwise, add the name to the namemap.
            self.namemap[name] = node

            # Add any init nodes to self.initcode.
            init = node.get_init()
            if init:
                initcode.append(init)

        # Compile bytecode from the file.
        self.update_bytecode()

        # Exec early python.
        for node in all_stmts:
            node.early_execute()

        if self.all_stmts is not None:
            self.all_stmts.extend(all_stmts)

        return stmts

    def load_appropriate_file(self, compiled, source, dir, fn, initcode): #@ReservedAssignment
        # This can only be a .rpyc file, since we're loading it
        # from an archive.
        if dir is None:
            if not self.load_file(dir, fn + compiled, initcode):
                raise Exception("Could not load from archive %s.%s" % (fn, compiled))
            return

        # Otherwise, we're loading from disk. So we need to decide if
        # we want to load the rpy or the rpyc file.
        rpyfn = dir + "/" + fn + source
        rpycfn = dir + "/" + fn + compiled

        renpy.loader.add_auto(rpyfn)

        if os.path.exists(rpyfn) and os.path.exists(rpycfn):
            rpydigest = md5.md5(file(rpyfn, "rU").read()).digest()
            f = file(rpycfn, "rb")
            f.seek(-md5.digest_size, 2)
            rpycdigest = f.read(md5.digest_size)
            f.close()

            if rpydigest == rpycdigest and \
                not (renpy.game.args.command == "compile" or renpy.game.args.compile): #@UndefinedVariable

                if self.load_file(dir, fn + compiled, initcode):
                    return

                print "Could not load " + rpycfn

            if not self.load_file(dir, fn + source, initcode):
                raise Exception("Could not load file %s." % rpyfn)

        elif os.path.exists(rpycfn):
            if not self.load_file(dir, fn + compiled, initcode):
                raise Exception("Could not load file %s." % rpycfn)

        elif os.path.exists(rpyfn):
            if not self.load_file(dir, fn + source, initcode):
                raise Exception("Could not load file %s." % rpyfn)


    def init_bytecode(self):
        """
        Init/Loads the bytecode cache.
        """

        # Load the oldcache.
        try:
            version, cache = loads(renpy.loader.load("bytecode.rpyb").read().decode("zlib"))
            if version == BYTECODE_VERSION:
                self.bytecode_oldcache = cache
        except:
            pass

    def update_bytecode(self):
        """
        Compiles the PyCode objects in self.all_pycode, updating the
        cache. Clears out self.all_pycode.
        """

        # Update all of the PyCode objects in the system with the loaded
        # bytecode.
        for i in self.all_pycode:

            key = i.get_hash() + MAGIC

            code = self.bytecode_oldcache.get(key, None)

            if code is None:

                self.bytecode_dirty = True

                old_ei = renpy.game.exception_info
                renpy.game.exception_info = "While compiling python block starting at line %d of %s." % (i.location[1], i.location[0])

                try:

                    if i.mode == 'exec':
                        code = renpy.python.py_compile_exec_bytecode(i.source, filename=i.location[0], lineno=i.location[1])
                    elif i.mode == 'eval':
                        code = renpy.python.py_compile_eval_bytecode(i.source, filename=i.location[0], lineno=i.location[1])

                except SyntaxError, e:

                    text = e.text

                    if text is None:
                        text = ''

                    try:
                        text = text.decode("utf-8")
                    except:
                        text = text.decode("latin-1")

                    pem = renpy.parser.ParseError(
                        filename = e.filename,
                        number = e.lineno,
                        msg = e.msg,
                        line = text,
                        pos = e.offset)

                    renpy.parser.parse_errors.append(pem.message)

                    continue

                renpy.game.exception_info = old_ei

            i.source = None
            self.bytecode_newcache[key] = code
            i.bytecode = marshal.loads(code)

        self.all_pycode = [ ]


    def save_bytecode(self):

        if self.bytecode_dirty:
            try:
                data = (BYTECODE_VERSION, self.bytecode_newcache)
                f = file(os.path.join(renpy.config.searchpath[0], "bytecode.rpyb"), "wb")
                f.write(dumps(data, 2).encode("zlib"))
                f.close()
            except:
                pass


    def lookup(self, label):
        """
        Looks up the given label in the game. If the label is not found,
        raises a ScriptError.
        """

        label = renpy.config.label_overrides.get(label, label)

        if label not in self.namemap:
            raise ScriptError("could not find label '%s'." % str(label))

        return self.namemap[label]

    def has_label(self, label):
        """
        Returns true if the label exists, or false otherwise.
        """

        label = renpy.config.label_overrides.get(label, label)

        return label in self.namemap

########NEW FILE########
__FILENAME__ = pyutil
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import

import renpy # @UnusedImport

# Import the Python AST module, instead of the Ren'Py ast module.
import ast

# The set of names that should be treated as constants.
constants = { 'True', 'False', 'None', "config", "style" }

# The set of names that should be treated as pure functions.
pure_functions = {
    # Python builtins.
    "abs", "all", "any", "apply", "bin", "bool", "bytes", "callable", "chr",
    "cmp", "dict", "divmod",
    "filter", "float", "frozenset",
    "getattr", "globals", "hasattr", "hash", "hex", "int", "isinstance",
    "len", "list", "long", "map", "max", "min", "oct", "ord", "pow",
    "range", "reduce", "repr", "round", "set", "sorted",
    "str", "sum", "tuple", "unichr", "unicode", "vars", "zip",

    # enumerator and reversed return iterators at the moment.

    # minstore.py
    "_",

    # defaultstore.py
    "ImageReference", "Image", "Frame", "Solid", "LiveComposite", "LiveCrop",
    "LiveTile", "Flatten", "Null", "Window", "Viewport", "DynamicDisplayable",
    "ConditionSwitch", "ShowingSwitch", "Transform", "Animation", "Movie",
    "Particles", "SnowBlossom", "Text", "ParameterizedText", "FontGroup",
    "Drag", "Alpha", "Position", "Pan", "Move", "Motion", "Revolve", "Zoom",
    "RotoZoom", "FactorZoom", "SizeZoom", "Fade", "Dissolve", "ImageDissolve",
    "AlphaDissolve", "CropMove", "Pixellate", "OldMoveTransition",
    "MoveTransition", "MoveFactory", "MoveIn", "MoveOut", "ZoomInOut",
    "RevolveInOut", "MultipleTransition", "ComposeTransition", "Pause",
    "SubTransition", "ADVSpeaker", "ADVCharacter", "Speaker", "Character",
    "DynamicCharacter", "Fixed", "HBox", "VBox", "Grid", "AlphaBlend", "At",
    "color",

    }

def const(name):
    """
    :doc: const

    Declares a variable in the store to be constant.


    A variable is constant if nothing can change its value, or any value
    reached by indexing it or accessing its attributes. Variables must
    remain constant out of define, init, and translate python blocks.

    `name`
        A string giving the name of the variable to declare constant.
    """

    constants.add(name)


def pure(fn):
    """
    :doc: const

    Declares a function as pure. A pure function must always return the
    same value when it is called with the same arguments, outside of
    define, init, and translate python blocks.

    `fn`
        The name of the function to declare pure. This may either be a string
        containing the name of the function, or the function itself.

    Returns `fn`, allowing this function to be used as a decorator.
    """

    rv = fn

    if not isinstance(fn, basestring):
        fn = fn.__name__

    pure_functions.add(fn)

    return rv

def is_constant(node):
    """
    Returns true if `node` is constant for the purpose of screen
    language. Node should be a python AST node.

    Screen language ignores object identity for the purposes of
    object equality.
    """

    def check_slice(slice): # @ReservedAssignment

        if isinstance(slice, ast.Index):
            return check_node(slice.value)

        elif isinstance(slice, ast.Slice):
            if slice.lower and not check_node(slice.lower):
                return False
            if slice.upper and not check_node(slice.upper):
                return False
            if slice.step and not check_node(slice.step):
                return False

            return True

        return False


    def check_name(node):
        """
        Check nodes that make up a name. This returns a pair:

        * The first element is True if the node is constant, and False
          otherwise.
        * The second element is None if the node is constant or the name is
          not known, and the name otherwise.
        """

        if isinstance(node, ast.Name):
            name = node.id

        elif isinstance(node, ast.Attribute):
            const, name = check_name(node.value)

            if name is not None:
                name = name + "." + node.attr

            if const:
                return True, name

        else:
            return check_node(node), None

        if name in constants:
            return True, None

        return False, name

    def check_nodes(nodes):
        """
        Checks a list of nodes. Returns true if all are constant, and
        False otherwise.
        """

        for i in nodes:
            if not check_node(i):
                return False
        return True

    def check_node(node):
        """
        Returns true if the ast node `node` is constant.
        """

        #PY3: see if there are new node types.

        if isinstance(node, (ast.Num, ast.Str)):
            return True

        elif isinstance(node, (ast.List, ast.Tuple)):
            return check_nodes(node.elts)

        elif isinstance(node, (ast.Attribute, ast.Name)):
            return check_name(node)[0]

        elif isinstance(node, ast.BoolOp):
            return check_nodes(node.values)

        elif isinstance(node, ast.BinOp):
            return (
                check_node(node.left) and
                check_node(node.right)
                )

        elif isinstance(node, ast.UnaryOp):
            return check_node(node.operand)

        elif isinstance(node, ast.Call):
            _const, name = check_name(node.func)

            # The function must have a name, and must be declared pure.
            if not name in pure_functions:
                return False

            # Arguments and keyword arguments must be pure.
            if not check_nodes(node.args):
                return False

            if not check_nodes(i.value for i in node.keywords):
                return False

            if (node.starargs is not None) and not check_node(node.starargs):
                return False

            if (node.kwargs is not None) and not check_node(node.kwargs):
                return False

            return True

        elif isinstance(node, ast.IfExp):
            return (
                check_node(node.test) and
                check_node(node.body) and
                check_node(node.orelse)
                )

        elif isinstance(node, ast.Dict):
            return (
                check_nodes(node.keys) and
                check_nodes(node.values)
                )

        elif isinstance(node, ast.Set):
            return check_nodes(node.elts)

        elif isinstance(node, ast.Compare):
            return (
                check_node(node.left) and
                check_nodes(node.comparators)
                )

        elif isinstance(node, ast.Repr):
            return check_node(node.value)

        elif isinstance(node, ast.Subscript):
            return (
                check_node(node.value) and
                check_slice(node.slice)
                )

        return False

    return check_node(node)

########NEW FILE########
__FILENAME__ = slast
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import ast
import collections

import renpy.display

from renpy.display.motion import Transform
from renpy.display.layout import Fixed

from renpy.python import py_compile, py_eval_bytecode
from renpy.sl2.pyutil import is_constant

# This file contains the abstract syntax tree for a screen language
# screen.

# A serial number that makes each SLNode unique.
serial = 0

# A sentinel used to indicate we should use the value found in the
# expression.
use_expression = renpy.object.Sentinel("use_expression")

# The filename that's currently being compiled.
filename = '<screen language>'

def compile_expr(node):
    """
    Wraps the node in a python AST, and compiles it.
    """

    expr = ast.Expression(body=node)
    ast.fix_missing_locations(expr)
    return compile(expr, filename, "eval")


class SLContext(renpy.ui.Addable):
    """
    A context object that can be passed to the execute methods, and can also
    be placed in renpy.ui.stack.
    """

    def __init__(self, parent=None):
        if parent is not None:
            self.__dict__.update(parent.__dict__)
            return

        # The local scope that python code is evaluated in.
        self.scope = { }

        # The global scope that python code is evaluated in.
        self.globals = { }

        # A list of child displayables that will be added to an outer
        # displayable.
        self.children = [ ]

        # A map from keyword arguments to their values.
        self.keywords = { }

        # The style prefix that is given to children of this displayable.
        self.style_prefix = ""

        # A cache associated with this context. The cache maps from
        # statement serial to information associated with the statement.
        self.cache = { }

        # The number of times a particular use statement has been called
        # in the current screen. We use this to generate a unique name for
        # each call site.
        self.use_index = collections.defaultdict(int)

        # When a constant node uses the scope, we add it to this list, so
        # it may be reused. (If None, no list is used.)
        self.uses_scope = None

        # When a constant node has an id, we added it to this dict, so it
        # may be reused. (If None, no dict is used.)
        self.widgets = None

    def get_style_group(self):
        style_prefix = self.style_prefix

        if style_prefix:
            return style_prefix[:-1]
        else:
            return None

    style_group = property(get_style_group)

    def add(self, d, key):
        self.children.append(d)

    def close(self, d):
        raise Exception("Spurious ui.close().")

class SLNode(object):
    """
    The base class for screen language nodes.
    """

    def __init__(self, loc):
        global serial
        serial += 1

        # A unique serial number assigned to this node.
        self.serial = serial

        # The location of this node, a (file, line) tuple.
        self.location = loc

        # True if this is a constant node, always producing an equivalent
        # tree of objects.
        self.constant = True

    def report_traceback(self, name):
        filename, line = self.location

        return [ (filename, line, name, None) ]

    def prepare(self):
        """
        This should be called before the execute code is called, and again
        after init-level code (like the code in a .rpym module or an init
        python block) is called.
        """

        # By default, does nothing.

    def execute(self, context):
        """
        Execute this node, updating context as appropriate.
        """

        raise Exception("execute not implemented by " + type(self).__name__)

    def keywords(self, context):
        """
        Execute this node, updating context.keywords as appropriate.
        """

        # By default, does nothing.
        return

# A sentinel used to indicate a keyword argument was not given.
NotGiven = renpy.object.Sentinel("NotGiven")

class SLBlock(SLNode):
    """
    Represents a screen language block that can contain keyword arguments
    and child displayables.
    """

    def __init__(self, loc):
        SLNode.__init__(self, loc)

        # A list of keyword argument, expr tuples.
        self.keyword = [ ]

        # A list of child SLNodes.
        self.children = [ ]


    def prepare(self):

        for i in self.children:
            i.prepare()

            if not i.constant:
                self.constant = False

        # Compile the keywords.

        keyword_values = { }
        keyword_keys = [ ]
        keyword_exprs = [ ]

        for k, expr in self.keyword:

            node = py_compile(expr, 'eval', ast_node=True)

            if is_constant(node):
                keyword_values[k] = py_eval_bytecode(compile_expr(node))
            else:
                keyword_keys.append(ast.Str(s=k))
                keyword_exprs.append(node) # Will be compiled as part of ast.Dict below.

        if keyword_values:
            self.keyword_values = keyword_values
        else:
            self.keyword_values = None

        if keyword_keys:
            node = ast.Dict(keys=keyword_keys, values=keyword_exprs)
            ast.copy_location(node, keyword_exprs[0])
            self.keyword_exprs = compile_expr(node)

            self.constant = False
        else:
            self.keyword_exprs = None


    def execute(self, context):

        # Note: SLBlock.execute() is inlined in various locations for performance
        # reasons.

        for i in self.children:
            i.execute(context)

    def keywords(self, context):

        keyword_values = self.keyword_values

        if keyword_values is not None:
            context.keywords.update(keyword_values)

        keyword_exprs = self.keyword_exprs

        if keyword_exprs is not None:
            context.keywords.update(eval(keyword_exprs, context.globals, context.scope))

        for i in self.children:
            i.keywords(context)

        style_group = context.keywords.pop("style_group", NotGiven)
        if style_group is not NotGiven:
            if style_group is not None:
                context.style_prefix = style_group + "_"
            else:
                context.style_prefix = ""

list_or_tuple = (list, tuple)

class SLCache(object):
    """
    The type of cache associated with an SLDisplayable.
    """

    def __init__(self):

        # The displayable object created.
        self.displayable = None

        # The positional arguments that were used to create the displayable.
        self.positional = None

        # The keyword arguments that were used to created the displayable.
        self.keywords = None

        # A list of the children that were added to self.displayable.
        self.children = None

        # The old transform created.
        self.transform = None

        # The transform that was used to create self.transform.
        self.raw_transform = None

        # The imagemap stack entry we reuse.
        self.imagemap = None

        # If this can be represented as a single constant displayable,
        # do so.
        self.constant = None

        # For a constant statement, a list of our children that use
        # the scope.
        self.constant_uses_scope = [ ]

        # For a constant statement, a map from children to widgets.
        self.constant_widgets = { }

class SLDisplayable(SLBlock):
    """
    A screen language AST node that corresponds to a displayable being
    added to the tree.
    """

    def __init__(self, loc, displayable, scope=False, child_or_fixed=False, style=None, text_style=None, pass_context=False, imagemap=False, replaces=False):
        """
        `displayable`
            A function that, when called with the positional and keyword
            arguments, causes the displayable to be displayed.

        `scope`
            If true, the scope is supplied as an argument to the displayable.

        `child_or_fixed`
            If true and the number of children of this displayable is not one,
            the children are added to a Fixed, and the Fixed is added to the
            displayable.

        `style`
            The base name of the main style.

        `pass_context`
            If given, the context is passed in as the first positonal argument
            of the displayable.

        `imagemap`
            True if this is an imagemap, and should be handled as one.

        `replaces`
            True if the object this displayable replaces should be
            passed to it.
        """

        SLBlock.__init__(self, loc)

        self.displayable = displayable

        self.scope = scope
        self.child_or_fixed = child_or_fixed
        self.style = style
        self.pass_context = pass_context
        self.imagemap = imagemap
        self.replaces = replaces

        # Positional argument expressions.
        self.positional = [ ]

    def prepare(self):

        SLBlock.prepare(self)

        # Prepare the positional arguments.

        exprs = [ ]
        values = [ ]
        has_exprs = False
        has_values = False

        for a in self.positional:
            node = py_compile(a, 'eval', ast_node=True)

            if is_constant(node):
                values.append(py_eval_bytecode(compile_expr(node)))
                exprs.append(ast.Num(n=0))
                has_values = True
            else:
                values.append(use_expression)
                exprs.append(node) # Will be compiled as part of the tuple.
                has_exprs = True

        if has_values:
            self.positional_values = values
        else:
            self.positional_values = None

        if has_exprs:
            t = ast.Tuple(elts=exprs, ctx=ast.Load())
            ast.copy_location(t, exprs[0])
            self.positional_exprs = compile_expr(t)

            self.constant = False
        else:
            self.positional_exprs = None

    def keywords(self, context):
        # We do not want to pass keywords to our parents, so just return.
        return

    def execute(self, context):

        screen = renpy.ui.screen

        cache = context.cache.get(self.serial, None)
        if cache is None:
            context.cache[self.serial] = cache = SLCache()

        if cache.constant:
            context.children.append(cache.constant)
            screen.widgets.update(cache.constant_widgets)

            for i in cache.constant_uses_scope:
                i._scope(context.scope)

            return

        stack = renpy.ui.stack

        # Evaluate the positional arguments.
        positional_values = self.positional_values
        positional_exprs = self.positional_exprs

        if positional_values and positional_exprs:
            values = eval(positional_exprs, context.globals, context.scope)
            positional = [ b if (a is use_expression) else a for a, b in zip(positional_values, values) ]
        elif positional_values:
            positional = positional_values
        elif positional_exprs:
            positional = eval(positional_exprs, context.globals, context.scope)
        else:
            positional = [ ]

        # Create the context.
        ctx = SLContext(context)
        keywords = ctx.keywords = { }

        if self.constant:
            if ctx.uses_scope is None:
                ctx.uses_scope = [ ]
            if ctx.widgets is None:
                ctx.widgets = { }

        SLBlock.keywords(self, ctx)

        # Get the widget id and transform, if any.
        widget_id = keywords.pop("id", None)
        transform = keywords.pop("at", None)

        # If we don't know the style, figure it out.
        if ("style" not in keywords) and self.style:
            keywords["style"] = ctx.style_prefix + self.style

        if widget_id and (widget_id in screen.widget_properties):
            keywords.update(screen.widget_properties[widget_id])

        if (positional == cache.positional) and (keywords == cache.keywords):
            d = cache.displayable
            reused = True

            if cache.imagemap:
                renpy.ui.imagemap_stack.append(cache.imagemap)

            # The main displayable, if d is a composite displayable. (This is
            # the one that gets the scope, and gets children added to it.)
            main = d._main or d

            if self.scope:
                main._scope(ctx.scope)

        else:
            cache.positional = positional
            cache.keywords = keywords.copy()

            if self.scope:
                keywords["scope"] = ctx.scope

            if self.replaces:
                old_d = cache.displayable

                if old_d is not None:
                    old_d = old_d._main or old_d

                    keywords['replaces'] = old_d

            # Pass the context
            if self.pass_context:
                keywords['context'] = ctx

            d = self.displayable(*positional, **keywords)
            main = d._main or d

            reused = False

            cache.children = None # Re-add the children.

        main._location = self.location

        if widget_id:
            screen.widgets[widget_id] = main

        ctx.children = [ ]
        stack.append(ctx)

        try:

            # Evaluate children. (Inlined SLBlock.execute)
            for i in self.children:
                i.execute(ctx)

        finally:

            stack.pop()

            if self.imagemap:
                cache.imagemap = renpy.ui.imagemap_stack.pop()

        if ctx.children != cache.children:

            if reused:
                main._clear()

            if self.child_or_fixed and len(self.children) != 1:
                f = Fixed()

                for i in ctx.children:
                    f.add(i)

                main.add(f)

            else:
                for i in ctx.children:
                    main.add(i)

        cache.displayable = d
        cache.children = ctx.children

        if transform is not None:
            if reused and (transform == cache.raw_transform):
                d = cache.transform
            else:
                cache.raw_transform = transform


                if isinstance(transform, Transform):
                    d = transform(child=d)
                elif isinstance(transform, list_or_tuple):
                    for t in transform:
                        if isinstance(t, Transform):
                            d = t(child=d)
                        else:
                            d = t(d)
                else:
                    d = transform(d)

                if isinstance(d, Transform):
                    if cache.transform is not None:
                        d.take_state(cache.transform)
                        d.take_execution_state(cache.transform)

            cache.transform = d

        else:
            cache.transform = None
            cache.raw_transform = None

        context.children.append(d)

        if self.constant:
            cache.constant = d

            if widget_id is not None:
                ctx.widgets[widget_id] = main

            if self.scope:
                ctx.uses_scope.append(main)

            if context.widgets is None:
                cache.constant_widgets = ctx.widgets

            if context.uses_scope is None:
                cache.constant_uses_scope = ctx.uses_scope

# TODO: Can we get rid of pass_context?


class SLIf(SLNode):
    """
    A screen language AST node that corresponds to an If/Elif/Else statement.
    """

    def __init__(self, loc):
        """
        An AST node that represents an if statement.
        """
        SLNode.__init__(self, loc)

        # A list of entries, with each consisting of an expression (or
        # None, for the else block) and a SLBlock.
        self.entries = [ ]

    def prepare(self):

        # A list of prepared entries, with each consisting of expression
        # bytecode and a SLBlock.
        self.prepared_entries = [ ]

        for cond, block in self.entries:
            if cond is not None:
                node = py_compile(cond, 'eval', ast_node=True)

                if not is_constant(node):
                    self.constant = False

                cond = compile_expr(node)

            block.prepare()

            if not block.constant:
                self.constant = False

            self.prepared_entries.append((cond, block))

    def execute(self, context):

        for cond, block in self.prepared_entries:
            if cond is None or eval(cond, context.globals, context.scope):
                block.execute(context)
                return

    def keywords(self, context):

        for cond, block in self.prepared_entries:
            if cond is None or eval(cond, context.globals, context.scope):
                block.keywords(context)
                return

unhashable = renpy.object.Sentinel("unhashable")

class SLFor(SLBlock):
    """
    The AST node that corresponds to a for statement. This only supports
    simple for loops that assign a single variable.
    """

    def __init__(self, loc, variable, expression):
        SLBlock.__init__(self, loc)

        self.variable = variable
        self.expression = expression

    def prepare(self):
        node = py_compile(self.expression, 'eval', ast_node=True)

        if is_constant(node):
            self.expression_value = py_eval_bytecode(compile_expr(node))
            self.expression_expr = None
        else:
            self.expression_value = None
            self.expression_expr = compile_expr(node)
            self.constant = False

        SLBlock.prepare(self)

    def execute(self, context):

        variable = self.variable
        expr = self.expression_expr

        if expr is not None:
            value = eval(expr, context.globals, context.scope)
        else:
            value = self.expression_value

        newcaches = {}
        oldcaches = context.cache.get(self.serial, newcaches)

        ctx = SLContext(context)

        count = { }

        for v in value:

            ctx.scope[variable] = v

            index = id(v)

            n = count.get(index, -1) + 1
            count[index] = n

            if n:
                index = (index, n)

            cache = oldcaches.get(index, None)

            if cache is None:
                cache = {}

            newcaches[index] = cache
            ctx.cache = cache

            # Inline of SLBlock.execute.

            for i in self.children:
                i.execute(ctx)

        context.cache[self.serial] = newcaches

    def keywords(self, context):
        return


class SLPython(SLNode):

    def __init__(self, loc, code):
        SLNode.__init__(self, loc)

        # A pycode object.
        self.code = code

    def execute(self, context):
        exec self.code.bytecode in context.globals, context.scope

    def prepare(self):
        self.constant = False

class SLPass(SLNode):

    def execute(self, context):
        return


class SLDefault(SLNode):

    def __init__(self, loc, variable, expression):
        SLNode.__init__(self, loc)

        self.variable = variable
        self.expression = expression

    def prepare(self):
        self.expr = py_compile(self.expression, 'eval')
        self.constant = False

    def execute(self, context):
        scope = context.scope
        variable = self.variable

        if variable in scope:
            return

        scope[variable] = eval(self.expr, context.globals, scope)

class SLOn(SLNode):

    def __init__(self, loc, event):
        SLNode.__init__(self, loc)

        self.event = event

        # This stores the action using the 'action' property.
        self.keyword = [ ]

    def prepare(self):

        keywords = dict(self.keyword)

        event_node = py_compile(self.event, 'eval', ast_node=True)
        action_node = py_compile(keywords.get('action', None), 'eval', ast_node=True)

        self.event_expr = compile_expr(event_node)
        self.action_expr = compile_expr(action_node)

        if is_constant(event_node):
            self.event_value = py_eval_bytecode(self.event_expr)
        else:
            self.event_value = None

        if is_constant(action_node):
            self.action_value = py_eval_bytecode(self.action_expr)
        else:
            self.action_value = None

        self.constant = False


    def execute(self, context):

        event = self.event_value
        if event is None:
            event = eval(self.event_expr, context.globals, context.scope)

        action = self.action_value
        if action is None:
            action = eval(self.action_expr, context.globals, context.scope)

        renpy.ui.on(event, action)



class SLUse(SLNode):

    def __init__(self, loc, target, args):

        SLNode.__init__(self, loc)

        # The name of the screen we're accessing.
        self.target = target

        # If the target is an SL2 screen, the SLScreen node at the root of
        # the ast for that screen.
        self.ast = None

        # If arguments are given, those arguments.
        self.args = args


    def prepare(self):

        ts = renpy.display.screen.get_screen_variant(self.target)

        if ts is None:
            self.constant = False
            return

        if ts.ast is None:
            self.constant = False
            return

        self.ast = ts.ast
        self.ast.prepare()

        self.constant = self.ast.constant

    def execute_use_screen(self, context):

        # Create an old-style displayable name for this call site.
        serial = context.use_index[self.serial]
        context.use_index[self.serial] = serial + 1

        name = (
            context.scope.get("_name", ()),
            self.serial,
            serial)

        if self.args:
            args, kwargs = self.args.evaluate(context.scope)
        else:
            args = [ ]
            kwargs = { }

        renpy.display.screen.use_screen(self.target, _name=name, _scope=context.scope, *args, **kwargs)

    def execute(self, context):

        ast = self.ast

        # If self.ast is not an SL2 screen, run it using renpy.display.screen.use_screen.
        if ast is None:
            self.execute_use_screen(context)
            return

        # Otherwise, run it directly.

        ctx = SLContext(context)

        # Create a new scope for the context, based on the parameters.
        scope = dict(context.scope)

        if self.args:
            args, kwargs = self.args.evaluate(context.scope)
        else:
            args = [ ]
            kwargs = { }

        if ast.parameters is not None:
            newscope = ast.parameters.apply(args, kwargs)
        else:
            if args:
                raise Exception("Screen {} does not take positional arguments. ({} given)".format(self.target, len(args)))

            newscope = kwargs

        scope.update(newscope)
        ctx.scope = scope

        # Use a call-site specific cache. (Otherwise, two uses of the same screen would
        # be sharing cache locations.

        cache = context.cache.get(self.serial, None)

        if cache is None:
            context.cache[self.serial] = cache = { }

        ctx.cache = cache

        # Run the child screen.
        ast.execute(ctx)


class SLScreen(SLBlock):
    """
    This represents a screen defined in the screen language 2.
    """

    def __init__(self, loc):

        SLBlock.__init__(self, loc)

        # The name of the screen.
        self.name = None

        # Should this screen be declared as modal?
        self.modal = "False"

        # The screen's zorder.
        self.zorder = "0"

        # The screen's tag.
        self.tag = None

        # The variant of screen we're defining.
        self.variant = "None" # expr.

        # Should we predict this screen?
        self.predict = "None" # expr.

        # The parameters this screen takes.
        self.parameters = None

        # True if this screen has been prepared.
        self.prepared = False

    def define(self):
        """
        Defines a screen.
        """

        renpy.display.screen.define_screen(
            self.name,
            self,
            modal=self.modal,
            zorder=self.zorder,
            tag=self.tag,
            variant=renpy.python.py_eval(self.variant),
            predict=renpy.python.py_eval(self.predict),
            parameters=self.parameters,
            )

    def unprepare(self):
        self.prepared = False

    def prepare(self):
        if not self.prepared:

            self.constant = False
            SLBlock.prepare(self)
            self.prepared = True

    def report_traceback(self, name):
        if name == "__call__":
            return [ ]

        return SLBlock.report_traceback(self, name)

    def __call__(self, *args, **kwargs):
        scope = kwargs["_scope"]

        if self.parameters:

            args = scope.get("_args", ())
            kwargs = scope.get("_kwargs", { })

            values = renpy.ast.apply_arguments(self.parameters, args, kwargs)
            scope.update(values)

        self.prepare()

        context = SLContext()
        context.scope = scope
        context.globals = renpy.python.store_dicts["store"]

        name = scope["_name"]
        main_cache = renpy.display.screen.current_screen().cache

        cache = main_cache.get(name, None)
        if cache is None:
            cache = { }
            main_cache[name] = cache

        context.cache = cache

        self.execute(context)

        for i in context.children:
            renpy.ui.add(i)


########NEW FILE########
__FILENAME__ = sldisplayables
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

##############################################################################
# Definitions of screen language statements.

import renpy.display
import renpy.text.text

from renpy.sl2.slparser import Positional, Keyword, Style, PrefixStyle, add
from renpy.sl2.slparser import DisplayableParser, many

position_property_names = [
        "anchor",
        "xanchor",
        "yanchor",
        "pos",
        "xpos",
        "ypos",
        "align",
        "xalign",
        "yalign",
        "xoffset",
        "yoffset",
        "maximum",
        "xmaximum",
        "ymaximum",
        "area",
        "clipping",
        "xfill",
        "yfill",
        # no center, since it can conflict with the center transform.
        "xcenter",
        "ycenter",
        "xsize",
        "ysize",
        "xysize",
        ]

position_properties = [ Style(i) for i in position_property_names ]
text_position_properties = [ PrefixStyle("text_", i) for i in position_property_names ]
side_position_properties = [ PrefixStyle("side_", i) for i in position_property_names ]

text_property_names = [
        "antialias",
        "vertical",
        "black_color",
        "bold",
        "color",
        "drop_shadow",
        "drop_shadow_color",
        "first_indent",
        "font",
        "size",
        "hyperlink_functions",
        "italic",
        "justify",
        "kerning",
        "language",
        "layout",
        "line_leading",
        "line_spacing",
        "minwidth",
        "min_width",
        "newline_indent",
        "outlines",
        "rest_indent",
        "ruby_style",
        "slow_cps",
        "slow_cps_multiplier",
        "slow_abortable",
        "strikethrough",
        "text_align",
        "text_y_fudge",
        "underline",
        "minimum",
        "xminimum",
        "yminimum",
        ]

text_properties = [ Style(i) for i in text_property_names ]
text_text_properties = [ PrefixStyle("text_", i) for i in text_property_names ]

window_properties = [ Style(i) for i in [
        "background",
        "foreground",
        "left_margin",
        "right_margin",
        "bottom_margin",
        "top_margin",
        "xmargin",
        "ymargin",
        "left_padding",
        "right_padding",
        "top_padding",
        "bottom_padding",
        "xpadding",
        "ypadding",
        "size_group",
        "minimum",
        "xminimum",
        "yminimum",
        ] ]

button_properties = [ Style(i) for i in [
        "sound",
        "mouse",
        "focus_mask",
        "child",
        ] ]

bar_properties = [ Style(i) for i in [
        "bar_vertical",
        "bar_invert",
        "bar_resizing",
        "left_gutter",
        "right_gutter",
        "top_gutter",
        "bottom_gutter",
        "left_bar",
        "right_bar",
        "top_bar",
        "bottom_bar",
        "thumb",
        "thumb_shadow",
        "thumb_offset",
        "mouse",
        "unscrollable",
        ] ]

box_properties = [ Style(i) for i in [
        "box_layout",
        "box_wrap",
        "box_reverse",
        "order_reverse",
        "spacing",
        "first_spacing",
        "fit_first",
        "minimum",
        "xminimum",
        "yminimum",
        ] ]

ui_properties = [
    Keyword("at"),
    Keyword("id"),
    Keyword("style"),
    Keyword("style_group"),
    Keyword("focus"),
    Keyword("default"),
    ]


DisplayableParser("null", renpy.display.layout.Null, "default", 0)
Keyword("width")
Keyword("height")
add(ui_properties)
add(position_properties)

DisplayableParser("text", renpy.text.text.Text, "text", 0, scope=True, replaces=True)
Positional("text")
Keyword("slow")
Keyword("slow_done")
Keyword("substitute")
Keyword("scope")
add(ui_properties)
add(position_properties)
add(text_properties)

DisplayableParser("hbox", renpy.display.layout.MultiBox, "hbox", many)
add(ui_properties)
add(position_properties)
add(box_properties)

DisplayableParser("vbox", renpy.display.layout.MultiBox, "vbox", many)
add(ui_properties)
add(position_properties)
add(box_properties)

DisplayableParser("fixed", renpy.display.layout.Fixed, "fixed", many)
add(ui_properties)
add(position_properties)
add(box_properties)

DisplayableParser("grid", renpy.display.layout.Grid, "grid", many)
Positional("cols")
Positional("rows")
Keyword("transpose")
Style("spacing")
add(ui_properties)
add(position_properties)

DisplayableParser("side", renpy.display.layout.Side, "side", many)
Positional("positions")
Style("spacing")
add(ui_properties)
add(position_properties)

# Omit sizer, as we can always just put an xmaximum and ymaximum on an item.

for name in [ "window", "frame" ]:
    DisplayableParser(name, renpy.display.layout.Window, name, 1)
    add(ui_properties)
    add(position_properties)
    add(window_properties)

DisplayableParser("key", renpy.ui._key, None, 0)
Positional("key")
Keyword("action")

DisplayableParser("timer", renpy.display.behavior.Timer, "default", 0, replaces=True)
Positional("delay")
Keyword("action")
Keyword("repeat")

# Omit behaviors.
# Omit menu as being too high-level.

DisplayableParser("input", renpy.display.behavior.Input, "input", 0, replaces=True)
Keyword("default")
Keyword("length")
Keyword("allow")
Keyword("exclude")
Keyword("prefix")
Keyword("suffix")
Keyword("changed")
Keyword("pixel_width")
add(ui_properties)
add(position_properties)
add(text_properties)

DisplayableParser("image", renpy.display.im.image, "default", 0)
Positional("im")

# Omit imagemap_compat for being too high level (and obsolete).

DisplayableParser("button", renpy.display.behavior.Button, "button", 1)
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Keyword("alternate")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)

DisplayableParser("imagebutton", renpy.ui._imagebutton, "image_button", 0)
Keyword("auto")
Keyword("idle")
Keyword("hover")
Keyword("insensitive")
Keyword("selected_idle")
Keyword("selected_hover")
Keyword("selected_insensitive")
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Keyword("alternate")
Keyword("image_style")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)

DisplayableParser("textbutton", renpy.ui._textbutton, 0, scope=True)
Positional("label")
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Keyword("alternate")
Keyword("text_style")
Keyword("substitute")
Keyword("scope")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)
add(text_position_properties)
add(text_text_properties)

DisplayableParser("label", renpy.ui._label, "label", 0, scope=True)
Positional("label")
Keyword("text_style")
add(ui_properties)
add(position_properties)
add(window_properties)
add(text_position_properties)
add(text_text_properties)

def sl2bar(context=None, **properties):
    range = 1 #@ReservedAssignment
    value = 0
    width = None
    height = None

    if "width" in properties:
        width = properties.pop("width")
    if "height" in properties:
        height  = properties.pop("height")
    if "range" in properties:
        range = properties.pop("range") #@ReservedAssignment
    if "value" in properties:
        value = properties.pop("value")

    if "style" not in properties:
        if isinstance(value, renpy.ui.BarValue):
            style = context.style_prefix + value.get_style()[0]
            properties["style"] = style

    return renpy.display.behavior.Bar(range, value, width, height, vertical=False, **properties)

DisplayableParser("bar", sl2bar, None, 0, replaces=True, pass_context=True)
Keyword("adjustment")
Keyword("range")
Keyword("value")
Keyword("changed")
Keyword("hovered")
Keyword("unhovered")
add(ui_properties)
add(position_properties)
add(bar_properties)


def sl2vbar(context=None, **properties):
    range = 1 #@ReservedAssignment
    value = 0
    width = None
    height = None

    if "width" in properties:
        width = properties.pop("width")
    if "height" in properties:
        height  = properties.pop("height")
    if "range" in properties:
        range = properties.pop("range") #@ReservedAssignment
    if "value" in properties:
        value = properties.pop("value")

    if "style" not in properties:
        if isinstance(value, renpy.ui.BarValue):
            style = context.style_prefix + value.get_style()[1]
            properties["style"] = style

    return renpy.display.behavior.Bar(range, value, width, height, vertical=True, **properties)

DisplayableParser("vbar", sl2vbar, None, 0, replaces=True, pass_context=True)
Keyword("adjustment")
Keyword("range")
Keyword("value")
Keyword("changed")
Keyword("hovered")
Keyword("unhovered")
add(ui_properties)
add(position_properties)
add(bar_properties)



# Omit autobar. (behavior)

def sl2viewport(**kwargs):
    """
    This converts the output of renpy.ui.viewport into something that
    sl.displayable can use.
    """

    vp = renpy.ui.viewport(**kwargs)
    renpy.ui.stack.pop()

    # Remove the side from the list of children. (It will be re-added later.)
    d = renpy.ui.stack[-1].children.pop()

    # Make the viewport the main element.
    d._main = vp

    return d

DisplayableParser("viewport", sl2viewport, "viewport", 1, replaces=True)
Keyword("child_size")
Keyword("mousewheel")
Keyword("draggable")
Keyword("edgescroll")
Keyword("xadjustment")
Keyword("yadjustment")
Keyword("xinitial")
Keyword("yinitial")
Keyword("scrollbars")
PrefixStyle("side_", "spacing")
add(ui_properties)
add(position_properties)
add(side_position_properties)

DisplayableParser("imagemap", renpy.ui._imagemap, "imagemap", many, imagemap=True)
Keyword("ground")
Keyword("hover")
Keyword("insensitive")
Keyword("idle")
Keyword("selected_hover")
Keyword("selected_idle")
Keyword("selected_insensitive")
Keyword("auto")
Keyword("alpha")
Keyword("cache")
add(ui_properties)
add(position_properties)

DisplayableParser("hotspot", renpy.ui._hotspot, "hotspot", 1)
Positional("spot")
Keyword("action")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
add(ui_properties)
add(position_properties)
add(window_properties)
add(button_properties)

DisplayableParser("hotbar", renpy.ui._hotbar, "hotbar", 0, replaces=True)
Positional("spot")
Keyword("adjustment")
Keyword("range")
Keyword("value")
add(ui_properties)
add(position_properties)
add(bar_properties)


DisplayableParser("transform", renpy.display.motion.Transform, "transform", 1)
Keyword("at")
Keyword("id")
for i in renpy.atl.PROPERTIES:
    Style(i)

DisplayableParser("add", renpy.ui._add, None, 0)
Positional("im")
Keyword("at")
Keyword("id")
for i in renpy.atl.PROPERTIES:
    Style(i)

DisplayableParser("drag", renpy.display.dragdrop.Drag, None, 1, replaces=True)
Keyword("drag_name")
Keyword("draggable")
Keyword("droppable")
Keyword("drag_raise")
Keyword("dragged")
Keyword("dropped")
Keyword("drag_handle")
Keyword("drag_joined")
Keyword("clicked")
Keyword("hovered")
Keyword("unhovered")
Style("child")
add(ui_properties)
add(position_properties)

DisplayableParser("draggroup", renpy.display.dragdrop.DragGroup, None, many, replaces=True)
add(ui_properties)
add(position_properties)

DisplayableParser("mousearea", renpy.display.behavior.MouseArea, 0, replaces=True)
Keyword("hovered")
Keyword("unhovered")
add(ui_properties)
add(position_properties)




########NEW FILE########
__FILENAME__ = slparser
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy
import renpy.sl2.slast as slast

# A list of style prefixes that we know of.
STYLE_PREFIXES = [
    '',
    'insensitive_',
    'hover_',
    'idle_',
    'activate_',
    'selected_',
    'selected_insensitive_',
    'selected_hover_',
    'selected_idle_',
    'selected_activate_',
]

##############################################################################
# Parsing.

# The parser that things are being added to.
parser = None

# All statements we know about.
all_statements = [ ]

# Statements that can contain children.
childbearing_statements = set()

class Positional(object):
    """
    This represents a positional parameter to a function.
    """

    def __init__(self, name):
        self.name = name

        if parser:
            parser.add(self)

# Used to generate the documentation
all_keyword_names = set()

class Keyword(object):
    """
    This represents an optional keyword parameter to a function.
    """

    def __init__(self, name):
        self.name = name

        all_keyword_names.add(self.name)

        if parser:
            parser.add(self)

class Style(object):
    """
    This represents a style parameter to a function.
    """

    def __init__(self, name):
        self.name = name

        for j in STYLE_PREFIXES:
            all_keyword_names.add(j + self.name)

        if parser:
            parser.add(self)


class PrefixStyle(object):
    """
    This represents a prefixed style parameter to a function.
    """

    def __init__(self, prefix, name):
        self.prefix = prefix
        self.name = name

        for j in STYLE_PREFIXES:
            all_keyword_names.add(prefix + j + self.name)

        if parser:
            parser.add(self)


class Parser(object):

    def __init__(self, name):

        # The name of this object.
        self.name = name

        # The positional arguments, keyword arguments, and child
        # statements of this statement.
        self.positional = [ ]
        self.keyword = { }
        self.children = { }

        all_statements.append(self)

        global parser
        parser = self

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.name)

    def add(self, i):
        """
        Adds a clause to this parser.
        """

        if isinstance(i, list):
            for j in i:
                self.add(j)

            return

        if isinstance(i, Positional):
            self.positional.append(i)

        elif isinstance(i, Keyword):
            self.keyword[i.name] = i

        elif isinstance(i, Style):
            for j in STYLE_PREFIXES:
                self.keyword[j + i.name] = i

        elif isinstance(i, PrefixStyle):
            for j in STYLE_PREFIXES:
                self.keyword[i.prefix + j + i.name] = i

        elif isinstance(i, Parser):
            self.children[i.name] = i

    def parse_statement(self, loc, l, layout_mode=False):
        word = l.word() or l.match(r'\$')

        if word and word in self.children:
            if layout_mode:
                c = self.children[word].parse_layout(loc, l, self)
            else:
                c = self.children[word].parse(loc, l, self)

            return c
        else:
            return None

    def parse_layout(self, loc, l, parent):
        l.error("The %s statement cannot be used as a container for the has statement." % self.name)

    def parse(self, loc, l, parent):
        """
        This is expected to parse a function statement, and to return
        a list of python ast statements.

        `loc`
            The location of the current statement.

        `l`
            The lexer.

        `parent`
            The parent Parser of the current statement.
        """

        raise Exception("Not Implemented")

    def parse_contents(self, l, target, layout_mode=False, can_has=False, can_tag=False, block_only=False):
        """
        Parses the remainder of the current line of `l`, and all of its subblock,
        looking for keywords and children.

        `layout_mode`
            If true, parsing continues to the end of `l`, rather than stopping
            with the end of the first logical line.

        `can_has`
            If true, we should parse layouts.

        `can_tag`
            If true, we should parse the ``tag`` keyword, as it's used by
            screens.

        `block_only`
            If true, only parse the
        """

        seen_keywords = set()

        # Parses a keyword argument from the lexer.
        def parse_keyword(l, expect):
            name = l.word()

            if name is None:
                l.error(expect)

            if can_tag and name == "tag":
                if target.tag is not None:
                    l.error('keyword argument %r appears more than once in a %s statement.' % (name, self.name))

                target.tag = l.require(l.word)

                return True

            if name not in self.keyword:
                l.error('%r is not a keyword argument or valid child for the %s statement.' % (name, self.name))

            if name in seen_keywords:
                l.error('keyword argument %r appears more than once in a %s statement.' % (name, self.name))

            seen_keywords.add(name)


            expr = l.comma_expression()

            target.keyword.append((name, expr))

        if block_only:
            l.expect_eol()
            l.expect_block(self.name)
            block = True

        else:

            # If not block_only, we allow keyword arguments on the starting
            # line.
            while True:
                if l.match(':'):
                    l.expect_eol()
                    l.expect_block(self.name)
                    block = True
                    break

                if l.eol():
                    l.expect_noblock(self.name)
                    block = False
                    break

                parse_keyword(l, 'expected a keyword argument, colon, or end of line.')


        # The index of the child we're adding to this statement.
        child_index = 0

        # A list of lexers we need to parse the contents of.
        lexers = [ ]

        if block:
            lexers.append(l.subblock_lexer())

        if layout_mode:
            lexers.append(l)

        # If we have a block, parse it. This also takes care of parsing the
        # block after a has clause.

        for l in lexers:

            while l.advance():

                state = l.checkpoint()
                loc = l.get_location()

                if l.keyword(r'has'):
                    if self.nchildren != 1:
                        l.error("The %s statement does not take a layout." % self.name)

                    if child_index != 0:
                        l.error("The has statement may not be given after a child has been supplied.")

                    c = self.parse_statement(loc, l, layout_mode=True)

                    if c is None:
                        l.error('Has expects a child statement.')

                    target.children.append(c)

                    continue

                c = self.parse_statement(loc, l)

                # Ignore passes.
                if isinstance(c, slast.SLPass):
                    continue

                # If not none, add the child to our AST.
                if c is not None:
                    target.children.append(c)
                    child_index += 1
                    continue

                l.revert(state)

                if not l.eol():
                    parse_keyword(l, "expected a keyword argument or child statement.")

                while not l.eol():
                    parse_keyword(l, "expected a keyword argument or end of line.")


def add(thing):
    parser.add(thing)

# A singleton value.
many = renpy.object.Sentinel("many")

class DisplayableParser(Parser):
    """
    This is responsible for parsing statements that create displayables.
    """

    def __init__(self, name, displayable, style, nchildren=0, scope=False, text_style=None,
        pass_context=False, imagemap=False, replaces=False):
        """
        `name`
            The name of the statement that creates the displayable.

        `displayable`
            A function that creates the displayable.

        `style`
            The name of the style that is applied to this displayable.

        `nchildren`
            The number of children of this displayable. One of:

            0
                The displayable takes no children.
            1
                The displayable takes 1 child. If more than one child is given,
                the children are placed in a Fixed.
            many
                The displayable takes more than one child.

        `scope`
            If true, the scope is passed into the displayable as a keyword
            argument named "scope".

        `text_style`
            The name of the text style that is applied to this displayable. This
            also enables the whole text style handling mechanism.

        `pass_context`
            If true, the context is passed as the first positional argument of the
            displayable.

        `imagemap`
            If true, the displayable is treated as defining an imagemap. (The imagemap
            is added to and removed from renpy.ui.imagemap_stack as appropraite.)

        `replaces`
            If true, and the displayable replaces a prior displayable, that displayable
            is passed as a parameter to the new displayable.
        """

        super(DisplayableParser, self).__init__(name)

        # The displayable that is called when this statement runs.
        self.displayable = displayable

        # The number of children we have.
        self.nchildren = nchildren

        if nchildren != 0:
            childbearing_statements.add(self)

        self.style = style
        self.scope = scope
        self.text_style = text_style
        self.pass_context = pass_context
        self.imagemap = imagemap
        self.replaces = replaces

    def parse_layout(self, loc, l, parent):
        return self.parse(loc, l, parent, True)

    def parse(self, loc, l, parent, layout_mode=False):

        rv = slast.SLDisplayable(
            loc,
            self.displayable,
            scope=self.scope,
            child_or_fixed=(self.nchildren == 1),
            style=self.style,
            text_style=self.text_style,
            pass_context=self.pass_context,
            imagemap=self.imagemap,
            replaces=self.replaces
            )

        for _i in self.positional:
            rv.positional.append(l.simple_expression())

        can_has = (self.nchildren == 1)
        self.parse_contents(l, rv, layout_mode=layout_mode, can_has=can_has, can_tag=False)

        return rv

class IfParser(Parser):

    def __init__(self, name):
        super(IfParser, self).__init__(name)

    def parse(self, loc, l, parent):

        rv = slast.SLIf(loc)

        condition = l.require(l.python_expression)

        l.require(':')

        block = slast.SLBlock(loc)
        parent.parse_contents(l, block, block_only=True)

        rv.entries.append((condition, block))

        state = l.checkpoint()

        while l.advance():

            loc = l.get_location()

            if l.keyword("elif"):

                condition = l.require(l.python_expression)
                l.require(':')

                block = slast.SLBlock(loc)
                parent.parse_contents(l, block, block_only=True)

                rv.entries.append((condition, block))

                state = l.checkpoint()

            elif l.keyword("else"):

                condition = None
                l.require(':')

                block = slast.SLBlock(loc)
                parent.parse_contents(l, block, block_only=True)

                rv.entries.append((condition, block))

                state = l.checkpoint()

                break

            else:
                l.revert(state)
                break

        return rv

if_statement = IfParser("if")

class ForParser(Parser):

    def __init__(self, name):
        super(ForParser, self).__init__(name)
        childbearing_statements.add(self)

    def name_or_tuple_pattern(self, l):
        """
        Matches either a name or a tuple pattern. If a single name is being
        matched, returns it. Otherwise, returns None.
        """

        name = None
        pattern = False

        while True:

            if l.match(r"\("):
                name = self.name_or_tuple_pattern(l)
                l.require(r'\)')
            else:
                name = l.name()

                if name is None:
                    break

            if l.match(r","):
                pattern = True
            else:
                break

        if pattern:
            return None

        if name is not None:
            return name

        l.error("expected variable or tuple pattern.")

    def parse(self, loc, l, parent):

        l.skip_whitespace()

        tuple_start = l.pos
        name = self.name_or_tuple_pattern(l)

        if not name:
            name = "_sl2_i"
            pattern = l.text[tuple_start:l.pos]
            stmt = pattern + " = " + name
            code = renpy.ast.PyCode(stmt, loc)
        else:
            code = None

        l.require('in')

        expression = l.require(l.python_expression)

        l.require(':')
        l.expect_eol()

        rv = slast.SLFor(loc, name, expression)

        if code:
            rv.children.append(slast.SLPython(loc, code))

        self.parse_contents(l, rv, block_only=True)

        return rv

ForParser("for")


class OneLinePythonParser(Parser):

    def parse(self, loc, l, parent):

        loc = l.get_location()
        source = l.require(l.rest)

        l.expect_eol()
        l.expect_noblock("one-line python")

        code = renpy.ast.PyCode(source, loc)
        return slast.SLPython(loc, code)

OneLinePythonParser("$")


class MultiLinePythonParser(Parser):

    def parse(self, loc, l, parent):

        loc = l.get_location()

        l.require(':')

        l.expect_eol()
        l.expect_block("python block")

        source = l.python_block()

        code = renpy.ast.PyCode(source, loc)
        return slast.SLPython(loc, code)

MultiLinePythonParser("python")


class PassParser(Parser):

    def parse(self, loc, l, parent):

        l.expect_eol()

        return slast.SLPass(loc)

PassParser("pass")


class DefaultParser(Parser):

    def parse(self, loc, l, parent):

        name = l.require(l.word)
        l.require(r'=')
        rest = l.rest()

        l.expect_eol()
        l.expect_noblock('default statement')

        return slast.SLDefault(loc, name, rest)

DefaultParser("default")


class OnParser(Parser):

    def parse(self, loc, l, parent):

        event = l.require(l.comma_expression)

        rv = slast.SLOn(loc, event)

        self.parse_contents(l, rv)

        return rv

OnParser("on")
Keyword("action")


class UseParser(Parser):

    def __init__(self, name):
        super(UseParser, self).__init__(name)
        childbearing_statements.add(self)

    def parse(self, loc, l, parent):

        target = l.require(l.word)
        args = renpy.parser.parse_arguments(l)

        l.expect_eol()
        l.expect_noblock("use statement")

        return slast.SLUse(loc, target, args)

UseParser("use")


class ScreenParser(Parser):

    def __init__(self):
        super(ScreenParser, self).__init__("screen")

    def parse(self, loc, l, parent, name="_name"):

        screen = slast.SLScreen(loc)

        screen.name = l.require(l.word)
        screen.parameters = renpy.parser.parse_parameters(l)

        self.parse_contents(l, screen, can_tag=True)

        keyword = dict(screen.keyword)

        screen.modal = keyword.get("modal", "False")
        screen.zorder = keyword.get("zorder", "0")
        screen.variant = keyword.get("variant", "None")
        screen.predict = keyword.get("predict", "None")

        return screen

screen_parser = ScreenParser()
Keyword("modal")
Keyword("zorder")
Keyword("variant")
Keyword("predict")

def init():
    screen_parser.add(all_statements)

    for i in all_statements:

        if i in childbearing_statements:
            i.add(all_statements)
        else:
            i.add(if_statement)


def parse_screen(l, loc):
    """
    Parses the screen statement.
    """

    return screen_parser.parse(loc, l, None)


########NEW FILE########
__FILENAME__ = statements
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This module contains code to support user-defined statements.

import renpy

# The statement registry. It's a map from tuples giving the prefixes of
# statements to dictionaries giving the methods used for that statement.
registry = { }

parsers = renpy.parser.ParseTrie()

def register(name, parse=None, lint=None, execute=None, predict=None, next=None, scry=None, block=False, init=False, translatable=False): #@ReservedAssignment
    """
    :doc: statement_register
    :name: renpy.register_statement

    This registers a user-defined statement.

    `name`
        This is either a space-separated list of names that begin the statement, or the
        empty string to define a new default statement (the default statement will
        replace the say statement).

    `parse`
        This is a function that takes a Lexer object. This function should parse the
        statement, and return an object. This object is passed as an argument to all the
        other functions. The lexer argument has the following methods:

    `lint`
        This is called to check the statement. It is passed a single object, the
        argument returned from parse. It should call renpy.error to report errors.

    `execute`
        This is a function that is called when the statement executes. It is passed a
        single object, the argument returned from parse.

    `predict`
        This is a function that is called to predict the images used by the statement.
        It is passed a single object, the argument returned from parse. It should return
        a list of displayables used by the statement.

    `next`
        This is called to determine the next statement. It is passed a single object,
        the argument returned from parse. It should either return a label, or return
        None if execution should continue to the next statement.

    `scry`
        Used internally by Ren'Py.

    `block`
        True if this takes a block, false otherwise.

    `init`
        True if this statement should be run at init-time. (If the statement
        is not already inside an init block, it's automatically placed inside
        an init 0 block.)
    """
    name = tuple(name.split())

    registry[name] = dict(parse=parse,
                          lint=lint,
                          execute=execute,
                          predict=predict,
                          next=next,
                          scry=scry)

    # The function that is called to create an ast.UserStatement.
    def parse_user_statement(l, loc):
        renpy.exports.push_error_handler(l.error)

        try:
            rv = renpy.ast.UserStatement(loc, l.text, l.subblock)
            rv.translatable = translatable

            if not block:
                l.expect_noblock(" ".join(name) + " statement")
                l.advance()
            else:
                l.expect_block(" ".join(name) + " statement")
                l.advance()
        finally:
            renpy.exports.pop_error_handler()

        if init and not l.init:
            rv = renpy.ast.Init(loc, [ rv ], 0)

        return rv

    renpy.parser.statements.add(name, parse_user_statement)

    # The function that is called to get our parse data.
    def parse_data(l):
        return (name, registry[name]["parse"](l))

    parsers.add(name, parse_data)


def parse(node, line, subblock):

    block = [ (node.filename, node.linenumber, line, subblock) ]
    l = renpy.parser.Lexer(block)
    l.advance()

    renpy.exports.push_error_handler(l.error)
    try:

        pf = parsers.parse(l)
        if pf is None:
            l.error("Could not find user-defined statement at runtime.")

        return pf(l)

    finally:
        renpy.exports.pop_error_handler()


def call(method, parsed, *args, **kwargs):
    name, parsed = parsed

    method = registry[name].get(method)
    if method is None:
        return None

    return method(parsed, *args, **kwargs)

def get_name(parsed):
    name, _parsed = parsed
    return " ".join(name)

########NEW FILE########
__FILENAME__ = substitutions
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains support for string translation and string formatting
# operations.

import renpy
import string
import os

update_translations = "RENPY_UPDATE_TRANSLATIONS" in os.environ

class Formatter(string.Formatter):
    """
    A string formatter that uses Ren'Py's formatting rules. Ren'Py uses
    square brackets to introduce formatting, and it supports a q conversion
    that quotes the text being shown to the user.
    """

    def parse(self, s):
        """
        Parses s according to Ren'Py string formatting rules. Returns a list
        of (literal_text, field_name, format, replacement) tuples, just like
        the method we're overriding.
        """

        # States for the parse state machine.
        LITERAL = 0
        OPEN_BRACKET = 1
        VALUE = 3
        FORMAT = 4
        CONVERSION = 5

        # The depth of brackets we've seen.
        bracket_depth = 0

        # The parts we've seen.
        literal = ''
        value = ''
        format = '' #@ReservedAssignment
        conversion = None

        state = LITERAL

        for c in s:

            if state == LITERAL:
                if c == '[':
                    state = OPEN_BRACKET
                    continue
                else:
                    literal += c
                    continue

            elif state == OPEN_BRACKET:
                if c == '[':
                    literal += c
                    state = LITERAL
                    continue

                else:
                    value = c
                    state = VALUE
                    bracket_depth = 0
                    continue

            elif state == VALUE:

                if c == '[':
                    bracket_depth += 1
                    value += c
                    continue

                elif c == ']':

                    if bracket_depth:
                        bracket_depth -= 1
                        value += c
                        continue

                    else:
                        yield (literal, value, format, conversion)
                        state = LITERAL
                        literal = ''
                        value = ''
                        format = '' #@ReservedAssignment
                        conversion = None
                        continue

                elif c == ':':
                    state = FORMAT
                    continue

                elif c == '!':
                    state = CONVERSION
                    conversion = ''
                    continue

                else:
                    value += c
                    continue

            elif state == FORMAT:

                if c == ']':
                    yield (literal, value, format, conversion)
                    state = LITERAL
                    literal = ''
                    value = ''
                    format = '' #@ReservedAssignment
                    conversion = None
                    continue

                elif c == '!':
                    state = CONVERSION
                    conversion = ''
                    continue

                else:
                    format += c
                    continue


            elif state == CONVERSION:
                if c == ']':
                    yield (literal, value, format, conversion)
                    state = LITERAL
                    literal = ''
                    value = ''
                    format = '' #@ReservedAssignment
                    conversion = None
                    continue

                else:
                    conversion += c
                    continue

        if state != LITERAL:
            raise Exception("String {0!r} ends with an open format operation.".format(s))

        if literal:
            yield (literal, None, None, None)

    def convert_field(self, value, conversion):

        if not conversion:
            return value

        if "r" in conversion:
            value = repr(value)
        elif "s" in conversion:
            value = str(value)

        if "t" in conversion:
            value = renpy.translation.translate_string(value)

        if "q" in conversion:
            value = value.replace("{", "{{")

        return value

# The instance of Formatter we use.
formatter = Formatter()

class MultipleDict(object):
    def __init__(self, *dicts):
        self.dicts = dicts

    def __getitem__(self, key):
        for d in self.dicts:
            if key in d:
                return d[key]

        raise KeyError(key)

def substitute(s, scope=None, force=False, translate=True):
    """
    Performs translation and formatting on `s`, as necessary.

    `scope`
        The scope which is used in formatting, in addition to the default
        store.

    `force`
        Force substitution to occur, even if it's disabled in the config.

    `translate`
        Determines if translation occurs.
    """

    if translate:
        s = renpy.translation.translate_string(s)

    # Substitute.
    if not renpy.config.new_substitutions and not force:
        return s

    if "[" in s:

        if scope is not None:
            kwargs = MultipleDict(scope, renpy.store.__dict__) #@UndefinedVariable
        else:
            kwargs = renpy.store.__dict__ #@UndefinedVariable

        s = formatter.vformat(s, (), kwargs)

    return s

########NEW FILE########
__FILENAME__ = extras
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Other text-related things.

import renpy.text

from renpy.text.textsupport import TAG
import renpy.text.textsupport as textsupport


# A list of text tags, mapping from the text tag prefix to if it
# requires a closing tag.
text_tags = dict(
    image=False,
    p=False,
    w=False,
    fast=False,
    b=True,
    i=True,
    u=True,
    a=True,
    plain=True,
    font=True,
    color=True,
    size=True,
    nw=False,
    s=True,
    rt=True,
    rb=True,
    k=True,
    cps=True,
    space=False,
    vspace=False
    )

text_tags[""] = True


# This checks the text tags in a string to be sure they are all matched, and
# properly nested. It returns an error message, or None if the line is okay.
def check_text_tags(s):
    """
    :doc: lint

    Checks the text tags in s for correctness. Returns an error string if there is
    an error, or None if there is no error.
    """

    tokens = textsupport.tokenize(unicode(s))

    tag_stack = [ ]

    for type, text in tokens: #@ReservedAssignment
        if type != TAG:
            continue

        if text[0] == "#":
            continue

        # Strip off arguments for tags.
        if text.find('=') != -1:
            text = text[:text.find('=')]

        # Closing tag.
        if text and text[0] == '/':
            if not tag_stack:
                return "Close text tag '%s' does not match an open text tag." % text

            if tag_stack[-1] != text[1:]:
                return "Close text tag '%s' does not match open text tag '%s'." % (text, tag_stack[-1])

            tag_stack.pop()
            continue

        if text not in text_tags:
            return "Text tag '%s' is not known." % text

        if text_tags[text]:
            tag_stack.append(text)

    if tag_stack:
        return "One or more text tags were left open at the end of the string: " + ", ".join([ "'" + i + "'" for i in tag_stack])

    return None


class ParameterizedText(object):
    """
    This can be used as an image. When used, this image is expected to
    have a single parameter, a string which is rendered as the image.
    """

    def __init__(self, style='default', **properties):
        self.style = style
        self.properties = properties

    def parameterize(self, name, parameters):

        if len(parameters) != 1:
            raise Exception("'%s' takes a single string parameter." %
                            ' '.join(name))

        param = parameters[0]
        string = renpy.python.py_eval(param)

        return renpy.text.text.Text(string, style=self.style, **self.properties)

########NEW FILE########
__FILENAME__ = font
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import pygame

try:
    import xml.etree.ElementTree as etree
except:
    pass

import renpy.display
import renpy.text.ftfont as ftfont
import renpy.text.textsupport as textsupport

ftfont.init() #@UndefinedVariable

WHITE = (255, 255, 255, 255)
BLACK = (0, 0, 0, 255)

class ImageFont(object):

    # ImageFonts are expected to have the following fields defined by
    # a subclass:

    # Font global:
    # height - The line height, the height of each character cell.
    # kerns - The kern between each pair of characters.
    # default_kern - The default kern.
    # baseline - The y offset of the font baseline.

    # Per-character:
    # width - The width of each character.
    # advance - The advance of each character.
    # offsets - The x and y offsets of each character.
    # chars - A map from a character to the surface containing that character.


    def glyphs(self, s):

        rv = [ ]

        if not s:
            return rv

        for c in s:
            g = textsupport.Glyph() #@UndefinedVariable

            g.character = ord(c)
            g.ascent = self.height
            g.line_spacing = self.height

            width = self.width.get(c, None)
            if width is None:
                raise Exception("Character {0!r} not found in image-based font.".format(c))

            g.width = self.width[c]
            g.advance = self.advance[c]

            rv.append(g)

        # Compute kerning.
        for i in range(len(s) - 1):
            kern = self.kerns.get(s[i] + s[i+1], self.default_kern)
            rv[i].advance += kern

        return rv

    def bounds(self, glyphs, bounds):
        return bounds

    def draw(self, target, xo, yo, color, glyphs, underline, strikethrough, black_color):

        if black_color is None:
            return

        for g in glyphs:
            c = unichr(g.character)

            cxo, cyo = self.offsets[c]
            x = g.x + xo + cxo
            y = g.y + yo + cyo - g.ascent

            char_surf = self.chars[c]

            if renpy.config.recolor_sfonts:
                if color != WHITE or black_color != BLACK:
                    new_surf = renpy.display.pgrender.surface(char_surf.get_size(), True)
                    renpy.display.module.twomap(char_surf, new_surf, color, black_color)

                    char_surf = new_surf

            target.blit(char_surf, (x, y))


class SFont(ImageFont):

    def __init__(self,
                 filename,
                 spacewidth,
                 default_kern,
                 kerns,
                 charset):

        super(SFont, self).__init__()

        self.filename = filename
        self.spacewidth = spacewidth
        self.default_kern = default_kern
        self.kerns = kerns
        self.charset = charset

    def load(self):

        self.chars = { } # W0201
        self.width = { } # W0201
        self.advance = { } # W0201
        self.offsets = { } # W0201

        # Load in the image.
        surf = renpy.display.im.Image(self.filename).load(unscaled=True)

        sw, sh = surf.get_size()
        height = sh
        self.height = height # W0201
        self.baseline = height # W0201

        # Create space characters.
        self.chars[u' '] = renpy.display.pgrender.surface((self.spacewidth, height), True)
        self.width[u' '] = self.spacewidth
        self.advance[u' '] = self.spacewidth
        self.offsets[u' '] = (0, 0)

        self.chars[u'\u200b'] = renpy.display.pgrender.surface((0, height), True)
        self.width[u'\u200b'] = 0
        self.advance[u'\u200b'] = 0
        self.offsets[u'\u200b'] = (0, 0)

        self.chars[u'\u00a0'] = self.chars[u' ']
        self.width[u'\u00a0'] = self.width[u' ']
        self.advance[u'\u00a0'] = self.advance[u' ']
        self.offsets[u'\u00a0'] = self.offsets[u' ']

        # The color key used to separate characters.
        i = 0
        while True:
            key = surf.get_at((i, 0))
            if key[3] != 0:
                break
            i += 1

        ci = 0

        # Find real characters, create them.
        while i < sw and ci < len(self.charset):

            if surf.get_at((i, 0)) != key:
                start = i
                i += 1

                while i < sw:
                    if surf.get_at((i, 0)) == key:
                        break

                    i += 1

                c = self.charset[ci]
                ci += 1

                ss = surf.subsurface((start, 0, i - start, height))
                ss = renpy.display.scale.surface_scale(ss)

                self.chars[c] = ss
                self.width[c] = i - start
                self.advance[c] = i - start
                self.offsets[c] = (0, 0)

            i += 1


class MudgeFont(ImageFont):

    def __init__(self,
                 filename,
                 xml,
                 spacewidth,
                 default_kern,
                 kerns):

        super(MudgeFont, self).__init__()

        self.filename = filename
        self.xml = xml
        self.spacewidth = spacewidth
        self.default_kern = default_kern
        self.kerns = kerns

    def load(self):

        self.chars = { } # W0201
        self.width = { } # W0201
        self.advance = { } # W0201
        self.offsets = { } # W0201

        # Load in the image.
        surf = renpy.display.im.Image(self.filename).load(unscaled=True)

        # Parse the xml file.
        tree = etree.fromstring(renpy.loader.load(self.xml).read())

        height = 0

        # Find each character.
        for e in tree.findall("char"):

            char = int(e.attrib["id"])
            if char < 0:
                continue

            c = unichr(char)
            x = int(e.attrib["x"])
            y = int(e.attrib["y"])
            w = int(e.attrib["width"])
            h = int(e.attrib["height"])

            ss = surf.subsurface((x, y, w, h))
            ss = renpy.display.scale.surface_scale(ss)

            self.chars[c] = ss
            self.width[c] = w
            self.advance[c] = w
            self.offsets[c] = (0, 0)

            height = max(height, h)

        self.height = height # W0201
        self.baseline = height # W0201

        # Create space characters.
        if u' ' not in self.chars:
            self.chars[u' '] = renpy.display.pgrender.surface((self.spacewidth, height), True)
            self.width[u' '] = self.spacewidth
            self.advance[u' '] = self.spacewidth
            self.offsets[u' '] = (0, 0)

        if u'\u00a0' not in self.chars:
            self.chars[u'\u00a0'] = self.chars[u' ']
            self.width[u'\u00a0'] = self.width[u' ']
            self.advance[u'\u00a0'] = self.advance[u' ']
            self.offsets[u'\u00a0'] = self.offsets[u' ']

        self.chars[u'\u200b'] = renpy.display.pgrender.surface((0, height), True)
        self.width[u'\u200b'] = 0
        self.advance[u'\u200b'] = 0
        self.offsets[u'\u200b'] = (0, 0)



def parse_bmfont_line(l):
    w = ""
    line = [ ]

    quote = False

    for c in l:
        if c == "\r" or c == "\n":
            continue

        if c == " " and not quote:
            if w:
                line.append(w)
                w = ""
            continue

        if c == "\"":
            quote = not quote
            continue

        w += c

    if w:
        line.append(w)

    map = dict(i.split("=", 1) for i in line[1:]) #@ReservedAssignment
    return line[0], map

class BMFont(ImageFont):

    def __init__(self, filename):
        super(BMFont, self).__init__()

        self.filename = filename

    def load(self):

        self.chars = { } # W0201
        self.width = { } # W0201
        self.advance = { } # W0201
        self.offsets = { } # W0201
        self.kerns = { } # W0201
        self.default_kern = 0 # W0201

        pages = { }

        f = renpy.loader.load(self.filename)
        for l in f:

            kind, args = parse_bmfont_line(l)

            if kind == "common":
                self.height = int(args["lineHeight"]) # W0201
                self.baseline = int(args["base"]) # W0201
            elif kind == "page":
                pages[int(args["id"])] = renpy.display.im.Image(args["file"]).load(unscaled=True)
            elif kind == "char":
                c = unichr(int(args["id"]))
                x = int(args["x"])
                y = int(args["y"])
                w = int(args["width"])
                h = int(args["height"])
                xo = int(args["xoffset"])
                yo = int(args["yoffset"])
                xadvance = int(args["xadvance"])
                page = int(args["page"])

                ss = pages[page].subsurface((x, y, w, h))
                ss = renpy.display.scale.surface_scale(ss)

                self.chars[c] = ss
                self.width[c] = w + xo
                self.advance[c] = xadvance
                self.offsets[c] = (xo, yo)

        f.close()

        if u'\u00a0' not in self.chars:
            self.chars[u'\u00a0'] = self.chars[u' ']
            self.width[u'\u00a0'] = self.width[u' ']
            self.advance[u'\u00a0'] = self.advance[u' ']
            self.offsets[u'\u00a0'] = self.offsets[u' ']


        self.chars[u'\u200b'] = renpy.display.pgrender.surface((0, self.height), True)
        self.width[u'\u200b'] = 0
        self.advance[u'\u200b'] = 0
        self.offsets[u'\u200b'] = (0, 0)


def register_sfont(name=None, size=None, bold=False, italics=False, underline=False,
                   filename=None, spacewidth=10, default_kern=0, kerns={},
                   charset=u"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"):

    """
    :doc: image_fonts

    This registers an SFont with the given details. Please note that size, bold,
    italic, and underline are all advisory (used for matching), and do not
    change the appearance of the font.

    `More information about SFont. <http://www.linux-games.com/sfont/>`_

    `name`
        The name of the font being registered, a string.

    `size`
        The size of the font being registered, an integer.

    `bold`
        The boldness of the font being registered, a boolean.

    `italics`
        The italicness of the font being registered, a boolean.

    `underline`
        An ignored parameter.

    `filename`
        The file containing the sfont image, a string.

    `spacewidth`
        The width of a space character, an integer in pixels.

    `default_kern`
        The default kern spacing between characters, in pixels.

    `kerns`
        A map from two-character strings to the kern that should be used between
        those characters.

    `charset` - The character set of the font. A string containing characters in
        the order in which they are found in the image. The default character
        set for a SFont is::

            ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
            @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _
            ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
    """

    if name is None or size is None or filename is None:
        raise Exception("When registering an SFont, the font name, font size, and filename are required.")

    sf = SFont(filename, spacewidth, default_kern, kerns, charset)
    image_fonts[(name, size, bold, italics)] = sf

def register_mudgefont(name=None, size=None, bold=False, italics=False, underline=False,
                   filename=None, xml=None, spacewidth=10, default_kern=0, kerns={}):

    """
    :doc: image_fonts

    This registers a MudgeFont with the given details. Please note that size,
    bold, italic, and underline are all advisory (used for matching), and do not
    change the appearance of the font.

    Please see the `MudgeFont home page <http://www.larryhastings.com/programming/mudgefont/>`_
    for the tool that creates MudgeFonts. Ren'Py assumes that character codes
    found in the MudgeFont xml file are unicode character numbers, and ignores
    negative character codes.

    `name`
        The name of the font being registered, a string.

    `size`
        The size of the font being registered, an integer.

    `bold`
        The boldness of the font being registered, a boolean.

    `italics`
        The italicness of the font being registered, a boolean.

    `underline`
        An ignored parameter.

    `filename`
        The file containing the MudgeFont image, a string. The image is usually
        a TGA file, but could be a PNG or other format that Ren'PY supports.

    `xml`
        The xml file containing information generated by the MudgeFont tool.

    `spacewidth`
        The width of a space character, an integer in pixels.

    `default_kern`
        The default kern spacing between characters, in pixels.

    `kerns`
        A map from two-character strings to the kern that should be used between
        those characters.
    """

    if name is None or size is None or filename is None or xml is None:
        raise Exception("When registering a Mudge Font, the font name, font size, filename, and xml filename are required.")

    mf = MudgeFont(filename, xml, spacewidth, default_kern, kerns)
    image_fonts[(name, size, bold, italics)] = mf

def register_bmfont(name=None, size=None, bold=False, italics=False, underline=False,
                    filename=None):

    """
    :doc: image_fonts

    This registers a BMFont with the given details. Please note that size, bold,
    italic, and underline are all advisory (used for matching), and do not
    change the appearance of the font.

    Please see the `BMFont home page <http://www.angelcode.com/products/bmfont/>`_
    for the tool that creates BMFonts. Ren'Py expects that the filename
    parameter will be to a file in the BMFont text format, that describes a
    32-bit font. The Alpha channel should contain the font information, while
    the Red, Green, and Blue channels should be set to one. The image files,
    kerning, and other control information is read out of the BMFont file.

    We recommend including Latin and General Punctuation as part of your BMFont,
    to ensure all of the Ren'Py interface can render.

    `name`
        The name of the font being registered, a string.

    `size`
        The size of the font being registered, an integer.

    `bold`
        The boldness of the font being registered, a boolean.

    `italics`
        The italicness of the font being registered, a boolean.

    `underline`
        An ignored parameter.

    `filename`
        The file containing BMFont control information.
    """

    bmf = BMFont(filename)
    image_fonts[(name, size, bold, italics)] = bmf

# A map from face name to ftfont.FTFace
face_cache = { }

def load_face(fn):

    if fn in face_cache:
        return face_cache[fn]

    orig_fn = fn

    # Figure out the font index.
    index = 0

    if "@" in fn:
        index, fn = fn.split("@", 1)
        index = int(index)

    font_file = None

    try:
        font_file = renpy.loader.load(fn)
    except IOError:

        # Let's try to find the font on our own.
        fonts = [ i.strip().lower() for i in fn.split(",") ]

        pygame.sysfont.initsysfonts()

        for v in pygame.sysfont.Sysfonts.itervalues():
            if v is not None:
                for _flags, ffn in v.iteritems():
                    for i in fonts:
                        if ffn.lower().endswith(i):
                            font_file = file(ffn, "rb")
                            break

                    if font_file:
                        break

            if font_file:
                break


    if font_file is None:
        raise Exception("Could not find font {0!r}.".format(orig_fn))

    rv = ftfont.FTFace(font_file, index) #@UndefinedVariable

    face_cache[orig_fn] = rv

    return rv

# Caches of fonts.
image_fonts = { }
font_cache = { }

def get_font(fn, size, bold, italics, outline, antialias, vertical):

    t = (fn, bold, italics)
    fn, bold, italics = renpy.config.font_replacement_map.get(t, t)

    rv = image_fonts.get((fn, size, bold, italics), None)
    if rv is not None:
        return rv

    if vertical:
        key = (fn, size, bold, italics, outline, antialias, True)
    else:
        key = (fn, size, bold, italics, outline, antialias)

    rv = font_cache.get(key, None)
    if rv is not None:
        return rv

    # If we made it here, we need to load a ttf.
    face = load_face(fn)

    rv = ftfont.FTFont(face, size, bold, italics, outline, antialias, vertical) #@UndefinedVariable

    font_cache[key] = rv

    return rv

def free_memory():
    """
    Clears the font cache.
    """

    font_cache.clear()
    face_cache.clear()

def load_image_fonts():
    for i in image_fonts.itervalues():
        i.load()


class FontGroup(object):
    """
    :doc: font_group
    :args: ()

    A group of fonts that can be used as a single font.
    """

    def __init__(self):

        # A list of font names we know of.
        self.fonts = [ ]

        # A map from character to the index of the font it's part of.
        self.cache = { }

        # A list of (index, start, end) tuples.
        self.patterns = [ ]

    def add(self, font, start, end):
        """
        :doc: font_group

        Associates a range of characters with a `font`.

        `start`
            The start of the range. This may be a single-character string, or
            an integer giving a unicode code point.

        `end`
            The end of the range. This may be a single-character string, or an
            integer giving a unicode code point.

        When multiple .add() calls include the same character, the first call
        takes precedence.

        This returns the FontGroup, so that multiple calls to .add() can be
        chained together.
        """

        if not isinstance(start, int):
            start = ord(start)

        if not isinstance(end, int):
            end = ord(end)

        if end < start:
            raise Exception("In FontGroup.add, the start of a character range must be before the end of the range.")

        if font not in self.fonts:
            self.fonts.append(font)

        index = self.fonts.index(font)

        self.patterns.append((index, start, end))

        return self

    def segment(self, s):
        """
        Segments `s` into fonts. Generates (font, string) tuples.
        """

        mark = 0
        pos = 0

        old_index = 0

        cache = self.cache

        for c in s:

            index = cache.get(c, None)

            if index is None:
                n = ord(c)

                for index, start, end in self.patterns:
                    if start <= n <= end:
                        break
                else:
                    raise Exception("Character U+{0:04x} not found in FontGroup".format(n))

                cache[c] = index

            if index != old_index:
                if pos:
                    yield self.fonts[old_index], s[mark:pos]

                old_index = index
                mark = pos

            pos += 1

        yield self.fonts[old_index], s[mark:]


########NEW FILE########
__FILENAME__ = text
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import math
import renpy.display

from renpy.text.textsupport import TAG, TEXT, PARAGRAPH, DISPLAYABLE

import renpy.text.textsupport as textsupport
import renpy.text.texwrap as texwrap
import renpy.text.font as font
import renpy.text.extras as extras

try:
    from _renpybidi import log2vis, WRTL, RTL, ON
except:
    pass

class Blit(object):
    """
    Represents a blit command, which can be used to render a texture to a
    render. This is a rectangle with an associated alpha.
    """

    def __init__(self, x, y, w, h, alpha=1.0):
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.alpha = alpha

    def __repr__(self):
        return "<Blit ({0}, {1}, {2}, {3}) {4}>".format(self.x, self.y, self.w, self.h, self.alpha)


def outline_blits(blits, outline):
    """
    Given a list of blits, adjusts it for the given outline size. That means
    adding borders on the left and right of each line of blits. Returns a second
    list of blit objects.

    We assume that there are a discrete set of vertical areas that divide the
    original blits, and that no blit covers two vertical areas. So something
    like:

     _____________________________________
    |_____________________________________|
    |___________|_________________|_______|
    |_____________________|_______________|

    is fine, but:

     _____________________________________
     |              |_____________________|
     |______________|_____________________|

    is forbidden. That's an invariant that the blit_<method> functions are
    required to enforce.
    """

    # Sort the blits.
    blits.sort(key=lambda b : (b.y, b.x))

    # The y coordinate that everything in the current line shares. This can
    # be adjusted in the output blits.
    line_y = 0

    # The y coordinate of the top of the current line.
    top_y = 0

    # The y coordinate of the bottom of the current line.
    bottom_y = 0


    # The maximum x coordinate of the previous blit on this line.
    max_x = 0

    rv = [ ]

    for b in blits:

        x0 = b.x
        x1 = b.x + b.w + outline * 2

        y0 = b.y
        y1 = b.y + b.h + outline * 2

        # Prevents some visual artifacting, where the two lines can overlap.
        y1 -= 1

        if line_y != y0:
            line_y = y0
            top_y = bottom_y
            max_x = 0

        y0 = top_y

        if y1 > bottom_y:
            bottom_y = y1

        if max_x > x0:
            x0 = max_x

        max_x = x1

        rv.append(Blit(x0, y0, x1 - x0, y1 - y0, b.alpha))

    return rv


class DrawInfo(object):
    """
    This object is supplied as a parameter to the draw method of the various
    segments. It has the following fields:

    `surface`
        The surface to draw to.

    `override_color`
        If not None, a color that's used for this outline/shadow.

    `outline`
        The amount to outline the text by.

    `displayable_blits`
        If not none, this is a list of (displayable, xo, yo) tuples. The draw
        method adds displayable blits to this list when this is not None.
    """

    # No implementation, this is set up in the layout object.


class TextSegment(object):
    """
    This represents a segment of text that has a single set of properties
    applied to it.
    """

    def __init__(self, source=None):
        """
        Creates a new segment of text. If `source` is given, this starts off
        a copy of that source segment. Otherwise, it's up to the code that
        creates it to initialize it with defaults.
        """

        if source is not None:
            self.antialias = source.antialias
            self.vertical = source.vertical
            self.font = source.font
            self.size = source.size
            self.bold = source.bold
            self.italic = source.italic
            self.underline = source.underline
            self.strikethrough = source.strikethrough
            self.color = source.color
            self.black_color = source.black_color
            self.hyperlink = source.hyperlink
            self.kerning = source.kerning
            self.cps = source.cps
            self.ruby_top = source.ruby_top
            self.ruby_bottom = source.ruby_bottom

        else:
            self.hyperlink = 0
            self.cps = 0
            self.ruby_top = False
            self.ruby_bottom = False

    def __repr__(self):
        return "<TextSegment font={font}, size={size}, bold={bold}, italic={italic}, underline={underline}, color={color}, black_color={black_color}, hyperlink={hyperlink}, vertical={vertical}>".format(**self.__dict__)

    def take_style(self, style):
        """
        Takes the style of this text segement from the named style object.
        """

        self.antialias = style.antialias
        self.vertical = style.vertical
        self.font = style.font
        self.size = style.size
        self.bold = style.bold
        self.italic = style.italic
        self.underline = style.underline
        self.strikethrough = style.strikethrough
        self.color = style.color
        self.black_color = style.black_color
        self.hyperlink = None
        self.kerning = style.kerning

        if style.slow_cps is True:
            self.cps = renpy.game.preferences.text_cps

        self.cps = self.cps * style.slow_cps_multiplier

    # From here down is the public glyph API.

    def glyphs(self, s):
        """
        Return the list of glyphs corresponding to unicode string s.
        """

        fo = font.get_font(self.font, self.size, self.bold, self.italic, 0, self.antialias, self.vertical)
        rv = fo.glyphs(s)

        # Apply kerning to the glyphs.
        if self.kerning:
            textsupport.kerning(rv, self.kerning)

        if self.hyperlink:
            for g in rv:
                g.hyperlink = self.hyperlink

        if self.ruby_bottom:
            textsupport.mark_ruby_bottom(rv)
        elif self.ruby_top:
            textsupport.mark_ruby_top(rv)

        return rv

    def draw(self, glyphs, di, xo, yo):
        """
        Draws the glyphs to surf.
        """

        if di.override_color:
            color = di.override_color
            black_color = None
        else:
            color = self.color
            black_color = self.black_color

        fo = font.get_font(self.font, self.size, self.bold, self.italic, di.outline, self.antialias, self.vertical)
        fo.draw(di.surface, xo, yo, color, glyphs, self.underline, self.strikethrough, black_color)

    def assign_times(self, gt, glyphs):
        """
        Assigns times to the glyphs. `gt` is the starting time of the first
        glyph, and it returns the starting time of the first glyph in the next
        segment.
        """

        return textsupport.assign_times(gt, self.cps, glyphs)

    def subsegment(self, s):
        """
        This is called to break the current text segment up into multiple
        text segments. It yields one or more(TextSegement, string) tuples
        for each sub-segment it creates.

        This is used by the FontGroup code to create new text segments based
        on the font group.
        """


        if not isinstance(self.font, font.FontGroup):
            yield (self, s)
            return

        segs = { }

        for f, ss in self.font.segment(s):

            seg = segs.get(f, None)

            if seg is None:
                seg = TextSegment(self)
                seg.font = f

                segs[f] = seg

            yield seg, ss

    def bounds(self, glyphs, bounds):
        """
        Given an x, y, w, h bounding box, returns the union of the given
        bounding box and the bounding box the glyphs will actually be drawn
        into, not including any offsets or expansions.

        This is used to deal with glyphs that are on the wrong side of the
        origin point.
        """

        fo = font.get_font(self.font, self.size, self.bold, self.italic, 0, self.antialias, self.vertical)
        return fo.bounds(glyphs, bounds)

class SpaceSegment(object):
    """
    A segment that's used to render horizontal or vertical whitespace.
    """

    def __init__(self, ts, width=0, height=0):
        """
        `ts`
            The text segment that this SpaceSegment follows.
        """

        self.glyph = glyph = textsupport.Glyph()

        glyph.character = 0
        glyph.ascent = 0
        glyph.line_spacing = height
        glyph.advance = width
        glyph.width = width

        if ts.hyperlink:
            glyph.hyperlink = ts.hyperlink

        self.cps = ts.cps

    def glyphs(self, s):
        return [ self.glyph ]

    def bounds(self, glyphs, bounds):
        return bounds

    def draw(self, glyphs, di, xo, yo):
        # Does nothing - since there's nothing to draw.
        return

    def assign_times(self, gt, glyphs):
        if self.cps != 0:
            gt += 1.0 / self.cps

        self.glyph.time = gt
        return gt


class DisplayableSegment(object):
    """
    A segment that's used to render horizontal or vertical whitespace.
    """

    def __init__(self, ts, d, renders):
        """
        `ts`
            The text segment that this SpaceSegment follows.
        """

        self.d = d
        rend = renders[d]

        w, h = rend.get_size()

        self.glyph = glyph = textsupport.Glyph()

        glyph.character = 0
        glyph.ascent = 0
        glyph.line_spacing = h
        glyph.advance = w
        glyph.width = w

        if ts.hyperlink:
            glyph.hyperlink = ts.hyperlink

        self.cps = ts.cps

    def glyphs(self, s):
        return [ self.glyph ]

    def draw(self, glyphs, di, xo, yo):
        if di.displayable_blits is not None:
            di.displayable_blits.append((self.d, self.glyph.x, self.glyph.y, self.glyph.time))

    def assign_times(self, gt, glyphs):
        if self.cps != 0:
            gt += 1.0 / self.cps

        self.glyph.time = gt
        return gt

    def bounds(self, glyphs, bounds):
        return bounds

class FlagSegment(object):
    """
    A do-nothing segment that just exists so we can flag the start and end
    of a run of text.
    """

    def glyphs(self, s):
        return [ ]

    def draw(self, glyphs, di, xo, yo):
        return

    def assign_times(self, gt, glyphs):
        return gt

    def bounds(self, glyphs, bounds):
        return bounds

class Layout(object):
    """
    Represents the layout of text.
    """

    def __init__(self, text, width, height, renders, size_only=False):
        """
        `text`
            The text object this layout is associated with.

        `width`, `height`
            The height of the laid-out text.

        `renders`
            A map from displayable to its render.

        `size_only`
            If true, layout will stop once the size field is filled
            out. The object will only be suitable for sizing, as it
            will be missing the textures required to render it.
        """

        style = text.style

        self.line_overlap_split = style.line_overlap_split

        # Do we have any hyperlinks in this text? Set by segment.
        self.has_hyperlinks = False

        # Do we have any ruby in the text?
        self.has_ruby = False

        # Slow text that is not before the start segment is displayed
        # instantaneously. Text after the end segment is not displayed
        # at all. These are controlled by the {_start} and {_end} tags.
        self.start_segment = None
        self.end_segment = None

        self.width = width
        self.height = height

        # Figure out outlines and other info.
        outlines, xborder, yborder, xoffset, yoffset = self.figure_outlines(style)
        self.outlines = outlines
        self.xborder = xborder
        self.yborder = yborder
        self.xoffset = xoffset
        self.yoffset = yoffset

        # Adjust the borders by the outlines.
        width -= self.xborder
        height -= self.yborder

        # The greatest x coordinate of the text.
        maxx = 0

        # The current y, which becomes the maximum height once all paragraphs
        # have been rendered.
        y = 0

        # A list of glyphs - all the glyphs we know of.
        all_glyphs = [ ]

        # A list of (segment, glyph_list) pairs for all paragraphs.
        par_seg_glyphs = [ ]

        # A list of Line objects.
        lines = [ ]

        # The time at which the next glyph will be displayed.
        gt = 0.0

        # True if we've encountered the end segment while assigning times.
        ended = False

        # 2. Breaks the text into a list of paragraphs, where each paragraph is
        # represented as a list of (Segment, text string) tuples.
        #
        # This takes information from the various styles that apply to the text,
        # and so needs to be redone when the style of the text changes.
        self.paragraphs = self.segment(text.tokens, style, renders)

        first_indent = style.first_indent
        rest_indent = style.rest_indent

        for p in self.paragraphs:

            # RTL - apply RTL to the text of each segment, then
            # reverse the order of the segments in each paragraph.
            if renpy.config.rtl:
                p, rtl = self.rtl_paragraph(p)
            else:
                rtl = False

            # 3. Convert each paragraph into a Segment, glyph list. (Store this
            # to use when we draw things.)

            # A list of glyphs in the line.
            line_glyphs = [ ]

            # A list of (segment, list of glyph) pairs.
            seg_glyphs = [ ]

            for ts, s in p:
                glyphs = ts.glyphs(s)

                t = (ts, glyphs)
                seg_glyphs.append(t)
                par_seg_glyphs.append(t)
                line_glyphs.extend(glyphs)
                all_glyphs.extend(glyphs)

            # RTL - Reverse each line, segment, so that we can use LTR
            # linebreaking algorithms.
            if rtl:
                line_glyphs.reverse()
                for ts, glyphs in seg_glyphs:
                    glyphs.reverse()

            # Tag the glyphs that are eligible for line breaking, and if
            # they should be included or excluded from the end of a line.
            language = style.language

            if language == "unicode" or language == "eastasian":
                textsupport.annotate_unicode(line_glyphs, False, 0)
            elif language == "korean-with-spaces":
                textsupport.annotate_unicode(line_glyphs, True, 0)
            elif language == "western":
                textsupport.annotate_western(line_glyphs)
            elif language == "japanese-loose":
                textsupport.annotate_unicode(line_glyphs, False, 1)
            elif language == "japanese-normal":
                textsupport.annotate_unicode(line_glyphs, False, 2)
            elif language == "japanese-strict":
                textsupport.annotate_unicode(line_glyphs, False, 3)
            else:
                raise Exception("Unknown language: {0}".format(language))

            # Break the paragraph up into lines.
            layout = style.layout

            if layout == "tex":
                texwrap.linebreak_tex(line_glyphs, width - first_indent, width - rest_indent, False)
            elif layout == "subtitle" or layout == "tex-subtitle":
                texwrap.linebreak_tex(line_glyphs, width - first_indent, width - rest_indent, True)
            elif layout == "greedy":
                textsupport.linebreak_greedy(line_glyphs, width - first_indent, width - rest_indent)
            elif layout == "nobreak":
                textsupport.linebreak_nobreak(line_glyphs)
            else:
                raise Exception("Unknown layout: {0}".format(layout))

            for ts, glyphs in seg_glyphs:
                # Only assign a time if we're past the start segment.
                if self.start_segment is not None:
                    if self.start_segment is ts:
                        self.start_segment = None
                    else:
                        continue

                if ts is self.end_segment:
                    ended = True

                if ended:
                    textsupport.assign_times(gt, 0.0, glyphs)
                else:
                    gt = ts.assign_times(gt, glyphs)

            # RTL - Reverse the glyphs in each line, back to RTL order,
            # now that we have lines.
            if rtl:
                line_glyphs = textsupport.reverse_lines(line_glyphs)

            # Taking into account indentation, kerning, justification, and text_align,
            # lay out the X coordinate of each glyph.

            w = textsupport.place_horizontal(line_glyphs, 0, first_indent, rest_indent)
            if w > maxx:
                maxx = w

            # Figure out the line height, line spacing, and the y coordinate of each
            # glyph.
            l, y = textsupport.place_vertical(line_glyphs, y, style.line_spacing, style.line_leading)
            lines.extend(l)

            # Figure out the indent of the next line.
            first_indent = style.newline_indent
            if first_indent is None:
                first_indent = rest_indent

        if style.line_spacing < 0:
            if renpy.config.broken_line_spacing:
                y += -style.line_spacing * len(lines)
            else:
                y += -style.line_spacing

            lines[-1].height = y - lines[-1].y

        if style.min_width > maxx + self.xborder:
            maxx = style.min_width - self.xborder

        maxx = math.ceil(maxx)

        textsupport.align_and_justify(lines, maxx, style.text_align, style.justify)

        # Figure out the size of the texture. (This is a little over-sized,
        # but it simplifies the code to not have to care about borders on a
        # per-outline basis.)
        sw, sh = size = (maxx + self.xborder, y + self.yborder)
        self.size = size

        # If we only care about the size, we're done.
        if size_only:
            return

        # Place ruby.
        if self.has_ruby:
            textsupport.place_ruby(all_glyphs, style.ruby_style.yoffset, sw, sh)

        # Check for glyphs that are being drawn out of bounds, because the font
        # or anti-aliasing or whatever makes them bigger than the bounding box. If
        # we have them, grow the b

        bounds = (0, 0, maxx, y)
        for ts, glyphs in par_seg_glyphs:
            bounds = ts.bounds(glyphs, bounds)


        self.add_left = max(-bounds[0], 0)
        self.add_top = max(-bounds[1], 0)
        self.add_right = max(bounds[2] - maxx, 0)
        self.add_bottom = max(bounds[3] - y, 0)

        sw += self.add_left * 10 + self.add_right
        sh += self.add_top + self.add_bottom

        # A map from (outline, color) to a texture.
        self.textures = { }

        di = DrawInfo()

        for o, color, _xo, _yo in self.outlines:
            key = (o, color)

            if key in self.textures:
                continue

            # Create the texture.
            surf = renpy.display.pgrender.surface((sw, sh), True)

            di.surface = surf
            di.override_color = color
            di.outline = o

            if color == None:
                self.displayable_blits = [ ]
                di.displayable_blits = self.displayable_blits
            else:
                di.displayable_blits = None

            for ts, glyphs in par_seg_glyphs:
                if ts is self.end_segment:
                    break

                ts.draw(glyphs, di, self.add_left, self.add_top)


            renpy.display.draw.mutated_surface(surf)
            tex = renpy.display.draw.load_texture(surf)

            self.textures[key] = tex

        # Compute the max time for all lines, and the max max time.
        self.max_time = textsupport.max_times(lines)

        # Store the lines, so we have them for typeout.
        self.lines = lines

        # Store the hyperlinks, if any.
        if self.has_hyperlinks:
            self.hyperlinks = textsupport.hyperlink_areas(lines)
        else:
            self.hyperlinks = [ ]

        # Log an overflow if the laid out width or height is larger than the
        # size of the provided area.
        if renpy.config.debug_text_overflow:
            ow, oh = self.size

            if ow > width or oh > height:
                filename, line = renpy.exports.get_filename_line()

                renpy.display.to_log.write("")
                renpy.display.to_log.write("File \"%s\", line %d, text overflow:", filename, line)
                renpy.display.to_log.write("     Available: (%d, %d) Laid-out: (%d, %d)", width, height, sw, sh)
                renpy.display.to_log.write("     Text: %r", text.text)

    def segment(self, tokens, style, renders):
        """
        Breaks the text up into segments. This creates a list of paragraphs,
        which each paragraph being represented as a list of TextSegment, glyph
        list tuples.
        """

        # A map from an integer to the number of the hyperlink this segment
        # is part of.
        self.hyperlink_targets = { }

        paragraphs = [ ]
        line = [ ]

        ts = TextSegment(None)

        ts.cps = style.slow_cps
        if ts.cps is None or ts.cps is True:
            ts.cps = renpy.game.preferences.text_cps

        ts.take_style(style)

        # The text segement stack.
        tss = [ ts ]

        def push():
            """
            Creates a new text segment, and pushes it onto the text segement
            stack. Returns the new text segment.
            """

            ts = TextSegment(tss[-1])
            tss.append(ts)

            return ts

        for type, text in tokens: #@ReservedAssignment

            if type == PARAGRAPH:

                # Note that this code is duplicated for the p tag, and for
                # the empty line case, below.
                if not line:
                    line.extend(tss[-1].subsegment(u" "))

                paragraphs.append(line)
                line = [ ]

                continue

            elif type == TEXT:
                line.extend(tss[-1].subsegment(text))
                continue

            elif type == DISPLAYABLE:
                line.append((DisplayableSegment(tss[-1], text, renders), u""))
                continue

            # Otherwise, we have a text tag.

            tag, _, value = text.partition("=")

            if tag and tag[0] == "/":
                tss.pop()

                if not tss:
                    raise Exception("%r closes a text tag that isn't open." % text)

            elif tag == "_start":
                fs = FlagSegment()
                line.append((fs, ""))
                self.start_segment = fs

            elif tag == "_end":
                fs = FlagSegment()
                line.append((fs, ""))
                self.end_segment = fs

            elif tag == "p":
                # Duplicated from the newline tag.

                if not line:
                    line.extend(tss[-1].subsegment(u" "))

                paragraphs.append(line)
                line = [ ]

            elif tag == "space":
                width = int(value)
                line.append((SpaceSegment(tss[-1], width=width), u""))

            elif tag == "vspace":
                # Duplicates from the newline tag.

                height = int(value)

                if line:
                    paragraphs.append(line)

                line = [ (SpaceSegment(tss[-1], height=height), u"") ]
                paragraphs.append(line)

                line = [ ]

            elif tag == "w":
                pass

            elif tag == "fast":
                pass

            elif tag == "nw":
                pass

            elif tag == "a":
                self.has_hyperlinks = True

                hyperlink_styler = style.hyperlink_functions[0]

                if hyperlink_styler:
                    hls = hyperlink_styler(value)
                else:
                    hls = style

                old_prefix = hls.prefix

                link = len(self.hyperlink_targets) + 1
                self.hyperlink_targets[link] = value

                if renpy.display.focus.argument == link:
                    hls.set_prefix("hover_")
                else:
                    hls.set_prefix("idle_")

                ts = push()
                # inherit vertical style
                vert_style = ts.vertical
                ts.take_style(hls)
                ts.vertical = vert_style
                ts.hyperlink = link

                hls.set_prefix(old_prefix)

            elif tag == "b":
                push().bold = True

            elif tag == "i":
                push().italic = True

            elif tag == "u":
                push().underline = True

            elif tag == "s":
                push().strikethrough = True

            elif tag == "plain":
                ts = push()
                ts.bold = False
                ts.italic = False
                ts.underline = False
                ts.strikethrough = False

            elif tag == "":
                style = getattr(renpy.store.style, value)
                push().take_style(style)

            elif tag == "font":
                push().font = value

            elif tag == "size":
                if value[0] in "+-":
                    push().size += int(value)
                else:
                    push().size = int(value)

            elif tag == "color":
                push().color = renpy.easy.color(value)

            elif tag == "k":
                push().kerning = float(value)

            elif tag == "rt":
                ts = push()
                # inherit vertical style
                vert_style = ts.vertical
                ts.take_style(style.ruby_style)
                ts.vertical = vert_style
                ts.ruby_top = True
                self.has_ruby = True

            elif tag == "rb":
                push().ruby_bottom = True
                # We only care about ruby if we have a top.

            elif tag == "cps":
                ts = push()

                if value[0] == "*":
                    ts.cps *= float(value[1:])
                else:
                    ts.cps = float(value)

            elif tag == "vert":
                push().vertical = True

            elif tag == "horiz":
                ts = push()
                ts.vertical = False

            elif tag[0] == "#":
                pass

            else:
                raise Exception("Unknown text tag %r" % text)

        if not line:
            line.extend(tss[-1].subsegment(u" "))

        paragraphs.append(line)

        return paragraphs

    def rtl_paragraph(self, p):
        """
        Given a paragraph (a list of segment, text tuples) handles
        RTL and ligaturization. This returns the reversed RTL paragraph,
        which differers from the LTR one. It also returns a flag that is
        True if this is an rtl paragraph.
        """

        direction = ON

        l = [ ]

        for ts, s in p:
            s, direction = log2vis(s, direction)
            l.append((ts, s))

        rtl = (direction == RTL or direction == WRTL)

        return l, rtl


    def figure_outlines(self, style):
        """
        Return a list containing the outlines, including an outline
        representing the drop shadow, if we have one, also including
        an entry for the main text, with color None. Also returns the
        space reserved for outlines - to be deducted from the width
        and the height.
        """

        style_outlines = style.outlines
        dslist = style.drop_shadow

        if not style_outlines and not dslist:
            return [ (0, None, 0, 0) ], 0, 0, 0, 0

        outlines = [ ]

        if dslist:
            if not isinstance(dslist, list):
                dslist = [ dslist ]

            for dsx, dsy in dslist:
                outlines.append((0, style.drop_shadow_color, dsx, dsy))

        outlines.extend(style_outlines)

        # The outline borders we reserve.
        left = 0
        right = 0
        top = 0
        bottom = 0

        for o, _c, x, y in outlines:

            l = x - o
            r = x + o
            t = y - o
            b = y + o

            if l < left:
                left = l

            if r > right:
                right = r

            if t < top:
                top = t

            if b > bottom:
                bottom = b

        outlines.append((0, None, 0, 0))

        return outlines, right - left, bottom - top, -left, -top


    def blits_typewriter(self, st):
        """
        Given a st and an outline, returns a list of blit objects that
        can be used to blit those objects.
        """

        width, max_height = self.size

        rv = [ ]

        max_y = 0

        for l in self.lines:

            if l.max_time > st:
                break

            max_y = min(l.y + l.height + self.line_overlap_split, max_height)

        else:
            l = None

        if max_y:
            rv.append(Blit(0, 0, width, max_y))

        if l is None:
            return rv

        # If l is not none, then we have a line for which max_time has not
        # yet been reached. Blit it.

        min_x = width
        max_x = 0

        for g in l.glyphs:

            if g.time > st:
                continue

            if g.x + g.advance > max_x:
                max_x = g.x + g.advance

            if g.x  < min_x:
                min_x = g.x

        ly = min(l.y + l.height + self.line_overlap_split, max_height)

        if min_x < max_x:
            rv.append(Blit(min_x, max_y, max_x - min_x, ly - max_y))

        return rv

    def redraw_typewriter(self, st):
        """
        Return the time of the first glyph that should be shown after st.
        """

        for l in self.lines:
            if not l.glyphs:
                continue

            if l.max_time > st:
                break

        else:
            return None

        return 0

# The maximum number of entries in the layout cache.
LAYOUT_CACHE_SIZE = 50

# Maps from a text to the layout of that text - in an old and new generation.
layout_cache_old = { }
layout_cache_new = { }

def layout_cache_clear():
    """
    Clears the old and new layout caches.
    """

    global layout_cache_old, layout_cache_new
    layout_cache_old = { }
    layout_cache_new = { }

def layout_cache_tick():
    """
    Called once per interaction, to merge the old and new layout caches.
    """

    global layout_cache_old, layout_cache_new
    layout_cache_old = layout_cache_new
    layout_cache_new = { }

VERT_REVERSE = renpy.display.render.Matrix2D(0, -1, 1, 0)
VERT_FORWARD = renpy.display.render.Matrix2D(0, 1, -1, 0)

class Text(renpy.display.core.Displayable):

    """
    :doc: text
    :args: (text, slow=None, scope=None, substitute=None, slow_done=None, **properties)

    A displayable that displays text on the screen.

    `text`
        The text to display on the screen. This may be a string, or a list of
        strings and displayables.

    `slow`
        Determines if the text is displayed slowly, being typed out one character at the time.
        If None, slow text mode is determined by the :propref:`slow_cps` style property. Otherwise,
        the truth value of this parameter determines if slow text mode is used.

    `scope`
        If not None, this should be a dictionary that provides an additional scope for text
        interpolation to occur in.

    `substitute`
        If true, text interpolation occurs. If false, it will not occur. If
        None, they are controlled by :var:`config.new_substitutions`.
    """

    __version__ = 4

    def after_upgrade(self, version):

        if version < 3:
            self.ctc = None

        if version < 4:

            if not isinstance(self.text, list):
                self.text = [ self.text ]

            self.scope = None
            self.substitute = False
            self.start = None
            self.end = None
            self.dirty = True

    def __init__(self, text, slow=None, scope=None, substitute=None, slow_done=None, replaces=None, **properties):

        super(Text, self).__init__(**properties)

        # We need text to be a list, so if it's not, wrap it.
        if not isinstance(text, list):
            text = [ text ]

        # Check that the text is all text-able things.
        for i in text:
            if not isinstance(i, (basestring, renpy.display.core.Displayable)):
                if renpy.config.developer:
                    raise Exception("Cannot display {0!r} as text.".format(i))
                else:
                    text = [ "" ]
                    break

        # True if we are substituting things in.
        self.substitute = substitute

        # The text, after substitutions.
        self.text = None

        # Sets the text we're showing, and performs substitutions.
        self.set_text(text, scope, substitute)

        if renpy.game.less_updates:
            slow = False

        # True if we're using slow text mode.
        self.slow = slow

        # The callback to be called when slow-text mode ends.
        self.slow_done = None

        # The ctc indicator associated with this text.
        self.ctc = None

        # The index of the start and end strings in the first segment of text.
        # (None to show the whole text.)
        self.start = None
        self.end = None

        if replaces is not None:
            self.slow = replaces.slow
            self.slow_done = replaces.slow_done
            self.ctc = replaces.ctc
            self.start = replaces.start
            self.end = replaces.end

        # Do we need to update ourselves?
        self.dirty = True

        # The list of displayables we use.
        self.displayables = None

    def __unicode__(self):
        s = ""

        for i in self.text:
            if isinstance(s, basestring):
                s += i

            if len(s) > 25:
                s = s[:24] + u"\u2026"
                break

        s = s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n")
        return u"Text \"{}\"".format(s)

    def _scope(self, scope):
        """
        Called to update the scope, when necessary.
        """

        self.set_text(self.text_parameter, scope, self.substitute)

    def set_text(self, text, scope=None, substitute=False):

        old_text = self.text

        if not isinstance(text, list):
            text = [ text ]

        # The text parameter, before substitutions were performed.
        self.text_parameter = text

        self.text = [ ]

        # Perform substitution as necessary.
        for i in text:
            if isinstance(i, basestring):
                if substitute is not False:
                    i = renpy.substitutions.substitute(i, scope, substitute)

                i = unicode(i)

            self.text.append(i)

        if self.text != old_text:
            self.dirty = True
            renpy.display.render.redraw(self, 0)

    def set_ctc(self, ctc):
        self.ctc = ctc
        self.dirty = True

    def update(self):
        """
        This needs to be called after text has been updated, but before
        any layout objects are created.
        """

        self.dirty = False

        self.kill_layout()

        text = self.text

        # Decide the portion of the text to show quickly, the part to
        # show slowly, and the part not to show (but to lay out).
        if self.start is not None:
            start_string = text[0][:self.start]
            mid_string = text[0][self.start:self.end]
            end_string = text[0][self.end:]

            if start_string:
                start_string = start_string + "{_start}"

            if end_string:
                end_string = "{_end}" + end_string

            text_split = [ ]

            if start_string:
                text_split.append(start_string)

            text_split.append(mid_string)

            if self.ctc is not None:
                text_split.append(self.ctc)

            if end_string:
                text_split.append(end_string)

            text_split.extend(text[1:])

            text = text_split

        else:
            # Add the CTC.
            if self.ctc is not None:
                text.append(self.ctc)

        # Tokenize the text.
        tokens = self.tokenize(text)

        # self.tokens is a list of pairs, where the first component of
        # each pair is TEXT, NEWLINE, TAG, or DISPLAYABLE, and the second
        # is text or a displayable.
        #
        # self.displayables is the set of displayables used by this
        # Text.
        self.tokens, self.displayables = self.get_displayables(tokens)


    def visit(self):

        if self.dirty or self.displayables is None:
            self.update()

        return list(self.displayables)

    def kill_layout(self):
        """
        Kills the layout of this Text. Used when the text or style
        changes.
        """

        key = id(self)
        layout_cache_old.pop(key, None)
        layout_cache_new.pop(key, None)

    def get_layout(self):
        """
        Gets the layout of this Text, creating a new layout object if
        none exists.
        """

        key = id(self)

        rv = layout_cache_new.get(key, None)

        if rv is None:
            rv = layout_cache_old.get(key, None)

        return rv

    def focus(self, default=False):
        """
        Called when a hyperlink gains focus.
        """

        layout = self.get_layout()

        self.kill_layout()
        renpy.display.render.redraw(self, 0)

        if layout is None:
            return

        hyperlink_focus = self.style.hyperlink_functions[2]
        target = layout.hyperlink_targets.get(renpy.display.focus.argument, None)

        if hyperlink_focus:
            return hyperlink_focus(target)

    def set_style_prefix(self, prefix, root):
        if prefix != self.style.prefix:
            self.kill_layout()

        super(Text, self).set_style_prefix(prefix, root)

    def unfocus(self, default=False):
        """
        Called when a hyperlink loses focus, or isn't focused to begin with.
        """

        self.kill_layout()
        renpy.display.render.redraw(self, 0)

        hyperlink_focus = self.style.hyperlink_functions[2]

        if hyperlink_focus:
            return hyperlink_focus(None)

    def call_slow_done(self, st):
        """
        Called when slow is finished.
        """

        self.slow = False

        if self.slow_done:
            self.slow_done()
            self.slow_done = None

    def event(self, ev, x, y, st):
        """
        Space, Enter, or Click ends slow, if it's enabled.
        """

        if self.slow and renpy.display.behavior.map_event(ev, "dismiss") and self.style.slow_abortable:
            self.call_slow_done(st)
            self.slow = False
            raise renpy.display.core.IgnoreEvent()

        layout = self.get_layout()
        if layout is None:
            return

        for d, xo, yo, _ in layout.displayable_blits:
            rv = d.event(ev, x - xo - layout.xoffset, y - yo - layout.yoffset, st)
            if rv is not None:
                return rv

        if (self.is_focused() and
            renpy.display.behavior.map_event(ev, "button_select")):

            clicked = self.style.hyperlink_functions[1]

            if clicked is not None:
                target = layout.hyperlink_targets.get(renpy.display.focus.argument, None)

                rv = self.style.hyperlink_functions[1](target)
                return rv

    def size(self, width=4096, height=4096, st=0, at=0):
        """
        Attempts to figure out the size of the text. The parameters are
        as for render.

        This does not rotate vertical text.
        """

        if self.dirty or self.displayables is None:
            self.update()

        renders = { }

        for i in self.displayables:
            renders[i] = renpy.display.render.render(i, width, self.style.size, st, at)

        layout = Layout(self, width, height, renders, size_only=True)

        return layout.size

    def render(self, width, height, st, at):

        if self.style.vertical:
            height, width = width, height

        # If slow is None, the style decides if we're in slow text mode.
        if self.slow is None:
            if self.style.slow_cps:
                self.slow = True
            else:
                self.slow = False

        if self.dirty or self.displayables is None:
            self.update()

        # Render all of the child displayables.
        renders = { }

        for i in self.displayables:
            renders[i] = renpy.display.render.render(i, width, self.style.size, st, at)

        # Find the layout, and update to the new size and width if necessary.
        layout = self.get_layout()

        if layout is None or layout.width != width or layout.height != height:
            layout = Layout(self, width, height, renders)

            if len(layout_cache_new) > LAYOUT_CACHE_SIZE:
                layout_cache_new.clear()

            layout_cache_new[id(self)] = layout

        # The laid-out size of this Text.
        w, h = layout.size

        # Get the list of blits we want to undertake.
        if not self.slow:
            blits = [ Blit(0, 0, w - layout.xborder, h - layout.yborder) ]
            redraw = None
        else:
            # TODO: Make this changeable.
            blits = layout.blits_typewriter(st)
            redraw = layout.redraw_typewriter(st)

        # Blit text layers.
        rv = renpy.display.render.Render(w, h)

        for o, color, xo, yo in layout.outlines:
            tex = layout.textures[o, color]

            if o:
                oblits = outline_blits(blits, o)
            else:
                oblits = blits

            for b in oblits:

                b_x = b.x
                b_y = b.y
                b_w = b.w
                b_h = b.h

                # Bound to inside texture rectangle.
                if b_x < 0:
                    b_w += b.x
                    b_x = 0

                if b_y < 0:
                    b_h += b_y
                    b_y = 0

                if b_w > w - b_x:
                    b_w = w - b_x
                if b_h > h - b_y:
                    b_h = h - b_y

                if b_w <= 0 or b_h <= 0:
                    continue

                # Expand the blits and offset them as necessary.
                if b_x + b_w == w:
                    b_w += layout.add_right

                if b_y + b_h == h:
                    b_h += layout.add_bottom

                if b_x == 0:
                    b_w += layout.add_left
                else:
                    b_x += layout.add_left

                if b_y == 0:
                    b_h += layout.add_top
                else:
                    b_y += layout.add_top

                # Blit.
                rv.blit(
                    tex.subsurface((b_x, b_y, b_w, b_h)),
                    (b_x + xo + layout.xoffset - o - layout.add_left,
                     b_y + yo + layout.yoffset - o - layout.add_top)
                     )

        # Blit displayables.
        for d, xo, yo, t in layout.displayable_blits:

            if self.slow and t > st:
                continue

            rv.blit(renders[d], (xo + layout.xoffset, yo + layout.yoffset))

        # Add in the focus areas.
        for hyperlink, hx, hy, hw, hh in layout.hyperlinks:
            rv.add_focus(self, hyperlink, hx + layout.xoffset, hy + layout.yoffset, hw, hh)

        # Figure out if we need to redraw or call slow_done.
        if self.slow:
            if redraw is not None:
                renpy.display.render.redraw(self, redraw)
            else:
                self.call_slow_done(st)

        if self.style.vertical:
            vrv = renpy.display.render.Render(rv.height, rv.width)
            vrv.forward = VERT_FORWARD
            vrv.reverse = VERT_REVERSE
            vrv.blit(rv, (rv.height, 0))
            rv = vrv

        return rv


    def tokenize(self, text):
        """
        Convert the text into a list of tokens.
        """

        tokens = [ ]

        for i in text:

            if isinstance(i, unicode):
                tokens.extend(textsupport.tokenize(i))

            elif isinstance(i, str):
                tokens.extend(textsupport.tokenize(unicode(i)))

            elif isinstance(i, renpy.display.core.Displayable):
                tokens.append((DISPLAYABLE, i))

            else:
                raise Exception("Can't display {0!r} as Text.".format(i))

        return tokens


    def get_displayables(self, tokens):
        """
        Goes through the list of tokens. Returns the set of displayables that
        we know about, and an updated list of tokens with all image tags turned
        into displayables.
        """

        displayables = set()
        new_tokens = [ ]

        for t in tokens:

            kind, text = t

            if kind == DISPLAYABLE:
                displayables.add(text)
                new_tokens.append(t)
                continue

            if kind == TAG:
                tag, _, value = text.partition("=")

                if tag == "image":
                    d = renpy.easy.displayable(value)
                    displayables.add(d)
                    new_tokens.append((DISPLAYABLE, d))

                    continue

            new_tokens.append(t)

        return new_tokens, displayables

language_tailor = textsupport.language_tailor

# Compatibility, in case one of these was pickled.
ParameterizedText = extras.ParameterizedText


########NEW FILE########
__FILENAME__ = translation
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import renpy.display

import hashlib
import re
import collections
import os
import time
import io

################################################################################
# Script
################################################################################

class ScriptTranslator(object):

    def __init__(self):

        # All languages we know about.
        self.languages = set()

        # A map from the translate identifier to the translate object used when the
        # language is None.
        self.default_translates = { }

        # A map from (identifier, language) to the translate object used for that
        # language.
        self.language_translates = { }

        # A list of (identifier, language) tuples that we need to chain together.
        self.chain_worklist = [ ]

        # A map from filename to a list of (label, translate) pairs found in
        # that file.
        self.file_translates = collections.defaultdict(list)

        # A map from language to the StringTranslator for that language.
        self.strings = collections.defaultdict(StringTranslator)

        # A map from language to a list of TranslateBlock objects for
        # that language.
        self.block = collections.defaultdict(list)

        # A map from language to a list of TranslatePython objects for
        # that language.
        self.python = collections.defaultdict(list)

        # A map from filename to a list of additional strings we've found
        # in that file.
        self.additional_strings = collections.defaultdict(list)

    def take_translates(self, nodes):
        """
        Takes the translates out of the flattened list of statements, and stores
        them into the dicts above.
        """

        label = None
        filename = None

        for n in nodes:

            if filename is None:
                filename = renpy.exports.unelide_filename(n.filename)
                filename = os.path.normpath(os.path.abspath(filename))

            if isinstance(n.name, basestring):
                label = n.name

            if isinstance(n, renpy.ast.TranslatePython):
                self.python[n.language].append(n)

            if isinstance(n, renpy.ast.TranslateBlock):
                self.block[n.language].append(n)

            elif isinstance(n, renpy.ast.Menu):

                for i in n.items:
                    s = i[0]

                    if s is None:
                        continue

                    self.additional_strings[filename].append((n.linenumber, s))

            elif isinstance(n, renpy.ast.Translate):


                if n.language is None:
                    self.default_translates[n.identifier] = n
                    self.file_translates[filename].append((label, n))
                else:
                    self.languages.add(n.language)
                    self.language_translates[n.identifier, n.language] = n
                    self.chain_worklist.append((n.identifier, n.language))

    def chain_translates(self):
        """
        Chains nodes in non-default translates together.
        """

        unchained = [ ]

        for identifier, language in self.chain_worklist:

            if identifier not in self.default_translates:
                unchained.append((identifier, language))
                continue

            translate = self.language_translates[identifier, language]
            next_node = self.default_translates[identifier].next

            renpy.ast.chain_block(translate.block, next_node)

        self.chain_worklist = unchained

    def lookup_translate(self, identifier):

        language = renpy.game.preferences.language

        if language is not None:
            tl = self.language_translates.get((identifier, language), None)
        else:
            tl = None

        if tl is None:
            tl = self.default_translates[identifier]

        return tl.block[0]

def encode_say_string(s):
    """
    Encodes a string in the format used by Ren'Py say statements.
    """

    s = s.replace("\\", "\\\\")
    s = s.replace("\n", "\\n")
    s = s.replace("\"", "\\\"")
    s = re.sub(r'(?<= ) ', '\\ ', s)

    return "\"" + s + "\""

class Restructurer(object):

    def __init__(self, children):
        self.label = None
        self.identifiers = set()
        self.callback(children)

    def id_exists(self, identifier):
        if identifier in self.identifiers:
            return True

        if identifier in renpy.game.script.translator.default_translates:
            return True

        return False

    def create_translate(self, block):
        """
        Creates an ast.Translate that wraps `block`. The block may only contain
        translatable statements.
        """

        md5 = hashlib.md5()

        for i in block:
            code = i.get_code()
            md5.update(code.encode("utf-8") + "\r\n")

        if self.label:
            base = self.label + "_" + md5.hexdigest()[:8]
        else:
            base = md5.hexdigest()[:8]

        i = 0
        suffix = ""

        while True:

            identifier = base + suffix

            if not self.id_exists(identifier):
                break

            i += 1
            suffix = "_{0}".format(i)

        self.identifiers.add(identifier)
        loc = (block[0].filename, block[0].linenumber)

        tl = renpy.ast.Translate(loc, identifier, None, block)
        tl.name = block[0].name + ("translate",)

        ed = renpy.ast.EndTranslate(loc)
        ed.name = block[0].name + ("end_translate",)

        return [ tl, ed ]

    def callback(self, children):
        """
        This should be called with a list of statements. It restructures the statements
        in the list so that translatable statements are contained within translation blocks.
        """

        new_children = [ ]
        group = [ ]

        for i in children:

            if isinstance(i, renpy.ast.Label):
                if not i.hide:
                    self.label = i.name

            if not isinstance(i, renpy.ast.Translate):
                i.restructure(self.callback)

            if isinstance(i, renpy.ast.Say):
                group.append(i)
                tl = self.create_translate(group)
                new_children.extend(tl)
                group = [ ]

            elif i.translatable:
                group.append(i)

            else:
                if group:
                    tl = self.create_translate(group)
                    new_children.extend(tl)
                    group = [ ]

                new_children.append(i)

        if group:
            nodes = self.create_translate(group)
            new_children.extend(nodes)
            group = [ ]

        children[:] = new_children

def restructure(children):
    Restructurer(children)


################################################################################
# String Translation
################################################################################

update_translations = ("RENPY_UPDATE_STRINGS" in os.environ)


def quote_unicode(s):
    s = s.replace("\\", "\\\\")
    s = s.replace("\"", "\\\"")
    s = s.replace("\a", "\\a")
    s = s.replace("\b", "\\b")
    s = s.replace("\f", "\\f")
    s = s.replace("\n", "\\n")
    s = s.replace("\r", "\\r")
    s = s.replace("\t", "\\t")
    s = s.replace("\v", "\\v")

    return s


class StringTranslator(object):
    """
    This object stores the translations for a single language. It can also
    buffer unknown translations, and write them to a file at game's end, if
    we want that to happen.
    """

    def __init__(self):

        # A map from translation to translated string.
        self.translations = { }

        # A list of unknown translations.
        self.unknown = [ ]

    def add(self, old, new):
        if old in self.translations:
            raise Exception("A translation for %r already exists." % old)

        self.translations[old] = new

    def translate(self, old):

        new = self.translations.get(old, None)

        if new is not None:
            return new

        if update_translations:
            self.translations[old] = old
            self.unknown.append(old)

        # Remove {#...} tags.
        if new is None:
            notags = re.sub(r"\{\#.*?\}", "", old)
            new = self.translations.get(notags, None)

        if new is not None:
            return new

        return old

    def write_updated_strings(self, language):

        if not self.unknown:
            return

        if language is None:
            fn = os.path.join(renpy.config.gamedir, "strings.rpy")
        else:
            fn = os.path.join(renpy.config.gamedir, renpy.config.tl_directory, language, "strings.rpy")

        f = open_tl_file(fn)

        f.write(u"translate {} strings:\n".format(language))
        f.write(u"\n")

        for i in self.unknown:

            i = quote_unicode(i)

            f.write(u"    old \"{}\"\n".format(i))
            f.write(u"    new \"{}\"\n".format(i))
            f.write(u"\n")

        f.close()

def add_string_translation(language, old, new):
    tl = renpy.game.script.translator
    stl = tl.strings[language]
    tl.languages.add(language)
    stl.add(old, new)

def translate_string(s):
    """
    Translates interface string `s`.
    """

    stl = renpy.game.script.translator.strings[renpy.game.preferences.language]
    return stl.translate(s)

def write_updated_strings():
    stl = renpy.game.script.translator.strings[renpy.game.preferences.language]
    stl.write_updated_strings(renpy.game.preferences.language)


################################################################################
# RPT Support
#
# RPT was the translation format used before 6.15.
################################################################################

def load_rpt(fn):
    """
    Loads the .rpt file `fn`.
    """

    def unquote(s):
        s = s.replace("\\n", "\n")
        s = s.replace("\\\\", "\\")
        return s

    language = os.path.basename(fn).replace(".rpt", "")

    f = renpy.loader.load(fn)

    old = None

    for l in f:
        l = l.decode("utf-8")
        l = l.rstrip()

        if not l:
            continue

        if l[0] == '#':
            continue

        s = unquote(l[2:])

        if l[0] == '<':
            if old:
                raise Exception("{0} string {1!r} does not have a translation.".format(language, old))

            old = s

        if l[0] == ">":
            if old is None:
                raise Exception("{0} translation {1!r} doesn't belong to a string.".format(language, s))

            add_string_translation(language, old, s)
            old = None

    f.close()

    if old is not None:
        raise Exception("{0} string {1!r} does not have a translation.".format(language, old))

def load_all_rpts():
    """
    Loads all .rpt files.
    """

    for fn in renpy.exports.list_files():
        if fn.endswith(".rpt"):
            load_rpt(fn)

################################################################################
# Changing language
################################################################################

style_backup = None

def init_translation():
    """
    Called before the game starts.
    """

    global style_backup
    style_backup = renpy.style.backup() # @UndefinedVariable

    load_all_rpts()

def change_language(language):
    """
    :doc: translation_functions

    Changes the current language to `language`, which can be a string or
    None to use the default language.
    """

    renpy.game.preferences.language = language

    tl = renpy.game.script.translator

    renpy.style.restore(style_backup) # @UndefinedVariable
    renpy.style.rebuild() # @UndefinedVariable

    def run_blocks():
        for i in tl.block[language]:
            renpy.game.context().run(i.block[0])

    renpy.game.invoke_in_new_context(run_blocks)

    for i in tl.python[language]:
        renpy.python.py_exec_bytecode(i.code.bytecode)

    for i in renpy.config.change_language_callbacks:
        i()

    # Reset various parts of the system. Most notably, this clears the image
    # cache, letting us load translated images.
    renpy.exports.free_memory()

    # Rebuild the styles.
    renpy.style.rebuild() # @UndefinedVariable

    # Re-prepare the screens.
    renpy.display.screen.prepare_screens()

    # Restart the interaction.
    renpy.exports.restart_interaction()

def check_language():
    """
    Checks to see if the language has changed. If it has, jump to the start
    of the current translation block.
    """

    ctx = renpy.game.contexts[-1]
    preferences = renpy.game.preferences

    # Deal with a changed language.
    if ctx.translate_language != preferences.language:
        ctx.translate_language = preferences.language

        tid = ctx.translate_identifier

        if tid is not None:
            node = renpy.game.script.translator.lookup_translate(tid)

            if node is not None:
                raise renpy.game.JumpException(node.name)

def known_languages():
    """
    :doc: translation_functions

    Returns the set of known languages. This does not include the default
    language, None.
    """

    return renpy.game.script.translator.languages


################################################################################
# Translation Generation
################################################################################

STRING_RE = r"""(?x)
\n
|\#[^\n]*
|\b__?\s*\(\s*[uU]?(
\"\"\"(?:\\.|\"{1,2}|[^\\"])*?\"\"\"
|'''(?:\\.|\'{1,2}|[^\\'])*?'''
|"(?:\\.|[^\\"])*"
|'(?:\\.|[^\\'])*'
)\s*\)
"""

def scan_strings(filename):
    """
    Scans `filename`, a file containing Ren'Py script, for translatable
    strings.

    Generates a list of (line, string) tuples.
    """

    for line, s in renpy.game.script.translator.additional_strings[filename]:
        yield line, s

    line = 1

    with open(filename, "r") as f:
        data = f.read().decode("utf-8")

    for m in re.finditer(STRING_RE, data):

        s = m.group(1)
        if s is not None:
            s = s.strip()
            s = "u" + s
            s = eval(s)
            yield line, s

        line += m.group(0).count("\n")


def open_tl_file(fn):

    if not os.path.exists(fn):
        dn = os.path.dirname(fn)

        try:
            os.makedirs(dn)
        except:
            pass

        f = io.open(fn, "a", encoding="utf-8")
        f.write(u"\ufeff")

    else:
        f = io.open(fn, "a", encoding="utf-8")

    f.write(u"# TODO: Translation updated at {}\n".format(time.strftime("%Y-%m-%d %H:%M")))
    f.write(u"\n")

    return f


class TranslateFile(object):

    def __init__(self, filename, language, filter): # @ReservedAssignment
        self.filename = filename
        self.filter = filter

        commondir = os.path.normpath(renpy.config.commondir)
        gamedir = os.path.normpath(renpy.config.gamedir)

        if filename.startswith(commondir):
            relfn = os.path.relpath(filename, commondir)

            if relfn == "_developer.rpym":
                return

            if relfn.startswith("compat"):
                return

            self.tl_filename = os.path.join(renpy.config.gamedir, renpy.config.tl_directory, language, "common.rpy")
        elif filename.startswith(gamedir):
            fn = os.path.relpath(filename, gamedir)
            self.tl_filename = os.path.join(renpy.config.gamedir, renpy.config.tl_directory, language, fn)

        if self.tl_filename.endswith(".rpym"):
            self.tl_filename = self.tl_filename[:-1]

        if language == "None":
            language = None

        self.language = language
        self.f = None

        if language is not None:
            self.write_translates()

        self.write_strings()

        self.close()

    def open(self):
        """
        Opens a translation file.
        """

        if self.f is not None:
            return

        self.f = open_tl_file(self.tl_filename)

    def close(self):
        """
        Closes the translation file, if it's open.
        """

        if self.f is not None:
            self.f.close()

    def write_translates(self):
        """
        Writes the translates to the file.
        """

        translator = renpy.game.script.translator

        for label, t in translator.file_translates[self.filename]:

            if (t.identifier, self.language) in translator.language_translates:
                continue

            self.open()

            if label is None:
                label = ""

            self.f.write(u"# {}:{}\n".format(t.filename, t.linenumber))
            self.f.write(u"translate {} {}:\n".format(self.language, t.identifier))
            self.f.write(u"\n")

            for n in t.block:
                self.f.write(u"    # " + n.get_code() + "\n")

            for n in t.block:
                self.f.write(u"    " + n.get_code(self.filter) + "\n")

            self.f.write(u"\n")

    def write_strings(self):
        """
        Writes strings to the file.
        """

        started = False
        filename = renpy.parser.elide_filename(self.filename)

        for line, s in scan_strings(self.filename):

            stl = renpy.game.script.translator.strings[self.language]

            if s in stl.translations:
                continue

            stl.translations[s] = s

            if not started:
                started = True

                self.open()
                self.f.write(u"translate {} strings:\n".format(self.language))
                self.f.write(u"\n")

            fs = self.filter(s)

            self.f.write(u"    # {}:{}\n".format(filename, line))
            self.f.write(u"    old \"{}\"\n".format(quote_unicode(s)))
            self.f.write(u"    new \"{}\"\n".format(quote_unicode(fs)))
            self.f.write(u"\n")

def null_filter(s):
    return s

def empty_filter(s):
    return ""

ROT13 = { }

for i, j in zip("ABCDEFGHIJKLM", "NMOPQRSTUVWYZ"):
    ROT13[i] = j
    ROT13[j] = i

    i = i.lower()
    j = j.lower()

    ROT13[i] = j
    ROT13[j] = i

def rot13_filter(s):

    def tag_pass(s):

        brace = False
        first = False
        rv = ""

        for i in s:

            if i == '{':

                if first:
                    brace = False
                else:
                    brace = True
                    first = True

                rv += "{"

            elif i == "}":
                first = False

                if brace:
                    brace = False

                rv += "}"

            else:
                first = False

                if brace:
                    rv += i
                else:
                    rv += ROT13.get(i, i)

        return rv

    def square_pass(s):
        squares = 0
        first = False

        rv = ""
        buf = ""

        for i in s:

            if i == "[":
                if first:
                    squares = 0
                else:
                    rv += tag_pass(buf)
                    buf = ""

                    if squares == 0:
                        first = True

                    squares += 1

                rv += "["

            elif i == "]":

                first = False

                squares -= 1
                if squares < 0:
                    squares += 1

                rv += "]"

            else:
                if squares:
                    rv += i
                else:
                    buf += i

        if buf:
            rv += tag_pass(buf)

        return rv


    return square_pass(s)

def translate_command():
    """
    The translate command. When called from the command line, this generates
    the translations.
    """

    ap = renpy.arguments.ArgumentParser(description="Generates or updates translations.")
    ap.add_argument("language", help="The language to generate translations for.")
    ap.add_argument("--rot13", help="Apply rot13 while generating translations.", dest="rot13", action="store_true")
    ap.add_argument("--empty", help="Produce empty strings while generating translations.", dest="empty", action="store_true")
    args = ap.parse_args()

    if args.rot13:
        filter = rot13_filter #@ReservedAssignment
    elif args.empty:
        filter = empty_filter # @ReservedAssignment
    else:
        filter = null_filter #@ReservedAssignment

    for dirname, filename in renpy.loader.listdirfiles():
        if dirname is None:
            continue

        filename = os.path.join(dirname, filename)

        if not (filename.endswith(".rpy") or filename.endswith(".rpym")):
            continue

        filename = os.path.normpath(filename)
        TranslateFile(filename, args.language, filter)

    return False

renpy.arguments.register_command("translate", translate_command)



def notags_filter(s):

    def tag_pass(s):

        brace = False
        first = False
        rv = ""

        for i in s:

            if i == '{':

                if first:
                    brace = False
                else:
                    brace = True
                    first = True

            elif i == "}":
                first = False

                if brace:
                    brace = False

            else:
                first = False

                if brace:
                    pass
                else:
                    rv += i

        return rv

    def square_pass(s):
        squares = 0
        first = False

        rv = ""
        buf = ""

        for i in s:

            if i == "[":
                if first:
                    squares = 0
                else:
                    rv += tag_pass(buf)
                    buf = ""

                    if squares == 0:
                        first = True

                    squares += 1

                rv += "["

            elif i == "]":

                first = False

                squares -= 1
                if squares < 0:
                    squares += 1

                rv += "]"

            else:
                if squares:
                    rv += i
                else:
                    buf += i

        if buf:
            rv += tag_pass(buf)

        return rv


    return square_pass(s)



class DialogueFile(object):

    def __init__(self, filename, output, tdf=True): # @ReservedAssignment
        """
        `filename`
            The file we're extracting dialogue from.

        `tdf`
            If true, dialogue is extracted in tab-delimited format. If false,
            dialogue is extracted by itself.
        """

        self.filename = filename

        commondir = os.path.normpath(renpy.config.commondir)

        if filename.startswith(commondir):
            return

        self.tdf = tdf

        self.f = open(output, "a")

        self.write_translates()

        self.f.close()

    def write_translates(self):
        """
        Writes the translates to the file.
        """

        translator = renpy.game.script.translator

        for label, t in translator.file_translates[self.filename]:

            if label is None:
                label = ""

            for n in t.block:

                if isinstance(n, renpy.ast.Say):

                    if not n.who:
                        who = ""
                    else:
                        who = n.who

                    what = notags_filter(n.what)

                    if self.tdf:

                        line = [
                            t.identifier,
                            who,
                            what,
                            n.filename,
                            str(n.linenumber),
                            ]

                    else:
                        line = [
                            what
                            ]

                    self.f.write("\t".join(line).encode("utf-8") + "\n")


def dialogue_command():
    """
    The dialogue command. This updates dialogue.txt, a file giving all the dialogue
    in the game.
    """

    ap = renpy.arguments.ArgumentParser(description="Generates or updates translations.")
    ap.add_argument("--text", help="Apply rot13 while generating translations.", dest="text", action="store_true")
    args = ap.parse_args()

    tdf = not args.text
    if tdf:
        output = os.path.join(renpy.config.basedir, "dialogue.tab")
    else:
        output = os.path.join(renpy.config.basedir, "dialogue.txt")

    with open(output, "w") as f:
        if tdf:
            line = [
                "Identifier",
                "Character",
                "Dialogue",
                "Filename",
                "Line Number",
                ]

            f.write("\t".join(line).encode("utf-8") + "\n")

    for dirname, filename in renpy.loader.listdirfiles():
        if dirname is None:
            continue

        filename = os.path.join(dirname, filename)

        if not (filename.endswith(".rpy") or filename.endswith(".rpym")):
            continue

        filename = os.path.normpath(filename)
        DialogueFile(filename, output, tdf=tdf)

    return False

renpy.arguments.register_command("dialogue", dialogue_command)

########NEW FILE########
__FILENAME__ = ui
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This file contains functions that can be used to display a UI on the
# screen.  The UI isn't implemented here (rather, in
# renpy.display). Instead, these functions provide a simple interface
# that allows a user to procedurally create a UI.

# All functions in the is file should be documented in the wiki.

import sys
import renpy.display
import renpy.text

##############################################################################
# Special classes that can be subclassed from the outside.

class Action(renpy.object.Object):
    """
    This can be passed to the clicked method of a button or hotspot. It is
    called when the action is selected. The other methods determine if the
    action should be displayed insensitive or disabled.
    """

    def get_sensitive(self):
        return True

    def get_selected(self):
        return False

    def periodic(self, st):
        return

    def predict(self):
        return

    def __call__(self):
        raise Exception("Not implemented")

class BarValue(renpy.object.Object):
    """
    This can be passed to the value method of bar and hotbar.
    """

    def replaces(self, other):
        return

    def periodic(self, st):
        return

    def get_adjustment(self):
        raise Exception("Not implemented")

    def get_style(self):
        return "bar", "vbar"


##############################################################################
# Things we can add to. These have two methods: add is called with the
# widget we're adding. close is called when the thing is ready to be
# closed.

class Addable(object):
    # A style_group associates with this addable.
    style_group = None

    def get_layer(self):
        return Exception("Operation can only be performed on a layer.")

class Layer(Addable):
    def __init__(self, name):
        self.name = name

    def add(self, d, key):
        renpy.game.context(-1).scene_lists.add(self.name, d, key=key)

    def close(self, d):
        stack.pop()

        if d and d != self.name:
            raise Exception("ui.close closed layer %s, not the expected %r." % (self.name, d))

    def get_layer(self):
        return self.name

    def __repr__(self):
        return "<Layer: %r>" % self.name


class Many(Addable):
    """
    A widget that takes many children.
    """

    def __init__(self, displayable, imagemap, style_group):
        self.displayable = displayable
        self.imagemap = imagemap
        self.style_group = style_group

    def add(self, d, key):
        self.displayable.add(d)

    def close(self, d):
        stack.pop()

        if self.imagemap:
            imagemap = imagemap_stack.pop()
            imagemap.cache.finish()


        if d and d != self.displayable:
            raise Exception("ui.close closed %r, not the expected %r." % (self.displayable, d))

    def __repr__(self):
        return "<Many: %r>" % self.displayable

class One(Addable):
    """
    A widget that expects exactly one child.
    """

    def __init__(self, displayable, style_group):
        self.displayable = displayable
        self.style_group = style_group

    def add(self, d, key):
        self.displayable.add(d)
        stack.pop()

    def close(self, d):
        raise Exception("Widget %r expects a child." % self.displayable)

    def __repr__(self):
        return "<One: %r>" % self.displayable

class Detached(Addable):
    """
    Used to indicate a widget is detached from the stack.
    """

    def add(self, d, key):
        stack.pop()

    def close(self, d):
        raise Exception("Detached expects to be given a child.")

class ChildOrFixed(Addable):
    """
    If one widget is added, then it is added directly to our
    parent. Otherwise, a fixed is added to our parent, and all
    the widgets are added to that.
    """

    def __init__(self, style_group):
        self.queue = [ ]
        self.style_group = style_group

    def add(self, d, key):
        self.queue.append(d)

    def close(self, d):
        stack.pop()

        if len(self.queue) == 1:
            add(self.queue[0])
        else:
            fixed()

            for i in self.queue:
                add(i)

            close()

        if d is not None:
            raise Exception("Did not expect to close %r." % d)

# A stack of things we can add to.
stack = [ ]

# A stack of open ui.ats.
at_stack = [ ]

# The tag for the displayble being added to the layer.
add_tag = None

# A stack of Imagemap objects.
imagemap_stack = [ ]


# Called at the end of the init phase, and from the screen
# prediction code.
def reset():
    global stack
    global at_stack
    global imagemap_stack

    stack = [ Layer('transient') ]
    at_stack = [ ]
    imagemap_stack = [ ]

renpy.game.post_init.append(reset)

def interact(type='misc', roll_forward=None, **kwargs): #@ReservedAssignment
    # Docs in wiki.

    if stack is None:
        raise Exception("Interaction not allowed during init phase.")

    if renpy.config.skipping == "fast":
        renpy.config.skipping = None

    if len(stack) != 1:
        raise Exception("ui.interact called with non-empty widget/layer stack. Did you forget a ui.close() somewhere?")

    if at_stack:
        raise Exception("ui.interact called with non-empty at stack.")

    renpy.game.context().info._current_interact_type = type
    rv = renpy.game.interface.interact(roll_forward=roll_forward, **kwargs)
    renpy.game.context().mark_seen()
    renpy.game.context().info._last_interact_type = type

    if renpy.exports.in_fixed_rollback() and roll_forward is not None:
        return roll_forward
    else:
        return rv

def tag(name):
    global add_tag
    add_tag = name

def child_or_fixed():
    """
    Causes the current widget to be given child-fixed semantics. This
    means that we will queue up children added to it. If there is one
    child, that child will be added to the widget directly. Otherwise,
    a fixed will be created, and the children will be added to that.
    """

    stack.append(ChildOrFixed(stack[-1].style_group))

def remove(d):
    layer = stack[-1].get_layer()
    renpy.game.context(-1).scene_lists.remove(layer, d)

def remove_above(d):
    layer = stack[-1].get_layer()
    renpy.game.context(-1).scene_lists.remove_above(layer, d)

def at(transform):
    """
    :doc: ui

    Specifieds a transform that is applied to the next displayable to
    be created. This is largely obsolete, as all UI functions now take
    an `at` argument.
    """

    at_stack.append(transform)

def clear():
    layer = stack[-1].get_layer()
    renpy.game.context(-1).scene_lists.clear(layer)

def detached():
    """
    :doc: ui

    Do not add the next displayable to any later or container. Use this if
    you want to assign the result of a ui function to a variable.
    """

    stack.append(Detached())

def layer(name):
    """
    :doc: ui

    Adds displayables to the layer named `name`. The later must be
    closed with :func:`ui.close`.
    """

    stack.append(Layer(name))

def close(d=None):
    """
    :doc: ui
    :args: ()

    Closes a displayable created with by a UI function. When a
    displayable is closed, we add new displayables to its parent,
    or to the layer if no displayable is open.
    """

    stack[-1].close(d)

    if not stack:
        raise Exception("ui.close() called when no layer or widget is open.")

def reopen(w, clear):

    stack.append(Many(w))

    if clear:
        w.children[:] = [ ]

def context_enter(w):
    if isinstance(renpy.ui.stack[-1], renpy.ui.Many) and renpy.ui.stack[-1].displayable is w:
        return

    raise Exception("%r cannot be used as a context manager.", type(w).__name__)

def context_exit(w):
    close(w)

NoStyleGroupGiven = renpy.object.Sentinel("NoStyleGroupGiven")

def style_group_style(s, style_group):
    """
    Given a style name s, combine it with the style_group to create a new
    style. If the style doesn't exist, create a new lightweight style.
    """

    if style_group is NoStyleGroupGiven:
        style_group = stack[-1].style_group

    if style_group is None:
        new_style = s
    else:
        new_style = style_group + "_" + s

    return renpy.style.get_style(new_style) # @UndefinedVariable

# The screen we're using as we add widgets. None if there isn't a
# screen.
screen = None

class Wrapper(renpy.object.Object):

    def __reduce__(self):
        return self.name

    def __init__(self, function, one=False, many=False, imagemap=False, replaces=False, style=None, **kwargs):

        # The name assigned to this wrapper. This is used to serialize us correctly.
        self.name = None

        # The function to call.
        self.function = function

        # Should we add one or many things to this wrapper?
        self.one = one
        self.many = many or imagemap
        self.imagemap = imagemap

        # Should the function be given the replaces parameter,
        # specifiying the displayable it replaced?
        self.replaces = replaces

        # Default keyword arguments to the function.
        self.kwargs = kwargs

        # Default style (suffix).
        self.style = style

    def __call__(self, *args, **kwargs):

        global add_tag

        if not stack:
            raise Exception("Can't add displayable during init phase.")

        # Pull out the special kwargs, id, at, and style_group.

        id = kwargs.pop("id", None) #@ReservedAssignment

        at_list = kwargs.pop("at", [ ])
        if not isinstance(at_list, (list, tuple)):
            at_list = [ at_list ]

        style_group = kwargs.pop("style_group", NoStyleGroupGiven)

        # Figure out our style_group.
        if style_group is NoStyleGroupGiven:
            style_group = stack[-1].style_group

        # Figure out the keyword arguments, based on the parameters.
        if self.kwargs:
            keyword = self.kwargs.copy()
            keyword.update(kwargs)
        else:
            keyword = kwargs

        # Should we transfer data from an old version of this screen?
        old_transfers = screen and screen.old_transfers

        # Should we add?
        do_add = True

        if screen:
            if id in screen.widget_properties:
                keyword.update(screen.widget_properties[id])

            if id in screen.hidden_widgets:
                do_add = False

        grab = False

        if old_transfers:
            if self.replaces:
                w = screen.old_widgets.get(id, None)

                if w is not None:
                    keyword["replaces"] = w

                    if (renpy.display.focus.grab is w) and (not screen.hiding):
                        grab = True


        if self.style and "style" not in keyword:
            keyword["style"] = style_group_style(self.style, style_group)

        try:
            w = self.function(*args, **keyword)
        except TypeError, e:
            etype, e, tb = sys.exc_info(); etype

            if tb.tb_next is None:
                e.args = (e.args[0].replace("__call__", "ui." + self.name), )

            del tb # Important! Prevents memory leaks via our frame.
            raise

        # Wrap the displayable based on the at_list and at_stack.
        atw = w

        if grab:
            renpy.display.focus.new_grab = w

        while at_stack:
            at_list.append(at_stack.pop())

        for atf in at_list:
            if isinstance(atf, renpy.display.motion.Transform):
                atw = atf(child=atw)
            else:
                atw = atf(atw)

        # Add to the displayable at the bottom of the stack.
        if do_add:
            stack[-1].add(atw, add_tag)

        # Update the stack, as necessary.
        if self.one:
            stack.append(One(w, style_group))
        elif self.many:
            stack.append(Many(w, self.imagemap, style_group))

        main = w._main or w

        # If we have an id, record the displayable, the transform,
        # and maybe take the state from a previous transform.
        if screen and id is not None:
            screen.widgets[id] = main

            if isinstance(atw, renpy.display.motion.Transform):
                screen.transforms[id] = atw

                if old_transfers:

                    oldt = screen.old_transforms.get(id, None)

                    if oldt is not None:
                        atw.take_state(oldt)
                        atw.take_execution_state(oldt)

        # Clear out the add_tag.
        add_tag = None

        return main

##############################################################################
# Button support functions
def is_selected(clicked):

    if isinstance(clicked, (list, tuple)):
        return any(is_selected(i) for i in clicked)

    elif isinstance(clicked, Action):
        return clicked.get_selected()

    else:
        return False

def is_sensitive(clicked):

    if isinstance(clicked, (list, tuple)):
        return all(is_sensitive(i) for i in clicked)

    elif isinstance(clicked, Action):
        return clicked.get_sensitive()

    else:
        return True



##############################################################################
# Widget functions.

def _add(d, **kwargs):
    d = renpy.easy.displayable(d)
    d = d.parameterize('displayable', [ ])

    rv = d

    if kwargs:
        rv = renpy.display.motion.Transform(child=d, **kwargs)

    return rv

add = Wrapper(_add)

def _image(im, **properties):
    d = renpy.display.im.image(im, loose=True, **properties)
    d = d.parameterize('displayable', [ ])
    return d

image = Wrapper(_image)

null = Wrapper(renpy.display.layout.Null)
text = Wrapper(renpy.text.text.Text, style="text", replaces=True)
hbox = Wrapper(renpy.display.layout.MultiBox, layout="horizontal", style="hbox", many=True)
vbox = Wrapper(renpy.display.layout.MultiBox, layout="vertical", style="vbox", many=True)
fixed = Wrapper(renpy.display.layout.MultiBox, layout="fixed", style="fixed", many=True)
grid = Wrapper(renpy.display.layout.Grid, style="grid", many=True)
side = Wrapper(renpy.display.layout.Side, style="side", many=True)

def _sizer(maxwidth=None, maxheight=None, **properties):
    return renpy.display.layout.Container(xmaximum=maxwidth, ymaximum=maxheight, **properties)

sizer = Wrapper(_sizer, one=True)
window = Wrapper(renpy.display.layout.Window, style="window", one=True, child=None)
frame = Wrapper(renpy.display.layout.Window, style="frame", one=True, child=None)

keymap = Wrapper(renpy.display.behavior.Keymap)
saybehavior = Wrapper(renpy.display.behavior.SayBehavior)
pausebehavior = Wrapper(renpy.display.behavior.PauseBehavior)
soundstopbehavior = Wrapper(renpy.display.behavior.SoundStopBehavior)

def _key(key, action=None):

    if action is None:
        raise Exception("Action is required in ui.key.")

    return renpy.display.behavior.Keymap(**{ key : action})

key = Wrapper(_key)

class ChoiceActionBase(Action):
    """
    Base class for choice actions. The choice is identified by a label
    and value. The class will automatically determine the rollback state
    and supply correct "sensitive" and "selected" information to the
    widget.
    If a location is supplied, it will check whether the choice was
    previously visited and mark it so if it is chosen.
    """
    def __init__(self, label, value, location=None, block_all=None):
        self.label = label
        self.value = value
        self.location = location

        if block_all is None:
            self.block_all = renpy.config.fix_rollback_without_choice
        else:
            self.block_all = block_all

        self.chosen = None

        if self.location:
            self.chosen = renpy.game.persistent._chosen  # @UndefinedVariable

            if self.chosen is None:
                self.chosen = renpy.game.persistent._chosen = { }


    def get_sensitive(self):
        return not renpy.exports.in_fixed_rollback() or (not self.block_all and self.get_selected())

    def get_selected(self):
        roll_forward = renpy.exports.roll_forward_info()
        return renpy.exports.in_fixed_rollback() and roll_forward == self.value

    def get_chosen(self):
        if self.chosen is None:
            return False

        return (self.location, self.label) in self.chosen

class ChoiceReturn(ChoiceActionBase):
    """
    :doc: blockrollback

    A menu choice action that returns `value`, while managing the button
    state in a manner consistent with fixed rollback. (See block_all for
    a description of the behavior.)


    `label`
        The label text of the button. For imagebuttons and hotspots this
        can be anything. This label is used as a unique identifier of
        the options within the current screen. Together with `location`
        it is used to store whether this option has been chosen.

    `value`
        The value this is returned when the choice is chosen.

    `location`
        A unique location identifier for the current choices screen.

    `block_all`
        If false, the button is given the selected role if it was
        the chosen choice, and insensitive if it was not selected.

        If true, the button is always insensitive during fixed
        rollback.

        If None, the value is taken from the :var:`config.fix_rollback_without_choice`
        variable.

        When true is given to all items in a screen, it will
        become unclickable (rolling forward will still work). This can
        be changed by calling :func:`ui.saybehavior` before the call
        to :func:`ui.interact`.
    """



    def __call__(self):
        if self.chosen is not None:
            self.chosen[(self.location, self.label)] = True

        return self.value

class ChoiceJump(ChoiceActionBase):
    """
    :doc: blockrollback

    A menu choice action that returns `value`, while managing the button
    state in a manner consistent with fixed rollback. (See block_all for
    a description of the behavior.)


    `label`
        The label text of the button. For imagebuttons and hotspots this
        can be anything. This label is used as a unique identifier of
        the options within the current screen. Together with `location`
        it is used to store whether this option has been chosen.

    `value`
        The location to jump to.

    `location`
        A unique location identifier for the current choices screen.

    `block_all`
        If false, the button is given the selected role if it was
        the chosen choice, and insensitive if it was not selected.

        If true, the button is always insensitive during fixed
        rollback.

        If None, the value is taken from the :var:`config.fix_rollback_without_choice`
        variable.

        When true is given to all items in a screen, it will
        become unclickable (rolling forward will still work). This can
        be changed by calling :func:`ui.saybehavior` before the call
        to :func:`ui.interact`.
    """


    def get_selected(self):
        roll_forward = renpy.exports.roll_forward_info()

        # renpy.exports.call_screen create a checkpoint with the jump exception
        if isinstance(roll_forward, renpy.game.JumpException):
            roll_forward = roll_forward.args[0]

        return renpy.exports.in_fixed_rollback() and roll_forward == self.value

    def __call__(self):
        if self.chosen is not None:
            self.chosen[(self.location, self.label)] = True

        renpy.exports.jump(self.value)


def menu(menuitems,
         style = 'menu',
         caption_style='menu_caption',
         choice_style='menu_choice',
         choice_chosen_style='menu_choice_chosen',
         choice_button_style='menu_choice_button',
         choice_chosen_button_style='menu_choice_chosen_button',
         location=None,
         focus=None,
         default=False,
         **properties):

    # menu is now a conglomeration of other widgets. And bully for it.

    renpy.ui.vbox(style=style, **properties)

    for label, val in menuitems:
        if val is None:
            renpy.ui.text(label, style=caption_style)
        else:

            text = choice_style
            button = choice_button_style

            clicked = ChoiceReturn(label, val, location)

            if clicked.get_chosen():
                    text = choice_chosen_style
                    button = choice_chosen_button_style

            if isinstance(button, basestring):
                button = getattr(renpy.game.style, button)
            if isinstance(text, basestring):
                text = getattr(renpy.game.style, text)

            button = button[label]
            text = text[label]

            renpy.ui.textbutton(label,
                                style=button,
                                text_style=text,
                                clicked=clicked,
                                focus=focus,
                                default=default)

    close()

input = Wrapper(renpy.display.behavior.Input, exclude='{}', style="input", replaces=True) #@ReservedAssignment

def imagemap_compat(ground,
                    selected,
                    hotspots,
                    unselected=None,
                    style='imagemap',
                    button_style='hotspot',
                    **properties):

    if isinstance(button_style, basestring):
        button_style = getattr(renpy.game.style, button_style)

    fixed(style=style, **properties)

    if unselected is None:
        unselected = ground

    add(ground)

    for x0, y0, x1, y1, result in hotspots:

        if result is None:
            continue

        action = ChoiceReturn(result, result)

        selected_img = renpy.display.layout.LiveCrop((x0, y0, x1 - x0, y1 - y0), selected)

        imagebutton(renpy.display.layout.LiveCrop((x0, y0, x1 - x0, y1 - y0), unselected),
                    selected_img,
                    selected_idle_image = selected_img,
                    selected_insensitive_image = selected_img,
                    clicked=action,
                    style=button_style[result],
                    xpos=x0,
                    xanchor=0,
                    ypos=y0,
                    yanchor=0,
                    focus_mask=True,
                    )

    close()

button = Wrapper(renpy.display.behavior.Button, style='button', one=True)

def _imagebutton(idle_image = None,
                 hover_image = None,
                 insensitive_image = None,
                 activate_image = None,
                 selected_idle_image = None,
                 selected_hover_image = None,
                 selected_insensitive_image = None,
                 selected_activate_image = None,
                 idle=None,
                 hover=None,
                 insensitive=None,
                 selected_idle=None,
                 selected_hover=None,
                 selected_insensitive=None,
                 image_style=None,
                 auto=None,
                 **properties):

    def choice(a, b, name, required=False):
        if a:
            return a

        if b:
            return b

        if auto is not None:
            return renpy.config.imagemap_auto_function(auto, name)

        if required:
            raise Exception("Could not find a %s image for imagemap." % name)

        return None

    idle = choice(idle, idle_image, "idle", required=True)
    hover = choice(hover, hover_image, "hover")
    insensitive = choice(insensitive, insensitive_image, "insensitive")
    selected_idle = choice(selected_idle, selected_idle_image, "selected_idle")
    selected_hover = choice(selected_hover, selected_hover_image, "selected_hover")
    selected_insensitive = choice(selected_insensitive, selected_insensitive_image, "selected_insensitive")

    return renpy.display.behavior.ImageButton(
            idle,
            hover,
            insensitive_image = insensitive,
            activate_image = activate_image,
            selected_idle_image = selected_idle,
            selected_hover_image = selected_hover,
            selected_insensitive_image = selected_insensitive,
            selected_activate_image = selected_activate_image,
            **properties)

imagebutton = Wrapper(_imagebutton, style="image_button")

def _textbutton(label, clicked=None, style=None, text_style=None, substitute=True, scope=None, **kwargs):

    button_kwargs = { }
    text_kwargs = { }

    for k, v in kwargs.iteritems():
        if k.startswith("text_"):
            text_kwargs[k[5:]] = v
        else:
            button_kwargs[k] = v

    # Deal with potentially bad keyword arguments. (We'd get these if the user
    # writes text_align instead of text_text_align.)
    if "align" in text_kwargs:
        if isinstance(text_kwargs["align"], float):
            text_kwargs.pop("align")
    text_kwargs.pop("y_fudge", None)

    if style is None:
        style = style_group_style('button', NoStyleGroupGiven)

    if text_style is None:
        text_style = renpy.style.get_text_style(style, style_group_style('button_text', NoStyleGroupGiven)) # @UndefinedVariable

    rv = renpy.display.behavior.Button(style=style, clicked=clicked, **button_kwargs)
    text = renpy.text.text.Text(label, style=text_style, substitute=substitute, scope=scope, **text_kwargs)
    rv.add(text)
    rv._main = text
    return rv

textbutton = Wrapper(_textbutton)

def _label(label, style=None, text_style=None, substitute=True, scope=None, **kwargs):

    label_kwargs = { }
    text_kwargs = { }

    for k, v in kwargs.iteritems():
        if k.startswith("text_"):
            text_kwargs[k[5:]] = v
        else:
            label_kwargs[k] = v

    if style is None:
        style = style_group_style('label', NoStyleGroupGiven)

    if text_style is None:
        text_style = renpy.style.get_text_style(style, style_group_style('label_text', NoStyleGroupGiven)) # @UndefinedVariable

    rv = renpy.display.layout.Window(None, style=style, **label_kwargs)
    text = renpy.text.text.Text(label, style=text_style, substitute=substitute, scope=scope, **text_kwargs)
    rv.add(text)
    rv._main = text
    return rv

label = Wrapper(_label)

adjustment = renpy.display.behavior.Adjustment

def _bar(*args, **properties):

    if len(args) == 4:
        width, height, range, value = args #@ReservedAssignment
    if len(args) == 2:
        range, value = args #@ReservedAssignment
        width = None
        height = None
    else:
        range = 1 #@ReservedAssignment
        value = 0
        width = None
        height = None

    if "width" in properties:
        width = properties.pop("width")

    if "height" in properties:
        height  = properties.pop("height")

    if "range" in properties:
        range = properties.pop("range") #@ReservedAssignment

    if "value" in properties:
        value = properties.pop("value")

    if "style" not in properties:
        if isinstance(value, BarValue):
            if properties["vertical"]:
                style = value.get_style()[1]
            else:
                style = value.get_style()[0]

            if isinstance(style, basestring):
                style = style_group_style(style, NoStyleGroupGiven)

            properties["style"] = style

    return renpy.display.behavior.Bar(range, value, width, height, **properties)

bar = Wrapper(_bar, vertical=False, replaces=True)
vbar = Wrapper(_bar, vertical=True, replaces=True)
slider = Wrapper(_bar, style='slider', replaces=True)
vslider = Wrapper(_bar, style='vslider', replaces=True)
scrollbar = Wrapper(_bar, style='scrollbar', replaces=True)
vscrollbar = Wrapper(_bar, style='vscrollbar', replaces=True)

def _autobar_interpolate(range, start, end, time, st, at, **properties): #@ReservedAssignment

    if st > time:
        t = 1.0
        redraw = None
    else:
        t = st / time
        redraw = 0

    value = start + t * (end - start)
    return renpy.display.behavior.Bar(range, value, None, None, **properties), redraw

autobar_interpolate = renpy.curry.curry(_autobar_interpolate)

def _autobar(range, start, end, time, **properties): #@ReservedAssignment
    return renpy.display.layout.DynamicDisplayable(autobar_interpolate(range, start, end, time, **properties))

autobar = Wrapper(_autobar)
transform = Wrapper(renpy.display.motion.Transform, one=True, style='transform')
_viewport = Wrapper(renpy.display.layout.Viewport, one=True, replaces=True, style='viewport')

def viewport(scrollbars=None, **properties):

    if scrollbars is None:
        return _viewport(**properties)

    viewport_properties = { }
    side_properties = { }

    for k, v in properties.iteritems():
        if k.startswith("side_"):
            side_properties[k[5:]] = v
        else:
            viewport_properties[k] = v

    if scrollbars == "vertical":
        side("c r", **side_properties)

        rv = _viewport(**viewport_properties)
        addable = stack.pop()

        vscrollbar(adjustment=rv.yadjustment)
        close()

        stack.append(addable)

        return rv

    elif scrollbars == "horizontal":
        side("c b", **side_properties)

        rv = _viewport(**viewport_properties)
        addable = stack.pop()

        scrollbar(adjustment=rv.xadjustment)
        close()

        stack.append(addable)

        return rv

    else:

        side("c r b", **side_properties)

        rv = _viewport(**viewport_properties)
        addable = stack.pop()

        vscrollbar(adjustment=rv.yadjustment)
        scrollbar(adjustment=rv.xadjustment)
        close()

        stack.append(addable)

        return rv

conditional = Wrapper(renpy.display.behavior.Conditional, one=True)
timer = Wrapper(renpy.display.behavior.Timer, replaces=True)
drag = Wrapper(renpy.display.dragdrop.Drag, replaces=True, one=True)
draggroup = Wrapper(renpy.display.dragdrop.DragGroup, replaces=True, many=True)
mousearea = Wrapper(renpy.display.behavior.MouseArea, replaces=True)


##############################################################################
# New-style imagemap related functions.

class Imagemap(object):
    """
    Stores information about the images used by an imagemap.
    """

    alpha = True

    def __init__(self, insensitive, idle, selected_idle, hover, selected_hover, selected_insensitive, alpha, cache):
        self.insensitive = renpy.easy.displayable(insensitive)
        self.idle = renpy.easy.displayable(idle)
        self.selected_idle = renpy.easy.displayable(selected_idle)
        self.hover = renpy.easy.displayable(hover)
        self.selected_hover = renpy.easy.displayable(selected_hover)
        self.selected_insensitive = renpy.easy.displayable(selected_insensitive)

        self.alpha = alpha

        self.cache = renpy.display.imagemap.ImageMapCache(cache)

def _imagemap(ground=None, hover=None, insensitive=None, idle=None, selected_hover=None, selected_idle=None, selected_insensitive=None, auto=None, alpha=True, cache=True, style='imagemap', **properties):

    def pick(variable, name, other):
        if variable:
            return variable

        if auto:
            fn = renpy.config.imagemap_auto_function(auto, name)
            if fn is not None:
                return fn

        if other is not None:
            return other

        raise Exception("Could not find a %s image for imagemap." % name)


    ground = pick(ground, "ground", None)
    idle = pick(idle, "idle", ground)
    selected_idle = pick(selected_idle, "selected_idle", idle)
    hover = pick(hover, "hover", ground)
    selected_hover = pick(selected_hover, "selected_hover", hover)
    insensitive = pick(insensitive, "insensitive", ground)
    selected_insensitive = pick(selected_insensitive, "selected_insensitive", hover)

    imagemap_stack.append(
        Imagemap(
            insensitive,
            idle,
            selected_idle,
            hover,
            selected_hover,
            selected_insensitive,
            alpha,
            cache))

    properties.setdefault('fit_first', True)

    rv = renpy.display.layout.MultiBox(layout='fixed', **properties)

    if ground:
        rv.add(renpy.easy.displayable(ground))

    box = renpy.display.layout.MultiBox(layout='fixed')
    rv.add(box)
    rv._main = box

    return rv

imagemap = Wrapper(_imagemap, imagemap=True, style='imagemap')

def _hotspot(spot, style='hotspot', **properties):

    if not imagemap_stack:
        raise Exception("hotspot expects an imagemap to be defined.")

    imagemap = imagemap_stack[-1]

    x, y, w, h = spot

    idle = imagemap.idle
    hover = imagemap.hover
    selected_idle = imagemap.selected_idle
    selected_hover = imagemap.selected_hover
    insensitive = imagemap.insensitive
    selected_insensitive = imagemap.selected_insensitive

    idle = imagemap.cache.crop(idle, spot)
    hover = imagemap.cache.crop(hover, spot)
    selected_idle = imagemap.cache.crop(selected_idle, spot)
    selected_hover = imagemap.cache.crop(selected_hover, spot)
    insensitive = imagemap.cache.crop(insensitive, spot)
    selected_insensitive = imagemap.cache.crop(selected_insensitive, spot)

    properties.setdefault("xpos", x)
    properties.setdefault("xanchor", 0)
    properties.setdefault("ypos", y)
    properties.setdefault("yanchor", 0)
    properties.setdefault("xminimum", w)
    properties.setdefault("xmaximum", w)
    properties.setdefault("yminimum", h)
    properties.setdefault("ymaximum", h)

    if imagemap.alpha:
        focus_mask = True
    else:
        focus_mask = None

    properties.setdefault("focus_mask", focus_mask)

    return renpy.display.behavior.Button(
        None,
        idle_background=idle,
        selected_idle_background=selected_idle,
        hover_background=hover,
        selected_hover_background=selected_hover,
        insensitive_background=insensitive,
        selected_insensitive_background=selected_insensitive,
        style=style,
        **properties)

hotspot_with_child = Wrapper(_hotspot, style="hotspot", one=True)

def hotspot(*args, **kwargs):
    hotspot_with_child(*args, **kwargs)
    null()

def _hotbar(spot, adjustment=None, range=None, value=None, **properties): #@ReservedAssignment

    if (adjustment is None) and (range is None) and (value is None):
        raise Exception("hotbar requires either an adjustment or a range and value.")

    if not imagemap_stack:
        raise Exception("hotbar expects an imagemap to be defined.")

    imagemap = imagemap_stack[-1]

    x, y, w, h = spot

    properties.setdefault("xpos", x)
    properties.setdefault("ypos", y)
    properties.setdefault("xanchor", 0)
    properties.setdefault("yanchor", 0)

    fore_bar=imagemap.cache.crop(imagemap.selected_idle, spot)
    aft_bar=imagemap.cache.crop(imagemap.idle, spot)
    hover_fore_bar=imagemap.cache.crop(imagemap.selected_hover, spot)
    hover_aft_bar=imagemap.cache.crop(imagemap.hover, spot)

    if h > w:
        properties.setdefault("bar_vertical", True)
        properties.setdefault("bar_invert", True)

        fore_bar, aft_bar = aft_bar, fore_bar
        hover_fore_bar, hover_aft_bar = hover_aft_bar, hover_fore_bar

    return renpy.display.behavior.Bar(
            adjustment=adjustment,
            range=range,
            value=value,
            fore_bar=fore_bar,
            aft_bar=aft_bar,
            hover_fore_bar=hover_fore_bar,
            hover_aft_bar=hover_aft_bar,
            fore_gutter=0,
            aft_gutter=0,
            bar_resizing=False,
            thumb=None,
            thumb_shadow=None,
            thumb_offset=0,
            xmaximum=w,
            ymaximum=h,
            **properties)

hotbar = Wrapper(_hotbar, style="hotbar", replaces=True)


##############################################################################
# Curried functions, for use in clicked, hovered, and unhovered.

def _returns(v):

    return v

returns = renpy.curry.curry(_returns)

def _jumps(label, transition=None):

    if isinstance(transition, basestring):
        transition = getattr(renpy.config, transition)

    if transition is not None:
        renpy.exports.transition(transition)

    raise renpy.exports.jump(label)

jumps = renpy.curry.curry(_jumps)

def _jumpsoutofcontext(label):

    raise renpy.game.JumpOutException(label)

jumpsoutofcontext = renpy.curry.curry(_jumpsoutofcontext)

def callsinnewcontext(*args, **kwargs):
    return renpy.exports.curried_call_in_new_context(*args, **kwargs)

def invokesinnewcontext(*args, **kwargs):
    return renpy.exports.curried_invoke_in_new_context(*args, **kwargs)

def gamemenus(*args):
    return callsinnewcontext("_game_menu", *args)

##############################################################################
# The on statement.
def on(event, action=[], id=None): #@ReservedAssignment
    if renpy.display.screen.current_screen().current_transform_event != event:
        return

    renpy.display.behavior.run(action)


##############################################################################
# Postamble

# Update the wrappers to have names.
k, v = None, None
for k, v in globals().iteritems():
    if isinstance(v, Wrapper):
        v.name = k

########NEW FILE########
__FILENAME__ = warp
# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# This code implements the ability to "warp" to a given location in
# the Ren'Py source code, given the filename and line number of the
# location.

import renpy
import sets

warp_spec = None

def warp():
    """
    Given a filename and line number, this attempts to warp the user
    to that filename and line number.
    """

    global warp_spec

    spec = warp_spec
    warp_spec = None

    if spec is None:
        return None

    if ':' not in spec:
        raise Exception('No : found in warp location.')

    filename, line = spec.split(':', 1)
    line = int(line)

    if not renpy.config.developer:
        raise Exception("Can't warp, developer mode disabled.")

    # First, compute for each statement reachable from a scene statement,
    # one statement that reaches that statement.

    prev = { }

    workset = sets.Set([ n for n in renpy.game.script.namemap.itervalues() if isinstance(n, renpy.ast.Scene) ])
    seenset = sets.Set(workset)

    # This is called to indicate that next can be executed following node.
    def add(node, next): #@ReservedAssignment
        if next not in seenset:
            seenset.add(next)
            workset.add(next)
            prev[next] = node

    while workset:

        n = workset.pop()

        if isinstance(n, renpy.ast.Menu):
            for i in n.items:
                if i[2] is not None:
                    add(n, i[2][0])

        if isinstance(n, renpy.ast.Jump):
            if not n.expression and n.target in renpy.game.script.namemap:
                add(n, renpy.game.script.namemap[n.target])
                continue

        if isinstance(n, renpy.ast.While):
            add(n, n.block[0])

        if isinstance(n, renpy.ast.If):

            seen_true = False

            for condition, block in n.entries:
                add(n, block[0])

                if condition == "True":
                    seen_true = True

            if seen_true:
                continue

        if isinstance(n, renpy.ast.UserStatement):
            add(n, n.get_next())

        elif getattr(n, 'next', None) is not None:
            add(n, n.next)

    # Now, attempt to find a statement preceding the line that the
    # user wants to warp to.

    candidates = [ (n.linenumber, n)
                   for n in seenset
                   if n.filename.endswith('/' + filename) and n.linenumber <= line ]

    # We didn't find any candidate statements, so give up the warp.
    if not candidates:
        return

    # Sort the list of candidates, so they're ordered by linenumber.
    candidates.sort()

    # Pick the candidate immediately before (or on) the line.
    node = candidates[-1][1]

    # Now, determine a list of nodes to run while getting to this node.
    run = [ ]
    n = node

    while True:
        n = prev.get(n, None)
        if n:
            run.append(n)
        else:
            break

    run.reverse()

    # Determine which statements we want to execute, and then run
    # only them.

    toexecute = ( renpy.ast.Scene, renpy.ast.Show, renpy.ast.Hide )

    for n in run:
        if isinstance(n, toexecute):
            n.execute()

    # Now, return the name of the place where we will warp to. This
    # becomes the new starting point of the game.

    return node.name

########NEW FILE########
__FILENAME__ = renpy
#!/usr/bin/env python
#@PydevCodeAnalysisIgnore

# This file is part of Ren'Py. The license below applies to Ren'Py only.
# Games and other projects that use Ren'Py may use a different license.

# Copyright 2004-2014 Tom Rothamel <pytom@bishoujo.us>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import os
import sys
import warnings

# Functions to be customized by distributors. ################################

# Given the Ren'Py base directory (usually the directory containing
# this file), this is expected to return the path to the common directory.
def path_to_common(renpy_base):
    return renpy_base + "/renpy/common"

# Given a directory holding a Ren'Py game, this is expected to return
# the path to a directory that will hold save files.
def path_to_saves(gamedir):
    import renpy #@UnresolvedImport

    # Android.
    if renpy.android:
        paths = [
            os.path.join(os.environ["ANDROID_OLD_PUBLIC"], "game/saves"),
            os.path.join(os.environ["ANDROID_PRIVATE"], "saves"),
            os.path.join(os.environ["ANDROID_PUBLIC"], "saves"),
            ]

        for rv in paths:
            if os.path.isdir(rv):
                break

        print "Using savedir", rv

        # We return the last path as the default.

        return rv


    # No save directory given.
    if not renpy.config.save_directory:
        return gamedir + "/saves"

    # Search the path above Ren'Py for a directory named "Ren'Py Data".
    # If it exists, then use that for our save directory.
    path = renpy.config.renpy_base

    while True:
        if os.path.isdir(path + "/Ren'Py Data"):
            return path + "/Ren'Py Data/" + renpy.config.save_directory

        newpath = os.path.dirname(path)
        if path == newpath:
            break
        path = newpath

    # Otherwise, put the saves in a platform-specific location.
    if renpy.macintosh:
        rv = "~/Library/RenPy/" + renpy.config.save_directory
        return os.path.expanduser(rv)

    elif renpy.windows:
        if 'APPDATA' in os.environ:
            return os.environ['APPDATA'] + "/RenPy/" + renpy.config.save_directory
        else:
            rv = "~/RenPy/" + renpy.config.save_directory
            return os.path.expanduser(rv)

    else:
        rv = "~/.renpy/" + renpy.config.save_directory
        return os.path.expanduser(rv)


# Returns the path to the Ren'Py base directory (containing common and
# the launcher, usually.)
def path_to_renpy_base():
    renpy_base = os.path.dirname(os.path.realpath(sys.argv[0]))
    renpy_base = os.environ.get('RENPY_BASE', renpy_base)
    renpy_base = os.path.abspath(renpy_base)

    return renpy_base

##############################################################################

# The version of the Mac Launcher and py4renpy that we require.
macos_version = (6, 14, 0)
linux_version = (6, 14, 0)

# Doing the version check this way also doubles as an import of ast,
# which helps py2exe et al.
try:
    import ast; ast
except:
    raise
    print "Ren'Py requires at least python 2.6."
    sys.exit(0)

android = ("ANDROID_PRIVATE" in os.environ)

# Android requires us to add code to the main module, and to command some
# renderers.
if android:
    __main__ = sys.modules["__main__"]
    __main__.path_to_renpy_base = path_to_renpy_base
    __main__.path_to_common = path_to_common
    __main__.path_to_saves = path_to_saves
    os.environ["RENPY_RENDERER"] = "gl"

def main():

    renpy_base = path_to_renpy_base()

    # Add paths.
    if os.path.exists(renpy_base + "/module"):
        sys.path.append(renpy_base + "/module")

    sys.path.append(renpy_base)

    # This is looked for by the mac launcher.
    if os.path.exists(renpy_base + "/renpy.zip"):
        sys.path.append(renpy_base + "/renpy.zip")

    # Ignore warnings that happen.
    warnings.simplefilter("ignore", DeprecationWarning)

    # Start Ren'Py proper.
    try:
        import renpy.bootstrap
    except ImportError:
        print >>sys.stderr, "Could not import renpy.bootstrap. Please ensure you decompressed Ren'Py"
        print >>sys.stderr, "correctly, preserving the directory structure."
        raise

    if android:
        renpy.linux = False
        renpy.android = True

    renpy.bootstrap.bootstrap(renpy_base)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = check_copyright
#!/usr/bin/env python

from __future__ import print_function

import os.path
import re
import codecs

ENDINGS = [
    ".rpy",
    ".rpym",
    ".py",
    ".pyx",
    ".pxd",
    ]

WHITELIST = """\
renpy/vc_version.py
renpy/angle
renpy/gl/__init__.py
renpy/common/00splines.rpy
renpy/common/00console.rpy
renpy/text/__init__.py
module/maketegl.py
module/generate_linebreak.py
module/pysdlsound/linmixer.py
module/pysdlsound/__init__.py
module/build/
module/include/
module/gen/
launcher/game/EasyDialogsResources.py
launcher/game/EasyDialogsWin.py
launcher/game/pefile.py
launcher/game/script_version.rpy
launcher/game/tl
launcher/game/theme""".split()

LICENSE = "Permission is hereby granted"

def process_file(fn):

    for i in ENDINGS:
        if fn.endswith(i):
            break
    else:
        return

    for i in WHITELIST:
        if fn.startswith(i):
            return

    has_copyright = False
    has_license = False
    first = True

    with open(fn, "rb") as f:

        for l in f:
            if fn.endswith(".rpy") or fn.endswith(".rpym"):
                if first:
                    if codecs.BOM_UTF8 not in l:
                        print("Missing BOM", fn)
                    first = False
                else:
                    if codecs.BOM_UTF8 in l:
                        print("Extra BOM", fn)

                first = False


            m = re.search(
                r"Copyright (\d{4})-2014 Tom Rothamel",
                l)

            if m:
                has_copyright = True

            if LICENSE in l:
                has_license = True

            if has_copyright and has_license:
                return

    print("Missing copyright", fn)


def process(root):

    for dirname, _dirs, files in os.walk(root):
        for fn in files:
            fn = os.path.join(dirname, fn)
            process_file(fn)

process_file("renpy.py")
process("renpy")
process("module")
process("launcher/game")


########NEW FILE########
__FILENAME__ = generate_update_keys
#!/usr/bin/env python
# Generate a pair of update keys.
#

import argparse
import rsa

ap = argparse.ArgumentParser()
ap.add_argument("private")
ap.add_argument("public")
args = ap.parse_args()

public, private = rsa.newkeys(2048)

with open(args.public, "wb") as f:
    f.write(public.save_pkcs1())

with open(args.private, "wb") as f:
    f.write(private.save_pkcs1())


########NEW FILE########
__FILENAME__ = sign_update
#!/usr/bin/env python
# Signs the update.json file.

import argparse
import rsa

ap = argparse.ArgumentParser()
ap.add_argument("private")
ap.add_argument("json")
args = ap.parse_args()

with open(args.private, "rb") as f:
    private = rsa.PrivateKey.load_pkcs1(f.read())

with open(args.json, "rb") as f:
    message = f.read()

signature = rsa.sign(message, private, "SHA-256")

with open(args.json + ".sig", "wb") as f:
    f.write(signature.encode("base64"))

########NEW FILE########
__FILENAME__ = style_to_statement
# Scans a file for python style assignments, and turns such lines into
# style statements.
#
# The result of this probably won't be legal Ren'Py, but it should be
# a reasonable starting point for conversions.

import argparse
import sys
import os
import re

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import renpy

renpy.import_all()
renpy.config.basedir = '/'
renpy.config.renpy_base = '/'

def main():

    ap = argparse.ArgumentParser()
    ap.add_argument("script")
    args = ap.parse_args()

    current_name = None
    current_parent = None
    current_entries = None

    def emit():
        if not current_name:
            return

        print

        if current_parent and current_entries:
            print "style {} is {}:".format(current_name, current_parent)
        elif current_parent:
            print "style {} is {}".format(current_name, current_parent)
        elif current_entries:
            print "style {}:".format(current_name)
        else:
            print "style {}".format(current_name)

        for name, expr in current_entries:
            if expr:
                print "    {} {}".format(name, expr.strip())
            else:
                print "    {}".format(name)


    for _fn, _lineno, l in renpy.parser.list_logical_lines(args.script):

        m = re.search(r'style\.(\w+)\s*=\s*Style\(\s*(["\'](\w+)["\']|style\.(\w+))', l)

        new_name = None
        new_parent = None
        new_entries = [ ]

        if m:
            name = m.group(1)
            parent = m.group(3) or m.group(4)

            new_name = name
            new_parent = parent

        m = re.search(r'style\.create\(["\'](\w+)["\'],\s*["\'](\w+)["\']', l)
        if m:
            new_name = m.group(1)
            new_parent = m.group(2)

        m = re.search(r'style\.(\w+)\.(\w+)\s*=\s*(.*)', l, re.S)
        if m:
            new_name = m.group(1)
            new_entries.append((m.group(2), m.group(3)))

        m = re.search(r'style\.(\w+)\.clear\(\)', l)
        if m:
            new_name = m.group(1)
            new_entries.append(("clear", None))

        m = re.search(r'style\.(\w+)\.take\((.*)\)', l)
        if m:
            new_name = m.group(1)
            new_entries.append(("take", m.group(2)))

        m = re.search(r'style\.(\w+)\.set_parent\(style\.(.*)\)', l)
        if m:
            new_name = m.group(1)
            new_entries.append(("is", m.group(2)))

        m = re.search(r'style\.(\w+)\.set_parent\([\'"](.*)[\'"]\)', l)
        if m:
            new_name = m.group(1)
            new_entries.append(("is", m.group(2)))

        if new_name is None:
            continue

        if new_name != current_name:
            emit()
            current_name = new_name
            current_parent = new_parent
            current_entries = new_entries
        else:
            if new_parent:
                current_parent = new_parent

            current_entries.extend(new_entries)

    emit()





if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = update_copyright
#!/usr/bin/env python

from __future__ import print_function

import os.path
import re
import codecs

ENDINGS = [
    ".rpy",
    ".rpym",
    ".py",
    ".pyx",
    ".pxf",
    ]

full_copyright="""\
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."""

def process_file(fn):

    for i in ENDINGS:
        if fn.endswith(i):
            break
    else:
        return

    print("Processing", fn)

    lines = [ ]

    has_copyright = False
    first = True

    with open(fn, "rb") as f:
        for l in f:
            l = re.sub(
                r"Copyright (\d{4})-\d{4} Tom Rothamel",
                r"Copyright \1-2014 Tom Rothamel",
                l)

            if re.search(r"Copyright .* Tom Rothamel", l):
                if has_copyright:
                    continue

                has_copyright = True

            l = l.replace("# See LICENSE.txt for license details.", full_copyright)

            if first:
                if fn.endswith(".rpy") or fn.endswith(".rpym"):
                    if codecs.BOM_UTF8 not in l:
                        l = codecs.BOM_UTF8 + l

                first = False

            lines.append(l)

    with open(fn, "wb") as f:
        f.write("".join(lines))


def process(root):

    for dirname, _dirs, files in os.walk(root):
        for fn in files:
            fn = os.path.join(dirname, fn)
            process_file(fn)

process_file("renpy.py")
process("renpy")
process("module")
process("launcher/game")

########NEW FILE########
__FILENAME__ = utflf
# Fixes line endings and adds UTF-8 BOM to all rpy files in a
# directory.

import sys

def process(fn):
    with open(fn, "rb") as f:
        data = f.read()

    data = data.decode("utf-8")
    data = data.replace("\r", "")
    data = data.replace(u"\ufeff", "")
    data = u"\ufeff" + data
    data = data.encode("utf-8")

    with open(fn, "wb") as f:
        f.write(data)

import os

for directory, dirs, files in os.walk(sys.argv[1]):
    for fn in files:
        fn = os.path.join(directory, fn)

        if not fn.endswith(".rpy"):
            continue

        print fn
        process(fn)

########NEW FILE########
__FILENAME__ = checks
from __future__ import print_function

import os
import re

def check_include():

    used = set()

    def scan_file(fn):
        f = open(fn)

        for l in f:
            m = re.search(r"\.\. include::(.+)", l)

            if not m:
                continue

            fn = m.group(1).strip()

            used.add(fn)

    for i in os.listdir("source"):
        if i.endswith(".rst"):
            scan_file(os.path.join("source", i))

    for i in os.listdir("source/inc"):
        scan_file(os.path.join("source", "inc", i))

    for i in os.listdir("source/inc"):
        fn = "inc/" + i
        if fn not in used:
            print("WARNING: source/{} is not used.".format(fn))

if __name__ == "__main__":
    check_include()

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Ren'Py Developer Guide documentation build configuration file, created by
# sphinx-quickstart on Fri Jul 29 20:07:18 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os #@UnusedImport

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Ren\'Py Developer Guide'
copyright = u'2011, Ren\'Py Project' #@ReservedAssignment

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '6.13'
# The full version, including alpha/beta/rc tags.
release = '6.13'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'RenPyDeveloperGuidedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
]

########NEW FILE########
__FILENAME__ = doc
import inspect
import re
import collections
import keyword
import renpy
import shutil
import StringIO
import os

import __builtin__

# Keywords in the Ren'Py script language.
KEYWORD1 = """\
$
as
at
behind
call
expression
hide
if
in
image
init
jump
menu
onlayer
python
return
scene
set
show
with
while
zorder
transform
play
queue
stop
pause
define
screen
label
voice
translate
"""

# Words that are sometimes statement keywords, like for ATL
# or Screen language statements.
KEYWORD2 = """\
nvl
window
repeat
block
contains
parallel
choice
on
time
function
event
animation
clockwise
counterclockwise
circles
knot
null
text
hbox
vbox
fixed
grid
side
frame
key
timer
input
button
imagebutton
textbutton
bar
vbar
viewport
imagemap
hotspot
hotbar
transform
add
use
has
style
"""


def write_keywords():
    f = file("source/keywords.py", "w")

    kwlist = list(keyword.kwlist)
    kwlist.extend(KEYWORD1.split())
    kwlist.extend(KEYWORD2.split())

    kwlist.sort()

    f.write("keywords = %r\n" % kwlist)

    properties = list(i for i in renpy.screenlang.all_keyword_names if i not in kwlist)
    properties.sort()

    f.write("properties = %r\n" % properties)

    f.close()

    shutil.copy("source/keywords.py", "../tutorial/game/keywords.py")


# A map from filename to a list of lines that are supposed to go into
# that file.
line_buffer = collections.defaultdict(list)


def scan(name, o, prefix=""):

    doc_type = "function"

    # The section it's going into.
    section = None

    # The formatted arguments.
    args = None

    # Get the function's docstring.
    doc = inspect.getdoc(o)

    if not doc:
        return

    # Break up the doc string, scan it for specials.
    lines = [ ]

    for l in doc.split("\n"):
        m = re.match(r':doc: *(\w+) *(\w+)?', l)
        if m:
            section = m.group(1)

            if m.group(2):
                doc_type = m.group(2)

            continue

        m = re.match(r':args: *(.*)', l)
        if m:
            args = m.group(1)
            continue

        m = re.match(r':name: *(\S+)', l)
        if m:
            if name != m.group(1):
                return
            continue

        lines.append(l)

    if section is None:
        return

    if args is None:

        # Get the arguments.
        if inspect.isclass(o):
            init = getattr(o, "__init__", None)
            if not init:
                return

            init_doc = inspect.getdoc(init)

            if init_doc and not init_doc.startswith("x.__init__("):
                lines.append("")
                lines.extend(init_doc.split("\n"))

            try:
                args = inspect.getargspec(init)
            except:
                args = None

        elif inspect.isfunction(o):
            args = inspect.getargspec(o)

        elif inspect.ismethod(o):
            args = inspect.getargspec(o)

        else:
            print "Warning: %s has section but not args." % name

            return

        # Format the arguments.
        if args is not None:

            args = inspect.formatargspec(*args)
            args = args.replace("(self, ", "(")
        else:
            args = "()"


    # Put it into the line buffer.
    lb = line_buffer[section]

    lb.append(prefix + ".. %s:: %s%s" % (doc_type, name, args))

    for l in lines:
        lb.append(prefix + "    " + l)

    lb.append(prefix + "")

    if inspect.isclass(o):
        for i in dir(o):
            scan(i, getattr(o, i), prefix + "    ")


def scan_section(name, o):
    """
    Scans object o. Assumes it has the name name.
    """

    for n in dir(o):
        scan(name + n, getattr(o, n))


def write_line_buffer():

    for k, v in line_buffer.iteritems():

        # f = file("source/inc/" + k, "w")

        f = StringIO.StringIO()

        print >>f, ".. Automatically generated file - do not modify."
        print >>f

        for l in v:
            print >>f, l

        s = f.getvalue()

        if os.path.exists("source/inc/" + k):
            with open("source/inc/" + k) as f:
                if f.read() == s:
                    print "Retaining", k
                    continue

        print "Generating", k

        with open("source/inc/" + k, "w") as f:
            f.write(s)


name_kind = collections.defaultdict(str)

def scan_docs():
    """
    Scans the documentation for functions, classes, and variables.
    """


    def scan_file(fn):
        f = open(fn)

        for l in f:
            m = re.search(r"\.\. (\w+):: ([.\w+]+)", l)

            if not m:
                continue

            name_kind[m.group(2)] = m.group(1)

    for i in os.listdir("source"):
        if i.endswith(".rst"):
            scan_file(os.path.join("source", i))

    for i in os.listdir("source/inc"):
        scan_file(os.path.join("source", "inc", i))




def write_reserved(module, dest, ignore_builtins):

    print "Writing", dest

    with open(dest, "w") as f:

        for i in sorted(dir(module)):

            if i == "doc":
                continue

            if i.startswith("_"):
                continue

            if ignore_builtins and hasattr(__builtin__, i):
                continue

            if name_kind[i] == 'function':
                i = ":func:`{}`".format(i)
            elif name_kind[i] == 'class':
                i = ":class:`{}`".format(i)
            elif name_kind[i] == 'var':
                i = ":var:`{}`".format(i)

            f.write("* " + i + "\n")

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# The Ren'Py Visual Novel Engine documentation build configuration file, created by
# sphinx-quickstart on Tue Jun 15 17:02:51 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.todo', 'sphinx.ext.extlinks', 'sphinx.ext.ifconfig', 'renpydoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Ren\'Py Visual Novel Engine'
copyright = u'2012, Tom Rothamel' #@ReservedAssignment

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.

sys.path.insert(0, '../..')
import renpy

version = ".".join(str(i) for i in renpy.version_tuple[:3])
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = [ ]

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'default'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
# html_theme = 'sphinxdoc'
html_theme = 'renpydoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = [ '.' ]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "Ren'Py Documentation"

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = False

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'TheRenPyVisualNovelEnginedoc'

locale_dirs = ["locale/"]


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'all.tex', u'Ren\'Py Visual Novel Engine Reference Manual',
   u'PyTom', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
latex_logo = "logo.png"

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
     # ('index', 'therenpyvisualnovelengine', u'The Ren'Py Visual Novel Engine Documentation',
     # [u'PyTom'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'The Ren\'Py Visual Novel Engine'
epub_author = u'PyTom'
epub_publisher = u'PyTom'
epub_copyright = u'2011, PyTom'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

highlight_language = "renpy"

extlinks = {'lpbug': ('https://bugs.launchpad.net/renpy/+bug/%s',
                      'launchpad bug '),
            'ghbug': ('https://github.com/renpy/renpy/issues/%s',
                      'github bug'),
            }

rst_prolog = """\
.. |PGS4A| replace:: RAPT
.. |PGS4A_URL| replace:: http://www.renpy.org/dl/android/
"""

def setup(app):
    app.add_config_value('is_renpy', '', True)

is_renpy = True


########NEW FILE########
__FILENAME__ = fill-translator-credits
#!/usr/bin/env python
#@PydevCodeAnalysisIgnore

# This file is part of Ren'Py. The license below applies to Ren'Py only.
# Games and other projects that use Ren'Py may use a different license.

# Copyright 2013 Koichi Akabe <vbkaisetsu@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import polib, os

po = polib.pofile("locale/credits/" + os.environ["LANGUAGE"] + ".po")

tc = ""

for podata in po:
    if podata.msgid == "translator-credits":
        tc = podata.msgstr
        break

if tc == "":
    tc = "???"

tc_lines = []
for line in tc.split("\n"):
    line_s = line.lstrip()
    tc_lines.append(" " * (len(line) - len(line_s)) + "* " + line_s)
    
tc = "\n\n".join(tc_lines)

creditsfile = open("source/credits.rst", "r")

reslines = []
for line in creditsfile:
    reslines.append(line.replace("@TRANSLATOR_CREDITS@", tc))

creditsfile.close()

creditsfile = open("source/credits.rst", "w")

for line in reslines:
    creditsfile.write(line)

creditsfile.close()

########NEW FILE########
__FILENAME__ = keywords
keywords = ['$', 'add', 'and', 'animation', 'as', 'as', 'assert', 'at', 'bar', 'behind', 'block', 'break', 'button', 'call', 'choice', 'circles', 'class', 'clockwise', 'contains', 'continue', 'counterclockwise', 'def', 'define', 'del', 'elif', 'else', 'event', 'except', 'exec', 'expression', 'finally', 'fixed', 'for', 'frame', 'from', 'function', 'global', 'grid', 'has', 'hbox', 'hide', 'hotbar', 'hotspot', 'if', 'if', 'image', 'imagebutton', 'imagemap', 'import', 'in', 'in', 'init', 'input', 'is', 'jump', 'key', 'knot', 'label', 'lambda', 'menu', 'not', 'null', 'nvl', 'on', 'onlayer', 'or', 'parallel', 'pass', 'pause', 'play', 'print', 'python', 'queue', 'raise', 'repeat', 'return', 'return', 'scene', 'screen', 'set', 'show', 'side', 'stop', 'style', 'text', 'textbutton', 'time', 'timer', 'transform', 'transform', 'translate', 'try', 'use', 'vbar', 'vbox', 'viewport', 'voice', 'while', 'while', 'window', 'with', 'with', 'yield', 'zorder']
properties = ['action', 'activate_additive', 'activate_align', 'activate_alignaround', 'activate_alpha', 'activate_anchor', 'activate_angle', 'activate_antialias', 'activate_area', 'activate_around', 'activate_background', 'activate_bar_invert', 'activate_bar_resizing', 'activate_bar_vertical', 'activate_black_color', 'activate_bold', 'activate_bottom_bar', 'activate_bottom_gutter', 'activate_bottom_margin', 'activate_bottom_padding', 'activate_box_layout', 'activate_box_reverse', 'activate_box_wrap', 'activate_child', 'activate_clipping', 'activate_color', 'activate_corner1', 'activate_corner2', 'activate_crop', 'activate_debug', 'activate_delay', 'activate_drop_shadow', 'activate_drop_shadow_color', 'activate_first_indent', 'activate_first_spacing', 'activate_fit_first', 'activate_focus_mask', 'activate_font', 'activate_foreground', 'activate_hyperlink_functions', 'activate_italic', 'activate_justify', 'activate_kerning', 'activate_language', 'activate_layout', 'activate_left_bar', 'activate_left_gutter', 'activate_left_margin', 'activate_left_padding', 'activate_line_leading', 'activate_line_spacing', 'activate_maximum', 'activate_min_width', 'activate_minimum', 'activate_minwidth', 'activate_mouse', 'activate_newline_indent', 'activate_offset', 'activate_order_reverse', 'activate_outlines', 'activate_pos', 'activate_radius', 'activate_rest_indent', 'activate_right_bar', 'activate_right_gutter', 'activate_right_margin', 'activate_right_padding', 'activate_rotate', 'activate_rotate_pad', 'activate_ruby_style', 'activate_size', 'activate_size_group', 'activate_slow_abortable', 'activate_slow_cps', 'activate_slow_cps_multiplier', 'activate_sound', 'activate_spacing', 'activate_strikethrough', 'activate_subpixel', 'activate_text_align', 'activate_text_y_fudge', 'activate_thumb', 'activate_thumb_offset', 'activate_thumb_shadow', 'activate_top_bar', 'activate_top_gutter', 'activate_top_margin', 'activate_top_padding', 'activate_transform_anchor', 'activate_underline', 'activate_unscrollable', 'activate_vertical', 'activate_xalign', 'activate_xanchor', 'activate_xanchoraround', 'activate_xaround', 'activate_xcenter', 'activate_xfill', 'activate_xmargin', 'activate_xmaximum', 'activate_xminimum', 'activate_xoffset', 'activate_xpadding', 'activate_xpos', 'activate_xsize', 'activate_xysize', 'activate_xzoom', 'activate_yalign', 'activate_yanchor', 'activate_yanchoraround', 'activate_yaround', 'activate_ycenter', 'activate_yfill', 'activate_ymargin', 'activate_ymaximum', 'activate_yminimum', 'activate_yoffset', 'activate_ypadding', 'activate_ypos', 'activate_ysize', 'activate_yzoom', 'activate_zoom', 'additive', 'adjustment', 'align', 'alignaround', 'allow', 'alpha', 'alternate', 'anchor', 'angle', 'antialias', 'area', 'around', 'auto', 'background', 'bar_invert', 'bar_resizing', 'bar_vertical', 'black_color', 'bold', 'bottom_bar', 'bottom_gutter', 'bottom_margin', 'bottom_padding', 'box_layout', 'box_reverse', 'box_wrap', 'cache', 'changed', 'child', 'child_size', 'clicked', 'clipping', 'color', 'corner1', 'corner2', 'crop', 'debug', 'default', 'delay', 'drag_handle', 'drag_joined', 'drag_name', 'drag_raise', 'draggable', 'dragged', 'drop_shadow', 'drop_shadow_color', 'droppable', 'dropped', 'edgescroll', 'exclude', 'first_indent', 'first_spacing', 'fit_first', 'focus', 'focus_mask', 'font', 'foreground', 'ground', 'height', 'hover', 'hover_additive', 'hover_align', 'hover_alignaround', 'hover_alpha', 'hover_anchor', 'hover_angle', 'hover_antialias', 'hover_area', 'hover_around', 'hover_background', 'hover_bar_invert', 'hover_bar_resizing', 'hover_bar_vertical', 'hover_black_color', 'hover_bold', 'hover_bottom_bar', 'hover_bottom_gutter', 'hover_bottom_margin', 'hover_bottom_padding', 'hover_box_layout', 'hover_box_reverse', 'hover_box_wrap', 'hover_child', 'hover_clipping', 'hover_color', 'hover_corner1', 'hover_corner2', 'hover_crop', 'hover_debug', 'hover_delay', 'hover_drop_shadow', 'hover_drop_shadow_color', 'hover_first_indent', 'hover_first_spacing', 'hover_fit_first', 'hover_focus_mask', 'hover_font', 'hover_foreground', 'hover_hyperlink_functions', 'hover_italic', 'hover_justify', 'hover_kerning', 'hover_language', 'hover_layout', 'hover_left_bar', 'hover_left_gutter', 'hover_left_margin', 'hover_left_padding', 'hover_line_leading', 'hover_line_spacing', 'hover_maximum', 'hover_min_width', 'hover_minimum', 'hover_minwidth', 'hover_mouse', 'hover_newline_indent', 'hover_offset', 'hover_order_reverse', 'hover_outlines', 'hover_pos', 'hover_radius', 'hover_rest_indent', 'hover_right_bar', 'hover_right_gutter', 'hover_right_margin', 'hover_right_padding', 'hover_rotate', 'hover_rotate_pad', 'hover_ruby_style', 'hover_size', 'hover_size_group', 'hover_slow_abortable', 'hover_slow_cps', 'hover_slow_cps_multiplier', 'hover_sound', 'hover_spacing', 'hover_strikethrough', 'hover_subpixel', 'hover_text_align', 'hover_text_y_fudge', 'hover_thumb', 'hover_thumb_offset', 'hover_thumb_shadow', 'hover_top_bar', 'hover_top_gutter', 'hover_top_margin', 'hover_top_padding', 'hover_transform_anchor', 'hover_underline', 'hover_unscrollable', 'hover_vertical', 'hover_xalign', 'hover_xanchor', 'hover_xanchoraround', 'hover_xaround', 'hover_xcenter', 'hover_xfill', 'hover_xmargin', 'hover_xmaximum', 'hover_xminimum', 'hover_xoffset', 'hover_xpadding', 'hover_xpos', 'hover_xsize', 'hover_xysize', 'hover_xzoom', 'hover_yalign', 'hover_yanchor', 'hover_yanchoraround', 'hover_yaround', 'hover_ycenter', 'hover_yfill', 'hover_ymargin', 'hover_ymaximum', 'hover_yminimum', 'hover_yoffset', 'hover_ypadding', 'hover_ypos', 'hover_ysize', 'hover_yzoom', 'hover_zoom', 'hovered', 'hyperlink_functions', 'id', 'idle', 'idle_additive', 'idle_align', 'idle_alignaround', 'idle_alpha', 'idle_anchor', 'idle_angle', 'idle_antialias', 'idle_area', 'idle_around', 'idle_background', 'idle_bar_invert', 'idle_bar_resizing', 'idle_bar_vertical', 'idle_black_color', 'idle_bold', 'idle_bottom_bar', 'idle_bottom_gutter', 'idle_bottom_margin', 'idle_bottom_padding', 'idle_box_layout', 'idle_box_reverse', 'idle_box_wrap', 'idle_child', 'idle_clipping', 'idle_color', 'idle_corner1', 'idle_corner2', 'idle_crop', 'idle_debug', 'idle_delay', 'idle_drop_shadow', 'idle_drop_shadow_color', 'idle_first_indent', 'idle_first_spacing', 'idle_fit_first', 'idle_focus_mask', 'idle_font', 'idle_foreground', 'idle_hyperlink_functions', 'idle_italic', 'idle_justify', 'idle_kerning', 'idle_language', 'idle_layout', 'idle_left_bar', 'idle_left_gutter', 'idle_left_margin', 'idle_left_padding', 'idle_line_leading', 'idle_line_spacing', 'idle_maximum', 'idle_min_width', 'idle_minimum', 'idle_minwidth', 'idle_mouse', 'idle_newline_indent', 'idle_offset', 'idle_order_reverse', 'idle_outlines', 'idle_pos', 'idle_radius', 'idle_rest_indent', 'idle_right_bar', 'idle_right_gutter', 'idle_right_margin', 'idle_right_padding', 'idle_rotate', 'idle_rotate_pad', 'idle_ruby_style', 'idle_size', 'idle_size_group', 'idle_slow_abortable', 'idle_slow_cps', 'idle_slow_cps_multiplier', 'idle_sound', 'idle_spacing', 'idle_strikethrough', 'idle_subpixel', 'idle_text_align', 'idle_text_y_fudge', 'idle_thumb', 'idle_thumb_offset', 'idle_thumb_shadow', 'idle_top_bar', 'idle_top_gutter', 'idle_top_margin', 'idle_top_padding', 'idle_transform_anchor', 'idle_underline', 'idle_unscrollable', 'idle_vertical', 'idle_xalign', 'idle_xanchor', 'idle_xanchoraround', 'idle_xaround', 'idle_xcenter', 'idle_xfill', 'idle_xmargin', 'idle_xmaximum', 'idle_xminimum', 'idle_xoffset', 'idle_xpadding', 'idle_xpos', 'idle_xsize', 'idle_xysize', 'idle_xzoom', 'idle_yalign', 'idle_yanchor', 'idle_yanchoraround', 'idle_yaround', 'idle_ycenter', 'idle_yfill', 'idle_ymargin', 'idle_ymaximum', 'idle_yminimum', 'idle_yoffset', 'idle_ypadding', 'idle_ypos', 'idle_ysize', 'idle_yzoom', 'idle_zoom', 'image_style', 'insensitive', 'insensitive_additive', 'insensitive_align', 'insensitive_alignaround', 'insensitive_alpha', 'insensitive_anchor', 'insensitive_angle', 'insensitive_antialias', 'insensitive_area', 'insensitive_around', 'insensitive_background', 'insensitive_bar_invert', 'insensitive_bar_resizing', 'insensitive_bar_vertical', 'insensitive_black_color', 'insensitive_bold', 'insensitive_bottom_bar', 'insensitive_bottom_gutter', 'insensitive_bottom_margin', 'insensitive_bottom_padding', 'insensitive_box_layout', 'insensitive_box_reverse', 'insensitive_box_wrap', 'insensitive_child', 'insensitive_clipping', 'insensitive_color', 'insensitive_corner1', 'insensitive_corner2', 'insensitive_crop', 'insensitive_debug', 'insensitive_delay', 'insensitive_drop_shadow', 'insensitive_drop_shadow_color', 'insensitive_first_indent', 'insensitive_first_spacing', 'insensitive_fit_first', 'insensitive_focus_mask', 'insensitive_font', 'insensitive_foreground', 'insensitive_hyperlink_functions', 'insensitive_italic', 'insensitive_justify', 'insensitive_kerning', 'insensitive_language', 'insensitive_layout', 'insensitive_left_bar', 'insensitive_left_gutter', 'insensitive_left_margin', 'insensitive_left_padding', 'insensitive_line_leading', 'insensitive_line_spacing', 'insensitive_maximum', 'insensitive_min_width', 'insensitive_minimum', 'insensitive_minwidth', 'insensitive_mouse', 'insensitive_newline_indent', 'insensitive_offset', 'insensitive_order_reverse', 'insensitive_outlines', 'insensitive_pos', 'insensitive_radius', 'insensitive_rest_indent', 'insensitive_right_bar', 'insensitive_right_gutter', 'insensitive_right_margin', 'insensitive_right_padding', 'insensitive_rotate', 'insensitive_rotate_pad', 'insensitive_ruby_style', 'insensitive_size', 'insensitive_size_group', 'insensitive_slow_abortable', 'insensitive_slow_cps', 'insensitive_slow_cps_multiplier', 'insensitive_sound', 'insensitive_spacing', 'insensitive_strikethrough', 'insensitive_subpixel', 'insensitive_text_align', 'insensitive_text_y_fudge', 'insensitive_thumb', 'insensitive_thumb_offset', 'insensitive_thumb_shadow', 'insensitive_top_bar', 'insensitive_top_gutter', 'insensitive_top_margin', 'insensitive_top_padding', 'insensitive_transform_anchor', 'insensitive_underline', 'insensitive_unscrollable', 'insensitive_vertical', 'insensitive_xalign', 'insensitive_xanchor', 'insensitive_xanchoraround', 'insensitive_xaround', 'insensitive_xcenter', 'insensitive_xfill', 'insensitive_xmargin', 'insensitive_xmaximum', 'insensitive_xminimum', 'insensitive_xoffset', 'insensitive_xpadding', 'insensitive_xpos', 'insensitive_xsize', 'insensitive_xysize', 'insensitive_xzoom', 'insensitive_yalign', 'insensitive_yanchor', 'insensitive_yanchoraround', 'insensitive_yaround', 'insensitive_ycenter', 'insensitive_yfill', 'insensitive_ymargin', 'insensitive_ymaximum', 'insensitive_yminimum', 'insensitive_yoffset', 'insensitive_ypadding', 'insensitive_ypos', 'insensitive_ysize', 'insensitive_yzoom', 'insensitive_zoom', 'italic', 'justify', 'kerning', 'language', 'layout', 'left_bar', 'left_gutter', 'left_margin', 'left_padding', 'length', 'line_leading', 'line_spacing', 'maximum', 'min_width', 'minimum', 'minwidth', 'mouse', 'mousewheel', 'newline_indent', 'offset', 'order_reverse', 'outlines', 'pixel_width', 'pos', 'prefix', 'radius', 'range', 'rest_indent', 'right_bar', 'right_gutter', 'right_margin', 'right_padding', 'rotate', 'rotate_pad', 'ruby_style', 'scope', 'scrollbars', 'selected_activate_additive', 'selected_activate_align', 'selected_activate_alignaround', 'selected_activate_alpha', 'selected_activate_anchor', 'selected_activate_angle', 'selected_activate_antialias', 'selected_activate_area', 'selected_activate_around', 'selected_activate_background', 'selected_activate_bar_invert', 'selected_activate_bar_resizing', 'selected_activate_bar_vertical', 'selected_activate_black_color', 'selected_activate_bold', 'selected_activate_bottom_bar', 'selected_activate_bottom_gutter', 'selected_activate_bottom_margin', 'selected_activate_bottom_padding', 'selected_activate_box_layout', 'selected_activate_box_reverse', 'selected_activate_box_wrap', 'selected_activate_child', 'selected_activate_clipping', 'selected_activate_color', 'selected_activate_corner1', 'selected_activate_corner2', 'selected_activate_crop', 'selected_activate_debug', 'selected_activate_delay', 'selected_activate_drop_shadow', 'selected_activate_drop_shadow_color', 'selected_activate_first_indent', 'selected_activate_first_spacing', 'selected_activate_fit_first', 'selected_activate_focus_mask', 'selected_activate_font', 'selected_activate_foreground', 'selected_activate_hyperlink_functions', 'selected_activate_italic', 'selected_activate_justify', 'selected_activate_kerning', 'selected_activate_language', 'selected_activate_layout', 'selected_activate_left_bar', 'selected_activate_left_gutter', 'selected_activate_left_margin', 'selected_activate_left_padding', 'selected_activate_line_leading', 'selected_activate_line_spacing', 'selected_activate_maximum', 'selected_activate_min_width', 'selected_activate_minimum', 'selected_activate_minwidth', 'selected_activate_mouse', 'selected_activate_newline_indent', 'selected_activate_offset', 'selected_activate_order_reverse', 'selected_activate_outlines', 'selected_activate_pos', 'selected_activate_radius', 'selected_activate_rest_indent', 'selected_activate_right_bar', 'selected_activate_right_gutter', 'selected_activate_right_margin', 'selected_activate_right_padding', 'selected_activate_rotate', 'selected_activate_rotate_pad', 'selected_activate_ruby_style', 'selected_activate_size', 'selected_activate_size_group', 'selected_activate_slow_abortable', 'selected_activate_slow_cps', 'selected_activate_slow_cps_multiplier', 'selected_activate_sound', 'selected_activate_spacing', 'selected_activate_strikethrough', 'selected_activate_subpixel', 'selected_activate_text_align', 'selected_activate_text_y_fudge', 'selected_activate_thumb', 'selected_activate_thumb_offset', 'selected_activate_thumb_shadow', 'selected_activate_top_bar', 'selected_activate_top_gutter', 'selected_activate_top_margin', 'selected_activate_top_padding', 'selected_activate_transform_anchor', 'selected_activate_underline', 'selected_activate_unscrollable', 'selected_activate_vertical', 'selected_activate_xalign', 'selected_activate_xanchor', 'selected_activate_xanchoraround', 'selected_activate_xaround', 'selected_activate_xcenter', 'selected_activate_xfill', 'selected_activate_xmargin', 'selected_activate_xmaximum', 'selected_activate_xminimum', 'selected_activate_xoffset', 'selected_activate_xpadding', 'selected_activate_xpos', 'selected_activate_xsize', 'selected_activate_xysize', 'selected_activate_xzoom', 'selected_activate_yalign', 'selected_activate_yanchor', 'selected_activate_yanchoraround', 'selected_activate_yaround', 'selected_activate_ycenter', 'selected_activate_yfill', 'selected_activate_ymargin', 'selected_activate_ymaximum', 'selected_activate_yminimum', 'selected_activate_yoffset', 'selected_activate_ypadding', 'selected_activate_ypos', 'selected_activate_ysize', 'selected_activate_yzoom', 'selected_activate_zoom', 'selected_additive', 'selected_align', 'selected_alignaround', 'selected_alpha', 'selected_anchor', 'selected_angle', 'selected_antialias', 'selected_area', 'selected_around', 'selected_background', 'selected_bar_invert', 'selected_bar_resizing', 'selected_bar_vertical', 'selected_black_color', 'selected_bold', 'selected_bottom_bar', 'selected_bottom_gutter', 'selected_bottom_margin', 'selected_bottom_padding', 'selected_box_layout', 'selected_box_reverse', 'selected_box_wrap', 'selected_child', 'selected_clipping', 'selected_color', 'selected_corner1', 'selected_corner2', 'selected_crop', 'selected_debug', 'selected_delay', 'selected_drop_shadow', 'selected_drop_shadow_color', 'selected_first_indent', 'selected_first_spacing', 'selected_fit_first', 'selected_focus_mask', 'selected_font', 'selected_foreground', 'selected_hover', 'selected_hover_additive', 'selected_hover_align', 'selected_hover_alignaround', 'selected_hover_alpha', 'selected_hover_anchor', 'selected_hover_angle', 'selected_hover_antialias', 'selected_hover_area', 'selected_hover_around', 'selected_hover_background', 'selected_hover_bar_invert', 'selected_hover_bar_resizing', 'selected_hover_bar_vertical', 'selected_hover_black_color', 'selected_hover_bold', 'selected_hover_bottom_bar', 'selected_hover_bottom_gutter', 'selected_hover_bottom_margin', 'selected_hover_bottom_padding', 'selected_hover_box_layout', 'selected_hover_box_reverse', 'selected_hover_box_wrap', 'selected_hover_child', 'selected_hover_clipping', 'selected_hover_color', 'selected_hover_corner1', 'selected_hover_corner2', 'selected_hover_crop', 'selected_hover_debug', 'selected_hover_delay', 'selected_hover_drop_shadow', 'selected_hover_drop_shadow_color', 'selected_hover_first_indent', 'selected_hover_first_spacing', 'selected_hover_fit_first', 'selected_hover_focus_mask', 'selected_hover_font', 'selected_hover_foreground', 'selected_hover_hyperlink_functions', 'selected_hover_italic', 'selected_hover_justify', 'selected_hover_kerning', 'selected_hover_language', 'selected_hover_layout', 'selected_hover_left_bar', 'selected_hover_left_gutter', 'selected_hover_left_margin', 'selected_hover_left_padding', 'selected_hover_line_leading', 'selected_hover_line_spacing', 'selected_hover_maximum', 'selected_hover_min_width', 'selected_hover_minimum', 'selected_hover_minwidth', 'selected_hover_mouse', 'selected_hover_newline_indent', 'selected_hover_offset', 'selected_hover_order_reverse', 'selected_hover_outlines', 'selected_hover_pos', 'selected_hover_radius', 'selected_hover_rest_indent', 'selected_hover_right_bar', 'selected_hover_right_gutter', 'selected_hover_right_margin', 'selected_hover_right_padding', 'selected_hover_rotate', 'selected_hover_rotate_pad', 'selected_hover_ruby_style', 'selected_hover_size', 'selected_hover_size_group', 'selected_hover_slow_abortable', 'selected_hover_slow_cps', 'selected_hover_slow_cps_multiplier', 'selected_hover_sound', 'selected_hover_spacing', 'selected_hover_strikethrough', 'selected_hover_subpixel', 'selected_hover_text_align', 'selected_hover_text_y_fudge', 'selected_hover_thumb', 'selected_hover_thumb_offset', 'selected_hover_thumb_shadow', 'selected_hover_top_bar', 'selected_hover_top_gutter', 'selected_hover_top_margin', 'selected_hover_top_padding', 'selected_hover_transform_anchor', 'selected_hover_underline', 'selected_hover_unscrollable', 'selected_hover_vertical', 'selected_hover_xalign', 'selected_hover_xanchor', 'selected_hover_xanchoraround', 'selected_hover_xaround', 'selected_hover_xcenter', 'selected_hover_xfill', 'selected_hover_xmargin', 'selected_hover_xmaximum', 'selected_hover_xminimum', 'selected_hover_xoffset', 'selected_hover_xpadding', 'selected_hover_xpos', 'selected_hover_xsize', 'selected_hover_xysize', 'selected_hover_xzoom', 'selected_hover_yalign', 'selected_hover_yanchor', 'selected_hover_yanchoraround', 'selected_hover_yaround', 'selected_hover_ycenter', 'selected_hover_yfill', 'selected_hover_ymargin', 'selected_hover_ymaximum', 'selected_hover_yminimum', 'selected_hover_yoffset', 'selected_hover_ypadding', 'selected_hover_ypos', 'selected_hover_ysize', 'selected_hover_yzoom', 'selected_hover_zoom', 'selected_hyperlink_functions', 'selected_idle', 'selected_idle_additive', 'selected_idle_align', 'selected_idle_alignaround', 'selected_idle_alpha', 'selected_idle_anchor', 'selected_idle_angle', 'selected_idle_antialias', 'selected_idle_area', 'selected_idle_around', 'selected_idle_background', 'selected_idle_bar_invert', 'selected_idle_bar_resizing', 'selected_idle_bar_vertical', 'selected_idle_black_color', 'selected_idle_bold', 'selected_idle_bottom_bar', 'selected_idle_bottom_gutter', 'selected_idle_bottom_margin', 'selected_idle_bottom_padding', 'selected_idle_box_layout', 'selected_idle_box_reverse', 'selected_idle_box_wrap', 'selected_idle_child', 'selected_idle_clipping', 'selected_idle_color', 'selected_idle_corner1', 'selected_idle_corner2', 'selected_idle_crop', 'selected_idle_debug', 'selected_idle_delay', 'selected_idle_drop_shadow', 'selected_idle_drop_shadow_color', 'selected_idle_first_indent', 'selected_idle_first_spacing', 'selected_idle_fit_first', 'selected_idle_focus_mask', 'selected_idle_font', 'selected_idle_foreground', 'selected_idle_hyperlink_functions', 'selected_idle_italic', 'selected_idle_justify', 'selected_idle_kerning', 'selected_idle_language', 'selected_idle_layout', 'selected_idle_left_bar', 'selected_idle_left_gutter', 'selected_idle_left_margin', 'selected_idle_left_padding', 'selected_idle_line_leading', 'selected_idle_line_spacing', 'selected_idle_maximum', 'selected_idle_min_width', 'selected_idle_minimum', 'selected_idle_minwidth', 'selected_idle_mouse', 'selected_idle_newline_indent', 'selected_idle_offset', 'selected_idle_order_reverse', 'selected_idle_outlines', 'selected_idle_pos', 'selected_idle_radius', 'selected_idle_rest_indent', 'selected_idle_right_bar', 'selected_idle_right_gutter', 'selected_idle_right_margin', 'selected_idle_right_padding', 'selected_idle_rotate', 'selected_idle_rotate_pad', 'selected_idle_ruby_style', 'selected_idle_size', 'selected_idle_size_group', 'selected_idle_slow_abortable', 'selected_idle_slow_cps', 'selected_idle_slow_cps_multiplier', 'selected_idle_sound', 'selected_idle_spacing', 'selected_idle_strikethrough', 'selected_idle_subpixel', 'selected_idle_text_align', 'selected_idle_text_y_fudge', 'selected_idle_thumb', 'selected_idle_thumb_offset', 'selected_idle_thumb_shadow', 'selected_idle_top_bar', 'selected_idle_top_gutter', 'selected_idle_top_margin', 'selected_idle_top_padding', 'selected_idle_transform_anchor', 'selected_idle_underline', 'selected_idle_unscrollable', 'selected_idle_vertical', 'selected_idle_xalign', 'selected_idle_xanchor', 'selected_idle_xanchoraround', 'selected_idle_xaround', 'selected_idle_xcenter', 'selected_idle_xfill', 'selected_idle_xmargin', 'selected_idle_xmaximum', 'selected_idle_xminimum', 'selected_idle_xoffset', 'selected_idle_xpadding', 'selected_idle_xpos', 'selected_idle_xsize', 'selected_idle_xysize', 'selected_idle_xzoom', 'selected_idle_yalign', 'selected_idle_yanchor', 'selected_idle_yanchoraround', 'selected_idle_yaround', 'selected_idle_ycenter', 'selected_idle_yfill', 'selected_idle_ymargin', 'selected_idle_ymaximum', 'selected_idle_yminimum', 'selected_idle_yoffset', 'selected_idle_ypadding', 'selected_idle_ypos', 'selected_idle_ysize', 'selected_idle_yzoom', 'selected_idle_zoom', 'selected_insensitive', 'selected_insensitive_additive', 'selected_insensitive_align', 'selected_insensitive_alignaround', 'selected_insensitive_alpha', 'selected_insensitive_anchor', 'selected_insensitive_angle', 'selected_insensitive_antialias', 'selected_insensitive_area', 'selected_insensitive_around', 'selected_insensitive_background', 'selected_insensitive_bar_invert', 'selected_insensitive_bar_resizing', 'selected_insensitive_bar_vertical', 'selected_insensitive_black_color', 'selected_insensitive_bold', 'selected_insensitive_bottom_bar', 'selected_insensitive_bottom_gutter', 'selected_insensitive_bottom_margin', 'selected_insensitive_bottom_padding', 'selected_insensitive_box_layout', 'selected_insensitive_box_reverse', 'selected_insensitive_box_wrap', 'selected_insensitive_child', 'selected_insensitive_clipping', 'selected_insensitive_color', 'selected_insensitive_corner1', 'selected_insensitive_corner2', 'selected_insensitive_crop', 'selected_insensitive_debug', 'selected_insensitive_delay', 'selected_insensitive_drop_shadow', 'selected_insensitive_drop_shadow_color', 'selected_insensitive_first_indent', 'selected_insensitive_first_spacing', 'selected_insensitive_fit_first', 'selected_insensitive_focus_mask', 'selected_insensitive_font', 'selected_insensitive_foreground', 'selected_insensitive_hyperlink_functions', 'selected_insensitive_italic', 'selected_insensitive_justify', 'selected_insensitive_kerning', 'selected_insensitive_language', 'selected_insensitive_layout', 'selected_insensitive_left_bar', 'selected_insensitive_left_gutter', 'selected_insensitive_left_margin', 'selected_insensitive_left_padding', 'selected_insensitive_line_leading', 'selected_insensitive_line_spacing', 'selected_insensitive_maximum', 'selected_insensitive_min_width', 'selected_insensitive_minimum', 'selected_insensitive_minwidth', 'selected_insensitive_mouse', 'selected_insensitive_newline_indent', 'selected_insensitive_offset', 'selected_insensitive_order_reverse', 'selected_insensitive_outlines', 'selected_insensitive_pos', 'selected_insensitive_radius', 'selected_insensitive_rest_indent', 'selected_insensitive_right_bar', 'selected_insensitive_right_gutter', 'selected_insensitive_right_margin', 'selected_insensitive_right_padding', 'selected_insensitive_rotate', 'selected_insensitive_rotate_pad', 'selected_insensitive_ruby_style', 'selected_insensitive_size', 'selected_insensitive_size_group', 'selected_insensitive_slow_abortable', 'selected_insensitive_slow_cps', 'selected_insensitive_slow_cps_multiplier', 'selected_insensitive_sound', 'selected_insensitive_spacing', 'selected_insensitive_strikethrough', 'selected_insensitive_subpixel', 'selected_insensitive_text_align', 'selected_insensitive_text_y_fudge', 'selected_insensitive_thumb', 'selected_insensitive_thumb_offset', 'selected_insensitive_thumb_shadow', 'selected_insensitive_top_bar', 'selected_insensitive_top_gutter', 'selected_insensitive_top_margin', 'selected_insensitive_top_padding', 'selected_insensitive_transform_anchor', 'selected_insensitive_underline', 'selected_insensitive_unscrollable', 'selected_insensitive_vertical', 'selected_insensitive_xalign', 'selected_insensitive_xanchor', 'selected_insensitive_xanchoraround', 'selected_insensitive_xaround', 'selected_insensitive_xcenter', 'selected_insensitive_xfill', 'selected_insensitive_xmargin', 'selected_insensitive_xmaximum', 'selected_insensitive_xminimum', 'selected_insensitive_xoffset', 'selected_insensitive_xpadding', 'selected_insensitive_xpos', 'selected_insensitive_xsize', 'selected_insensitive_xysize', 'selected_insensitive_xzoom', 'selected_insensitive_yalign', 'selected_insensitive_yanchor', 'selected_insensitive_yanchoraround', 'selected_insensitive_yaround', 'selected_insensitive_ycenter', 'selected_insensitive_yfill', 'selected_insensitive_ymargin', 'selected_insensitive_ymaximum', 'selected_insensitive_yminimum', 'selected_insensitive_yoffset', 'selected_insensitive_ypadding', 'selected_insensitive_ypos', 'selected_insensitive_ysize', 'selected_insensitive_yzoom', 'selected_insensitive_zoom', 'selected_italic', 'selected_justify', 'selected_kerning', 'selected_language', 'selected_layout', 'selected_left_bar', 'selected_left_gutter', 'selected_left_margin', 'selected_left_padding', 'selected_line_leading', 'selected_line_spacing', 'selected_maximum', 'selected_min_width', 'selected_minimum', 'selected_minwidth', 'selected_mouse', 'selected_newline_indent', 'selected_offset', 'selected_order_reverse', 'selected_outlines', 'selected_pos', 'selected_radius', 'selected_rest_indent', 'selected_right_bar', 'selected_right_gutter', 'selected_right_margin', 'selected_right_padding', 'selected_rotate', 'selected_rotate_pad', 'selected_ruby_style', 'selected_size', 'selected_size_group', 'selected_slow_abortable', 'selected_slow_cps', 'selected_slow_cps_multiplier', 'selected_sound', 'selected_spacing', 'selected_strikethrough', 'selected_subpixel', 'selected_text_align', 'selected_text_y_fudge', 'selected_thumb', 'selected_thumb_offset', 'selected_thumb_shadow', 'selected_top_bar', 'selected_top_gutter', 'selected_top_margin', 'selected_top_padding', 'selected_transform_anchor', 'selected_underline', 'selected_unscrollable', 'selected_vertical', 'selected_xalign', 'selected_xanchor', 'selected_xanchoraround', 'selected_xaround', 'selected_xcenter', 'selected_xfill', 'selected_xmargin', 'selected_xmaximum', 'selected_xminimum', 'selected_xoffset', 'selected_xpadding', 'selected_xpos', 'selected_xsize', 'selected_xysize', 'selected_xzoom', 'selected_yalign', 'selected_yanchor', 'selected_yanchoraround', 'selected_yaround', 'selected_ycenter', 'selected_yfill', 'selected_ymargin', 'selected_ymaximum', 'selected_yminimum', 'selected_yoffset', 'selected_ypadding', 'selected_ypos', 'selected_ysize', 'selected_yzoom', 'selected_zoom', 'side_activate_align', 'side_activate_anchor', 'side_activate_area', 'side_activate_clipping', 'side_activate_maximum', 'side_activate_pos', 'side_activate_spacing', 'side_activate_xalign', 'side_activate_xanchor', 'side_activate_xcenter', 'side_activate_xfill', 'side_activate_xmaximum', 'side_activate_xoffset', 'side_activate_xpos', 'side_activate_xsize', 'side_activate_xysize', 'side_activate_yalign', 'side_activate_yanchor', 'side_activate_ycenter', 'side_activate_yfill', 'side_activate_ymaximum', 'side_activate_yoffset', 'side_activate_ypos', 'side_activate_ysize', 'side_align', 'side_anchor', 'side_area', 'side_clipping', 'side_hover_align', 'side_hover_anchor', 'side_hover_area', 'side_hover_clipping', 'side_hover_maximum', 'side_hover_pos', 'side_hover_spacing', 'side_hover_xalign', 'side_hover_xanchor', 'side_hover_xcenter', 'side_hover_xfill', 'side_hover_xmaximum', 'side_hover_xoffset', 'side_hover_xpos', 'side_hover_xsize', 'side_hover_xysize', 'side_hover_yalign', 'side_hover_yanchor', 'side_hover_ycenter', 'side_hover_yfill', 'side_hover_ymaximum', 'side_hover_yoffset', 'side_hover_ypos', 'side_hover_ysize', 'side_idle_align', 'side_idle_anchor', 'side_idle_area', 'side_idle_clipping', 'side_idle_maximum', 'side_idle_pos', 'side_idle_spacing', 'side_idle_xalign', 'side_idle_xanchor', 'side_idle_xcenter', 'side_idle_xfill', 'side_idle_xmaximum', 'side_idle_xoffset', 'side_idle_xpos', 'side_idle_xsize', 'side_idle_xysize', 'side_idle_yalign', 'side_idle_yanchor', 'side_idle_ycenter', 'side_idle_yfill', 'side_idle_ymaximum', 'side_idle_yoffset', 'side_idle_ypos', 'side_idle_ysize', 'side_insensitive_align', 'side_insensitive_anchor', 'side_insensitive_area', 'side_insensitive_clipping', 'side_insensitive_maximum', 'side_insensitive_pos', 'side_insensitive_spacing', 'side_insensitive_xalign', 'side_insensitive_xanchor', 'side_insensitive_xcenter', 'side_insensitive_xfill', 'side_insensitive_xmaximum', 'side_insensitive_xoffset', 'side_insensitive_xpos', 'side_insensitive_xsize', 'side_insensitive_xysize', 'side_insensitive_yalign', 'side_insensitive_yanchor', 'side_insensitive_ycenter', 'side_insensitive_yfill', 'side_insensitive_ymaximum', 'side_insensitive_yoffset', 'side_insensitive_ypos', 'side_insensitive_ysize', 'side_maximum', 'side_pos', 'side_selected_activate_align', 'side_selected_activate_anchor', 'side_selected_activate_area', 'side_selected_activate_clipping', 'side_selected_activate_maximum', 'side_selected_activate_pos', 'side_selected_activate_spacing', 'side_selected_activate_xalign', 'side_selected_activate_xanchor', 'side_selected_activate_xcenter', 'side_selected_activate_xfill', 'side_selected_activate_xmaximum', 'side_selected_activate_xoffset', 'side_selected_activate_xpos', 'side_selected_activate_xsize', 'side_selected_activate_xysize', 'side_selected_activate_yalign', 'side_selected_activate_yanchor', 'side_selected_activate_ycenter', 'side_selected_activate_yfill', 'side_selected_activate_ymaximum', 'side_selected_activate_yoffset', 'side_selected_activate_ypos', 'side_selected_activate_ysize', 'side_selected_align', 'side_selected_anchor', 'side_selected_area', 'side_selected_clipping', 'side_selected_hover_align', 'side_selected_hover_anchor', 'side_selected_hover_area', 'side_selected_hover_clipping', 'side_selected_hover_maximum', 'side_selected_hover_pos', 'side_selected_hover_spacing', 'side_selected_hover_xalign', 'side_selected_hover_xanchor', 'side_selected_hover_xcenter', 'side_selected_hover_xfill', 'side_selected_hover_xmaximum', 'side_selected_hover_xoffset', 'side_selected_hover_xpos', 'side_selected_hover_xsize', 'side_selected_hover_xysize', 'side_selected_hover_yalign', 'side_selected_hover_yanchor', 'side_selected_hover_ycenter', 'side_selected_hover_yfill', 'side_selected_hover_ymaximum', 'side_selected_hover_yoffset', 'side_selected_hover_ypos', 'side_selected_hover_ysize', 'side_selected_idle_align', 'side_selected_idle_anchor', 'side_selected_idle_area', 'side_selected_idle_clipping', 'side_selected_idle_maximum', 'side_selected_idle_pos', 'side_selected_idle_spacing', 'side_selected_idle_xalign', 'side_selected_idle_xanchor', 'side_selected_idle_xcenter', 'side_selected_idle_xfill', 'side_selected_idle_xmaximum', 'side_selected_idle_xoffset', 'side_selected_idle_xpos', 'side_selected_idle_xsize', 'side_selected_idle_xysize', 'side_selected_idle_yalign', 'side_selected_idle_yanchor', 'side_selected_idle_ycenter', 'side_selected_idle_yfill', 'side_selected_idle_ymaximum', 'side_selected_idle_yoffset', 'side_selected_idle_ypos', 'side_selected_idle_ysize', 'side_selected_insensitive_align', 'side_selected_insensitive_anchor', 'side_selected_insensitive_area', 'side_selected_insensitive_clipping', 'side_selected_insensitive_maximum', 'side_selected_insensitive_pos', 'side_selected_insensitive_spacing', 'side_selected_insensitive_xalign', 'side_selected_insensitive_xanchor', 'side_selected_insensitive_xcenter', 'side_selected_insensitive_xfill', 'side_selected_insensitive_xmaximum', 'side_selected_insensitive_xoffset', 'side_selected_insensitive_xpos', 'side_selected_insensitive_xsize', 'side_selected_insensitive_xysize', 'side_selected_insensitive_yalign', 'side_selected_insensitive_yanchor', 'side_selected_insensitive_ycenter', 'side_selected_insensitive_yfill', 'side_selected_insensitive_ymaximum', 'side_selected_insensitive_yoffset', 'side_selected_insensitive_ypos', 'side_selected_insensitive_ysize', 'side_selected_maximum', 'side_selected_pos', 'side_selected_spacing', 'side_selected_xalign', 'side_selected_xanchor', 'side_selected_xcenter', 'side_selected_xfill', 'side_selected_xmaximum', 'side_selected_xoffset', 'side_selected_xpos', 'side_selected_xsize', 'side_selected_xysize', 'side_selected_yalign', 'side_selected_yanchor', 'side_selected_ycenter', 'side_selected_yfill', 'side_selected_ymaximum', 'side_selected_yoffset', 'side_selected_ypos', 'side_selected_ysize', 'side_spacing', 'side_xalign', 'side_xanchor', 'side_xcenter', 'side_xfill', 'side_xmaximum', 'side_xoffset', 'side_xpos', 'side_xsize', 'side_xysize', 'side_yalign', 'side_yanchor', 'side_ycenter', 'side_yfill', 'side_ymaximum', 'side_yoffset', 'side_ypos', 'side_ysize', 'size', 'size_group', 'slow', 'slow_abortable', 'slow_cps', 'slow_cps_multiplier', 'slow_done', 'sound', 'spacing', 'strikethrough', 'style_group', 'subpixel', 'substitute', 'suffix', 'text_activate_align', 'text_activate_anchor', 'text_activate_antialias', 'text_activate_area', 'text_activate_black_color', 'text_activate_bold', 'text_activate_clipping', 'text_activate_color', 'text_activate_drop_shadow', 'text_activate_drop_shadow_color', 'text_activate_first_indent', 'text_activate_font', 'text_activate_hyperlink_functions', 'text_activate_italic', 'text_activate_justify', 'text_activate_kerning', 'text_activate_language', 'text_activate_layout', 'text_activate_line_leading', 'text_activate_line_spacing', 'text_activate_maximum', 'text_activate_min_width', 'text_activate_minimum', 'text_activate_minwidth', 'text_activate_newline_indent', 'text_activate_outlines', 'text_activate_pos', 'text_activate_rest_indent', 'text_activate_ruby_style', 'text_activate_size', 'text_activate_slow_abortable', 'text_activate_slow_cps', 'text_activate_slow_cps_multiplier', 'text_activate_strikethrough', 'text_activate_text_align', 'text_activate_text_y_fudge', 'text_activate_underline', 'text_activate_vertical', 'text_activate_xalign', 'text_activate_xanchor', 'text_activate_xcenter', 'text_activate_xfill', 'text_activate_xmaximum', 'text_activate_xminimum', 'text_activate_xoffset', 'text_activate_xpos', 'text_activate_xsize', 'text_activate_xysize', 'text_activate_yalign', 'text_activate_yanchor', 'text_activate_ycenter', 'text_activate_yfill', 'text_activate_ymaximum', 'text_activate_yminimum', 'text_activate_yoffset', 'text_activate_ypos', 'text_activate_ysize', 'text_align', 'text_anchor', 'text_antialias', 'text_area', 'text_black_color', 'text_bold', 'text_clipping', 'text_color', 'text_drop_shadow', 'text_drop_shadow_color', 'text_first_indent', 'text_font', 'text_hover_align', 'text_hover_anchor', 'text_hover_antialias', 'text_hover_area', 'text_hover_black_color', 'text_hover_bold', 'text_hover_clipping', 'text_hover_color', 'text_hover_drop_shadow', 'text_hover_drop_shadow_color', 'text_hover_first_indent', 'text_hover_font', 'text_hover_hyperlink_functions', 'text_hover_italic', 'text_hover_justify', 'text_hover_kerning', 'text_hover_language', 'text_hover_layout', 'text_hover_line_leading', 'text_hover_line_spacing', 'text_hover_maximum', 'text_hover_min_width', 'text_hover_minimum', 'text_hover_minwidth', 'text_hover_newline_indent', 'text_hover_outlines', 'text_hover_pos', 'text_hover_rest_indent', 'text_hover_ruby_style', 'text_hover_size', 'text_hover_slow_abortable', 'text_hover_slow_cps', 'text_hover_slow_cps_multiplier', 'text_hover_strikethrough', 'text_hover_text_align', 'text_hover_text_y_fudge', 'text_hover_underline', 'text_hover_vertical', 'text_hover_xalign', 'text_hover_xanchor', 'text_hover_xcenter', 'text_hover_xfill', 'text_hover_xmaximum', 'text_hover_xminimum', 'text_hover_xoffset', 'text_hover_xpos', 'text_hover_xsize', 'text_hover_xysize', 'text_hover_yalign', 'text_hover_yanchor', 'text_hover_ycenter', 'text_hover_yfill', 'text_hover_ymaximum', 'text_hover_yminimum', 'text_hover_yoffset', 'text_hover_ypos', 'text_hover_ysize', 'text_hyperlink_functions', 'text_idle_align', 'text_idle_anchor', 'text_idle_antialias', 'text_idle_area', 'text_idle_black_color', 'text_idle_bold', 'text_idle_clipping', 'text_idle_color', 'text_idle_drop_shadow', 'text_idle_drop_shadow_color', 'text_idle_first_indent', 'text_idle_font', 'text_idle_hyperlink_functions', 'text_idle_italic', 'text_idle_justify', 'text_idle_kerning', 'text_idle_language', 'text_idle_layout', 'text_idle_line_leading', 'text_idle_line_spacing', 'text_idle_maximum', 'text_idle_min_width', 'text_idle_minimum', 'text_idle_minwidth', 'text_idle_newline_indent', 'text_idle_outlines', 'text_idle_pos', 'text_idle_rest_indent', 'text_idle_ruby_style', 'text_idle_size', 'text_idle_slow_abortable', 'text_idle_slow_cps', 'text_idle_slow_cps_multiplier', 'text_idle_strikethrough', 'text_idle_text_align', 'text_idle_text_y_fudge', 'text_idle_underline', 'text_idle_vertical', 'text_idle_xalign', 'text_idle_xanchor', 'text_idle_xcenter', 'text_idle_xfill', 'text_idle_xmaximum', 'text_idle_xminimum', 'text_idle_xoffset', 'text_idle_xpos', 'text_idle_xsize', 'text_idle_xysize', 'text_idle_yalign', 'text_idle_yanchor', 'text_idle_ycenter', 'text_idle_yfill', 'text_idle_ymaximum', 'text_idle_yminimum', 'text_idle_yoffset', 'text_idle_ypos', 'text_idle_ysize', 'text_insensitive_align', 'text_insensitive_anchor', 'text_insensitive_antialias', 'text_insensitive_area', 'text_insensitive_black_color', 'text_insensitive_bold', 'text_insensitive_clipping', 'text_insensitive_color', 'text_insensitive_drop_shadow', 'text_insensitive_drop_shadow_color', 'text_insensitive_first_indent', 'text_insensitive_font', 'text_insensitive_hyperlink_functions', 'text_insensitive_italic', 'text_insensitive_justify', 'text_insensitive_kerning', 'text_insensitive_language', 'text_insensitive_layout', 'text_insensitive_line_leading', 'text_insensitive_line_spacing', 'text_insensitive_maximum', 'text_insensitive_min_width', 'text_insensitive_minimum', 'text_insensitive_minwidth', 'text_insensitive_newline_indent', 'text_insensitive_outlines', 'text_insensitive_pos', 'text_insensitive_rest_indent', 'text_insensitive_ruby_style', 'text_insensitive_size', 'text_insensitive_slow_abortable', 'text_insensitive_slow_cps', 'text_insensitive_slow_cps_multiplier', 'text_insensitive_strikethrough', 'text_insensitive_text_align', 'text_insensitive_text_y_fudge', 'text_insensitive_underline', 'text_insensitive_vertical', 'text_insensitive_xalign', 'text_insensitive_xanchor', 'text_insensitive_xcenter', 'text_insensitive_xfill', 'text_insensitive_xmaximum', 'text_insensitive_xminimum', 'text_insensitive_xoffset', 'text_insensitive_xpos', 'text_insensitive_xsize', 'text_insensitive_xysize', 'text_insensitive_yalign', 'text_insensitive_yanchor', 'text_insensitive_ycenter', 'text_insensitive_yfill', 'text_insensitive_ymaximum', 'text_insensitive_yminimum', 'text_insensitive_yoffset', 'text_insensitive_ypos', 'text_insensitive_ysize', 'text_italic', 'text_justify', 'text_kerning', 'text_language', 'text_layout', 'text_line_leading', 'text_line_spacing', 'text_maximum', 'text_min_width', 'text_minimum', 'text_minwidth', 'text_newline_indent', 'text_outlines', 'text_pos', 'text_rest_indent', 'text_ruby_style', 'text_selected_activate_align', 'text_selected_activate_anchor', 'text_selected_activate_antialias', 'text_selected_activate_area', 'text_selected_activate_black_color', 'text_selected_activate_bold', 'text_selected_activate_clipping', 'text_selected_activate_color', 'text_selected_activate_drop_shadow', 'text_selected_activate_drop_shadow_color', 'text_selected_activate_first_indent', 'text_selected_activate_font', 'text_selected_activate_hyperlink_functions', 'text_selected_activate_italic', 'text_selected_activate_justify', 'text_selected_activate_kerning', 'text_selected_activate_language', 'text_selected_activate_layout', 'text_selected_activate_line_leading', 'text_selected_activate_line_spacing', 'text_selected_activate_maximum', 'text_selected_activate_min_width', 'text_selected_activate_minimum', 'text_selected_activate_minwidth', 'text_selected_activate_newline_indent', 'text_selected_activate_outlines', 'text_selected_activate_pos', 'text_selected_activate_rest_indent', 'text_selected_activate_ruby_style', 'text_selected_activate_size', 'text_selected_activate_slow_abortable', 'text_selected_activate_slow_cps', 'text_selected_activate_slow_cps_multiplier', 'text_selected_activate_strikethrough', 'text_selected_activate_text_align', 'text_selected_activate_text_y_fudge', 'text_selected_activate_underline', 'text_selected_activate_vertical', 'text_selected_activate_xalign', 'text_selected_activate_xanchor', 'text_selected_activate_xcenter', 'text_selected_activate_xfill', 'text_selected_activate_xmaximum', 'text_selected_activate_xminimum', 'text_selected_activate_xoffset', 'text_selected_activate_xpos', 'text_selected_activate_xsize', 'text_selected_activate_xysize', 'text_selected_activate_yalign', 'text_selected_activate_yanchor', 'text_selected_activate_ycenter', 'text_selected_activate_yfill', 'text_selected_activate_ymaximum', 'text_selected_activate_yminimum', 'text_selected_activate_yoffset', 'text_selected_activate_ypos', 'text_selected_activate_ysize', 'text_selected_align', 'text_selected_anchor', 'text_selected_antialias', 'text_selected_area', 'text_selected_black_color', 'text_selected_bold', 'text_selected_clipping', 'text_selected_color', 'text_selected_drop_shadow', 'text_selected_drop_shadow_color', 'text_selected_first_indent', 'text_selected_font', 'text_selected_hover_align', 'text_selected_hover_anchor', 'text_selected_hover_antialias', 'text_selected_hover_area', 'text_selected_hover_black_color', 'text_selected_hover_bold', 'text_selected_hover_clipping', 'text_selected_hover_color', 'text_selected_hover_drop_shadow', 'text_selected_hover_drop_shadow_color', 'text_selected_hover_first_indent', 'text_selected_hover_font', 'text_selected_hover_hyperlink_functions', 'text_selected_hover_italic', 'text_selected_hover_justify', 'text_selected_hover_kerning', 'text_selected_hover_language', 'text_selected_hover_layout', 'text_selected_hover_line_leading', 'text_selected_hover_line_spacing', 'text_selected_hover_maximum', 'text_selected_hover_min_width', 'text_selected_hover_minimum', 'text_selected_hover_minwidth', 'text_selected_hover_newline_indent', 'text_selected_hover_outlines', 'text_selected_hover_pos', 'text_selected_hover_rest_indent', 'text_selected_hover_ruby_style', 'text_selected_hover_size', 'text_selected_hover_slow_abortable', 'text_selected_hover_slow_cps', 'text_selected_hover_slow_cps_multiplier', 'text_selected_hover_strikethrough', 'text_selected_hover_text_align', 'text_selected_hover_text_y_fudge', 'text_selected_hover_underline', 'text_selected_hover_vertical', 'text_selected_hover_xalign', 'text_selected_hover_xanchor', 'text_selected_hover_xcenter', 'text_selected_hover_xfill', 'text_selected_hover_xmaximum', 'text_selected_hover_xminimum', 'text_selected_hover_xoffset', 'text_selected_hover_xpos', 'text_selected_hover_xsize', 'text_selected_hover_xysize', 'text_selected_hover_yalign', 'text_selected_hover_yanchor', 'text_selected_hover_ycenter', 'text_selected_hover_yfill', 'text_selected_hover_ymaximum', 'text_selected_hover_yminimum', 'text_selected_hover_yoffset', 'text_selected_hover_ypos', 'text_selected_hover_ysize', 'text_selected_hyperlink_functions', 'text_selected_idle_align', 'text_selected_idle_anchor', 'text_selected_idle_antialias', 'text_selected_idle_area', 'text_selected_idle_black_color', 'text_selected_idle_bold', 'text_selected_idle_clipping', 'text_selected_idle_color', 'text_selected_idle_drop_shadow', 'text_selected_idle_drop_shadow_color', 'text_selected_idle_first_indent', 'text_selected_idle_font', 'text_selected_idle_hyperlink_functions', 'text_selected_idle_italic', 'text_selected_idle_justify', 'text_selected_idle_kerning', 'text_selected_idle_language', 'text_selected_idle_layout', 'text_selected_idle_line_leading', 'text_selected_idle_line_spacing', 'text_selected_idle_maximum', 'text_selected_idle_min_width', 'text_selected_idle_minimum', 'text_selected_idle_minwidth', 'text_selected_idle_newline_indent', 'text_selected_idle_outlines', 'text_selected_idle_pos', 'text_selected_idle_rest_indent', 'text_selected_idle_ruby_style', 'text_selected_idle_size', 'text_selected_idle_slow_abortable', 'text_selected_idle_slow_cps', 'text_selected_idle_slow_cps_multiplier', 'text_selected_idle_strikethrough', 'text_selected_idle_text_align', 'text_selected_idle_text_y_fudge', 'text_selected_idle_underline', 'text_selected_idle_vertical', 'text_selected_idle_xalign', 'text_selected_idle_xanchor', 'text_selected_idle_xcenter', 'text_selected_idle_xfill', 'text_selected_idle_xmaximum', 'text_selected_idle_xminimum', 'text_selected_idle_xoffset', 'text_selected_idle_xpos', 'text_selected_idle_xsize', 'text_selected_idle_xysize', 'text_selected_idle_yalign', 'text_selected_idle_yanchor', 'text_selected_idle_ycenter', 'text_selected_idle_yfill', 'text_selected_idle_ymaximum', 'text_selected_idle_yminimum', 'text_selected_idle_yoffset', 'text_selected_idle_ypos', 'text_selected_idle_ysize', 'text_selected_insensitive_align', 'text_selected_insensitive_anchor', 'text_selected_insensitive_antialias', 'text_selected_insensitive_area', 'text_selected_insensitive_black_color', 'text_selected_insensitive_bold', 'text_selected_insensitive_clipping', 'text_selected_insensitive_color', 'text_selected_insensitive_drop_shadow', 'text_selected_insensitive_drop_shadow_color', 'text_selected_insensitive_first_indent', 'text_selected_insensitive_font', 'text_selected_insensitive_hyperlink_functions', 'text_selected_insensitive_italic', 'text_selected_insensitive_justify', 'text_selected_insensitive_kerning', 'text_selected_insensitive_language', 'text_selected_insensitive_layout', 'text_selected_insensitive_line_leading', 'text_selected_insensitive_line_spacing', 'text_selected_insensitive_maximum', 'text_selected_insensitive_min_width', 'text_selected_insensitive_minimum', 'text_selected_insensitive_minwidth', 'text_selected_insensitive_newline_indent', 'text_selected_insensitive_outlines', 'text_selected_insensitive_pos', 'text_selected_insensitive_rest_indent', 'text_selected_insensitive_ruby_style', 'text_selected_insensitive_size', 'text_selected_insensitive_slow_abortable', 'text_selected_insensitive_slow_cps', 'text_selected_insensitive_slow_cps_multiplier', 'text_selected_insensitive_strikethrough', 'text_selected_insensitive_text_align', 'text_selected_insensitive_text_y_fudge', 'text_selected_insensitive_underline', 'text_selected_insensitive_vertical', 'text_selected_insensitive_xalign', 'text_selected_insensitive_xanchor', 'text_selected_insensitive_xcenter', 'text_selected_insensitive_xfill', 'text_selected_insensitive_xmaximum', 'text_selected_insensitive_xminimum', 'text_selected_insensitive_xoffset', 'text_selected_insensitive_xpos', 'text_selected_insensitive_xsize', 'text_selected_insensitive_xysize', 'text_selected_insensitive_yalign', 'text_selected_insensitive_yanchor', 'text_selected_insensitive_ycenter', 'text_selected_insensitive_yfill', 'text_selected_insensitive_ymaximum', 'text_selected_insensitive_yminimum', 'text_selected_insensitive_yoffset', 'text_selected_insensitive_ypos', 'text_selected_insensitive_ysize', 'text_selected_italic', 'text_selected_justify', 'text_selected_kerning', 'text_selected_language', 'text_selected_layout', 'text_selected_line_leading', 'text_selected_line_spacing', 'text_selected_maximum', 'text_selected_min_width', 'text_selected_minimum', 'text_selected_minwidth', 'text_selected_newline_indent', 'text_selected_outlines', 'text_selected_pos', 'text_selected_rest_indent', 'text_selected_ruby_style', 'text_selected_size', 'text_selected_slow_abortable', 'text_selected_slow_cps', 'text_selected_slow_cps_multiplier', 'text_selected_strikethrough', 'text_selected_text_align', 'text_selected_text_y_fudge', 'text_selected_underline', 'text_selected_vertical', 'text_selected_xalign', 'text_selected_xanchor', 'text_selected_xcenter', 'text_selected_xfill', 'text_selected_xmaximum', 'text_selected_xminimum', 'text_selected_xoffset', 'text_selected_xpos', 'text_selected_xsize', 'text_selected_xysize', 'text_selected_yalign', 'text_selected_yanchor', 'text_selected_ycenter', 'text_selected_yfill', 'text_selected_ymaximum', 'text_selected_yminimum', 'text_selected_yoffset', 'text_selected_ypos', 'text_selected_ysize', 'text_size', 'text_slow_abortable', 'text_slow_cps', 'text_slow_cps_multiplier', 'text_strikethrough', 'text_style', 'text_text_align', 'text_text_y_fudge', 'text_underline', 'text_vertical', 'text_xalign', 'text_xanchor', 'text_xcenter', 'text_xfill', 'text_xmaximum', 'text_xminimum', 'text_xoffset', 'text_xpos', 'text_xsize', 'text_xysize', 'text_y_fudge', 'text_yalign', 'text_yanchor', 'text_ycenter', 'text_yfill', 'text_ymaximum', 'text_yminimum', 'text_yoffset', 'text_ypos', 'text_ysize', 'thumb', 'thumb_offset', 'thumb_shadow', 'top_bar', 'top_gutter', 'top_margin', 'top_padding', 'transform_anchor', 'transpose', 'underline', 'unhovered', 'unscrollable', 'value', 'vertical', 'width', 'xadjustment', 'xalign', 'xanchor', 'xanchoraround', 'xaround', 'xcenter', 'xfill', 'xinitial', 'xmargin', 'xmaximum', 'xminimum', 'xoffset', 'xpadding', 'xpos', 'xsize', 'xysize', 'xzoom', 'yadjustment', 'yalign', 'yanchor', 'yanchoraround', 'yaround', 'ycenter', 'yfill', 'yinitial', 'ymargin', 'ymaximum', 'yminimum', 'yoffset', 'ypadding', 'ypos', 'ysize', 'yzoom', 'zoom']

########NEW FILE########
__FILENAME__ = renpydoc
#@PydevCodeAnalysisIgnore
from pygments.lexers.agile import PythonLexer
from pygments.token import Token, Name, Operator

import keywords

KEYWORDS = set(keywords.keywords)
PROPERTIES = set(keywords.properties)

class RenPyLexer(PythonLexer):
    name = "Ren'Py"
    aliases = [ "renpy", "rpy" ]
    filenames = [ "*.rpy", "*.rpym" ]

    def get_tokens_unprocessed(self, text):
        for index, token, value in PythonLexer.get_tokens_unprocessed(self, text):

            if value.startswith("###"):
                continue

            if token == Token.Error and value == "$":
                yield index, Token.Keyword, value

            elif token in [ Name, Operator.Word ] and value in KEYWORDS:
                yield index, Token.Keyword, value

            elif token in Name and value in PROPERTIES:
                yield index, Name.Attribute, value

            else:
                yield index, token, value

import re
import sphinx.addnodes
import docutils.nodes
import sphinx.domains

def parse_var_node(env, sig, signode):
    m = re.match(r'(\S+)(.*)', sig)

    signode += sphinx.addnodes.desc_name(m.group(1), m.group(1))
    signode += docutils.nodes.Text(m.group(2), m.group(2))

    ref = m.group(1)
    return ref


style_seen_ids = set()

def parse_style_node(env, sig, signode):
    m = re.match(r'(\S+)(.*)', sig)

    name = m.group(1)
    desc = m.group(2)
    desc = " - " + desc

    signode += sphinx.addnodes.desc_name(name, name)
    signode += docutils.nodes.Text(desc, desc)

    ref = m.group(1)

    while ref in style_seen_ids:
        print "duplicate id:", ref
        ref = ref + "_alt"

    style_seen_ids.add(ref)

    return ref


class PythonIndex(sphinx.domains.Index):
    name = "function-class-index"
    localname = "Function and Class Index"
    shortname = ""

    def generate(self, docnames=None):

        if not isinstance(self.domain, sphinx.domains.python.PythonDomain):
            return [ ], False

        entries = [ ]

        for name, (docname, kind) in self.domain.data['objects'].iteritems():

            if kind == "function" or kind == "class":
                entries.append((name, 0, docname, name, None, None, ''))

        content = { }

        for name, subtype, docname, anchor, extra, qualifier, descr in entries:
            c = name[0].upper()

            if c not in content:
                content[c] = [ ]

            content[c].append((name, subtype, docname, anchor, extra, qualifier, descr))

        for i in content.itervalues():
            i.sort()

        # self.domain.data['labels']["py-function-class-index"] = ("py-function-class-index", '', self.localname)

        return sorted(content.items()), False




class CustomIndex(sphinx.domains.Index):

    name = ""
    localname = ""
    shortname = ""
    kind = ""

    def generate(self, docnames=None):

        if not isinstance(self.domain, sphinx.domains.std.StandardDomain):
            return [ ], False

        entries = [ ]

        for (kind, name), (docname, anchor) in self.domain.data["objects"].iteritems():

            if self.kind != kind:
                continue

            if docnames is not None and docname not in docnames:
                continue

            entries.append((name, 0, docname, anchor, None, None, ''))

        content = { }

        for name, subtype, docname, anchor, extra, qualifier, descr in entries:
            c = name[0].upper()

            if c not in content:
                content[c] = [ ]

            content[c].append((name, subtype, docname, anchor, extra, qualifier, descr))

        for i in content.itervalues():
            i.sort()

        self.domain.data['labels'][self.kind + "-index"] = ("std-" + self.kind + "-index", '', self.localname)

        return sorted(content.items()), False

def add_index(app, domain, object_type, title):

    class MyIndex(CustomIndex):
        name = object_type + "-index"
        localname = title
        kind = object_type

    app.domains[domain].indices.append(MyIndex)

def setup(app):
    # app.add_description_unit('property', 'propref')
    app.add_lexer('renpy', RenPyLexer())
    app.add_object_type("var", "var", "single: %s (variable)",  parse_node=parse_var_node)
    app.add_object_type("style-property", "propref", "single: %s (style property)", parse_node=parse_style_node)
    app.add_object_type("transform-property", "tpref", "single: %s (transform property)")
    app.add_object_type("text-tag", "tt", "single: %s (text tag)")

    add_index(app, "std", "style-property", "Style Property Index")
    add_index(app, "std", "transform-property", "Transform Property Index")
    add_index(app, "std", "var", "Variable Index")

    app.domains['py'].indices.append(PythonIndex)
    # app.domains['std'].data['labels']['py-function-class-index'] = ('py-function-class-index', '', 'Function and Class Index')

########NEW FILE########
__FILENAME__ = keywords
keywords = ['$', 'add', 'and', 'animation', 'as', 'as', 'assert', 'at', 'bar', 'behind', 'block', 'break', 'button', 'call', 'choice', 'circles', 'class', 'clockwise', 'contains', 'continue', 'counterclockwise', 'def', 'define', 'del', 'elif', 'else', 'event', 'except', 'exec', 'expression', 'finally', 'fixed', 'for', 'frame', 'from', 'function', 'global', 'grid', 'has', 'hbox', 'hide', 'hotbar', 'hotspot', 'if', 'if', 'image', 'imagebutton', 'imagemap', 'import', 'in', 'in', 'init', 'input', 'is', 'jump', 'key', 'knot', 'label', 'lambda', 'menu', 'not', 'null', 'nvl', 'on', 'onlayer', 'or', 'parallel', 'pass', 'pause', 'play', 'print', 'python', 'queue', 'raise', 'repeat', 'return', 'return', 'scene', 'screen', 'set', 'show', 'side', 'stop', 'style', 'text', 'textbutton', 'time', 'timer', 'transform', 'transform', 'translate', 'try', 'use', 'vbar', 'vbox', 'viewport', 'voice', 'while', 'while', 'window', 'with', 'with', 'yield', 'zorder']
properties = ['action', 'activate_additive', 'activate_align', 'activate_alignaround', 'activate_alpha', 'activate_anchor', 'activate_angle', 'activate_antialias', 'activate_area', 'activate_around', 'activate_background', 'activate_bar_invert', 'activate_bar_resizing', 'activate_bar_vertical', 'activate_black_color', 'activate_bold', 'activate_bottom_bar', 'activate_bottom_gutter', 'activate_bottom_margin', 'activate_bottom_padding', 'activate_box_layout', 'activate_box_reverse', 'activate_box_wrap', 'activate_child', 'activate_clipping', 'activate_color', 'activate_corner1', 'activate_corner2', 'activate_crop', 'activate_debug', 'activate_delay', 'activate_drop_shadow', 'activate_drop_shadow_color', 'activate_first_indent', 'activate_first_spacing', 'activate_fit_first', 'activate_focus_mask', 'activate_font', 'activate_foreground', 'activate_hyperlink_functions', 'activate_italic', 'activate_justify', 'activate_kerning', 'activate_language', 'activate_layout', 'activate_left_bar', 'activate_left_gutter', 'activate_left_margin', 'activate_left_padding', 'activate_line_leading', 'activate_line_spacing', 'activate_maximum', 'activate_min_width', 'activate_minimum', 'activate_minwidth', 'activate_mouse', 'activate_newline_indent', 'activate_offset', 'activate_order_reverse', 'activate_outlines', 'activate_pos', 'activate_radius', 'activate_rest_indent', 'activate_right_bar', 'activate_right_gutter', 'activate_right_margin', 'activate_right_padding', 'activate_rotate', 'activate_rotate_pad', 'activate_ruby_style', 'activate_size', 'activate_size_group', 'activate_slow_abortable', 'activate_slow_cps', 'activate_slow_cps_multiplier', 'activate_sound', 'activate_spacing', 'activate_strikethrough', 'activate_subpixel', 'activate_text_align', 'activate_text_y_fudge', 'activate_thumb', 'activate_thumb_offset', 'activate_thumb_shadow', 'activate_top_bar', 'activate_top_gutter', 'activate_top_margin', 'activate_top_padding', 'activate_transform_anchor', 'activate_underline', 'activate_unscrollable', 'activate_vertical', 'activate_xalign', 'activate_xanchor', 'activate_xanchoraround', 'activate_xaround', 'activate_xcenter', 'activate_xfill', 'activate_xmargin', 'activate_xmaximum', 'activate_xminimum', 'activate_xoffset', 'activate_xpadding', 'activate_xpos', 'activate_xsize', 'activate_xysize', 'activate_xzoom', 'activate_yalign', 'activate_yanchor', 'activate_yanchoraround', 'activate_yaround', 'activate_ycenter', 'activate_yfill', 'activate_ymargin', 'activate_ymaximum', 'activate_yminimum', 'activate_yoffset', 'activate_ypadding', 'activate_ypos', 'activate_ysize', 'activate_yzoom', 'activate_zoom', 'additive', 'adjustment', 'align', 'alignaround', 'allow', 'alpha', 'alternate', 'anchor', 'angle', 'antialias', 'area', 'around', 'auto', 'background', 'bar_invert', 'bar_resizing', 'bar_vertical', 'black_color', 'bold', 'bottom_bar', 'bottom_gutter', 'bottom_margin', 'bottom_padding', 'box_layout', 'box_reverse', 'box_wrap', 'cache', 'changed', 'child', 'child_size', 'clicked', 'clipping', 'color', 'corner1', 'corner2', 'crop', 'debug', 'default', 'delay', 'drag_handle', 'drag_joined', 'drag_name', 'drag_raise', 'draggable', 'dragged', 'drop_shadow', 'drop_shadow_color', 'droppable', 'dropped', 'edgescroll', 'exclude', 'first_indent', 'first_spacing', 'fit_first', 'focus', 'focus_mask', 'font', 'foreground', 'ground', 'height', 'hover', 'hover_additive', 'hover_align', 'hover_alignaround', 'hover_alpha', 'hover_anchor', 'hover_angle', 'hover_antialias', 'hover_area', 'hover_around', 'hover_background', 'hover_bar_invert', 'hover_bar_resizing', 'hover_bar_vertical', 'hover_black_color', 'hover_bold', 'hover_bottom_bar', 'hover_bottom_gutter', 'hover_bottom_margin', 'hover_bottom_padding', 'hover_box_layout', 'hover_box_reverse', 'hover_box_wrap', 'hover_child', 'hover_clipping', 'hover_color', 'hover_corner1', 'hover_corner2', 'hover_crop', 'hover_debug', 'hover_delay', 'hover_drop_shadow', 'hover_drop_shadow_color', 'hover_first_indent', 'hover_first_spacing', 'hover_fit_first', 'hover_focus_mask', 'hover_font', 'hover_foreground', 'hover_hyperlink_functions', 'hover_italic', 'hover_justify', 'hover_kerning', 'hover_language', 'hover_layout', 'hover_left_bar', 'hover_left_gutter', 'hover_left_margin', 'hover_left_padding', 'hover_line_leading', 'hover_line_spacing', 'hover_maximum', 'hover_min_width', 'hover_minimum', 'hover_minwidth', 'hover_mouse', 'hover_newline_indent', 'hover_offset', 'hover_order_reverse', 'hover_outlines', 'hover_pos', 'hover_radius', 'hover_rest_indent', 'hover_right_bar', 'hover_right_gutter', 'hover_right_margin', 'hover_right_padding', 'hover_rotate', 'hover_rotate_pad', 'hover_ruby_style', 'hover_size', 'hover_size_group', 'hover_slow_abortable', 'hover_slow_cps', 'hover_slow_cps_multiplier', 'hover_sound', 'hover_spacing', 'hover_strikethrough', 'hover_subpixel', 'hover_text_align', 'hover_text_y_fudge', 'hover_thumb', 'hover_thumb_offset', 'hover_thumb_shadow', 'hover_top_bar', 'hover_top_gutter', 'hover_top_margin', 'hover_top_padding', 'hover_transform_anchor', 'hover_underline', 'hover_unscrollable', 'hover_vertical', 'hover_xalign', 'hover_xanchor', 'hover_xanchoraround', 'hover_xaround', 'hover_xcenter', 'hover_xfill', 'hover_xmargin', 'hover_xmaximum', 'hover_xminimum', 'hover_xoffset', 'hover_xpadding', 'hover_xpos', 'hover_xsize', 'hover_xysize', 'hover_xzoom', 'hover_yalign', 'hover_yanchor', 'hover_yanchoraround', 'hover_yaround', 'hover_ycenter', 'hover_yfill', 'hover_ymargin', 'hover_ymaximum', 'hover_yminimum', 'hover_yoffset', 'hover_ypadding', 'hover_ypos', 'hover_ysize', 'hover_yzoom', 'hover_zoom', 'hovered', 'hyperlink_functions', 'id', 'idle', 'idle_additive', 'idle_align', 'idle_alignaround', 'idle_alpha', 'idle_anchor', 'idle_angle', 'idle_antialias', 'idle_area', 'idle_around', 'idle_background', 'idle_bar_invert', 'idle_bar_resizing', 'idle_bar_vertical', 'idle_black_color', 'idle_bold', 'idle_bottom_bar', 'idle_bottom_gutter', 'idle_bottom_margin', 'idle_bottom_padding', 'idle_box_layout', 'idle_box_reverse', 'idle_box_wrap', 'idle_child', 'idle_clipping', 'idle_color', 'idle_corner1', 'idle_corner2', 'idle_crop', 'idle_debug', 'idle_delay', 'idle_drop_shadow', 'idle_drop_shadow_color', 'idle_first_indent', 'idle_first_spacing', 'idle_fit_first', 'idle_focus_mask', 'idle_font', 'idle_foreground', 'idle_hyperlink_functions', 'idle_italic', 'idle_justify', 'idle_kerning', 'idle_language', 'idle_layout', 'idle_left_bar', 'idle_left_gutter', 'idle_left_margin', 'idle_left_padding', 'idle_line_leading', 'idle_line_spacing', 'idle_maximum', 'idle_min_width', 'idle_minimum', 'idle_minwidth', 'idle_mouse', 'idle_newline_indent', 'idle_offset', 'idle_order_reverse', 'idle_outlines', 'idle_pos', 'idle_radius', 'idle_rest_indent', 'idle_right_bar', 'idle_right_gutter', 'idle_right_margin', 'idle_right_padding', 'idle_rotate', 'idle_rotate_pad', 'idle_ruby_style', 'idle_size', 'idle_size_group', 'idle_slow_abortable', 'idle_slow_cps', 'idle_slow_cps_multiplier', 'idle_sound', 'idle_spacing', 'idle_strikethrough', 'idle_subpixel', 'idle_text_align', 'idle_text_y_fudge', 'idle_thumb', 'idle_thumb_offset', 'idle_thumb_shadow', 'idle_top_bar', 'idle_top_gutter', 'idle_top_margin', 'idle_top_padding', 'idle_transform_anchor', 'idle_underline', 'idle_unscrollable', 'idle_vertical', 'idle_xalign', 'idle_xanchor', 'idle_xanchoraround', 'idle_xaround', 'idle_xcenter', 'idle_xfill', 'idle_xmargin', 'idle_xmaximum', 'idle_xminimum', 'idle_xoffset', 'idle_xpadding', 'idle_xpos', 'idle_xsize', 'idle_xysize', 'idle_xzoom', 'idle_yalign', 'idle_yanchor', 'idle_yanchoraround', 'idle_yaround', 'idle_ycenter', 'idle_yfill', 'idle_ymargin', 'idle_ymaximum', 'idle_yminimum', 'idle_yoffset', 'idle_ypadding', 'idle_ypos', 'idle_ysize', 'idle_yzoom', 'idle_zoom', 'image_style', 'insensitive', 'insensitive_additive', 'insensitive_align', 'insensitive_alignaround', 'insensitive_alpha', 'insensitive_anchor', 'insensitive_angle', 'insensitive_antialias', 'insensitive_area', 'insensitive_around', 'insensitive_background', 'insensitive_bar_invert', 'insensitive_bar_resizing', 'insensitive_bar_vertical', 'insensitive_black_color', 'insensitive_bold', 'insensitive_bottom_bar', 'insensitive_bottom_gutter', 'insensitive_bottom_margin', 'insensitive_bottom_padding', 'insensitive_box_layout', 'insensitive_box_reverse', 'insensitive_box_wrap', 'insensitive_child', 'insensitive_clipping', 'insensitive_color', 'insensitive_corner1', 'insensitive_corner2', 'insensitive_crop', 'insensitive_debug', 'insensitive_delay', 'insensitive_drop_shadow', 'insensitive_drop_shadow_color', 'insensitive_first_indent', 'insensitive_first_spacing', 'insensitive_fit_first', 'insensitive_focus_mask', 'insensitive_font', 'insensitive_foreground', 'insensitive_hyperlink_functions', 'insensitive_italic', 'insensitive_justify', 'insensitive_kerning', 'insensitive_language', 'insensitive_layout', 'insensitive_left_bar', 'insensitive_left_gutter', 'insensitive_left_margin', 'insensitive_left_padding', 'insensitive_line_leading', 'insensitive_line_spacing', 'insensitive_maximum', 'insensitive_min_width', 'insensitive_minimum', 'insensitive_minwidth', 'insensitive_mouse', 'insensitive_newline_indent', 'insensitive_offset', 'insensitive_order_reverse', 'insensitive_outlines', 'insensitive_pos', 'insensitive_radius', 'insensitive_rest_indent', 'insensitive_right_bar', 'insensitive_right_gutter', 'insensitive_right_margin', 'insensitive_right_padding', 'insensitive_rotate', 'insensitive_rotate_pad', 'insensitive_ruby_style', 'insensitive_size', 'insensitive_size_group', 'insensitive_slow_abortable', 'insensitive_slow_cps', 'insensitive_slow_cps_multiplier', 'insensitive_sound', 'insensitive_spacing', 'insensitive_strikethrough', 'insensitive_subpixel', 'insensitive_text_align', 'insensitive_text_y_fudge', 'insensitive_thumb', 'insensitive_thumb_offset', 'insensitive_thumb_shadow', 'insensitive_top_bar', 'insensitive_top_gutter', 'insensitive_top_margin', 'insensitive_top_padding', 'insensitive_transform_anchor', 'insensitive_underline', 'insensitive_unscrollable', 'insensitive_vertical', 'insensitive_xalign', 'insensitive_xanchor', 'insensitive_xanchoraround', 'insensitive_xaround', 'insensitive_xcenter', 'insensitive_xfill', 'insensitive_xmargin', 'insensitive_xmaximum', 'insensitive_xminimum', 'insensitive_xoffset', 'insensitive_xpadding', 'insensitive_xpos', 'insensitive_xsize', 'insensitive_xysize', 'insensitive_xzoom', 'insensitive_yalign', 'insensitive_yanchor', 'insensitive_yanchoraround', 'insensitive_yaround', 'insensitive_ycenter', 'insensitive_yfill', 'insensitive_ymargin', 'insensitive_ymaximum', 'insensitive_yminimum', 'insensitive_yoffset', 'insensitive_ypadding', 'insensitive_ypos', 'insensitive_ysize', 'insensitive_yzoom', 'insensitive_zoom', 'italic', 'justify', 'kerning', 'language', 'layout', 'left_bar', 'left_gutter', 'left_margin', 'left_padding', 'length', 'line_leading', 'line_spacing', 'maximum', 'min_width', 'minimum', 'minwidth', 'mouse', 'mousewheel', 'newline_indent', 'offset', 'order_reverse', 'outlines', 'pixel_width', 'pos', 'prefix', 'radius', 'range', 'rest_indent', 'right_bar', 'right_gutter', 'right_margin', 'right_padding', 'rotate', 'rotate_pad', 'ruby_style', 'scope', 'scrollbars', 'selected_activate_additive', 'selected_activate_align', 'selected_activate_alignaround', 'selected_activate_alpha', 'selected_activate_anchor', 'selected_activate_angle', 'selected_activate_antialias', 'selected_activate_area', 'selected_activate_around', 'selected_activate_background', 'selected_activate_bar_invert', 'selected_activate_bar_resizing', 'selected_activate_bar_vertical', 'selected_activate_black_color', 'selected_activate_bold', 'selected_activate_bottom_bar', 'selected_activate_bottom_gutter', 'selected_activate_bottom_margin', 'selected_activate_bottom_padding', 'selected_activate_box_layout', 'selected_activate_box_reverse', 'selected_activate_box_wrap', 'selected_activate_child', 'selected_activate_clipping', 'selected_activate_color', 'selected_activate_corner1', 'selected_activate_corner2', 'selected_activate_crop', 'selected_activate_debug', 'selected_activate_delay', 'selected_activate_drop_shadow', 'selected_activate_drop_shadow_color', 'selected_activate_first_indent', 'selected_activate_first_spacing', 'selected_activate_fit_first', 'selected_activate_focus_mask', 'selected_activate_font', 'selected_activate_foreground', 'selected_activate_hyperlink_functions', 'selected_activate_italic', 'selected_activate_justify', 'selected_activate_kerning', 'selected_activate_language', 'selected_activate_layout', 'selected_activate_left_bar', 'selected_activate_left_gutter', 'selected_activate_left_margin', 'selected_activate_left_padding', 'selected_activate_line_leading', 'selected_activate_line_spacing', 'selected_activate_maximum', 'selected_activate_min_width', 'selected_activate_minimum', 'selected_activate_minwidth', 'selected_activate_mouse', 'selected_activate_newline_indent', 'selected_activate_offset', 'selected_activate_order_reverse', 'selected_activate_outlines', 'selected_activate_pos', 'selected_activate_radius', 'selected_activate_rest_indent', 'selected_activate_right_bar', 'selected_activate_right_gutter', 'selected_activate_right_margin', 'selected_activate_right_padding', 'selected_activate_rotate', 'selected_activate_rotate_pad', 'selected_activate_ruby_style', 'selected_activate_size', 'selected_activate_size_group', 'selected_activate_slow_abortable', 'selected_activate_slow_cps', 'selected_activate_slow_cps_multiplier', 'selected_activate_sound', 'selected_activate_spacing', 'selected_activate_strikethrough', 'selected_activate_subpixel', 'selected_activate_text_align', 'selected_activate_text_y_fudge', 'selected_activate_thumb', 'selected_activate_thumb_offset', 'selected_activate_thumb_shadow', 'selected_activate_top_bar', 'selected_activate_top_gutter', 'selected_activate_top_margin', 'selected_activate_top_padding', 'selected_activate_transform_anchor', 'selected_activate_underline', 'selected_activate_unscrollable', 'selected_activate_vertical', 'selected_activate_xalign', 'selected_activate_xanchor', 'selected_activate_xanchoraround', 'selected_activate_xaround', 'selected_activate_xcenter', 'selected_activate_xfill', 'selected_activate_xmargin', 'selected_activate_xmaximum', 'selected_activate_xminimum', 'selected_activate_xoffset', 'selected_activate_xpadding', 'selected_activate_xpos', 'selected_activate_xsize', 'selected_activate_xysize', 'selected_activate_xzoom', 'selected_activate_yalign', 'selected_activate_yanchor', 'selected_activate_yanchoraround', 'selected_activate_yaround', 'selected_activate_ycenter', 'selected_activate_yfill', 'selected_activate_ymargin', 'selected_activate_ymaximum', 'selected_activate_yminimum', 'selected_activate_yoffset', 'selected_activate_ypadding', 'selected_activate_ypos', 'selected_activate_ysize', 'selected_activate_yzoom', 'selected_activate_zoom', 'selected_additive', 'selected_align', 'selected_alignaround', 'selected_alpha', 'selected_anchor', 'selected_angle', 'selected_antialias', 'selected_area', 'selected_around', 'selected_background', 'selected_bar_invert', 'selected_bar_resizing', 'selected_bar_vertical', 'selected_black_color', 'selected_bold', 'selected_bottom_bar', 'selected_bottom_gutter', 'selected_bottom_margin', 'selected_bottom_padding', 'selected_box_layout', 'selected_box_reverse', 'selected_box_wrap', 'selected_child', 'selected_clipping', 'selected_color', 'selected_corner1', 'selected_corner2', 'selected_crop', 'selected_debug', 'selected_delay', 'selected_drop_shadow', 'selected_drop_shadow_color', 'selected_first_indent', 'selected_first_spacing', 'selected_fit_first', 'selected_focus_mask', 'selected_font', 'selected_foreground', 'selected_hover', 'selected_hover_additive', 'selected_hover_align', 'selected_hover_alignaround', 'selected_hover_alpha', 'selected_hover_anchor', 'selected_hover_angle', 'selected_hover_antialias', 'selected_hover_area', 'selected_hover_around', 'selected_hover_background', 'selected_hover_bar_invert', 'selected_hover_bar_resizing', 'selected_hover_bar_vertical', 'selected_hover_black_color', 'selected_hover_bold', 'selected_hover_bottom_bar', 'selected_hover_bottom_gutter', 'selected_hover_bottom_margin', 'selected_hover_bottom_padding', 'selected_hover_box_layout', 'selected_hover_box_reverse', 'selected_hover_box_wrap', 'selected_hover_child', 'selected_hover_clipping', 'selected_hover_color', 'selected_hover_corner1', 'selected_hover_corner2', 'selected_hover_crop', 'selected_hover_debug', 'selected_hover_delay', 'selected_hover_drop_shadow', 'selected_hover_drop_shadow_color', 'selected_hover_first_indent', 'selected_hover_first_spacing', 'selected_hover_fit_first', 'selected_hover_focus_mask', 'selected_hover_font', 'selected_hover_foreground', 'selected_hover_hyperlink_functions', 'selected_hover_italic', 'selected_hover_justify', 'selected_hover_kerning', 'selected_hover_language', 'selected_hover_layout', 'selected_hover_left_bar', 'selected_hover_left_gutter', 'selected_hover_left_margin', 'selected_hover_left_padding', 'selected_hover_line_leading', 'selected_hover_line_spacing', 'selected_hover_maximum', 'selected_hover_min_width', 'selected_hover_minimum', 'selected_hover_minwidth', 'selected_hover_mouse', 'selected_hover_newline_indent', 'selected_hover_offset', 'selected_hover_order_reverse', 'selected_hover_outlines', 'selected_hover_pos', 'selected_hover_radius', 'selected_hover_rest_indent', 'selected_hover_right_bar', 'selected_hover_right_gutter', 'selected_hover_right_margin', 'selected_hover_right_padding', 'selected_hover_rotate', 'selected_hover_rotate_pad', 'selected_hover_ruby_style', 'selected_hover_size', 'selected_hover_size_group', 'selected_hover_slow_abortable', 'selected_hover_slow_cps', 'selected_hover_slow_cps_multiplier', 'selected_hover_sound', 'selected_hover_spacing', 'selected_hover_strikethrough', 'selected_hover_subpixel', 'selected_hover_text_align', 'selected_hover_text_y_fudge', 'selected_hover_thumb', 'selected_hover_thumb_offset', 'selected_hover_thumb_shadow', 'selected_hover_top_bar', 'selected_hover_top_gutter', 'selected_hover_top_margin', 'selected_hover_top_padding', 'selected_hover_transform_anchor', 'selected_hover_underline', 'selected_hover_unscrollable', 'selected_hover_vertical', 'selected_hover_xalign', 'selected_hover_xanchor', 'selected_hover_xanchoraround', 'selected_hover_xaround', 'selected_hover_xcenter', 'selected_hover_xfill', 'selected_hover_xmargin', 'selected_hover_xmaximum', 'selected_hover_xminimum', 'selected_hover_xoffset', 'selected_hover_xpadding', 'selected_hover_xpos', 'selected_hover_xsize', 'selected_hover_xysize', 'selected_hover_xzoom', 'selected_hover_yalign', 'selected_hover_yanchor', 'selected_hover_yanchoraround', 'selected_hover_yaround', 'selected_hover_ycenter', 'selected_hover_yfill', 'selected_hover_ymargin', 'selected_hover_ymaximum', 'selected_hover_yminimum', 'selected_hover_yoffset', 'selected_hover_ypadding', 'selected_hover_ypos', 'selected_hover_ysize', 'selected_hover_yzoom', 'selected_hover_zoom', 'selected_hyperlink_functions', 'selected_idle', 'selected_idle_additive', 'selected_idle_align', 'selected_idle_alignaround', 'selected_idle_alpha', 'selected_idle_anchor', 'selected_idle_angle', 'selected_idle_antialias', 'selected_idle_area', 'selected_idle_around', 'selected_idle_background', 'selected_idle_bar_invert', 'selected_idle_bar_resizing', 'selected_idle_bar_vertical', 'selected_idle_black_color', 'selected_idle_bold', 'selected_idle_bottom_bar', 'selected_idle_bottom_gutter', 'selected_idle_bottom_margin', 'selected_idle_bottom_padding', 'selected_idle_box_layout', 'selected_idle_box_reverse', 'selected_idle_box_wrap', 'selected_idle_child', 'selected_idle_clipping', 'selected_idle_color', 'selected_idle_corner1', 'selected_idle_corner2', 'selected_idle_crop', 'selected_idle_debug', 'selected_idle_delay', 'selected_idle_drop_shadow', 'selected_idle_drop_shadow_color', 'selected_idle_first_indent', 'selected_idle_first_spacing', 'selected_idle_fit_first', 'selected_idle_focus_mask', 'selected_idle_font', 'selected_idle_foreground', 'selected_idle_hyperlink_functions', 'selected_idle_italic', 'selected_idle_justify', 'selected_idle_kerning', 'selected_idle_language', 'selected_idle_layout', 'selected_idle_left_bar', 'selected_idle_left_gutter', 'selected_idle_left_margin', 'selected_idle_left_padding', 'selected_idle_line_leading', 'selected_idle_line_spacing', 'selected_idle_maximum', 'selected_idle_min_width', 'selected_idle_minimum', 'selected_idle_minwidth', 'selected_idle_mouse', 'selected_idle_newline_indent', 'selected_idle_offset', 'selected_idle_order_reverse', 'selected_idle_outlines', 'selected_idle_pos', 'selected_idle_radius', 'selected_idle_rest_indent', 'selected_idle_right_bar', 'selected_idle_right_gutter', 'selected_idle_right_margin', 'selected_idle_right_padding', 'selected_idle_rotate', 'selected_idle_rotate_pad', 'selected_idle_ruby_style', 'selected_idle_size', 'selected_idle_size_group', 'selected_idle_slow_abortable', 'selected_idle_slow_cps', 'selected_idle_slow_cps_multiplier', 'selected_idle_sound', 'selected_idle_spacing', 'selected_idle_strikethrough', 'selected_idle_subpixel', 'selected_idle_text_align', 'selected_idle_text_y_fudge', 'selected_idle_thumb', 'selected_idle_thumb_offset', 'selected_idle_thumb_shadow', 'selected_idle_top_bar', 'selected_idle_top_gutter', 'selected_idle_top_margin', 'selected_idle_top_padding', 'selected_idle_transform_anchor', 'selected_idle_underline', 'selected_idle_unscrollable', 'selected_idle_vertical', 'selected_idle_xalign', 'selected_idle_xanchor', 'selected_idle_xanchoraround', 'selected_idle_xaround', 'selected_idle_xcenter', 'selected_idle_xfill', 'selected_idle_xmargin', 'selected_idle_xmaximum', 'selected_idle_xminimum', 'selected_idle_xoffset', 'selected_idle_xpadding', 'selected_idle_xpos', 'selected_idle_xsize', 'selected_idle_xysize', 'selected_idle_xzoom', 'selected_idle_yalign', 'selected_idle_yanchor', 'selected_idle_yanchoraround', 'selected_idle_yaround', 'selected_idle_ycenter', 'selected_idle_yfill', 'selected_idle_ymargin', 'selected_idle_ymaximum', 'selected_idle_yminimum', 'selected_idle_yoffset', 'selected_idle_ypadding', 'selected_idle_ypos', 'selected_idle_ysize', 'selected_idle_yzoom', 'selected_idle_zoom', 'selected_insensitive', 'selected_insensitive_additive', 'selected_insensitive_align', 'selected_insensitive_alignaround', 'selected_insensitive_alpha', 'selected_insensitive_anchor', 'selected_insensitive_angle', 'selected_insensitive_antialias', 'selected_insensitive_area', 'selected_insensitive_around', 'selected_insensitive_background', 'selected_insensitive_bar_invert', 'selected_insensitive_bar_resizing', 'selected_insensitive_bar_vertical', 'selected_insensitive_black_color', 'selected_insensitive_bold', 'selected_insensitive_bottom_bar', 'selected_insensitive_bottom_gutter', 'selected_insensitive_bottom_margin', 'selected_insensitive_bottom_padding', 'selected_insensitive_box_layout', 'selected_insensitive_box_reverse', 'selected_insensitive_box_wrap', 'selected_insensitive_child', 'selected_insensitive_clipping', 'selected_insensitive_color', 'selected_insensitive_corner1', 'selected_insensitive_corner2', 'selected_insensitive_crop', 'selected_insensitive_debug', 'selected_insensitive_delay', 'selected_insensitive_drop_shadow', 'selected_insensitive_drop_shadow_color', 'selected_insensitive_first_indent', 'selected_insensitive_first_spacing', 'selected_insensitive_fit_first', 'selected_insensitive_focus_mask', 'selected_insensitive_font', 'selected_insensitive_foreground', 'selected_insensitive_hyperlink_functions', 'selected_insensitive_italic', 'selected_insensitive_justify', 'selected_insensitive_kerning', 'selected_insensitive_language', 'selected_insensitive_layout', 'selected_insensitive_left_bar', 'selected_insensitive_left_gutter', 'selected_insensitive_left_margin', 'selected_insensitive_left_padding', 'selected_insensitive_line_leading', 'selected_insensitive_line_spacing', 'selected_insensitive_maximum', 'selected_insensitive_min_width', 'selected_insensitive_minimum', 'selected_insensitive_minwidth', 'selected_insensitive_mouse', 'selected_insensitive_newline_indent', 'selected_insensitive_offset', 'selected_insensitive_order_reverse', 'selected_insensitive_outlines', 'selected_insensitive_pos', 'selected_insensitive_radius', 'selected_insensitive_rest_indent', 'selected_insensitive_right_bar', 'selected_insensitive_right_gutter', 'selected_insensitive_right_margin', 'selected_insensitive_right_padding', 'selected_insensitive_rotate', 'selected_insensitive_rotate_pad', 'selected_insensitive_ruby_style', 'selected_insensitive_size', 'selected_insensitive_size_group', 'selected_insensitive_slow_abortable', 'selected_insensitive_slow_cps', 'selected_insensitive_slow_cps_multiplier', 'selected_insensitive_sound', 'selected_insensitive_spacing', 'selected_insensitive_strikethrough', 'selected_insensitive_subpixel', 'selected_insensitive_text_align', 'selected_insensitive_text_y_fudge', 'selected_insensitive_thumb', 'selected_insensitive_thumb_offset', 'selected_insensitive_thumb_shadow', 'selected_insensitive_top_bar', 'selected_insensitive_top_gutter', 'selected_insensitive_top_margin', 'selected_insensitive_top_padding', 'selected_insensitive_transform_anchor', 'selected_insensitive_underline', 'selected_insensitive_unscrollable', 'selected_insensitive_vertical', 'selected_insensitive_xalign', 'selected_insensitive_xanchor', 'selected_insensitive_xanchoraround', 'selected_insensitive_xaround', 'selected_insensitive_xcenter', 'selected_insensitive_xfill', 'selected_insensitive_xmargin', 'selected_insensitive_xmaximum', 'selected_insensitive_xminimum', 'selected_insensitive_xoffset', 'selected_insensitive_xpadding', 'selected_insensitive_xpos', 'selected_insensitive_xsize', 'selected_insensitive_xysize', 'selected_insensitive_xzoom', 'selected_insensitive_yalign', 'selected_insensitive_yanchor', 'selected_insensitive_yanchoraround', 'selected_insensitive_yaround', 'selected_insensitive_ycenter', 'selected_insensitive_yfill', 'selected_insensitive_ymargin', 'selected_insensitive_ymaximum', 'selected_insensitive_yminimum', 'selected_insensitive_yoffset', 'selected_insensitive_ypadding', 'selected_insensitive_ypos', 'selected_insensitive_ysize', 'selected_insensitive_yzoom', 'selected_insensitive_zoom', 'selected_italic', 'selected_justify', 'selected_kerning', 'selected_language', 'selected_layout', 'selected_left_bar', 'selected_left_gutter', 'selected_left_margin', 'selected_left_padding', 'selected_line_leading', 'selected_line_spacing', 'selected_maximum', 'selected_min_width', 'selected_minimum', 'selected_minwidth', 'selected_mouse', 'selected_newline_indent', 'selected_offset', 'selected_order_reverse', 'selected_outlines', 'selected_pos', 'selected_radius', 'selected_rest_indent', 'selected_right_bar', 'selected_right_gutter', 'selected_right_margin', 'selected_right_padding', 'selected_rotate', 'selected_rotate_pad', 'selected_ruby_style', 'selected_size', 'selected_size_group', 'selected_slow_abortable', 'selected_slow_cps', 'selected_slow_cps_multiplier', 'selected_sound', 'selected_spacing', 'selected_strikethrough', 'selected_subpixel', 'selected_text_align', 'selected_text_y_fudge', 'selected_thumb', 'selected_thumb_offset', 'selected_thumb_shadow', 'selected_top_bar', 'selected_top_gutter', 'selected_top_margin', 'selected_top_padding', 'selected_transform_anchor', 'selected_underline', 'selected_unscrollable', 'selected_vertical', 'selected_xalign', 'selected_xanchor', 'selected_xanchoraround', 'selected_xaround', 'selected_xcenter', 'selected_xfill', 'selected_xmargin', 'selected_xmaximum', 'selected_xminimum', 'selected_xoffset', 'selected_xpadding', 'selected_xpos', 'selected_xsize', 'selected_xysize', 'selected_xzoom', 'selected_yalign', 'selected_yanchor', 'selected_yanchoraround', 'selected_yaround', 'selected_ycenter', 'selected_yfill', 'selected_ymargin', 'selected_ymaximum', 'selected_yminimum', 'selected_yoffset', 'selected_ypadding', 'selected_ypos', 'selected_ysize', 'selected_yzoom', 'selected_zoom', 'side_activate_align', 'side_activate_anchor', 'side_activate_area', 'side_activate_clipping', 'side_activate_maximum', 'side_activate_pos', 'side_activate_spacing', 'side_activate_xalign', 'side_activate_xanchor', 'side_activate_xcenter', 'side_activate_xfill', 'side_activate_xmaximum', 'side_activate_xoffset', 'side_activate_xpos', 'side_activate_xsize', 'side_activate_xysize', 'side_activate_yalign', 'side_activate_yanchor', 'side_activate_ycenter', 'side_activate_yfill', 'side_activate_ymaximum', 'side_activate_yoffset', 'side_activate_ypos', 'side_activate_ysize', 'side_align', 'side_anchor', 'side_area', 'side_clipping', 'side_hover_align', 'side_hover_anchor', 'side_hover_area', 'side_hover_clipping', 'side_hover_maximum', 'side_hover_pos', 'side_hover_spacing', 'side_hover_xalign', 'side_hover_xanchor', 'side_hover_xcenter', 'side_hover_xfill', 'side_hover_xmaximum', 'side_hover_xoffset', 'side_hover_xpos', 'side_hover_xsize', 'side_hover_xysize', 'side_hover_yalign', 'side_hover_yanchor', 'side_hover_ycenter', 'side_hover_yfill', 'side_hover_ymaximum', 'side_hover_yoffset', 'side_hover_ypos', 'side_hover_ysize', 'side_idle_align', 'side_idle_anchor', 'side_idle_area', 'side_idle_clipping', 'side_idle_maximum', 'side_idle_pos', 'side_idle_spacing', 'side_idle_xalign', 'side_idle_xanchor', 'side_idle_xcenter', 'side_idle_xfill', 'side_idle_xmaximum', 'side_idle_xoffset', 'side_idle_xpos', 'side_idle_xsize', 'side_idle_xysize', 'side_idle_yalign', 'side_idle_yanchor', 'side_idle_ycenter', 'side_idle_yfill', 'side_idle_ymaximum', 'side_idle_yoffset', 'side_idle_ypos', 'side_idle_ysize', 'side_insensitive_align', 'side_insensitive_anchor', 'side_insensitive_area', 'side_insensitive_clipping', 'side_insensitive_maximum', 'side_insensitive_pos', 'side_insensitive_spacing', 'side_insensitive_xalign', 'side_insensitive_xanchor', 'side_insensitive_xcenter', 'side_insensitive_xfill', 'side_insensitive_xmaximum', 'side_insensitive_xoffset', 'side_insensitive_xpos', 'side_insensitive_xsize', 'side_insensitive_xysize', 'side_insensitive_yalign', 'side_insensitive_yanchor', 'side_insensitive_ycenter', 'side_insensitive_yfill', 'side_insensitive_ymaximum', 'side_insensitive_yoffset', 'side_insensitive_ypos', 'side_insensitive_ysize', 'side_maximum', 'side_pos', 'side_selected_activate_align', 'side_selected_activate_anchor', 'side_selected_activate_area', 'side_selected_activate_clipping', 'side_selected_activate_maximum', 'side_selected_activate_pos', 'side_selected_activate_spacing', 'side_selected_activate_xalign', 'side_selected_activate_xanchor', 'side_selected_activate_xcenter', 'side_selected_activate_xfill', 'side_selected_activate_xmaximum', 'side_selected_activate_xoffset', 'side_selected_activate_xpos', 'side_selected_activate_xsize', 'side_selected_activate_xysize', 'side_selected_activate_yalign', 'side_selected_activate_yanchor', 'side_selected_activate_ycenter', 'side_selected_activate_yfill', 'side_selected_activate_ymaximum', 'side_selected_activate_yoffset', 'side_selected_activate_ypos', 'side_selected_activate_ysize', 'side_selected_align', 'side_selected_anchor', 'side_selected_area', 'side_selected_clipping', 'side_selected_hover_align', 'side_selected_hover_anchor', 'side_selected_hover_area', 'side_selected_hover_clipping', 'side_selected_hover_maximum', 'side_selected_hover_pos', 'side_selected_hover_spacing', 'side_selected_hover_xalign', 'side_selected_hover_xanchor', 'side_selected_hover_xcenter', 'side_selected_hover_xfill', 'side_selected_hover_xmaximum', 'side_selected_hover_xoffset', 'side_selected_hover_xpos', 'side_selected_hover_xsize', 'side_selected_hover_xysize', 'side_selected_hover_yalign', 'side_selected_hover_yanchor', 'side_selected_hover_ycenter', 'side_selected_hover_yfill', 'side_selected_hover_ymaximum', 'side_selected_hover_yoffset', 'side_selected_hover_ypos', 'side_selected_hover_ysize', 'side_selected_idle_align', 'side_selected_idle_anchor', 'side_selected_idle_area', 'side_selected_idle_clipping', 'side_selected_idle_maximum', 'side_selected_idle_pos', 'side_selected_idle_spacing', 'side_selected_idle_xalign', 'side_selected_idle_xanchor', 'side_selected_idle_xcenter', 'side_selected_idle_xfill', 'side_selected_idle_xmaximum', 'side_selected_idle_xoffset', 'side_selected_idle_xpos', 'side_selected_idle_xsize', 'side_selected_idle_xysize', 'side_selected_idle_yalign', 'side_selected_idle_yanchor', 'side_selected_idle_ycenter', 'side_selected_idle_yfill', 'side_selected_idle_ymaximum', 'side_selected_idle_yoffset', 'side_selected_idle_ypos', 'side_selected_idle_ysize', 'side_selected_insensitive_align', 'side_selected_insensitive_anchor', 'side_selected_insensitive_area', 'side_selected_insensitive_clipping', 'side_selected_insensitive_maximum', 'side_selected_insensitive_pos', 'side_selected_insensitive_spacing', 'side_selected_insensitive_xalign', 'side_selected_insensitive_xanchor', 'side_selected_insensitive_xcenter', 'side_selected_insensitive_xfill', 'side_selected_insensitive_xmaximum', 'side_selected_insensitive_xoffset', 'side_selected_insensitive_xpos', 'side_selected_insensitive_xsize', 'side_selected_insensitive_xysize', 'side_selected_insensitive_yalign', 'side_selected_insensitive_yanchor', 'side_selected_insensitive_ycenter', 'side_selected_insensitive_yfill', 'side_selected_insensitive_ymaximum', 'side_selected_insensitive_yoffset', 'side_selected_insensitive_ypos', 'side_selected_insensitive_ysize', 'side_selected_maximum', 'side_selected_pos', 'side_selected_spacing', 'side_selected_xalign', 'side_selected_xanchor', 'side_selected_xcenter', 'side_selected_xfill', 'side_selected_xmaximum', 'side_selected_xoffset', 'side_selected_xpos', 'side_selected_xsize', 'side_selected_xysize', 'side_selected_yalign', 'side_selected_yanchor', 'side_selected_ycenter', 'side_selected_yfill', 'side_selected_ymaximum', 'side_selected_yoffset', 'side_selected_ypos', 'side_selected_ysize', 'side_spacing', 'side_xalign', 'side_xanchor', 'side_xcenter', 'side_xfill', 'side_xmaximum', 'side_xoffset', 'side_xpos', 'side_xsize', 'side_xysize', 'side_yalign', 'side_yanchor', 'side_ycenter', 'side_yfill', 'side_ymaximum', 'side_yoffset', 'side_ypos', 'side_ysize', 'size', 'size_group', 'slow', 'slow_abortable', 'slow_cps', 'slow_cps_multiplier', 'slow_done', 'sound', 'spacing', 'strikethrough', 'style_group', 'subpixel', 'substitute', 'suffix', 'text_activate_align', 'text_activate_anchor', 'text_activate_antialias', 'text_activate_area', 'text_activate_black_color', 'text_activate_bold', 'text_activate_clipping', 'text_activate_color', 'text_activate_drop_shadow', 'text_activate_drop_shadow_color', 'text_activate_first_indent', 'text_activate_font', 'text_activate_hyperlink_functions', 'text_activate_italic', 'text_activate_justify', 'text_activate_kerning', 'text_activate_language', 'text_activate_layout', 'text_activate_line_leading', 'text_activate_line_spacing', 'text_activate_maximum', 'text_activate_min_width', 'text_activate_minimum', 'text_activate_minwidth', 'text_activate_newline_indent', 'text_activate_outlines', 'text_activate_pos', 'text_activate_rest_indent', 'text_activate_ruby_style', 'text_activate_size', 'text_activate_slow_abortable', 'text_activate_slow_cps', 'text_activate_slow_cps_multiplier', 'text_activate_strikethrough', 'text_activate_text_align', 'text_activate_text_y_fudge', 'text_activate_underline', 'text_activate_vertical', 'text_activate_xalign', 'text_activate_xanchor', 'text_activate_xcenter', 'text_activate_xfill', 'text_activate_xmaximum', 'text_activate_xminimum', 'text_activate_xoffset', 'text_activate_xpos', 'text_activate_xsize', 'text_activate_xysize', 'text_activate_yalign', 'text_activate_yanchor', 'text_activate_ycenter', 'text_activate_yfill', 'text_activate_ymaximum', 'text_activate_yminimum', 'text_activate_yoffset', 'text_activate_ypos', 'text_activate_ysize', 'text_align', 'text_anchor', 'text_antialias', 'text_area', 'text_black_color', 'text_bold', 'text_clipping', 'text_color', 'text_drop_shadow', 'text_drop_shadow_color', 'text_first_indent', 'text_font', 'text_hover_align', 'text_hover_anchor', 'text_hover_antialias', 'text_hover_area', 'text_hover_black_color', 'text_hover_bold', 'text_hover_clipping', 'text_hover_color', 'text_hover_drop_shadow', 'text_hover_drop_shadow_color', 'text_hover_first_indent', 'text_hover_font', 'text_hover_hyperlink_functions', 'text_hover_italic', 'text_hover_justify', 'text_hover_kerning', 'text_hover_language', 'text_hover_layout', 'text_hover_line_leading', 'text_hover_line_spacing', 'text_hover_maximum', 'text_hover_min_width', 'text_hover_minimum', 'text_hover_minwidth', 'text_hover_newline_indent', 'text_hover_outlines', 'text_hover_pos', 'text_hover_rest_indent', 'text_hover_ruby_style', 'text_hover_size', 'text_hover_slow_abortable', 'text_hover_slow_cps', 'text_hover_slow_cps_multiplier', 'text_hover_strikethrough', 'text_hover_text_align', 'text_hover_text_y_fudge', 'text_hover_underline', 'text_hover_vertical', 'text_hover_xalign', 'text_hover_xanchor', 'text_hover_xcenter', 'text_hover_xfill', 'text_hover_xmaximum', 'text_hover_xminimum', 'text_hover_xoffset', 'text_hover_xpos', 'text_hover_xsize', 'text_hover_xysize', 'text_hover_yalign', 'text_hover_yanchor', 'text_hover_ycenter', 'text_hover_yfill', 'text_hover_ymaximum', 'text_hover_yminimum', 'text_hover_yoffset', 'text_hover_ypos', 'text_hover_ysize', 'text_hyperlink_functions', 'text_idle_align', 'text_idle_anchor', 'text_idle_antialias', 'text_idle_area', 'text_idle_black_color', 'text_idle_bold', 'text_idle_clipping', 'text_idle_color', 'text_idle_drop_shadow', 'text_idle_drop_shadow_color', 'text_idle_first_indent', 'text_idle_font', 'text_idle_hyperlink_functions', 'text_idle_italic', 'text_idle_justify', 'text_idle_kerning', 'text_idle_language', 'text_idle_layout', 'text_idle_line_leading', 'text_idle_line_spacing', 'text_idle_maximum', 'text_idle_min_width', 'text_idle_minimum', 'text_idle_minwidth', 'text_idle_newline_indent', 'text_idle_outlines', 'text_idle_pos', 'text_idle_rest_indent', 'text_idle_ruby_style', 'text_idle_size', 'text_idle_slow_abortable', 'text_idle_slow_cps', 'text_idle_slow_cps_multiplier', 'text_idle_strikethrough', 'text_idle_text_align', 'text_idle_text_y_fudge', 'text_idle_underline', 'text_idle_vertical', 'text_idle_xalign', 'text_idle_xanchor', 'text_idle_xcenter', 'text_idle_xfill', 'text_idle_xmaximum', 'text_idle_xminimum', 'text_idle_xoffset', 'text_idle_xpos', 'text_idle_xsize', 'text_idle_xysize', 'text_idle_yalign', 'text_idle_yanchor', 'text_idle_ycenter', 'text_idle_yfill', 'text_idle_ymaximum', 'text_idle_yminimum', 'text_idle_yoffset', 'text_idle_ypos', 'text_idle_ysize', 'text_insensitive_align', 'text_insensitive_anchor', 'text_insensitive_antialias', 'text_insensitive_area', 'text_insensitive_black_color', 'text_insensitive_bold', 'text_insensitive_clipping', 'text_insensitive_color', 'text_insensitive_drop_shadow', 'text_insensitive_drop_shadow_color', 'text_insensitive_first_indent', 'text_insensitive_font', 'text_insensitive_hyperlink_functions', 'text_insensitive_italic', 'text_insensitive_justify', 'text_insensitive_kerning', 'text_insensitive_language', 'text_insensitive_layout', 'text_insensitive_line_leading', 'text_insensitive_line_spacing', 'text_insensitive_maximum', 'text_insensitive_min_width', 'text_insensitive_minimum', 'text_insensitive_minwidth', 'text_insensitive_newline_indent', 'text_insensitive_outlines', 'text_insensitive_pos', 'text_insensitive_rest_indent', 'text_insensitive_ruby_style', 'text_insensitive_size', 'text_insensitive_slow_abortable', 'text_insensitive_slow_cps', 'text_insensitive_slow_cps_multiplier', 'text_insensitive_strikethrough', 'text_insensitive_text_align', 'text_insensitive_text_y_fudge', 'text_insensitive_underline', 'text_insensitive_vertical', 'text_insensitive_xalign', 'text_insensitive_xanchor', 'text_insensitive_xcenter', 'text_insensitive_xfill', 'text_insensitive_xmaximum', 'text_insensitive_xminimum', 'text_insensitive_xoffset', 'text_insensitive_xpos', 'text_insensitive_xsize', 'text_insensitive_xysize', 'text_insensitive_yalign', 'text_insensitive_yanchor', 'text_insensitive_ycenter', 'text_insensitive_yfill', 'text_insensitive_ymaximum', 'text_insensitive_yminimum', 'text_insensitive_yoffset', 'text_insensitive_ypos', 'text_insensitive_ysize', 'text_italic', 'text_justify', 'text_kerning', 'text_language', 'text_layout', 'text_line_leading', 'text_line_spacing', 'text_maximum', 'text_min_width', 'text_minimum', 'text_minwidth', 'text_newline_indent', 'text_outlines', 'text_pos', 'text_rest_indent', 'text_ruby_style', 'text_selected_activate_align', 'text_selected_activate_anchor', 'text_selected_activate_antialias', 'text_selected_activate_area', 'text_selected_activate_black_color', 'text_selected_activate_bold', 'text_selected_activate_clipping', 'text_selected_activate_color', 'text_selected_activate_drop_shadow', 'text_selected_activate_drop_shadow_color', 'text_selected_activate_first_indent', 'text_selected_activate_font', 'text_selected_activate_hyperlink_functions', 'text_selected_activate_italic', 'text_selected_activate_justify', 'text_selected_activate_kerning', 'text_selected_activate_language', 'text_selected_activate_layout', 'text_selected_activate_line_leading', 'text_selected_activate_line_spacing', 'text_selected_activate_maximum', 'text_selected_activate_min_width', 'text_selected_activate_minimum', 'text_selected_activate_minwidth', 'text_selected_activate_newline_indent', 'text_selected_activate_outlines', 'text_selected_activate_pos', 'text_selected_activate_rest_indent', 'text_selected_activate_ruby_style', 'text_selected_activate_size', 'text_selected_activate_slow_abortable', 'text_selected_activate_slow_cps', 'text_selected_activate_slow_cps_multiplier', 'text_selected_activate_strikethrough', 'text_selected_activate_text_align', 'text_selected_activate_text_y_fudge', 'text_selected_activate_underline', 'text_selected_activate_vertical', 'text_selected_activate_xalign', 'text_selected_activate_xanchor', 'text_selected_activate_xcenter', 'text_selected_activate_xfill', 'text_selected_activate_xmaximum', 'text_selected_activate_xminimum', 'text_selected_activate_xoffset', 'text_selected_activate_xpos', 'text_selected_activate_xsize', 'text_selected_activate_xysize', 'text_selected_activate_yalign', 'text_selected_activate_yanchor', 'text_selected_activate_ycenter', 'text_selected_activate_yfill', 'text_selected_activate_ymaximum', 'text_selected_activate_yminimum', 'text_selected_activate_yoffset', 'text_selected_activate_ypos', 'text_selected_activate_ysize', 'text_selected_align', 'text_selected_anchor', 'text_selected_antialias', 'text_selected_area', 'text_selected_black_color', 'text_selected_bold', 'text_selected_clipping', 'text_selected_color', 'text_selected_drop_shadow', 'text_selected_drop_shadow_color', 'text_selected_first_indent', 'text_selected_font', 'text_selected_hover_align', 'text_selected_hover_anchor', 'text_selected_hover_antialias', 'text_selected_hover_area', 'text_selected_hover_black_color', 'text_selected_hover_bold', 'text_selected_hover_clipping', 'text_selected_hover_color', 'text_selected_hover_drop_shadow', 'text_selected_hover_drop_shadow_color', 'text_selected_hover_first_indent', 'text_selected_hover_font', 'text_selected_hover_hyperlink_functions', 'text_selected_hover_italic', 'text_selected_hover_justify', 'text_selected_hover_kerning', 'text_selected_hover_language', 'text_selected_hover_layout', 'text_selected_hover_line_leading', 'text_selected_hover_line_spacing', 'text_selected_hover_maximum', 'text_selected_hover_min_width', 'text_selected_hover_minimum', 'text_selected_hover_minwidth', 'text_selected_hover_newline_indent', 'text_selected_hover_outlines', 'text_selected_hover_pos', 'text_selected_hover_rest_indent', 'text_selected_hover_ruby_style', 'text_selected_hover_size', 'text_selected_hover_slow_abortable', 'text_selected_hover_slow_cps', 'text_selected_hover_slow_cps_multiplier', 'text_selected_hover_strikethrough', 'text_selected_hover_text_align', 'text_selected_hover_text_y_fudge', 'text_selected_hover_underline', 'text_selected_hover_vertical', 'text_selected_hover_xalign', 'text_selected_hover_xanchor', 'text_selected_hover_xcenter', 'text_selected_hover_xfill', 'text_selected_hover_xmaximum', 'text_selected_hover_xminimum', 'text_selected_hover_xoffset', 'text_selected_hover_xpos', 'text_selected_hover_xsize', 'text_selected_hover_xysize', 'text_selected_hover_yalign', 'text_selected_hover_yanchor', 'text_selected_hover_ycenter', 'text_selected_hover_yfill', 'text_selected_hover_ymaximum', 'text_selected_hover_yminimum', 'text_selected_hover_yoffset', 'text_selected_hover_ypos', 'text_selected_hover_ysize', 'text_selected_hyperlink_functions', 'text_selected_idle_align', 'text_selected_idle_anchor', 'text_selected_idle_antialias', 'text_selected_idle_area', 'text_selected_idle_black_color', 'text_selected_idle_bold', 'text_selected_idle_clipping', 'text_selected_idle_color', 'text_selected_idle_drop_shadow', 'text_selected_idle_drop_shadow_color', 'text_selected_idle_first_indent', 'text_selected_idle_font', 'text_selected_idle_hyperlink_functions', 'text_selected_idle_italic', 'text_selected_idle_justify', 'text_selected_idle_kerning', 'text_selected_idle_language', 'text_selected_idle_layout', 'text_selected_idle_line_leading', 'text_selected_idle_line_spacing', 'text_selected_idle_maximum', 'text_selected_idle_min_width', 'text_selected_idle_minimum', 'text_selected_idle_minwidth', 'text_selected_idle_newline_indent', 'text_selected_idle_outlines', 'text_selected_idle_pos', 'text_selected_idle_rest_indent', 'text_selected_idle_ruby_style', 'text_selected_idle_size', 'text_selected_idle_slow_abortable', 'text_selected_idle_slow_cps', 'text_selected_idle_slow_cps_multiplier', 'text_selected_idle_strikethrough', 'text_selected_idle_text_align', 'text_selected_idle_text_y_fudge', 'text_selected_idle_underline', 'text_selected_idle_vertical', 'text_selected_idle_xalign', 'text_selected_idle_xanchor', 'text_selected_idle_xcenter', 'text_selected_idle_xfill', 'text_selected_idle_xmaximum', 'text_selected_idle_xminimum', 'text_selected_idle_xoffset', 'text_selected_idle_xpos', 'text_selected_idle_xsize', 'text_selected_idle_xysize', 'text_selected_idle_yalign', 'text_selected_idle_yanchor', 'text_selected_idle_ycenter', 'text_selected_idle_yfill', 'text_selected_idle_ymaximum', 'text_selected_idle_yminimum', 'text_selected_idle_yoffset', 'text_selected_idle_ypos', 'text_selected_idle_ysize', 'text_selected_insensitive_align', 'text_selected_insensitive_anchor', 'text_selected_insensitive_antialias', 'text_selected_insensitive_area', 'text_selected_insensitive_black_color', 'text_selected_insensitive_bold', 'text_selected_insensitive_clipping', 'text_selected_insensitive_color', 'text_selected_insensitive_drop_shadow', 'text_selected_insensitive_drop_shadow_color', 'text_selected_insensitive_first_indent', 'text_selected_insensitive_font', 'text_selected_insensitive_hyperlink_functions', 'text_selected_insensitive_italic', 'text_selected_insensitive_justify', 'text_selected_insensitive_kerning', 'text_selected_insensitive_language', 'text_selected_insensitive_layout', 'text_selected_insensitive_line_leading', 'text_selected_insensitive_line_spacing', 'text_selected_insensitive_maximum', 'text_selected_insensitive_min_width', 'text_selected_insensitive_minimum', 'text_selected_insensitive_minwidth', 'text_selected_insensitive_newline_indent', 'text_selected_insensitive_outlines', 'text_selected_insensitive_pos', 'text_selected_insensitive_rest_indent', 'text_selected_insensitive_ruby_style', 'text_selected_insensitive_size', 'text_selected_insensitive_slow_abortable', 'text_selected_insensitive_slow_cps', 'text_selected_insensitive_slow_cps_multiplier', 'text_selected_insensitive_strikethrough', 'text_selected_insensitive_text_align', 'text_selected_insensitive_text_y_fudge', 'text_selected_insensitive_underline', 'text_selected_insensitive_vertical', 'text_selected_insensitive_xalign', 'text_selected_insensitive_xanchor', 'text_selected_insensitive_xcenter', 'text_selected_insensitive_xfill', 'text_selected_insensitive_xmaximum', 'text_selected_insensitive_xminimum', 'text_selected_insensitive_xoffset', 'text_selected_insensitive_xpos', 'text_selected_insensitive_xsize', 'text_selected_insensitive_xysize', 'text_selected_insensitive_yalign', 'text_selected_insensitive_yanchor', 'text_selected_insensitive_ycenter', 'text_selected_insensitive_yfill', 'text_selected_insensitive_ymaximum', 'text_selected_insensitive_yminimum', 'text_selected_insensitive_yoffset', 'text_selected_insensitive_ypos', 'text_selected_insensitive_ysize', 'text_selected_italic', 'text_selected_justify', 'text_selected_kerning', 'text_selected_language', 'text_selected_layout', 'text_selected_line_leading', 'text_selected_line_spacing', 'text_selected_maximum', 'text_selected_min_width', 'text_selected_minimum', 'text_selected_minwidth', 'text_selected_newline_indent', 'text_selected_outlines', 'text_selected_pos', 'text_selected_rest_indent', 'text_selected_ruby_style', 'text_selected_size', 'text_selected_slow_abortable', 'text_selected_slow_cps', 'text_selected_slow_cps_multiplier', 'text_selected_strikethrough', 'text_selected_text_align', 'text_selected_text_y_fudge', 'text_selected_underline', 'text_selected_vertical', 'text_selected_xalign', 'text_selected_xanchor', 'text_selected_xcenter', 'text_selected_xfill', 'text_selected_xmaximum', 'text_selected_xminimum', 'text_selected_xoffset', 'text_selected_xpos', 'text_selected_xsize', 'text_selected_xysize', 'text_selected_yalign', 'text_selected_yanchor', 'text_selected_ycenter', 'text_selected_yfill', 'text_selected_ymaximum', 'text_selected_yminimum', 'text_selected_yoffset', 'text_selected_ypos', 'text_selected_ysize', 'text_size', 'text_slow_abortable', 'text_slow_cps', 'text_slow_cps_multiplier', 'text_strikethrough', 'text_style', 'text_text_align', 'text_text_y_fudge', 'text_underline', 'text_vertical', 'text_xalign', 'text_xanchor', 'text_xcenter', 'text_xfill', 'text_xmaximum', 'text_xminimum', 'text_xoffset', 'text_xpos', 'text_xsize', 'text_xysize', 'text_y_fudge', 'text_yalign', 'text_yanchor', 'text_ycenter', 'text_yfill', 'text_ymaximum', 'text_yminimum', 'text_yoffset', 'text_ypos', 'text_ysize', 'thumb', 'thumb_offset', 'thumb_shadow', 'top_bar', 'top_gutter', 'top_margin', 'top_padding', 'transform_anchor', 'transpose', 'underline', 'unhovered', 'unscrollable', 'value', 'vertical', 'width', 'xadjustment', 'xalign', 'xanchor', 'xanchoraround', 'xaround', 'xcenter', 'xfill', 'xinitial', 'xmargin', 'xmaximum', 'xminimum', 'xoffset', 'xpadding', 'xpos', 'xsize', 'xysize', 'xzoom', 'yadjustment', 'yalign', 'yanchor', 'yanchoraround', 'yaround', 'ycenter', 'yfill', 'yinitial', 'ymargin', 'ymaximum', 'yminimum', 'yoffset', 'ypadding', 'ypos', 'ysize', 'yzoom', 'zoom']

########NEW FILE########
__FILENAME__ = teststyles
#@PydevCodeAnalysisIgnore
import unittest

import renpy
renpy.import_all()
from renpy.styleaccel import Style, StyleManager, build_styles


class TestStyles(unittest.TestCase):

    def test_set_prefix(self):
        s = Style(None)

        s.bold = "insensitive"
        s.hover_bold = "hover"
        s.selected_bold = "selected"
        s.selected_hover_bold = "selected_hover"

        renpy.styleaccel.build_style(s)

        assert s.bold == "insensitive"

        s.set_prefix("hover_")
        assert s.bold == "hover"

        s.set_prefix("selected_idle_")
        assert s.bold == "selected"

        s.set_prefix("selected_hover_")
        assert s.bold == "selected_hover"

        s.set_prefix("insensitive_")
        assert s.bold == "insensitive"

    def test_inheritance(self):

        sm = StyleManager()

        sm.default = Style(None)

        assert sm.default is sm.default
        assert sm.default.name == ("default",)
        assert sm.default.parent is None

        assert sm.prefs_default is sm.prefs_default
        assert sm.prefs_default.name == ("prefs_default",)
        assert sm.prefs_default.parent == ("default",)

        assert sm.default["foo"] is sm.default["foo"]
        assert sm.default["foo"].name == ("default","foo")
        assert sm.default["foo"].parent is None

        assert sm.prefs_default["foo"] is sm.prefs_default["foo"]
        assert sm.prefs_default["foo"].name == ("prefs_default","foo")
        assert sm.prefs_default["foo"].parent == ("default","foo")

        sm.default.size = "default"
        sm.default.italic = "default"
        sm.default.bold = "default"

        sm.prefs_default.italic = "prefs_default"
        sm.prefs_default.bold = "prefs_default"

        sm.default["foo"].bold = "default_foo"

        build_styles()

        s = sm.prefs_default["foo"]

        assert s.bold == "default_foo"
        assert s.italic == "prefs_default"
        assert s.size == "default"







########NEW FILE########
