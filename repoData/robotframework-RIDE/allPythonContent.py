__FILENAME__ = logger
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Public logging API for test libraries.

This module provides a public API for writing messages to the log file
and the console. Test libraries can use this API like `logger.info('My
message')` instead of logging through the standard output like `print
'*INFO* My message'`. In addition to a programmatic interface being
cleaner to use, this API has a benefit that the log messages have
accurate timestamps.

Log levels
----------

It is possible to log messages using levels `TRACE`, `DEBUG`, `INFO`
and `WARN` either using the `write` method or, more commonly, with the
log level specific `trace`, `debug`, `info` and `warn` methods.

By default the trace and debug messages are not logged but that can be
changed with the `--loglevel` command line option. Warnings are
automatically written also to the `Test Execution Errors` section in
the log file and to the console.

Logging HTML
------------

All methods that are used for writing messages to the log file have an
optional `html` argument. If a message to be logged is supposed to be
shown as HTML, this argument should be set to `True`.

Example
-------

from robot.api import logger

def my_keyword(arg):
    logger.debug('Got argument %s' % arg)
    do_something()
    logger.info('<i>This</i> is a boring example', html=True)
"""

import sys
import threading

from robot.output import LOGGER, Message
from robot.running.timeouts import timeoutthread


LOGGING_THREADS = ('MainThread', timeoutthread.TIMEOUT_THREAD_NAME)


def write(msg, level, html=False):
    """Writes the message to the log file using the given level.

    Valid log levels are `TRACE`, `DEBUG`, `INFO` and `WARN`. Instead
    of using this method, it is generally better to use the level
    specific methods such as `info` and `debug`.
    """
    if threading.currentThread().getName() in LOGGING_THREADS:
        LOGGER.log_message(Message(msg, level, html))

def trace(msg, html=False):
    """Writes the message to the log file with the TRACE level."""
    write(msg, 'TRACE', html)

def debug(msg, html=False):
    """Writes the message to the log file with the DEBUG level."""
    write(msg, 'DEBUG', html)

def info(msg, html=False, also_console=False):
    """Writes the message to the log file with the INFO level.

    If `also_console` argument is set to `True`, the message is written
    both to the log file and to the console.
    """
    write(msg, 'INFO', html)
    if also_console:
        console(msg)

def warn(msg, html=False):
    """Writes the message to the log file with the WARN level."""
    write(msg, 'WARN', html)

def console(msg, newline=True):
    """Writes the message to the console.

    If the `newline` argument is `True`, a newline character is automatically
    added to the message.
    """
    if newline:
        msg += '\n'
    sys.__stdout__.write(msg)

########NEW FILE########
__FILENAME__ = handlers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError


class UserErrorHandler:
    """Created if creating handlers fail -- running raises DataError.

    The idea is not to raise DataError at processing time and prevent all
    tests in affected test case file from executing. Instead UserErrorHandler
    is created and if it is ever run DataError is raised then.
    """
    type = 'error'

    def __init__(self, name, error):
        self.name = self.longname = name
        self.doc = self.shortdoc = ''
        self.error = error
        self.timeout = ''

    def init_keyword(self, varz):
        pass

    def run(self, *args):
        raise DataError(self.error)

########NEW FILE########
__FILENAME__ = keyword
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class BaseKeyword:

    def __init__(self, name='', args=None, doc='', timeout='', type='kw'):
        self.name = name
        self.args = args or []
        self.doc = doc
        self.timeout = timeout
        self.type = type
        self.message = ''
        self.status = 'NOT_RUN'

    @property
    def passed(self):
        return self.status == 'PASS'

    def serialize(self, serializer):
        serializer.start_keyword(self)
        serializer.end_keyword(self)

########NEW FILE########
__FILENAME__ = libraries
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


from robot.errors import DataError


class BaseLibrary:

    def get_handler(self, name):
        try:
            return self.handlers[name]
        except KeyError:
            raise DataError("No keyword handler with name '%s' found"  % name)

    def has_handler(self, name):
        return self.handlers.has_key(name)

    def __len__(self):
        return len(self.handlers)

########NEW FILE########
__FILENAME__ = model
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import random

from robot import utils
from robot.errors import DataError

from .statistics import Stat


class _TestAndSuiteHelper:
    _longname = None

    def __init__(self, name, parent=None):
        self.name = name
        self.doc = ''
        self.parent = parent
        self.setup = None
        self.teardown = None
        self.status = 'NOT_RUN'
        self.message = ''

    def _get_longname(self, sep='.'):
        if self._longname:
            return self._longname
        names = self.parent._get_longname(sep=None) if self.parent else []
        names.append(self.name)
        return sep.join(names) if sep else names

    def _set_longname(self, name):
        self._longname = name

    # Mabot requires longname to be assignable
    longname = property(_get_longname, _set_longname)

    def _set_teardown_fail_msg(self, message):
        if self.message == '':
            self.message = message
        else:
            self.message += '\n\nAlso ' + message[0].lower() + message[1:]

    def __str__(self):
        return self.name

    def __repr__(self):
        return repr(self.name)


class BaseTestSuite(_TestAndSuiteHelper):
    """Base class for TestSuite used in runtime and by rebot."""

    def __init__(self, name, source=None, parent=None):
        _TestAndSuiteHelper.__init__(self, name, parent)
        self.source = utils.abspath(source) if source else None
        self._id = None
        self.metadata = utils.NormalizedDict()
        self.suites = []
        self.tests = []
        self.critical = _Critical()
        self.critical_stats = Stat()
        self.all_stats = Stat()
        if parent:
            parent.suites.append(self)

    def set_name(self, name):
        if name:
            self.name = name
        elif self._is_multi_source_suite():
            self.name = ' & '.join(suite.name for suite in self.suites)

    def _is_multi_source_suite(self):
        return self.parent is None and self.name == ''

    @property
    def id(self):
        if not self._id:
            self._find_root()._set_id()
        return self._id

    def _find_root(self):
        if self.parent:
            return self.parent._find_root()
        return self

    def _set_id(self):
        if not self._id:
            self._id = 's1'
        for index, suite in enumerate(self.suites):
            suite._id = '%s-s%s' % (self._id, index+1)
            suite._set_id()

    def set_critical_tags(self, critical, non_critical):
        if critical is not None or non_critical is not None:
            self.critical.set(critical, non_critical)
            self._set_critical_tags(self.critical)

    def _set_critical_tags(self, critical):
        self.critical = critical
        for suite in self.suites:
            suite._set_critical_tags(critical)
        for test in self.tests:
            test.set_criticality(critical)

    def set_doc(self, doc):
        if doc:
            self.doc = doc

    def set_metadata(self, metalist):
        for name, value in metalist:
            self.metadata[name] = value

    def get_test_count(self):
        count = len(self.tests)
        for suite in self.suites:
            count += suite.get_test_count()
        return count

    def get_full_message(self):
        """Returns suite's message including statistics message"""
        stat_msg = self.get_stat_message()
        if not self.message:
            return stat_msg
        return '%s\n\n%s' % (self.message, stat_msg)

    def get_stat_message(self):
        ctotal, cend, cpass, cfail = self._get_counts(self.critical_stats)
        atotal, aend, apass, afail = self._get_counts(self.all_stats)
        return ('%d critical test%s, %d passed, %d failed\n'
                '%d test%s total, %d passed, %d failed'
                % (ctotal, cend, cpass, cfail, atotal, aend, apass, afail))

    def _get_counts(self, stat):
        ending = utils.plural_or_not(stat.total)
        return stat.total, ending, stat.passed, stat.failed

    def set_status(self):
        """Sets status and statistics based on subsuite and test statuses.

        Can/should be used when statuses have been changed somehow.
        """
        self.status = self._set_stats()

    def _set_stats(self):
        self.critical_stats = Stat()
        self.all_stats = Stat()
        for suite in self.suites:
            suite.set_status()
            self._add_suite_to_stats(suite)
        for test in self.tests:
            self._add_test_to_stats(test)
        return self._get_status()

    def _get_status(self):
        return 'PASS' if not self.critical_stats.failed else 'FAIL'

    def _add_test_to_stats(self, test):
        self.all_stats.add_test(test)
        if test.critical:
            self.critical_stats.add_test(test)

    def _add_suite_to_stats(self, suite):
        self.critical_stats.add_stat(suite.critical_stats)
        self.all_stats.add_stat(suite.all_stats)

    def suite_teardown_failed(self, error=None, message=None):
        if error:
            message = 'Suite teardown failed:\n%s' % unicode(error)
        self._set_teardown_fail_msg(message)
        self.critical_stats.fail_all()
        self.all_stats.fail_all()
        self.status = self._get_status()
        sub_message = 'Teardown of the parent suite failed.'
        for suite in self.suites:
            suite.suite_teardown_failed(message=sub_message)
        for test in self.tests:
            test.suite_teardown_failed(sub_message)

    def set_tags(self, tags):
        if tags:
            for test in self.tests:
                test.tags = utils.normalize_tags(test.tags + tags)
            for suite in self.suites:
                suite.set_tags(tags)

    def filter(self, suites=None, tests=None, includes=None, excludes=None,
               zero_tests_ok=False):
        if suites or tests:
            self.filter_by_names(suites, tests, zero_tests_ok)
        if includes or excludes:
            self.filter_by_tags(includes, excludes, zero_tests_ok)

    def filter_by_names(self, suites=None, tests=None, zero_tests_ok=False):
        suites = [([], name.split('.')) for name in suites or []]
        tests = utils.MultiMatcher(tests, ignore=['_'], match_if_no_patterns=True)
        if not self._filter_by_names(suites, tests) and not zero_tests_ok:
            self._raise_no_tests_filtered_by_names(suites, tests)

    def _filter_by_names(self, suites, tests):
        suites = self._filter_suite_names(suites)
        self.suites = [suite for suite in self.suites
                       if suite._filter_by_names(suites, tests)]
        if not suites:
            self.tests = [test for test in self.tests
                          if tests.match(test.name) or tests.match(test.longname)]
        else:
            self.tests = []
        return bool(self.suites or self.tests)

    def _filter_suite_names(self, suites):
        try:
            return [self._filter_suite_name(p, s) for p, s in suites]
        except StopIteration:
            return []

    def _filter_suite_name(self, parent, suite):
        if utils.matches(self.name, suite[0], ignore=['_']):
            if len(suite) == 1:
                raise StopIteration('Match found')
            return (parent + [suite[0]], suite[1:])
        return ([], parent + suite)

    def _raise_no_tests_filtered_by_names(self, suites, tests):
        tests = utils.seq2str(list(tests), lastsep=' or ')
        suites = utils.seq2str(['.'.join(p + s) for p, s in suites],
                               lastsep=' or ')
        if not suites:
            msg = 'test cases named %s.' % tests
        elif not tests:
            msg = 'test suites named %s.' % suites
        else:
            msg = 'test cases %s in suites %s.' % (tests, suites)
        raise DataError("Suite '%s' contains no %s" % (self.name, msg))

    def filter_by_tags(self, includes=None, excludes=None, zero_tests_ok=False):
        includes = includes or []
        excludes = excludes or []
        if not self._filter_by_tags(includes, excludes) and not zero_tests_ok:
            self._raise_no_tests_filtered_by_tags(includes, excludes)

    def _filter_by_tags(self, incls, excls):
        self.suites = [suite for suite in self.suites
                       if suite._filter_by_tags(incls, excls)]
        self.tests = [test for test in self.tests
                      if test.is_included(incls, excls)]
        return bool(self.suites or self.tests)

    def _raise_no_tests_filtered_by_tags(self, incls, excls):
        incl = utils.seq2str(incls)
        excl = utils.seq2str(excls)
        msg = "Suite '%s' with "  % self.name
        if incl:
            msg += 'includes %s ' % incl
            if excl:
                msg += 'and '
        if excl:
            msg += 'excludes %s ' % excl
        raise DataError(msg + 'contains no test cases.')

    def set_runmode(self, runmode):
        origmode = runmode
        runmode = runmode.upper()
        if runmode == 'EXITONFAILURE':
            self._exit_on_failure_mode = True
        elif runmode == 'SKIPTEARDOWNONEXIT':
            self._skip_teardowns_on_exit_mode = True
        elif runmode == 'DRYRUN':
            self._dry_run_mode = True
        elif runmode == 'RANDOM:TEST':
            random.shuffle(self.tests)
        elif runmode == 'RANDOM:SUITE':
            random.shuffle(self.suites)
        elif runmode == 'RANDOM:ALL':
            random.shuffle(self.suites)
            random.shuffle(self.tests)
        else:
            from robot.output import LOGGER  # avoid recursive import
            LOGGER.warn("Option '--runmode' does not support value '%s'." % origmode)
            return
        for suite in self.suites:
            suite.set_runmode(runmode)

    def set_options(self, settings):
        self.set_tags(settings['SetTag'])
        self.filter(settings['SuiteNames'], settings['TestNames'],
                    settings['Include'], settings['Exclude'],
                    settings['RunEmptySuite'])
        self.set_name(settings['Name'])
        self.set_doc(settings['Doc'])
        self.set_metadata(settings['Metadata'])
        self.set_critical_tags(settings['Critical'], settings['NonCritical'])
        self._return_status_rc = not settings['NoStatusRC']
        if 'RunMode' in settings:
            map(self.set_runmode, settings['RunMode'])

    def serialize(self, serializer):
        serializer.start_suite(self)
        if self.setup is not None:
            self.setup.serialize(serializer)
        if self.teardown is not None:
            self.teardown.serialize(serializer)
        for suite in self.suites:
            suite.serialize(serializer)
        for test in self.tests:
            test.serialize(serializer)
        serializer.end_suite(self)

    @property
    def return_code(self):
        rc = min(self.critical_stats.failed, 250)
        return rc if self._return_status_rc else 0


class BaseTestCase(_TestAndSuiteHelper):

    def __init__(self, name, parent):
        _TestAndSuiteHelper.__init__(self, name, parent)
        self.critical = True
        if parent:
            parent.tests.append(self)

    @property
    def id(self):
        if not self.parent:
            return 't1'
        return '%s-t%d' % (self.parent.id, self.parent.tests.index(self)+1)

    @property
    def passed(self):
        return self.status == 'PASS'

    def suite_teardown_failed(self, message):
        self.status = 'FAIL'
        self._set_teardown_fail_msg(message)

    def set_criticality(self, critical):
        self.critical = critical.are_critical(self.tags)

    def is_included(self, incl_tags, excl_tags):
        """Returns True if this test case is included but not excluded.

        If no 'incl_tags' are given all tests are considered to be included.
        """
        included = not incl_tags or self._matches_any_tag_rule(incl_tags)
        excluded = self._matches_any_tag_rule(excl_tags)
        return included and not excluded

    def _matches_any_tag_rule(self, tag_rules):
        """Returns True if any of tag_rules matches self.tags

        Matching equals supporting AND, & and NOT boolean operators and simple
        pattern matching. NOT is 'or' operation meaning if any of the NOTs is
        matching, False is returned.
        """
        return any(self._matches_tag_rule(rule) for rule in tag_rules)

    def _matches_tag_rule(self, tag_rule):
        if 'NOT' not in tag_rule:
            return self._matches_tag(tag_rule)
        nots = tag_rule.split('NOT')
        should_match = nots.pop(0)
        return self._matches_tag(should_match) \
            and not any(self._matches_tag(n) for n in nots)

    def _matches_tag(self, tag):
        """Returns True if given tag matches any tag from self.tags.

        Note that given tag may be ANDed combination of multiple tags (e.g.
        tag1&tag2) and then all of them must match some tag from self.tags.
        """
        for item in tag.split('&'):
            if not any(utils.matches(t, item, ignore=['_']) for t in self.tags):
                return False
        return True

    def __cmp__(self, other):
        if self.status != other.status:
            return -1 if not self.passed else 1
        if self.critical != other.critical:
            return -1 if self.critical else 1
        try:
            return cmp(self.longname, other.longname)
        except AttributeError:
            return cmp(self.name, other.name)

    def serialize(self, serializer):
        serializer.start_test(self)
        if self.setup is not None:
            self.setup.serialize(serializer)
        for kw in self.keywords:
            kw.serialize(serializer)
        if self.teardown is not None:
            self.teardown.serialize(serializer)
        serializer.end_test(self)


class _Critical:

    def __init__(self, tags=None, nons=None):
        self.set(tags, nons)

    def set(self, tags, nons):
        self.tags = self._get_tags(tags)
        self.nons = self._get_tags(nons)

    def _get_tags(self, tags):
        if isinstance(tags, utils.MultiMatcher):
            return tags
        return utils.MultiMatcher(utils.normalize_tags(tags or []), ignore=['_'])

    def is_critical(self, tag):
        return self.tags.match(tag)

    def is_non_critical(self, tag):
        return self.nons.match(tag)

    def are_critical(self, tags):
        for tag in tags:
            if self.is_non_critical(tag):
                return False
        for tag in tags:
            if self.is_critical(tag):
                return True
        return not self.tags

    def __nonzero__(self):
        return bool(self.tags or self.nons)

########NEW FILE########
__FILENAME__ = statistics
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robot.model.tags import TagPatterns
from robot.utils import Matcher, MultiMatcher, NormalizedDict, normalize


class Statistics:

    def __init__(self, suite, suite_stat_level=-1, tag_stat_include=None,
                 tag_stat_exclude=None, tag_stat_combine=None, tag_doc=None,
                 tag_stat_link=None):
        self.tags = TagStatistics(tag_stat_include, tag_stat_exclude,
                                  tag_stat_combine, tag_doc, tag_stat_link)
        self.suite = SuiteStatistics(suite, self.tags, suite_stat_level)
        self.total = TotalStatistics(self.suite)
        self.tags.sort()

    def serialize(self, serializer):
        serializer.start_statistics(self)
        self.total.serialize(serializer)
        self.tags.serialize(serializer)
        self.suite.serialize(serializer)
        serializer.end_statistics(self)


class Stat:

    def __init__(self, name=''):
        self.name = name
        self._norm_name = normalize(name, ignore='_')
        self.passed = 0
        self.failed = 0

    @property
    def total(self):
        return self.passed + self.failed

    def add_stat(self, other):
        self.passed += other.passed
        self.failed += other.failed

    def add_test(self, test):
        if test.passed:
            self.passed += 1
        else:
            self.failed += 1

    def fail_all(self):
        self.failed += self.passed
        self.passed = 0

    def add_suite(self, suite):
        for test in suite.tests:
            if self._is_included(test):
                self.add_test(test)
        for suite in suite.suites:
            self.add_stat(self._subsuite_stats(suite))

    def _is_included(self, test):
        return True

    def _subsuite_stats(self, suite):
        return suite.all_stats

    def __cmp__(self, other):
        return cmp(self._norm_name, other._norm_name)

    def __nonzero__(self):
        return self.failed == 0


class CriticalStats(Stat):

    def __init__(self, suite):
        Stat.__init__(self)
        self.add_suite(suite)

    def _is_included(self, test):
        return test.critical

    def _subsuite_stats(self, suite):
        return suite.critical_stats


class AllStats(Stat):

    def __init__(self, suite):
        Stat.__init__(self)
        self.add_suite(suite)


class SuiteStat(Stat):
    type = 'suite'

    def __init__(self, suite):
        Stat.__init__(self, suite.name)
        self.longname = suite.longname
        self.id = suite.id

    def serialize(self, serializer):
        serializer.suite_stat(self)


class TagStat(Stat):
    type = 'tag'

    def __init__(self, name, doc='', links=[], critical=False,
                 non_critical=False, combined=''):
        Stat.__init__(self, name)
        self.doc = doc
        self.links = links
        self.critical = critical
        self.non_critical = non_critical
        self.combined = combined
        self.tests = []

    def add_test(self, test):
        Stat.add_test(self, test)
        self.tests.append(test)

    def __cmp__(self, other):
        if self.critical != other.critical:
            return cmp(other.critical, self.critical)
        if self.non_critical != other.non_critical:
            return cmp(other.non_critical, self.non_critical)
        if bool(self.combined) != bool(other.combined):
            return cmp(bool(other.combined), bool(self.combined))
        return Stat.__cmp__(self, other)

    def serialize(self, serializer):
        serializer.tag_stat(self)


class TotalStat(Stat):
    type = 'total'

    def __init__(self, name, suite_stat):
        Stat.__init__(self, name)
        self.passed = suite_stat.passed
        self.failed = suite_stat.failed

    def serialize(self, serializer):
        serializer.total_stat(self)


class SuiteStatistics:

    def __init__(self, suite, tag_stats, suite_stat_level=-1):
        self.all = SuiteStat(suite)
        self.critical = SuiteStat(suite)
        self.suites = []
        self._process_suites(suite, tag_stats)
        self._process_tests(suite, tag_stats)
        self._suite_stat_level = suite_stat_level

    def _process_suites(self, suite, tag_stats):
        for subsuite in suite.suites:
            substat = SuiteStatistics(subsuite, tag_stats)
            self.suites.append(substat)
            self.all.add_stat(substat.all)
            self.critical.add_stat(substat.critical)

    def _process_tests(self, suite, tag_stats):
        for test in suite.tests:
            self.all.add_test(test)
            if test.critical:
                self.critical.add_test(test)
            tag_stats.add_test(test, suite.critical)

    def serialize(self, serializer):
        serializer.start_suite_stats(self)
        self._serialize(serializer, self._suite_stat_level)
        serializer.end_suite_stats(self)

    def _serialize(self, serializer, max_suite_level, suite_level=1):
        self.all.serialize(serializer)
        if max_suite_level < 0 or max_suite_level > suite_level:
            for suite in self.suites:
                suite._serialize(serializer, max_suite_level, suite_level+1)


class TagStatistics:

    def __init__(self, include=None, exclude=None, combine=None, docs=None,
                 links=None):
        self.stats = NormalizedDict(ignore=['_'])
        self._include = MultiMatcher(include, ignore=['_'])
        self._exclude = MultiMatcher(exclude, ignore=['_'])
        self._combine = combine or []
        info = TagStatInfo(docs or [], links or [])
        self._get_doc = info.get_doc
        self._get_links = info.get_links

    def add_test(self, test, critical):
        self._add_tags_statistics(test, critical)
        self._add_combined_statistics(test)

    def _add_tags_statistics(self, test, critical):
        for tag in test.tags:
            if not self._is_included(tag):
                continue
            if tag not in self.stats:
                self.stats[tag] = TagStat(tag, self._get_doc(tag),
                                          self._get_links(tag),
                                          critical.is_critical(tag),
                                          critical.is_non_critical(tag))
            self.stats[tag].add_test(test)

    def _is_included(self, tag):
        if self._include and not self._include.match(tag):
            return False
        return not self._exclude.match(tag)

    def _add_combined_statistics(self, test):
        for pattern, name in self._combine:
            name = name or pattern
            if name not in self.stats:
                self.stats[name] = TagStat(name, self._get_doc(name),
                                           self._get_links(name),
                                           combined=pattern)
            if TagPatterns(pattern).match(test.tags):
                self.stats[name].add_test(test)

    def serialize(self, serializer):
        serializer.start_tag_stats(self)
        for stat in sorted(self.stats.values()):
            stat.serialize(serializer)
        serializer.end_tag_stats(self)

    def sort(self):
        for stat in self.stats.values():
            stat.tests.sort()


class TotalStatistics:

    def __init__(self, suite):
        self.critical = TotalStat('Critical Tests', suite.critical)
        self.all = TotalStat('All Tests', suite.all)

    def serialize(self, serializer):
        serializer.start_total_stats(self)
        self.critical.serialize(serializer)
        self.all.serialize(serializer)
        serializer.end_total_stats(self)


class TagStatInfo:

    def __init__(self, docs, links):
        self._docs = [TagStatDoc(*doc) for doc in docs]
        self._links = [TagStatLink(*link) for link in links]

    def get_doc(self, tag):
        return ' & '.join(doc.text for doc in self._docs if doc.matches(tag))

    def get_links(self, tag):
        return [link.get_link(tag) for link in self._links if link.matches(tag)]


class TagStatDoc:

    def __init__(self, pattern, doc):
        self.text = doc
        self._matcher = Matcher(pattern, ignore=['_'])

    def matches(self, tag):
        return self._matcher.match(tag)


class TagStatLink:
    _match_pattern_tokenizer = re.compile('(\*|\?)')

    def __init__(self, pattern, link, title):
        self._regexp = self._get_match_regexp(pattern)
        self._link = link
        self._title = title.replace('_', ' ')

    def matches(self, tag):
        return self._regexp.match(tag) is not None

    def get_link(self, tag):
        match = self._regexp.match(tag)
        if not match:
            return None
        link, title = self._replace_groups(self._link, self._title, match)
        return link, title

    def _replace_groups(self, link, title, match):
        for index, group in enumerate(match.groups()):
            placefolder = '%' + str(index+1)
            link = link.replace(placefolder, group)
            title = title.replace(placefolder, group)
        return link, title

    def _get_match_regexp(self, pattern):
        regexp = []
        open_parenthesis = False
        for token in self._match_pattern_tokenizer.split(pattern):
            if token == '':
                continue
            if token == '?':
                if not open_parenthesis:
                    regexp.append('(')
                    open_parenthesis = True
                regexp.append('.')
                continue
            if open_parenthesis:
                regexp.append(')')
                open_parenthesis = False
            if token == '*':
                regexp.append('(.*)')
                continue
            regexp.append(re.escape(token))
        if open_parenthesis:
            regexp.append(')')
        return re.compile('^%s$' % ''.join(regexp), re.IGNORECASE)

########NEW FILE########
__FILENAME__ = settings
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot import utils
from robot.errors import DataError, FrameworkError
from robot.output import LOGGER, loggerhelper


class _BaseSettings(object):
    _cli_opts = {'Name'             : ('name', None),
                 'Doc'              : ('doc', None),
                 'Metadata'         : ('metadata', []),
                 'TestNames'        : ('test', []),
                 'SuiteNames'       : ('suite', []),
                 'SetTag'           : ('settag', []),
                 'Include'          : ('include', []),
                 'Exclude'          : ('exclude', []),
                 'Critical'         : ('critical', None),
                 'NonCritical'      : ('noncritical', None),
                 'OutputDir'        : ('outputdir', utils.abspath('.')),
                 'Log'              : ('log', 'log.html'),
                 'Report'           : ('report', 'report.html'),
                 'XUnitFile'        : ('xunitfile', 'NONE'),
                 'SplitLog'         : ('splitlog', False),
                 'TimestampOutputs' : ('timestampoutputs', False),
                 'LogTitle'         : ('logtitle', None),
                 'ReportTitle'      : ('reporttitle', None),
                 'ReportBackground' : ('reportbackground',
                                       ('#99FF66', '#99FF66', '#FF3333')),
                 'SuiteStatLevel'   : ('suitestatlevel', -1),
                 'TagStatInclude'   : ('tagstatinclude', []),
                 'TagStatExclude'   : ('tagstatexclude', []),
                 'TagStatCombine'   : ('tagstatcombine', []),
                 'TagDoc'           : ('tagdoc', []),
                 'TagStatLink'      : ('tagstatlink', []),
                 'RemoveKeywords'   : ('removekeywords', []),
                 'NoStatusRC'       : ('nostatusrc', False),
                 'MonitorColors'    : ('monitorcolors', 'AUTO'),
                 'StdOut'           : ('stdout', None),
                 'StdErr'           : ('stderr', None)}
    _output_opts = ['Output', 'Log', 'Report', 'DebugFile', 'XUnitFile']

    def __init__(self, options=None, log=True):
        self._opts = {}
        self._cli_opts = self._cli_opts.copy()
        self._cli_opts.update(self._extra_cli_opts)
        self._process_cli_opts(options or {}, log)
        if log: LOGGER.info('Settings:\n%s' % unicode(self))

    def _process_cli_opts(self, opts, log):
        for name, (cli_name, default) in self._cli_opts.items():
            value = opts.get(cli_name, default)
            if value in [None, []]:
                value = default
            elif default == [] and isinstance(value, basestring):
                value = [value]
            self[name] = self._process_value(name, value, log)

    def __setitem__(self, name, value):
        if name not in self._cli_opts:
            raise KeyError("Non-existing settings '%s'" % name)
        self._opts[name] = value

    def _process_value(self, name, value, log):
        if name == 'LogLevel':
            return self._process_log_level(value)
        if value == self._get_default_value(name):
            return value
        if name in ['Name', 'Doc', 'LogTitle', 'ReportTitle']:
            if name == 'Doc': value = self._escape(value)
            return value.replace('_', ' ')
        if name in ['Metadata', 'TagDoc']:
            if name == 'Metadata': value = [self._escape(v) for v in value]
            return [self._process_metadata_or_tagdoc(v) for v in value]
        if name in ['Include', 'Exclude']:
            return [v.replace('AND', '&').replace('_', ' ') for v in value]
        if name in self._output_opts and utils.eq(value, 'NONE'):
            return 'NONE'
        if name == 'OutputDir':
            return utils.abspath(value)
        if name in ['SuiteStatLevel', 'MonitorWidth']:
            return self._convert_to_positive_integer_or_default(name, value)
        if name in ['Listeners', 'VariableFiles']:
            return [self._split_args_from_name_or_path(item) for item in value]
        if name == 'ReportBackground':
            return self._process_report_background(value)
        if name == 'TagStatCombine':
            return [self._process_tag_stat_combine(v) for v in value]
        if name == 'TagStatLink':
            return [v for v in [self._process_tag_stat_link(v) for v in value] if v]
        if name == 'RemoveKeywords':
            return [v.upper() for v in value]
        return value

    def _process_log_level(self, level):
        level, visible_level = self._split_log_level(level.upper())
        self._opts['VisibleLogLevel'] = visible_level
        return level

    def _split_log_level(self, level):
        if ':' in level:
            level, visible_level = level.split(':', 1)
        else:
            visible_level = level
        self._validate_log_level_and_default(level, visible_level)
        return level, visible_level

    def _validate_log_level_and_default(self, log_level, default):
        if log_level not in loggerhelper.LEVELS:
            raise DataError("Invalid log level '%s'" % log_level)
        if default not in loggerhelper.LEVELS:
            raise DataError("Invalid log level '%s'" % default)
        if not loggerhelper.IsLogged(log_level)(default):
            raise DataError("Default visible log level '%s' is lower than "
                            "log level '%s'" % (default, log_level))

    def __getitem__(self, name):
        if name not in self._opts:
            raise KeyError("Non-existing setting '%s'" % name)
        if name in self._output_opts:
            return self._get_output_file(name)
        return self._opts[name]

    def _get_output_file(self, type_):
        """Returns path of the requested output file and creates needed dirs.

        `type_` can be 'Output', 'Log', 'Report', 'DebugFile' or 'XUnitFile'.
        """
        name = self._opts[type_]
        if self._outputfile_disabled(type_, name):
            return 'NONE'
        name = self._process_output_name(name, type_)
        path = utils.abspath(os.path.join(self['OutputDir'], name))
        self._create_output_dir(os.path.dirname(path), type_)
        return path

    def _process_output_name(self, name, type_):
        base, ext = os.path.splitext(name)
        if self['TimestampOutputs']:
            base = '%s-%s' % (base, utils.get_start_timestamp('', '-', ''))
        ext = self._get_output_extension(ext, type_)
        return base + ext

    def _get_output_extension(self, ext, type_):
        if ext != '':
            return ext
        if type_ in ['Output', 'XUnitFile']:
            return '.xml'
        if type_ in ['Log', 'Report']:
            return '.html'
        if type_ == 'DebugFile':
            return '.txt'
        raise FrameworkError("Invalid output file type: %s" % type_)

    def _create_output_dir(self, path, type_):
        try:
            if not os.path.exists(path):
                os.makedirs(path)
        except EnvironmentError, err:
            raise DataError("Creating %s file directory '%s' failed: %s"
                            % (type_.lower(), path, err.strerror))

    def _process_metadata_or_tagdoc(self, value):
        value = value.replace('_', ' ')
        if ':' in value:
            return value.split(':', 1)
        return value, ''

    def _process_report_background(self, colors):
        if colors.count(':') not in [1, 2]:
            LOGGER.error("Invalid report background colors '%s'." % colors)
            return self._get_default_value('ReportBackground')
        colors = colors.split(':')
        if len(colors) == 2:
            return colors[0], colors[0], colors[1]
        return tuple(colors)

    def _process_tag_stat_combine(self, value):
        for replwhat, replwith in [('&', 'AND'), ('AND', ' AND '), ('NOT', ' NOT ')]:
            value = value.replace(replwhat, replwith)
        if ':' not in value:
            return value, ''
        pattern, title = value.rsplit(':', 1)
        return pattern, title.replace('_', ' ')

    def _process_tag_stat_link(self, value):
        tokens = value.split(':')
        if len(tokens) >= 3:
            return tokens[0], ':'.join(tokens[1:-1]), tokens[-1]
        LOGGER.error("Invalid format for option '--tagstatlink'. "
                     "Expected 'tag:link:title' but got '%s'." % value)
        return None

    def _convert_to_positive_integer_or_default(self, name, value):
        value = self._convert_to_integer(name, value)
        return value if value > 0 else self._get_default_value(name)

    def _convert_to_integer(self, name, value):
        try:
            return int(value)
        except ValueError:
            LOGGER.error("Option '--%s' expected integer value but got '%s'. "
                         "Default value used instead." % (name.lower(), value))
            return self._get_default_value(name)

    def _get_default_value(self, name):
        return self._cli_opts[name][1]

    def _split_args_from_name_or_path(self, name):
        if ':' not in name or os.path.exists(name):
            args = []
        else:
            args = name.split(':')
            name = args.pop(0)
            # Handle absolute Windows paths with arguments
            if len(name) == 1 and args[0].startswith(('/', '\\')):
                name = name + ':' + args.pop(0)
        if os.path.exists(name):
            name = os.path.abspath(name)
        return name, args

    def __contains__(self, setting):
        return setting in self._cli_opts

    def __unicode__(self):
        return '\n'.join('%s: %s' % (name, self._opts[name])
                         for name in sorted(self._opts))

    @property
    def output(self):
        return self._get_file('Output')

    @property
    def log(self):
        return self._get_file('Log')

    @property
    def report(self):
        return self._get_file('Report')

    @property
    def xunit(self):
        return self._get_file('XUnitFile')

    def _get_file(self, name):
        value = self[name]
        return value if value != 'NONE' else None

    @property
    def split_log(self):
        return self['SplitLog']

    @property
    def status_rc(self):
        return not self['NoStatusRC']


class RobotSettings(_BaseSettings):
    _extra_cli_opts = {'Output'        : ('output', 'output.xml'),
                       'LogLevel'      : ('loglevel', 'INFO'),
                       'RunMode'       : ('runmode', []),
                       'RunEmptySuite' : ('runemptysuite', False),
                       'WarnOnSkipped' : ('warnonskippedfiles', False),
                       'Variables'     : ('variable', []),
                       'VariableFiles' : ('variablefile', []),
                       'Listeners'     : ('listener', []),
                       'MonitorWidth'  : ('monitorwidth', 78),
                       'MonitorMarkers': ('monitormarkers', 'AUTO'),
                       'DebugFile'     : ('debugfile', 'NONE')}

    def is_rebot_needed(self):
        return not ('NONE' == self['Log'] == self['Report'] == self['XUnitFile'])

    def get_rebot_datasource_and_settings(self):
        datasource = self['Output']
        settings = RebotSettings(log=False)
        settings._opts.update(self._opts)
        for name in ['Variables', 'VariableFiles', 'Listeners']:
            del(settings._opts[name])
        for name in ['Include', 'Exclude', 'TestNames', 'SuiteNames', 'Metadata']:
            settings._opts[name] = []
        for name in ['Name', 'Doc']:
            settings._opts[name] = None
        settings._opts['Output'] = 'NONE'
        settings._opts['LogLevel'] = 'TRACE'
        settings._opts['ProcessEmptySuite'] = self['RunEmptySuite']
        return datasource, settings

    def _outputfile_disabled(self, type_, name):
        if name == 'NONE':
            return True
        return self._opts['Output'] == 'NONE' and type_ != 'DebugFile'

    def _escape(self, value):
        return utils.escape(value)


class RebotSettings(_BaseSettings):
    _extra_cli_opts = {'Output'            : ('output', 'NONE'),
                       'LogLevel'          : ('loglevel', 'TRACE'),
                       'ProcessEmptySuite' : ('processemptysuite', False),
                       'StartTime'         : ('starttime', None),
                       'EndTime'           : ('endtime', None)}

    def _outputfile_disabled(self, type_, name):
        return name == 'NONE'

    def _escape(self, value):
        return value

    @property
    def suite_config(self):
        return {
            'name': self['Name'],
            'doc': self['Doc'],
            'metadata': dict(self['Metadata']),
            'set_tags': self['SetTag'],
            'include_tags': self['Include'],
            'exclude_tags': self['Exclude'],
            'include_suites': self['SuiteNames'],
            'include_tests': self['TestNames'],
            'process_empty_suite': self['ProcessEmptySuite'],
            'remove_keywords': self['RemoveKeywords'],
            'log_level': self['LogLevel'],
            'critical': self['Critical'],
            'noncritical': self['NonCritical'],
            'starttime': self['StartTime'],
            'endtime': self['EndTime']
        }

    @property
    def statistics_config(self):
        return {
            'suite_stat_level': self['SuiteStatLevel'],
            'tag_stat_include': self['TagStatInclude'],
            'tag_stat_exclude': self['TagStatExclude'],
            'tag_stat_combine': self['TagStatCombine'],
            'tag_stat_link': self['TagStatLink'],
            'tag_doc': self['TagDoc'],
        }

    @property
    def log_config(self):
        if not self.log:
            return {}
        return {
            'title': utils.html_escape(self['LogTitle'] or ''),
            'reportURL': self._url_from_path(self.log, self.report),
            'splitLogBase': os.path.basename(os.path.splitext(self.log)[0]),
            'defaultLevel': self['VisibleLogLevel']
        }

    @property
    def report_config(self):
        if not self.report:
            return {}
        return {
            'title': utils.html_escape(self['ReportTitle'] or ''),
            'logURL': self._url_from_path(self.report, self.log),
            'background' : self._resolve_background_colors(),
        }

    def _url_from_path(self, source, destination):
        if not destination:
            return None
        return utils.get_link_path(destination, os.path.dirname(source))

    def _resolve_background_colors(self):
        colors = self['ReportBackground']
        return {'pass': colors[0], 'nonCriticalFail': colors[1], 'fail': colors[2]}

########NEW FILE########
__FILENAME__ = errors
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import utils

# Return codes from Robot and Rebot.
# RC below 250 is the number of failed critical tests and exactly 250
# means that number or more such failures.
INFO_PRINTED    = 251   # --help or --version
DATA_ERROR      = 252   # Invalid data or cli args
STOPPED_BY_USER = 253   # KeyboardInterrupt or SystemExit
FRAMEWORK_ERROR = 255   # Unexpected error


class RobotError(Exception):
    """Base class for Robot Framework errors.

    Do not raise this method but use more specific errors instead.
    """
    def __init__(self, message='', details=''):
        Exception.__init__(self, message)
        self.details = details

    @property
    def message(self):
        return self.__unicode__()

    def __unicode__(self):
        # Needed to handle exceptions w/ Unicode correctly on Python 2.5
        return unicode(self.args[0]) if self.args else u''


class FrameworkError(RobotError):
    """Can be used when the core framework goes to unexpected state.

    It is good to explicitly raise a FrameworkError if some framework
    component is used incorrectly. This is pretty much same as
    'Internal Error' and should of course never happen.
    """


class DataError(RobotError):
    """Used when the provided test data is invalid.

    DataErrors are not be caught by keywords that run other keywords
    (e.g. `Run Keyword And Expect Error`). Libraries should thus use
    this exception with care.
    """


class TimeoutError(RobotError):
    """Used when a test or keyword timeout occurs.

    This exception is handled specially so that execution of the
    current test is always stopped immediately and it is not caught by
    keywords executing other keywords (e.g. `Run Keyword And Expect
    Error`). Libraries should thus NOT use this exception themselves.
    """


class Information(RobotError):
    """Used by argument parser with --help or --version."""


class ExecutionFailed(RobotError):
    """Used for communicating failures in test execution."""

    def __init__(self, message, timeout=False, syntax=False, exit=False,
                 continue_on_failure=False, return_value=None):
        if '\r\n' in message:
            message = message.replace('\r\n', '\n')
        RobotError.__init__(self, utils.cut_long_message(message))
        self.timeout = timeout
        self.syntax = syntax
        self.exit = exit
        self.continue_on_failure = continue_on_failure
        self.return_value = return_value

    @property
    def dont_continue(self):
        return self.timeout or self.syntax or self.exit

    def _get_continue_on_failure(self):
        return self._continue_on_failure

    def _set_continue_on_failure(self, continue_on_failure):
        self._continue_on_failure = continue_on_failure
        for child in getattr(self, '_errors', []):
            child.continue_on_failure = continue_on_failure

    continue_on_failure = property(_get_continue_on_failure,
                                   _set_continue_on_failure)

    def can_continue(self, teardown=False, templated=False, dry_run=False):
        if dry_run:
            return True
        if self.dont_continue and not (teardown and self.syntax):
            return False
        if teardown or templated:
            return True
        return self.continue_on_failure

    def get_errors(self):
        return [self]


class HandlerExecutionFailed(ExecutionFailed):

    def __init__(self):
        details = utils.ErrorDetails()
        timeout = isinstance(details.error, TimeoutError)
        syntax = isinstance(details.error, DataError)
        exit_on_failure = self._get(details.error, 'EXIT_ON_FAILURE')
        continue_on_failure = self._get(details.error, 'CONTINUE_ON_FAILURE')
        ExecutionFailed.__init__(self, details.message, timeout, syntax,
                                 exit_on_failure, continue_on_failure)
        self.full_message = details.message
        self.traceback = details.traceback
        self._handle_deprecated_exit_for_loop(details.error)

    def _get(self, error, attr):
        return bool(getattr(error, 'ROBOT_' + attr, False))

    def _handle_deprecated_exit_for_loop(self, error):
        if self._get(error, 'EXIT_FOR_LOOP'):
            from robot.output import LOGGER
            LOGGER.warn("Support for using 'ROBOT_EXIT_FOR_LOOP' attribute to "
                        "exit for loops is deprecated in Robot Framework 2.8 "
                        "and will be removed in 2.9.")
            raise ExitForLoop


class ExecutionFailures(ExecutionFailed):

    def __init__(self, errors, message=None):
        message = message or self._format_message([unicode(e) for e in errors])
        ExecutionFailed.__init__(self, message, **self._get_attrs(errors))
        self._errors = errors

    def _format_message(self, messages):
        if len(messages) == 1:
            return messages[0]
        lines = ['Several failures occurred:'] \
                + ['%d) %s' % (i+1, m) for i, m in enumerate(messages)]
        return '\n\n'.join(lines)

    def _get_attrs(self, errors):
        return {'timeout': any(err.timeout for err in errors),
                'syntax': any(err.syntax for err in errors),
                'exit': any(err.exit for err in errors),
                'continue_on_failure': all(err.continue_on_failure for err in errors)
                }

    def get_errors(self):
        return self._errors


class UserKeywordExecutionFailed(ExecutionFailures):

    def __init__(self, run_errors=None, teardown_errors=None):
        errors = self._get_active_errors(run_errors, teardown_errors)
        message = self._get_message(run_errors, teardown_errors)
        ExecutionFailures.__init__(self, errors, message)
        if run_errors and not teardown_errors:
            self._errors = run_errors.get_errors()
        else:
            self._errors = [self]

    def _get_active_errors(self, *errors):
        return [err for err in errors if err]

    def _get_message(self, run_errors, teardown_errors):
        run_msg = unicode(run_errors or '')
        td_msg = unicode(teardown_errors or '')
        if not td_msg:
            return run_msg
        if not run_msg:
            return 'Keyword teardown failed:\n%s' % td_msg
        return '%s\n\nAlso keyword teardown failed:\n%s' % (run_msg, td_msg)


class ExecutionPassed(ExecutionFailed):
    """Base class for all exceptions communicating that execution passed.

    Should not be raised directly, but more detailed exceptions used instead.
    """

    def __init__(self, message=None, **kwargs):
        ExecutionFailed.__init__(self, message or self._get_message(), **kwargs)
        self._earlier_failures = []

    def _get_message(self):
        return "Invalid '%s' usage." \
               % utils.printable_name(self.__class__.__name__, code_style=True)

    def set_earlier_failures(self, failures):
        if failures:
            self._earlier_failures.extend(failures)

    @property
    def earlier_failures(self):
        if not self._earlier_failures:
            return None
        return ExecutionFailures(self._earlier_failures)


class PassExecution(ExecutionPassed):
    """Used by 'Pass Execution' keyword."""

    def __init__(self, message):
        ExecutionPassed.__init__(self, message)


class ContinueForLoop(ExecutionPassed):
    """Used by 'Continue For Loop' keyword."""


class ExitForLoop(ExecutionPassed):
    """Used by 'Exit For Loop' keyword."""


class ReturnFromKeyword(ExecutionPassed):
    """Used by 'Return From Keyword' keyword."""

    def __init__(self, return_value):
        ExecutionPassed.__init__(self, return_value=return_value)


class RemoteError(RobotError):
    """Used by Remote library to report remote errors."""

########NEW FILE########
__FILENAME__ = htmlfilewriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os
import re

from robot.utils import HtmlWriter
from robot.version import get_full_version

from .template import HtmlTemplate


class HtmlFileWriter(object):

    def __init__(self, output, model_writer):
        self._output = output
        self._model_writer = model_writer

    def write(self, template):
        writers = self._get_writers(os.path.dirname(template))
        for line in HtmlTemplate(template):
            for writer in writers:
                if writer.handles(line):
                    writer.write(line)
                    break

    def _get_writers(self, base_dir):
        html_writer = HtmlWriter(self._output)
        return (self._model_writer,
                JsFileWriter(html_writer, base_dir),
                CssFileWriter(html_writer, base_dir),
                GeneratorWriter(html_writer),
                LineWriter(self._output))


class _Writer(object):
    _handles_line = None

    def handles(self, line):
        return line.startswith(self._handles_line)

    def write(self, line):
        raise NotImplementedError


class ModelWriter(_Writer):
    _handles_line = '<!-- JS MODEL -->'


class LineWriter(_Writer):

    def __init__(self, output):
        self._output = output

    def handles(self, line):
        return True

    def write(self, line):
        self._output.write(line + os.linesep)


class GeneratorWriter(_Writer):
    _handles_line = '<meta name="Generator" content='

    def __init__(self, html_writer):
        self._html_writer = html_writer

    def write(self, line):
        version = get_full_version('Robot Framework')
        self._html_writer.start('meta', {'name': 'Generator', 'content': version})


class _InliningWriter(_Writer):

    def __init__(self, html_writer, base_dir):
        self._html_writer = html_writer
        self._base_dir = base_dir

    def _inline_file(self, filename, tag, attrs):
        self._html_writer.start(tag, attrs)
        for line in HtmlTemplate(os.path.join(self._base_dir, filename)):
            self._html_writer.content(line + os.linesep, escape=False)
        self._html_writer.end(tag)


class JsFileWriter(_InliningWriter):
    _handles_line = '<script type="text/javascript" src='
    _source_file = re.compile('src=\"([^\"]+)\"')

    def write(self, line):
        name = self._source_file.search(line).group(1)
        self._inline_file(name, 'script', {'type': 'text/javascript'})


class CssFileWriter(_InliningWriter):
    _handles_line = '<link rel="stylesheet"'
    _source_file = re.compile('href=\"([^\"]+)\"')
    _media_type = re.compile('media=\"([^\"]+)\"')

    def write(self, line):
        name = self._source_file.search(line).group(1)
        media = self._media_type.search(line).group(1)
        self._inline_file(name, 'style', {'type': 'text/css', 'media': media})

########NEW FILE########
__FILENAME__ = jartemplate
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os
from posixpath import normpath, join
from contextlib import contextmanager
from java.io import BufferedReader, InputStreamReader

# Works only when running from jar
from org.robotframework.RobotRunner import getResourceAsStream


class HtmlTemplate(object):
    _base_dir = '/Lib/robot/htmldata/'

    def __init__(self, filename):
        self._path = normpath(join(self._base_dir, filename.replace(os.sep, '/')))

    def __iter__(self):
        with self._reader as reader:
            line = reader.readLine()
            while line is not None:
                yield line.rstrip()
                line = reader.readLine()

    @property
    @contextmanager
    def _reader(self):
        stream = getResourceAsStream(self._path)
        reader = BufferedReader(InputStreamReader(stream, 'UTF-8'))
        try:
            yield reader
        finally:
            reader.close()

########NEW FILE########
__FILENAME__ = jsonwriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os


class JsonWriter(object):

    def __init__(self, output, separator=''):
        self._writer = JsonDumper(output)
        self._separator = separator

    def write_json(self, prefix, data, postfix=';'+os.linesep, mapping=None,
                   separator=True):
        self._writer.write(prefix)
        self._writer.dump(data, mapping)
        self._writer.write(postfix)
        self._write_separator(separator)

    def write(self, string, postfix=';'+os.linesep, separator=True):
        self._writer.write(string + postfix)
        self._write_separator(separator)

    def _write_separator(self, separator):
        if separator and self._separator:
            self._writer.write(self._separator)


class JsonDumper(object):

    def __init__(self, output):
        self._output = output
        self._dumpers = (MappingDumper(self),
                         IntegerDumper(self),
                         TupleListDumper(self),
                         StringDumper(self),
                         NoneDumper(self),
                         DictDumper(self))

    def dump(self, data, mapping=None):
        for dumper in self._dumpers:
            if dumper.handles(data, mapping):
                dumper.dump(data, mapping)
                return
        raise ValueError('Dumping %s not supported' % type(data))

    def write(self, data):
        self._output.write(data)


class _Dumper(object):
    _handled_types = None

    def __init__(self, jsondumper):
        self._dump = jsondumper.dump
        self._write = jsondumper.write

    def handles(self, data, mapping):
        return isinstance(data, self._handled_types)

    def dump(self, data, mapping):
        raise NotImplementedError


class StringDumper(_Dumper):
    _handled_types = basestring
    _replace = {'\\': '\\\\', '"': '\\"', '\t': '\\t', '\n': '\\n', '\r': '\\r'}

    def dump(self, data, mapping):
        self._write('"%s"' % ''.join(self._encode_chars(data)))

    def _encode_chars(self, string):
        # Performance optimized code..
        replace = self._replace
        for char in string:
            if char in replace:
                yield replace[char]
            else:
                val = ord(char)
                yield char if 31 < val < 127 else '\\u%04x' % val


class IntegerDumper(_Dumper):
    _handled_types = (int, long, bool)

    def dump(self, data, mapping):
        self._write(str(data).lower())


class DictDumper(_Dumper):
    _handled_types = dict

    def dump(self, data, mapping):
        self._write('{')
        last_index = len(data) - 1
        for index, key in enumerate(sorted(data)):
            self._dump(key, mapping)
            self._write(':')
            self._dump(data[key], mapping)
            if index < last_index:
                self._write(',')
        self._write('}')


class TupleListDumper(_Dumper):
    _handled_types = (tuple, list)

    def dump(self, data, mapping):
        self._write('[')
        last_index = len(data) - 1
        for index, item in enumerate(data):
            self._dump(item, mapping)
            if index < last_index:
                self._write(',')
        self._write(']')


class MappingDumper(_Dumper):

    def handles(self, data, mapping):
        try:
            return mapping and data in mapping
        except TypeError:
            return False

    def dump(self, data, mapping):
        self._write(mapping[data])


class NoneDumper(_Dumper):

    def handles(self, data, mapping):
        return data is None

    def dump(self, data, mapping):
        self._write('null')

########NEW FILE########
__FILENAME__ = normaltemplate
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os
from os.path import abspath, dirname, join, normpath

from robot.utils import utf8open

class HtmlTemplate(object):
    _base_dir = join(dirname(abspath(__file__)), '..', 'htmldata')

    def __init__(self, filename):
        self._path = normpath(join(self._base_dir, filename.replace('/', os.sep)))

    def __iter__(self):
        with utf8open(self._path) as file:
            for line in file:
                yield line.rstrip()

########NEW FILE########
__FILENAME__ = template
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

try:
    from .jartemplate import HtmlTemplate
except ImportError:
    from .normaltemplate import HtmlTemplate

########NEW FILE########
__FILENAME__ = create_jsdata
#!/usr/bin/env python

from os.path import abspath, dirname, normpath, join
import os
import sys

BASEDIR = dirname(abspath(__file__))
LOG = normpath(join(BASEDIR, '..', 'log.html'))
TESTDATA = join(BASEDIR, 'dir.suite')
OUTPUT = join(BASEDIR, 'output.xml')
TARGET = join(BASEDIR, 'data.js')
SRC = normpath(join(BASEDIR, '..', '..', '..'))

sys.path.insert(0, SRC)

import robot
from robot.conf.settings import RebotSettings
from robot.reporting.resultwriter import Results
from robot.reporting.jswriter import JsResultWriter
from robot.utils import utf8open

def run_robot(testdata, outxml):
    robot.run(testdata, loglevel='DEBUG', log='NONE', report='NONE', output=outxml)


def create_jsdata(outxml, target):
    settings = RebotSettings({
        'name': '<Suite.Name>',
        'critical': ['i?'],
        'noncritical': ['*kek*kone*'],
        'tagstatlink': ['force:http://google.com:<kuukkeli&gt;',
                        'i*:http://%1/:Title of i%1',
                        '?1:http://%1/:Title',
                        '</script>:<url>:<title>'],
        'tagdoc': ['test:this_is_*my_bold*_test',
                   'IX:*Combined* and escaped <&lt; tag doc',
                   'i*:Me, myself, and I.',
                   '</script>:<doc>'],
        'tagstatcombine': ['fooANDi*:No Match',
                           'i?:IX',
                           '<*>:<any>']
    })
    result = Results(outxml, settings).js_result
    config = {'logURL': 'log.html',
              'title': 'This is a long long title. A very long title indeed. '
                       'And it even contains some stuff to <esc&ape>. '
                       'Yet it should still look good.',
              'minLevel': 'DEBUG',
              'defaultLevel': 'DEBUG',
              'reportURL': 'report.html',
              'background': {'fail': 'DeepPink'}}
    with utf8open(target, 'w') as output:
        writer = JsResultWriter(output, start_block='', end_block='')
        writer.write(result, config)
    print 'Log:    ', normpath(join(BASEDIR, '..', 'rebot', 'log.html'))
    print 'Report: ', normpath(join(BASEDIR, '..', 'rebot', 'report.html'))


if __name__ == '__main__':
    run_robot(TESTDATA, OUTPUT)
    create_jsdata(OUTPUT, TARGET)
    os.remove(OUTPUT)

########NEW FILE########
__FILENAME__ = create_libdoc_data
#!/usr/bin/env python

import sys
from os.path import abspath, dirname, join, normpath

BASE = dirname(abspath(__file__))
SRC = normpath(join(BASE, '..', '..', '..', '..', 'src'))
# must generate data next to testdoc.html to get relative sources correct
INPUT = join(BASE, 'libdoc.txt')
OUTPUT = join(BASE, 'libdoc.js')

sys.path.insert(0, SRC)

from robot.libdoc import LibraryDocumentation
from robot.libdocpkg.htmlwriter import LibdocModelWriter

with open(OUTPUT, 'w') as output:
    libdoc = LibraryDocumentation(INPUT)
    LibdocModelWriter(output, libdoc).write_data()

print OUTPUT


########NEW FILE########
__FILENAME__ = create_testdoc_data
#!/usr/bin/env python

import sys
from os.path import abspath, dirname, join, normpath
import shutil

BASE = dirname(abspath(__file__))
ROOT = normpath(join(BASE, '..', '..', '..', '..'))
DATADIR = join(ROOT, 'atest', 'testdata', 'misc')
SRC = join(ROOT, 'src')
# must generate data next to testdoc.html to get relative sources correct
OUTPUT = join(BASE, '..', 'testdoc.js')
REAL_OUTPUT =  join(BASE, 'testdoc.js')

sys.path.insert(0, SRC)

from robot.testdoc import TestSuiteFactory, TestdocModelWriter

with open(OUTPUT, 'w') as output:
    TestdocModelWriter(output, TestSuiteFactory(DATADIR)).write_data()

shutil.move(OUTPUT, REAL_OUTPUT)

print REAL_OUTPUT


########NEW FILE########
__FILENAME__ = jarrunner
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from org.robotframework import RobotRunner
from robot import run_cli, rebot_cli
from robot.libdoc import libdoc_cli
from robot.tidy import tidy_cli
from robot.testdoc import testdoc_cli


USAGE = """robotframework.jar - Robot Framework runner.

Usage: java -jar robotframework.jar [command] [options] [input(s)]

Available commands:
  run     - Run Robot Framework tests. The default, if no command is given.
  rebot   - Post process Robot Framework output files.
  libdoc  - Create test library or resource file documentation.
  tidy    - Clean-up and changed format of test data files.
  testdoc - Create documentation from Robot Framework test data files.

Run `java -jar robotframework.jar command --help` for more information about
an individual command.

Examples:
  java -jar robotframework.jar mytests.txt
  java -jar robotframework.jar run mytests.txt
  java -jar robotframework.jar rebot --log mylog.html out.xml
  java -jar robotframework.jar tidy --format txt mytests.html
"""


class JarRunner(RobotRunner):
    """Used for Java-Jython interop when RF is executed from .jar file"""
    _commands = {'run': run_cli, 'rebot': rebot_cli, 'tidy': tidy_cli,
                 'libdoc': libdoc_cli, 'testdoc': testdoc_cli}

    def run(self, args):
        try:
            self._run(args)
        except SystemExit, err:
            return err.code

    def _run(self, args):
        if not args or args[0] in ('-h', '--help'):
            print USAGE
            raise SystemExit(0)
        command, args = self._parse_command_line(args)
        command(args) # Always calls sys.exit()

    def _parse_command_line(self, args):
        try:
            return self._commands[args[0]], args[1:]
        except KeyError:
            return run_cli, args

########NEW FILE########
__FILENAME__ = jythonworkarounds
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys
from java.lang import String


# Global workaround for os.listdir bug http://bugs.jython.org/issue1593
# This bug has been fixed in Jython 2.5.2.
if sys.version_info[:3] < (2, 5, 2):
    os._orig_listdir = os.listdir
    def listdir(path):
        items = os._orig_listdir(path)
        if isinstance(path, unicode):
            items = [unicode(String(i).toString()) for i in items]
        return items
    os.listdir = listdir

########NEW FILE########
__FILENAME__ = libdoc
#!/usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

USAGE = """robot.libdoc -- Robot Framework library documentation generator

Version:  <VERSION>

Usage:  python -m robot.libdoc [options] library output_file
   or:  python -m robot.libdoc [options] library list|show|version [names]

Libdoc tool can generate keyword documentation in HTML and XML formats both
for test libraries and resource files. HTML format is suitable for humans and
XML specs for RIDE and other tools. Libdoc also has few special commands to
show library or resource information on the console.

Libdoc supports all library and resource types and also earlier generated XML
specs can be used as input. If a library needs arguments, they must be given
as part of the library name and separated by two colons, for example, like
`LibraryName::arg1::arg2`.

Options
=======

 -f --format HTML|XML     Specifies whether to generate HTML or XML output.
                          If this options is not used, the format is got
                          from the extension of the output file.
 -F --docformat ROBOT|HTML|TEXT|REST
                          Specifies the source documentation format. Possible
                          values are Robot Framework's documentation format,
                          HTML, plain text, and reStructuredText. The default
                          value can be specified in test library source code
                          and the initial default value is `ROBOT`.
                          New in Robot Framework 2.7.5.
 -n --name newname        Sets the name of the documented library or resource.
 -v --version newversion  Sets the version of the documented library or
                          resource.
 -P --pythonpath path *   Additional locations where to search for libraries
                          and resources.
 -E --escape what:with *  Escapes characters which are problematic in console.
                          'what' is the name of the character to escape and
                          'with' is the string to escape it with.
                          <-------------------ESCAPES------------------------>
 -h -? --help             Print this help.

Creating documentation
======================

When creating documentation in HTML or XML format, the output file must
be specified as a second argument after the library/resource name or path.
Output format is got automatically from the extension but can also be set
with `--format` option.

Examples:

  python -m robot.libdoc src/MyLib.py doc/MyLib.html
  jython -m robot.libdoc MyJavaLibrary.java MyJavaLibrary.html
  python -m robot.libdoc --name MyLib Remote::10.0.0.42:8270 MyLib.xml

Viewing information on console
==============================

Libdoc has three special commands to show information on the console. These
commands are used instead of the name of the output file, and they can also
take additional arguments.

list:    List names of the keywords the library/resource contains. Can be
         limited to show only certain keywords by passing optional patterns as
         arguments. Keyword is listed if its name contains any given pattern.
show:    Show library/resource documentation. Can be limited to show only
         certain keywords by passing names as arguments. Keyword is shown if
         its name matches any given name. Special argument `intro` will show
         the library introduction and importing sections.
version: Show library version

Optional patterns given to `list` and `show` are case and space insensitive.
Both also accept `*` and `?` as wildcards.

Examples:

  python -m robot.libdoc Dialogs list
  python -m robot.libdoc Selenium2Library list browser
  python -m robot.libdoc Remote::10.0.0.42:8270 show
  python -m robot.libdoc Dialogs show PauseExecution execute*
  python -m robot.libdoc Selenium2Library show intro
  python -m robot.libdoc Selenium2Library version

Alternative execution
=====================

Libdoc works with all interpreters supported by Robot Framework (Python,
Jython and IronPython). In the examples above libdoc is executed as an
installed module, but it can also be executed as a script like
`python path/robot/libdoc.py`.

For more information see libdoc section in Robot Framework User Guide at
http://code.google.com/p/robotframework/wiki/UserGuide
"""

import sys
import os

# Allows running as a script. __name__ check needed with multiprocessing:
# http://code.google.com/p/robotframework/issues/detail?id=1137
if 'robot' not in sys.modules and __name__ == '__main__':
    import pythonpathsetter

from robot.utils import Application, seq2str
from robot.errors import DataError
from robot.libdocpkg import LibraryDocumentation, ConsoleViewer


class LibDoc(Application):

    def __init__(self):
        Application.__init__(self, USAGE, arg_limits=(2,), auto_version=False)

    def validate(self, options, arguments):
        if ConsoleViewer.handles(arguments[1]):
            ConsoleViewer.validate_command(arguments[1], arguments[2:])
        elif len(arguments) > 2:
            raise DataError('Only two arguments allowed when writing output.')
        return options, arguments

    def main(self, args, name='', version='', format=None, docformat=None):
        lib_or_res, output = args[:2]
        libdoc = LibraryDocumentation(lib_or_res, name, version,
                                      self._get_doc_format(docformat))
        if ConsoleViewer.handles(output):
            ConsoleViewer(libdoc).view(output, *args[2:])
        else:
            libdoc.save(output, self._get_output_format(format, output))
            self.console(os.path.abspath(output))

    def _get_doc_format(self, format):
        if not format:
            return None
        return self._verify_format('Doc format', format,
                                   ['ROBOT', 'TEXT', 'HTML', 'REST'])

    def _get_output_format(self, format, output):
        default = os.path.splitext(output)[1][1:]
        return self._verify_format('Format', format or default, ['HTML', 'XML'])

    def _verify_format(self, type, format, valid):
        format = format.upper()
        if format not in valid:
            raise DataError("%s must be %s, got '%s'."
                            % (type, seq2str(valid, lastsep=' or '), format))
        return format


def libdoc_cli(args):
    """Executes libdoc similarly as from the command line.

    :param args: command line arguments as a list of strings.

    Example:
        libdoc_cli(['--name', 'Something', 'MyLibrary.py', 'doc.html'])
    """
    LibDoc().execute_cli(args)


def libdoc(library_or_resource, outfile, name='', version='', format=None):
    """Executes libdoc.

    Arguments are same as command line options to libdoc.py.

    Example:
        libdoc('MyLibrary.py', 'MyLibrary.html', version='1.0')
    """

    LibDoc().execute(library_or_resource, outfile, name=name, version=version,
                     format=format)


if __name__ == '__main__':
    libdoc_cli(sys.argv[1:])

########NEW FILE########
__FILENAME__ = builder
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import os

from robot.parsing import VALID_EXTENSIONS as RESOURCE_EXTENSIONS
from robot.errors import DataError

from .robotbuilder import LibraryDocBuilder, ResourceDocBuilder
from .specbuilder import SpecDocBuilder
if sys.platform.startswith('java'):
    from .javabuilder import JavaDocBuilder
else:
    def JavaDocBuilder():
        raise DataError('Documenting Java test libraries requires Jython.')


def DocumentationBuilder(library_or_resource):
    extension = os.path.splitext(library_or_resource)[1][1:].lower()
    if extension in RESOURCE_EXTENSIONS:
        return ResourceDocBuilder()
    if extension == 'xml':
        return SpecDocBuilder()
    if extension == 'java':
        return JavaDocBuilder()
    return LibraryDocBuilder()

########NEW FILE########
__FILENAME__ = consoleviewer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import textwrap

from robot.utils import MultiMatcher, encode_output
from robot.errors import DataError


class ConsoleViewer(object):

    def __init__(self, libdoc):
        self._libdoc = libdoc
        self._keywords = KeywordMatcher(libdoc)

    @classmethod
    def handles(cls, command):
        return command.lower() in ['list', 'show', 'version']

    @classmethod
    def validate_command(cls, command, args):
        if not cls.handles(command):
            raise DataError("Unknown command '%s'." % command)
        if command.lower() == 'version' and args:
            raise DataError("Command 'version' does not take arguments.")

    def view(self, command, *args):
        self.validate_command(command, args)
        getattr(self, command.lower())(*args)

    def list(self, *patterns):
        for kw in self._keywords.search('*%s*' % p for p in patterns):
            self._console(kw.name)

    def show(self, *names):
        if MultiMatcher(names, match_if_no_patterns=True).match('intro'):
            self._show_intro(self._libdoc)
            if self._libdoc.inits:
                self._show_inits(self._libdoc)
        for kw in self._keywords.search(names):
            self._show_keyword(kw)

    def version(self):
        self._console(self._libdoc.version or 'N/A')

    def _console(self, msg):
        print encode_output(msg)

    def _show_intro(self, lib):
        self._header(lib.name, underline='=')
        named_args = 'supported' if lib.named_args else 'not supported'
        self._data([('Version', lib.version), ('Scope', lib.scope),
                    ('Named arguments', named_args)])
        self._doc(lib.doc)

    def _show_inits(self, lib):
        self._header('Importing', underline='-')
        for init in lib.inits:
            self._show_keyword(init, show_name=False)

    def _show_keyword(self, kw, show_name=True):
        if show_name:
            self._header(kw.name, underline='-')
        self._data([('Arguments', '[%s]' % ', '.join(kw.args))])
        self._doc(kw.doc)

    def _header(self, name, underline):
        self._console('%s\n%s' % (name, underline * len(name)))

    def _data(self, items):
        ljust = max(len(name) for name, _ in items) + 3
        for name, value in items:
            if value:
                text = '%s%s' % ((name+':').ljust(ljust), value)
                self._console(self._wrap(text, subsequent_indent=' '*ljust))

    def _doc(self, doc):
        self._console('')
        for line in doc.splitlines():
            self._console(self._wrap(line))
        if doc:
            self._console('')

    def _wrap(self, text, width=78, **config):
        return '\n'.join(textwrap.wrap(text, width=width, **config))


class KeywordMatcher(object):

    def __init__(self, libdoc):
        self._keywords = libdoc.keywords

    def search(self, patterns):
        matcher = MultiMatcher(patterns, match_if_no_patterns=True)
        for kw in self._keywords:
            if matcher.match(kw.name):
                yield kw

########NEW FILE########
__FILENAME__ = htmlwriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import re

from robot.errors import DataError
from robot.htmldata import HtmlFileWriter, ModelWriter, JsonWriter, LIBDOC
from robot import utils


class LibdocHtmlWriter(object):

    def write(self, libdoc, output):
        model_writer = LibdocModelWriter(output, libdoc)
        HtmlFileWriter(output, model_writer).write(LIBDOC)


class LibdocModelWriter(ModelWriter):

    def __init__(self, output, libdoc):
        self._output = output
        self._libdoc = libdoc

    def write(self, line):
        self._output.write('<script type="text/javascript">' + os.linesep)
        self.write_data()
        self._output.write('</script>' + os.linesep)

    def write_data(self):
        formatter = DocFormatter(self._libdoc.keywords, self._libdoc.doc,
                                 self._libdoc.doc_format)
        libdoc = JsonConverter(formatter).convert(self._libdoc)
        JsonWriter(self._output).write_json('libdoc = ', libdoc)


class JsonConverter(object):

    def __init__(self, doc_formatter):
        self._doc_formatter = doc_formatter

    def convert(self, libdoc):
        return {
            'name': libdoc.name,
            'doc': self._doc_formatter.html(libdoc.doc, intro=True),
            'version': libdoc.version,
            'named_args': libdoc.named_args,
            'scope': libdoc.scope,
            'generated': utils.get_timestamp(daysep='-', millissep=None),
            'inits': self._get_keywords(libdoc.inits),
            'keywords': self._get_keywords(libdoc.keywords)
        }

    def _get_keywords(self, keywords):
        return [self._convert_keyword(kw) for kw in keywords]

    def _convert_keyword(self, kw):
        return {
            'name': kw.name,
            'args': ', '.join(kw.args),
            'doc': self._doc_formatter.html(kw.doc),
            'shortdoc': kw.shortdoc
        }


class DocFormatter(object):
    _header_regexp = re.compile(r'<h2>(.+?)</h2>')
    _name_regexp = re.compile('`(.+?)`')

    def __init__(self, keywords, introduction, doc_format='ROBOT'):
        self._doc_to_html = DocToHtml(doc_format)
        self._targets = self._get_targets(keywords, introduction,
                                          doc_format == 'ROBOT')

    def _get_targets(self, keywords, introduction, robot_format):
        targets = utils.NormalizedDict({
            'introduction': 'Introduction',
            'library introduction': 'Introduction',
            'importing': 'Importing',
            'library importing': 'Importing',
            'shortcuts': 'Shortcuts',
            'keywords': 'Keywords'
        })
        for kw in keywords:
            targets[kw.name] = kw.name
        if robot_format:
            for header in self._yield_header_targets(introduction):
                targets[header] = header
        return targets

    def _yield_header_targets(self, introduction):
        for line in introduction.splitlines():
            line = line.strip()
            if line.startswith('= ') and line.endswith(' ='):
                yield line[1:-1].strip()

    def html(self, doc, intro=False):
        doc = self._doc_to_html(doc)
        if intro:
            doc = self._header_regexp.sub(r'<h2 id="\1">\1</h2>', doc)
        return self._name_regexp.sub(self._link_keywords, doc)

    def _link_keywords(self, match):
        name = match.group(1)
        if name in self._targets:
            return '<a href="#%s" class="name">%s</a>' % (self._targets[name], name)
        return '<span class="name">%s</span>' % name


class DocToHtml(object):

    def __init__(self, format):
        self._formatter =  self._get_formatter(format)


    def _get_formatter(self, format):
        try:
            return {'ROBOT': utils.html_format,
                    'TEXT': self._format_text,
                    'HTML': self._format_html,
                    'REST': self._format_rest}[format]
        except KeyError:
            raise DataError("Invalid documentation format '%s'." % format)

    def _format_text(self, doc):
        return '<p style="white-space: pre-wrap">%s</p>' % utils.html_escape(doc)

    def _format_html(self, doc):
        return '<div style="margin: 0">%s</div>' % doc

    def _format_rest(self, doc):
        try:
            from docutils.core import publish_parts
        except ImportError:
            raise DataError("reST format requires 'docutils' module to be installed.")
        parts = publish_parts(doc, writer_name='html')
        return self._format_html(parts['html_body'])

    def __call__(self, doc):
        return self._formatter(doc)

########NEW FILE########
__FILENAME__ = javabuilder
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError
from robot import utils

from .model import LibraryDoc, KeywordDoc


class JavaDocBuilder(object):

    def build(self, path):
        doc = ClassDoc(path)
        libdoc = LibraryDoc(name=doc.qualifiedName(),
                            doc=self._get_doc(doc),
                            version=self._get_version(doc),
                            scope=self._get_scope(doc),
                            doc_format=self._get_doc_format(doc))
        libdoc.keywords = self._keywords(doc)
        libdoc.inits = self._intializers(doc)
        return libdoc

    def _get_doc(self, doc):
        text = doc.getRawCommentText()
        return '\n'.join(line.strip() for line in text.splitlines())

    def _get_version(self, doc):
        return self._get_attr(doc, 'VERSION')

    def _get_scope(self, doc):
        return self._get_attr(doc, 'SCOPE', default='TESTCASE', upper=True)

    def _get_doc_format(self, doc):
        return self._get_attr(doc, 'DOC_FORMAT', upper=True)

    def _get_attr(self, doc, name, default='', upper=False):
        name = 'ROBOT_LIBRARY_' + name
        for field in doc.fields():
            if field.name() == name and field.isPublic():
                value = field.constantValue()
                if upper:
                    value = utils.normalize(value, ignore='_').upper()
                return value
        return default

    def _keywords(self, doc):
        return [self._keyword_doc(m) for m in doc.methods()]

    def _keyword_doc(self, method):
        return KeywordDoc(
            name=utils.printable_name(method.name(), code_style=True),
            args=list(self._yield_keyword_arguments(method)),
            doc=self._get_doc(method)
        )

    def _yield_keyword_arguments(self, method):
        for param in method.parameters():
            name = param.name()
            if param.type().dimension() == '[]':
                name = '*' + name
            yield name

    def _intializers(self, doc):
        inits = [self._keyword_doc(init) for init in doc.constructors()]
        if len(inits) == 1 and not inits[0].args:
            return []
        return inits


def ClassDoc(path):
    """Process the given Java source file and return ClassDoc instance.

    Processing is done using com.sun.tools.javadoc APIs. The usage has
    been figured out from sources at
    http://www.java2s.com/Open-Source/Java-Document/JDK-Modules-com.sun/tools/com.sun.tools.javadoc.htm

    Returned object implements com.sun.javadoc.ClassDoc interface, see
    http://java.sun.com/j2se/1.4.2/docs/tooldocs/javadoc/doclet/
    """
    try:
        from com.sun.tools.javadoc import JavadocTool, Messager, ModifierFilter
        from com.sun.tools.javac.util import List, Context
        from com.sun.tools.javac.code.Flags import PUBLIC
    except ImportError:
        raise DataError("Creating documentation from Java source files "
                        "requires 'tools.jar' to be in CLASSPATH.")
    context = Context()
    Messager.preRegister(context, 'libdoc')
    jdoctool = JavadocTool.make0(context)
    filter = ModifierFilter(PUBLIC)
    java_names = List.of(path)
    root = jdoctool.getRootDocImpl('en', 'utf-8', filter, java_names,
                                   List.nil(), False, List.nil(),
                                   List.nil(), False, False, True)
    return root.classes()[0]


########NEW FILE########
__FILENAME__ = model
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

from robot.utils import setter

from .writer import LibdocWriter
from .output import LibdocOutput


class LibraryDoc(object):

    def __init__(self, name='', doc='', version='', type='library',
                 scope='', named_args=False, doc_format=''):
        self.name = name
        self.doc = doc
        self.version = version
        self.type = type
        self.scope = scope
        self.named_args = named_args
        self.doc_format = doc_format
        self.inits = []
        self.keywords = []

    @setter
    def scope(self, scope):
        return {'TESTCASE': 'test case',
                'TESTSUITE': 'test suite',
                'GLOBAL': 'global'}.get(scope, scope)

    @setter
    def doc_format(self, format):
        return format or 'ROBOT'

    @setter
    def keywords(self, kws):
        return sorted(kws)

    def save(self, output=None, format='HTML'):
        with LibdocOutput(output, format) as outfile:
            LibdocWriter(format).write(self, outfile)


class KeywordDoc(object):

    def __init__(self, name='', args=None, doc=''):
        self.name = name
        self.args = args or []
        self.doc = doc

    @property
    def shortdoc(self):
        return self.doc.splitlines()[0] if self.doc else ''

    def __cmp__(self, other):
        return cmp(self.name.lower(), other.name.lower())

########NEW FILE########
__FILENAME__ = output
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import codecs


class LibdocOutput(object):

    def __init__(self, output_path, format):
        self._output_path = output_path
        self._format = format.upper()
        self._output_file = None

    def __enter__(self):
        if self._format == 'HTML':
            self._output_file = codecs.open(self._output_path, 'w', 'UTF-8')
            return self._output_file
        return self._output_path

    def __exit__(self, *exc_info):
        if self._output_file:
            self._output_file.close()

########NEW FILE########
__FILENAME__ = robotbuilder
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys

from robot.errors import DataError
from robot.running import TestLibrary, UserLibrary
from robot.parsing import disable_curdir_processing
from robot import utils

from .model import LibraryDoc, KeywordDoc


class LibraryDocBuilder(object):
    _argument_separator = '::'

    def build(self, library):
        name, args = self._split_library_name_and_args(library)
        lib = TestLibrary(name, args)
        libdoc = LibraryDoc(name=lib.name,
                            doc=self._get_doc(lib),
                            version=lib.version,
                            scope=lib.scope,
                            named_args=lib.supports_named_arguments,
                            doc_format=lib.doc_format)
        libdoc.inits = self._get_initializers(lib)
        libdoc.keywords = KeywordDocBuilder().build_keywords(lib)
        return libdoc

    def _split_library_name_and_args(self, library):
        args = library.split(self._argument_separator)
        name = args.pop(0)
        return self._normalize_library_path(name), args

    def _normalize_library_path(self, library):
        path = library.replace('/', os.sep)
        if os.path.exists(path):
            return os.path.abspath(path)
        return library

    def _get_doc(self, lib):
        return lib.doc or "Documentation for test library `%s`." % lib.name

    def _get_initializers(self, lib):
        if lib.init.arguments.maxargs:
            return [KeywordDocBuilder().build_keyword(lib.init)]
        return []


class ResourceDocBuilder(object):

    def build(self, path):
        res = self._import_resource(path)
        libdoc = LibraryDoc(name=res.name, doc=self._get_doc(res),
                            type='resource', named_args=True)
        libdoc.keywords = KeywordDocBuilder().build_keywords(res)
        return libdoc

    @disable_curdir_processing
    def _import_resource(self, path):
        return UserLibrary(self._find_resource_file(path))

    def _find_resource_file(self, path):
        if os.path.isfile(path):
            return path
        for dire in [item for item in sys.path if os.path.isdir(item)]:
            if os.path.isfile(os.path.join(dire, path)):
                return os.path.join(dire, path)
        raise DataError("Resource file '%s' does not exist." % path)

    def _get_doc(self, res):
        doc = res.doc or "Documentation for resource file `%s`." % res.name
        return utils.unescape(doc)


class KeywordDocBuilder(object):

    def build_keywords(self, lib):
        return [self.build_keyword(kw) for kw in lib.handlers.values()]

    def build_keyword(self, kw):
        return KeywordDoc(name=kw.name, args=self._get_args(kw), doc=kw.doc)

    def _get_args(self, kw):
        required, defaults = self._parse_args(kw)
        args = required + ['%s=%s' % item for item in defaults]
        varargs = self._normalize_arg(kw.arguments.varargs, kw.type)
        if varargs:
            args.append('*%s' % varargs)
        return args

    def _parse_args(self, kw):
        args = [self._normalize_arg(arg, kw.type) for arg in kw.arguments.names]
        default_count = len(kw.arguments.defaults)
        if not default_count:
            return args, []
        required = args[:-default_count]
        defaults = zip(args[-default_count:], kw.arguments.defaults)
        return required, defaults

    def _normalize_arg(self, arg, kw_type):
        if arg and kw_type == 'user':
            arg = arg[2:-1]  # strip ${} to make args look consistent
        return arg

########NEW FILE########
__FILENAME__ = specbuilder
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os.path

from robot.errors import DataError
from robot.utils import ET, ETSource

from .model import LibraryDoc, KeywordDoc


class SpecDocBuilder(object):

    def build(self, path):
        spec = self._parse_spec(path)
        libdoc = LibraryDoc(name=spec.get('name'),
                            type=spec.get('type'),
                            version=spec.find('version').text or '',
                            doc=spec.find('doc').text or '',
                            scope=spec.find('scope').text or '',
                            named_args=self._get_named_args(spec),
                            doc_format=spec.get('format', 'ROBOT'))
        libdoc.inits = self._create_keywords(spec, 'init')
        libdoc.keywords = self._create_keywords(spec, 'kw')
        return libdoc

    def _parse_spec(self, path):
        if not os.path.isfile(path):
            raise DataError("Spec file '%s' does not exist." % path)
        with ETSource(path) as source:
            root = ET.parse(source).getroot()
        if root.tag != 'keywordspec':
            raise DataError("Invalid spec file '%s'." % path)
        return root

    def _get_named_args(self, spec):
        elem = spec.find('namedargs')
        if elem is None:
            return False    # Backwards compatiblity with RF < 2.6.2
        return elem.text == 'yes'

    def _create_keywords(self, spec, path):
        return [self._create_keyword(elem) for elem in spec.findall(path)]

    def _create_keyword(self, elem):
        return KeywordDoc(name=elem.get('name', ''),
                          args=[a.text for a in elem.findall('arguments/arg')],
                          doc=elem.find('doc').text or '')

########NEW FILE########
__FILENAME__ = writer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError

from .htmlwriter import LibdocHtmlWriter
from .xmlwriter import LibdocXmlWriter


def LibdocWriter(format=None):
    format = (format or 'HTML').upper()
    if format == 'HTML':
        return LibdocHtmlWriter()
    if format == 'XML':
        return LibdocXmlWriter()
    raise DataError("Format must be either 'HTML' or 'XML', got '%s'." % format)

########NEW FILE########
__FILENAME__ = xmlwriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import XmlWriter, get_timestamp


class LibdocXmlWriter(object):

    def write(self, libdoc, outfile):
        writer = XmlWriter(outfile, encoding='UTF-8')
        writer.start('keywordspec', {'name': libdoc.name, 'type': libdoc.type,
                                     'format': libdoc.doc_format,
                                     'generated': get_timestamp(millissep=None)})
        writer.element('version', libdoc.version)
        writer.element('scope', libdoc.scope)
        writer.element('namedargs', 'yes' if libdoc.named_args else 'no')
        writer.element('doc', libdoc.doc)
        self._write_keywords('init', libdoc.inits, writer)
        self._write_keywords('kw', libdoc.keywords, writer)
        writer.end('keywordspec')
        writer.close()

    def _write_keywords(self, type, keywords, writer):
        for kw in keywords:
            writer.start(type, {'name': kw.name} if type == 'kw' else {})
            writer.start('arguments')
            for arg in kw.args:
                writer.element('arg', arg)
            writer.end('arguments')
            writer.element('doc', kw.doc)
            writer.end(type)

########NEW FILE########
__FILENAME__ = BuiltIn
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
import time

from robot.output import LOGGER, Message
from robot.errors import (ContinueForLoop, DataError, ExecutionFailed,
                          ExecutionFailures, ExitForLoop, PassExecution,
                          ReturnFromKeyword)
from robot import utils
from robot.utils import asserts
from robot.variables import is_var, is_list_var
from robot.running import Keyword, RUN_KW_REGISTER
from robot.running.context import EXECUTION_CONTEXTS
from robot.running.usererrorhandler import UserErrorHandler
from robot.version import get_version

if utils.is_jython:
    from java.lang import String, Number

try:
    bin  # available since Python 2.6
except NameError:
    def bin(integer):
        if not isinstance(integer, (int, long)):
            raise TypeError
        if integer >= 0:
            prefix = '0b'
        else:
            prefix = '-0b'
            integer = abs(integer)
        bins = []
        while integer > 1:
            integer, remainder = divmod(integer, 2)
            bins.append(str(remainder))
        bins.append(str(integer))
        return prefix + ''.join(reversed(bins))


def run_keyword_variant(resolve):
    def decorator(method):
        RUN_KW_REGISTER.register_run_keyword('BuiltIn', method.__name__, resolve)
        return method
    return decorator


class _Converter:

    def convert_to_integer(self, item, base=None):
        """Converts the given item to an integer number.

        If the given item is a string, it is by default expected to be an
        integer in base 10. Starting from Robot Framework 2.6 there are two
        ways to convert from other bases:

        1) Give base explicitly to the keyword as `base` argument.

        2) Prefix the given string with the base so that `0b` means binary
        (base 2), `0o` means octal (base 8), and `0x` means hex (base 16).
        The prefix is considered only when `base` argument is not given and
        may itself be prefixed with a plus or minus sign.

        The syntax is case-insensitive and possible spaces are ignored.

        Examples:
        | ${result} = | Convert To Integer | 100    |    | # Result is 100   |
        | ${result} = | Convert To Integer | FF AA  | 16 | # Result is 65450 |
        | ${result} = | Convert To Integer | 100    | 8  | # Result is 64    |
        | ${result} = | Convert To Integer | -100   | 2  | # Result is -4    |
        | ${result} = | Convert To Integer | 0b100  |    | # Result is 4     |
        | ${result} = | Convert To Integer | -0x100 |    | # Result is -256  |

        See also `Convert To Number`, `Convert To Binary`, `Convert To Octal`
        and `Convert To Hex`.
        """
        self._log_types(item)
        return self._convert_to_integer(item, base)

    def _convert_to_integer(self, orig, base=None):
        try:
            item = self._handle_java_numbers(orig)
            item, base = self._get_base(item, base)
            if base:
                return int(item, self._convert_to_integer(base))
            return int(item)
        except:
            raise RuntimeError("'%s' cannot be converted to an integer: %s"
                               % (orig, utils.get_error_message()))

    def _handle_java_numbers(self, item):
        if not utils.is_jython:
            return item
        if isinstance(item, String):
            return utils.unic(item)
        if isinstance(item, Number):
            return item.doubleValue()
        return item

    def _get_base(self, item, base):
        if not isinstance(item, basestring):
            return item, base
        item = utils.normalize(item)
        if item.startswith(('-', '+')):
            sign = item[0]
            item = item[1:]
        else:
            sign = ''
        bases = {'0b': 2, '0o': 8, '0x': 16}
        if base or not item.startswith(tuple(bases)):
            return sign+item, base
        return sign+item[2:], bases[item[:2]]

    def convert_to_binary(self, item, base=None, prefix=None, length=None):
        """Converts the given item to a binary string.

        The `item`, with an optional `base`, is first converted to an
        integer using `Convert To Integer` internally. After that it
        is converted to a binary number (base 2) represented as a
        string such as `'1011'`.

        The returned value can contain an optional `prefix` and can be
        required to be of minimum `length` (excluding the prefix and a
        possible minus sign). If the value is initially shorter than
        the required length, it is padded with zeros.

        Examples:
        | ${result} = | Convert To Binary | 10 |         |           | # Result is 1010   |
        | ${result} = | Convert To Binary | F  | base=16 | prefix=0b | # Result is 0b1111 |
        | ${result} = | Convert To Binary | -2 | prefix=B | length=4 | # Result is -B0010 |

        This keyword was added in Robot Framework 2.6. See also
        `Convert To Integer`, `Convert To Octal` and `Convert To Hex`.
        """
        return self._convert_to_bin_oct_hex(bin, item, base, prefix, length)

    def convert_to_octal(self, item, base=None, prefix=None, length=None):
        """Converts the given item to an octal string.

        The `item`, with an optional `base`, is first converted to an
        integer using `Convert To Integer` internally. After that it
        is converted to an octal number (base 8) represented as a
        string such as `'775'`.

        The returned value can contain an optional `prefix` and can be
        required to be of minimum `length` (excluding the prefix and a
        possible minus sign). If the value is initially shorter than
        the required length, it is padded with zeros.

        Examples:
        | ${result} = | Convert To Octal | 10 |            |          | # Result is 12      |
        | ${result} = | Convert To Octal | -F | base=16    | prefix=0 | # Result is -017    |
        | ${result} = | Convert To Octal | 16 | prefix=oct | length=4 | # Result is oct0020 |

        This keyword was added in Robot Framework 2.6. See also
        `Convert To Integer`, `Convert To Binary` and `Convert To Hex`.
        """
        return self._convert_to_bin_oct_hex(oct, item, base, prefix, length)

    def convert_to_hex(self, item, base=None, prefix=None, length=None,
                       lowercase=False):
        """Converts the given item to a hexadecimal string.

        The `item`, with an optional `base`, is first converted to an
        integer using `Convert To Integer` internally. After that it
        is converted to a hexadecimal number (base 16) represented as
        a string such as `'FF0A'`.

        The returned value can contain an optional `prefix` and can be
        required to be of minimum `length` (excluding the prefix and a
        possible minus sign). If the value is initially shorter than
        the required length, it is padded with zeros.

        By default the value is returned as an upper case string, but
        giving any non-empty value to the `lowercase` argument turns
        the value (but not the prefix) to lower case.

        Examples:
        | ${result} = | Convert To Hex | 255 |           |              | # Result is FF    |
        | ${result} = | Convert To Hex | -10 | prefix=0x | length=2     | # Result is -0x0A |
        | ${result} = | Convert To Hex | 255 | prefix=X | lowercase=yes | # Result is Xff   |

        This keyword was added in Robot Framework 2.6. See also
        `Convert To Integer`, `Convert To Binary` and `Convert To Octal`.
        """
        return self._convert_to_bin_oct_hex(hex, item, base, prefix, length,
                                            lowercase)

    def _convert_to_bin_oct_hex(self, method, item, base, prefix, length,
                                lowercase=False):
        self._log_types(item)
        ret = method(self._convert_to_integer(item, base)).upper()
        prefix = prefix or ''
        if ret[0] == '-':
            prefix = '-' + prefix
            ret = ret[1:]
        if len(ret) > 1:  # oct(0) -> '0' (i.e. has no prefix)
            prefix_length = {bin: 2, oct: 1, hex: 2}[method]
            ret = ret[prefix_length:]
        if length:
            ret = ret.rjust(self._convert_to_integer(length), '0')
        if lowercase:
            ret = ret.lower()
        return prefix + ret

    def convert_to_number(self, item, precision=None):
        """Converts the given item to a floating point number.

        If the optional `precision` is positive or zero, the returned number
        is rounded to that number of decimal digits. Negative precision means
        that the number is rounded to the closest multiple of 10 to the power
        of the absolute precision. The support for precision was added in
        Robot Framework 2.6.

        Examples:
        | ${result} = | Convert To Number | 42.512 |    | # Result is 42.512 |
        | ${result} = | Convert To Number | 42.512 | 1  | # Result is 42.5   |
        | ${result} = | Convert To Number | 42.512 | 0  | # Result is 43.0   |
        | ${result} = | Convert To Number | 42.512 | -1 | # Result is 40.0   |

        Notice that machines generally cannot store floating point numbers
        accurately. This may cause surprises with these numbers in general
        and also when they are rounded. For more information see, for example,
        this floating point arithmetic tutorial:
        http://docs.python.org/tutorial/floatingpoint.html

        If you need an integer number, use `Convert To Integer` instead.
        """
        self._log_types(item)
        return self._convert_to_number(item, precision)

    def _convert_to_number(self, item, precision=None):
        number = self._convert_to_number_without_precision(item)
        if precision:
            number = round(number, self._convert_to_integer(precision))
        return number

    def _convert_to_number_without_precision(self, item):
        try:
            if utils.is_jython:
                item = self._handle_java_numbers(item)
            return float(item)
        except:
            error = utils.get_error_message()
            try:
                return float(self._convert_to_integer(item))
            except RuntimeError:
                raise RuntimeError("'%s' cannot be converted to a floating "
                                   "point number: %s" % (item, error))

    def convert_to_string(self, item):
        """Converts the given item to a Unicode string.

        Uses '__unicode__' or '__str__' method with Python objects and
        'toString' with Java objects.

        Use `Encode String To Bytes` and `Decode Bytes To String` keywords
        in `String` library if you need to convert between Unicode and byte
        strings.
        """
        self._log_types(item)
        return self._convert_to_string(item)

    def _convert_to_string(self, item):
        return utils.unic(item)

    def convert_to_boolean(self, item):
        """Converts the given item to Boolean true or false.

        Handles strings 'True' and 'False' (case-insensitive) as expected,
        otherwise returns item's truth value using Python's 'bool' method.
        For more information about truth values, see
        http://docs.python.org/lib/truth.html.
        """
        self._log_types(item)
        if isinstance(item, basestring):
            if utils.eq(item, 'True'):
                return True
            if utils.eq(item, 'False'):
                return False
        return bool(item)

    def create_list(self, *items):
        """Returns a list containing given items.

        The returned list can be assigned both to ${scalar} and @{list}
        variables. The earlier can be used e.g. with Java keywords expecting
        an array as an argument.

        Examples:
        | @{list} =   | Create List | a    | b    | c    |
        | ${scalar} = | Create List | a    | b    | c    |
        | ${ints} =   | Create List | ${1} | ${2} | ${3} |
        """
        return list(items)


class _Verify:

    def _set_and_remove_tags(self, tags):
        set_tags = [tag for tag in tags if not tag.startswith('-')]
        remove_tags = [tag[1:] for tag in tags if tag.startswith('-')]
        if remove_tags:
            self.remove_tags(*remove_tags)
        if set_tags:
            self.set_tags(*set_tags)

    def fail(self, msg=None, *tags):
        """Fails the test with the given message and optionally alters its tags.

        The error message is specified using the `msg` argument.
        It is possible to use HTML in the given error message, similarly
        as with any other keyword accepting an error message, by prefixing
        the error with `*HTML*`.

        It is possible to modify tags of the current test case by passing tags
        after the message. Tags starting with a hyphen (e.g. `-regression`) are
        removed and others added. Tags are modified using `Set Tags` and
        `Remove Tags` internally, and the semantics setting and removing them
        are the same as with these keywords.

        Examples:
        | Fail | Test not ready   |             | | # Fails with the given message.    |
        | Fail | *HTML*<b>Test not ready</b> | | | # Fails using HTML in the message. |
        | Fail | Test not ready   | not-ready   | | # Fails and adds 'not-ready' tag.  |
        | Fail | OS not supported | -regression | | # Removes tag 'regression'.        |
        | Fail | My message       | tag    | -t*  | # Removes all tags starting with 't' except the newly added 'tag'. |

        See `Fatal Error` if you need to stop the whole test execution.

        Support for modifying tags was added in Robot Framework 2.7.4 and
        HTML message support in 2.8.
        """
        self._set_and_remove_tags(tags)
        raise AssertionError(msg) if msg else AssertionError()

    def fatal_error(self, msg=None):
        """Stops the whole test execution.

        The test or suite where this keyword is used fails with the provided
        message, and subsequent tests fail with a canned message.
        Possible teardowns will nevertheless be executed.

        See `Fail` if you only want to stop one test case unconditionally.
        """
        error = AssertionError(msg) if msg else AssertionError()
        error.ROBOT_EXIT_ON_FAILURE = True
        raise error

    def should_not_be_true(self, condition, msg=None):
        """Fails if the given condition is true.

        See `Should Be True` for details about how `condition` is evaluated and
        how `msg` can be used to override the default error message.
        """
        if not msg:
            msg = "'%s' should not be true" % condition
        asserts.fail_if(self._is_true(condition), msg)

    def should_be_true(self, condition, msg=None):
        """Fails if the given condition is not true.

        If `condition` is a string (e.g. '${rc} < 10'), it is evaluated as a
        Python expression using the built-in 'eval' function and the keyword
        status is decided based on the result. If a non-string item is given,
        the status is got directly from its truth value as explained at
        http://docs.python.org/lib/truth.html.

        The default error message ('<condition> should be true') is not very
        informative, but it can be overridden with the `msg` argument.

        Examples:
        | Should Be True | ${rc} < 10  |
        | Should Be True | '${status}' == 'PASS' | # Strings must be quoted |
        | Should Be True | ${number}   | # Passes if ${number} is not zero |
        | Should Be True | ${list}     | # Passes if ${list} is not empty  |

        Starting from Robot Framework 2.8, `Should Be True` automatically
        imports Python's os- and sys-modules:

        | Should Be True | os.linesep == '\\n' | # Is Unix |
        | Should Be True | os.linesep == '\\r\\n' | # Is Windows |
        | Should Be True | sys.platform == 'darwin' | # Is OS X |
        | Should Be True | sys.platform == 'linux2' | # Is Linux |
        """
        if not msg:
            msg = "'%s' should be true" % condition
        asserts.fail_unless(self._is_true(condition), msg)

    def should_be_equal(self, first, second, msg=None, values=True):
        """Fails if the given objects are unequal.

        - If `msg` is not given, the error message is 'first != second'.
        - If `msg` is given and `values` is either Boolean False or the
          string 'False' or 'No Values', the error message is simply `msg`.
        - Otherwise the error message is '`msg`: `first` != `second`'.
        """
        self._log_types(first, second)
        self._should_be_equal(first, second, msg, values)

    def _should_be_equal(self, first, second, msg, values):
        asserts.fail_unless_equal(first, second, msg,
                                  self._include_values(values))

    def _log_types(self, *args):
        msg = ["Argument types are:"] + [self._get_type(a) for a in args]
        self.log('\n'.join(msg))

    def _get_type(self, arg):
        # In IronPython type(u'x') is str. We want to report unicode anyway.
        if isinstance(arg, unicode):
            return "<type 'unicode'>"
        return str(type(arg))

    def _include_values(self, values):
        if isinstance(values, basestring):
            return values.lower() not in ['no values', 'false']
        return bool(values)

    def should_not_be_equal(self, first, second, msg=None, values=True):
        """Fails if the given objects are equal.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        self._log_types(first, second)
        self._should_not_be_equal(first, second, msg, values)

    def _should_not_be_equal(self, first, second, msg, values):
        asserts.fail_if_equal(first, second, msg, self._include_values(values))

    def should_not_be_equal_as_integers(self, first, second, msg=None,
                                        values=True, base=None):
        """Fails if objects are equal after converting them to integers.

        See `Convert To Integer` for information how to convert integers from
        other bases than 10 using `base` argument or `0b/0o/0x` prefixes.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.

        See `Should Be Equal As Integers` for some usage examples.
        """
        self._log_types(first, second)
        self._should_not_be_equal(self._convert_to_integer(first, base),
                                  self._convert_to_integer(second, base),
                                  msg, values)

    def should_be_equal_as_integers(self, first, second, msg=None, values=True,
                                    base=None):
        """Fails if objects are unequal after converting them to integers.

        See `Convert To Integer` for information how to convert integers from
        other bases than 10 using `base` argument or `0b/0o/0x` prefixes.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.

        Examples:
        | Should Be Equal As Integers | 42   | ${42} | Error message |
        | Should Be Equal As Integers | ABCD | abcd  | base=16 |
        | Should Be Equal As Integers | 0b1011 | 11  |
        """
        self._log_types(first, second)
        self._should_be_equal(self._convert_to_integer(first, base),
                              self._convert_to_integer(second, base),
                              msg, values)

    def should_not_be_equal_as_numbers(self, first, second, msg=None,
                                       values=True, precision=6):
        """Fails if objects are equal after converting them to real numbers.

        The conversion is done with `Convert To Number` keyword using the
        given `precision`. The support for giving precision was added in
        Robot Framework 2.6, in earlier versions it was hard-coded to 6.

        See `Should Be Equal As Numbers` for examples on how to use
        `precision` and why it does not always work as expected. See also
        `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        self._log_types(first, second)
        first = self._convert_to_number(first, precision)
        second = self._convert_to_number(second, precision)
        self._should_not_be_equal(first, second, msg, values)

    def should_be_equal_as_numbers(self, first, second, msg=None, values=True,
                                   precision=6):
        """Fails if objects are unequal after converting them to real numbers.

        The conversion is done with `Convert To Number` keyword using the
        given `precision`. The support for giving precision was added in
        Robot Framework 2.6, in earlier versions it was hard-coded to 6.

        Examples:
        | Should Be Equal As Numbers | ${x} | 1.1 | | # Passes if ${x} is 1.1 |
        | Should Be Equal As Numbers | 1.123 | 1.1 | precision=1  | # Passes |
        | Should Be Equal As Numbers | 1.123 | 1.4 | precision=0  | # Passes |
        | Should Be Equal As Numbers | 112.3 | 75  | precision=-2 | # Passes |

        As discussed in the documentation of `Convert To Number`, machines
        generally cannot store floating point numbers accurately. Because of
        this limitation, comparing floats for equality is problematic and
        a correct approach to use depends on the context. This keyword uses
        a very naive approach of rounding the numbers before comparing them,
        which is both prone to rounding errors and does not work very well if
        numbers are really big or small. For more information about comparing
        floats, and ideas on how to implement your own context specific
        comparison algorithm, see this great article:
        http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm

        See `Should Not Be Equal As Numbers` for a negative version of this
        keyword and `Should Be Equal` for an explanation on how to override
        the default error message with `msg` and `values`.
        """
        self._log_types(first, second)
        first = self._convert_to_number(first, precision)
        second = self._convert_to_number(second, precision)
        self._should_be_equal(first, second, msg, values)

    def should_not_be_equal_as_strings(self, first, second, msg=None, values=True):
        """Fails if objects are equal after converting them to strings.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        self._log_types(first, second)
        first, second = [self._convert_to_string(i) for i in first, second]
        self._should_not_be_equal(first, second, msg, values)

    def should_be_equal_as_strings(self, first, second, msg=None, values=True):
        """Fails if objects are unequal after converting them to strings.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        self._log_types(first, second)
        first, second = [self._convert_to_string(i) for i in first, second]
        self._should_be_equal(first, second, msg, values)

    def should_not_start_with(self, str1, str2, msg=None, values=True):
        """Fails if the string `str1` starts with the string `str2`.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        msg = self._get_string_msg(str1, str2, msg, values, 'starts with')
        asserts.fail_if(str1.startswith(str2), msg)

    def should_start_with(self, str1, str2, msg=None, values=True):
        """Fails if the string `str1` does not start with the string `str2`.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        msg = self._get_string_msg(str1, str2, msg, values, 'does not start with')
        asserts.fail_unless(str1.startswith(str2), msg)

    def should_not_end_with(self, str1, str2, msg=None, values=True):
        """Fails if the string `str1` ends with the string `str2`.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        msg = self._get_string_msg(str1, str2, msg, values, 'ends with')
        asserts.fail_if(str1.endswith(str2), msg)

    def should_end_with(self, str1, str2, msg=None, values=True):
        """Fails if the string `str1` does not end with the string `str2`.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        msg = self._get_string_msg(str1, str2, msg, values, 'does not end with')
        asserts.fail_unless(str1.endswith(str2), msg)

    def should_not_contain(self, item1, item2, msg=None, values=True):
        """Fails if `item1` contains `item2` one or more times.

        Works with strings, lists, and anything that supports Python's 'in'
        keyword. See `Should Be Equal` for an explanation on how to override
        the default error message with `msg` and `values`.

        Examples:
        | Should Not Contain | ${output}    | FAILED |
        | Should Not Contain | ${some_list} | value  |
        """
        msg = self._get_string_msg(item1, item2, msg, values, 'contains')
        asserts.fail_if(item2 in item1, msg)

    def should_contain(self, item1, item2, msg=None, values=True):
        """Fails if `item1` does not contain `item2` one or more times.

        Works with strings, lists, and anything that supports Python's 'in'
        keyword. See `Should Be Equal` for an explanation on how to override
        the default error message with `msg` and `values`.

        Examples:
        | Should Contain | ${output}    | PASS |
        | Should Contain | ${some_list} | value  |
        """
        msg = self._get_string_msg(item1, item2, msg, values, 'does not contain')
        asserts.fail_unless(item2 in item1, msg)

    def should_contain_x_times(self, item1, item2, count, msg=None):
        """Fails if `item1` does not contain `item2` `count` times.

        Works with strings, lists and all objects that `Get Count` works
        with. The default error message can be overridden with `msg` and
        the actual count is always logged.

        Examples:
        | Should Contain X Times | ${output}    | hello  | 2 |
        | Should Contain X Times | ${some list} | value  | 3 |
        """
        if not msg:
            msg = "'%s' does not contain '%s' %s times" \
                    % (utils.unic(item1), utils.unic(item2), count)
        self.should_be_equal_as_integers(self.get_count(item1, item2),
                                         count, msg, values=False)

    def get_count(self, item1, item2):
        """Returns and logs how many times `item2` is found from `item1`.

        This keyword works with Python strings and lists and all objects
        that either have 'count' method or can be converted to Python lists.

        Example:
        | ${count} = | Get Count | ${some item} | interesting value |
        | Should Be True | 5 < ${count} < 10 |
        """
        if not hasattr(item1, 'count'):
            try:
                item1 = list(item1)
            except:
                raise RuntimeError("Converting '%s' to list failed: %s"
                                % (item1, utils.get_error_message()))
        count = item1.count(item2)
        self.log('Item found from the first item %d time%s'
                 % (count, utils.plural_or_not(count)))
        return count

    def should_not_match(self, string, pattern, msg=None, values=True):
        """Fails if the given `string` matches the given `pattern`.

        Pattern matching is similar as matching files in a shell, and it is
        always case-sensitive. In the pattern '*' matches to anything and '?'
        matches to any single character.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        msg = self._get_string_msg(string, pattern, msg, values, 'matches')
        asserts.fail_if(self._matches(string, pattern), msg)

    def should_match(self, string, pattern, msg=None, values=True):
        """Fails unless the given `string` matches the given `pattern`.

        Pattern matching is similar as matching files in a shell, and it is
        always case-sensitive. In the pattern, '*' matches to anything and '?'
        matches to any single character.

        See `Should Be Equal` for an explanation on how to override the default
        error message with `msg` and `values`.
        """
        msg = self._get_string_msg(string, pattern, msg, values,
                                   'does not match')
        asserts.fail_unless(self._matches(string, pattern), msg)

    def should_match_regexp(self, string, pattern, msg=None, values=True):
        """Fails if `string` does not match `pattern` as a regular expression.

        Regular expression check is done using the Python 're' module, which
        has a pattern syntax derived from Perl, and thus also very similar to
        the one in Java. See the following documents for more details about
        regular expressions in general and Python implementation in particular.

        | http://docs.python.org/lib/module-re.html
        | http://www.amk.ca/python/howto/regex/

        Things to note about the regexp syntax in Robot Framework test data:

        1) Backslash is an escape character in the test data, and possible
        backslashes in the pattern must thus be escaped with another backslash
        (e.g. '\\\\d\\\\w+').

        2) Strings that may contain special characters, but should be handled
        as literal strings, can be escaped with the `Regexp Escape` keyword.

        3) The given pattern does not need to match the whole string. For
        example, the pattern 'ello' matches the string 'Hello world!'. If
        a full match is needed, the '^' and '$' characters can be used to
        denote the beginning and end of the string, respectively. For example,
        '^ello$' only matches the exact string 'ello'.

        4) Possible flags altering how the expression is parsed (e.g.
        re.IGNORECASE, re.MULTILINE) can be set by prefixing the pattern with
        the '(?iLmsux)' group (e.g. '(?im)pattern'). The available flags are
        'IGNORECASE': 'i', 'MULTILINE': 'm', 'DOTALL': 's', 'VERBOSE': 'x',
        'UNICODE': 'u', and 'LOCALE': 'L'.

        If this keyword passes, it returns the portion of the string that
        matched the pattern. Additionally, the possible captured groups are
        returned.

        See the `Should Be Equal` keyword for an explanation on how to override
        the default error message with the `msg` and `values` arguments.

        Examples:
        | Should Match Regexp | ${output} | \\\\d{6}   | # Output contains six numbers  |
        | Should Match Regexp | ${output} | ^\\\\d{6}$ | # Six numbers and nothing more |
        | ${ret} = | Should Match Regexp | Foo: 42 | (?i)foo: \\\\d+ |
        | ${match} | ${group1} | ${group2} = |
        | ...      | Should Match Regexp | Bar: 43 | (Foo|Bar): (\\\\d+) |
        =>
        | ${ret} = 'Foo: 42'
        | ${match} = 'Bar: 43'
        | ${group1} = 'Bar'
        | ${group2} = '43'
        """
        msg = self._get_string_msg(string, pattern, msg, values, 'does not match')
        res = re.search(pattern, string)
        asserts.fail_if_none(res, msg, False)
        match = res.group(0)
        groups = res.groups()
        if groups:
            return [match] + list(groups)
        return match

    def should_not_match_regexp(self, string, pattern, msg=None, values=True):
        """Fails if `string` matches `pattern` as a regular expression.

        See `Should Match Regexp` for more information about arguments.
        """
        msg = self._get_string_msg(string, pattern, msg, values, 'matches')
        asserts.fail_unless_none(re.search(pattern, string), msg, False)

    def get_length(self, item):
        """Returns and logs the length of the given item.

        The item can be anything that has a length, for example, a string,
        a list, or a mapping. The keyword first tries to get the length with
        the Python function `len`, which calls the  item's `__len__` method
        internally. If that fails, the keyword tries to call the item's
        possible `length` and `size` methods directly. The final attempt is
        trying to get the value of the item's `length` attribute. If all
        these attempts are unsuccessful, the keyword fails.

        It is possible to use this keyword also with list variables (e.g.
        `@{LIST}`), but you need to use them as scalars (e.g. `${LIST}`).
        """
        length = self._get_length(item)
        self.log('Length is %d' % length)
        return length

    def _get_length(self, item):
        try: return len(item)
        except utils.RERAISED_EXCEPTIONS: raise
        except:
            try: return item.length()
            except utils.RERAISED_EXCEPTIONS: raise
            except:
                try: return item.size()
                except utils.RERAISED_EXCEPTIONS: raise
                except:
                    try: return item.length
                    except utils.RERAISED_EXCEPTIONS: raise
                    except:
                        raise RuntimeError("Could not get length of '%s'" % item)

    def length_should_be(self, item, length, msg=None):
        """Verifies that the length of the given item is correct.

        The length of the item is got using the `Get Length` keyword. The
        default error message can be overridden with the `msg` argument.
        """
        length = self._convert_to_integer(length)
        actual = self.get_length(item)
        if actual != length:
            raise AssertionError(msg or "Length of '%s' should be %d but is %d"
                                        % (item, length, actual))

    def should_be_empty(self, item, msg=None):
        """Verifies that the given item is empty.

        The length of the item is got using the `Get Length` keyword. The
        default error message can be overridden with the `msg` argument.
        """
        if self.get_length(item) > 0:
            raise AssertionError(msg or "'%s' should be empty" % item)

    def should_not_be_empty(self, item, msg=None):
        """Verifies that the given item is not empty.

        The length of the item is got using the `Get Length` keyword. The
        default error message can be overridden with the `msg` argument.
        """
        if self.get_length(item) == 0:
            raise AssertionError(msg or "'%s' should not be empty" % item)

    def _get_string_msg(self, str1, str2, msg, values, delim):
        default = "'%s' %s '%s'" % (utils.unic(str1), delim, utils.unic(str2))
        if not msg:
            msg = default
        elif values is True:
            msg = '%s: %s' % (msg, default)
        return msg


class _Variables:

    def get_variables(self):
        """Returns a dictionary containing all variables in the current scope.

        Variables are returned as a special dictionary that allows accessing
        variables in space, case, and underscore insensitive manner similarly
        as accessing variables in the test data. This dictionary supports all
        same operations as normal Python dictionaries and, for example,
        Collections library can be used to access or modify it. Modifying the
        returned dictionary has no effect on the variables available in the
        current scope.

        Example:
        | ${example_variable} =         | Set Variable | example value         |
        | ${variables} =                | Get Variables |                      |
        | Dictionary Should Contain Key | ${variables} | \\${example_variable} |
        | Dictionary Should Contain Key | ${variables} | \\${ExampleVariable}  |
        | Set To Dictionary             | ${variables} | \\${name} | value     |
        | Variable Should Not Exist     | \\${name}    |           |           |

        Note: Prior to Robot Framework 2.7.4 variables were returned as
        a custom object that did not support all dictionary methods.
        """
        return utils.NormalizedDict(self._variables.current, ignore='_')

    @run_keyword_variant(resolve=0)
    def get_variable_value(self, name, default=None):
        """Returns variable value or `default` if the variable does not exist.

        The name of the variable can be given either as a normal variable name
        (e.g. `${NAME}`) or in escaped format (e.g. `\\${NAME}`). Notice that
        the former has some limitations explained in `Set Suite Variable`.

        Examples:
        | ${x} = | Get Variable Value | ${a} | default |
        | ${y} = | Get Variable Value | ${a} | ${b}    |
        | ${z} = | Get Variable Value | ${z} |         |
        =>
        | ${x} gets value of ${a} if ${a} exists and string "default" otherwise
        | ${y} gets value of ${a} if ${a} exists and value of ${b} otherwise
        | ${z} is set to Python `None` if it does not exist previously

        This keyword was added in Robot Framework 2.6. See `Set Variable If`
        for another keyword to set variables dynamically.
        """
        try:
            return self._variables[self._get_var_name(name)]
        except DataError:
            return self._variables.replace_scalar(default)

    def log_variables(self, level='INFO'):
        """Logs all variables in the current scope with given log level."""
        variables = self.get_variables()
        for name in sorted(variables.keys(), key=lambda s: s.lower()):
            msg = utils.format_assign_message(name, variables[name],
                                              cut_long=False)
            self.log(msg, level)

    @run_keyword_variant(resolve=0)
    def variable_should_exist(self, name, msg=None):
        """Fails unless the given variable exists within the current scope.

        The name of the variable can be given either as a normal variable name
        (e.g. `${NAME}`) or in escaped format (e.g. `\\${NAME}`). Notice that
        the former has some limitations explained in `Set Suite Variable`.

        The default error message can be overridden with the `msg` argument.

        See also `Variable Should Not Exist` and `Keyword Should Exist`.
        """
        name = self._get_var_name(name)
        msg = self._variables.replace_string(msg) if msg \
            else "Variable %s does not exist" % name
        asserts.fail_unless(name in self._variables, msg)

    @run_keyword_variant(resolve=0)
    def variable_should_not_exist(self, name, msg=None):
        """Fails if the given variable exists within the current scope.

        The name of the variable can be given either as a normal variable name
        (e.g. `${NAME}`) or in escaped format (e.g. `\\${NAME}`). Notice that
        the former has some limitations explained in `Set Suite Variable`.

        The default error message can be overridden with the `msg` argument.

        See also `Variable Should Exist` and `Keyword Should Exist`.
        """
        name = self._get_var_name(name)
        msg = self._variables.replace_string(msg) if msg \
            else "Variable %s exists" % name
        asserts.fail_if(name in self._variables, msg)

    def replace_variables(self, text):
        """Replaces variables in the given text with their current values.

        If the text contains undefined variables, this keyword fails.
        If the given `text` contains only a single variable, its value is
        returned as-is and it can be any object. Otherwise this keyword
        always returns a string.

        Example:

        The file 'template.txt' contains 'Hello ${NAME}!' and variable
        '${NAME}' has the value 'Robot'.

        | ${template} =   | Get File          | ${CURDIR}/template.txt |
        | ${message} =    | Replace Variables | ${template}            |
        | Should Be Equal | ${message}        | Hello Robot!           |
        """
        return self._variables.replace_scalar(text)

    def set_variable(self, *values):
        """Returns the given values which can then be assigned to a variables.

        This keyword is mainly used for setting scalar variables.
        Additionally it can be used for converting a scalar variable
        containing a list to a list variable or to multiple scalar variables.
        It is recommended to use `Create List` when creating new lists.

        Examples:
        | ${hi} =   | Set Variable | Hello, world! |
        | ${hi2} =  | Set Variable | I said: ${hi} |
        | ${var1}   | ${var2} =    | Set Variable | Hello | world |
        | @{list} = | Set Variable | ${list with some items} |
        | ${item1}  | ${item2} =   | Set Variable  | ${list with 2 items} |

        Variables created with this keyword are available only in the
        scope where they are created. See `Set Global Variable`,
        `Set Test Variable` and `Set Suite Variable` for information on how to
        set variables so that they are available also in a larger scope.
        """
        if len(values) == 0:
            return ''
        elif len(values) == 1:
            return values[0]
        else:
            return list(values)

    @run_keyword_variant(resolve=0)
    def set_test_variable(self, name, *values):
        """Makes a variable available everywhere within the scope of the current test.

        Variables set with this keyword are available everywhere within the
        scope of the currently executed test case. For example, if you set a
        variable in a user keyword, it is available both in the test case level
        and also in all other user keywords used in the current test. Other
        test cases will not see variables set with this keyword.

        See `Set Suite Variable` for more information and examples.
        """
        name = self._get_var_name(name)
        value = self._get_var_value(name, values)
        self._variables.set_test(name, value)
        self._log_set_variable(name, value)

    @run_keyword_variant(resolve=0)
    def set_suite_variable(self, name, *values):
        """Makes a variable available everywhere within the scope of the current suite.

        Variables set with this keyword are available everywhere within the
        scope of the currently executed test suite. Setting variables with this
        keyword thus has the same effect as creating them using the Variable
        table in the test data file or importing them from variable files.
        Other test suites, including possible child test suites, will not see
        variables set with this keyword.

        The name of the variable can be given either as a normal variable name
        (e.g. `${NAME}`) or in escaped format as `\\${NAME}` or `$NAME`.

        If a variable already exists within the new scope, its value will be
        overwritten. Otherwise a new variable is created. If a variable already
        exists within the current scope, the value can be left empty and the
        variable within the new scope gets the value within the current scope.

        Examples:
        | Set Suite Variable | ${GREET} | Hello, world! |
        | Set Suite Variable | @{LIST}  | First item    | Second item |
        | ${ID} =            | Get ID   |
        | Set Suite Variable | ${ID}    |

        To override an existing value with an empty value, use built-in
        variables `${EMPTY}` or `@{EMPTY}`:

        | Set Suite Variable | ${GREET} | ${EMPTY} |
        | Set Suite Variable | @{LIST}  | @{EMPTY} | # New in RF 2.7.4 |

        *NOTE:* If the variable has value which itself is a variable (escaped
        or not), you must always use the escaped format to reset the variable:

        Example:
        | ${NAME} =          | Set Variable | \${var} |
        | Set Suite Variable | ${NAME}      | value | # Sets variable ${var}  |
        | Set Suite Variable | \${NAME}     | value | # Sets variable ${NAME} |

        This limitation applies also to `Set Test/Suite/Global Variable`,
        `Variable Should (Not) Exist`, and `Get Variable Value` keywords.
        """
        name = self._get_var_name(name)
        value = self._get_var_value(name, values)
        self._variables.set_suite(name, value)
        self._log_set_variable(name, value)

    @run_keyword_variant(resolve=0)
    def set_global_variable(self, name, *values):
        """Makes a variable available globally in all tests and suites.

        Variables set with this keyword are globally available in all test
        cases and suites executed after setting them. Setting variables with
        this keyword thus has the same effect as creating from the command line
        using the options '--variable' or '--variablefile'. Because this
        keyword can change variables everywhere, it should be used with care.

        See `Set Suite Variable` for more information and examples.
        """
        name = self._get_var_name(name)
        value = self._get_var_value(name, values)
        self._variables.set_global(name, value)
        self._log_set_variable(name, value)

    # Helpers

    def _get_var_name(self, orig):
        name = self._resolve_possible_variable(orig)
        try:
            return self._unescape_variable_if_needed(name)
        except ValueError:
            raise RuntimeError("Invalid variable syntax '%s'" % orig)

    def _resolve_possible_variable(self, name):
        try:
            resolved = self._variables[name]
            return self._unescape_variable_if_needed(resolved)
        except (KeyError, ValueError, DataError):
            return name

    def _unescape_variable_if_needed(self, name):
        if not (isinstance(name, basestring) and len(name) > 1):
            raise ValueError
        if name.startswith('\\'):
            name = name[1:]
        elif name[0] in ['$','@'] and name[1] != '{':
            name = '%s{%s}' % (name[0], name[1:])
        if is_var(name):
            return name
        # Support for possible internal variables (issue 397)
        name = '%s{%s}' % (name[0], self.replace_variables(name[2:-1]))
        if is_var(name):
            return name
        raise ValueError

    def _get_var_value(self, name, values):
        if not values:
            return self._variables[name]
        values = self._variables.replace_list(values)
        if len(values) == 1 and name[0] == '$':
            return values[0]
        return list(values)

    def _log_set_variable(self, name, value):
        self.log(utils.format_assign_message(name, value))


class _RunKeyword:

    # If you use any of these run keyword variants from another library, you
    # should register those keywords with 'register_run_keyword' method. See
    # the documentation of that method at the end of this file. There are also
    # other run keyword variant keywords in BuiltIn which can also be seen
    # at the end of this file.

    def run_keyword(self, name, *args):
        """Executes the given keyword with the given arguments.

        Because the name of the keyword to execute is given as an argument, it
        can be a variable and thus set dynamically, e.g. from a return value of
        another keyword or from the command line.
        """
        if not isinstance(name, basestring):
            raise RuntimeError('Keyword name must be a string.')
        kw = Keyword(name, list(args))
        return kw.run(self._context)

    def run_keywords(self, *keywords):
        """Executes all the given keywords in a sequence.

        This keyword is mainly useful in setups and teardowns when they need to
        take care of multiple actions and creating a new higher level user
        keyword would be an overkill.

        Examples:
        | Run Keywords | Initialize database | Start servers | Clear logs |
        | Run Keywords | ${KW 1} | ${KW 2} |
        | Run Keywords | @{KEYWORDS} |

        In this example, we call `Run Keywords` with three different combination
        of arguments. Keyword names and arguments can come from variables, as
        demonstrated in the second and third row.

        Starting from Robot Framework 2.7.6, keywords can also be run with
        arguments using upper case `AND` as a separator between keywords.
        The keywords are executed so that the first argument is the first
        keyword and proceeding arguments until the first `AND` are arguments
        to it. First argument after the first `AND` is the second keyword and
        proceeding arguments until the next `AND` are its arguments. And so on.

        Examples:
        | Run Keywords | Initialize database | db1 | AND | Start servers | server1 | server2 |
        | Run Keywords | Initialize database | ${DB NAME} | AND | Start servers | @{SERVERS} | AND | Clear logs |
        | Run Keywords | ${KW} | AND | @{KW WITH ARGS} |

        Notice that the `AND` control argument must be used explicitly and thus
        cannot itself come from a variable. If you need to use literal `AND`
        string as argument, you can either use variables or escape it with
        a backslash like `\\AND`.
        """
        errors = []
        for kw, args in self._split_run_keywords(list(keywords)):
            try:
                self.run_keyword(kw, *args)
            except ExecutionFailed, err:
                errors.extend(err.get_errors())
                if not err.can_continue(self._context.in_teardown):
                    break
        if errors:
            raise ExecutionFailures(errors)

    def _split_run_keywords(self, keywords):
        if 'AND' not in keywords:
            for name in self._variables.replace_list(keywords):
                yield name, ()
        else:
            for name, args in self._split_run_keywords_from_and(keywords):
                yield name, args

    def _split_run_keywords_from_and(self, keywords):
        while 'AND' in keywords:
            index = keywords.index('AND')
            yield self._resolve_run_keywords_name_and_args(keywords[:index])
            keywords = keywords[index+1:]
        yield self._resolve_run_keywords_name_and_args(keywords)

    def _resolve_run_keywords_name_and_args(self, kw_call):
        kw_call = self._variables.replace_list(kw_call, replace_until=1)
        if not kw_call:
            raise DataError('Incorrect use of AND')
        return kw_call[0], kw_call[1:]

    def run_keyword_if(self, condition, name, *args):
        """Runs the given keyword with the given arguments, if `condition` is true.

        The given `condition` is evaluated similarly as with `Should Be
        True` keyword, and `name` and `*args` have same semantics as with
        `Run Keyword`.

        Example, a simple if/else construct:
        | ${status} | ${value} = | `Run Keyword And Ignore Error` | `My Keyword` |
        | `Run Keyword If`     | '${status}' == 'PASS' | `Some Action`    | arg |
        | `Run Keyword Unless` | '${status}' == 'PASS' | `Another Action` |

        In this example, only either `Some Action` or `Another Action` is
        executed, based on the status of `My Keyword`. Instead of `Run Keyword
        And Ignore Error` you can also use `Run Keyword And Return Status`.

        Starting from Robot version 2.7.4, this keyword supports also optional
        ELSE and ELSE IF branches. Both of these are defined in `*args` and must
        use exactly format `ELSE` or `ELSE IF`, respectively. ELSE branches
        must contain first the name of the keyword to execute and then its
        possible arguments. ELSE IF branches must first contain a condition,
        like the first argument to this keyword, and then the keyword to execute
        and its possible arguments. It is possible to have ELSE branch after
        ELSE IF and to have multiple ELSE IF branches.

        Given previous example, if/else construct can also be created like this:
        | ${status} | ${value} = | `Run Keyword And Ignore Error` | My Keyword |
        | `Run Keyword If` | '${status}' == 'PASS' | `Some Action` | arg | ELSE | `Another Action` |

        Using ELSE and/or ELSE IF branches is especially handy if you are
        interested in the return value. This is illustrated by the example
        below that also demonstrates using ELSE IF and ELSE together:

        | ${result} = | `Run Keyword If` | ${rc} == 0  | `Zero return value` |
        | ...         | ELSE IF          | 0 < ${rc} < 42 | `Normal return value` |
        | ...         | ELSE IF          | ${rc} < 0      | `Negative return value` | ${rc} | arg2 |
        | ...         | ELSE             | `Abnormal return value` | ${rc} |

        Notice that ELSE and ELSE IF control arguments must be used explicitly
        and thus cannot come from variables. If you need to use literal ELSE
        and ELSE IF strings as arguments, you can either use variables or
        escape them with a backslash like `\\ELSE` and `\\ELSE IF`.

        Starting from Robot Framework 2.8, Python's os- and sys-modules are automatically
        imported when evaluating the `condition`:

        | `Run Keyword If` | os.sep == '/' | `Unix Keyword` |
        | ...              | ELSE          | `Windows Keyword` |
        """
        args, branch = self._split_elif_or_else_branch(args)
        if self._is_true(condition):
            return self.run_keyword(name, *args)
        return branch()

    def _split_elif_or_else_branch(self, args):
        if 'ELSE IF' in args:
            args, branch = self._split_branch(args, 'ELSE IF', 2,
                                              'condition and keyword')
            return args, lambda: self.run_keyword_if(*branch)
        if 'ELSE' in args:
            args, branch = self._split_branch(args, 'ELSE', 1, 'keyword')
            return args, lambda: self.run_keyword(*branch)
        return args, lambda: None

    def _split_branch(self, args, control_word, required, required_error):
        index = list(args).index(control_word)
        branch = self._variables.replace_list(args[index+1:], required)
        if len(branch) < required:
            raise DataError('%s requires %s.' % (control_word, required_error))
        return args[:index], branch

    def run_keyword_unless(self, condition, name, *args):
        """Runs the given keyword with the given arguments, if `condition` is false.

        See `Run Keyword If` for more information and an example.
        """
        if not self._is_true(condition):
            return self.run_keyword(name, *args)

    def run_keyword_and_ignore_error(self, name, *args):
        """Runs the given keyword with the given arguments and ignores possible error.

        This keyword returns two values, so that the first is either 'PASS' or
        'FAIL', depending on the status of the executed keyword. The second
        value is either the return value of the keyword or the received error
        message. See `Run Keyword And Return Status` If you are only interested
        in the execution status.

        The keyword name and arguments work as in `Run Keyword`. See
        `Run Keyword If` for a usage example.

        Starting from Robot Framework 2.5 errors caused by invalid syntax,
        timeouts, or fatal exceptions are not caught by this keyword.
        """
        try:
            return 'PASS', self.run_keyword(name, *args)
        except ExecutionFailed, err:
            if err.dont_continue:
                raise
            return 'FAIL', unicode(err)

    def run_keyword_and_return_status(self, name, *args):
        """Runs the given keyword with given arguments and returns the status as a Boolean value.

        This keyword returns `True` if the keyword that is executed succeeds and
        `False` if it fails. This is useful, for example, in combination with
        `Run Keyword If`. If you are interested in the error message or return
        value, use `Run Keyword And Ignore Error` instead.

        The keyword name and arguments work as in `Run Keyword`.

        Example:
        | ${passed} = | `Run Keyword And Return Status` | Keyword | args |
        | `Run Keyword If` | ${passed} | Another keyword |

        New in Robot Framework 2.7.6.
        """
        status, _ = self.run_keyword_and_ignore_error(name, *args)
        return status == 'PASS'

    def run_keyword_and_continue_on_failure(self, name, *args):
        """Runs the keyword and continues execution even if a failure occurs.

        The keyword name and arguments work as with `Run Keyword`.

        Example:
        | Run Keyword And Continue On Failure | Fail | This is a stupid example |
        | Log | This keyword is executed |

        This keyword was added in Robot Framework 2.5. The execution is not
        continued if the failure is caused by invalid syntax, timeout, or
        fatal exception.
        """
        try:
            return self.run_keyword(name, *args)
        except ExecutionFailed, err:
            if not err.dont_continue:
                err.continue_on_failure = True
            raise err

    def run_keyword_and_expect_error(self, expected_error, name, *args):
        """Runs the keyword and checks that the expected error occurred.

        The expected error must be given in the same format as in
        Robot Framework reports. It can be a pattern containing
        characters '?', which matches to any single character and
        '*', which matches to any number of any characters. `name` and
        `*args` have same semantics as with `Run Keyword`.

        If the expected error occurs, the error message is returned and it can
        be further processed/tested, if needed. If there is no error, or the
        error does not match the expected error, this keyword fails.

        Examples:
        | Run Keyword And Expect Error | My error | Some Keyword | arg1 | arg2 |
        | ${msg} = | Run Keyword And Expect Error | * | My KW |
        | Should Start With | ${msg} | Once upon a time in |

        Starting from Robot Framework 2.5 errors caused by invalid syntax,
        timeouts, or fatal exceptions are not caught by this keyword.
        """
        try:
            self.run_keyword(name, *args)
        except ExecutionFailed, err:
            if err.dont_continue:
                raise
        else:
            raise AssertionError("Expected error '%s' did not occur"
                                 % expected_error)
        if not self._matches(unicode(err), expected_error):
            raise AssertionError("Expected error '%s' but got '%s'"
                                 % (expected_error, err))
        return unicode(err)

    def repeat_keyword(self, times, name, *args):
        """Executes the specified keyword multiple times.

        `name` and `args` define the keyword that is executed
        similarly as with `Run Keyword`, and `times` specifies how many
        the keyword should be executed. `times` can be given as an
        integer or as a string that can be converted to an integer. It
        can also have postfix 'times' or 'x' (case and space
        insensitive) to make the expression easier to read.

        If `times` is zero or negative, the keyword is not executed at
        all. This keyword fails immediately if any of the execution
        rounds fails.

        Examples:
        | Repeat Keyword | 5 times | Goto Previous Page |
        | Repeat Keyword | ${var}  | Some Keyword | arg1 | arg2 |
        """
        times = utils.normalize(str(times))
        if times.endswith('times'):
            times = times[:-5]
        elif times.endswith('x'):
            times = times[:-1]
        times = self._convert_to_integer(times)
        if times <= 0:
            self.log("Keyword '%s' repeated zero times" % name)
        for i in xrange(times):
            self.log("Repeating keyword, round %d/%d" % (i+1, times))
            self.run_keyword(name, *args)

    def wait_until_keyword_succeeds(self, timeout, retry_interval, name, *args):
        """Waits until the specified keyword succeeds or the given timeout expires.

        `name` and `args` define the keyword that is executed
        similarly as with `Run Keyword`. If the specified keyword does
        not succeed within `timeout`, this keyword fails.
        `retry_interval` is the time to wait before trying to run the
        keyword again after the previous run has failed.

        Both `timeout` and `retry_interval` must be given in Robot Framework's
        time format (e.g. '1 minute', '2 min 3 s', '4.5').

        Errors caused by invalid syntax, test or keyword timeouts, or fatal
        exceptions are not caught by this keyword.

        Example:
        | Wait Until Keyword Succeeds | 2 min | 5 sec | My keyword | arg1 | arg2 |

        Running the same keyword multiple times inside this keyword can create
        lots of output and considerably increase the size of the generated
        output files. Starting from Robot Framework 2.7, it is possible to
        remove unnecessary keywords from the outputs using
        `--RemoveKeywords WUKS` command line option.
        """
        timeout = utils.timestr_to_secs(timeout)
        retry_interval = utils.timestr_to_secs(retry_interval)
        maxtime = time.time() + timeout
        error = None
        while not error:
            try:
                return self.run_keyword(name, *args)
            except ExecutionFailed, err:
                if err.dont_continue:
                    raise
                if time.time() > maxtime:
                    error = unicode(err)
                else:
                    time.sleep(retry_interval)
        raise AssertionError("Timeout %s exceeded. The last error was: %s"
                             % (utils.secs_to_timestr(timeout), error))

    def set_variable_if(self, condition, *values):
        """Sets variable based on the given condition.

        The basic usage is giving a condition and two values. The
        given condition is first evaluated the same way as with the
        `Should Be True` keyword. If the condition is true, then the
        first value is returned, and otherwise the second value is
        returned. The second value can also be omitted, in which case
        it has a default value None. This usage is illustrated in the
        examples below, where `${rc}` is assumed to be zero.

        | ${var1} = | Set Variable If | ${rc} == 0 | zero     | nonzero |
        | ${var2} = | Set Variable If | ${rc} > 0  | value1   | value2  |
        | ${var3} = | Set Variable If | ${rc} > 0  | whatever |         |
        =>
        | ${var1} = 'zero'
        | ${var2} = 'value2'
        | ${var3} = None

        It is also possible to have 'Else If' support by replacing the
        second value with another condition, and having two new values
        after it. If the first condition is not true, the second is
        evaluated and one of the values after it is returned based on
        its truth value. This can be continued by adding more
        conditions without a limit.

        | ${var} = | Set Variable If | ${rc} == 0        | zero           |
        | ...      | ${rc} > 0       | greater than zero | less then zero |
        |          |
        | ${var} = | Set Variable If |
        | ...      | ${rc} == 0      | zero              |
        | ...      | ${rc} == 1      | one               |
        | ...      | ${rc} == 2      | two               |
        | ...      | ${rc} > 2       | greater than two  |
        | ...      | ${rc} < 0       | less than zero    |

        Use `Get Variable Value` if you need to set variables
        dynamically based on whether a variable exist or not.
        """
        values = self._verify_values_for_set_variable_if(list(values))
        if self._is_true(condition):
            return self._variables.replace_scalar(values[0])
        values = self._verify_values_for_set_variable_if(values[1:], True)
        if len(values) == 1:
            return self._variables.replace_scalar(values[0])
        return self.run_keyword('BuiltIn.Set Variable If', *values[0:])

    def _verify_values_for_set_variable_if(self, values, default=False):
        if not values:
            if default:
                return [None]
            raise RuntimeError('At least one value is required')
        if is_list_var(values[0]):
            values[:1] = [utils.escape(item) for item in
                          self._variables[values[0]]]
            return self._verify_values_for_set_variable_if(values)
        return values

    def run_keyword_if_test_failed(self, name, *args):
        """Runs the given keyword with the given arguments, if the test failed.

        This keyword can only be used in a test teardown. Trying to use it
        anywhere else results in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.
        """
        test = self._get_test_in_teardown('Run Keyword If Test Failed')
        if not test.passed:
            return self.run_keyword(name, *args)

    def run_keyword_if_test_passed(self, name, *args):
        """Runs the given keyword with the given arguments, if the test passed.

        This keyword can only be used in a test teardown. Trying to use it
        anywhere else results in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.
        """
        test = self._get_test_in_teardown('Run Keyword If Test Passed')
        if test.passed:
            return self.run_keyword(name, *args)

    def run_keyword_if_timeout_occurred(self, name, *args):
        """Runs the given keyword if either a test or a keyword timeout has occurred.

        This keyword can only be used in a test teardown. Trying to use it
        anywhere else results in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.

        Available in Robot Framework 2.5 and newer.
        """
        self._get_test_in_teardown('Run Keyword If Timeout Occurred')
        if self._context.timeout_occurred:
            return self.run_keyword(name, *args)

    def _get_test_in_teardown(self, kwname):
        ctx = self._context
        if ctx.test and ctx.in_test_teardown:
            return ctx.test
        raise RuntimeError("Keyword '%s' can only be used in test teardown"
                           % kwname)

    def run_keyword_if_all_critical_tests_passed(self, name, *args):
        """Runs the given keyword with the given arguments, if all critical tests passed.

        This keyword can only be used in suite teardown. Trying to use it in
        any other place will result in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.
        """
        suite = self._get_suite_in_teardown('Run Keyword If '
                                            'All Critical Tests Passed')
        if suite.statistics.critical.failed == 0:
            return self.run_keyword(name, *args)

    def run_keyword_if_any_critical_tests_failed(self, name, *args):
        """Runs the given keyword with the given arguments, if any critical tests failed.

        This keyword can only be used in a suite teardown. Trying to use it
        anywhere else results in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.
        """
        suite = self._get_suite_in_teardown('Run Keyword If '
                                            'Any Critical Tests Failed')
        if suite.statistics.critical.failed > 0:
            return self.run_keyword(name, *args)

    def run_keyword_if_all_tests_passed(self, name, *args):
        """Runs the given keyword with the given arguments, if all tests passed.

        This keyword can only be used in a suite teardown. Trying to use it
        anywhere else results in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.
        """
        suite = self._get_suite_in_teardown('Run Keyword If All Tests Passed')
        if suite.statistics.all.failed == 0:
            return self.run_keyword(name, *args)

    def run_keyword_if_any_tests_failed(self, name, *args):
        """Runs the given keyword with the given arguments, if one or more tests failed.

        This keyword can only be used in a suite teardown. Trying to use it
        anywhere else results in an error.

        Otherwise, this keyword works exactly like `Run Keyword`, see its
        documentation for more details.
        """
        suite = self._get_suite_in_teardown('Run Keyword If Any Tests Failed')
        if suite.statistics.all.failed > 0:
            return self.run_keyword(name, *args)

    def _get_suite_in_teardown(self, kwname):
        if not self._context.in_suite_teardown:
            raise RuntimeError("Keyword '%s' can only be used in suite teardown"
                               % kwname)
        return self._context.suite


class _Control:

    def continue_for_loop(self):
        """Skips the current for loop iteration and continues from the next.

        Skips the remaining keywords in the current for loop iteration and
        continues from the next one. Can be used directly in a for loop or
        in a keyword that the loop uses.

        Example:
        | :FOR | ${var}         | IN                     | @{VALUES}         |
        |      | Run Keyword If | '${var}' == 'CONTINUE' | Continue For Loop |
        |      | Do Something   | ${var}                 |

        See `Continue For Loop If` to conditionally continue a for loop without
        using `Run Keyword If` or other wrapper keywords.

        New in Robot Framework 2.8.
        """
        self.log("Continuing for loop from the next iteration.")
        raise ContinueForLoop()

    def continue_for_loop_if(self, condition):
        """Skips the current for loop iteration if the `condition` is true.

        A wrapper for `Continue For Loop` to continue a for loop based on
        the given condition. The condition is evaluated using the same
        semantics as with `Should Be True` keyword.

        Example:
        | :FOR | ${var}               | IN                     | @{VALUES} |
        |      | Continue For Loop If | '${var}' == 'CONTINUE' |
        |      | Do Something         | ${var}                 |

        New in Robot Framework 2.8.
        """
        if self._is_true(condition):
            self.continue_for_loop()

    def exit_for_loop(self):
        """Stops executing the enclosing for loop.

        Exits the enclosing for loop and continues execution after it.
        Can be used directly in a for loop or in a keyword that the loop uses.

        Example:
        | :FOR | ${var}         | IN                 | @{VALUES}     |
        |      | Run Keyword If | '${var}' == 'EXIT' | Exit For Loop |
        |      | Do Something   | ${var} |

        See `Exit For Loop If` to conditionally exit a for loop without
        using `Run Keyword If` or other wrapper keywords.

        New in Robot Framework 2.5.2.
        """
        self.log("Exiting for loop altogether.")
        raise ExitForLoop()

    def exit_for_loop_if(self, condition):
        """Stops executing the enclosing for loop if the `condition` is true.

        A wrapper for `Exit For Loop` to exit a for loop based on
        the given condition. The condition is evaluated using the same
        semantics as with `Should Be True` keyword.

        Example:
        | :FOR | ${var}           | IN                 | @{VALUES} |
        |      | Exit For Loop If | '${var}' == 'EXIT' |
        |      | Do Something     | ${var}             |

        New in Robot Framework 2.8.
        """
        if self._is_true(condition):
            self.exit_for_loop()

    @run_keyword_variant(resolve=0)
    def return_from_keyword(self, *return_values):
        """Returns from the enclosing user keyword.

        This keyword can be used to return from a user keyword with PASS status
        without executing it fully. It is also possible to return values
        similarly as with the `[Return]` setting. For more detailed information
        about working with the return values, see the User Guide.

        This keyword is typically wrapped to some other keyword, such as
        `Run Keyword If` or `Run Keyword If Test Passed`, to return based
        on a condition:

        | Run Keyword If | ${rc} < 0 | Return From Keyword |
        | Run Keyword If Test Passed | Return From Keyword |

        It is possible to use this keyword to return from a keyword also inside
        a for loop. That, as well as returning values, is demonstrated by the
        `Find Index` keyword in the following somewhat advanced example.
        Notice that it is often a good idea to move this kind of complicated
        logic into a test library.

        | ***** Variables *****
        | @{LIST} =    foo    baz
        |
        | ***** Test Cases *****
        | Example
        |     ${index} =    Find Index    baz    @{LIST}
        |     Should Be Equal    ${index}    ${1}
        |     ${index} =    Find Index    non existing    @{LIST}
        |     Should Be Equal    ${index}    ${-1}
        |
        | ***** Keywords *****
        | Find Index
        |    [Arguments]    ${element}    @{items}
        |    ${index} =    Set Variable    ${0}
        |    :FOR    ${item}    IN    @{items}
        |    \\    Run Keyword If    '${item}' == '${element}'    Return From Keyword    ${index}
        |    \\    ${index} =    Set Variable    ${index + 1}
        |    Return From Keyword    ${-1}    # Also [Return] would work here.

        The most common use case, returning based on an expression, can be
        accomplished directly with `Return From Keyword If`. Both of these
        keywords are new in Robot Framework 2.8.
        """
        self.log('Returning from the enclosing user keyword.')
        raise ReturnFromKeyword(return_values)

    @run_keyword_variant(resolve=1)
    def return_from_keyword_if(self, condition, *return_values):
        """Returns from the enclosing user keyword if `condition` is true.

        A wrapper for `Return From Keyword` to return based on the given
        condition. The condition is evaluated using the same semantics as
        with `Should Be True` keyword.

        Given the same example as in `Return From Keyword`, we can rewrite the
        `Find Index` keyword as follows:

        | ***** Keywords *****
        | Find Index
        |    [Arguments]    ${element}    @{items}
        |    ${index} =    Set Variable    ${0}
        |    :FOR    ${item}    IN    @{items}
        |    \\    Return From Keyword If    '${item}' == '${element}'    ${index}
        |    \\    ${index} =    Set Variable    ${index + 1}
        |    Return From Keyword    ${-1}    # Also [Return] would work here.

        New in Robot Framework 2.8.
        """
        if self._is_true(condition):
            self.return_from_keyword(*return_values)

    def pass_execution(self, message, *tags):
        """Skips rest of the current test, setup, or teardown with PASS status.

        This keyword can be used anywhere in the test data, but the place where
        used affects the behavior:

        - When used in any setup or teardown (suite, test or keyword), passes
          that setup or teardown. Possible keyword teardowns of the started
          keywords are executed. Does not affect execution or statuses
          otherwise.
        - When used in a test outside setup or teardown, passes that particular
          test case. Possible test and keyword teardowns are executed.

        Possible continuable failures before this keyword is used, as well as
        failures in executed teardowns, will fail the execution.

        It is mandatory to give a message explaining why execution was passed.
        By default the message is considered plain text, but starting it with
        `*HTML*` allows using HTML formatting.

        It is also possible to modify test tags passing tags after the message
        similarly as with `Fail` keyword. Tags starting with a hyphen
        (e.g. `-regression`) are removed and others added. Tags are modified
        using `Set Tags` and `Remove Tags` internally, and the semantics
        setting and removing them are the same as with these keywords.

        Examples:
        | Pass Execution | All features available in this version tested. |
        | Pass Execution | Deprecated test. | deprecated | -regression    |

        This keyword is typically wrapped to some other keyword, such as
        `Run Keyword If`, to pass based on a condition. The most common case
        can be handled also with `Pass Execution If`:

        | Run Keyword If    | ${rc} < 0 | Pass Execution | Negative values are cool. |
        | Pass Execution If | ${rc} < 0 | Negative values are cool. |

        Passing execution in the middle of a test, setup or teardown should be
        used with care. In the worst case it leads to tests that skip all the
        parts that could actually uncover problems in the tested application.
        In cases where execution cannot continue do to external factors,
        it is often safer to fail the test case and make it non-critical.

        New in Robot Framework 2.8.
        """
        message = message.strip()
        if not message:
            raise RuntimeError('Message cannot be empty.')
        self._set_and_remove_tags(tags)
        log_message, level = self._get_logged_test_message_and_level(message)
        self.log('Execution passed with message:\n%s' % log_message, level)
        raise PassExecution(message)

    @run_keyword_variant(resolve=1)
    def pass_execution_if(self, condition, message, *tags):
        """Conditionally skips rest of the current test, setup, or teardown with PASS status.

        A wrapper for `Pass Execution` to skip rest of the current test,
        setup or teardown based the given `condition`. The condition is
        evaluated similarly as with `Should Be True` keyword, and `message`
        and `*tags` have same semantics as with `Pass Execution`.

        Example:
        | :FOR | ${var}            | IN                     | @{VALUES}               |
        |      | Pass Execution If | '${var}' == 'EXPECTED' | Correct value was found |
        |      | Do Something      | ${var}                 |

        New in Robot Framework 2.8.
        """
        if self._is_true(condition):
            message = self._variables.replace_string(message)
            tags = [self._variables.replace_string(tag) for tag in tags]
            self.pass_execution(message, *tags)


class _Misc:

    def no_operation(self):
        """Does absolutely nothing."""

    def sleep(self, time_, reason=None):
        """Pauses the test executed for the given time.

        `time` may be either a number or a time string. Time strings are in
        a format such as '1 day 2 hours 3 minutes 4 seconds 5milliseconds' or
        '1d 2h 3m 4s 5ms', and they are fully explained in an appendix of Robot
        Framework User Guide. Optional `reason` can be used to explain why
        sleeping is necessary. Both the time slept and the reason are logged.

        Examples:
        | Sleep | 42                   |
        | Sleep | 1.5                  |
        | Sleep | 2 minutes 10 seconds |
        | Sleep | 10s                  | Wait for a reply |
        """
        seconds = utils.timestr_to_secs(time_)
        # Python hangs with negative values
        if seconds < 0:
            seconds = 0
        self._sleep_in_parts(seconds)
        self.log('Slept %s' % utils.secs_to_timestr(seconds))
        if reason:
            self.log(reason)

    def _sleep_in_parts(self, seconds):
        # time.sleep can't be stopped in windows
        # to ensure that we can signal stop (with timeout)
        # split sleeping to small pieces
        endtime = time.time() + float(seconds)
        while True:
            remaining = endtime - time.time()
            if remaining <= 0:
                break
            time.sleep(min(remaining, 0.5))

    def catenate(self, *items):
        """Catenates the given items together and returns the resulted string.

        By default, items are catenated with spaces, but if the first item
        contains the string 'SEPARATOR=<sep>', the separator '<sep>' is used.
        Items are converted into strings when necessary.

        Examples:
        | ${str1} = | Catenate | Hello         | world |       |
        | ${str2} = | Catenate | SEPARATOR=--- | Hello | world |
        | ${str3} = | Catenate | SEPARATOR=    | Hello | world |
        =>
        | ${str1} = 'Hello world'
        | ${str2} = 'Hello---world'
        | ${str3} = 'Helloworld'
        """
        if not items:
            return ''
        items = [utils.unic(item) for item in items]
        if items[0].startswith('SEPARATOR='):
            sep = items[0][len('SEPARATOR='):]
            items = items[1:]
        else:
            sep = ' '
        return sep.join(items)

    def log(self, message, level="INFO"):
        """Logs the given message with the given level.

        Valid levels are TRACE, DEBUG, INFO (default), HTML and WARN.

        The HTML level is special because it allows writing messages
        without HTML code in them being escaped. For example, logging
        a message '<img src="image.png">' using the HTML level creates
        an image, but with other levels the message would be that exact
        string. Notice that invalid HTML can easily corrupt the whole
        log file so this feature should be used with care. The
        actual log level used for HTML messages is INFO.

        Messages logged with the WARN level will be visible also in
        the console and in the Test Execution Errors section in the
        log file.
        """
        LOGGER.log_message(Message(message, level))

    def log_many(self, *messages):
        """Logs the given messages as separate entries with the INFO level."""
        for msg in messages:
            self.log(msg)

    @run_keyword_variant(resolve=0)
    def comment(self, *messages):
        """Displays the given messages in the log file as keyword arguments.

        This keyword does nothing with the arguments it receives, but as they
        are visible in the log, this keyword can be used to display simple
        messages. Given arguments are ignored so thoroughly that they can even
        contain non-existing variables. If you are interested about variable
        values, you can use the `Log` or `Log Many` keywords.
        """
        pass

    def set_log_level(self, level):
        """Sets the log threshold to the specified level and returns the old level.

        Messages below the level will not logged. The default logging level is
        INFO, but it can be overridden with the command line option
        '--loglevel'.

        The available levels: TRACE, DEBUG, INFO (default), WARN and NONE (no
        logging).
        """
        try:
            old = self._context.output.set_log_level(level)
        except DataError, err:
            raise RuntimeError(unicode(err))
        self._namespace.variables.set_global('${LOG_LEVEL}', level.upper())
        self.log('Log level changed from %s to %s' % (old, level.upper()))
        return old

    @run_keyword_variant(resolve=0)
    def import_library(self, name, *args):
        """Imports a library with the given name and optional arguments.

        This functionality allows dynamic importing of libraries while tests
        are running. That may be necessary, if the library itself is dynamic
        and not yet available when test data is processed. In a normal case,
        libraries should be imported using the Library setting in the Setting
        table.

        This keyword supports importing libraries both using library
        names and physical paths. When paths are used, they must be
        given in absolute format. Forward slashes can be used as path
        separators in all operating systems.

        It is possible to pass arguments to the imported library and also
        named argument syntax works if the library supports it. 'WITH NAME'
        syntax can be used to give a custom name to the imported library.

        Examples:
        | Import Library | MyLibrary |
        | Import Library | ${CURDIR}/../Library.py | arg1 | named=arg2 |
        | Import Library | ${LIBRARIES}/Lib.java | arg | WITH NAME | JavaLib |
        """
        try:
            self._namespace.import_library(name, list(args))
        except DataError, err:
            raise RuntimeError(unicode(err))

    @run_keyword_variant(resolve=0)
    def import_variables(self, path, *args):
        """Imports a variable file with the given path and optional arguments.

        Variables imported with this keyword are set into the test suite scope
        similarly when importing them in the Setting table using the Variables
        setting. These variables override possible existing variables with
        the same names. This functionality can thus be used to import new
        variables, for example, for each test in a test suite.

        The given path must be absolute. Forward slashes can be used as path
        separator regardless the operating system.

        Examples:
        | Import Variables | ${CURDIR}/variables.py   |      |      |
        | Import Variables | ${CURDIR}/../vars/env.py | arg1 | arg2 |

        New in Robot Framework 2.5.4.
        """
        try:
            self._namespace.import_variables(path, list(args), overwrite=True)
        except DataError, err:
            raise RuntimeError(unicode(err))

    @run_keyword_variant(resolve=0)
    def import_resource(self, path):
        """Imports a resource file with the given path.

        Resources imported with this keyword are set into the test suite scope
        similarly when importing them in the Setting table using the Resource
        setting.

        The given path must be absolute. Forward slashes can be used as path
        separator regardless the operating system.

        Examples:
        | Import Resource | ${CURDIR}/resource.txt |
        | Import Resource | ${CURDIR}/../resources/resource.html |
        """
        try:
            self._namespace.import_resource(path)
        except DataError, err:
            raise RuntimeError(unicode(err))

    def set_library_search_order(self, *libraries):
        """Sets the resolution order to use when a name matches multiple keywords.

        The library search order is used to resolve conflicts when a keyword
        name in the test data matches multiple keywords. The first library
        (or resource, see below) containing the keyword is selected and that
        keyword implementation used. If the keyword is not found from any library
        (or resource), test executing fails the same way as when the search
        order is not set.

        When this keyword is used, there is no need to use the long
        `LibraryName.Keyword Name` notation.  For example, instead of
        having

        | MyLibrary.Keyword | arg |
        | MyLibrary.Another Keyword |
        | MyLibrary.Keyword | xxx |

        you can have

        | Set Library Search Order | MyLibrary |
        | Keyword | arg |
        | Another Keyword |
        | Keyword | xxx |

        Starting from Robot Framework 2.6.2 this keyword can be used also to
        set the order of keywords in different resource files. In this case
        resource names must be given without paths or extensions like:

        | Set Library Search Order | resource | another_resource |

        *NOTE:*
        - The search order is valid only in the suite where this keywords is used.
        - Keywords in resources always have higher priority than
          keywords in libraries regardless the search order.
        - The old order is returned and can be used to reset the search order later.
        - Starting from RF 2.6.2, library and resource names in the search order
          are both case and space insensitive.
        """
        old_order = self._namespace.library_search_order
        self._namespace.library_search_order = libraries
        return old_order

    def keyword_should_exist(self, name, msg=None):
        """Fails unless the given keyword exists in the current scope.

        Fails also if there are more than one keywords with the same name.
        Works both with the short name (e.g. `Log`) and the full name
        (e.g. `BuiltIn.Log`).

        The default error message can be overridden with the `msg` argument.

        New in Robot Framework 2.6. See also `Variable Should Exist`.
        """
        try:
            handler = self._namespace._get_handler(name)
            if not handler:
                raise DataError("No keyword with name '%s' found." % name)
            if isinstance(handler, UserErrorHandler):
                handler.run()
        except DataError, err:
            raise AssertionError(msg or unicode(err))

    def get_time(self, format='timestamp', time_='NOW'):
        """Returns the given time in the requested format.

        How time is returned is determined based on the given `format`
        string as follows. Note that all checks are case-insensitive.

        1) If `format` contains the word 'epoch', the time is returned
           in seconds after the UNIX epoch (1970-01-01 00:00:00 UTC).
           The return value is always an integer.

        2) If `format` contains any of the words 'year', 'month',
           'day', 'hour', 'min', or 'sec', only the selected parts are
           returned. The order of the returned parts is always the one
           in the previous sentence and the order of words in `format`
           is not significant. The parts are returned as zero-padded
           strings (e.g. May -> '05').

        3) Otherwise (and by default) the time is returned as a
           timestamp string in the format '2006-02-24 15:08:31'.

        By default this keyword returns the current local time, but
        that can be altered using `time` argument as explained below.
        Note that all checks involving strings are case-insensitive.

        1) If `time` is a number, or a string that can be converted to
           a number, it is interpreted as seconds since the UNIX epoch.
           This documentation was originally written about 1177654467
           seconds after the epoch.

        2) If `time` is a timestamp, that time will be used. Valid
           timestamp formats are 'YYYY-MM-DD hh:mm:ss' and 'YYYYMMDD hhmmss'.

        3) If `time` is equal to 'NOW' (default), the current local
           time is used. This time is got using Python's 'time.time()'
           function.

        4) If `time` is equal to 'UTC', the current time in
           [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]
           is used. This time is got using 'time.time() + time.altzone'
           in Python.

        5) If `time` is in the format like 'NOW - 1 day' or 'UTC + 1 hour
           30 min', the current local/UTC time plus/minus the time
           specified with the time string is used. The time string format
           is described in an appendix of Robot Framework User Guide.

        Examples (expecting the current local time is 2006-03-29 15:06:21):
        | ${time} = | Get Time |             |  |  |
        | ${secs} = | Get Time | epoch       |  |  |
        | ${year} = | Get Time | return year |  |  |
        | ${yyyy}   | ${mm}    | ${dd} =     | Get Time | year,month,day |
        | @{time} = | Get Time | year month day hour min sec |  |  |
        | ${y}      | ${s} =   | Get Time    | seconds and year |  |
        =>
        | ${time} = '2006-03-29 15:06:21'
        | ${secs} = 1143637581
        | ${year} = '2006'
        | ${yyyy} = '2006', ${mm} = '03', ${dd} = '29'
        | @{time} = ['2006', '03', '29', '15', '06', '21']
        | ${y} = '2006'
        | ${s} = '21'

        Examples (expecting the current local time is 2006-03-29 15:06:21 and
        UTC time is 2006-03-29 12:06:21):
        | ${time} = | Get Time |              | 1177654467          | # Time given as epoch seconds        |
        | ${secs} = | Get Time | sec          | 2007-04-27 09:14:27 | # Time given as a timestamp          |
        | ${year} = | Get Time | year         | NOW                 | # The local time of execution        |
        | @{time} = | Get Time | hour min sec | NOW + 1h 2min 3s    | # 1h 2min 3s added to the local time |
        | @{utc} =  | Get Time | hour min sec | UTC                 | # The UTC time of execution          |
        | ${hour} = | Get Time | hour         | UTC - 1 hour        | # 1h subtracted from the UTC  time   |
        =>
        | ${time} = '2007-04-27 09:14:27'
        | ${secs} = 27
        | ${year} = '2006'
        | @{time} = ['16', '08', '24']
        | @{utc} = ['12', '06', '21']
        | ${hour} = '11'

        Support for UTC time was added in Robot Framework 2.7.5 but it did not
        work correctly until 2.7.7.
        """
        return utils.get_time(format, utils.parse_time(time_))

    def evaluate(self, expression, modules=None):
        """Evaluates the given expression in Python and returns the results.

        `modules` argument can be used to specify a comma separated
        list of Python modules to be imported and added to the
        namespace of the evaluated `expression`.

        Examples (expecting `${result}` is 3.14):
        | ${status} = | Evaluate | 0 < ${result} < 10    |
        | ${down}   = | Evaluate | int(${result})        |
        | ${up}     = | Evaluate | math.ceil(${result})  | math |
        | ${random} = | Evaluate | random.randint(0, sys.maxint) | random,sys |
        =>
        | ${status} = True
        | ${down} = 3
        | ${up} = 4.0
        | ${random} = <random integer>

        Notice that instead of creating complicated expressions, it is
        recommended to move the logic into a test library.
        """
        modules = modules.replace(' ','').split(',') if modules else []
        namespace = dict((m, __import__(m)) for m in modules if m != '')
        try:
            return eval(expression, namespace)
        except:
            raise RuntimeError("Evaluating expression '%s' failed: %s"
                               % (expression, utils.get_error_message()))

    def call_method(self, object, method_name, *args):
        """Calls the named method of the given object with the provided arguments.

        The possible return value from the method is returned and can be
        assigned to a variable. Keyword fails both if the object does not have
        a method with the given name or if executing the method raises an
        exception.

        Examples:
        | Call Method      | ${hashtable} | put          | myname  | myvalue |
        | ${isempty} =     | Call Method  | ${hashtable} | isEmpty |         |
        | Should Not Be True | ${isempty} |              |         |         |
        | ${value} =       | Call Method  | ${hashtable} | get     | myname  |
        | Should Be Equal  | ${value}     | myvalue      |         |         |
        """
        try:
            method = getattr(object, method_name)
        except AttributeError:
            raise RuntimeError("Object '%s' does not have a method '%s'"
                               % (object, method_name))
        return method(*args)

    def regexp_escape(self, *patterns):
        """Returns each argument string escaped for use as a regular expression.

        This keyword can be used to escape strings to be used with
        `Should Match Regexp` and `Should Not Match Regexp` keywords.

        Escaping is done with Python's re.escape() function.

        Examples:
        | ${escaped} = | Regexp Escape | ${original} |
        | @{strings} = | Regexp Escape | @{strings}  |
        """
        if len(patterns) == 0:
            return ''
        if len(patterns) == 1:
            return re.escape(patterns[0])
        return [re.escape(p) for p in patterns]

    def set_test_message(self, message, append=False):
        """Sets message for the current test case.

        Possible failures override this message.

        If the optional `append` argument is given any value considered `true`
        in Python, for example, any non-empty string, the given `message` is
        added after the possible earlier message by joining the messages with
        a space.

        In teardown the current test message is available as a built-in variable
        `${TEST MESSAGE}`. This keyword can not be used in suite setup or
        or suite teardown.

        It is possible to use HTML format in the message by starting the message
        with `*HTML*`.

        Examples:
        | Set Test Message | My message          |            |
        | Set Test Message | is continued.       | append=yes |
        | Should Be Equal  | ${TEST MESSAGE}     | My message is continued. |
        | Set Test Message | *HTML*<b>Hello!</b> |            |


        New in Robot Framework 2.5. Support for `append` was added in 2.7.7
        and HTML support in 2.8.
        """
        test = self._namespace.test
        if not test:
            raise RuntimeError("'Set Test Message' keyword cannot be used in "
                               "suite setup or teardown")
        test.message = self._get_possibly_appended_value(test.message, message, append)
        message, level = self._get_logged_test_message_and_level(test.message)
        self.log('Set test message to:\n%s' % message, level)

    def _get_possibly_appended_value(self, initial, new, append):
        if not isinstance(new, unicode):
            new = utils.unic(new)
        return '%s %s' % (initial, new) if append and initial else new

    def _get_logged_test_message_and_level(self, message):
        if message.startswith('*HTML*'):
            return message[6:].lstrip(), 'HTML'
        return message, 'INFO'

    def set_test_documentation(self, doc, append=False):
        """Sets documentation for the current test case.

        By default the possible existing documentation is overwritten, but
        this can be changed using the optional `append` argument similarly
        as with `Set Test Message` keyword.

        The current test documentation is available as a built-in variable
        `${TEST DOCUMENTATION}`. This keyword can not be used in suite
        setup or suite teardown.

        New in Robot Framework 2.7. Support for `append` was added in 2.7.7.
        """
        test = self._namespace.test
        if not test:
            raise RuntimeError("'Set Test Documentation' keyword cannot be used in "
                               "suite setup or teardown")
        test.doc = self._get_possibly_appended_value(test.doc, doc, append)
        self._variables.set_test('${TEST_DOCUMENTATION}', test.doc)
        self.log('Set test documentation to:\n%s' % test.doc)

    def set_suite_documentation(self, doc, append=False, top=False):
        """Sets documentation for the current test suite.

        By default the possible existing documentation is overwritten, but
        this can be changed using the optional `append` argument similarly
        as with `Set Test Message` keyword.

        This keyword sets the documentation of the current suite by default.
        If the optional `top` argument is given any value considered
        `true` in Python, for example, any non-empty string, the documentation
        of the top level suite is altered instead.

        The documentation of the current suite is available as a built-in
        variable `${SUITE DOCUMENTATION}`.

        New in Robot Framework 2.7. Support for `append` and `top` were
        added in 2.7.7..
        """
        ns = self._get_namespace(top)
        suite = ns.suite
        suite.doc = self._get_possibly_appended_value(suite.doc, doc, append)
        ns.variables.set_suite('${SUITE_DOCUMENTATION}', suite.doc)
        self.log('Set suite documentation to:\n%s' % suite.doc)

    def set_suite_metadata(self, name, value, append=False, top=False):
        """Sets metadata for the current test suite.

        By default possible existing metadata values are overwritten, but
        this can be changed using the optional `append` argument similarly
        as with `Set Test Message` keyword.

        This keyword sets the metadata of the current suite by default.
        If the optional `top` argument is given any value considered
        `true` in Python, for example, any non-empty string, the metadata
        of the top level suite is altered instead.

        The metadata of the current suite is available as a built-in variable
        `${SUITE METADATA}` in a Python dictionary. Notice that modifying this
        variable directly has no effect on the actual metadata the suite has.

        New in Robot Framework 2.7.4. Support for `append` and `top` were
        added in 2.7.7.
        """
        if not isinstance(name, unicode):
            name = utils.unic(name)
        ns = self._get_namespace(top)
        metadata = ns.suite.metadata
        metadata[name] = self._get_possibly_appended_value(metadata.get(name, ''), value, append)
        ns.variables.set_suite('${SUITE_METADATA}', metadata.copy())
        self.log("Set suite metadata '%s' to value '%s'." % (name, metadata[name]))

    def set_tags(self, *tags):
        """Adds given `tags` for the current test or all tests in a suite.

        When this keyword is used inside a test case, that test gets
        the specified tags and other tests are not affected.

        If this keyword is used in a suite setup, all test cases in
        that suite, recursively, gets the given tags. It is a failure
        to use this keyword in a suite teardown.

        The current tags are available as a built-in variable `@{TEST TAGS}`.

        See `Remove Tags` if you want to remove certain tags and `Fail` if
        you want to fail the test case after setting and/or removing tags.
        """
        ctx = self._context
        if ctx.test:
            ctx.test.tags.add(tags)
            ctx.variables.set_test('@{TEST_TAGS}', list(ctx.test.tags))
        elif not ctx.in_suite_teardown:
            ctx.suite.set_tags(tags, persist=True)
        else:
            raise RuntimeError("'Set Tags' cannot be used in suite teardown.")
        self.log('Set tag%s %s.' % (utils.plural_or_not(tags),
                                    utils.seq2str(tags)))

    def remove_tags(self, *tags):
        """Removes given `tags` from the current test or all tests in a suite.

        Tags can be given exactly or using a pattern where '*' matches
        anything and '?' matches one character.

        This keyword can affect either one test case or all test cases in a
        test suite similarly as `Set Tags` keyword.

        The current tags are available as a built-in variable `@{TEST TAGS}`.

        Example:
        | Remove Tags | mytag | something-* | ?ython |

        See `Set Tags` if you want to add certain tags and `Fail` if you want
        to fail the test case after setting and/or removing tags.
        """
        ctx = self._context
        if ctx.test:
            ctx.test.tags.remove(tags)
            ctx.variables.set_test('@{TEST_TAGS}', list(ctx.test.tags))
        elif not ctx.in_suite_teardown:
            ctx.suite.set_tags(remove=tags, persist=True)
        else:
            raise RuntimeError("'Remove Tags' cannot be used in suite teardown.")
        self.log('Removed tag%s %s.' % (utils.plural_or_not(tags),
                                        utils.seq2str(tags)))

    def get_library_instance(self, name):
        """Returns the currently active instance of the specified test library.

        This keyword makes it easy for test libraries to interact with
        other test libraries that have state. This is illustrated by
        the Python example below:

        | from robot.libraries.BuiltIn import BuiltIn
        |
        | def title_should_start_with(expected):
        |     seleniumlib = BuiltIn().get_library_instance('SeleniumLibrary')
        |     title = seleniumlib.get_title()
        |     if not title.startswith(expected):
        |         raise AssertionError("Title '%s' did not start with '%s'"
        |                              % (title, expected))

        It is also possible to use this keyword in the test data and
        pass the returned library instance to another keyword. If a
        library is imported with a custom name, the `name` used to get
        the instance must be that name and not the original library name.
        """
        try:
            return self._namespace.get_library_instance(name)
        except DataError, err:
            raise RuntimeError(unicode(err))


class BuiltIn(_Verify, _Converter, _Variables, _RunKeyword, _Control, _Misc):
    """An always available standard library with often needed keywords.

    `BuiltIn` is Robot Framework's standard library that provides a set
    of generic keywords needed often. It is imported automatically and
    thus always available. The provided keywords can be used, for example,
    for verifications (e.g. `Should Be Equal`, `Should Contain`),
    conversions (e.g. `Convert To Integer`) and for various other purposes
    (e.g. `Log`, `Sleep`, `Run Keyword If`, `Set Global Variable`).

    Many of the keywords accept an optional error message to use if the keyword
    fails. Starting from Robot Framework 2.8, it is possible to use HTML in
    these messages by prefixing them with `*HTML*`. See `Fail` keyword for
    a usage example. Notice that using HTML in messages is not limited to
    BuiltIn library but works with any error message.
    """
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'
    ROBOT_LIBRARY_VERSION = get_version()

    @property
    def _context(self):
        return EXECUTION_CONTEXTS.current

    @property
    def _namespace(self):
        return self._context.namespace

    def _get_namespace(self, top=False):
        ctx = EXECUTION_CONTEXTS.top if top else EXECUTION_CONTEXTS.current
        return ctx.namespace

    @property
    def _variables(self):
        return self._namespace.variables

    def _matches(self, string, pattern):
        # Must use this instead of fnmatch when string may contain newlines.
        matcher = utils.Matcher(pattern, caseless=False, spaceless=False)
        return matcher.match(string)

    def _is_true(self, condition):
        if isinstance(condition, basestring):
            condition = self.evaluate(condition, modules='os,sys')
        return bool(condition)


def register_run_keyword(library, keyword, args_to_process=None):
    """Registers 'run keyword' so that its arguments can be handled correctly.

    1) Why is this method needed

    Keywords running other keywords internally (normally using `Run Keyword`
    or some variants of it in BuiltIn) must have the arguments meant to the
    internally executed keyword handled specially to prevent processing them
    twice. This is done ONLY for keywords registered using this method.

    If the register keyword has same name as any keyword from Robot Framework
    standard libraries, it can be used without getting warnings. Normally
    there is a warning in such cases unless the keyword is used in long
    format (e.g. MyLib.Keyword).

    Starting from Robot Framework 2.5.2, keywords executed by registered run
    keywords can be tested in dry-run mode they have 'name' argument which
    takes the name of the executed keyword.

    2) How to use this method

    `library` is the name of the library where the registered keyword is
    implemented.

    `keyword` can be either a function or method implementing the
    keyword, or name of the implemented keyword as a string.

    `args_to_process` is needed when `keyword` is given as a string, and it
    defines how many of the arguments to the registered keyword must be
    processed normally. When `keyword` is a method or function, this
    information is got directly from it so that varargs (those specified with
    syntax '*args') are not processed but others are.

    3) Examples

    from robot.libraries.BuiltIn import BuiltIn, register_run_keyword

    def my_run_keyword(name, *args):
        # do something
        return BuiltIn().run_keyword(name, *args)

    # Either one of these works
    register_run_keyword(__name__, my_run_keyword)
    register_run_keyword(__name__, 'My Run Keyword', 1)

    -------------

    from robot.libraries.BuiltIn import BuiltIn, register_run_keyword

    class MyLibrary:
        def my_run_keyword_if(self, expression, name, *args):
            # do something
            return BuiltIn().run_keyword_if(expression, name, *args)

    # Either one of these works
    register_run_keyword('MyLibrary', MyLibrary.my_run_keyword_if)
    register_run_keyword('MyLibrary', 'my_run_keyword_if', 2)
    """
    RUN_KW_REGISTER.register_run_keyword(library, keyword, args_to_process)


for name in [attr for attr in dir(_RunKeyword) if not attr.startswith('_')]:
    register_run_keyword('BuiltIn', getattr(_RunKeyword, name))
del name, attr

########NEW FILE########
__FILENAME__ = Collections
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.api import logger
from robot.utils import plural_or_not, seq2str, seq2str2, unic
from robot.utils.asserts import assert_equals
from robot.version import get_version


class _List:

    def convert_to_list(self, item):
        """Converts the given `item` to a list.

        Mainly useful for converting tuples and other iterable to lists.
        Use `Create List` from the BuiltIn library for constructing new lists.
        """
        return list(item)

    def append_to_list(self, list_, *values):
        """Adds `values` to the end of `list`.

        Example:
        | Append To List | ${L1} | xxx |   |   |
        | Append To List | ${L2} | x   | y | z |
        =>
        - ${L1} = ['a', 'xxx']
        - ${L2} = ['a', 'b', 'x', 'y', 'z']
        """
        for value in values:
            list_.append(value)

    def insert_into_list(self, list_, index, value):
        """Inserts `value` into `list` to the position specified with `index`.

        Index '0' adds the value into the first position, '1' to the second,
        and so on. Inserting from right works with negative indices so that
        '-1' is the second last position, '-2' third last, and so on. Use
        `Append To List` to add items to the end of the list.

        If the absolute value of the index is greater than
        the length of the list, the value is added at the end
        (positive index) or the beginning (negative index). An index
        can be given either as an integer or a string that can be
        converted to an integer.

        Example:
        | Insert Into List | ${L1} | 0     | xxx |
        | Insert Into List | ${L2} | ${-1} | xxx |
        =>
        - ${L1} = ['xxx', 'a']
        - ${L2} = ['a', 'xxx', 'b']
        """
        list_.insert(self._index_to_int(index), value)

    def combine_lists(self, *lists):
        """Combines the given `lists` together and returns the result.

        The given lists are not altered by this keyword.

        Example:
        | ${x} = | Combine List | ${L1} | ${L2} |       |
        | ${y} = | Combine List | ${L1} | ${L2} | ${L1} |
        =>
        - ${x} = ['a', 'a', 'b']
        - ${y} = ['a', 'a', 'b', 'a']
        - ${L1} and ${L2} are not changed.
        """
        ret = []
        for item in lists:
            ret.extend(item)
        return ret

    def set_list_value(self, list_, index, value):
        """Sets the value of `list` specified by `index` to the given `value`.

        Index '0' means the first position, '1' the second and so on.
        Similarly, '-1' is the last position, '-2' second last, and so on.
        Using an index that does not exist on the list causes an error.
        The index can be either an integer or a string that can be converted to
        an integer.

        Example:
        | Set List Value | ${L3} | 1  | xxx |
        | Set List Value | ${L3} | -1 | yyy |
        =>
        - ${L3} = ['a', 'xxx', 'yyy']
        """
        try:
            list_[self._index_to_int(index)] = value
        except IndexError:
            self._index_error(list_, index)

    def remove_values_from_list(self, list_, *values):
        """Removes all occurences of given `values` from `list`.

        It is not an error is a value does not exist in the list at all.

        Example:
        | Remove Values From List | ${L4} | a | c | e | f |
        =>
        - ${L4} = ['b', 'd']
        """
        for value in values:
            while value in list_:
                list_.remove(value)

    def remove_from_list(self, list_, index):
        """Removes and returns the value specified with an `index` from `list`.

        Index '0' means the first position, '1' the second and so on.
        Similarly, '-1' is the last position, '-2' the second last, and so on.
        Using an index that does not exist on the list causes an error.
        The index can be either an integer or a string that can be converted
        to an integer.

        Example:
        | ${x} = | Remove From List | ${L2} | 0 |
        =>
        - ${x} = 'a'
        - ${L2} = ['b']
        """
        try:
            return list_.pop(self._index_to_int(index))
        except IndexError:
            self._index_error(list_, index)

    def remove_duplicates(self, list_):
        """Returns a list without duplicates based on the given `list`.

        Creates and returns a new list that contains all items in the given
        list so that one item can appear only once. Order of the items in
        the new list is the same as in the original except for missing
        duplicates. Number of the removed duplicates is logged.

        New in Robot Framework 2.7.5.
        """
        ret = []
        for item in list_:
            if item not in ret:
                ret.append(item)
        removed = len(list_) - len(ret)
        logger.info('%d duplicate%s removed.' % (removed, plural_or_not(removed)))
        return ret

    def get_from_list(self, list_, index):
        """Returns the value specified with an `index` from `list`.

        The given list is never altered by this keyword.

        Index '0' means the first position, '1' the second, and so on.
        Similarly, '-1' is the last position, '-2' the second last, and so on.
        Using an index that does not exist on the list causes an error.
        The index can be either an integer or a string that can be converted
        to an integer.

        Examples (including Python equivalents in comments):
        | ${x} = | Get From List | ${L5} | 0  | # L5[0]  |
        | ${y} = | Get From List | ${L5} | -2 | # L5[-2] |
        =>
        - ${x} = 'a'
        - ${y} = 'd'
        - ${L5} is not changed
        """
        try:
            return list_[self._index_to_int(index)]
        except IndexError:
            self._index_error(list_, index)

    def get_slice_from_list(self, list_, start=0, end=None):
        """Returns a slice of the given list between `start` and `end` indexes.

        The given list is never altered by this keyword.

        If both `start` and `end` are given, a sublist containing values from
        `start` to `end` is returned. This is the same as 'list[start:end]' in
        Python. To get all items from the beginning, use 0 as the start value,
        and to get all items until the end, use 'None' as the end value. 'None'
        is also a default value, so in this case, it is enough to give only
        `start`. If only `end` is given, `start` gets the value 0.

        Using `start` or `end` not found on the list is the same as using the
        largest (or smallest) available index.

        Examples (incl. Python equivelants in comments):
        | ${x} = | Get Slice From List | ${L5} | 2 | 4  | # L5[2:4]    |
        | ${y} = | Get Slice From List | ${L5} | 1 |    | # L5[1:None] |
        | ${z} = | Get Slice From List | ${L5} |   | -2 | # L5[0:-2]   |
        =>
        - ${x} = ['c', 'd']
        - ${y} = ['b', 'c', 'd', 'e']
        - ${z} = ['a', 'b', 'c']
        - ${L5} is not changed
        """
        start = self._index_to_int(start, True)
        if end is not None:
            end = self._index_to_int(end)
        return list_[start:end]

    def count_values_in_list(self, list_, value, start=0, end=None):
        """Returns the number of occurrences of the given `value` in `list`.

        The search can be narrowed to the selected sublist by the `start` and
        `end` indexes having the same semantics as in the `Get Slice From List`
        keyword. The given list is never altered by this keyword.

        Example:
        | ${x} = | Count Values In List | ${L3} | b |
        =>
        - ${x} = 1
        - ${L3} is not changed
        """
        return self.get_slice_from_list(list_, start, end).count(value)

    def get_index_from_list(self, list_, value, start=0, end=None):
        """Returns the index of the first occurrence of the `value` on the list.

        The search can be narrowed to the selected sublist by the `start` and
        `end` indexes having the same semantics as in the `Get Slice From List`
        keyword. In case the value is not found, -1 is returned. The given list
        is never altered by this keyword.

        Example:
        | ${x} = | Get Index From List | ${L5} | d |
        =>
        - ${x} = 3
        - ${L5} is not changed
        """
        if start == '':
            start = 0
        list_ = self.get_slice_from_list(list_, start, end)
        try:
            return int(start) + list_.index(value)
        except ValueError:
            return -1

    def copy_list(self, list_):
        """Returns a copy of the given list.

        The given list is never altered by this keyword.
        """
        return list_[:]

    def reverse_list(self, list_):
        """Reverses the given list in place.

        Note that the given list is changed and nothing is returned. Use
        `Copy List` first, if you need to keep also the original order.

        | Reverse List | ${L3} |
        =>
        - ${L3} = ['c', 'b', 'a']
        """
        list_.reverse()

    def sort_list(self, list_):
        """Sorts the given list in place.

        The strings are sorted alphabetically and the numbers numerically.

        Note that the given list is changed and nothing is returned. Use
        `Copy List` first, if you need to keep also the original order.

        ${L} = [2,1,'a','c','b']
        | Sort List | ${L} |
        =>
        - ${L} = [1, 2, 'a', 'b', 'c']
        """
        list_.sort()

    def list_should_contain_value(self, list_, value, msg=None):
        """Fails if the `value` is not found from `list`.

        If `msg` is not given, the default error message "[ a | b | c ] does
        not contain the value 'x'" is shown in case of a failure. Otherwise,
        the given `msg` is used in case of a failure.
        """
        default = "%s does not contain value '%s'" % (seq2str2(list_), value)
        _verify_condition(value in list_, default, msg)

    def list_should_not_contain_value(self, list_, value, msg=None):
        """Fails if the `value` is not found from `list`.

        See `List Should Contain Value` for an explanation of `msg`.
        """
        default = "%s contains value '%s'" % (seq2str2(list_), value)
        _verify_condition(value not in list_, default, msg)

    def list_should_not_contain_duplicates(self, list_, msg=None):
        """Fails if any element in the `list` is found from it more than once.

        The default error message lists all the elements that were found
        from the `list` multiple times, but it can be overridden by giving
        a custom `msg`. All multiple times found items and their counts are
        also logged.

        This keyword works with all iterables that can be converted to a list.
        The original iterable is never altered.
        """
        if not isinstance(list_, list):
            list_ = list(list_)
        dupes = []
        for item in list_:
            if item not in dupes:
                count = list_.count(item)
                if count > 1:
                    logger.info("'%s' found %d times" % (item, count))
                    dupes.append(item)
        if dupes:
            raise AssertionError(msg or '%s found multiple times' % seq2str(dupes))

    def lists_should_be_equal(self, list1, list2, msg=None, values=True,
                              names=None):
        """Fails if given lists are unequal.

        The keyword first verifies that the lists have equal lengths, and then
        it checks are all their values equal. Possible differences between the
        values are listed in the default error message like `Index 4: ABC !=
        Abc`.

        The error message can be configured using `msg` and `values` arguments:
        - If `msg` is not given, the default error message is used.
        - If `msg` is given and `values` is either Boolean False or a string
          'False' or 'No Values', the error message is simply `msg`.
        - Otherwise the error message is `msg` + 'new line' + default.

        Optional `names` argument (new in 2.6) can be used for naming
        the indices shown in the default error message. It can either
        be a list of names matching the indices in the lists or a
        dictionary where keys are indices that need to be named. It is
        not necessary to name all of the indices.  When using a
        dictionary, keys can be either integers or strings that can be
        converted to integers.

        Examples:
        | ${names} = | Create List | First Name | Family Name | Email |
        | Lists Should Be Equal | ${people1} | ${people2} | names=${names} |
        | ${names} = | Create Dictionary | 0 | First Name | 2 | Email |
        | Lists Should Be Equal | ${people1} | ${people2} | names=${names} |

        If the items in index 2 would differ in the above examples, the error
        message would contain a row like `Index 2 (email): name@foo.com !=
        name@bar.com`.
        """
        len1 = len(list1)
        len2 = len(list2)
        default = 'Lengths are different: %d != %d' % (len1, len2)
        _verify_condition(len1 == len2, default, msg, values)
        names = self._get_list_index_name_mapping(names, len1)
        diffs = list(self._yield_list_diffs(list1, list2, names))
        default = 'Lists are different:\n' + '\n'.join(diffs)
        _verify_condition(diffs == [], default, msg, values)

    def _get_list_index_name_mapping(self, names, list_length):
        if not names:
            return {}
        if isinstance(names, dict):
            return dict((int(index), names[index]) for index in names)
        return dict(zip(range(list_length), names))

    def _yield_list_diffs(self, list1, list2, names):
        for index, (item1, item2) in enumerate(zip(list1, list2)):
            name = ' (%s)' % names[index] if index in names else ''
            try:
                assert_equals(item1, item2, msg='Index %d%s' % (index, name))
            except AssertionError, err:
                yield unic(err)

    def list_should_contain_sub_list(self, list1, list2, msg=None, values=True):
        """Fails if not all of the elements in `list2` are found in `list1`.

        The order of values and the number of values are not taken into
        account.

        See the use of `msg` and `values` from the `Lists Should Be Equal`
        keyword.
        """
        diffs = ', '.join(unic(item) for item in list2 if item not in list1)
        default = 'Following values were not found from first list: ' + diffs
        _verify_condition(diffs == '', default, msg, values)

    def log_list(self, list_, level='INFO'):
        """Logs the length and contents of the `list` using given `level`.

        Valid levels are TRACE, DEBUG, INFO (default), and WARN.

        If you only want to the length, use keyword `Get Length` from
        the BuiltIn library.
        """
        logger.write('\n'.join(self._log_list(list_)), level)

    def _log_list(self, list_):
        if not list_:
            yield 'List is empty'
        elif len(list_) == 1:
            yield 'List has one item:\n%s' % list_[0]
        else:
            yield 'List length is %d and it contains following items:' % len(list_)
            for index, item in enumerate(list_):
                yield '%s: %s' % (index, item)

    def _index_to_int(self, index, empty_to_zero=False):
        if empty_to_zero and not index:
            return 0
        try:
            return int(index)
        except ValueError:
            raise ValueError("Cannot convert index '%s' to an integer" % index)

    def _index_error(self, list_, index):
        raise IndexError('Given index %s is out of the range 0-%d'
                         % (index, len(list_)-1))


class _Dictionary:

    def create_dictionary(self, *key_value_pairs):
        """Creates and returns a dictionary from the given `key_value_pairs`.

        Examples:
        | ${x} = | Create Dictionary | name | value |   |   |
        | ${y} = | Create Dictionary | a    | 1     | b | 2 |
        | ${z} = | Create Dictionary | a    | ${1}  | b | ${2} |
        =>
        - ${x} = {'name': 'value'}
        - ${y} = {'a': '1', 'b': '2'}
        - ${z} = {'a': 1, 'b': 2}
        """
        if len(key_value_pairs) % 2 != 0:
            raise ValueError("Creating a dictionary failed. There should be "
                             "an even number of key-value-pairs.")
        return self.set_to_dictionary({}, *key_value_pairs)

    def set_to_dictionary(self, dictionary, *key_value_pairs):
        """Adds the given `key_value_pairs` to the `dictionary`.

        Example:
        | Set To Dictionary | ${D1} | key | value |
        =>
        - ${D1} = {'a': 1, 'key': 'value'}
        """
        if len(key_value_pairs) % 2 != 0:
            raise ValueError("Adding data to a dictionary failed. There "
                             "should be an even number of key-value-pairs.")
        for i in range(0, len(key_value_pairs), 2):
            dictionary[key_value_pairs[i]] = key_value_pairs[i+1]
        return dictionary

    def remove_from_dictionary(self, dictionary, *keys):
        """Removes the given `keys` from the `dictionary`.

        If the given `key` cannot be found from the `dictionary`, it
        is ignored.

        Example:
        | Remove From Dictionary | ${D3} | b | x | y |
        =>
        - ${D3} = {'a': 1, 'c': 3}
        """
        for key in keys:
            if key in dictionary:
                value = dictionary.pop(key)
                logger.info("Removed item with key '%s' and value '%s'" % (key, value))
            else:
                logger.info("Key '%s' not found" % (key))

    def keep_in_dictionary(self, dictionary, *keys):
        """Keeps the given `keys` in the `dictionary` and removes all other.

        If the given `key` cannot be found from the `dictionary`, it
        is ignored.

        Example:
        | Keep In Dictionary | ${D5} | b | x | d |
        =>
        - ${D5} = {'b': 2, 'd': 4}
        """
        remove_keys = [k for k in dictionary if k not in keys]
        self.remove_from_dictionary(dictionary, *remove_keys)

    def copy_dictionary(self, dictionary):
        """Returns a copy of the given dictionary.

        The given dictionary is never altered by this keyword.
        """
        return dictionary.copy()

    def get_dictionary_keys(self, dictionary):
        """Returns `keys` of the given `dictionary`.

        `Keys` are returned in sorted order. The given `dictionary` is never
        altered by this keyword.

        Example:
        | ${keys} = | Get Dictionary Keys | ${D3} |
        =>
        - ${keys} = ['a', 'b', 'c']
        """
        return sorted(dictionary)

    def get_dictionary_values(self, dictionary):
        """Returns values of the given dictionary.

        Values are returned sorted according to keys. The given dictionary is
        never altered by this keyword.

        Example:
        | ${values} = | Get Dictionary Values | ${D3} |
        =>
        - ${values} = [1, 2, 3]
        """
        return [dictionary[k] for k in self.get_dictionary_keys(dictionary)]

    def get_dictionary_items(self, dictionary):
        """Returns items of the given `dictionary`.

        Items are returned sorted by keys. The given `dictionary` is not
        altered by this keyword.

        Example:
        | ${items} = | Get Dictionary Items | ${D3} |
        =>
        - ${items} = ['a', 1, 'b', 2, 'c', 3]
        """
        ret = []
        for key in self.get_dictionary_keys(dictionary):
            ret.extend((key, dictionary[key]))
        return ret

    def get_from_dictionary(self, dictionary, key):
        """Returns a value from the given `dictionary` based on the given `key`.

        If the given `key` cannot be found from the `dictionary`, this keyword
        fails.

        The given dictionary is never altered by this keyword.

        Example:
        | ${value} = | Get From Dictionary | ${D3} | b |
        =>
        - ${value} = 2
        """
        try:
            return dictionary[key]
        except KeyError:
            raise RuntimeError("Dictionary does not contain key '%s'" % key)

    def dictionary_should_contain_key(self, dictionary, key, msg=None):
        """Fails if `key` is not found from `dictionary`.

        See `List Should Contain Value` for an explanation of `msg`.

        The given dictionary is never altered by this keyword.
        """
        default = "Dictionary does not contain key '%s'" % key
        _verify_condition(dictionary.has_key(key), default, msg)

    def dictionary_should_not_contain_key(self, dictionary, key, msg=None):
        """Fails if `key` is found from `dictionary`.

        See `List Should Contain Value` for an explanation of `msg`.

        The given dictionary is never altered by this keyword.
        """
        default = "Dictionary contains key '%s'" % key
        _verify_condition(not dictionary.has_key(key), default, msg)

    def dictionary_should_contain_value(self, dictionary, value, msg=None):
        """Fails if `value` is not found from `dictionary`.

        See `List Should Contain Value` for an explanation of `msg`.

        The given dictionary is never altered by this keyword.
        """
        default = "Dictionary does not contain value '%s'" % value
        _verify_condition(value in dictionary.values(), default, msg)

    def dictionary_should_not_contain_value(self, dictionary, value, msg=None):
        """Fails if `value` is found from `dictionary`.

        See `List Should Contain Value` for an explanation of `msg`.

        The given dictionary is never altered by this keyword.
        """
        default = "Dictionary contains value '%s'" % value
        _verify_condition(not value in dictionary.values(), default, msg)

    def dictionaries_should_be_equal(self, dict1, dict2, msg=None, values=True):
        """Fails if the given dictionaries are not equal.

        First the equality of dictionaries' keys is checked and after that all
        the key value pairs. If there are differences between the values, those
        are listed in the error message.

        See `Lists Should Be Equal` for an explanation of `msg`.
        The given dictionaries are never altered by this keyword.
        """
        keys = self._keys_should_be_equal(dict1, dict2, msg, values)
        self._key_values_should_be_equal(keys, dict1, dict2, msg, values)

    def dictionary_should_contain_sub_dictionary(self, dict1, dict2, msg=None,
                                                 values=True):
        """Fails unless all items in `dict2` are found from `dict1`.

        See `Lists Should Be Equal` for an explanation of `msg`.
        The given dictionaries are never altered by this keyword.
        """
        keys = self.get_dictionary_keys(dict2)
        diffs = [unic(k) for k in keys if k not in dict1]
        default = "Following keys missing from first dictionary: %s" \
                  % ', '.join(diffs)
        _verify_condition(diffs == [], default, msg, values)
        self._key_values_should_be_equal(keys, dict1, dict2, msg, values)

    def log_dictionary(self, dictionary, level='INFO'):
        """Logs the size and contents of the `dictionary` using given `level`.

        Valid levels are TRACE, DEBUG, INFO (default), and WARN.

        If you only want to log the size, use keyword `Get Length` from
        the BuiltIn library.
        """
        logger.write('\n'.join(self._log_dictionary(dictionary)), level)

    def _log_dictionary(self, dictionary):
        if not dictionary:
            yield 'Dictionary is empty'
        elif len(dictionary) == 1:
            yield 'Dictionary has one item:'
        else:
            yield 'Dictionary size is %d and it contains following items:' % len( dictionary)
        for key in self.get_dictionary_keys(dictionary):
            yield '%s: %s' % (key, dictionary[key])

    def _keys_should_be_equal(self, dict1, dict2, msg, values):
        keys1 = self.get_dictionary_keys(dict1)
        keys2 = self.get_dictionary_keys(dict2)
        miss1 = [unic(k) for k in keys2 if k not in dict1]
        miss2 = [unic(k) for k in keys1 if k not in dict2]
        error = []
        if miss1:
            error += ['Following keys missing from first dictionary: %s'
                      % ', '.join(miss1)]
        if miss2:
            error += ['Following keys missing from second dictionary: %s'
                      % ', '.join(miss2)]
        _verify_condition(error == [], '\n'.join(error), msg, values)
        return keys1

    def _key_values_should_be_equal(self, keys, dict1, dict2, msg, values):
        diffs = list(self._yield_dict_diffs(keys, dict1, dict2))
        default = 'Following keys have different values:\n' + '\n'.join(diffs)
        _verify_condition(diffs == [], default, msg, values)

    def _yield_dict_diffs(self, keys, dict1, dict2):
        for key in keys:
            try:
                assert_equals(dict1[key], dict2[key], msg='Key %s' % (key,))
            except AssertionError, err:
                yield unic(err)


class Collections(_List, _Dictionary):

    """A test library providing keywords for handling lists and dictionaries.

    `Collections` is Robot Framework's standard library that provides a
    set of keywords for handling Python lists and dictionaries. This
    library has keywords, for example, for modifying and getting
    values from lists and dictionaries (e.g. `Append To List`, `Get
    From Dictionary`) and for verifying their contents (e.g. `Lists
    Should Be Equal`, `Dictionary Should Contain Value`).

    Following keywords from the BuiltIn library can also be used with
    lists and dictionaries:
    | *Keyword Name*               | *Applicable With* |
    | `Create List`                | lists |
    | `Get Length`                 | both  |
    | `Length Should Be`           | both  |
    | `Should Be Empty`            | both  |
    | `Should Not Be Empty`        | both  |
    | `Should Contain`             | lists |
    | `Should Not Contain`         | lists |
    | `Should Contain X Times`     | lists |
    | `Should Not Contain X Times` | lists |
    | `Get Count`                  | lists |

    All list keywords expect a scalar variable (e.g. ${list}) as an
    argument.  It is, however, possible to use list variables
    (e.g. @{list}) as scalars simply by replacing '@' with '$'.

    List keywords that do not alter the given list can also be used
    with tuples, and to some extend also with other iterables.
    `Convert To List` can be used to convert tuples and other iterables
    to lists.

    -------

    List related keywords use variables in format ${Lx} in their examples,
    which means a list with as many alphabetic characters as specified by 'x'.
    For example ${L1} means ['a'] and ${L3} means ['a', 'b', 'c'].

    Dictionary keywords use similar ${Dx} variables. For example ${D1} means
    {'a': 1} and ${D3} means {'a': 1, 'b': 2, 'c': 3}.

    --------
    """
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'
    ROBOT_LIBRARY_VERSION = get_version()


def _verify_condition(condition, default_msg, given_msg, include_default=False):
    if not condition:
        if not given_msg:
            raise AssertionError(default_msg)
        if _include_default_message(include_default):
            raise AssertionError(given_msg + '\n' + default_msg)
        raise AssertionError(given_msg)

def _include_default_message(include):
    if isinstance(include, basestring):
        return include.lower() not in ['no values', 'false']
    return bool(include)

########NEW FILE########
__FILENAME__ = DeprecatedBuiltIn
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import re
import fnmatch


from robot.utils import asserts

import BuiltIn


BUILTIN = BuiltIn.BuiltIn()

class DeprecatedBuiltIn:
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'

    integer = BUILTIN.convert_to_integer
    float = BUILTIN.convert_to_number
    string = BUILTIN.convert_to_string
    boolean = BUILTIN.convert_to_boolean
    list = BUILTIN.create_list

    equal = equals = fail_unless_equal = BUILTIN.should_be_equal
    not_equal = not_equals = fail_if_equal = BUILTIN.should_not_be_equal
    is_true = fail_unless = BUILTIN.should_be_true
    is_false = fail_if = BUILTIN.should_not_be_true
    fail_if_ints_equal = ints_not_equal = BUILTIN.should_not_be_equal_as_integers
    ints_equal = fail_unless_ints_equal = BUILTIN.should_be_equal_as_integers
    floats_not_equal = fail_if_floats_equal = BUILTIN.should_not_be_equal_as_numbers
    floats_equal = fail_unless_floats_equal = BUILTIN.should_be_equal_as_numbers
    does_not_start = fail_if_starts = BUILTIN.should_not_start_with
    starts = fail_unless_starts = BUILTIN.should_start_with
    does_not_end = fail_if_ends = BUILTIN.should_not_end_with
    ends = fail_unless_ends = BUILTIN.should_end_with
    does_not_contain = fail_if_contains = BUILTIN.should_not_contain
    contains = fail_unless_contains = BUILTIN.should_contain
    does_not_match = fail_if_matches = BUILTIN.should_not_match
    matches = fail_unless_matches = BUILTIN.should_match
    does_not_match_regexp = fail_if_regexp_matches = BUILTIN.should_not_match_regexp
    matches_regexp = fail_unless_regexp_matches = BUILTIN.should_match_regexp

    noop = BUILTIN.no_operation
    set_ = BUILTIN.set_variable
    message = BUILTIN.comment

    variable_exists = fail_unless_variable_exists = BUILTIN.variable_should_exist
    variable_does_not_exist = fail_if_variable_exists = BUILTIN.variable_should_not_exist

    def error(self, msg=None):
        """Errors the test immediately with the given message."""
        asserts.error(msg)

    def grep(self, text, pattern, pattern_type='literal string'):
        lines = self._filter_lines(text.splitlines(), pattern, pattern_type)
        return '\n'.join(lines)

    def _filter_lines(self, lines, pattern, ptype):
        ptype = ptype.lower().replace(' ','').replace('-','')
        if not pattern:
            filtr = lambda line: True
        elif 'simple' in ptype or 'glob' in ptype:
            if 'caseinsensitive' in ptype:
                pattern = pattern.lower()
                filtr = lambda line: fnmatch.fnmatchcase(line.lower(), pattern)
            else:
                filtr = lambda line: fnmatch.fnmatchcase(line, pattern)
        elif 'regularexpression' in ptype or 'regexp' in ptype:
            pattern = re.compile(pattern)
            filtr = lambda line: pattern.search(line)
        elif 'caseinsensitive' in ptype:
            pattern = pattern.lower()
            filtr = lambda line: pattern in line.lower()
        else:
            filtr = lambda line: pattern in line
        return [ line for line in lines if filtr(line) ]


########NEW FILE########
__FILENAME__ = DeprecatedOperatingSystem
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import OperatingSystem

OPSYS = OperatingSystem.OperatingSystem()

class DeprecatedOperatingSystem:
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'

    delete_environment_variable = OPSYS.remove_environment_variable
    environment_variable_is_set = OPSYS.environment_variable_should_be_set
    environment_variable_is_not_set = OPSYS.environment_variable_should_not_be_set

    fail_unless_exists = OPSYS.should_exist
    fail_if_exists = OPSYS.should_not_exist
    fail_unless_file_exists = OPSYS.file_should_exist
    fail_if_file_exists = OPSYS.file_should_not_exist
    fail_unless_dir_exists = OPSYS.directory_should_exist
    fail_if_dir_exists = OPSYS.directory_should_not_exist
    fail_unless_dir_empty = OPSYS.directory_should_be_empty
    fail_if_dir_empty = OPSYS.directory_should_not_be_empty
    fail_unless_file_empty = OPSYS.file_should_be_empty
    fail_if_file_empty = OPSYS.file_should_not_be_empty

    empty_dir = OPSYS.empty_directory
    remove_dir = OPSYS.remove_directory
    copy_dir = OPSYS.copy_directory
    move_dir = OPSYS.move_directory
    create_dir = OPSYS.create_directory
    list_dir = OPSYS.list_directory
    list_files_in_dir = OPSYS.list_files_in_directory
    list_dirs_in_dir = OPSYS.list_directories_in_directory
    count_items_in_dir = OPSYS.count_items_in_directory
    count_files_in_dir = OPSYS.count_files_in_directory
    count_dirs_in_dir = OPSYS.count_directories_in_directory

########NEW FILE########
__FILENAME__ = Dialogs
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""A test library providing dialogs for interacting with users.

`Dialogs` is Robot Framework's standard library that provides means
for pausing the test execution and getting input from users. The
dialogs are slightly different depending on are tests run on Python or
Jython but they provide the same functionality.

The library has following two limitations:
- It is not compatible with IronPython.
- It cannot be used with timeouts on Python.
"""

import sys

if sys.platform.startswith('java'):
    from dialogs_jy import MessageDialog, PassFailDialog, InputDialog, SelectionDialog
elif sys.platform == 'cli':
    from dialogs_ipy import MessageDialog, PassFailDialog, InputDialog, SelectionDialog
else:
    from dialogs_py import MessageDialog, PassFailDialog, InputDialog, SelectionDialog

try:
    from robot.version import get_version
except ImportError:
    __version__ = '<unknown>'
else:
    __version__ = get_version()

__all__ = ['execute_manual_step', 'get_value_from_user',
           'get_selection_from_user', 'pause_execution']


def pause_execution(message='Test execution paused. Press OK to continue.'):
    """Pauses test execution until user clicks `Ok` button.

    `message` is the message shown in the dialog.
    """
    MessageDialog(message).show()


def execute_manual_step(message, default_error=''):
    """Pauses test execution until user sets the keyword status.

    User can select 'PASS' or 'FAIL', and in the latter case an additional
    dialog is opened for defining the error message.

    `message` is the instruction shown in the initial dialog and
    `default_error` is the default value shown in the possible error message
    dialog.
    """
    if not PassFailDialog(message).show():
        msg = get_value_from_user('Give error message:', default_error)
        raise AssertionError(msg)


def get_value_from_user(message, default_value=''):
    """Pauses test execution and asks user to input a value.

    `message` is the instruction shown in the dialog and `default_value` is
    the possible default value shown in the input field. Selecting 'Cancel'
    fails the keyword.
    """
    return _validate_user_input(InputDialog(message, default_value))


def get_selection_from_user(message, *values):
    """Pauses test execution and asks user to select a value.

    `message` is the instruction shown in the dialog and `values` are
    the options given to the user. Selecting 'Cancel' fails the keyword.
    """
    return _validate_user_input(SelectionDialog(message, values))


def _validate_user_input(dialog):
    value = dialog.show()
    if value is None:
        raise RuntimeError('No value provided by user')
    return value

########NEW FILE########
__FILENAME__ = dialogs_ipy
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class _AbstractWinformsDialog:

    def __init__(self):
        raise RuntimeError('This keyword is not yet implemented with IronPython')


class MessageDialog(_AbstractWinformsDialog):

    def __init__(self, message):
        _AbstractWinformsDialog.__init__(self)


class InputDialog(_AbstractWinformsDialog):

    def __init__(self, message, default):
        _AbstractWinformsDialog.__init__(self)


class SelectionDialog(_AbstractWinformsDialog):

    def __init__(self, message, options):
        _AbstractWinformsDialog.__init__(self)


class PassFailDialog(_AbstractWinformsDialog):

    def __init__(self, message):
        _AbstractWinformsDialog.__init__(self)

########NEW FILE########
__FILENAME__ = dialogs_jy
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import time
from javax.swing import JOptionPane
from javax.swing.JOptionPane import PLAIN_MESSAGE, UNINITIALIZED_VALUE, \
    YES_NO_OPTION, OK_CANCEL_OPTION, DEFAULT_OPTION


class _SwingDialog(object):

    def __init__(self, pane):
        self._pane = pane

    def show(self):
        self._show_dialog(self._pane)
        return self._get_value(self._pane)

    def _show_dialog(self, pane):
        dialog = pane.createDialog(None, 'Robot Framework')
        dialog.setModal(False)
        dialog.setAlwaysOnTop(True)
        dialog.show()
        while dialog.isShowing():
            time.sleep(0.2)
        dialog.dispose()

    def _get_value(self, pane):
        value = pane.getInputValue()
        return value if value != UNINITIALIZED_VALUE else None


class MessageDialog(_SwingDialog):

    def __init__(self, message):
        pane = JOptionPane(message, PLAIN_MESSAGE, DEFAULT_OPTION)
        _SwingDialog.__init__(self, pane)


class InputDialog(_SwingDialog):

    def __init__(self, message, default):
        pane = JOptionPane(message, PLAIN_MESSAGE, OK_CANCEL_OPTION)
        pane.setWantsInput(True)
        pane.setInitialSelectionValue(default)
        _SwingDialog.__init__(self, pane)


class SelectionDialog(_SwingDialog):

    def __init__(self, message, options):
        pane = JOptionPane(message, PLAIN_MESSAGE, OK_CANCEL_OPTION)
        pane.setWantsInput(True)
        pane.setSelectionValues(options)
        _SwingDialog.__init__(self, pane)


class PassFailDialog(_SwingDialog):

    def __init__(self, message):
        pane = JOptionPane(message, PLAIN_MESSAGE, YES_NO_OPTION,
                           None, ['PASS', 'FAIL'], 'PASS')
        _SwingDialog.__init__(self, pane)

    def _get_value(self, pane):
        return pane.getValue() == 'PASS'

########NEW FILE########
__FILENAME__ = dialogs_py
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
from threading import currentThread
from Tkinter import (Tk, Toplevel, Frame, Listbox, Label, Button, Entry,
                     BOTH, END, LEFT, W)


class _TkDialog(Toplevel):
    _left_button = 'OK'
    _right_button = 'Cancel'

    def __init__(self, message, value=None):
        self._prevent_execution_with_timeouts()
        Toplevel.__init__(self, self._get_parent())
        self._init_dialog()
        self._create_body(message, value)
        self._create_buttons()
        self._result = None

    def show(self):
        self.wait_window(self)
        return self._result

    def _prevent_execution_with_timeouts(self):
        if 'linux' not in sys.platform \
                and currentThread().getName() != 'MainThread':
            raise RuntimeError('Dialogs library is not supported with '
                               'timeouts on Python on this platform.')

    def _get_parent(self):
        parent = Tk()
        parent.withdraw()
        return parent

    def _init_dialog(self):
        self.title('Robot Framework')
        self.grab_set()
        self.protocol("WM_DELETE_WINDOW", self._right_button_clicked)
        self.bind("<Escape>", self._right_button_clicked)
        self.minsize(250, 80)
        self.geometry("+%d+%d" % self._get_center_location())
        self._bring_to_front()

    def _get_center_location(self):
        x = (self.winfo_screenwidth() - self.winfo_reqwidth()) / 2
        y = (self.winfo_screenheight() - self.winfo_reqheight()) / 2
        return x, y

    def _bring_to_front(self):
        self.attributes('-topmost', True)
        self.attributes('-topmost', False)

    def _create_body(self, message, value):
        frame = Frame(self)
        Label(frame, text=message, anchor=W, justify=LEFT).pack(fill=BOTH)
        selector = self._create_selector(frame, value)
        if selector:
            selector.pack(fill=BOTH)
            selector.focus_set()
        frame.pack(padx=5, pady=5, expand=1, fill=BOTH)

    def _create_selector(self, frame, value):
        return None

    def _create_buttons(self):
        frame = Frame(self)
        self._create_button(frame, self._left_button,
                            self._left_button_clicked)
        self._create_button(frame, self._right_button,
                            self._right_button_clicked)
        frame.pack()

    def _create_button(self, parent, label, callback):
        if label:
            button = Button(parent, text=label, width=10, command=callback)
            button.pack(side=LEFT, padx=5, pady=5)

    def _left_button_clicked(self, event=None):
        if self._validate_value():
            self._result = self._get_value()
            self.destroy()

    def _get_value(self):
        return None

    def _validate_value(self):
        return True

    def _right_button_clicked(self, event=None):
        self._result = self._get_right_button_value()
        self.destroy()

    def _get_right_button_value(self):
        return None


class MessageDialog(_TkDialog):
    _right_button = None


class InputDialog(_TkDialog):

    def __init__(self, message, default=''):
        _TkDialog.__init__(self, message, default)

    def _create_selector(self, parent, default):
        self._entry = Entry(parent)
        self._entry.insert(0, default)
        self._entry.select_range(0, END)
        return self._entry

    def _get_value(self):
        return self._entry.get()


class SelectionDialog(_TkDialog):

    def __init__(self, message, values):
        _TkDialog.__init__(self, message, values)

    def _create_selector(self, parent, values):
        self._listbox = Listbox(parent)
        for item in values:
            self._listbox.insert(END, item)
        return self._listbox

    def _validate_value(self):
        return bool(self._listbox.curselection())

    def _get_value(self):
        return self._listbox.get(self._listbox.curselection())


class PassFailDialog(_TkDialog):
    _left_button = 'PASS'
    _right_button = 'FAIL'

    def _get_value(self):
        return True

    def _get_right_button_value(self):
        return False

########NEW FILE########
__FILENAME__ = Easter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

def none_shall_pass(who):
    if who is not None:
        raise AssertionError('None shall pass!')
    print '*HTML* <object width="480" height="385"><param name="movie" value="http://www.youtube.com/v/dhRUe-gz690&hl=en_US&fs=1&rel=0&color1=0x234900&color2=0x4e9e00"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/dhRUe-gz690&hl=en_US&fs=1&rel=0&color1=0x234900&color2=0x4e9e00" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="480" height="385"></embed></object>'

########NEW FILE########
__FILENAME__ = OperatingSystem
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys
import time
import glob
import fnmatch
import shutil
import subprocess

try:
    from robot.version import get_version
    from robot.api import logger
    from robot.utils import (ConnectionCache, seq2str, timestr_to_secs,
                             secs_to_timestr, plural_or_not, get_time, abspath,
                             secs_to_timestamp, parse_time, unic, decode_output,
                             get_env_var, set_env_var, del_env_var, get_env_vars,
                             decode_from_system)
    __version__ = get_version()
    PROCESSES = ConnectionCache('No active processes')
    del ConnectionCache, get_version

# Support for using this library without installed Robot Framework
except ImportError:
    from os.path import abspath
    from os import (getenv as get_env_var, putenv as set_env_var,
                    unsetenv as del_env_var, environ)
    __version__ = '<unknown>'
    get_env_vars = environ.copy
    logger = None
    seq2str = lambda items: ', '.join("'%s'" % item for item in items)
    timestr_to_secs = int
    plural_or_not = lambda count: '' if count == 1 else 's'
    secs_to_timestr = lambda secs: '%d second%s' % (secs, plural_or_not(secs))
    unic = unicode
    decode_output = decode_from_system = lambda string: string
    class _NotImplemented:
        def __getattr__(self, name):
            raise NotImplementedError('This usage requires Robot Framework '
                                      'to be installed.')
    get_time = secs_to_timestamp = parse_time = PROCESSES = _NotImplemented()


class OperatingSystem:
    """A test library providing keywords for OS related tasks.

    `OperatingSystem` is Robot Framework's standard library that
    enables various operating system related tasks to be performed in
    the system where Robot Framework is running. It can, among other
    things, execute commands (e.g. `Run`), create and remove files and
    directories (e.g. `Create File`, `Remove Directory`), check
    whether files or directories exists or contain something
    (e.g. `File Should Exist`, `Directory Should Be Empty`) and
    manipulate environment variables (e.g. `Set Environment Variable`).

    = Pattern matching =

    Some keywords allow their arguments to be specified as _glob patterns_
    where:
    | *        | matches anything, even an empty string |
    | ?        | matches any single character |
    | [chars]  | matches any character inside square brackets (e.g. '[abc]' matches either 'a', 'b' or 'c') |
    | [!chars] | matches any character not inside square brackets |

    Unless otherwise noted, matching is case-insensitive on
    case-insensitive operating systems such as Windows. Pattern
    matching is implemented using Python's `fnmatch` module:
    http://docs.python.org/library/fnmatch.html

    = Path separators =

    All keywords expecting paths as arguments accept a forward slash
    (`/`) as a path separator regardless the operating system. Notice
    that this *does not work when the path is part of an argument*,
    like it often is with `Run` and `Start Process` keywords. In such
    cases the built-in variable `${/}` can be used to keep the test
    data platform independent.

    = Example =

    |  *Setting*  |     *Value*     |
    | Library     | OperatingSystem |

    | *Variable*  |       *Value*         |
    | ${PATH}     | ${CURDIR}/example.txt |

    | *Test Case* |     *Action*      | *Argument* |    *Argument*       |
    | Example     | Create File       | ${PATH}    | Some text           |
    |             | File Should Exist | ${PATH}    |                     |
    |             | Copy File         | ${PATH}    | ${TEMPDIR}/stuff    |
    |             | ${output} =       | Run | ${CURDIR}${/}script.py arg |
    """

    ROBOT_LIBRARY_SCOPE = 'GLOBAL'
    ROBOT_LIBRARY_VERSION = __version__

    def run(self, command):
        """Runs the given command in the system and returns the output.

        The execution status of the command *is not checked* by this
        keyword, and it must be done separately based on the returned
        output. If the execution return code is needed, either `Run
        And Return RC` or `Run And Return RC And Output` can be used.

        The standard error stream is automatically redirected to the standard
        output stream by adding `2>&1` after the executed command. This
        automatic redirection is done only when the executed command does not
        contain additional output redirections. You can thus freely forward
        the standard error somewhere else, for example, like
        `my_command 2>stderr.txt`.

        The returned output contains everything written into the standard
        output or error streams by the command (unless either of them
        is redirected explicitly). Many commands add an extra newline
        (`\\n`) after the output to make it easier to read in the
        console. To ease processing the returned output, this possible
        trailing newline is stripped by this keyword.

        Examples:
        | ${output} =        | Run       | ls -lhF /tmp |
        | Log                | ${output} |
        | ${result} =        | Run       | ${CURDIR}${/}tester.py arg1 arg2 |
        | Should Not Contain | ${result} | FAIL |
        | ${stdout} =        | Run       | /opt/script.sh 2>/tmp/stderr.txt |
        | Should Be Equal    | ${stdout} | TEST PASSED |
        | File Should Be Empty | /tmp/stderr.txt |
        """
        return self._run(command)[1]

    def run_and_return_rc(self, command):
        """Runs the given command in the system and returns the return code.

        The return code (RC) is returned as a positive integer in
        range from 0 to 255 as returned by the executed command. On
        some operating systems (notable Windows) original return codes
        can be something else, but this keyword always maps them to
        the 0-255 range. Since the RC is an integer, it must be
        checked e.g. with the keyword `Should Be Equal As Integers`
        instead of `Should Be Equal` (both are built-in keywords).

        Examples:
        | ${rc} = | Run and Return RC | ${CURDIR}${/}script.py arg |
        | Should Be Equal As Integers | ${rc} | 0 |
        | ${rc} = | Run and Return RC | /path/to/example.rb arg1 arg2 |
        | Should Be True | 0 < ${rc} < 42 |

        See `Run` and `Run And Return RC And Output` if you need to get the
        output of the executed command.
        """
        return self._run(command)[0]

    def run_and_return_rc_and_output(self, command):
        """Runs the given command in the system and returns the RC and output.

        The return code (RC) is returned similarly as with `Run And Return RC`
        and the output similarly as with `Run`.

        Examples:
        | ${rc} | ${output} =  | Run and Return RC and Output | ${CURDIR}${/}mytool |
        | Should Be Equal As Integers | ${rc}    | 0    |
        | Should Not Contain   | ${output}       | FAIL |
        | ${rc} | ${stdout} =  | Run and Return RC and Output | /opt/script.sh 2>/tmp/stderr.txt |
        | Should Be True       | ${rc} > 42      |
        | Should Be Equal      | ${stdout}       | TEST PASSED |
        | File Should Be Empty | /tmp/stderr.txt |
        """
        return self._run(command)

    def _run(self, command):
        process = _Process(command)
        self._info("Running command '%s'" % process)
        stdout = process.read()
        rc = process.close()
        return rc, stdout

    def start_process(self, command, stdin=None, alias=None):
        """Starts the given command as a background process.

        Starts the process in the background and sets this process as
        the current process. The following calls of the keywords `Read
        Process Output` or `Stop Process` affect this process, unless
        the keyword `Switch Process` is used.

        If the command needs input through the standard input stream,
        it can be defined with the `stdin` argument.  It is not
        possible to give input to the command later. Possible command
        line arguments must be given as part of the command like
        '/tmp/script.sh arg1 arg2'.

        Returns the index of this process. The indexing starts from 1, and it
        can be used to switch between the processes with the `Switch Process`
        keyword. To wait until all processes terminate and to reset indexing, the
        `Stop All Processes` keyword must be used.

        The optional `alias` is a name for this process that may be used with
        `Switch Process` instead of the returned index.

        The standard error stream is redirected to the standard input
        stream automatically by adding '2>&1' after the executed
        command. This is done the same way, and for the same reasons,
        as with `Run` keyword.

        Example:
        | Start Process  | /path/longlasting.sh |
        | Do Something   |                      |
        | ${output} =    | Read Process Output  |
        | Should Contain | ${output}            | Expected text |
        | [Teardown]     | Stop All Processes   |
        """
        process = _Process2(command, stdin)
        self._info("Running command '%s'" % process)
        return PROCESSES.register(process, alias)

    def switch_process(self, index_or_alias):
        """Switches the active process to the specified process.

        The index is the return value of the `Start Process` keyword and an
        alias may have been defined to it.

        Example:
        | Start Process  | /path/script.sh arg  |    | 1st process |
        | ${2nd} =       | Start Process        | /path/script2.sh |
        | Switch Process | 1st process          |
        | ${out1} =      | Read Process Output  |
        | Switch Process | ${2nd}               |
        | ${out2} =      | Read Process Output  |
        | Log Many       | 1st process: ${out1} | 2nd process: ${out1} |
        | [Teardown]     | Stop All Processes   |
        """
        PROCESSES.switch(index_or_alias)

    def read_process_output(self):
        """Waits for the process to finish and returns its output.

        As mentioned in the documentation of `Start Process` keyword,
        and documented thoroughly in `Run` keyword, the standard error
        stream is automatically redirected to the standard
        output. This keyword thus always returns all the output
        procuded by the command.

        Note that although the process is finished, it is not removed
        from the process list. Trying to read from a stopped process
        nevertheless fails. To reset the process list (and indexes and
        aliases), `Stop All Processes` must be used.

        See `Start Process` and `Switch Process` for more information
        and examples about running processes.
        """
        output = PROCESSES.current.read()
        PROCESSES.current.close()
        return output

    def stop_process(self):
        """Waits until the current process terminates without reading from it.

        Note that this keyword does not actually stop the process, only waits
        until it terminates on its own. It does not either remove it from the
        process list. To reset the process list (and indexes and aliases),
        `Stop All Processes` must be used. Calling Stop Process on a process
        that has already terminated has no effect.

        See `Start Process` and `Switch Process` for more information.
        """
        PROCESSES.current.close()

    def stop_all_processes(self):
        """Waits until all the processes terminate and removes them from the
        process list.

        Note that this keyword does not actually stop the processes, only waits
        until they terminate on their own.

        This keyword resets the indexing that `Start Process` uses. All aliases
        are also deleted. It does not matter have some of the processes
        already been closed or not.

        It is highly recommended to use this keyword in test or suite level
        teardown to make sure all the started processes are closed.
        """
        PROCESSES.close_all()

    def get_file(self, path, encoding='UTF-8'):
        """Returns the contents of a specified file.

        This keyword reads the specified file and returns the contents.
        Line breaks in content are converted to platform independent form.
        See also `Get Binary File`.

        `encoding` defines the encoding of the file. By default the value is
        'UTF-8', which means that UTF-8 and ASCII-encoded files are read
        correctly.
        """
        content = self.get_binary_file(path)
        return unicode(content, encoding).replace('\r\n', '\n')

    def get_binary_file(self, path):
        """Returns the contents of a specified file.

        This keyword reads the specified file and returns the contents as is.
        See also `Get File`.

        New in Robot Framework 2.5.5.
        """
        path = self._absnorm(path)
        self._link("Getting file '%s'", path)
        f = open(path, 'rb')
        try:
            return f.read()
        finally:
            f.close()

    def grep_file(self, path, pattern, encoding='UTF-8'):
        """Returns the lines of the specified file that match the `pattern`.

        This keyword reads a file from the file system using the defined
        `path` and `encoding` similarly as `Get File`. A difference is
        that only the lines that match the given `pattern` are returned.
        Lines are returned as a single string catenated back together with
        newlines and the number of matched lines is automatically logged.
        Possible trailing newline is never returned.

        A line matches if it contains the `pattern` anywhere in it and
        it *does not need to match the pattern fully*. The pattern
        matching syntax is explained in `introduction`, and in this
        case matching is case-sensitive.

        Examples:
        | ${errors} = | Grep File | /var/log/myapp.log | ERROR |
        | ${ret} = | Grep File | ${CURDIR}/file.txt | [Ww]ildc??d ex*ple |

        If more complex pattern matching is needed, it is possible to use
        `Get File` in combination with String library keywords like `Get
        Lines Matching Regexp`.
        """
        pattern = '*%s*' % pattern
        orig = self.get_file(path, encoding).splitlines()
        lines = [line for line in orig if fnmatch.fnmatchcase(line, pattern)]
        self._info('%d out of %d lines matched' % (len(lines), len(orig)))
        return '\n'.join(lines)

    def log_file(self, path, encoding='UTF-8'):
        """Wrapper for `Get File` that also logs the returned file.

        The file is logged with the INFO level. If you want something else,
        just use `Get File` and the built-in keyword `Log` with the desired
        level.
        """
        content = self.get_file(path, encoding)
        self._info(content)
        return content

    # File and directory existence

    def should_exist(self, path, msg=None):
        """Fails unless the given path (file or directory) exists.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        if not glob.glob(path):
            self._fail(msg, "Path '%s' does not match any file or directory" % path)
        self._link("Path '%s' exists", path)

    def should_not_exist(self, path, msg=None):
        """Fails if the given path (file or directory) exists.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        matches = glob.glob(path)
        if not matches:
            self._link("Path '%s' does not exist", path)
            return
        if not msg:
            if self._is_pattern_path(path):
                matches.sort()
                msg = "Path '%s' matches %s" % (path, seq2str(matches))
            else:
                msg = "Path '%s' exists" % path
        raise AssertionError(msg)

    def file_should_exist(self, path, msg=None):
        """Fails unless the given `path` points to an existing file.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        matches = [p for p in glob.glob(path) if os.path.isfile(p)]
        if not matches:
            self._fail(msg, "Path '%s' does not match any file" % path)
        self._link("File '%s' exists", path)

    def file_should_not_exist(self, path, msg=None):
        """Fails if the given path points to an existing file.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        matches = [p for p in glob.glob(path) if os.path.isfile(p)]
        if not matches:
            self._link("File '%s' does not exist", path)
            return
        if not msg:
            if self._is_pattern_path(path):
                matches.sort()
                name = len(matches) == 1 and 'file' or 'files'
                msg = "Path '%s' matches %s %s" % (path, name, seq2str(matches))
            else:
                msg = "File '%s' exists" % path
        raise AssertionError(msg)

    def directory_should_exist(self, path, msg=None):
        """Fails unless the given path points to an existing directory.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        matches = [p for p in glob.glob(path) if os.path.isdir(p)]
        if not matches:
            self._fail(msg, "Path '%s' does not match any directory" % path)
        self._link("Directory '%s' exists", path)

    def directory_should_not_exist(self, path, msg=None):
        """Fails if the given path points to an existing file.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        matches = [p for p in glob.glob(path) if os.path.isdir(p)]
        if not matches:
            self._link("Directory '%s' does not exist", path)
            return
        if not msg:
            if self._is_pattern_path(path):
                matches.sort()
                name = len(matches) == 1 and 'directory' or 'directories'
                msg = "Path '%s' matches %s %s" % (path, name, seq2str(matches))
            else:
                msg = "Directory '%s' exists" % path
        raise AssertionError(msg)

    def _is_pattern_path(self, path):
        return '*' in path or '?' in path or ('[' in path and ']' in path)

    # Waiting file/dir to appear/disappear

    def wait_until_removed(self, path, timeout='1 minute'):
        """Waits until the given file or directory is removed.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        If the path is a pattern, the keyword waits until all matching
        items are removed.

        The optional `timeout` can be used to control the maximum time of
        waiting. The timeout is given as a timeout string, e.g. in a format
        '15 seconds', '1min 10s' or just '10'. The time string format is
        described in an appendix of Robot Framework User Guide.

        If the timeout is negative, the keyword is never timed-out. The keyword
        returns immediately, if the path does not exist in the first place.
        """
        path = self._absnorm(path)
        timeout = timestr_to_secs(timeout)
        maxtime = time.time() + timeout
        while glob.glob(path):
            time.sleep(0.1)
            if timeout >= 0 and time.time() > maxtime:
                raise AssertionError("'%s' was not removed in %s"
                                     % (path, secs_to_timestr(timeout)))
        self._link("'%s' was removed", path)

    def wait_until_created(self, path, timeout='1 minute'):
        """Waits until the given file or directory is created.

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        If the path is a pattern, the keyword returns when an item matching
        it is created.

        The optional `timeout` can be used to control the maximum time of
        waiting. The timeout is given as a timeout string, e.g. in a format
        '15 seconds', '1min 10s' or just '10'. The time string format is
        described in an appendix of Robot Framework User Guide.

        If the timeout is negative, the keyword is never timed-out. The keyword
        returns immediately, if the path already exists.
        """
        path = self._absnorm(path)
        timeout = timestr_to_secs(timeout)
        maxtime = time.time() + timeout
        while not glob.glob(path):
            time.sleep(0.1)
            if timeout >= 0 and time.time() > maxtime:
                raise AssertionError("'%s' was not created in %s"
                                     % (path, secs_to_timestr(timeout)))
        self._link("'%s' was created", path)

    # Dir/file empty

    def directory_should_be_empty(self, path, msg=None):
        """Fails unless the specified directory is empty.

        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        items = self._list_dir(path)
        if items:
            if not msg:
                msg = "Directory '%s' is not empty. Contents: %s" \
                        % (path, seq2str(items, lastsep=', '))
            raise AssertionError(msg)
        self._link("Directory '%s' is empty.", path)

    def directory_should_not_be_empty(self, path, msg=None):
        """Fails if the specified directory is empty.

        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        count = len(self._list_dir(path))
        if count == 0:
            self._fail(msg, "Directory '%s' is empty." % path)
        plural = plural_or_not(count)
        self._link("Directory '%%s' contains %d item%s." % (count, plural),
                   path)

    def file_should_be_empty(self, path, msg=None):
        """Fails unless the specified file is empty.

        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        if not os.path.isfile(path):
            raise AssertionError("File '%s' does not exist" % path)
        size = os.stat(path).st_size
        if size > 0:
            self._fail(msg, "File '%s' is not empty. Size: %d bytes" % (path, size))
        self._link("File '%s' is empty", path)

    def file_should_not_be_empty(self, path, msg=None):
        """Fails if the specified directory is empty.

        The default error message can be overridden with the `msg` argument.
        """
        path = self._absnorm(path)
        if not os.path.isfile(path):
            raise AssertionError("File '%s' does not exist" % path)
        size = os.stat(path).st_size
        if size == 0:
            self._fail(msg, "File '%s' is empty." % path)
        self._link("File '%%s' contains %d bytes" % size, path)

    # Creating and removing files and directory

    def create_file(self, path, content='', encoding='UTF-8'):
        """Creates a file with the given content and encoding.

        If the directory where to create file does not exist it, and possible
        intermediate missing directories, are created.

        Use `Append To File` if you want to append to an existing file,
        and use `File Should Not Exist` if you want to avoid overwriting
        existing files.
        """
        path = self._write_to_file(path, content, encoding, 'w')
        self._link("Created file '%s'", path)

    def append_to_file(self, path, content, encoding='UTF-8'):
        """Appends the given contend to the specified file.

        If the file does not exists, this keyword works exactly the same
        way as `Create File With Encoding`.
        """
        path = self._write_to_file(path, content, encoding, 'a')
        self._link("Appended to file '%s'", path)

    def _write_to_file(self, path, content, encoding, mode):
        path = self._absnorm(path)
        parent = os.path.dirname(path)
        if not os.path.exists(parent):
            os.makedirs(parent)
        f = open(path, mode+'b')
        try:
            f.write(content.encode(encoding))
        finally:
            f.close()
        return path

    def remove_file(self, path):
        """Removes a file with the given path.

        Passes if the file does not exist, but fails if the path does
        not point to a regular file (e.g. it points to a directory).

        The path can be given as an exact path or as a glob pattern.
        The pattern matching syntax is explained in `introduction`.
        If the path is a pattern, all files matching it are removed.
        """
        path = self._absnorm(path)
        matches = glob.glob(path)
        if not matches:
            self._link("File '%s' does not exist", path)
        for match in matches:
            if not os.path.isfile(match):
                raise RuntimeError("Path '%s' is not a file" % match)
            os.remove(match)
            self._link("Removed file '%s'", match)

    def remove_files(self, *paths):
        """Uses `Remove File` to remove multiple files one-by-one.

        Example:
        | Remove Files | ${TEMPDIR}${/}foo.txt | ${TEMPDIR}${/}bar.txt | ${TEMPDIR}${/}zap.txt |
        """
        for path in paths:
            self.remove_file(path)

    def empty_directory(self, path):
        """Deletes all the content (incl. subdirectories) from the given directory."""
        path = self._absnorm(path)
        items = [os.path.join(path, item) for item in self._list_dir(path)]
        for item in items:
            if os.path.isdir(item):
                shutil.rmtree(item)
            else:
                os.remove(item)
        self._link("Emptied directory '%s'", path)

    def create_directory(self, path):
        """Creates the specified directory.

        Also possible intermediate directories are created. Passes if the
        directory already exists, and fails if the path points to a regular
        file.
        """
        path = self._absnorm(path)
        if os.path.isdir(path):
            self._link("Directory '%s' already exists", path )
            return
        if os.path.exists(path):
            raise RuntimeError("Path '%s' already exists but is not a directory" % path)
        os.makedirs(path)
        self._link("Created directory '%s'", path)

    def remove_directory(self, path, recursive=False):
        """Removes the directory pointed to by the given `path`.

        If the second argument `recursive` is set to any non-empty string,
        the directory is removed recursively. Otherwise removing fails if
        the directory is not empty.

        If the directory pointed to by the `path` does not exist, the keyword
        passes, but it fails, if the `path` points to a file.
        """
        path = self._absnorm(path)
        if not os.path.exists(path):
            self._link("Directory '%s' does not exist", path)
            return
        if os.path.isfile(path):
            raise RuntimeError("Path '%s' is not a directory" % path)
        if recursive:
            shutil.rmtree(path)
        else:
            msg = "Directory '%s' is not empty." % path
            self.directory_should_be_empty(path, msg)
            os.rmdir(path)
        self._link("Removed directory '%s'", path)

    # Moving and copying files and directories

    def copy_file(self, source, destination):
        """Copies the source file into a new destination.

        1) If the destination is an existing file, the source file is copied
        over it.

        2) If the destination is an existing directory, the source file is
        copied into it. A possible file with the same name is overwritten.

        3) If the destination does not exist and it ends with a path
        separator ('/' or '\\'), it is considered a directory. That
        directory is created and a source file copied into it.
        Possible missing intermediate directories are also created.

        4) If the destination does not exist and it does not end with a path
        separator, it is considered a file. If the path to the file does not
        exist, it is created.
        """
        source, destination = self._copy_file(source, destination)
        self._link("Copied file from '%s' to '%s'", source, destination)

    def move_file(self, source, destination):
        """Moves the source file into a new destination.

        Uses `Copy File` keyword internally, and `source` and `destination`
        arguments have exactly same semantics as with that keyword.
        """
        source, destination = self._copy_file(source, destination)
        os.remove(source)
        self._link("Moved file from '%s' to '%s'", source, destination)

    def _copy_file(self, source, dest):
        source = self._absnorm(source)
        dest = dest.replace('/', os.sep)
        dest_is_dir = dest.endswith(os.sep)
        dest = self._absnorm(dest)
        if not os.path.exists(source):
            raise RuntimeError("Source file '%s' does not exist" % source)
        if not os.path.isfile(source):
            raise RuntimeError("Source file '%s' is not a regular file" % source)
        if not os.path.exists(dest):
            if dest_is_dir:
                parent = dest
            else:
                parent = os.path.dirname(dest)
            if not os.path.exists(parent):
                os.makedirs(parent)
        shutil.copy(source, dest)
        return source, dest

    def copy_directory(self, source, destination):
        """Copies the source directory into the destination.

        If the destination exists, the source is copied under it. Otherwise
        the destination directory and the possible missing intermediate
        directories are created.
        """
        source, destination = self._copy_dir(source, destination)
        self._link("Copied directory from '%s' to '%s'", source, destination)

    def move_directory(self, source, destination):
        """Moves the source directory into a destination.

        Uses `Copy Directory` keyword internally, and `source` and
        `destination` arguments have exactly same semantics as with
        that keyword.
        """
        source, destination = self._copy_dir(source, destination)
        shutil.rmtree(source)
        self._link("Moved directory from '%s' to '%s'", source, destination)

    def _copy_dir(self, source, dest):
        source = self._absnorm(source)
        dest = self._absnorm(dest)
        if not os.path.exists(source):
            raise RuntimeError("Source directory '%s' does not exist" % source)
        if not os.path.isdir(source):
            raise RuntimeError("Source directory '%s' is not a directory" % source)
        if os.path.exists(dest) and not os.path.isdir(dest):
            raise RuntimeError("Destination '%s' exists but is not a directory" % dest)
        if os.path.exists(dest):
            base = os.path.basename(source)
            dest = os.path.join(dest, base)
        else:
            parent = os.path.dirname(dest)
            if not os.path.exists(parent):
                os.makedirs(parent)
        shutil.copytree(source, dest)
        return source, dest

    # Environment Variables

    def get_environment_variable(self, name, default=None):
        """Returns the value of an environment variable with the given name.

        If no such environment variable is set, returns the default value, if
        given. Otherwise fails the test case.

        Starting from Robot Framework 2.7, returned variables are automatically
        decoded to Unicode using the system encoding.

        Note that you can also access environment variables directly using
        the variable syntax `%{ENV_VAR_NAME}`.
        """
        value = get_env_var(name, default)
        if value is None:
            raise RuntimeError("Environment variable '%s' does not exist" % name)
        return value

    def set_environment_variable(self, name, value):
        """Sets an environment variable to a specified value.

        Values are converted to strings automatically. Starting from Robot
        Framework 2.7, set variables are automatically encoded using the system
        encoding.
        """
        set_env_var(name, value)
        self._info("Environment variable '%s' set to value '%s'" % (name, value))

    def remove_environment_variable(self, *names):
        """Deletes the specified environment variable.

        Does nothing if the environment variable is not set.

        Starting from Robot Framework 2.7, it is possible to remove multiple
        variables by passing them to this keyword as separate arguments.
        """
        for name in names:
            value = del_env_var(name)
            if value:
                self._info("Environment variable '%s' deleted" % name)
            else:
                self._info("Environment variable '%s' does not exist" % name)

    def environment_variable_should_be_set(self, name, msg=None):
        """Fails if the specified environment variable is not set.

        The default error message can be overridden with the `msg` argument.
        """
        value = get_env_var(name)
        if not value:
            self._fail(msg, "Environment variable '%s' is not set" % name)
        self._info("Environment variable '%s' is set to '%s'" % (name, value))

    def environment_variable_should_not_be_set(self, name, msg=None):
        """Fails if the specified environment variable is set.

        The default error message can be overridden with the `msg` argument.
        """
        value = get_env_var(name)
        if value:
            self._fail(msg, "Environment variable '%s' is set to '%s'" % (name, value))
        self._info("Environment variable '%s' is not set" % name)

    def get_environment_variables(self):
        """Returns currently available environment variables as a dictionary.

        Both keys and values are decoded to Unicode using the system encoding.
        Altering the returned dictionary has no effect on the actual environment
        variables.

        New in Robot Framework 2.7.
        """
        return get_env_vars()

    def log_environment_variables(self, level='INFO'):
        """Logs all environment variables using the given log level.

        Environment variables are also returned the same way as with
        `Get Environment Variables` keyword.

        New in Robot Framework 2.7.
        """
        vars = get_env_vars()
        for name, value in sorted(vars.items(), key=lambda item: item[0].lower()):
            self._log('%s = %s' % (name, value), level)
        return vars

    # Path

    def join_path(self, base, *parts):
        """Joins the given path part(s) to the given base path.

        The path separator ('/' or '\\') is inserted when needed and
        the possible absolute paths handled as expected. The resulted
        path is also normalized.

        Examples:
        | ${path} = | Join Path | my        | path  |
        | ${p2} =   | Join Path | my/       | path/ |
        | ${p3} =   | Join Path | my        | path  | my | file.txt |
        | ${p4} =   | Join Path | my        | /path |
        | ${p5} =   | Join Path | /my/path/ | ..    | path2 |
        =>
        - ${path} = 'my/path'
        - ${p2} = 'my/path'
        - ${p3} = 'my/path/my/file.txt'
        - ${p4} = '/path'
        - ${p5} = '/my/path2'
        """
        base = base.replace('/', os.sep)
        parts = [p.replace('/', os.sep) for p in parts]
        return self.normalize_path(os.path.join(base, *parts))

    def join_paths(self, base, *paths):
        """Joins given paths with base and returns resulted paths.

        See `Join Path` for more information.

        Examples:
        | @{p1} = | Join Path | base     | example       | other |          |
        | @{p2} = | Join Path | /my/base | /example      | other |          |
        | @{p3} = | Join Path | my/base  | example/path/ | other | one/more |
        =>
        - @{p1} = ['base/example', 'base/other']
        - @{p2} = ['/example', '/my/base/other']
        - @{p3} = ['my/base/example/path', 'my/base/other', 'my/base/one/more']
        """
        return [self.join_path(base, path) for path in paths]

    def normalize_path(self, path):
        """Normalizes the given path.

        Examples:
        | ${path} = | Normalize Path | abc        |
        | ${p2} =   | Normalize Path | abc/       |
        | ${p3} =   | Normalize Path | abc/../def |
        | ${p4} =   | Normalize Path | abc/./def  |
        | ${p5} =   | Normalize Path | abc//def   |
        =>
        - ${path} = 'abc'
        - ${p2} = 'abc'
        - ${p3} = 'def'
        - ${p4} = 'abc/def'
        - ${p5} = 'abc/def'
        """
        return os.path.normpath(path.replace('/', os.sep)) or '.'

    def split_path(self, path):
        """Splits the given path from the last path separator ('/' or '\\').

        The given path is first normalized (e.g. a possible trailing
        path separator is removed, special directories '..' and '.'
        removed). The parts that are split are returned as separate
        components.

        Examples:
        | ${path1} | ${dir} =  | Split Path | abc/def         |
        | ${path2} | ${file} = | Split Path | abc/def/ghi.txt |
        | ${path3} | ${d2}  =  | Split Path | abc/../def/ghi/ |
        =>
        - ${path1} = 'abc' & ${dir} = 'def'
        - ${path2} = 'abc/def' & ${file} = 'ghi.txt'
        - ${path3} = 'def' & ${d2} = 'ghi'
        """
        return os.path.split(self.normalize_path(path))

    def split_extension(self, path):
        """Splits the extension from the given path.

        The given path is first normalized (e.g. possible trailing
        path separators removed, special directories '..' and '.'
        removed). The base path and extension are returned as separate
        components so that the dot used as an extension separator is
        removed. If the path contains no extension, an empty string is
        returned for it. Possible leading and trailing dots in the file
        name are never considered to be extension separators.

        Examples:
        | ${path} | ${ext} = | Split Extension | file.extension    |
        | ${p2}   | ${e2} =  | Split Extension | path/file.ext     |
        | ${p3}   | ${e3} =  | Split Extension | path/file         |
        | ${p4}   | ${e4} =  | Split Extension | p1/../p2/file.ext |
        | ${p5}   | ${e5} =  | Split Extension | path/.file.ext    |
        | ${p6}   | ${e6} =  | Split Extension | path/.file        |
        =>
        - ${path} = 'file' & ${ext} = 'extension'
        - ${p2} = 'path/file' & ${e2} = 'ext'
        - ${p3} = 'path/file' & ${e3} = ''
        - ${p4} = 'p2/file' & ${e4} = 'ext'
        - ${p5} = 'path/.file' & ${e5} = 'ext'
        - ${p6} = 'path/.file' & ${e6} = ''
        """
        path = self.normalize_path(path)
        basename = os.path.basename(path)
        if basename.startswith('.' * basename.count('.')):
            return path, ''
        if path.endswith('.'):
            path2 = path.rstrip('.')
            trailing_dots = '.' * (len(path) - len(path2))
            path = path2
        else:
            trailing_dots = ''
        basepath, ext = os.path.splitext(path)
        if ext.startswith('.'):
            ext = ext[1:]
        if ext:
            ext += trailing_dots
        else:
            basepath += trailing_dots
        return basepath, ext

    # Misc

    def get_modified_time(self, path, format='timestamp'):
        """Returns the last modification time of a file or directory.

        How time is returned is determined based on the given `format`
        string as follows. Note that all checks are case-insensitive.
        Returned time is also automatically logged.

        1) If `format` contains the word 'epoch', the time is returned
           in seconds after the UNIX epoch. The return value is always
           an integer.

        2) If `format` contains any of the words 'year', 'month',
           'day', 'hour', 'min' or 'sec', only the selected parts are
           returned. The order of the returned parts is always the one
           in the previous sentence and the order of the words in
           `format` is not significant. The parts are returned as
           zero-padded strings (e.g. May -> '05').

        3) Otherwise, and by default, the time is returned as a
           timestamp string in the format '2006-02-24 15:08:31'.

        Examples (when the modified time of the ${CURDIR} is
        2006-03-29 15:06:21):
        | ${time} = | Get Modified Time | ${CURDIR} |
        | ${secs} = | Get Modified Time | ${CURDIR} | epoch |
        | ${year} = | Get Modified Time | ${CURDIR} | return year |
        | ${y} | ${d} = | Get Modified Time | ${CURDIR} | year,day |
        | @{time} = | Get Modified Time | ${CURDIR} | year,month,day,hour,min,sec |
        =>
        - ${time} = '2006-03-29 15:06:21'
        - ${secs} = 1143637581
        - ${year} = '2006'
        - ${y} = '2006' & ${d} = '29'
        - @{time} = ['2006', '03', '29', '15', '06', '21']
        """
        path = self._absnorm(path)
        if not os.path.exists(path):
            raise RuntimeError("Getting modified time of '%s' failed: "
                               "Path does not exist" % path)
        mtime = get_time(format, os.stat(path).st_mtime)
        self._link("Last modified time of '%%s' is %s" % mtime, path)
        return mtime

    def set_modified_time(self, path, mtime):
        """Sets the file modification and access times.

        Changes the modification and access times of the given file to
        the value determined by `mtime`. The time can be given in
        different formats described below. Note that all checks
        involving strings are case-insensitive.

        1) If `mtime` is a number, or a string that can be converted
           to a number, it is interpreted as seconds since the UNIX
           epoch (1970-01-01 00:00:00 UTC). This documentation was
           originally written about 1177654467 seconds after the epoch.

        2) If `mtime` is a timestamp, that time will be used. Valid
           timestamp formats are 'YYYY-MM-DD hh:mm:ss' and 'YYYYMMDD hhmmss'.

        3) If `mtime` is equal to 'NOW', the current local time is used.
           This time is got using Python's 'time.time()' function.

        4) If `mtime` is equal to 'UTC', the current time in
           [http://en.wikipedia.org/wiki/Coordinated_Universal_Time|UTC]
           is used. This time is got using 'time.time() + time.altzone'
           in Python.

        5) If `mtime` is in the format like 'NOW - 1 day' or 'UTC + 1
           hour 30 min', the current local/UTC time plus/minus the time
           specified with the time string is used. The time string format
           is described in an appendix of Robot Framework User Guide.

        Examples:
        | Set Modified Time | /path/file | 1177654467         | # Time given as epoch seconds |
        | Set Modified Time | /path/file | 2007-04-27 9:14:27 | # Time given as a timestamp   |
        | Set Modified Time | /path/file | NOW                | # The local time of execution |
        | Set Modified Time | /path/file | NOW - 1 day        | # 1 day subtracted from the local time |
        | Set Modified Time | /path/file | UTC + 1h 2min 3s   | # 1h 2min 3s added to the UTC time |

        Support for UTC time is a new feature in Robot Framework 2.7.5.
        """
        path = self._absnorm(path)
        try:
            if not os.path.exists(path):
                raise ValueError('File does not exist')
            if not os.path.isfile(path):
                raise ValueError('Modified time can only be set to regular files')
            mtime = parse_time(mtime)
        except ValueError, err:
            raise RuntimeError("Setting modified time of '%s' failed: %s"
                               % (path, unicode(err)))
        os.utime(path, (mtime, mtime))
        time.sleep(0.1)  # Give os some time to really set these times
        tstamp = secs_to_timestamp(mtime, ('-',' ',':'))
        self._link("Set modified time of '%%s' to %s" % tstamp, path)

    def get_file_size(self, path):
        """Returns and logs file size as an integer in bytes"""
        path = self._absnorm(path)
        if not os.path.isfile(path):
            raise RuntimeError("File '%s' does not exist." % path)
        size = os.stat(path).st_size
        plural = plural_or_not(size)
        self._link("Size of file '%%s' is %d byte%s" % (size, plural), path)
        return size

    def list_directory(self, path, pattern=None, absolute=False):
        """Returns and logs items in a directory, optionally filtered with `pattern`.

        File and directory names are returned in case-sensitive alphabetical
        order, e.g. ['A Name', 'Second', 'a lower case name', 'one more'].
        Implicit directories '.' and '..' are not returned. The returned items
        are automatically logged.

        By default, the file and directory names are returned relative to the
        given path (e.g. 'file.txt'). If you want them be returned in the
        absolute format (e.g. '/home/robot/file.txt'), set the `absolute`
        argument to any non-empty string.

        If `pattern` is given, only items matching it are returned. The pattern
        matching syntax is explained in `introduction`, and in this case
        matching is case-sensitive.

        Examples (using also other `List Directory` variants):
        | @{items} = | List Directory           | ${TEMPDIR} |
        | @{files} = | List Files In Directory  | /tmp | *.txt | absolute |
        | ${count} = | Count Files In Directory | ${CURDIR} | ??? |
        """
        items = self._list_dir(path, pattern, absolute)
        self._info('%d item%s:\n%s' % (len(items), plural_or_not(items), '\n'.join(items)))
        return items

    def list_files_in_directory(self, path, pattern=None, absolute=False):
        """A wrapper for `List Directory` that returns only files."""
        files = self._list_files_in_dir(path, pattern, absolute)
        self._info('%d file%s:\n%s' % (len(files), plural_or_not(files), '\n'.join(files)))
        return files

    def list_directories_in_directory(self, path, pattern=None, absolute=False):
        """A wrapper for `List Directory` that returns only directories."""
        dirs = self._list_dirs_in_dir(path, pattern, absolute)
        self._info('%d director%s:\n%s' % (len(dirs), 'y' if len(dirs) == 1 else 'ies', '\n'.join(dirs)))
        return dirs

    def count_items_in_directory(self, path, pattern=None):
        """Returns and logs the number of all items in the given directory.

        The argument `pattern` has the same semantics as in the `List Directory`
        keyword. The count is returned as an integer, so it must be checked e.g.
        with the built-in keyword `Should Be Equal As Integers`.
        """
        count = len(self._list_dir(path, pattern))
        self._info("%s item%s." % (count, plural_or_not(count)))
        return count

    def count_files_in_directory(self, path, pattern=None):
        """A wrapper for `Count Items In Directory` returning only file count."""
        count = len(self._list_files_in_dir(path, pattern))
        self._info("%s file%s." % (count, plural_or_not(count)))
        return count

    def count_directories_in_directory(self, path, pattern=None):
        """A wrapper for `Count Items In Directory` returning only directory count."""
        count = len(self._list_dirs_in_dir(path, pattern))
        self._info("%s director%s." % (count, 'y' if count == 1 else 'ies'))
        return count

    def _list_dir(self, path, pattern=None, absolute=False):
        path = self._absnorm(path)
        self._link("Listing contents of directory '%s'.", path)
        if not os.path.isdir(path):
            raise RuntimeError("Directory '%s' does not exist" % path)
        # result is already unicode but unic also handles NFC normalization
        items = sorted(unic(item) for item in os.listdir(path))
        if pattern:
            items = [i for i in items if fnmatch.fnmatchcase(i, pattern)]
        if absolute:
            path = os.path.normpath(path)
            items = [os.path.join(path,item) for item in items]
        return items

    def _list_files_in_dir(self, path, pattern=None, absolute=False):
        return [item for item in self._list_dir(path, pattern, absolute)
                if os.path.isfile(os.path.join(path, item))]

    def _list_dirs_in_dir(self, path, pattern=None, absolute=False):
        return [item for item in self._list_dir(path, pattern, absolute)
                if os.path.isdir(os.path.join(path, item))]

    def touch(self, path):
        """Emulates the UNIX touch command.

        Creates a file, if it does not exist. Otherwise changes its access and
        modification times to the current time.

        Fails if used with the directories or the parent directory of the given
        file does not exist.
        """
        path = self._absnorm(path)
        if os.path.isdir(path):
            raise RuntimeError("Cannot touch '%s' because it is a directory" % path)
        if not os.path.exists(os.path.dirname(path)):
            raise RuntimeError("Cannot touch '%s' because its parent directory "
                            "does not exist" % path)
        if os.path.exists(path):
            mtime = round(time.time())
            os.utime(path, (mtime, mtime))
            self._link("Touched existing file '%s'", path)
        else:
            open(path, 'w').close()
            self._link("Touched new file '%s'", path)

    def _absnorm(self, path):
        try:
            return abspath(path.replace('/', os.sep))
        except ValueError:  # http://ironpython.codeplex.com/workitem/29489
            return os.path.normpath(path.replace('/', os.sep))

    def _fail(self, error, default):
        raise AssertionError(error or default)

    def _info(self, msg):
        self._log(msg, 'INFO')

    def _link(self, msg, *paths):
        paths = tuple('<a href="file://%s">%s</a>' % (p, p) for p in paths)
        self._log(msg % paths, 'HTML')

    def _warn(self, msg):
        self._log(msg, 'WARN')

    def _log(self, msg, level):
        if logger:
            logger.write(msg, level)
        else:
            print '*%s* %s' % (level, msg)


class _Process:

    def __init__(self, command):
        self._command = self._process_command(command)
        self._process = os.popen(self._command)

    def __str__(self):
        return self._command

    def read(self):
        return self._process_output(self._process.read())

    def close(self):
        try:
            rc = self._process.close()
        except IOError:  # Has occurred sometimes in Windows
            return 255
        if rc is None:
            return 0
        # In Windows (Python and Jython) return code is value returned by
        # command (can be almost anything)
        # In other OS:
        #   In Jython return code can be between '-255' - '255'
        #   In Python return code must be converted with 'rc >> 8' and it is
        #   between 0-255 after conversion
        if os.sep == '\\' or sys.platform.startswith('java'):
            return rc % 256
        return rc >> 8

    def _process_command(self, command):
        if '>' not in command:
            if command.endswith('&'):
                command = command[:-1] + ' 2>&1 &'
            else:
                command += ' 2>&1'
        return self._encode_to_file_system(command)

    def _encode_to_file_system(self, string):
        enc = sys.getfilesystemencoding()
        return string.encode(enc) if enc else string

    def _process_output(self, stdout):
        stdout = stdout.replace('\r\n', '\n') # http://bugs.jython.org/issue1566
        if stdout.endswith('\n'):
            stdout = stdout[:-1]
        return decode_output(stdout)


class _Process2(_Process):

    def __init__(self, command, input_):
        self._command = self._process_command(command)
        p = subprocess.Popen(self._command, shell=True, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                             close_fds=os.sep=='/')
        stdin, self.stdout = p.stdin, p.stdout
        if input_:
            stdin.write(input_)
        stdin.close()
        self.closed = False

    def read(self):
        if self.closed:
            raise RuntimeError('Cannot read from a closed process')
        return self._process_output(self.stdout.read())

    def close(self):
        if not self.closed:
            self.stdout.close()
            self.closed = True

########NEW FILE########
__FILENAME__ = Process
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

import os
import subprocess

from robot.utils import (ConnectionCache, abspath, encode_to_system,
                         decode_from_system, get_env_vars)
from robot.version import get_version
from robot.api import logger


class Process(object):
    """Robot Framework test library for running processes.

    This library utilizes Python's
    [http://docs.python.org/2.7/library/subprocess.html|subprocess]
    module and its
    [http://docs.python.org/2.7/library/subprocess.html#subprocess.Popen|Popen]
    class.

    The library has following main usages:

    - Running processes in system and waiting for their completion using
      `Run Process` keyword.
    - Starting processes on background using `Start Process`.
    - Waiting started process to complete using `Wait For Process` or
      stopping them with `Terminate Process` or `Terminate All Processes`.

    This library is new in Robot Framework 2.8.

    == Table of contents ==

    - `Specifying command and arguments`
    - `Process configuration`
    - `Active process`
    - `Stopping processes`
    - `Result object`
    - `Using with OperatingSystem library`
    - `Example`

    = Specifying command and arguments =

    Both `Run Process` and `Start Process` accept the command to execute
    and all arguments passed to it as separate arguments. This is convenient
    to use and also allows these keywords to automatically escape possible
    spaces and other special characters in the command or arguments.

    When `running processes in shell`, it is also possible to give the
    whole command to execute as a single string. The command can then
    contain multiple commands, for example, connected with pipes. When
    using this approach the caller is responsible on escaping.

    Examples:
    | `Run Process` | ${progdir}${/}prog.py        | first arg | second         |
    | `Run Process` | script1.sh arg && script2.sh | shell=yes | cwd=${progdir} |

    = Process configuration =

    `Run Process` and `Start Process` keywords can be configured using
    optional `**configuration` keyword arguments. Available configuration
    arguments are listed below and discussed further in sections afterwards.

    | *Name*     | *Explanation*                                         |
    | shell      | Specifies whether to run the command in shell or not  |
    | cwd        | Specifies the working directory.                      |
    | env        | Specifies environment variables given to the process. |
    | env:<name> | Overrides the named environment variable(s) only.     |
    | stdout     | Path of a file where to write standard output.        |
    | stderr     | Path of a file where to write standard error.         |
    | alias      | Alias given to the process.                           |

    Configuration must be given after other arguments passed to these keywords
    and must use syntax `name=value`.

    == Running processes in shell ==

    The `shell` argument specifies whether to run the process in a shell or
    not. By default shell is not used, which means that shell specific
    commands, like `copy` and `dir` on Windows, are not available.

    Giving the `shell` argument any non-false value, such as `shell=True`,
    changes the program to be executed in a shell. It allows using the shell
    capabilities, but can also make the process invocation operating system
    dependent.

    When using a shell it is possible to give the whole command to execute
    as a single string. See `Specifying command and arguments` section for
    more details.

    == Current working directory ==

    By default the child process will be executed in the same directory
    as the parent process, the process running tests, is executed. This
    can be changed by giving an alternative location using the `cwd` argument.
    Forward slashes in the given path are automatically converted to
    backslashes on Windows.

    `Standard output and error streams`, when redirected to files,
    are also relative to the current working directory possibly set using
    the `cwd` argument.

    Example:
    | `Run Process` | prog.exe | cwd=${ROOT}/directory | stdout=stdout.txt |

    == Environment variables ==

    By default the child process will get a copy of the parent process's
    environment variables. The `env` argument can be used to give the
    child a custom environment as a Python dictionary. If there is a need
    to specify only certain environment variable, it is possible to use the
    `env:<name>` format to set or override only that named variables. It is
    also possible to use these two approaches together.

    Examples:
    | `Run Process` | program | env=${environ} |
    | `Run Process` | program | env:PATH=%{PATH}${:}${PROGRAM DIR} |
    | `Run Process` | program | env=${environ} | env:EXTRA=value   |

    == Standard output and error streams ==

    By default processes are run so that their standard output and standard
    error streams are kept in the memory. This works fine normally,
    but if there is a lot of output, the output buffers may get full and
    the program could hang.

    To avoid output buffers getting full, it is possible to use `stdout`
    and `stderr` arguments to specify files on the file system where to
    redirect the outputs. This can also be useful if other processes or
    other keywords need to read or manipulate the outputs somehow.

    Given `stdout` and `stderr` paths are relative to the `current working
    directory`. Forward slashes in the given paths are automatically converted
    to backslashes on Windows.

    As a special feature, it is possible to redirect the standard error to
    the standard output by using `stderr=STDOUT`.

    Regardless are outputs redirected to files or not, they are accessible
    through the `result object` returned when the process ends.

    Examples:
    | ${result} = | `Run Process` | program | stdout=${TEMPDIR}/stdout.txt | stderr=${TEMPDIR}/stderr.txt |
    | `Log Many`  | stdout: ${result.stdout} | stderr: ${result.stderr} |
    | ${result} = | `Run Process` | program | stderr=STDOUT |
    | `Log`       | all output: ${result.stdout} |

    *Note:* The created output files are not automatically removed after
    the test run. The user is responsible to remove them if needed.

    == Alias ==

    A custom name given to the process that can be used when selecting the
    `active process`.

    Example:
    | `Start Process` | program | alias=example |

    = Active process =

    The test library keeps record which of the started processes is currently
    active. By default it is latest process started with `Start Process`,
    but `Switch Process` can be used to select a different one.

    The keywords that operate on started processes will use the active process
    by default, but it is possible to explicitly select a different process
    using the `handle` argument. The handle can be the identifier returned by
    `Start Process` or an explicitly given `alias`.

    = Stopping processes =

    Started processed can be stopped using `Terminate Process` and
    `Terminate All Processes`. The former is used for stopping a selected
    process, and the latter to make sure all processes are stopped, for
    example, in a suite teardown.

    Both keywords use `subprocess`
    [http://docs.python.org/2.7/library/subprocess.html#subprocess.Popen.terminate|terminate()]
    method by default, but can be configured to use
    [http://docs.python.org/2.7/library/subprocess.html#subprocess.Popen.kill|kill()]
    instead.

    Because both `terminate()` and `kill()` methods were added to `subprocess`
    in Python 2.6, stopping processes does not work with Python or Jython 2.5.
    Unfortunately at least beta releases of Jython 2.7
    [http://bugs.jython.org/issue1898|do not seem to support it either].

    Examples:
    | `Terminate Process` | kill=True |
    | `Terminate All Processes` |

    = Result object =

    `Run Process` and `Wait For Process` keywords return a result object
    that contains information about the process execution as its attibutes.
    What is available is documented in the table below.

    | *Attribute* | *Explanation*                             |
    | rc          | Return code of the process as an integer. |
    | stdout      | Contents of the standard output stream.   |
    | stderr      | Contents of the standard error stream.    |
    | stdout_path | Path where stdout was redirected or `None` if not redirected. |
    | stderr_path | Path where stderr was redirected or `None` if not redirected. |

    Example:
    | ${result} =            | `Run Process`         | program               |
    | `Should Be Equal As Integers` | ${result.rc}   |                       |
    | `Should Match`         | ${result.stdout}      | Some t?xt*            |
    | `Should Be Empty`      | ${result.stderr}      |                       |
    | ${stdout} =            | `Get File`            | ${result.stdout_path} |
    | `File Should Be Empty` | ${result.stderr_path} |                       |
    | `Should Be Equal`      | ${result.stdout}      | ${stdout}             |

    = Using with OperatingSystem library =

    The OperatingSystem library also contains keywords for running processes.
    They are not as flexible as the keywords provided by this library, and
    thus not recommended to be used anymore. They may eventually even be
    deprecated.

    There is a name collision because both of these libraries have
    `Start Process` and `Switch Process` keywords. This is handled so that
    if both libraries are imported, the keywords in the Process library are
    used by default. If there is a need to use the OperatingSystem variants,
    it is possible to use `OperatingSystem.Start Process` syntax or use
    the `BuiltIn` keyword `Set Library Search Order` to change the priority.

    Other keywords in the OperatingSystem library can be used freely with
    keywords in the Process library.

    = Example =

    | ***** Settings *****
    | Library    Process
    | Suite Teardown    `Terminate All Processes`    kill=True
    |
    | ***** Test Cases *****
    | Example
    |     `Start Process`    program    arg1   arg2    alias=First
    |     ${handle} =    `Start Process`    command.sh arg | command2.sh   shell=True    cwd=/path
    |     ${result} =    `Run Process`    ${CURDIR}/script.py
    |     `Should Not Contain`    ${result.stdout}    FAIL
    |     `Terminate Process`    ${handle}
    |     ${result} =    `Wait For Process`    First
    |     `Should Be Equal As Integers`   ${result.rc}    0
    """
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'
    ROBOT_LIBRARY_VERSION = get_version()

    def __init__(self):
        self._processes = ConnectionCache('No active process.')
        self._results = {}

    def run_process(self, command, *arguments, **configuration):
        """Runs a process and waits for it to complete.

        See `Specifying command and arguments` and `Process configuration`
        for more information about the arguments.

        Returns a `result object` containing information about the execution.

        This command does not change the `active process`.
        """
        current = self._processes.current
        try:
            handle = self.start_process(command, *arguments, **configuration)
            return self.wait_for_process(handle)
        finally:
            self._processes.current = current

    def start_process(self, command, *arguments, **configuration):
        """Starts a new process on background.

        See `Specifying command and arguments` and `Process configuration`
        for more information about the arguments.

        Makes the started process new `active process`. Returns an identifier
        that can be used as a handle to active the started process if needed.
        """
        config = ProcessConfig(**configuration)
        executable_command = self._cmd(arguments, command, config.shell)
        logger.info('Starting process:\n%s' % executable_command)
        logger.debug('Process configuration:\n%s' % config)
        process = subprocess.Popen(executable_command,
                                   stdout=config.stdout_stream,
                                   stderr=config.stderr_stream,
                                   stdin=subprocess.PIPE,
                                   shell=config.shell,
                                   cwd=config.cwd,
                                   env=config.env,
                                   universal_newlines=True)
        self._results[process] = ExecutionResult(process,
                                                 config.stdout_stream,
                                                 config.stderr_stream)
        return self._processes.register(process, alias=config.alias)

    def _cmd(self, args, command, use_shell):
        command = [encode_to_system(item) for item in [command] + list(args)]
        if not use_shell:
            return command
        if args:
            return subprocess.list2cmdline(command)
        return command[0]

    def is_process_running(self, handle=None):
        """Checks is the process running or not.

        If `handle`is not given, uses the current `active process`.

        Returns `True` if the process is still running and `False` otherwise.
        """
        return self._processes[handle].poll() is None

    def process_should_be_running(self, handle=None,
                                  error_message='Process is not running.'):
        """Verifies that the process is running.

        If `handle`is not given, uses the current `active process`.

        Fails if the process has stopped.
        """
        if not self.is_process_running(handle):
            raise AssertionError(error_message)

    def process_should_be_stopped(self, handle=None,
                                  error_message='Process is running.'):
        """Verifies that the process is not running.

        If `handle`is not given, uses the current `active process`.

        Fails if the process is still running.
        """
        if self.is_process_running(handle):
            raise AssertionError(error_message)

    def wait_for_process(self, handle=None):
        """Waits for the process to complete.

        If `handle`is not given, uses the current `active process`.

        Returns a `result object` containing information about the execution.
        """
        process = self._processes[handle]
        result = self._results[process]
        logger.info('Waiting for process to complete.')
        result.rc = process.wait() or 0
        logger.info('Process completed.')
        return result

    def terminate_process(self, handle=None, kill=False):
        """Terminates the process.

        If `handle`is not given, uses the current `active process`.

        See `Stopping process` for more details.
        """
        process = self._processes[handle]
        try:
            terminator = process.kill if kill else process.terminate
        except AttributeError:
            raise RuntimeError('Terminating processes is not supported '
                               'by this interpreter version.')
        logger.info('Killing process.' if kill else 'Terminating process.')
        try:
            terminator()
        except OSError:
            if process.poll() is None:
                raise
            logger.debug('Ignored OSError because process was stopped.')

    def terminate_all_processes(self, kill=True):
        """Terminates all still running processes started by this library.

        See `Stopping processes` for more details.
        """
        for handle in range(1, len(self._processes) + 1):
            if self.is_process_running(handle):
                self.terminate_process(handle, kill=kill)
        self.__init__()

    def get_process_id(self, handle=None):
        """Returns the process ID (pid) of the process.

        If `handle`is not given, uses the current `active process`.

        Returns the pid assigned by the operating system as an integer.
        Note that with Jython, at least with the 2.5 version, the returned
        pid seems to always be `None`.

        The pid is not the same as the identifier returned by
        `Start Process` that is used internally by this library.
        """
        return self._processes[handle].pid

    def get_process_object(self, handle=None):
        """Return the underlying `subprocess.Popen`  object.

        If `handle`is not given, uses the current `active process`.
        """
        return self._processes[handle]

    def switch_process(self, handle):
        """Makes the specified process the current `active process`.

        The handle can be an identifier returned by `Start Process` or
        the `alias` given to it explicitly.

        Example:
        | `Start Process` | prog1 | alias=process1 |
        | `Start Process` | prog2 | alias=process2 |
        | # currently active process is process2 |
        | `Switch Process` | process1 |
        | # now active process is process 1 |
        """
        self._processes.switch(handle)


class ExecutionResult(object):

    def __init__(self, process, stdout, stderr, rc=None):
        self._process = process
        self.stdout_path = self._get_path(stdout)
        self.stderr_path = self._get_path(stderr)
        self.rc = rc
        self._stdout = None
        self._stderr = None

    def _get_path(self, stream):
        if stream in (subprocess.PIPE, subprocess.STDOUT):
            return None
        return stream.name

    @property
    def stdout(self):
        if self._stdout is None:
            self._stdout = self._read_stream(self.stdout_path,
                                             self._process.stdout)
        return self._stdout

    @property
    def stderr(self):
        if self._stderr is None:
            self._stderr = self._read_stream(self.stderr_path,
                                             self._process.stderr)
        return self._stderr

    def _read_stream(self, stream_path, stream):
        if stream_path:
            stream = open(stream_path, 'r')
        try:
            return self._format_output(stream.read() if stream else '')
        finally:
            if stream_path:
                stream.close()

    def _format_output(self, output):
        if output.endswith('\n'):
            output = output[:-1]
        return decode_from_system(output)

    def __str__(self):
        return '<result object with rc %d>' % self.rc


class ProcessConfig(object):

    def __init__(self, cwd=None, shell=False, stdout=None, stderr=None,
                 alias=None, env=None, **rest):
        self.cwd = self._get_cwd(cwd)
        self.stdout_stream = self._new_stream(stdout)
        self.stderr_stream = self._get_stderr(stderr, stdout)
        self.shell = bool(shell)
        self.alias = alias
        self.env = self._construct_env(env, rest)

    def _get_cwd(self, cwd):
        if cwd:
            return cwd.replace('/', os.sep)
        return abspath('.')

    def _new_stream(self, name):
        if name:
            name = name.replace('/', os.sep)
            return open(os.path.join(self.cwd, name), 'w')
        return subprocess.PIPE

    def _get_stderr(self, stderr, stdout):
        if stderr:
            if stderr == 'STDOUT' or stderr == stdout:
                if self.stdout_stream == subprocess.PIPE:
                    return subprocess.STDOUT
                return self.stdout_stream
        return self._new_stream(stderr)

    def _construct_env(self, env, rest):
        for key in rest:
            if not key.startswith('env:'):
                raise RuntimeError("'%s' is not supported by this keyword." % key)
            if env is None:
                env = get_env_vars(upper=False)
            env[key[4:]] = rest[key]
        if env:
            env = dict((encode_to_system(key), encode_to_system(env[key]))
                       for key in env)
        return env

    def __str__(self):
        return encode_to_system("""\
cwd = %s
stdout_stream = %s
stderr_stream = %s
shell = %r
alias = %s
env = %r""" % (self.cwd, self.stdout_stream, self.stderr_stream,
               self.shell, self.alias, self.env))

########NEW FILE########
__FILENAME__ = Remote
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import xmlrpclib
import socket
import time
import sys
try:
    from xml.parsers.expat import ExpatError
except ImportError:   # No expat in IronPython 2.7
    class ExpatError(Exception): pass

from robot import utils
from robot.errors import RemoteError


class Remote:
    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'

    def __init__(self, uri='http://localhost:8270'):
        if '://' not in uri:
            uri = 'http://' + uri
        self._client = XmlRpcRemoteClient(uri)

    def get_keyword_names(self, attempts=5):
        for i in range(attempts):
            try:
                return self._client.get_keyword_names()
            except TypeError, err:
                time.sleep(1)
        raise RuntimeError('Connecting remote server failed: %s' % err)

    def get_keyword_arguments(self, name):
        try:
            return self._client.get_keyword_arguments(name)
        except TypeError:
            return ['*args']

    def get_keyword_documentation(self, name):
        try:
            return self._client.get_keyword_documentation(name)
        except TypeError:
            return ''

    def run_keyword(self, name, args):
        args = [self._handle_argument(arg) for arg in args]
        result = RemoteResult(self._client.run_keyword(name, args))
        sys.stdout.write(result.output)
        if result.status != 'PASS':
            raise RemoteError(result.error, result.traceback)
        return result.return_

    def _handle_argument(self, arg):
        if isinstance(arg, (basestring, int, long, float)):
            return arg
        if isinstance(arg, (tuple, list)):
            return [self._handle_argument(item) for item in arg]
        if isinstance(arg, dict):
            return dict((self._str(key), self._handle_argument(value))
                        for key, value in arg.items())
        return self._str(arg)

    def _str(self, item):
        if item is None:
            return ''
        return utils.unic(item)


class RemoteResult:

    def __init__(self, result):
        try:
            self.status = result['status']
            self.output = result.get('output', '')
            self.return_ = result.get('return', '')
            self.error = result.get('error', '')
            self.traceback = result.get('traceback', '')
        except (KeyError, AttributeError):
            raise RuntimeError('Invalid remote result dictionary: %s' % result)


class XmlRpcRemoteClient:

    def __init__(self, uri):
        self._server = xmlrpclib.ServerProxy(uri, encoding='UTF-8')

    def get_keyword_names(self):
        try:
            return self._server.get_keyword_names()
        except socket.error, (errno, err):
            raise TypeError(err)
        except xmlrpclib.Error, err:
            raise TypeError(err)

    def get_keyword_arguments(self, name):
        try:
            return self._server.get_keyword_arguments(name)
        except xmlrpclib.Error:
            raise TypeError

    def get_keyword_documentation(self, name):
        try:
            return self._server.get_keyword_documentation(name)
        except xmlrpclib.Error:
            raise TypeError

    def run_keyword(self, name, args):
        try:
            return self._server.run_keyword(name, args)
        except xmlrpclib.Error, err:
            raise RuntimeError(err.faultString)
        except socket.error, (errno, err):
            raise RuntimeError('Connection to remote server broken: %s' % err)
        except ExpatError, err:
            raise RuntimeError('Processing XML-RPC return value failed. '
                               'Most often this happens when the return value '
                               'contains characters that are not valid in XML. '
                               'Original error was: ExpatError: %s' % err)

########NEW FILE########
__FILENAME__ = Reserved
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


RESERVED_KEYWORDS = [ 'for', 'while', 'break', 'continue', 'end',
                      'if', 'else', 'elif', 'else if', 'return' ]


class Reserved:

    ROBOT_LIBRARY_SCOPE = 'GLOBAL'

    def get_keyword_names(self):
        return RESERVED_KEYWORDS

    def run_keyword(self, name, args):
        raise Exception("'%s' is a reserved keyword" % name.title())


########NEW FILE########
__FILENAME__ = Screenshot
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import os
if sys.platform.startswith('java'):
    from java.awt import Toolkit, Robot, Rectangle
    from javax.imageio import ImageIO
    from java.io import File
elif sys.platform == 'cli':
    import clr
    clr.AddReference('System.Windows.Forms')
    clr.AddReference('System.Drawing')
    from System.Drawing import Bitmap, Graphics, Imaging
    from System.Windows.Forms import Screen
else:
    try:
        import wx
    except ImportError:
        wx = None
    try:
        from gtk import gdk
    except ImportError:
        gdk = None
    try:
        from PIL import ImageGrab  # apparently available only on Windows
    except ImportError:
        ImageGrab = None

from robot import utils
from robot.api import logger
from robot.libraries.BuiltIn import BuiltIn
from robot.version import get_version


class Screenshot(object):
    """Test library for taking screenshots on the machine where tests are run.

    Notice that successfully taking screenshots requires tests to be run with
    a physical or virtual display.

    *Using with Python*

    With Python you need to have one of the following modules installed to be
    able to use this library. The first module that is found will be used.

    - wxPython :: http://wxpython.org :: Required also by RIDE so many Robot
      Framework users already have this module installed.
    - PyGTK :: http://pygtk.org :: This module is available by default on most
      Linux distributions.
    - Python Imaging Library (PIL) :: http://www.pythonware.com/products/pil ::
      This module can take screenshots only on Windows.

    Python support was added in Robot Framework 2.5.5.

    *Using with Jython and IronPython*

    With Jython and IronPython this library uses APIs provided by JVM and .NET
    platforms, respectively. These APIs are always available and thus no
    external modules are needed.

    IronPython support was added in Robot Framework 2.7.5.

    *Where screenshots are saved*

    By default screenshots are saved into the same directory where the Robot
    Framework log file is written. If no log is created, screenshots are saved
    into the directory where the XML output file is written.

    It is possible to specify a custom location for screenshots using
   `screenshot_directory` argument in `importing` and `Set Screenshot Directory`
    keyword during execution. It is also possible to save screenshots using
    an absolute path.

    Note that prior to Robot Framework 2.5.5 the default screenshot location
    was system's temporary directory.

    *Changes in Robot Framework 2.5.5 and Robot Framework 2.6*

    This library was heavily enhanced in Robot Framework 2.5.5 release. The
    changes are listed below and explained more thoroughly in affected places.

    - The support for using this library on Python (see above) was added.
    - The default location where screenshots are saved was changed (see above).
    - New `Take Screenshot` and `Take Screenshot Without Embedding` keywords
      were added. These keywords should be used for taking screenshots in
      the future. Other screenshot taking keywords will be deprecated and
      removed later.
    - `log_file_directory` argument was deprecated everywhere it was used.

    In Robot Framework 2.6, following additional changes were made:

    - `log_file_directory` argument was removed altogether.
    - `Set Screenshot Directories` keyword was removed.
    - `Save Screenshot`, `Save Screenshot To` and `Log Screenshot`
      keywords were deprecated. They will be removed in Robot Framework 2.8.
    """

    ROBOT_LIBRARY_SCOPE = 'TEST SUITE'
    ROBOT_LIBRARY_VERSION = get_version()

    def __init__(self, screenshot_directory=None):
        """Configure where screenshots are saved.

        If `screenshot_directory` is not given, screenshots are saved into
        same directory as the log file. The directory can also be set using
        `Set Screenshot Directory` keyword.

        Examples (use only one of these):

        | *Setting* | *Value*  | *Value*    | *Value* |
        | Library | Screenshot |            | # Default location |
        | Library | Screenshot | ${TEMPDIR} | # System temp (this was default prior to 2.5.5) |
        """
        self._given_screenshot_dir = self._norm_path(screenshot_directory)
        self._screenshot_taker = ScreenshotTaker()

    def _norm_path(self, path):
        if not path:
            return path
        return os.path.normpath(path.replace('/', os.sep))

    @property
    def _screenshot_dir(self):
        return self._given_screenshot_dir or self._log_dir

    @property
    def _log_dir(self):
        variables = BuiltIn().get_variables()
        outdir = variables['${OUTPUTDIR}']
        log = variables['${LOGFILE}']
        log = os.path.dirname(log) if log != 'NONE' else '.'
        return self._norm_path(os.path.join(outdir, log))

    def set_screenshot_directory(self, path):
        """Sets the directory where screenshots are saved.

        It is possible to use `/` as a path separator in all operating systems.
        Path to the old directory is returned.

        The directory can also be set in `importing`.
        """
        path = self._norm_path(path)
        if not os.path.isdir(path):
            raise RuntimeError("Directory '%s' does not exist." % path)
        old = self._screenshot_dir
        self._given_screenshot_dir = path
        return old

    def save_screenshot_to(self, path):
        """*DEPRECATED* Use `Take Screenshot` or `Take Screenshot Without Embedding` instead."""
        path = self._screenshot_to_file(path)
        self._link_screenshot(path)
        return path

    def save_screenshot(self, basename="screenshot", directory=None):
        """*DEPRECATED* Use `Take Screenshot` or `Take Screenshot Without Embedding` instead."""
        path = self._save_screenshot(basename, directory)
        self._link_screenshot(path)
        return path

    def log_screenshot(self, basename='screenshot', directory=None,
                       width='100%'):
        """*DEPRECATED* Use `Take Screenshot` or `Take Screenshot Without Embedding` instead."""
        path = self._save_screenshot(basename, directory)
        self._embed_screenshot(path, width)
        return path

    def take_screenshot(self, name="screenshot", width="800px"):
        """Takes a screenshot in JPEG format and embeds it into the log file.

        Name of the file where the screenshot is stored is derived from the
        given `name`. If the `name` ends with extension `.jpg` or `.jpeg`,
        the screenshot will be stored with that exact name. Otherwise a unique
        name is created by adding an underscore, a running index and
        an extension to the `name`.

        The name will be interpreted to be relative to the directory where
        the log file is written. It is also possible to use absolute paths.
        Using `/` as a path separator works in all operating systems.

        `width` specifies the size of the screenshot in the log file.

        Examples: (LOGDIR is determined automatically by the library)
        | Take Screenshot |                  |     | # LOGDIR/screenshot_1.jpg (index automatically incremented) |
        | Take Screenshot | mypic            |     | # LOGDIR/mypic_1.jpg (index automatically incremented) |
        | Take Screenshot | ${TEMPDIR}/mypic |     | # /tmp/mypic_1.jpg (index automatically incremented) |
        | Take Screenshot | pic.jpg          |     | # LOGDIR/pic.jpg (always uses this file) |
        | Take Screenshot | images/login.jpg | 80% | # Specify both name and width. |
        | Take Screenshot | width=550px      |     | # Specify only width. |

        The path where the screenshot is saved is returned.
        """
        path = self._save_screenshot(name)
        self._embed_screenshot(path, width)
        return path

    def take_screenshot_without_embedding(self, name="screenshot"):
        """Takes a screenshot and links it from the log file.

        This keyword is otherwise identical to `Take Screenshot` but the saved
        screenshot is not embedded into the log file. The screenshot is linked
        so it is nevertheless easily available.
        """
        path = self._save_screenshot(name)
        self._link_screenshot(path)
        return path

    def _save_screenshot(self, basename, directory=None):
        path = self._get_screenshot_path(basename, directory)
        return self._screenshot_to_file(path)

    def _screenshot_to_file(self, path):
        path = self._validate_screenshot_path(path)
        logger.debug('Using %s modules for taking screenshot.'
                     % self._screenshot_taker.module)
        try:
            self._screenshot_taker(path)
        except:
            logger.warn('Taking screenshot failed: %s\n'
                        'Make sure tests are run with a physical or virtual display.'
                        % utils.get_error_message())
        return path

    def _validate_screenshot_path(self, path):
        path = utils.abspath(self._norm_path(path))
        if not os.path.exists(os.path.dirname(path)):
            raise RuntimeError("Directory '%s' where to save the screenshot "
                               "does not exist" % os.path.dirname(path))
        return path

    def _get_screenshot_path(self, basename, directory):
        directory = self._norm_path(directory) if directory else self._screenshot_dir
        if basename.lower().endswith(('.jpg', '.jpeg')):
            return os.path.join(directory, basename)
        index = 0
        while True:
            index += 1
            path = os.path.join(directory, "%s_%d.jpg" % (basename, index))
            if not os.path.exists(path):
                return path

    def _embed_screenshot(self, path, width):
        link = utils.get_link_path(path, self._log_dir)
        logger.info('<a href="%s"><img src="%s" width="%s"></a>'
                    % (link, link, width), html=True)

    def _link_screenshot(self, path):
        link = utils.get_link_path(path, self._log_dir)
        logger.info("Screenshot saved to '<a href=\"%s\">%s</a>'."
                    % (link, path), html=True)


class ScreenshotTaker(object):

    def __init__(self, module_name=None):
        self._screenshot = self._get_screenshot_taker(module_name)
        self.module = self._screenshot.__name__.split('_')[1]
        self._wx_app_reference = None

    def __call__(self, path):
        self._screenshot(path)

    def _get_screenshot_taker(self, module_name):
        if sys.platform.startswith('java'):
            return self._java_screenshot
        if sys.platform == 'cli':
            return self._cli_screenshot
        if module_name:
            method_name = '_%s_screenshot' % module_name.lower()
            if hasattr(self, method_name):
                return getattr(self, method_name)
        return self._get_default_screenshot_taker()

    def _get_default_screenshot_taker(self):
        for module, screenshot_taker in [(wx, self._wx_screenshot),
                                         (gdk, self._gtk_screenshot),
                                         (ImageGrab, self._pil_screenshot),
                                         (True, self._no_screenshot)]:
            if module:
                return screenshot_taker

    def _java_screenshot(self, path):
        size = Toolkit.getDefaultToolkit().getScreenSize()
        rectangle = Rectangle(0, 0, size.width, size.height)
        image = Robot().createScreenCapture(rectangle)
        ImageIO.write(image, 'jpg', File(path))

    def _cli_screenshot(self, path):
        bmp = Bitmap(Screen.PrimaryScreen.Bounds.Width,
                     Screen.PrimaryScreen.Bounds.Height)
        graphics = Graphics.FromImage(bmp)
        try:
            graphics.CopyFromScreen(0, 0, 0, 0, bmp.Size)
        finally:
            graphics.Dispose()
            bmp.Save(path, Imaging.ImageFormat.Jpeg)

    def _wx_screenshot(self, path):
        if not self._wx_app_reference:
            self._wx_app_reference = wx.PySimpleApp()
        context = wx.ScreenDC()
        width, height = context.GetSize()
        bitmap = wx.EmptyBitmap(width, height, -1)
        memory = wx.MemoryDC()
        memory.SelectObject(bitmap)
        memory.Blit(0, 0, width, height, context, -1, -1)
        memory.SelectObject(wx.NullBitmap)
        bitmap.SaveFile(path, wx.BITMAP_TYPE_JPEG)

    def _gtk_screenshot(self, path):
        window = gdk.get_default_root_window()
        if not window:
            raise RuntimeError('Taking screenshot failed')
        width, height = window.get_size()
        pb = gdk.Pixbuf(gdk.COLORSPACE_RGB, False, 8, width, height)
        pb = pb.get_from_drawable(window, window.get_colormap(),
                                  0, 0, 0, 0, width, height)
        if not pb:
            raise RuntimeError('Taking screenshot failed')
        pb.save(path, 'jpeg')

    def _pil_screenshot(self, path):
        ImageGrab.grab().save(path, 'JPEG')

    def _no_screenshot(self, path):
        raise RuntimeError('Taking screenshots is not supported on this platform '
                           'by default. See library documentation for details.')


if __name__ == "__main__":
    if len(sys.argv) not in [2, 3]:
        sys.exit("Usage: %s <path> [wx|gtk|pil] OR test" % os.path.basename(sys.argv[0]))
    if sys.argv[1] == 'test':
        sys.exit('OK' if ScreenshotTaker().module != 'no' else 'NOK')
    path = utils.abspath(sys.argv[1])
    module = sys.argv[2] if len(sys.argv) == 3 else None
    shooter = ScreenshotTaker(module)
    print 'Using %s modules' % shooter.module
    shooter(path)
    print path

########NEW FILE########
__FILENAME__ = String
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
from fnmatch import fnmatchcase
from random import randint
from string import ascii_lowercase, ascii_uppercase, digits

from robot.api import logger
from robot.utils import unic
from robot.version import get_version


class String:
    """A test library for string manipulation and verification.

    `String` is Robot Framework's standard library for manipulating
    strings (e.g. `Replace String Using Regexp`, `Split To Lines`) and
    verifying their contents (e.g. `Should Be String`).

    Following keywords from `BuiltIn` library can also be used with strings:

    - `Catenate`
    - `Get Length`
    - `Length Should Be`
    - `Should (Not) Be Empty`
    - `Should (Not) Be Equal (As Strings/Integers/Numbers)`
    - `Should (Not) Match (Regexp)`
    - `Should (Not) Contain`
    - `Should (Not) Start With`
    - `Should (Not) End With`
    - `Convert To String`
    """
    ROBOT_LIBRARY_SCOPE = 'GLOBAL'
    ROBOT_LIBRARY_VERSION = get_version()

    def encode_string_to_bytes(self, string, encoding, errors='strict'):
        """Encodes the given Unicode `string` to bytes using the given `encoding`.

        `errors` argument controls what to do if encoding some characters fails.
        All values accepted by `encode` method in Python are valid, but in
        practice the following values are most useful:

        - `strict`: fail if characters cannot be encoded (default)
        - `ignore`: ignore characters that cannot be encoded
        - `replace`: replace characters that cannot be encoded with
          a replacement character

        Examples:
        | ${bytes} = | Encode String To Bytes | ${string} | UTF-8 |
        | ${bytes} = | Encode String To Bytes | ${string} | ASCII | errors=ignore |

        Use `Decode Bytes To String` if you need to convert byte strings to
        Unicode strings, and `Convert To String` in `BuiltIn` if you need to
        convert arbitrary objects to Unicode strings.

        New in Robot Framework 2.7.7.
        """
        return string.encode(encoding, errors)

    def decode_bytes_to_string(self, bytes, encoding, errors='strict'):
        """Decodes the given `bytes` to a Unicode string using the given `encoding`.

        `errors` argument controls what to do if decoding some bytes fails.
        All values accepted by `decode` method in Python are valid, but in
        practice the following values are most useful:

        - `strict`: fail if characters cannot be decoded (default)
        - `ignore`: ignore characters that cannot be decoded
        - `replace`: replace characters that cannot be decoded with
          a replacement character

        Examples:
        | ${string} = | Decode Bytes To String | ${bytes} | UTF-8 |
        | ${string} = | Decode Bytes To String | ${bytes} | ASCII | errors=ignore |

        Use `Encode String To Bytes` if you need to convert Unicode strings to
        byte strings, and `Convert To String` in `BuiltIn` if you need to
        convert arbitrary objects to Unicode strings.

        New in Robot Framework 2.7.7.
        """
        return bytes.decode(encoding, errors)

    def get_line_count(self, string):
        """Returns and logs the number of lines in the given `string`."""
        count = len(string.splitlines())
        logger.info('%d lines' % count)
        return count

    def split_to_lines(self, string, start=0, end=None):
        """Converts the `string` into a list of lines.

        It is possible to get only a selection of lines from `start`
        to `end` so that `start` index is inclusive and `end` is
        exclusive. Line numbering starts from 0, and it is possible to
        use negative indices to refer to lines from the end.

        Lines are returned without the newlines. The number of
        returned lines is automatically logged.

        Examples:
        | @{lines} =        | Split To Lines | ${manylines} |    |    |
        | @{ignore first} = | Split To Lines | ${manylines} | 1  |    |
        | @{ignore last} =  | Split To Lines | ${manylines} |    | -1 |
        | @{5th to 10th} =  | Split To Lines | ${manylines} | 4  | 10 |
        | @{first two} =    | Split To Lines | ${manylines} |    | 1  |
        | @{last two} =     | Split To Lines | ${manylines} | -2 |    |

        Use `Get Line` if you only need to get a single line.
        """
        start = self._convert_to_index(start, 'start')
        end = self._convert_to_index(end, 'end')
        lines = string.splitlines()[start:end]
        logger.info('%d lines returned' % len(lines))
        return lines

    def get_line(self, string, line_number):
        """Returns the specified line from the given `string`.

        Line numbering starts from 0 and it is possible to use
        negative indices to refer to lines from the end. The line is
        returned without the newline character.

        Examples:
        | ${first} =    | Get Line | ${string} | 0  |
        | ${2nd last} = | Get Line | ${string} | -2 |
        """
        line_number = self._convert_to_integer(line_number, 'line_number')
        return string.splitlines()[line_number]

    def get_lines_containing_string(self, string, pattern, case_insensitive=False):
        """Returns lines of the given `string` that contain the `pattern`.

        The `pattern` is always considered to be a normal string and a
        line matches if the `pattern` is found anywhere in it. By
        default the match is case-sensitive, but setting
        `case_insensitive` to any value makes it case-insensitive.

        Lines are returned as one string catenated back together with
        newlines. Possible trailing newline is never returned. The
        number of matching lines is automatically logged.

        Examples:
        | ${lines} = | Get Lines Containing String | ${result} | An example |
        | ${ret} =   | Get Lines Containing String | ${ret} | FAIL | case-insensitive |

        See `Get Lines Matching Pattern` and `Get Lines Matching Regexp`
        if you need more complex pattern matching.
        """
        if case_insensitive:
            pattern = pattern.lower()
            contains = lambda line: pattern in line.lower()
        else:
            contains = lambda line: pattern in line
        return self._get_matching_lines(string, contains)

    def get_lines_matching_pattern(self, string, pattern, case_insensitive=False):
        """Returns lines of the given `string` that match the `pattern`.

        The `pattern` is a _glob pattern_ where:
        | *        | matches everything |
        | ?        | matches any single character |
        | [chars]  | matches any character inside square brackets (e.g. '[abc]' matches either 'a', 'b' or 'c') |
        | [!chars] | matches any character not inside square brackets |

        A line matches only if it matches the `pattern` fully.  By
        default the match is case-sensitive, but setting
        `case_insensitive` to any value makes it case-insensitive.

        Lines are returned as one string catenated back together with
        newlines. Possible trailing newline is never returned. The
        number of matching lines is automatically logged.

        Examples:
        | ${lines} = | Get Lines Matching Pattern | ${result} | Wild???? example |
        | ${ret} = | Get Lines Matching Pattern | ${ret} | FAIL: * | case-insensitive |

        See `Get Lines Matching Regexp` if you need more complex
        patterns and `Get Lines Containing String` if searching
        literal strings is enough.
        """
        if case_insensitive:
            pattern = pattern.lower()
            matches = lambda line: fnmatchcase(line.lower(), pattern)
        else:
            matches = lambda line: fnmatchcase(line, pattern)
        return self._get_matching_lines(string, matches)

    def get_lines_matching_regexp(self, string, pattern):
        """Returns lines of the given `string` that match the regexp `pattern`.

        See `BuiltIn.Should Match Regexp` for more information about
        Python regular expression syntax in general and how to use it
        in Robot Framework test data in particular. A line matches
        only if it matches the `pattern` fully. Notice that to make
        the match case-insensitive, you need to embed case-insensitive
        flag into the pattern.

        Lines are returned as one string catenated back together with
        newlines. Possible trailing newline is never returned. The
        number of matching lines is automatically logged.

        Examples:
        | ${lines} = | Get Lines Matching Regexp | ${result} | Reg\\\\w{3} example |
        | ${ret} = | Get Lines Matching Regexp | ${ret} | (?i)FAIL: .* |

        See `Get Lines Matching Pattern` and `Get Lines Containing
        String` if you do not need full regular expression powers (and
        complexity).
        """
        regexp = re.compile('^%s$' % pattern)
        return self._get_matching_lines(string, regexp.match)

    def _get_matching_lines(self, string, matches):
        lines = string.splitlines()
        matching = [ line for line in lines if matches(line) ]
        logger.info('%d out of %d lines matched' % (len(matching), len(lines)))
        return '\n'.join(matching)

    def replace_string(self, string, search_for, replace_with, count=-1):
        """Replaces `search_for` in the given `string` with `replace_with`.

        `search_for` is used as a literal string. See `Replace String
        Using Regexp` if more powerful pattern matching is needed.

        If the optional argument `count` is given, only that many
        occurrences from left are replaced. Negative `count` means
        that all occurrences are replaced (default behaviour) and zero
        means that nothing is done.

        A modified version of the string is returned and the original
        string is not altered.

        Examples:
        | ${str} = | Replace String | ${str} | Hello | Hi     |   |
        | ${str} = | Replace String | ${str} | world | tellus | 1 |
        """
        count = self._convert_to_integer(count, 'count')
        return string.replace(search_for, replace_with, count)

    def replace_string_using_regexp(self, string, pattern, replace_with, count=-1):
        """Replaces `pattern` in the given `string` with `replace_with`.

        This keyword is otherwise identical to `Replace String`, but
        the `pattern` to search for is considered to be a regular
        expression.  See `BuiltIn.Should Match Regexp` for more
        information about Python regular expression syntax in general
        and how to use it in Robot Framework test data in particular.

        Examples:
        | ${str} = | Replace String Using Regexp | ${str} | (Hello|Hi) | Hei  |   |
        | ${str} = | Replace String Using Regexp | ${str} | 20\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d | <DATE>  | 2  |
        """
        count = self._convert_to_integer(count, 'count')
        # re.sub handles 0 and negative counts differently than string.replace
        if count == 0:
            return string
        return re.sub(pattern, replace_with, string, max(count, 0))

    def split_string(self, string, separator=None, max_split=-1):
        """Splits the `string` using `separator` as a delimiter string.

        If a `separator` is not given, any whitespace string is a
        separator. In that case also possible consecutive whitespace
        as well as leading and trailing whitespace is ignored.

        Split words are returned as a list. If the optional
        `max_split` is given, at most `max_split` splits are done, and
        the returned list will have maximum `max_split + 1` elements.

        Examples:
        | @{words} =         | Split String | ${string} |
        | @{words} =         | Split String | ${string} | ,${SPACE} |
        | ${pre} | ${post} = | Split String | ${string} | ::    | 1 |

        See `Split String From Right` if you want to start splitting
        from right, and `Fetch From Left` and `Fetch From Right` if
        you only want to get first/last part of the string.
        """
        if separator == '':
            separator = None
        max_split = self._convert_to_integer(max_split, 'max_split')
        return string.split(separator, max_split)

    def split_string_from_right(self, string, separator=None, max_split=-1):
        """Splits the `string` using `separator` starting from right.

        Same as `Split String`, but splitting is started from right. This has
        an effect only when `max_split` is given.

        Examples:
        | ${first} | ${others} = | Split String | ${string} | - | 1 |
        | ${others} | ${last} = | Split String From Right | ${string} | - | 1 |
        """
        # Strings in Jython 2.2 don't have 'rsplit' methods
        reversed = self.split_string(string[::-1], separator, max_split)
        return [ r[::-1] for r in reversed ][::-1]

    def split_string_to_characters(self, string):
        """Splits the string` to characters.

        Example:
        | @{characters} = | Split String To Characters | ${string} |
        """
        return list(string)

    def fetch_from_left(self, string, marker):
        """Returns contents of the `string` before the first occurrence of `marker`.

        If the `marker` is not found, whole string is returned.

        See also `Fetch From Right`, `Split String` and `Split String
        From Right`.
        """
        return string.split(marker)[0]

    def fetch_from_right(self, string, marker):
        """Returns contents of the `string` after the last occurrence of `marker`.

        If the `marker` is not found, whole string is returned.

        See also `Fetch From Left`, `Split String` and `Split String
        From Right`.
        """
        return string.split(marker)[-1]

    def generate_random_string(self, length=8, chars='[LETTERS][NUMBERS]'):
        """Generates a string with a desired `length` from the given `chars`.

        The population sequence `chars` contains the characters to use
        when generating the random string. It can contain any
        characters, and it is possible to use special markers
        explained in the table below:

        | _[LOWER]_   | Lowercase ASCII characters from 'a' to 'z'. |
        | _[UPPER]_   | Uppercase ASCII characters from 'A' to 'Z'. |
        | _[LETTERS]_ | Lowercase and uppercase ASCII characters.   |
        | _[NUMBERS]_ | Numbers from 0 to 9. |

        Examples:
        | ${ret} = | Generate Random String |
        | ${low} = | Generate Random String | 12 | [LOWER]         |
        | ${bin} = | Generate Random String | 8  | 01              |
        | ${hex} = | Generate Random String | 4  | [NUMBERS]abcdef |
        """
        if length == '':
            length = 8
        length = self._convert_to_integer(length, 'length')
        for name, value in [('[LOWER]', ascii_lowercase),
                            ('[UPPER]', ascii_uppercase),
                            ('[LETTERS]', ascii_lowercase + ascii_uppercase),
                            ('[NUMBERS]', digits)]:
            chars = chars.replace(name, value)
        maxi = len(chars) - 1
        return ''.join([ chars[randint(0, maxi)] for i in xrange(length) ])

    def get_substring(self, string, start, end=None):
        """Returns a substring from `start` index to `end` index.

        The `start` index is inclusive and `end` is exclusive.
        Indexing starts from 0, and it is possible to use
        negative indices to refer to characters from the end.

        Examples:
        | ${ignore first} = | Get Substring | ${string} | 1  |    |
        | ${ignore last} =  | Get Substring | ${string} |    | -1 |
        | ${5th to 10th} =  | Get Substring | ${string} | 4  | 10 |
        | ${first two} =    | Get Substring | ${string} |    | 1  |
        | ${last two} =     | Get Substring | ${string} | -2 |    |
        """
        start = self._convert_to_index(start, 'start')
        end = self._convert_to_index(end, 'end')
        return string[start:end]

    def should_be_string(self, item, msg=None):
        """Fails if the given `item` is not a string.

        This keyword passes regardless is the `item` is a Unicode string or
        a byte string. Use `Should Be Unicode String` or `Should Be Byte
        String` if you want to restrict the string type.

        The default error message can be overridden with the optional
        `msg` argument.
        """
        if not isinstance(item, basestring):
            self._fail(msg, "'%s' is not a string.", item)

    def should_not_be_string(self, item, msg=None):
        """Fails if the given `item` is a string.

        The default error message can be overridden with the optional
        `msg` argument.
        """
        if isinstance(item, basestring):
            self._fail(msg, "'%s' is a string.", item)

    def should_be_unicode_string(self, item, msg=None):
        """Fails if the given `item` is not a Unicode string.

        Use `Should Be Byte String` if you want to verify the `item` is a
        byte string, or `Should Be String` if both Unicode and byte strings
        are fine.

        The default error message can be overridden with the optional
        `msg` argument.

        New in Robot Framework 2.7.7.
        """
        if not isinstance(item, unicode):
            self._fail(msg, "'%s' is not a Unicode string.", item)

    def should_be_byte_string(self, item, msg=None):
        """Fails if the given `item` is not a byte string.

        Use `Should Be Unicode String` if you want to verify the `item` is a
        Unicode string, or `Should Be String` if both Unicode and byte strings
        are fine.

        The default error message can be overridden with the optional
        `msg` argument.

        New in Robot Framework 2.7.7.
        """
        if not isinstance(item, str):
            self._fail(msg, "'%s' is not a byte string.", item)

    def should_be_lowercase(self, string, msg=None):
        """Fails if the given `string` is not in lowercase.

        For example 'string' and 'with specials!' would pass, and 'String', ''
        and ' ' would fail.

        The default error message can be overridden with the optional
        `msg` argument.

        See also `Should Be Uppercase` and `Should Be Titlecase`.
        All these keywords were added in Robot Framework 2.1.2.
        """
        if not string.islower():
            self._fail(msg, "'%s' is not lowercase.", string)

    def should_be_uppercase(self, string, msg=None):
        """Fails if the given `string` is not in uppercase.

        For example 'STRING' and 'WITH SPECIALS!' would pass, and 'String', ''
        and ' ' would fail.

        The default error message can be overridden with the optional
        `msg` argument.

        See also `Should Be Titlecase` and `Should Be Lowercase`.
        All these keywords were added in Robot Framework 2.1.2.
        """
        if not string.isupper():
            self._fail(msg, "'%s' is not uppercase.", string)

    def should_be_titlecase(self, string, msg=None):
        """Fails if given `string` is not title.

        `string` is a titlecased string if there is at least one
        character in it, uppercase characters only follow uncased
        characters and lowercase characters only cased ones.

        For example 'This Is Title' would pass, and 'Word In UPPER',
        'Word In lower', '' and ' ' would fail.

        The default error message can be overridden with the optional
        `msg` argument.

        See also `Should Be Uppercase` and `Should Be Lowercase`.
        All theses keyword were added in Robot Framework 2.1.2.
        """
        if not string.istitle():
            self._fail(msg, "'%s' is not titlecase.", string)

    def _convert_to_index(self, value, name):
        if value == '':
            return 0
        if value is None:
            return None
        return self._convert_to_integer(value, name)

    def _convert_to_integer(self, value, name):
        try:
            return int(value)
        except ValueError:
            raise ValueError("Cannot convert '%s' argument '%s' to an integer."
                             % (name, value))

    def _fail(self, message, default_template, *items):
        if not message:
            message = default_template % tuple(unic(item) for item in items)
        raise AssertionError(message)

########NEW FILE########
__FILENAME__ = Telnet
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
from contextlib import contextmanager
import telnetlib
import time
import re
import inspect

from robot.api import logger
from robot.version import get_version
from robot import utils


class Telnet:
    """A test library providing communication over Telnet connections.

    `Telnet` is Robot Framework's standard library that makes it possible to
    connect to Telnet servers and execute commands on the opened connections.

    == Table of contents ==

    - `Connections`
    - `Writing and reading`
    - `Configuration`
    - `Importing`
    - `Logging`
    - `Time string format`
    - `Shortcuts`
    - `Keywords`

    = Connections =

    The first step of using `Telnet` is opening a connection with `Open
    Connection` keyword. Typically the next step is logging in with `Login`
    keyword, and in the end the opened connection can be closed with `Close
    Connection`.

    It is possible to open multiple connections and switch the active one
    using `Switch Connection`. `Close All Connections` can be used to close
    all the connections, which is especially useful in suite teardowns to
    guarantee that all connections are always closed.

    = Writing and reading =

    After opening a connection and possibly logging in, commands can be
    executed or text written to the connection for other reasons using `Write`
    and `Write Bare` keywords. The main difference between these two is that
    the former adds a [#Configuration|configurable newline] after the text
    automatically.

    After writing something to the connection, the resulting output can be
    read using `Read`, `Read Until`, `Read Until Regexp`, and `Read Until
    Prompt` keywords. Which one to use depends on the context, but the latest
    one is often the most convenient.

    As a convenience when running a command, it is possible to use `Execute
    Command` that simply uses `Write` and `Read Until Prompt` internally.
    `Write Until Expected Output` is useful if you need to wait until writing
    something produces a desired output.

    Written and read text is automatically encoded/decoded using a
    [#Configuration|configured encoding].

    = Configuration =

    Many aspects related the connections can be easily configured either
    globally or per connection basis. Global configuration is done when
    [#Importing|library is imported], and these values can be overridden per
    connection by `Open Connection` or with setting specific keywords
    `Set Timeout`, `Set Newline`, `Set Prompt`, `Set Encoding`, and
    `Set Default Log Level`

    == Timeout ==

    Timeout defines how long is the maximum time to wait when reading
    output. It is used internally by `Read Until`, `Read Until Regexp`,
    `Read Until Prompt`, and `Login` keywords. The default value is 3 seconds.

    == Newline ==

    Newline defines which line separator `Write` keyword should use. The
    default value is `CRLF` that is typically used by Telnet connections.

    Newline can be given either in escaped format using '\\n' and '\\r' or
    with special 'LF' and 'CR' syntax.

    Examples:
    | Set Newline | \\n  |
    | Set Newline | CRLF |

    == Prompt ==

    Often the easiest way to read the output of a command is reading all
    the output until the next prompt with `Read Until Prompt`. It also makes
    it easier, and faster, to verify did `Login` succeed.

    Prompt can be specified either as a normal string or a regular expression.
    The latter is especially useful if the prompt changes as a result of
    the executed commands.

    == Encoding ==

    Encoding is needed when written or read text contains non-ASCII characters.
    The default encoding is UTF-8 that works also with ASCII.

    Using UTF-8 encoding by default and being able to configure encoding are
    new features in Robot Framework 2.7.6. In earlier versions only ASCII was
    supported.

    == Default log level ==

    Default log level specifies the log level keywords use for `logging` unless
    they are given an explicit log level. The default value is `INFO`, and
    changing it, for example, to `DEBUG` can be a good idea if there is lot
    of unnecessary output that makes log files big.

    Configuring default log level in `importing` and with `Open Connection`
    are new features in Robot Framework 2.7.6. In earlier versions only
    `Set Default Log Level` could be used.

    = Logging =

    All keywords that read something log the output. These keywords take the
    log level to use as an optional argument, and if no log level is specified
    they use the [#Configuration|configured] default value.

    The valid log levels to use are `TRACE`, `DEBUG`, `INFO` (default), and
    `WARN`. Levels below `INFO` are not shown in log files by default whereas
    warnings are shown more prominently.

    = Time string format =

    Timeouts and other times used must be given as a time string using format
    in format like '15 seconds' or '1min 10s'. If the timeout is given as
    just a number, for example, '10' or '1.5', it is considered to be seconds.
    The time string format is described in more detail in an appendix of
    [http://code.google.com/p/robotframework/wiki/UserGuide|Robot Framework User Guide].
    """
    ROBOT_LIBRARY_SCOPE = 'TEST_SUITE'
    ROBOT_LIBRARY_VERSION = get_version()

    def __init__(self, timeout='3 seconds', newline='CRLF', prompt=None,
                 prompt_is_regexp=False, encoding='UTF-8', default_log_level='INFO'):
        """Telnet library can be imported with optional configuration parameters.

        Configuration parameters are used as default values when new
        connections are opened with `Open Connection` keyword. They can also be
        overridden after opening the connection using the `Set Timeout`,
        `Set Newline`, `Set Prompt`, `Set Encoding`, and `Set Default Log Level`
        keywords. See these keywords and `Configuration` section above for more
        information about these parameters and their possible values.

        Examples (use only one of these):

        | *Setting* | *Value* | *Value* | *Value* | *Value* | *Value* | *Comment* |
        | Library | Telnet |     |    |     |    | # default values                |
        | Library | Telnet | 0.5 |    |     |    | # set only timeout              |
        | Library | Telnet |     | LF |     |    | # set only newline              |
        | Library | Telnet | newline=LF | encoding=ISO-8859-1 | | | # set newline and encoding using named arguments |
        | Library | Telnet | 2.0 | LF |     |    | # set timeout and newline       |
        | Library | Telnet | 2.0 | CRLF | $ |    | # set also prompt               |
        | Library | Telnet | 2.0 | LF | (> |# ) | True | # set prompt as a regular expression |
        """
        self._timeout = timeout or 3.0
        self._newline = newline or 'CRLF'
        self._prompt = (prompt, bool(prompt_is_regexp))
        self._encoding = encoding
        self._default_log_level = default_log_level
        self._cache = utils.ConnectionCache()
        self._conn = None
        self._conn_kws = self._lib_kws = None

    def get_keyword_names(self):
        return self._get_library_keywords() + self._get_connection_keywords()

    def _get_library_keywords(self):
        if self._lib_kws is None:
            self._lib_kws = self._get_keywords(self, ['get_keyword_names'])
        return self._lib_kws

    def _get_keywords(self, source, excluded):
        return [name for name in dir(source)
                if self._is_keyword(name, source, excluded)]

    def _is_keyword(self, name, source, excluded):
        return (name not in excluded and
                not name.startswith('_') and
                name != 'get_keyword_names' and
                inspect.ismethod(getattr(source, name)))

    def _get_connection_keywords(self):
        if self._conn_kws is None:
            conn = self._get_connection()
            excluded = [name for name in dir(telnetlib.Telnet())
                        if name not in ['write', 'read', 'read_until']]
            self._conn_kws = self._get_keywords(conn, excluded)
        return self._conn_kws

    def __getattr__(self, name):
        if name not in self._get_connection_keywords():
            raise AttributeError(name)
        # If no connection is initialized, get attributes from a non-active
        # connection. This makes it possible for Robot to create keyword
        # handlers when it imports the library.
        return getattr(self._conn or self._get_connection(), name)

    def open_connection(self, host, alias=None, port=23, timeout=None,
                        newline=None, prompt=None, prompt_is_regexp=False,
                        encoding=None, default_log_level=None):
        """Opens a new Telnet connection to the given host and port.

        The `timeout`, `newline`, `prompt`, `prompt_is_regexp`, `encoding`,
        and `default_log_level` arguments get default values when the library
        is [#Importing|imported]. Setting them here overrides those values for
        the opened connection. See `Configuration` section for more information.

        Possible already opened connections are cached and it is possible to
        switch back to them using `Switch Connection` keyword. It is possible
        to switch either using explicitly given `alias` or using index returned
        by this keyword. Indexing starts from 1 and is reset back to it by
        `Close All Connections` keyword.
        """
        timeout = timeout or self._timeout
        newline = newline or self._newline
        encoding = encoding or self._encoding
        default_log_level = default_log_level or self._default_log_level
        if not prompt:
            prompt, prompt_is_regexp = self._prompt
        logger.info('Opening connection to %s:%s with prompt: %s'
                    % (host, port, prompt))
        self._conn = self._get_connection(host, port, timeout, newline,
                                          prompt, prompt_is_regexp,
                                          encoding, default_log_level)
        return self._cache.register(self._conn, alias)

    def _get_connection(self, *args):
        """Can be overridden to use a custom connection."""
        return TelnetConnection(*args)

    def switch_connection(self, index_or_alias):
        """Switches between active connections using an index or an alias.

        Aliases can be given to `Open Connection` keyword which also always
        returns the connection index.

        This keyword returns the index of previous active connection.

        Example:
        | `Open Connection`   | myhost.net              |          |           |
        | `Login`             | john                    | secret   |           |
        | `Write`             | some command            |          |           |
        | `Open Connection`   | yourhost.com            | 2nd conn |           |
        | `Login`             | root                    | password |           |
        | `Write`             | another cmd             |          |           |
        | ${old index}=       | `Switch Connection`     | 1        | # index   |
        | `Write`             | something               |          |           |
        | `Switch Connection` | 2nd conn                |          | # alias   |
        | `Write`             | whatever                |          |           |
        | `Switch Connection` | ${old index}            | | # back to original |
        | [Teardown]          | `Close All Connections` |          |           |

        The example above expects that there were no other open
        connections when opening the first one, because it used index
        '1' when switching to the connection later. If you are not
        sure about that, you can store the index into a variable as
        shown below.

        | ${index} =          | `Open Connection` | myhost.net |
        | `Do Something`      |                   |            |
        | `Switch Connection` | ${index}          |            |
        """
        old_index = self._cache.current_index
        self._conn = self._cache.switch(index_or_alias)
        return old_index

    def close_all_connections(self):
        """Closes all open connections and empties the connection cache.

        If multiple connections are opened, this keyword should be used in
        a test or suite teardown to make sure that all connections are closed.
        It is not an error is some of the connections have already been closed
        by `Close Connection`.

        After this keyword, new indexes returned by `Open Connection`
        keyword are reset to 1.
        """
        self._conn = self._cache.close_all()


class TelnetConnection(telnetlib.Telnet):

    def __init__(self, host=None, port=23, timeout=3.0, newline='CRLF',
                 prompt=None, prompt_is_regexp=False, encoding='UTF-8',
                 default_log_level='INFO'):
        telnetlib.Telnet.__init__(self, host, int(port) if port else 23)
        self._set_timeout(timeout)
        self._set_newline(newline)
        self._set_prompt(prompt, prompt_is_regexp)
        self._set_encoding(encoding)
        self._set_default_log_level(default_log_level)
        self.set_option_negotiation_callback(self._negotiate_echo_on)

    def set_timeout(self, timeout):
        """Sets the timeout used for waiting output in the current connection.

        Read operations that expect some output to appear (`Read Until`, `Read
        Until Regexp`, `Read Until Prompt`, `Login`) use this timeout and fail
        if the expected output does not appear before this timeout expires.

        The `timeout` must be given in `time string format`. The old timeout is
        returned and can be used to restore the timeout later.

        Example:
        | ${old} =       | `Set Timeout` | 2 minute 30 seconds |
        | `Do Something` |
        | `Set Timeout`  | ${old}  |

        See `Configuration` section for more information about global and
        connection specific configuration.
        """
        self._verify_connection()
        old = self._timeout
        self._set_timeout(timeout)
        return utils.secs_to_timestr(old)

    def _set_timeout(self, timeout):
        self._timeout = utils.timestr_to_secs(timeout)

    def set_newline(self, newline):
        """Sets the newline used by `Write` keyword in the current connection.

        The old newline is returned and can be used to restore the newline later.

        See `Configuration` section for more information about global and
        connection specific configuration.
        """
        self._verify_connection()
        old = self._newline
        self._set_newline(newline)
        return old

    def _set_newline(self, newline):
        self._newline = newline.upper().replace('LF','\n').replace('CR','\r')

    def set_prompt(self, prompt, prompt_is_regexp=False):
        """Sets the prompt used by `Read Until Prompt` and `Login` in the current connection.

        If `prompt_is_regexp` is given any true value, including any non-empty
        string, the given `prompt` is considered to be a regular expression.

        The old prompt is returned and can be used to restore the prompt later.

        Example:
        | ${prompt} | ${regexp} = | `Set Prompt` | $ |
        | `Do Something` |
        | `Set Prompt` | ${prompt} | ${regexp} |

        See the documentation of
        [http://docs.python.org/2/library/re.html|Python `re` module]
        for more information about the supported regular expression syntax.
        Notice that possible backslashes need to be escaped in Robot Framework
        test data.

        See `Configuration` section for more information about global and
        connection specific configuration.
        """
        self._verify_connection()
        old = self._prompt
        self._set_prompt(prompt, prompt_is_regexp)
        if old[1]:
            return old[0].pattern, True
        return old

    def _set_prompt(self, prompt, prompt_is_regexp):
        if prompt_is_regexp:
            self._prompt = (re.compile(prompt), True)
        else:
            self._prompt = (prompt, False)

    def _prompt_is_set(self):
        return self._prompt[0] is not None

    def set_encoding(self, encoding):
        """Sets the encoding to use for `writing and reading` in the current connection.

        The old encoding is returned and can be used to restore the encoding
        later.

        See `Configuration` section for more information about global and
        connection specific configuration.

        Setting encoding is a new feature in Robot Framework 2.7.6. Earlier
        versions only supported ASCII.
        """
        self._verify_connection()
        old = self._encoding
        self._set_encoding(encoding)
        return old

    def _set_encoding(self, encoding):
        self._encoding = encoding

    def _encode(self, text):
        if isinstance(text, str):
            return text
        return text.encode(self._encoding)

    def _decode(self, bytes):
        return bytes.decode(self._encoding)

    def set_default_log_level(self, level):
        """Sets the default log level used for `logging` in the current connection.

        The old default log level is returned and can be used to restore the
        log level later.

        See `Configuration` section for more information about global and
        connection specific configuration.
        """
        self._verify_connection()
        old = self._default_log_level
        self._set_default_log_level(level)
        return old

    def _set_default_log_level(self, level):
        if level is None or not self._is_valid_log_level(level):
            raise AssertionError("Invalid log level '%s'" % level)
        self._default_log_level = level.upper()

    def _is_valid_log_level(self, level):
        return level is None or level.upper() in ('TRACE', 'DEBUG', 'INFO', 'WARN')

    def close_connection(self, loglevel=None):
        """Closes the current Telnet connection.

        Remaining output in the connection is read, logged, and returned.
        It is not an error to close an already closed connection.

        Use `Close All Connections` if you want to make sure all opened
        connections are closed.

        See `Logging` section for more information about log levels.
        """
        self.close()
        output = self._decode(self.read_all())
        self._log(output, loglevel)
        return output

    def login(self, username, password, login_prompt='login: ',
              password_prompt='Password: ', login_timeout='1 second',
              login_incorrect='Login incorrect'):
        """Logs in to the Telnet server with the given user information.

        This keyword reads from the connection until the `login_prompt` is
        encountered and then types the given `username`. Then it reads until
        the `password_prompt` and types the given `password`. In both cases
        a newline is appended automatically and the connection specific
        timeout used when waiting for outputs.

        How logging status is verified depends on whether a prompt is set for
        this connection or not:

        1) If the prompt is set, this keyword reads the output until the prompt
        is found using the normal timeout. If no prompt is found, login is
        considered failed and also this keyword fails. Note that in this case
        both `login_timeout` and `login_incorrect` arguments are ignored.

        2) If the prompt is not set, this keywords sleeps until `login_timeout`
        and then reads all the output available on the connection. If the
        output contains `login_incorrect` text, login is considered failed
        and also this keyword fails. Both of these configuration parameters
        were added in Robot Framework 2.7.6. In earlier versions they were
        hard coded.

        See `Configuration` section for more information about setting
        newline, timeout, and prompt.
        """
        output = self._submit_credentials(username, password, login_prompt,
                                          password_prompt)
        if self._prompt_is_set():
            success, output2 = self._read_until_prompt()
        else:
            success, output2 = self._verify_login_without_prompt(
                    login_timeout, login_incorrect)
        output += output2
        self._log(output)
        if not success:
            raise AssertionError('Login incorrect')
        return output

    def _submit_credentials(self, username, password, login_prompt, password_prompt):
        output = self.read_until(login_prompt, 'TRACE')
        output += self.write(username, 'TRACE')
        output += self.read_until(password_prompt, 'TRACE')
        output += self.write(password, 'TRACE')
        return output

    def _verify_login_without_prompt(self, delay, incorrect):
        time.sleep(utils.timestr_to_secs(delay))
        output = self.read('TRACE')
        success = incorrect not in output
        return success, output

    def write(self, text, loglevel=None):
        """Writes the given text plus a newline into the connection.

        The newline character sequence to use can be [#Configuration|configured]
        both globally and per connection basis. The default value is `CRLF`.

        This keyword consumes the written text, until the added newline, from
        the output and logs and returns it. The given text itself must not
        contain newlines. Use `Write Bare` instead if either of these features
        causes a problem.

        *Note:* This keyword does not return the possible output of the executed
        command. To get the output, one of the `Read ...` keywords must be used.
        See `Writing and reading` section for more details.

        See `Logging` section for more information about log levels.
        """
        if self._newline in text:
            raise RuntimeError("'Write' keyword cannot be used with strings "
                               "containing newlines. Use 'Write Bare' instead.")
        self.write_bare(text + self._newline)
        # Can't read until 'text' because long lines are cut strangely in the output
        return self.read_until(self._newline, loglevel)

    def write_bare(self, text):
        """Writes the given text, and nothing else, into the connection.

        This keyword does not append a newline nor consume the written text.
        Use `Write` if these features are needed.
        """
        self._verify_connection()
        telnetlib.Telnet.write(self, self._encode(text))

    def write_until_expected_output(self, text, expected, timeout,
                                    retry_interval, loglevel=None):
        """Writes the given `text` repeatedly, until `expected` appears in the output.

        `text` is written without appending a newline and it is consumed from
        the output before trying to find `expected`. If `expected` does not
        appear in the output within `timeout`, this keyword fails.

        `retry_interval` defines the time to wait `expected` to appear before
        writing the `text` again. Consuming the written `text` is subject to
        the normal [#Configuration|configured timeout].

        Both `timeout` and `retry_interval` must be given in `time string
        format`. See `Logging` section for more information about log levels.

        Example:
        | Write Until Expected Output | ps -ef| grep myprocess\\r\\n | myprocess |
        | ...                         | 5 s                          | 0.5 s     |

        The above example writes command `ps -ef | grep myprocess\\r\\n` until
        `myprocess` appears in the output. The command is written every 0.5
        seconds and the keyword fails if `myprocess` does not appear in
        the output in 5 seconds.
        """
        timeout = utils.timestr_to_secs(timeout)
        retry_interval = utils.timestr_to_secs(retry_interval)
        maxtime = time.time() + timeout
        while time.time() < maxtime:
            self.write_bare(text)
            self.read_until(text, loglevel)
            try:
                with self._custom_timeout(retry_interval):
                    return self.read_until(expected, loglevel)
            except AssertionError:
                pass
        self._raise_no_match_found(expected, timeout)

    def read(self, loglevel=None):
        """Reads everything that is currently available in the output.

        Read output is both returned and logged. See `Logging` section for more
        information about log levels.
        """
        self._verify_connection()
        output = self._decode(self.read_very_eager())
        self._log(output, loglevel)
        return output

    def read_until(self, expected, loglevel=None):
        """Reads output until `expected` text is encountered.

        Text up to and including the match is returned and logged. If no match
        is found, this keyword fails. How much to wait for the output depends
        on the [#Configuration|configured timeout].

        See `Logging` section for more information about log levels. Use
        `Read Until Regexp` if more complex matching is needed.
        """
        output = self._read_until(expected)
        self._log(output, loglevel)
        if not output.endswith(expected):
            self._raise_no_match_found(expected)
        return output

    def _read_until(self, expected):
        self._verify_connection()
        expected = self._encode(expected)
        output = telnetlib.Telnet.read_until(self, expected, self._timeout)
        return self._decode(output)

    def read_until_regexp(self, *expected):
        """Reads output until any of the `expected` regular expressions match.

        This keyword accepts any number of regular expressions patterns or
        compiled Python regular expression objects as arguments. Text up to
        and including the first match to any of the regular expressions is
        returned and logged. If no match is found, this keyword fails. How much
        to wait for the output depends on the [#Configuration|configured timeout].

        If the last given argument is a [#Logging|valid log level], it is used
        as `loglevel` similarly as with `Read Until` keyword.

        See the documentation of
        [http://docs.python.org/2/library/re.html|Python `re` module]
        for more information about the supported regular expression syntax.
        Notice that possible backslashes need to be escaped in Robot Framework
        test data.

        Examples:
        | `Read Until Regexp` | (#|$) |
        | `Read Until Regexp` | first_regexp | second_regexp |
        | `Read Until Regexp` | \\\\d{4}-\\\\d{2}-\\\\d{2} | DEBUG |
        """
        if not expected:
            raise RuntimeError('At least one pattern required')
        if self._is_valid_log_level(expected[-1]):
            loglevel = expected[-1]
            expected = expected[:-1]
        else:
            loglevel = None
        index, output = self._read_until_regexp(*expected)
        self._log(output, loglevel)
        if index == -1:
            expected = [exp if isinstance(exp, basestring) else exp.pattern
                        for exp in expected]
            self._raise_no_match_found(expected)
        return output

    def _read_until_regexp(self, *expected):
        self._verify_connection()
        expected = [self._encode(exp) if isinstance(exp, unicode) else exp
                    for exp in expected]
        try:
            index, _, output = self.expect(expected, self._timeout)
        except TypeError:
            index, output = -1, ''
        return index, self._decode(output)

    def read_until_prompt(self, loglevel=None):
        """Reads output until the prompt is encountered.

        This keyword requires the prompt to be [#Configuration|configured]
        either in `importing` or with `Open Connection` or `Set Prompt` keyword.

        Text up to and including the prompt is returned and logged. If no prompt
        is found, this keyword fails. How much to wait for the output depends
        on the [#Configuration|configured timeout].

        See `Logging` section for more information about log levels.
        """
        if not self._prompt_is_set():
            raise RuntimeError('Prompt is not set')
        success, output = self._read_until_prompt()
        self._log(output, loglevel)
        if not success:
            prompt, regexp = self._prompt
            raise AssertionError("Prompt '%s' not found in %s"
                    % (prompt if not regexp else prompt.pattern,
                       utils.secs_to_timestr(self._timeout)))
        return output

    def _read_until_prompt(self):
        prompt, regexp = self._prompt
        if regexp:
            index, output = self._read_until_regexp(prompt)
            success = index != -1
        else:
            output = self._read_until(prompt)
            success = output.endswith(prompt)
        return success, output

    def execute_command(self, command, loglevel=None):
        """Executes the given `command` and reads, logs, and returns everything until the prompt.

        This keyword requires the prompt to be [#Configuration|configured]
        either in `importing` or with `Open Connection` or `Set Prompt` keyword.

        This is a convenience keyword that uses `Write` and `Read Until Prompt`
        internally Following two examples are thus functionally identical:

        | ${out} = | `Execute Command`   | pwd |

        | `Write`  | pwd                 |
        | ${out} = | `Read Until Prompt` |

        See `Logging` section for more information about log levels.
        """
        self.write(command, loglevel)
        return self.read_until_prompt(loglevel)

    @contextmanager
    def _custom_timeout(self, timeout):
        old = self.set_timeout(timeout)
        try:
            yield
        finally:
            self.set_timeout(old)

    def _verify_connection(self):
        if not self.sock:
            raise RuntimeError('No connection open')

    def _log(self, msg, level=None):
        msg = msg.strip()
        if msg:
            logger.write(msg, level or self._default_log_level)

    def _raise_no_match_found(self, expected, timeout=None):
        timeout = utils.secs_to_timestr(timeout or self._timeout)
        expected = "'%s'" % expected if isinstance(expected, basestring) \
            else utils.seq2str(expected, lastsep=' or ')
        raise AssertionError("No match found for %s in %s" % (expected, timeout))

    def _negotiate_echo_on(self, sock, cmd, opt):
        # This is supposed to turn server side echoing on and turn other options off.
        if opt == telnetlib.ECHO and cmd in (telnetlib.WILL, telnetlib.WONT):
            self.sock.sendall(telnetlib.IAC + telnetlib.DO + opt)
        elif opt != telnetlib.NOOPT:
            if cmd in (telnetlib.DO, telnetlib.DONT):
                self.sock.sendall(telnetlib.IAC + telnetlib.WONT + opt)
            elif cmd in (telnetlib.WILL, telnetlib.WONT):
                self.sock.sendall(telnetlib.IAC + telnetlib.DONT + opt)

########NEW FILE########
__FILENAME__ = XML
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

import copy
import re

from robot.api import logger
from robot.libraries.BuiltIn import BuiltIn
from robot.utils import asserts, ET, ETSource, plural_or_not as s
from robot.version import get_version


should_be_equal = asserts.assert_equals
should_match = BuiltIn().should_match


class XML(object):
    """Robot Framework test library for verifying and modifying XML documents.

    As the name implies, `XML` is a test library for verifying contents of XML
    files. In practice it is a pretty thin wrapper on top of Python's
    [http://docs.python.org/library/xml.etree.elementtree.html|ElementTree XML API].

    The library has the following main usages:

    - Parsing an XML file, or a string containing XML, into an XML element
      structure and finding certain elements from it for for further analysis
      (e.g. `Parse XML` and `Get Element` keywords).
    - Getting text or attributes of elements
      (e.g. `Get Element Text` and `Get Element Attribute`).
    - Directly verifying text, attributes, or whole elements
      (e.g `Element Text Should Be` and `Elements Should Be Equal`).
    - Modifying XML and saving it (e.g. `Set Element Text`, `Add Element`
      and `Save XML`).

    == Table of contents ==

    - `Parsing XML`
    - `Example`
    - `Finding elements with xpath`
    - `Element attributes`
    - `Handling XML namespaces`
    - `Shortcuts`
    - `Keywords`

    = Parsing XML =

    XML can be parsed into an element structure using `Parse XML` keyword.
    It accepts both paths to XML files and strings that contain XML. The
    keyword returns the root element of the structure, which then contains
    other elements as its children and their children.

    The element structure returned by `Parse XML`, as well as elements
    returned by keywords such as `Get Element`, can be used as the `source`
    argument with other keywords. In addition to an already parsed XML
    structure, other keywords also accept paths to XML files and strings
    containing XML similarly as `Parse XML`.

    When the source is given as a path to a file, the forward slash character
    (`/`) can be used as the path separator regardless the operating system.
    On Windows also the backslash works, but it the test data it needs to be
    escaped by doubling it (`\\\\`). Using the built-in variable `${/}`
    naturally works too.

    = Example =

    The following simple example demonstrates parsing XML and verifying its
    contents both using keywords in this library and in `BuiltIn` and
    `Collections` libraries. How to use xpath expressions to find elements
    and what attributes the returned elements contain are discussed, with
    more examples, in `Finding elements with xpath` and `Element attributes`
    sections.

    In this example, as well as in many other examples in this documentation,
    `${XML}` refers to the following example XML document. In practice `${XML}`
    could either be a path to an XML file or it could contain the XML itself.

    | <example>
    |   <first id="1">text</first>
    |   <second id="2">
    |     <child/>
    |   </second>
    |   <third>
    |     <child>more text</child>
    |     <second id="child"/>
    |     <child><grandchild/></child>
    |   </third>
    |   <html>
    |     <p>
    |       Text with <b>bold</b> and <i>italics</i>.
    |     </p>
    |   </html>
    | </example>

    | ${root} =                | `Parse XML`   | ${XML}  |       |             |
    | `Should Be Equal`        | ${root.tag}   | example |       |             |
    | ${first} =               | `Get Element` | ${root} | first |             |
    | `Should Be Equal`        | ${first.text} | text    |       |             |
    | `Dictionary Should Contain Key` | ${first.attrib}  | id    |             |
    | `Element Text Should Be` | ${first}      | text    |       |             |
    | `Element Attribute Should Be` | ${first} | id      | 1     |             |
    | `Element Attribute Should Be` | ${root}  | id      | 1     | xpath=first |
    | `Element Attribute Should Be` | ${XML}   | id      | 1     | xpath=first |

    Notice that in the example three last lines are equivalent. Which one to
    use in practice depends on which other elements you need to get or verify.
    If you only need to do one verification, using the last line alone would
    suffice. If more verifications are needed, parsing the XML with `Parse XML`
    only once would be more efficient.

    = Finding elements with xpath =

    ElementTree, and thus also this library, supports finding elements using
    xpath expressions. ElementTree does not, however, support the full xpath
    syntax, and what is supported depends on its version. ElementTree 1.3 that
    is distributed with Python and Jython 2.7 supports richer syntax than
    versions distributed with earlier Python interpreters.

    The supported xpath syntax is explained below and
    [http://effbot.org/zone/element-xpath.htm|ElementTree documentation]
    provides more details. In the examples `${XML}` refers to the same XML
    structure as in the earlier example.

    == Tag names ==

    When just a single tag name is used, xpath matches all direct child
    elements that have that tag name.

    | ${elem} =          | `Get Element`  | ${XML}      | third |
    | `Should Be Equal`  | ${elem.tag}    | third       |       |
    | @{children} =      | `Get Elements` | ${elem}     | child |
    | `Length Should Be` | ${children}    | 2           |       |

    == Paths ==

    Paths are created by combining tag names with a forward slash (`/`).
    For example, `parent/child` matches all `child` elements under `parent`
    element. Notice that if there are multiple `parent` elements that all
    have `child` elements, `parent/child` xpath will match all these `child`
    elements.

    | ${elem} =         | `Get Element` | ${XML}     | second/child            |
    | `Should Be Equal` | ${elem.tag}   | child      |                         |
    | ${elem} =         | `Get Element` | ${XML}     | third/child/grandchild  |
    | `Should Be Equal` | ${elem.tag}   | grandchild |                         |

    == Wildcards ==

    An asterisk (`*`) can be used in paths instead of a tag name to denote
    any element.

    | @{children} =      | `Get Elements` | ${XML} | */child |
    | `Length Should Be` | ${children}    | 3      |         |

    == Current element ==

    The current element is denoted with a dot (`.`). Normally the current
    element is implicit and does not need to be included in the xpath.

    == Parent element ==

    The parent element of another element is denoted with two dots (`..`).
    Notice that it is not possible to refer to the parent of the current
    element. This syntax is supported only in ElementTree 1.3 (i.e.
    Python/Jython 2.7 and newer).

    | ${elem} =         | `Get Element` | ${XML} | */second/.. |
    | `Should Be Equal` | ${elem.tag}   | third  |             |

    == Search all sub elements ==

    Two forward slashes (`//`) mean that all sub elements, not only the
    direct children, are searched. If the search is started from the current
    element, an explicit dot is required.

    | @{elements} =      | `Get Elements` | ${XML} | .//second |
    | `Length Should Be` | ${elements}    | 2      |           |
    | ${b} =             | `Get Element`  | ${XML} | html//b   |
    | `Should Be Equal`  | ${b.text}      | bold   |           |

    == Predicates ==

    Predicates allow selecting elements using also other criteria than tag
    names, for example, attributes or position. They are specified after the
    normal tag name or path using syntax `path[predicate]`. The path can have
    wildcards and other special syntax explained above.

    What predicates ElementTree supports is explained in the table below.
    Notice that predicates in general are supported only in ElementTree 1.3
    (i.e. Python/Jython 2.7 and newer).

    | _Predicate_     | _Matches_                         | _Example_          |
    | @attrib         | Elements with attribute `attrib`. | second[@id]        |
    | @attrib="value" | Elements with attribute `attrib` having value `value`. | *[@id="2"] |
    | position        | Elements at the specified position. Position can be an integer (starting from 1), expression `last()`, or relative expression like `last() - 1`. | third/child[1] |
    | tag             | Elements with a child element named `tag`. | third/child[grandchild] |

    Predicates can also be stacked like `path[predicate1][predicate2]`.
    A limitation is that possible position predicate must always be first.

    = Element attributes =

    All keywords returning elements, such as `Parse XML`, and `Get Element`,
    return ElementTree's
    [http://docs.python.org/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element|Element objects].
    These elements can be used as inputs for other keywords, but they also
    contain several useful attributes that can be accessed directly using
    the extended variable syntax.

    The attributes that are both useful and convenient to use in the test
    data are explained below. Also other attributes, including methods, can
    be accessed, but that is typically better to do in custom libraries than
    directly in the test data.

    The examples use the same `${XML}` structure as the earlier examples.

    == tag ==

    The tag of the element.

    | ${root} =         | `Parse XML` | ${XML}  |
    | `Should Be Equal` | ${root.tag} | example |

    == text ==

    The text that the element contains or Python `None` if the element has no
    text. Notice that the text _does not_ contain texts of possible child
    elements nor text after or between children. Notice also that in XML
    whitespace is significant, so the text contains also possible indentation
    and newlines. To get also text of the possible children, optionally
    whitespace normalized, use `Get Element Text` keyword.

    | ${1st} =          | `Get Element` | ${XML}  | first        |
    | `Should Be Equal` | ${1st.text}   | text    |              |
    | ${2nd} =          | `Get Element` | ${XML}  | second/child |
    | `Should Be Equal` | ${2nd.text}   | ${NONE} |              |
    | ${p} =            | `Get Element` | ${XML}  | html/p       |
    | `Should Be Equal` | ${p.text}     | \\n${SPACE*6}Text with${SPACE} |

    == tail ==

    The text after the element before the next opening or closing tag. Python
    `None` if the element has no tail. Similarly as with `text`, also `tail`
    contains possible indentation and newlines.

    | ${b} =            | `Get Element` | ${XML}  | html/p/b  |
    | `Should Be Equal` | ${b.tail}     | ${SPACE}and${SPACE} |

    == attrib ==

    A Python dictionary containing attributes of the element.

    | ${2nd} =          | `Get Element`       | ${XML} | second |
    | `Should Be Equal` | ${2nd.attrib['id']} | 2      |        |
    | ${3rd} =          | `Get Element`       | ${XML} | third  |
    | `Should Be Empty` | ${3rd.attrib}       |        |        |

    = Handling XML namespaces =

    ElementTree handles possible namespaces in XML documents by adding the
    namespace URI to tag names in so called Clark Notation. That is
    inconvenient especially with xpaths, and by default this library strips
    those namespaces away and moves them to `xmlns` attribute instead. That can
    be avoided by passing `keep_clark_notation` argument to `Parse XML` keyword.
    The pros and cons of both approaches are discussed in more detail below.

    == How ElementTree handles namespaces ==

    If an XML document has namespaces, ElementTree adds namespace information
    to tag names in [http://www.jclark.com/xml/xmlns.htm|Clark Notation]
    (e.g. `{http://ns.uri}tag` and removes original `xmlns` attributes. This
    is done both with default namespaces and with namespaces with a prefix.
    How it works in practice is illustrated by the following example, where
    `${NS}` variable contains this XML document:

    | <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    |                 xmlns="http://www.w3.org/1999/xhtml">
    |   <xsl:template match="/">
    |     <html></html>
    |   </xsl:template>
    | </xsl:stylesheet>

    | ${root} = | `Parse XML` | ${NS} | keep_clark_notation=yes |
    | `Should Be Equal` | ${root.tag} | {http://www.w3.org/1999/XSL/Transform}stylesheet |
    | `Element Should Exist` | ${root} | {http://www.w3.org/1999/XSL/Transform}template/{http://www.w3.org/1999/xhtml}html |
    | `Should Be Empty` | ${root.attrib} |

    As you can see, including the namespace URI in tag names makes xpaths
    really long and complex.

    If you save the XML, ElementTree moves namespace information back to `xmlns`
    attributes. Unfortunately it does not restore the original prefixes:

    | <ns0:stylesheet xmlns:ns0="http://www.w3.org/1999/XSL/Transform">
    |   <ns0:template match="/">
    |     <ns1:html xmlns:ns1="http://www.w3.org/1999/xhtml"></ns1:html>
    |   </ns0:template>
    | </ns0:stylesheet>

    The resulting output is semantically same as the original, but mangling
    prefixes like this may still not be desirable. Notice also that the actual
    output depends slightly on ElementTree version.

    == Default namespace handling ==

    Because the way ElementTree handles namespaces makes xpaths so complicated,
    this library, by default, strips namespaces from tag names and moves that
    information back to `xmlns` attributes. How this works in practice is shown
    by the example below, where `${NS}` variable contains the same XML
    document as in the previous example.

    | ${root} = | `Parse XML` | ${NS} |
    | `Should Be Equal` | ${root.tag} | stylesheet |
    | `Element Should Exist` | ${root} | template/html |
    | `Element Attribute Should Be` | ${root} | xmlns | http://www.w3.org/1999/XSL/Transform |
    | `Element Attribute Should Be` | ${root} | xmlns | http://www.w3.org/1999/xhtml | xpath=template/html |

    Now that tags do not contain namespace information, xpaths are simple again.

    A minor limitation of this approach is that namespace prefixes are lost.
    As a result the saved output is not exactly same as the original one in
    this case either:

    | <stylesheet xmlns="http://www.w3.org/1999/XSL/Transform">
    |   <template match="/">
    |     <html xmlns="http://www.w3.org/1999/xhtml"></html>
    |   </template>
    | </stylesheet>

    Also this output is semantically same as the original. If the original XML
    had only default namespaces, the output would also looks identical.

    == Attribute namespaces ==

    Attributes in XML documents are, by default, in the same namespaces as
    the element they belong to. It is possible to use different namespaces
    by using prefixes, but this is pretty rare.

    If an attribute has a namespace prefix, ElementTree will replace it with
    Clark Notation the same way it handles elements. Because stripping
    namespaces from attributes could cause attribute conflicts, this library
    does not handle attribute namespaces at all. Thus the following example
    works the same way regardless how namespaces are handled.

    | ${root} = | `Parse XML` | <root id="1" ns:id="2" xmlns:ns="http://my.ns"/> |
    | `Element Attribute Should Be` | ${root} | id | 1 |
    | `Element Attribute Should Be` | ${root} | {http://my.ns}id | 2 |
    """

    ROBOT_LIBRARY_SCOPE = 'GLOBAL'
    ROBOT_LIBRARY_VERSION = get_version()
    _whitespace = re.compile('\s+')
    _xml_declaration = re.compile('^<\?xml .*\?>\n')

    def parse_xml(self, source, keep_clark_notation=False):
        """Parses the given XML file or string into an element structure.

        The `source` can either be a path to an XML file or a string containing
        XML. In both cases the XML is parsed into ElementTree
        [http://docs.python.org/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element|element structure]
        and the root element is returned.

        As discussed in `Handling XML namespaces` section, this keyword, by
        default, strips possible namespaces added by ElementTree into tag names.
        This typically eases handling XML documents with namespaces
        considerably. If you do not want that to happen, or want to avoid
        the small overhead of going through the element structure when your
        XML does not have namespaces, you can disable this feature by giving
        `keep_clark_notation` argument a true value (e.g. any non-empty string).

        Examples:
        | ${root} = | Parse XML | <root><child/></root> |
        | ${xml} =  | Parse XML | ${CURDIR}/test.xml    | no namespace cleanup |

        Use `Get Element` keyword if you want to get a certain element and not
        the whole structure. See `Parsing XML` section for more details and
        examples

        Stripping namespaces is a new feature in Robot Framework 2.7.5.
        """
        with ETSource(source) as source:
            root = ET.parse(source).getroot()
        if not keep_clark_notation:
            self._strip_namespaces(root)
        return root

    def _strip_namespaces(self, elem, current_ns=None):
        if elem.tag.startswith('{') and '}' in elem.tag:
            ns, elem.tag = elem.tag[1:].split('}', 1)
            if ns != current_ns:
                elem.set('xmlns', ns)
                current_ns = ns
        for child in elem:
            self._strip_namespaces(child, current_ns)

    def get_element(self, source, xpath='.'):
        """Returns an element in the `source` matching the `xpath`.

        The `source` can be a path to an XML file, a string containing XML, or
        an already parsed XML element. The `xpath` specifies which element to
        find. See the `introduction` for more details about both the possible
        sources and the supported xpath syntax.

        The keyword fails if more, or less, than one element matches the
        `xpath`. Use `Get Elements` if you want all matching elements to be
        returned.

        Examples using `${XML}` structure from the `introduction`:
        | ${element} = | Get Element | ${XML}     | second |
        | ${child} =   | Get Element | ${element} | child  |

        `Parse XML` is recommended for parsing XML when the whole structure
        is needed. It must be used if there is a need to configure how XML
        namespaces are handled.
        """
        elements = self.get_elements(source, xpath)
        if len(elements) != 1:
            self._raise_wrong_number_of_matches(len(elements), xpath)
        return elements[0]

    def _raise_wrong_number_of_matches(self, count, xpath, message=None):
        if not message:
            message = self._wrong_number_of_matches(count, xpath)
        raise AssertionError(message)

    def _wrong_number_of_matches(self, count, xpath):
        if not count:
            return "No element matching '%s' found." % xpath
        if count == 1:
            return "One element matching '%s' found." % xpath
        return "Multiple elements (%d) matching '%s' found." % (count, xpath)

    def get_elements(self, source, xpath):
        """Returns a list of elements in the `source` matching the `xpath`.

        The `source` can be a path to an XML file, a string containing XML, or
        an already parsed XML element. The `xpath` specifies which element to
        find. See the `introduction` for more details.

        Elements matching the `xpath` are returned as a list. If no elements
        match, an empty list is returned. Use `Get Element` if you want to get
        exactly one match.

        Examples using `${XML}` structure from the `introduction`:
        | ${children} =    | Get Elements | ${XML} | third/child |
        | Length Should Be | ${children}  | 2      |             |
        | ${children} =    | Get Elements | ${XML} | first/child |
        | Should Be Empty  |  ${children} |        |             |
        """
        if isinstance(source, basestring):
            source = self.parse_xml(source)
        if not xpath:
            raise RuntimeError('No xpath given.')
        if xpath == '.':  # ET < 1.3 does not support '.' alone.
            return [source]
        return source.findall(self._get_xpath(xpath))

    if ET.VERSION >= '1.3':
        def _get_xpath(self, xpath):
            return xpath
    else:
        def _get_xpath(self, xpath):
            try:
                return str(xpath)
            except UnicodeError:
                if not xpath.replace('/', '').isalnum():
                    logger.warn('XPATHs containing non-ASCII characters and '
                                'other than tag names do not always work with '
                                'Python/Jython versions prior to 2.7. Verify '
                                'results manually and consider upgrading to 2.7.')
                return xpath

    def get_child_elements(self, source, xpath='.'):
        """Returns the child elements of the specified element as a list.

        The element whose children to return is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        All the direct child elements of the specified element are returned.
        If the element has no children, an empty list is returned.

        Examples using `${XML}` structure from the `introduction`:
        | ${children} =    | Get Child Elements | ${XML} |             |
        | Length Should Be | ${children}        | 4      |             |
        | ${children} =    | Get Child Elements | ${XML} | xpath=first |
        | Should Be Empty  | ${children}        |        |             |
        """
        return list(self.get_element(source, xpath))

    def get_element_count(self, source, xpath='.'):
        """Returns and logs how many elements the given `xpath` matches.

        Arguments `source` and `xpath` have exactly the same semantics as with
        `Get Elements` keyword that this keyword uses internally.

        See also `Element Should Exist` and `Element Should Not Exist`.

        New in Robot Framework 2.7.5.
        """
        count = len(self.get_elements(source, xpath))
        logger.info("%d element%s matched '%s'." % (count, s(count), xpath))
        return count

    def element_should_exist(self, source, xpath='.', message=None):
        """Verifies that one or more element match the given `xpath`.

        Arguments `source` and `xpath` have exactly the same semantics as with
        `Get Elements` keyword. Keyword passes if the `xpath` matches one or
        more elements in the `source`. The default error message can be
        overridden with the `message` argument.

        See also `Element Should Not Exist` as well as `Get Element Count`
        that this keyword uses internally.

        New in Robot Framework 2.7.5.
        """
        count = self.get_element_count(source, xpath)
        if not count:
            self._raise_wrong_number_of_matches(count, xpath, message)

    def element_should_not_exist(self, source, xpath='.', message=None):
        """Verifies that no element match the given `xpath`.

        Arguments `source` and `xpath` have exactly the same semantics as with
        `Get Elements` keyword. Keyword fails if the `xpath` matches any
        element in the `source`. The default error message can be overridden
        with the `message` argument.

        See also `Element Should Exist` as well as `Get Element Count`
        that this keyword uses internally.

        New in Robot Framework 2.7.5.
        """
        count = self.get_element_count(source, xpath)
        if count:
            self._raise_wrong_number_of_matches(count, xpath, message)

    def get_element_text(self, source, xpath='.', normalize_whitespace=False):
        """Returns all text of the element, possibly whitespace normalized.

        The element whose text to return is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        This keyword returns all the text of the specified element, including
        all the text its children and grandchildren contains. If the element
        has no text, an empty string is returned. As discussed in the
        `introduction`, the returned text is thus not always the same as
        the `text` attribute of the element.

        Be default all whitespace, including newlines and indentation, inside
        the element is returned as-is. If `normalize_whitespace` is given any
        true value (e.g. any non-empty string), then leading and trailing
        whitespace is stripped, newlines and tabs converted to spaces, and
        multiple spaces collapsed into one. This is especially useful when
        dealing with HTML data.

        Examples using `${XML}` structure from the `introduction`:
        | ${text} =       | Get Element Text | ${XML}       | first        |
        | Should Be Equal | ${text}          | text         |              |
        | ${text} =       | Get Element Text | ${XML}       | second/child |
        | Should Be Empty | ${text}          |              |              |
        | ${paragraph} =  | Get Element      | ${XML}       | html/p       |
        | ${text} =       | Get Element Text | ${paragraph} | normalize_whitespace=yes |
        | Should Be Equal | ${text}          | Text with bold and italics. |

        See also `Get Elements Texts`, `Element Text Should Be` and
        `Element Text Should Match`.
        """
        element = self.get_element(source, xpath)
        text = ''.join(self._yield_texts(element))
        if normalize_whitespace:
            text = self._normalize_whitespace(text)
        return text

    def _yield_texts(self, element, top=True):
        if element.text:
            yield element.text
        for child in element:
            for text in self._yield_texts(child, top=False):
                yield text
        if element.tail and not top:
            yield element.tail

    def _normalize_whitespace(self, text):
        return self._whitespace.sub(' ', text.strip())

    def get_elements_texts(self, source, xpath, normalize_whitespace=False):
        """Returns text of all elements matching `xpath` as a list.

        The elements whose text to return is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Elements`
        keyword.

        The text of the matched elements is returned using the same logic
        as with `Get Element Text`. This includes optional whitespace
        normalization using the `normalize_whitespace` option.

        Examples using `${XML}` structure from the `introduction`:
        | @{texts} =       | Get Elements Texts | ${XML}    | third/child |
        | Length Should Be | ${texts}           | 2         |             |
        | Should Be Equal  | @{texts}[0]        | more text |             |
        | Should Be Equal  | @{texts}[1]        | ${EMPTY}  |             |
        """
        return [self.get_element_text(elem, normalize_whitespace=normalize_whitespace)
                for elem in self.get_elements(source, xpath)]

    def element_text_should_be(self, source, expected, xpath='.',
                               normalize_whitespace=False, message=None):
        """Verifies that the text of the specified element is `expected`.

        The element whose text is verified is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        The text to verify is got from the specified element using the same
        logic as with `Get Element Text`. This includes optional whitespace
        normalization using the `normalize_whitespace` option.

        The keyword passes if the text of the element is equal to the
        `expected` value, and otherwise it fails. The default error message can
        be overridden with the `message` argument.  Use `Element Text Should
        Match` to verify the text against a pattern instead of an exact value.

        Examples using `${XML}` structure from the `introduction`:
        | Element Text Should Be | ${XML}       | text     | xpath=first      |
        | Element Text Should Be | ${XML}       | ${EMPTY} | xpath=second/child |
        | ${paragraph} =         | Get Element  | ${XML}   | xpath=html/p     |
        | Element Text Should Be | ${paragraph} | Text with bold and italics. | normalize_whitespace=yes |
        """
        text = self.get_element_text(source, xpath, normalize_whitespace)
        should_be_equal(text, expected, message, values=False)

    def element_text_should_match(self, source, pattern, xpath='.',
                                  normalize_whitespace=False, message=None):
        """Verifies that the text of the specified element matches `expected`.

        This keyword works exactly like `Element Text Should Be` except that
        the expected value can be given as a pattern that the text of the
        element must match.

        Pattern matching is similar as matching files in a shell, and it is
        always case-sensitive. In the pattern, '*' matches anything and '?'
        matches any single character.

        Examples using `${XML}` structure from the `introduction`:
        | Element Text Should Match | ${XML}       | t???   | xpath=first  |
        | ${paragraph} =            | Get Element  | ${XML} | xpath=html/p |
        | Element Text Should Match | ${paragraph} | Text with * and *. | normalize_whitespace=yes |
        """
        text = self.get_element_text(source, xpath, normalize_whitespace)
        should_match(text, pattern, message, values=False)

    def get_element_attribute(self, source, name, xpath='.', default=None):
        """Returns the named attribute of the specified element.

        The element whose attribute to return is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        The value of the attribute `name` of the specified element is returned.
        If the element does not have such element, the `default` value is
        returned instead.

        Examples using `${XML}` structure from the `introduction`:
        | ${attribute} =  | Get Element Attribute | ${XML} | id | xpath=first |
        | Should Be Equal | ${attribute}          | 1      |    |             |
        | ${attribute} =  | Get Element Attribute | ${XML} | xx | xpath=first | default=value |
        | Should Be Equal | ${attribute}          | value  |    |             |

        See also `Get Element Attributes`, `Element Attribute Should Be`,
        `Element Attribute Should Match` and `Element Should Not Have Attribute`.
        """
        return self.get_element(source, xpath).get(name, default)

    def get_element_attributes(self, source, xpath='.'):
        """Returns all attributes of the specified element.

        The element whose attributes to return is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        Attributes are returned as a Python dictionary. It is a copy of the
        original attributes so modifying it has no effect on the XML structure.

        Examples using `${XML}` structure from the `introduction`:
        | ${attributes} = | Get Element Attributes      | ${XML} | first |
        | Dictionary Should Contain Key | ${attributes} | id     |       |
        | ${attributes} = | Get Element Attributes      | ${XML} | third |
        | Should Be Empty | ${attributes}               |        |       |

        Use `Get Element Attribute` to get the value of a single attribute.
        """
        return self.get_element(source, xpath).attrib.copy()

    def element_attribute_should_be(self, source, name, expected, xpath='.',
                                    message=None):
        """Verifies that the specified attribute is `expected`.

        The element whose attribute is verified is specified using `source`
        and `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        The keyword passes if the attribute `name` of the element is equal to
        the `expected` value, and otherwise it fails. The default error message
        can be overridden with the `message` argument.

        To test that the element does not have a certain attribute, Python
        `None` (i.e. variable `${NONE}`) can be used as the `expected` value.
        A cleaner alternative is using `Element Should Not Have Attribute`.

        Examples using `${XML}` structure from the `introduction`:
        | Element Attribute Should Be | ${XML} | id | 1       | xpath=first |
        | Element Attribute Should Be | ${XML} | id | ${NONE} |             |

        See also `Element Attribute Should Match` and `Get Element Attribute`.
        """
        attr = self.get_element_attribute(source, name, xpath)
        should_be_equal(attr, expected, message, values=False)

    def element_attribute_should_match(self, source, name, pattern, xpath='.',
                                       message=None):
        """Verifies that the specified attribute matches `expected`.

        This keyword works exactly like `Element Attribute Should Be` except
        that the expected value can be given as a pattern that the attribute of
        the element must match.

        Pattern matching is similar as matching files in a shell, and it is
        always case-sensitive. In the pattern, '*' matches anything and '?'
        matches any single character.

        Examples using `${XML}` structure from the `introduction`:
        | Element Attribute Should Match | ${XML} | id | ?   | xpath=first |
        | Element Attribute Should Match | ${XML} | id | c*d | xpath=third/second |
        """
        attr = self.get_element_attribute(source, name, xpath)
        if attr is None:
            raise AssertionError("Attribute '%s' does not exist." % name)
        should_match(attr, pattern, message, values=False)

    def element_should_not_have_attribute(self, source, name, xpath='.', message=None):
        """Verifies that the specified element does not have  attribute `name`.

        The element whose attribute is verified is specified using `source`
        and `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        The keyword fails if the specified element has attribute `name`.
        The default error message can be overridden with the `message` argument.

        Examples using `${XML}` structure from the `introduction`:
        | Element Should Not Have Attribute | ${XML} | id  |
        | Element Should Not Have Attribute | ${XML} | xxx | xpath=first |

        See also `Get Element Attribute`, `Get Element Attributes`,
        `Element Text Should Be` and `Element Text Should Match`.

        New in Robot Framework 2.7.5.
        """
        attr = self.get_element_attribute(source, name, xpath)
        if attr is not None:
            raise AssertionError(message or "Attribute '%s' exists and "
                                            "has value '%s'." % (name, attr))

    def elements_should_be_equal(self, source, expected, exclude_children=False,
                                 normalize_whitespace=False):
        """Verifies that the given `source` element is equal to `expected`.

        Both `source` and `expected` can be given as a path to an XML file, as
        a string containing XML, or as an already parsed XML element structure.
        See `introduction` for more information about parsing XML in general.

        The keyword passes if the `source` element and `expected` element
        are equal. This includes testing the tag names, texts, and attributes
        of the elements. By default also child elements are verified the same
        way, but this can be disabled by setting `exclude_children` to any true
        value (e.g. any non-empty string).

        All texts inside the given elements are verified, but possible text
        outside them is not. By default texts must match exactly, but setting
        `normalize_whitespace` to any true value makes text verification
        independent on newlines, tabs, and the amount of spaces. For more
        details about handling text see `Get Element Text` keyword and
        discussion about elements' `text` and `tail` attributes in the
        `introduction`.

        Examples using `${XML}` structure from the `introduction`:
        | ${first} =               | Get Element | ${XML} | first             |
        | Elements Should Be Equal | ${first}    | <first id="1">text</first> |
        | ${p} =                   | Get Element | ${XML} | html/p            |
        | Elements Should Be Equal | ${p} | <p>Text with <b>bold</b> and <i>italics</i>.</p> | normalize_whitespace=yes |
        | Elements Should Be Equal | ${p} | <p>Text with</p> | exclude | normalize |

        The last example may look a bit strange because the `<p>` element only
        has text `Text with`. The reason is that rest of the text inside `<p>`
        actually belongs to the child elements.

        See also `Elements Should Match`.
        """
        self._compare_elements(source, expected, should_be_equal,
                               exclude_children, normalize_whitespace)

    def elements_should_match(self, source, expected, exclude_children=False,
                              normalize_whitespace=False):
        """Verifies that the given `source` element matches `expected`.

        This keyword works exactly like `Elements Should Be Equal` except that
        texts and attribute values in the expected value can be given as
        patterns.

        Pattern matching is similar as matching files in a shell, and it is
        always case-sensitive. In the pattern, '*' matches anything and '?'
        matches any single character.

        Examples using `${XML}` structure from the `introduction`:
        | ${first} =            | Get Element | ${XML} | first          |
        | Elements Should Match | ${first}    | <first id="?">*</first> |

        See `Elements Should Be Equal` for more examples.
        """
        self._compare_elements(source, expected, should_match,
                               exclude_children, normalize_whitespace)

    def _compare_elements(self, source, expected, comparator, exclude_children,
                          normalize_whitespace):
        normalizer = self._normalize_whitespace if normalize_whitespace else None
        comparator = ElementComparator(comparator, normalizer, exclude_children)
        comparator.compare(self.get_element(source), self.get_element(expected))

    def set_element_tag(self, source, tag, xpath='.'):
        """Sets the tag of the specified element to `tag`.

        The element whose tag to set is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword. The given `source` structure  is modified and also returned.

        Examples using `${XML}` structure from `Example`:
        | Set Element Tag      | ${XML}     | newTag     |
        | Should Be Equal      | ${XML.tag} | newTag     |
        | Set Element Tag      | ${XML}     | xxx        | xpath=second/child |
        | Element Should Exist | ${XML}     | second/xxx |
        | Element Should Not Exist | ${XML} | second/child |

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        self.get_element(source, xpath).tag = tag
        return source

    def set_element_text(self, source, text=None, tail=None, xpath='.'):
        """Sets text and/or tail text of the specified element.

        The element whose text to set is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword. The given `source` structure  is modified and also returned.

        Element's text and tail text are changed only if new `text` and/or
        `tail` values are given. See `Element attributes` section for more
        information about text and tail in general.

        Examples using `${XML}` structure from `Example`:
        | Set Element Text       | ${XML} | new text | xpath=first    |
        | Element Text Should Be | ${XML} | new text | xpath=first    |
        | Set Element Text       | ${XML} | tail=&   | xpath=html/p/b |
        | Element Text Should Be | ${XML} | Text with bold&italics. | xpath=html/p  | normalize_whitespace=yes |
        | Set Element Text       | ${XML} | slanted  | !! | xpath=html/p/i |
        | Element Text Should Be | ${XML} | Text with bold&slanted!! | xpath=html/p  | normalize_whitespace=yes |

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        element = self.get_element(source, xpath)
        if text is not None:
            element.text = text
        if tail is not None:
            element.tail = tail
        return source

    def set_element_attribute(self, source, name, value, xpath='.'):
        """Sets attribute `name` of the specified element to `value`

        The element whose attribute to set is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword. The given `source` structure  is modified and also returned.

        It is possible to both set new attributes and to overwrite existing.
        Use `Remove Element Attribute` or `Remove Element Attributes` for
        removing them.

        Examples using `${XML}` structure from `Example`:
        | Set Element Attribute       | ${XML} | attr | value |
        | Element Attribute Should Be | ${XML} | attr | value |
        | Set Element Attribute       | ${XML} | id   | new   | xpath=first |
        | Element Attribute Should Be | ${XML} | id   | new   | xpath=first |

        New in Robot Framework 2.7.5.
        """
        if not name:
            raise RuntimeError('Attribute name can not be empty.')
        source = self.get_element(source)
        self.get_element(source, xpath).attrib[name] = value
        return source

    def remove_element_attribute(self, source, name, xpath='.'):
        """Removes attribute `name` from the specified element.

        The element whose attribute to remove is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword. The given `source` structure  is modified and also returned.

        It is not a failure to remove a non-existing attribute. Use `Remove
        Element Attributes` to remove all attributes and `Set Element Attribute`
        to set them.

        Examples using `${XML}` structure from `Example`:
        | Remove Element Attribute          | ${XML} | id | xpath=first |
        | Element Should Not Have Attribute | ${XML} | id | xpath=first |

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        attrib = self.get_element(source, xpath).attrib
        if name in attrib:
            attrib.pop(name)
        return source

    def remove_element_attributes(self, source, xpath='.'):
        """Removes all attributes from the specified element.

        The element whose attributes to remove is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword. The given `source` structure  is modified and also returned.

        Use `Remove Element Attribute` to remove a single attribute and
        `Set Element Attribute` to set them.

        Examples using `${XML}` structure from `Example`:
        | Remove Element Attributes         | ${XML} | xpath=first |
        | Element Should Not Have Attribute | ${XML} | id | xpath=first |

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        self.get_element(source, xpath).attrib.clear()
        return source

    def add_element(self, source, element, index=None, xpath='.'):
        """Adds a child element to the specified element.

        The element to whom to add the new element is specified using `source`
        and `xpath`. They have exactly the same semantics as with `Get Element`
        keyword. The given `source` structure  is modified and also returned.

        The `element` to add can be specified as a path to an XML file or
        as a string containing XML, or it can be an already parsed XML element.
        The element is copied before adding so modifying either the original
        or the added element has no effect on the other
        .
        The element is added as the last child by default, but a custom index
        can be used to alter the position. Indices start from zero (0 = first
        position, 1 = second position, etc.), and negative numbers refer to
        positions at the end (-1 = second last position, -2 = third last, etc.).

        Examples using `${XML}` structure from `Example`:
        | Add Element | ${XML} | <new id="x"><c1/></new> |
        | Add Element | ${XML} | <c2/> | xpath=new |
        | Add Element | ${XML} | <c3/> | index=1 | xpath=new |
        | ${new} = | Get Element | ${XML} | new |
        | Elements Should Be Equal | ${new} | <new id="x"><c1/><c3/><c2/></new> |

        Use `Remove Element` or `Remove Elements` to remove elements.

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        parent = self.get_element(source, xpath)
        element = self.copy_element(element)
        if index is None:
            parent.append(element)
        else:
            parent.insert(int(index), element)
        return source

    def remove_element(self, source, xpath='', remove_tail=False):
        """Removes the element matching `xpath` from the `source` structure.

        The element to remove from the `source` is specified with `xpath`
        using the same semantics as with `Get Element` keyword. The given
        `source` structure  is modified and also returned.

        The keyword fails if `xpath` does not match exactly one element.
        Use `Remove Elements` to remove all matched elements.

        Element's tail text is not removed by default, but that can be changed
        by giving `remove_tail` a true value (e.g. any non-empty string).
        See `Element attributes` section for more information about tail in
        general.

        Examples using `${XML}` structure from `Example`:
        | Remove Element           | ${XML} | xpath=second |
        | Element Should Not Exist | ${XML} | xpath=second |
        | Remove Element           | ${XML} | xpath=html/p/b | remove_tail=yes |
        | Element Text Should Be   | ${XML} | Text with italics. | xpath=html/p | normalize_whitespace=yes |

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        self._remove_element(source, self.get_element(source, xpath), remove_tail)
        return source

    def remove_elements(self, source, xpath='', remove_tail=False):
        """Removes all elements matching `xpath` from the `source` structure.

        The elements to remove from the `source` are specified with `xpath`
        using the same semantics as with `Get Elements` keyword. The given
        `source` structure  is modified and also returned.

        It is not a failure if `xpath` matches no elements. Use `Remove Element`
        to remove exactly one element and `Add Element` to add new ones.

        Element's tail text is not removed by default, but that can be changed
        by using `remove_tail` argument similarly as with `Remove Element`.

        Examples using `${XML}` structure from `Example`:
        | Remove Elements          | ${XML} | xpath=*/child      |
        | Element Should Not Exist | ${XML} | xpath=second/child |
        | Element Should Not Exist | ${XML} | xpath=third/child  |

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        for element in self.get_elements(source, xpath):
            self._remove_element(source, element, remove_tail)
        return source

    def _remove_element(self, root, element, remove_tail=False):
        parent = self._find_parent(root, element)
        if element.tail and not remove_tail:
            self._preserve_tail(element, parent)
        parent.remove(element)

    def _find_parent(self, root, element):
        for parent in root.getiterator():
            for child in parent:
                if child is element:
                    return parent
        raise RuntimeError('Cannot remove root element.')

    def _preserve_tail(self, element, parent):
        index = list(parent).index(element)
        if index == 0:
            parent.text = (parent.text or '') + element.tail
        else:
            sibling = parent[index-1]
            sibling.tail = (sibling.tail or '') + element.tail

    def clear_element(self, source, xpath='.', clear_tail=False):
        """Clears the contents of the specified element.

        The element to clear is specified using `source` and `xpath`. They
        have exactly the same semantics as with `Get Element` keyword.
        The given `source` structure  is modified and also returned.

        Clearing the element means removing its text, attributes, and children.
        Element's tail text is not removed by default, but that can be changed
        by giving `clear_tail` a true value (e.g. any non-empty string).
        See `Element attributes` section for more information about tail in
        general.

        Examples using `${XML}` structure from `Example`:
        | Clear Element            | ${XML}   | xpath=first |
        | ${first} = | Get Element | ${XML}   | xpath=first |
        | Elements Should Be Equal | ${first} | <first/>    |
        | Clear Element            | ${XML}   | xpath=html/p/b | clear_tail=yes |
        | Element Text Should Be   | ${XML}   | Text with italics. | xpath=html/p | normalize_whitespace=yes |
        | Clear Element            | ${XML}   |
        | Elements Should Be Equal | ${XML}   | <example/> |

        Use `Remove Element` to remove the whole element.

        New in Robot Framework 2.7.5.
        """
        source = self.get_element(source)
        element = self.get_element(source, xpath)
        tail = element.tail
        element.clear()
        if not clear_tail:
            element.tail = tail
        return source

    def copy_element(self, source, xpath='.'):
        """Returns a copy of the specified element.

        The element to copy is specified using `source` and `xpath`. They
        have exactly the same semantics as with `Get Element` keyword.

        If the copy or the original element is modified afterwards, the changes
        have no effect on the other.

        Examples using `${XML}` structure from `Example`:
        | ${elem} =  | Get Element  | ${XML}  | xpath=first |
        | ${copy1} = | Copy Element | ${elem} |
        | ${copy2} = | Copy Element | ${XML}  | xpath=first |
        | Set Element Text         | ${XML}   | new text    | xpath=first      |
        | Set Element Attribute    | ${copy1} | id          | new              |
        | Elements Should Be Equal | ${elem}  | <first id="1">new text</first> |
        | Elements Should Be Equal | ${copy1} | <first id="new">text</first>   |
        | Elements Should Be Equal | ${copy2} | <first id="1">text</first>     |

        New in Robot Framework 2.7.5.
        """
        return copy.deepcopy(self.get_element(source, xpath))

    def element_to_string(self, source, xpath='.'):
        """Returns the string representation of the specified element.

        The element to convert to a string is specified using `source` and
        `xpath`. They have exactly the same semantics as with `Get Element`
        keyword.

        The returned string is in Unicode format and it does not contain any
        XML declaration.

        See also `Log Element` and `Save XML`.
        """
        string = ET.tostring(self.get_element(source, xpath), encoding='UTF-8')
        return self._xml_declaration.sub('', string.decode('UTF-8')).strip()

    def log_element(self, source, level='INFO', xpath='.'):
        """Logs the string representation of the specified element.

        The element specified with `source` and `xpath` is first converted into
        a string using `Element To String` keyword internally. The resulting
        string is then logged using the given `level`.

        The logged string is also returned.
        """
        string = self.element_to_string(source, xpath)
        logger.write(string, level)
        return string

    def save_xml(self, source, path, encoding='UTF-8'):
        """Saves the given element to the specified file.

        The element to save is specified with `source` using the same
        semantics as with `Get Element` keyword.

        The file where the element is saved is denoted with `path` and the
        encoding to use with `encoding`. The resulting file contains an XML
        declaration.

        Use `Element To String` if you just need a string representation of
        the element,

        New in Robot Framework 2.7.5.
        """
        tree = ET.ElementTree(self.get_element(source))
        kwargs = {'xml_declaration': True} if ET.VERSION >= '1.3' else {}
        # Need to explicitly open/close files because older ET versions don't
        # close files they open and Jython/IPY don't close them implicitly.
        with open(path, 'w') as output:
            tree.write(output, encoding, **kwargs)


class ElementComparator(object):

    def __init__(self, comparator, normalizer=None, exclude_children=False):
        self._comparator = comparator
        self._normalizer = normalizer or (lambda text: text)
        self._exclude_children = exclude_children

    def compare(self, actual, expected, location=None):
        if not location:
            location = Location(actual.tag)
        self._compare_tags(actual, expected, location)
        self._compare_attributes(actual, expected, location)
        self._compare_texts(actual, expected, location)
        if location.is_not_root:
            self._compare_tails(actual, expected, location)
        if not self._exclude_children:
            self._compare_children(actual, expected, location)

    def _compare_tags(self, actual, expected, location):
        self._compare(actual.tag, expected.tag, 'Different tag name', location,
                      should_be_equal)

    def _compare(self, actual, expected, message, location, comparator=None):
        if location.is_not_root:
            message = "%s at '%s'" % (message, location.path)
        if not comparator:
            comparator = self._comparator
        comparator(actual, expected, message)

    def _compare_attributes(self, actual, expected, location):
        self._compare(sorted(actual.attrib), sorted(expected.attrib),
                      'Different attribute names', location, should_be_equal)
        for key in actual.attrib:
            self._compare(actual.attrib[key], expected.attrib[key],
                          "Different value for attribute '%s'" % key, location)

    def _compare_texts(self, actual, expected, location):
        self._compare(self._text(actual.text), self._text(expected.text),
                      'Different text', location)

    def _text(self, text):
        return self._normalizer(text or '')

    def _compare_tails(self, actual, expected, location):
        self._compare(self._text(actual.tail), self._text(expected.tail),
                      'Different tail text', location)

    def _compare_children(self, actual, expected, location):
        self._compare(len(actual), len(expected), 'Different number of child elements',
                      location, should_be_equal)
        for act, exp in zip(actual, expected):
            self.compare(act, exp, location.child(act.tag))


class Location(object):

    def __init__(self, path, is_root=True):
        self.path = path
        self.is_not_root = not is_root
        self._children = {}

    def child(self, tag):
        if tag not in self._children:
            self._children[tag] = 1
        else:
            self._children[tag] += 1
            tag += '[%d]' % self._children[tag]
        return Location('%s/%s' % (self.path, tag), is_root=False)

########NEW FILE########
__FILENAME__ = criticality
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from .tags import TagPatterns


class Criticality(object):

    def __init__(self, critical_tags=None, non_critical_tags=None):
        self.critical_tags = TagPatterns(critical_tags)
        self.non_critical_tags = TagPatterns(non_critical_tags)

    def tag_is_critical(self, tag):
        return self.critical_tags.match(tag)

    def tag_is_non_critical(self, tag):
        return self.non_critical_tags.match(tag)

    def test_is_critical(self, test):
        if self.critical_tags and not self.critical_tags.match(test.tags):
            return False
        return not self.non_critical_tags.match(test.tags)

    def __nonzero__(self):
        return bool(self.critical_tags or self.non_critical_tags)

########NEW FILE########
__FILENAME__ = filter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import setter

from .tags import TagPatterns
from .namepatterns import SuiteNamePatterns, TestNamePatterns
from .visitor import SuiteVisitor


class Filter(SuiteVisitor):

    def __init__(self, include_suites=None, include_tests=None,
                 include_tags=None, exclude_tags=None):
        self.include_suites = include_suites
        self.include_tests = include_tests
        self.include_tags = include_tags
        self.exclude_tags = exclude_tags

    @setter
    def include_suites(self, suites):
        return SuiteNamePatterns(suites) \
            if not isinstance(suites, SuiteNamePatterns) else suites

    @setter
    def include_tests(self, tests):
        return TestNamePatterns(tests) \
            if not isinstance(tests, TestNamePatterns) else tests

    @setter
    def include_tags(self, tags):
        return TagPatterns(tags) if not isinstance(tags, TagPatterns) else tags

    @setter
    def exclude_tags(self, tags):
        return TagPatterns(tags) if not isinstance(tags, TagPatterns) else tags

    def start_suite(self, suite):
        if not self:
            return False
        if hasattr(suite, 'starttime'):
            suite.starttime = suite.endtime = None
        if self.include_suites:
            return self._filter_by_suite_name(suite)
        if self.include_tests:
            suite.tests = self._filter(suite, self._included_by_test_name)
        if self.include_tags:
            suite.tests = self._filter(suite, self._included_by_tags)
        if self.exclude_tags:
            suite.tests = self._filter(suite, self._not_excluded_by_tags)
        return bool(suite.suites)

    def _filter_by_suite_name(self, suite):
        if self.include_suites.match(suite.name, suite.longname):
            suite.visit(Filter(include_suites=[],
                               include_tests=self.include_tests,
                               include_tags=self.include_tags,
                               exclude_tags=self.exclude_tags))
            return False
        suite.tests = []
        return True

    def _filter(self, suite, filter):
        return [t for t in suite.tests if filter(t)]

    def _included_by_test_name(self, test):
        return self.include_tests.match(test.name, test.longname)

    def _included_by_tags(self, test):
        return self.include_tags.match(test.tags)

    def _not_excluded_by_tags(self, test):
        return not self.exclude_tags.match(test.tags)

    def end_suite(self, suite):
        suite.suites = [s for s in suite.suites if s.test_count]

    def visit_test(self, test):
        pass

    def visit_keyword(self, keyword):
        pass

    def __nonzero__(self):
        return bool(self.include_suites or self.include_tests or
                    self.include_tags or self.exclude_tags)

########NEW FILE########
__FILENAME__ = itemlist
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class ItemList(object):
    __slots__ = ['_item_class', '_common_attrs', '_items']

    def __init__(self, item_class, common_attrs=None, items=None):
        self._item_class = item_class
        self._common_attrs = common_attrs
        self._items = []
        if items:
            self.extend(items)

    def create(self, *args, **kwargs):
        self.append(self._item_class(*args, **kwargs))
        return self._items[-1]

    def append(self, item):
        self._check_type_and_set_attrs(item)
        self._items.append(item)

    def _check_type_and_set_attrs(self, item):
        if not isinstance(item, self._item_class):
            raise TypeError("Only '%s' objects accepted, got '%s'"
                            % (self._item_class.__name__, type(item).__name__))
        if self._common_attrs:
            for attr in self._common_attrs:
                setattr(item, attr, self._common_attrs[attr])

    def extend(self, items):
        for item in items:
            self._check_type_and_set_attrs(item)
        self._items.extend(items)

    def index(self, item):
        return self._items.index(item)

    def clear(self):
        self._items = []

    def visit(self, visitor):
        for item in self:
            item.visit(visitor)

    def __iter__(self):
        return iter(self._items)

    def __getitem__(self, index):
        if isinstance(index, slice):
            raise ValueError("'%s' object does not support slicing" % type(self).__name__)
        return self._items[index]

    def __len__(self):
        return len(self._items)

    def __unicode__(self):
        return u'[%s]' % ', '.join(unicode(item) for item in self)

    def __str__(self):
        return unicode(self).encode('ASCII', 'replace')

########NEW FILE########
__FILENAME__ = keyword
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import setter

from itemlist import ItemList
from message import Message, Messages
from modelobject import ModelObject


class Keyword(ModelObject):
    __slots__ = ['parent', 'name', 'doc', 'args', 'type', 'timeout']
    KEYWORD_TYPE = 'kw'
    SETUP_TYPE = 'setup'
    TEARDOWN_TYPE = 'teardown'
    FOR_LOOP_TYPE = 'for'
    FOR_ITEM_TYPE = 'foritem'
    message_class = Message

    def __init__(self, name='', doc='', args=None, type='kw', timeout=''):
        self.parent = None
        self.name = name
        self.doc = doc
        self.args = args or []
        self.type = type
        self.timeout = timeout
        self.messages = []
        self.keywords = []

    @setter
    def keywords(self, keywords):
        return Keywords(self.__class__, self, keywords)

    @setter
    def messages(self, messages):
        return Messages(self.message_class, self, messages)

    @property
    def id(self):
        if not self.parent:
            return 'k1'
        return '%s-k%d' % (self.parent.id, self.parent.keywords.index(self)+1)

    def visit(self, visitor):
        visitor.visit_keyword(self)


class Keywords(ItemList):
    __slots__ = []

    def __init__(self, keyword_class=Keyword, parent=None, keywords=None):
        ItemList.__init__(self, keyword_class, {'parent': parent}, keywords)

    @property
    def setup(self):
        return self[0] if (self and self[0].type == 'setup') else None

    @property
    def teardown(self):
        return self[-1] if (self and self[-1].type == 'teardown') else None

    @property
    def all(self):
        return self

    @property
    def normal(self):
        for kw in self:
            if kw.type not in ('setup', 'teardown'):
                yield kw

########NEW FILE########
__FILENAME__ = message
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import html_escape

from .itemlist import ItemList
from .modelobject import ModelObject


class Message(ModelObject):
    __slots__ = ['message', 'level', 'html', 'timestamp', 'parent']

    def __init__(self, message='', level='INFO', html=False, timestamp=None,
                 parent=None):
        self.message = message
        self.level = level
        self.html = html
        self.timestamp = timestamp
        self.parent = parent

    @property
    def html_message(self):
        return self.message if self.html else html_escape(self.message)

    def visit(self, visitor):
        visitor.visit_message(self)

    def __unicode__(self):
        return self.message


class Messages(ItemList):
    __slots__ = []

    def __init__(self, message_class=Message, parent=None, messages=None):
        ItemList.__init__(self, message_class, {'parent': parent}, messages)


########NEW FILE########
__FILENAME__ = metadata
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import NormalizedDict


class Metadata(NormalizedDict):

    def __init__(self, initial=None):
        NormalizedDict.__init__(self, initial, ignore=['_'])

    def __unicode__(self):
        return u'{%s}' % ', '.join('%s: %s' % (k, self[k]) for k in self)

    def __str__(self):
        return unicode(self).encode('ASCII', 'replace')

########NEW FILE########
__FILENAME__ = modelobject
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils.setter import SetterAwareType


class ModelObject(object):
    __slots__ = []
    __metaclass__ = SetterAwareType

    def __unicode__(self):
        return self.name

    def __str__(self):
        return unicode(self).encode('ASCII', 'replace')

########NEW FILE########
__FILENAME__ = namepatterns
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import MultiMatcher


class _NamePatterns(object):

    def __init__(self, patterns=None):
        self._matcher = MultiMatcher(patterns, ignore=['_'])

    def match(self, name, longname=None):
        return self._match(name) or longname and self._match_longname(longname)

    def _match(self, name):
        return self._matcher.match(name)

    def _match_longname(self, name):
        raise NotImplementedError

    def __nonzero__(self):
        return bool(self._matcher)


class SuiteNamePatterns(_NamePatterns):

    def _match_longname(self, name):
        while '.' in name:
            if self._match(name):
                return True
            name = name.split('.', 1)[1]
        return False


class TestNamePatterns(_NamePatterns):

    def _match_longname(self, name):
        return self._match(name)

########NEW FILE########
__FILENAME__ = statistics
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from .totalstatistics import TotalStatisticsBuilder
from .suitestatistics import SuiteStatisticsBuilder
from .tagstatistics import TagStatisticsBuilder
from .visitor import SuiteVisitor


class Statistics(object):

    def __init__(self, suite, suite_stat_level=-1, tag_stat_include=None,
                 tag_stat_exclude=None, tag_stat_combine=None, tag_doc=None,
                 tag_stat_link=None):
        total_builder = TotalStatisticsBuilder()
        suite_builder = SuiteStatisticsBuilder(suite_stat_level)
        tag_builder = TagStatisticsBuilder(suite.criticality, tag_stat_include,
                                           tag_stat_exclude, tag_stat_combine,
                                           tag_doc, tag_stat_link)
        suite.visit(StatisticsBuilder(total_builder, suite_builder, tag_builder))
        self.total = total_builder.stats
        self.suite = suite_builder.stats
        self.tags = tag_builder.stats

    def visit(self, visitor):
        visitor.visit_statistics(self)


class StatisticsBuilder(SuiteVisitor):

    def __init__(self, total_builder, suite_builder, tag_builder):
        self._total_builder = total_builder
        self._suite_builder = suite_builder
        self._tag_builder = tag_builder

    def start_suite(self, suite):
        self._suite_builder.start_suite(suite)

    def end_suite(self, suite):
        self._suite_builder.end_suite()

    def visit_test(self, test):
        self._total_builder.add_test(test)
        self._suite_builder.add_test(test)
        self._tag_builder.add_test(test)

    def visit_keyword(self, kw):
        pass

########NEW FILE########
__FILENAME__ = stats
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import elapsed_time_to_string, html_escape, normalize

from .tags import TagPatterns


class Stat(object):

    def __init__(self, name):
        self.name = name
        self.passed = 0
        self.failed = 0
        self.elapsed = 0
        self._norm_name = normalize(name, ignore='_')

    def get_attributes(self, include_label=False, include_elapsed=False,
                       exclude_empty=False, values_as_strings=False,
                       html_escape=False):
        attrs =  {'pass': self.passed, 'fail': self.failed}
        attrs.update(self._get_custom_attrs())
        if include_label:
            attrs['label'] = self.name
        if include_elapsed:
            attrs['elapsed'] = elapsed_time_to_string(self.elapsed,
                                                      include_millis=False)
        if exclude_empty:
            attrs = dict((k, v) for k, v in attrs.items() if v != '')
        if values_as_strings:
            attrs = dict((k, unicode(v)) for k, v in attrs.items())
        if html_escape:
            attrs = dict((k, self._html_escape(v)) for k, v in attrs.items())
        return attrs

    def _get_custom_attrs(self):
        return {}

    def _html_escape(self, item):
        return html_escape(item) if isinstance(item, basestring) else item

    @property
    def total(self):
        return self.passed + self.failed

    def add_test(self, test):
        self._update_stats(test)
        self._update_elapsed(test)

    def _update_stats(self, test):
        if test.passed:
            self.passed += 1
        else:
            self.failed += 1

    def _update_elapsed(self, test):
        self.elapsed += test.elapsedtime

    def __cmp__(self, other):
        return cmp(self._norm_name, other._norm_name)

    def __nonzero__(self):
        return not self.failed

    def visit(self, visitor):
        visitor.visit_stat(self)


class TotalStat(Stat):
    type = 'total'


class SuiteStat(Stat):
    type = 'suite'

    def __init__(self, suite):
        Stat.__init__(self, suite.longname)
        self.id = suite.id
        self.elapsed = suite.elapsedtime
        self._name = suite.name

    def _get_custom_attrs(self):
        return {'id': self.id, 'name': self._name}

    def _update_elapsed(self, test):
        pass

    def add_stat(self, other):
        self.passed += other.passed
        self.failed += other.failed


class TagStat(Stat):
    type = 'tag'

    def __init__(self, name, doc='', links=None, critical=False,
                 non_critical=False, combined=''):
        Stat.__init__(self, name)
        self.doc = doc
        self.links = links or []
        self.critical = critical
        self.non_critical = non_critical
        self.combined = combined

    @property
    def info(self):
        if self.critical:
            return 'critical'
        if self.non_critical:
            return 'non-critical'
        if self.combined:
            return 'combined'
        return ''

    def _get_custom_attrs(self):
        return {'doc': self.doc, 'links': self._get_links_as_string(),
                'info': self.info, 'combined': self.combined}

    def _get_links_as_string(self):
        return ':::'.join('%s:%s' % (title, url) for url, title in self.links)

    def __cmp__(self, other):
        return cmp(other.critical, self.critical) \
            or cmp(other.non_critical, self.non_critical) \
            or cmp(bool(other.combined), bool(self.combined)) \
            or Stat.__cmp__(self, other)


class CombinedTagStat(TagStat):

    def __init__(self, pattern, name=None, doc='', links=None):
        TagStat.__init__(self, name or pattern, doc, links, combined=pattern)
        self._matcher = TagPatterns(pattern)

    def match(self, tags):
        return self._matcher.match(tags)

########NEW FILE########
__FILENAME__ = suitestatistics
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from .stats import SuiteStat


class SuiteStatistics(object):

    def __init__(self, suite):
        self.stat = SuiteStat(suite)
        self.suites = []

    def visit(self, visitor):
        visitor.visit_suite_statistics(self)

    def __iter__(self):
        yield self.stat
        for child in self.suites:
            for stat in child:
                yield stat


class SuiteStatisticsBuilder(object):

    def __init__(self, suite_stat_level):
        self._suite_stat_level = suite_stat_level
        self._stats_stack = []
        self.stats = None

    @property
    def current(self):
        return self._stats_stack[-1] if self._stats_stack else None

    def start_suite(self, suite):
        self._stats_stack.append(SuiteStatistics(suite))
        if self.stats is None:
            self.stats = self.current

    def add_test(self, test):
        self.current.stat.add_test(test)

    def end_suite(self):
        stats = self._stats_stack.pop()
        if self.current:
            self.current.stat.add_stat(stats.stat)
            if self._is_child_included():
                self.current.suites.append(stats)

    def _is_child_included(self):
        return self._include_all_levels() or self._below_threshold()

    def _include_all_levels(self):
        return self._suite_stat_level == -1

    def _below_threshold(self):
        return len(self._stats_stack) < self._suite_stat_level

########NEW FILE########
__FILENAME__ = tags
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import normalize_tags, setter, Matcher


class Tags(object):

    def __init__(self, tags=None):
        self._tags = tags

    @setter
    def _tags(self, tags):
        if isinstance(tags, basestring):
            tags = [tags]
        return normalize_tags(tags or [])

    def add(self, tags):
        self._tags = list(self) + list(Tags(tags))

    def remove(self, tags):
        tags = TagPatterns(tags)
        self._tags = [t for t in self if not tags.match(t)]

    def match(self, tags):
        return TagPatterns(tags).match(self)

    def __contains__(self, tags):
        return self.match(tags)

    def __len__(self):
        return len(self._tags)

    def __iter__(self):
        return iter(self._tags)

    def __unicode__(self):
        return u'[%s]' % ', '.join(self)

    def __str__(self):
        return unicode(self).encode('UTF-8')


class TagPatterns(object):

    def __init__(self, patterns):
        self._patterns = [TagPattern(p) for p in Tags(patterns)]

    def match(self, tags):
        tags = tags if isinstance(tags, Tags) else Tags(tags)
        return any(p.match(tags) for p in self._patterns)

    def __contains__(self, tag):
        return self.match(tag)

    def __len__(self):
        return len(self._patterns)

    def __iter__(self):
        return iter(self._patterns)

    def __getitem__(self, index):
        return self._patterns[index]


def TagPattern(pattern):
    pattern = pattern.replace('&', 'AND')
    if 'NOT' in pattern:
        return _NotTagPattern(*pattern.split('NOT'))
    if 'AND' in pattern:
        return _AndTagPattern(pattern.split('AND'))
    return _SingleTagPattern(pattern)


class _SingleTagPattern(object):

    def __init__(self, pattern):
        self._matcher = Matcher(pattern, ignore=['_'])

    def match(self, tags):
        return any(self._matcher.match(tag) for tag in tags)

    def __unicode__(self):
        return self._matcher.pattern


class _AndTagPattern(object):

    def __init__(self, patterns):
        self._patterns = [TagPattern(p) for p in patterns]

    def match(self, tags):
        return all(p.match(tags) for p in self._patterns)


class _NotTagPattern(object):

    def __init__(self, must_match, *must_not_match):
        self._must = TagPattern(must_match)
        self._must_not = [TagPattern(m) for m in must_not_match]

    def match(self, tags):
        return self._must.match(tags) \
            and not any(p.match(tags) for p in self._must_not)

########NEW FILE########
__FILENAME__ = tagsetter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from visitor import SuiteVisitor


class TagSetter(SuiteVisitor):

    def __init__(self, add=None, remove=None):
        self.add = add
        self.remove = remove

    def start_suite(self, suite):
        return bool(self)

    def visit_test(self, test):
        test.tags.add(self.add)
        test.tags.remove(self.remove)

    def visit_keyword(self, keyword):
        pass

    def __nonzero__(self):
        return bool(self.add or self.remove)

########NEW FILE########
__FILENAME__ = tagstatistics
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robot.utils import NormalizedDict

from .criticality import Criticality
from .stats import TagStat, CombinedTagStat
from .tags import TagPatterns


class TagStatistics(object):

    def __init__(self, combined_stats):
        self.tags = NormalizedDict(ignore=['_'])
        self.combined = combined_stats

    def visit(self, visitor):
        visitor.visit_tag_statistics(self)

    def __iter__(self):
        return iter(sorted(self.tags.values() + self.combined))


class TagStatisticsBuilder(object):

    def __init__(self, criticality=None, included=None, excluded=None,
                 combined=None, docs=None, links=None):
        self._included = TagPatterns(included)
        self._excluded = TagPatterns(excluded)
        self._info = TagStatInfo(criticality, docs, links)
        self.stats = TagStatistics(self._info.get_combined_stats(combined))

    def add_test(self, test):
        self._add_tags_to_statistics(test)
        self._add_to_combined_statistics(test)

    def _add_tags_to_statistics(self, test):
        for tag in test.tags:
            if self._is_included(tag):
                if tag not in self.stats.tags:
                    self.stats.tags[tag] = self._info.get_stat(tag)
                self.stats.tags[tag].add_test(test)

    def _is_included(self, tag):
        if self._included and not self._included.match(tag):
            return False
        return not self._excluded.match(tag)

    def _add_to_combined_statistics(self, test):
        for comb in self.stats.combined:
            if comb.match(test.tags):
                comb.add_test(test)


class TagStatInfo(object):

    def __init__(self, criticality=None, docs=None, links=None):
        self._criticality = criticality or Criticality()
        self._docs = [TagStatDoc(*doc) for doc in docs or []]
        self._links = [TagStatLink(*link) for link in links or []]

    def get_stat(self, tag):
        return TagStat(tag, self.get_doc(tag), self.get_links(tag),
                       self._criticality.tag_is_critical(tag),
                       self._criticality.tag_is_non_critical(tag))

    def get_combined_stats(self, combined=None):
        return [self.get_combined_stat(*comb) for comb in combined or []]

    def get_combined_stat(self, pattern, name=None):
        name = name or pattern
        return CombinedTagStat(pattern, name, self.get_doc(name),
                               self.get_links(name))

    def get_doc(self, tag):
        return ' & '.join(doc.text for doc in self._docs if doc.match(tag))

    def get_links(self, tag):
        return [link.get_link(tag) for link in self._links if link.match(tag)]


class TagStatDoc(object):

    def __init__(self, pattern, doc):
        self._matcher = TagPatterns(pattern)
        self.text = doc

    def match(self, tag):
        return self._matcher.match(tag)


class TagStatLink(object):
    _match_pattern_tokenizer = re.compile('(\*|\?+)')

    def __init__(self, pattern, link, title):
        self._regexp = self._get_match_regexp(pattern)
        self._link = link
        self._title = title.replace('_', ' ')

    def match(self, tag):
        return self._regexp.match(tag) is not None

    def get_link(self, tag):
        match = self._regexp.match(tag)
        if not match:
            return None
        link, title = self._replace_groups(self._link, self._title, match)
        return link, title

    def _replace_groups(self, link, title, match):
        for index, group in enumerate(match.groups()):
            placefolder = '%%%d' % (index+1)
            link = link.replace(placefolder, group)
            title = title.replace(placefolder, group)
        return link, title

    def _get_match_regexp(self, pattern):
        pattern = '^%s$' % ''.join(self._yield_match_pattern(pattern))
        return re.compile(pattern, re.IGNORECASE)

    def _yield_match_pattern(self, pattern):
        for token in self._match_pattern_tokenizer.split(pattern):
            if token.startswith('?'):
                yield '(%s)' % ('.'*len(token))
            elif token == '*':
                yield '(.*)'
            else:
                yield re.escape(token)

########NEW FILE########
__FILENAME__ = testcase
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import setter

from .itemlist import ItemList
from .keyword import Keyword, Keywords
from .modelobject import ModelObject
from .tags import Tags


class TestCase(ModelObject):
    __slots__ = ['parent', 'name', 'doc', 'timeout']
    keyword_class = Keyword

    def __init__(self, name='', doc='', tags=None, timeout=''):
        self.parent = None
        self.name = name
        self.doc = doc
        self.tags = tags
        self.timeout = timeout
        self.keywords = []

    @setter
    def tags(self, tags):
        return Tags(tags)

    @setter
    def keywords(self, keywords):
        return Keywords(self.keyword_class, self, keywords)

    @property
    def id(self):
        if not self.parent:
            return 't1'
        return '%s-t%d' % (self.parent.id, self.parent.tests.index(self)+1)

    @property
    def longname(self):
        if not self.parent:
            return self.name
        return '%s.%s' % (self.parent.longname, self.name)

    @property
    def critical(self):
        if not self.parent:
            return True
        return self.parent.criticality.test_is_critical(self)

    def visit(self, visitor):
        visitor.visit_test(self)


class TestCases(ItemList):
    __slots__ = []

    def __init__(self, test_class=TestCase, parent=None, tests=None):
        ItemList.__init__(self, test_class, {'parent': parent}, tests)

########NEW FILE########
__FILENAME__ = testsuite
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import setter

from .criticality import Criticality
from .filter import Filter
from .itemlist import ItemList
from .keyword import Keyword, Keywords
from .metadata import Metadata
from .modelobject import ModelObject
from .tagsetter import TagSetter
from .testcase import TestCase, TestCases


class TestSuite(ModelObject):
    __slots__ = ['parent', 'source', '_name', 'doc', '_criticality']
    test_class = TestCase
    keyword_class = Keyword

    def __init__(self, source='', name='', doc='', metadata=None):
        self.parent = None
        self.source = source
        self.name = name
        self.doc = doc
        self.metadata = metadata
        self.suites = []
        self.tests = []
        self.keywords = []
        self._criticality = None

    def _get_name(self):
        return self._name or ' & '.join(s.name for s in self.suites)
    def _set_name(self, name):
        self._name = name
    name = property(_get_name, _set_name)

    def set_criticality(self, critical_tags=None, non_critical_tags=None):
        if self.parent:
            raise TypeError('Criticality can only be set to top level suite')
        self._criticality = Criticality(critical_tags, non_critical_tags)

    @property
    def criticality(self):
        if self.parent:
            return self.parent.criticality
        if self._criticality is None:
            self.set_criticality()
        return self._criticality

    @setter
    def metadata(self, metadata):
        return Metadata(metadata)

    @setter
    def suites(self, suites):
        return TestSuites(self.__class__, self, suites)

    @setter
    def tests(self, tests):
        return TestCases(self.test_class, self, tests)

    @setter
    def keywords(self, keywords):
        return Keywords(self.keyword_class, self, keywords)

    @property
    def id(self):
        if not self.parent:
            return 's1'
        return '%s-s%d' % (self.parent.id, self.parent.suites.index(self)+1)

    @property
    def longname(self):
        if not self.parent:
            return self.name
        return '%s.%s' % (self.parent.longname, self.name)

    @property
    def test_count(self):
        return len(self.tests) + sum(suite.test_count for suite in self.suites)

    def set_tags(self, add=None, remove=None):
        self.visit(TagSetter(add, remove))

    def filter(self, included_suites=None, included_tests=None,
               included_tags=None, excluded_tags=None):
        self.visit(Filter(included_suites, included_tests,
                          included_tags, excluded_tags))

    def visit(self, visitor):
        visitor.visit_suite(self)


class TestSuites(ItemList):
    __slots__ = []

    def __init__(self, suite_class=TestSuite, parent=None, suites=None):
        ItemList.__init__(self, suite_class, {'parent': parent}, suites)

########NEW FILE########
__FILENAME__ = totalstatistics
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from .stats import TotalStat
from .visitor import SuiteVisitor


class TotalStatistics(object):

    def __init__(self):
        self.critical = TotalStat('Critical Tests')
        self.all = TotalStat('All Tests')

    def visit(self, visitor):
        visitor.visit_total_statistics(self)

    def __iter__(self):
        return iter([self.critical, self.all])

    @property
    def message(self):
        ctotal, cend, cpass, cfail = self._get_counts(self.critical)
        atotal, aend, apass, afail = self._get_counts(self.all)
        return ('%d critical test%s, %d passed, %d failed\n'
                '%d test%s total, %d passed, %d failed'
                % (ctotal, cend, cpass, cfail, atotal, aend, apass, afail))

    def _get_counts(self, stat):
        ending = 's' if stat.total != 1 else ''
        return stat.total, ending, stat.passed, stat.failed


class TotalStatisticsBuilder(SuiteVisitor):

    def __init__(self, suite=None):
        self.stats = TotalStatistics()
        if suite:
            suite.visit(self)

    def add_test(self, test):
        self.stats.all.add_test(test)
        if test.critical:
            self.stats.critical.add_test(test)

    def visit_test(self, test):
        self.add_test(test)

    def visit_keyword(self, kw):
        pass

########NEW FILE########
__FILENAME__ = visitor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

class SuiteVisitor(object):

    def visit_suite(self, suite):
        if self.start_suite(suite) is not False:
            suite.keywords.visit(self)
            suite.suites.visit(self)
            suite.tests.visit(self)
            self.end_suite(suite)

    def start_suite(self, suite):
        pass

    def end_suite(self, suite):
        pass

    def visit_test(self, test):
        if self.start_test(test) is not False:
            test.keywords.visit(self)
            self.end_test(test)

    def start_test(self, test):
        pass

    def end_test(self, test):
        pass

    def visit_keyword(self, kw):
        if self.start_keyword(kw) is not False:
            kw.keywords.visit(self)
            kw.messages.visit(self)
            self.end_keyword(kw)

    def start_keyword(self, keyword):
        pass

    def end_keyword(self, keyword):
        pass

    def visit_message(self, msg):
        if self.start_message(msg) is not False:
            self.end_message(msg)

    def start_message(self, msg):
        pass

    def end_message(self, msg):
        pass


class SkipAllVisitor(SuiteVisitor):

    def visit_suite(self, suite):
        pass

    def visit_keyword(self, kw):
        pass

    def visit_test(self, test):
        pass

    def visit_message(self, msg):
        pass

########NEW FILE########
__FILENAME__ = debugfile
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import utils

from .logger import LOGGER
from .loggerhelper import IsLogged


def DebugFile(path):
    if path == 'NONE':
        LOGGER.info('No debug file')
        return None
    try:
        outfile = open(path, 'w')
    except EnvironmentError, err:
        LOGGER.error("Opening debug file '%s' failed: %s" % (path, err.strerror))
        return None
    else:
        LOGGER.info('Debug file: %s' % path)
        return _DebugFileWriter(outfile)


class _DebugFileWriter:
    _separators = {'SUITE': '=', 'TEST': '-', 'KW': '~'}
    _setup_or_teardown = ('setup', 'teardown')

    def __init__(self, outfile):
        self._indent = 0
        self._kw_level = 0
        self._separator_written_last = False
        self._outfile = outfile
        self._is_logged = IsLogged('DEBUG')

    def start_suite(self, suite):
        self._separator('SUITE')
        self._start('SUITE', suite.longname)
        self._separator('SUITE')

    def end_suite(self, suite):
        self._separator('SUITE')
        self._end('SUITE', suite.longname, suite.elapsedtime)
        self._separator('SUITE')
        if self._indent == 0:
            LOGGER.output_file('Debug', self._outfile.name)
            self.close()

    def start_test(self, test):
        self._separator('TEST')
        self._start('TEST', test.name)
        self._separator('TEST')

    def end_test(self, test):
        self._separator('TEST')
        self._end('TEST', test.name, test.elapsedtime)
        self._separator('TEST')

    def start_keyword(self, kw):
        if self._kw_level == 0:
            self._separator('KW')
        self._start(self._get_kw_type(kw), kw.name, kw.args)
        self._kw_level += 1

    def end_keyword(self, kw):
        self._end(self._get_kw_type(kw), kw.name, kw.elapsedtime)
        self._kw_level -= 1

    def log_message(self, msg):
        if self._is_logged(msg.level):
            self._write(msg.message)

    def close(self):
        if not self._outfile.closed:
            self._outfile.close()

    def _get_kw_type(self, kw):
        if kw.type in self._setup_or_teardown:
            return kw.type.upper()
        return 'KW'

    def _start(self, type_, name, args=''):
        args = ' ' + utils.seq2str2(args)
        self._write('+%s START %s: %s%s' % ('-'*self._indent, type_, name, args))
        self._indent += 1

    def _end(self, type_, name, elapsed):
        self._indent -= 1
        self._write('+%s END %s: %s (%s)' % ('-'*self._indent, type_, name, elapsed))

    def _separator(self, type_):
        self._write(self._separators[type_] * 78, separator=True)

    def _write(self, text, separator=False):
        if not (separator and self._separator_written_last):
            self._outfile.write(text.encode('UTF-8').rstrip() + '\n')
            self._outfile.flush()
            self._separator_written_last = separator

########NEW FILE########
__FILENAME__ = filelogger
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError

from .loggerhelper import AbstractLogger


class FileLogger(AbstractLogger):

    def __init__(self, path, level):
        AbstractLogger.__init__(self, level)
        self._writer = self._get_writer(path)  # unit test hook

    def _get_writer(self, path):
        try:
            return open(path, 'w')
        except EnvironmentError, err:
            raise DataError(err.strerror)

    def message(self, msg):
        if self._is_logged(msg.level) and not self._writer.closed:
            entry = '%s | %s | %s\n' % (msg.timestamp, msg.level.ljust(5),
                                        msg.message)
            self._writer.write(entry.encode('UTF-8'))

    def start_suite(self, suite):
        self.info("Started test suite '%s'" % suite.name)

    def end_suite(self, suite):
        self.info("Ended test suite '%s'" % suite.name)

    def start_test(self, test):
        self.info("Started test case '%s'" % test.name)

    def end_test(self, test):
        self.info("Ended test case '%s'" % test.name)

    def start_keyword(self, kw):
        self.debug(lambda: "Started keyword '%s'" % kw.name)

    def end_keyword(self, kw):
        self.debug(lambda: "Ended keyword '%s'" % kw.name)

    def output_file(self, name, path):
        self.info('%s: %s' % (name, path))

    def close(self):
        self._writer.close()

########NEW FILE########
__FILENAME__ = highlighting
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Windows highlighting code adapted from color_console.py. It is copyright
# Andre Burgaud, licensed under the MIT License, and available here:
# http://www.burgaud.com/bring-colors-to-the-windows-console-with-python/

import os
import sys
try:
    from ctypes import windll, Structure, c_short, c_ushort, byref
except ImportError:  # Not on Windows or using Jython
    windll = None


def Highlighter(stream):
    if os.sep == '/':
        return AnsiHighlighter(stream)
    return DosHighlighter(stream) if windll else NoHighlighting(stream)


class AnsiHighlighter(object):
    _ANSI_GREEN  = '\033[32m'
    _ANSI_RED = '\033[31m'
    _ANSI_YELLOW = '\033[33m'
    _ANSI_RESET = '\033[0m'

    def __init__(self, stream):
        self._stream = stream

    def green(self):
        self._set_color(self._ANSI_GREEN)

    def red(self):
        self._set_color(self._ANSI_RED)

    def yellow(self):
        self._set_color(self._ANSI_YELLOW)

    def reset(self):
        self._set_color(self._ANSI_RESET)

    def _set_color(self, color):
        self._stream.write(color)


class NoHighlighting(AnsiHighlighter):

    def _set_color(self, color):
        pass


class DosHighlighter(object):
    _FOREGROUND_GREEN = 0x2
    _FOREGROUND_RED = 0x4
    _FOREGROUND_YELLOW = 0x6
    _FOREGROUND_GREY = 0x7
    _FOREGROUND_INTENSITY = 0x8
    _BACKGROUND_MASK = 0xF0
    _STDOUT_HANDLE = -11
    _STDERR_HANDLE = -12

    def __init__(self, stream):
        self._handle = self._get_std_handle(stream)
        self._orig_colors = self._get_colors()
        self._background = self._orig_colors & self._BACKGROUND_MASK

    def green(self):
        self._set_foreground_colors(self._FOREGROUND_GREEN)

    def red(self):
        self._set_foreground_colors(self._FOREGROUND_RED)

    def yellow(self):
        self._set_foreground_colors(self._FOREGROUND_YELLOW)

    def reset(self):
        self._set_colors(self._orig_colors)

    def _get_std_handle(self, stream):
        handle = self._STDOUT_HANDLE \
            if stream is sys.__stdout__ else self._STDERR_HANDLE
        return windll.kernel32.GetStdHandle(handle)

    def _get_colors(self):
        csbi = _CONSOLE_SCREEN_BUFFER_INFO()
        ok = windll.kernel32.GetConsoleScreenBufferInfo(self._handle, byref(csbi))
        if not ok:  # Call failed, return default console colors (gray on black)
            return self._FOREGROUND_GREY
        return csbi.wAttributes

    def _set_foreground_colors(self, colors):
        self._set_colors(colors | self._FOREGROUND_INTENSITY | self._background)

    def _set_colors(self, colors):
        windll.kernel32.SetConsoleTextAttribute(self._handle, colors)


if windll:

    class _COORD(Structure):
        _fields_ = [("X", c_short),
                    ("Y", c_short)]

    class _SMALL_RECT(Structure):
        _fields_ = [("Left", c_short),
                    ("Top", c_short),
                    ("Right", c_short),
                    ("Bottom", c_short)]

    class _CONSOLE_SCREEN_BUFFER_INFO(Structure):
        _fields_ = [("dwSize", _COORD),
                    ("dwCursorPosition", _COORD),
                    ("wAttributes", c_ushort),
                    ("srWindow", _SMALL_RECT),
                    ("dwMaximumWindowSize", _COORD)]

########NEW FILE########
__FILENAME__ = listeners
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import inspect
import os.path

from robot import utils
from robot.errors import DataError

from .loggerhelper import AbstractLoggerProxy
from .logger import LOGGER

if utils.is_jython:
    from java.lang import Object
    from java.util import HashMap


class _RecursionAvoidingMetaclass(type):
    """Metaclass to wrap listener methods so that they cannot cause recursion.

    Recursion would otherwise happen if one listener logs something and that
    message is received and logged again by log_message or message method.
    """

    def __new__(cls, name, bases, dct):
        for attr, value in dct.items():
            if not attr.startswith('_') and inspect.isroutine(value):
                dct[attr] = cls._wrap_listener_method(value)
        dct['_calling_method'] = False
        return type.__new__(cls, name, bases, dct)

    @staticmethod
    def _wrap_listener_method(method):
        def wrapped(self, *args):
            if not self._calling_method:
                self._calling_method = True
                method(self, *args)
                self._calling_method = False
        return wrapped


class Listeners(object):
    __metaclass__ = _RecursionAvoidingMetaclass
    _start_attrs = ['doc', 'starttime', 'longname']
    _end_attrs = _start_attrs + ['endtime', 'elapsedtime', 'status', 'message']

    def __init__(self, listeners):
        self._listeners = self._import_listeners(listeners)
        self._running_test = False
        self._setup_or_teardown_type = None

    def __nonzero__(self):
        return bool(self._listeners)

    def _import_listeners(self, listener_data):
        listeners = []
        for name, args in listener_data:
            try:
                listeners.append(_ListenerProxy(name, args))
            except DataError, err:
                if args:
                    name += ':' + ':'.join(args)
                LOGGER.error("Taking listener '%s' into use failed: %s"
                             % (name, unicode(err)))
        return listeners

    def start_suite(self, suite):
        for li in self._listeners:
            if li.version == 1:
                li.call_method(li.start_suite, suite.name, suite.doc)
            else:
                attrs = self._get_start_attrs(suite, 'metadata')
                attrs.update({'tests' : [t.name for t in suite.tests],
                              'suites': [s.name for s in suite.suites],
                              'totaltests': suite.get_test_count(),
                              'source': suite.source or ''})
                li.call_method(li.start_suite, suite.name, attrs)

    def end_suite(self, suite):
        for li in self._listeners:
            if li.version == 1:
                li.call_method(li.end_suite, suite.status,
                               suite.get_full_message())
            else:
                attrs = self._get_end_attrs(suite, 'metadata')
                attrs.update({'statistics': suite.get_stat_message(),
                              'source': suite.source or ''})
                li.call_method(li.end_suite, suite.name, attrs)

    def start_test(self, test):
        self._running_test = True
        for li in self._listeners:
            if li.version == 1:
                li.call_method(li.start_test, test.name, test.doc, test.tags)
            else:
                attrs = self._get_start_attrs(test, 'tags')
                attrs['critical'] = 'yes' if test.critical else 'no'
                attrs['template'] = test.template or ''
                li.call_method(li.start_test, test.name, attrs)

    def end_test(self, test):
        self._running_test = False
        for li in self._listeners:
            if li.version == 1:
                li.call_method(li.end_test, test.status, test.message)
            else:
                attrs = self._get_end_attrs(test, 'tags')
                attrs['critical'] = 'yes' if test.critical else 'no'
                attrs['template'] = test.template or ''
                li.call_method(li.end_test, test.name, attrs)

    def start_keyword(self, kw):
        for li in self._listeners:
            if li.version == 1:
                li.call_method(li.start_keyword, kw.name, kw.args)
            else:
                attrs = self._get_start_attrs(kw, 'args', '-longname')
                attrs['type'] = self._get_keyword_type(kw, start=True)
                li.call_method(li.start_keyword, kw.name, attrs)

    def end_keyword(self, kw):
        for li in self._listeners:
            if li.version == 1:
                li.call_method(li.end_keyword, kw.status)
            else:
                attrs = self._get_end_attrs(kw, 'args', '-longname', '-message')
                attrs['type'] = self._get_keyword_type(kw, start=False)
                li.call_method(li.end_keyword, kw.name, attrs)

    def _get_keyword_type(self, kw, start=True):
        # When running setup or teardown, only the top level keyword has type
        # set to setup/teardown but we want to pass that type also to all
        # start/end_keyword listener methods called below that keyword.
        if kw.type == 'kw':
            return self._setup_or_teardown_type or 'Keyword'
        kw_type = self._get_setup_or_teardown_type(kw)
        self._setup_or_teardown_type = kw_type if start else None
        return kw_type

    def _get_setup_or_teardown_type(self, kw):
        return '%s %s' % (('Test' if self._running_test else 'Suite'),
                          kw.type.title())

    def log_message(self, msg):
        for li in self._listeners:
            if li.version == 2:
                li.call_method(li.log_message, self._create_msg_dict(msg))

    def message(self, msg):
        for li in self._listeners:
            if li.version == 2:
                li.call_method(li.message, self._create_msg_dict(msg))

    def _create_msg_dict(self, msg):
        return {'timestamp': msg.timestamp, 'message': msg.message,
                'level': msg.level, 'html': 'yes' if msg.html else 'no'}

    def output_file(self, name, path):
        for li in self._listeners:
            li.call_method(getattr(li, '%s_file' % name.lower()), path)

    def close(self):
        for li in self._listeners:
            li.call_method(li.close)

    def _get_start_attrs(self, item, *names):
        return self._get_attrs(item, self._start_attrs, names)

    def _get_end_attrs(self, item, *names):
        return self._get_attrs(item, self._end_attrs, names)

    def _get_attrs(self, item, defaults, extras):
        names = self._get_attr_names(defaults, extras)
        return dict((n, self._get_attr_value(item, n)) for n in names)

    def _get_attr_names(self, defaults, extras):
        names = list(defaults)
        for name in extras:
            if name.startswith('-'):
                names.remove(name[1:])
            else:
                names.append(name)
        return names

    def _get_attr_value(self, item, name):
        value = getattr(item, name)
        return self._take_copy_of_mutable_value(value)

    def _take_copy_of_mutable_value(self, value):
        if isinstance(value, (dict, utils.NormalizedDict)):
            return dict(value)
        if isinstance(value, list):
            return list(value)
        return value


class _ListenerProxy(AbstractLoggerProxy):
    _methods = ['start_suite', 'end_suite', 'start_test', 'end_test',
                'start_keyword', 'end_keyword', 'log_message', 'message',
                'output_file', 'report_file', 'log_file', 'debug_file',
                'xunit_file', 'close']

    def __init__(self, name, args):
        listener = self._import_listener(name, args)
        AbstractLoggerProxy.__init__(self, listener)
        self.name = name
        self.version = self._get_version(listener)
        self.is_java = utils.is_jython and isinstance(listener, Object)

    def _import_listener(self, name, args):
        importer = utils.Importer('listener')
        return importer.import_class_or_module(os.path.normpath(name),
                                               instantiate_with_args=args)

    def _get_version(self, listener):
        try:
            return int(getattr(listener, 'ROBOT_LISTENER_API_VERSION', 1))
        except ValueError:
            return 1

    def call_method(self, method, *args):
        if self.is_java:
            args = [self._to_map(a) if isinstance(a, dict) else a for a in args]
        try:
            method(*args)
        except:
            message, details = utils.get_error_details()
            LOGGER.error("Calling listener method '%s' of listener '%s' failed: %s"
                     % (method.__name__, self.name, message))
            LOGGER.info("Details:\n%s" % details)

    def _to_map(self, dictionary):
        map = HashMap()
        for key, value in dictionary.iteritems():
            map.put(key, value)
        return map

########NEW FILE########
__FILENAME__ = logger
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot.errors import DataError

from .filelogger import FileLogger
from .loggerhelper import AbstractLogger, AbstractLoggerProxy
from .monitor import CommandLineMonitor
from .stdoutlogsplitter import StdoutLogSplitter


class Logger(AbstractLogger):
    """A global logger proxy to which new loggers may be registered.

    Whenever something is written to LOGGER in code, all registered loggers are
    notified.  Messages are also cached and cached messages written to new
    loggers when they are registered.

    Tools using Robot Framework's internal modules should register their own
    loggers at least to get notifications about errors and warnings. A shortcut
    to get errors/warnings into console is using 'register_console_logger'.
    """

    def __init__(self):
        self._loggers = LoggerCollection()
        self._message_cache = []
        self._register_console_logger()
        self._console_logger_disabled = False
        self._started_keywords = 0

    def disable_message_cache(self):
        self._message_cache = None

    def disable_automatic_console_logger(self):
        if not self._console_logger_disabled:
            self._console_logger_disabled = True
            return self._loggers.remove_first_regular_logger()

    def register_logger(self, *loggers):
        for log in loggers:
            logger = self._loggers.register_regular_logger(log)
            self._relay_cached_messages_to(logger)

    def register_context_changing_logger(self, logger):
        log = self._loggers.register_context_changing_logger(logger)
        self._relay_cached_messages_to(log)

    def _relay_cached_messages_to(self, logger):
        if self._message_cache:
            for msg in self._message_cache[:]:
                logger.message(msg)

    def unregister_logger(self, *loggers):
        for log in loggers:
            self._loggers.unregister_logger(log)

    def register_console_logger(self, width=78, colors='AUTO', markers='AUTO',
                                stdout=None, stderr=None):
        self.disable_automatic_console_logger()
        self._register_console_logger(width, colors, markers, stdout, stderr)

    def _register_console_logger(self, width=78, colors='AUTO', markers='AUTO',
                                 stdout=None, stderr=None):
        monitor = CommandLineMonitor(width, colors, markers, stdout, stderr)
        self._loggers.register_regular_logger(monitor)

    def register_file_logger(self, path=None, level='INFO'):
        if not path:
            path = os.environ.get('ROBOT_SYSLOG_FILE', 'NONE')
            level = os.environ.get('ROBOT_SYSLOG_LEVEL', level)
        if path.upper() == 'NONE':
            return
        try:
            logger = FileLogger(path, level)
        except DataError, err:
            self.error("Opening syslog file '%s' failed: %s" % (path, unicode(err)))
        else:
            self.register_logger(logger)

    def message(self, msg):
        """Messages about what the framework is doing, warnings, errors, ..."""
        for logger in self._loggers.all_loggers():
            logger.message(msg)
        if self._message_cache is not None:
            self._message_cache.append(msg)

    def _log_message(self, msg):
        """Log messages written (mainly) by libraries"""
        for logger in self._loggers.all_loggers():
            logger.log_message(msg)
        if msg.level == 'WARN':
            self.message(msg)

    log_message = message

    def log_output(self, output):
        for msg in StdoutLogSplitter(output):
            self.log_message(msg)

    def enable_library_import_logging(self):
        self._prev_log_message = self.log_message
        self.log_message = self.message

    def disable_library_import_logging(self):
        self.log_message = self._prev_log_message

    def output_file(self, name, path):
        """Finished output, report, log, debug, or xunit file"""
        for logger in self._loggers.all_loggers():
            logger.output_file(name, path)

    def close(self):
        for logger in self._loggers.all_loggers():
            logger.close()
        self._loggers = LoggerCollection()
        self._message_cache = []

    def start_suite(self, suite):
        for logger in self._loggers.starting_loggers():
            logger.start_suite(suite)

    def end_suite(self, suite):
        for logger in self._loggers.ending_loggers():
            logger.end_suite(suite)

    def start_test(self, test):
        for logger in self._loggers.starting_loggers():
            logger.start_test(test)

    def end_test(self, test):
        for logger in self._loggers.ending_loggers():
            logger.end_test(test)

    def start_keyword(self, keyword):
        self._started_keywords += 1
        self.log_message = self._log_message
        for logger in self._loggers.starting_loggers():
            logger.start_keyword(keyword)

    def end_keyword(self, keyword):
        self._started_keywords -= 1
        for logger in self._loggers.ending_loggers():
            logger.end_keyword(keyword)
        if not self._started_keywords:
            self.log_message = self.message

    def __iter__(self):
        return iter(self._loggers)


class LoggerCollection(object):

    def __init__(self):
        self._regular_loggers = []
        self._context_changing_loggers = []

    def register_regular_logger(self, logger):
        self._regular_loggers.append(_LoggerProxy(logger))
        return self._regular_loggers[-1]

    def register_context_changing_logger(self, logger):
        self._context_changing_loggers.append(_LoggerProxy(logger))
        return self._context_changing_loggers[-1]

    def remove_first_regular_logger(self):
        return self._regular_loggers.pop(0)

    def unregister_logger(self, logger):
        self._regular_loggers = [proxy for proxy in self._regular_loggers
                                 if proxy.logger is not logger]
        self._context_changing_loggers = [proxy for proxy
                                          in self._context_changing_loggers
                                          if proxy.logger is not logger]

    def starting_loggers(self):
        return self.all_loggers()

    def ending_loggers(self):
        return self._regular_loggers + self._context_changing_loggers

    def all_loggers(self):
        return self._context_changing_loggers + self._regular_loggers

    def __iter__(self):
        return iter(self.all_loggers())


class _LoggerProxy(AbstractLoggerProxy):
    _methods = ['message', 'log_message', 'output_file', 'close',
                'start_suite', 'end_suite', 'start_test', 'end_test',
                'start_keyword', 'end_keyword']


LOGGER = Logger()

########NEW FILE########
__FILENAME__ = loggerhelper
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import utils
from robot.errors import DataError
from robot.model import Message as BaseMessage


LEVELS = {
  'NONE'  : 6,
  'ERROR' : 5,
  'FAIL'  : 4,
  'WARN'  : 3,
  'INFO'  : 2,
  'DEBUG' : 1,
  'TRACE' : 0,
}


class AbstractLogger:

    def __init__(self, level='TRACE'):
        self._is_logged = IsLogged(level)

    def set_level(self, level):
        return self._is_logged.set_level(level)

    def trace(self, msg):
        self.write(msg, 'TRACE')

    def debug(self, msg):
        self.write(msg, 'DEBUG')

    def info(self, msg):
        self.write(msg, 'INFO')

    def warn(self, msg):
        self.write(msg, 'WARN')

    def fail(self, msg):
        self.write(msg, 'FAIL')

    def error(self, msg):
        self.write(msg, 'ERROR')

    def write(self, message, level, html=False):
        self.message(Message(message, level, html))

    def message(self, msg):
        raise NotImplementedError(self.__class__)


class Message(BaseMessage):
    __slots__ = ['_message']

    def __init__(self, message, level='INFO', html=False, timestamp=None):
        message = self._normalize_message(message)
        level, html = self._get_level_and_html(level, html)
        timestamp = timestamp or utils.get_timestamp()
        BaseMessage.__init__(self, message, level, html, timestamp)

    def _normalize_message(self, msg):
        if callable(msg):
            return msg
        if not isinstance(msg, unicode):
            msg = utils.unic(msg)
        if '\r\n' in msg:
            msg = msg.replace('\r\n', '\n')
        return msg

    def _get_level_and_html(self, level, html):
        level = level.upper()
        if level == 'HTML':
            return 'INFO', True
        if level not in LEVELS:
            raise DataError("Invalid log level '%s'" % level)
        return level, html

    def _get_message(self):
        if callable(self._message):
            self._message = self._message()
        return self._message

    def _set_message(self, message):
        self._message = message

    message = property(_get_message, _set_message)


class IsLogged:

    def __init__(self, level):
        self._str_level = level
        self._int_level = self._level_to_int(level)

    def __call__(self, level):
        return self._level_to_int(level) >= self._int_level

    def set_level(self, level):
        old = self._str_level.upper()
        self.__init__(level)
        return old

    def _level_to_int(self, level):
        try:
            return LEVELS[level.upper()]
        except KeyError:
            raise DataError("Invalid log level '%s'" % level)


class AbstractLoggerProxy:
    _methods = NotImplemented
    _no_method = lambda *args: None

    def __init__(self, logger):
        self.logger = logger
        for name in self._methods:
            setattr(self, name, self._get_method(logger, name))

    def _get_method(self, logger, name):
        if hasattr(logger, name):
            return getattr(logger, name)
        return getattr(logger, self._toCamelCase(name), self._no_method)

    def _toCamelCase(self, name):
        parts = name.split('_')
        return ''.join([parts[0]] + [part.capitalize() for part in parts[1:]])

########NEW FILE########
__FILENAME__ = monitor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys

from robot import utils

from .highlighting import AnsiHighlighter, Highlighter, NoHighlighting
from .loggerhelper import IsLogged


class CommandLineMonitor(object):

    def __init__(self, width=78, colors='AUTO', markers='AUTO', stdout=None,
                 stderr=None):
        self._writer = CommandLineWriter(width, colors, markers, stdout, stderr)
        self._is_logged = IsLogged('WARN')
        self._started = False
        self._started_keywords = 0
        self._running_test = False

    def start_suite(self, suite):
        if not self._started:
            self._writer.suite_separator()
            self._started = True
        self._writer.info(suite.longname, suite.doc, start_suite=True)
        self._writer.suite_separator()

    def end_suite(self, suite):
        self._writer.info(suite.longname, suite.doc)
        self._writer.status(suite.status)
        self._writer.message(suite.get_full_message())
        self._writer.suite_separator()

    def start_test(self, test):
        self._writer.info(test.name, test.doc)
        self._running_test = True

    def end_test(self, test):
        self._writer.status(test.status, clear=True)
        self._writer.message(test.message)
        self._writer.test_separator()
        self._running_test = False

    def start_keyword(self, kw):
        self._started_keywords += 1

    def end_keyword(self, kw):
        self._started_keywords -= 1
        if self._running_test and not self._started_keywords:
            self._writer.keyword_marker(kw)

    def message(self, msg):
        if self._is_logged(msg.level):
            self._writer.error(msg.message, msg.level, clear=self._running_test)

    def output_file(self, name, path):
        self._writer.output(name, path)


class CommandLineWriter(object):
    _status_length = len('| PASS |')

    def __init__(self, width=78, colors='AUTO', markers='AUTO', stdout=None,
                 stderr=None):
        self._width = width
        self._stdout = stdout or sys.__stdout__
        self._stderr = stderr or sys.__stderr__
        self._highlighter = StatusHighlighter(colors, self._stdout, self._stderr)
        self._keyword_marker = KeywordMarker(markers, self._stdout, self._highlighter)
        self._last_info = None

    def info(self, name, doc, start_suite=False):
        width, separator = self._get_info_width_and_separator(start_suite)
        self._last_info = self._get_info(name, doc, width) + separator
        self._write(self._last_info, newline=False)
        self._keyword_marker.reset_count()

    def _get_info_width_and_separator(self, start_suite):
        if start_suite:
            return self._width, '\n'
        return self._width - self._status_length - 1, ' '

    def _get_info(self, name, doc, width):
        if utils.get_console_length(name) > width:
            return utils.pad_console_length(name, width)
        info = name if not doc else '%s :: %s' % (name, doc.splitlines()[0])
        return utils.pad_console_length(info, width)

    def suite_separator(self):
        self._fill('=')

    def test_separator(self):
        self._fill('-')

    def _fill(self, char):
        self._write(char * self._width)

    def status(self, status, clear=False):
        if self._should_clear_markers(clear):
            self._clear_status()
        self._highlight('| ', status, ' |')

    def _should_clear_markers(self, clear):
        return clear and self._keyword_marker.marking_enabled

    def _clear_status(self):
        self._clear_info_line()
        self._rewrite_info()

    def _clear_info_line(self):
        self._write('\r' + ' ' * self._width + '\r', newline=False)
        self._keyword_marker.reset_count()

    def _rewrite_info(self):
        self._write(self._last_info, newline=False)

    def message(self, message):
        if message:
            self._write(message.strip())

    def keyword_marker(self, kw):
        if self._keyword_marker.marker_count == self._status_length:
            self._clear_status()
            self._keyword_marker.reset_count()
        self._keyword_marker.mark(kw)

    def error(self, message, level, clear=False):
        if self._should_clear_markers(clear):
            self._clear_info_line()
        self._highlight('[ ', level, ' ] ' + message, error=True)
        if self._should_clear_markers(clear):
            self._rewrite_info()

    def output(self, name, path):
        self._write('%-8s %s' % (name+':', path))

    def _write(self, text, newline=True, error=False):
        stream = self._stdout if not error else self._stderr
        if newline:
            text += '\n'
        stream.write(utils.encode_output(text))
        stream.flush()

    def _highlight(self, before, status, after, newline=True, error=False):
        stream = self._stdout if not error else self._stderr
        self._write(before, newline=False, error=error)
        self._highlighter.highlight_status(status, stream)
        self._write(after, newline=newline, error=error)


class StatusHighlighter(object):

    def __init__(self, colors, *streams):
        self._highlighters = dict((stream, self._get_highlighter(stream, colors))
                                  for stream in streams)

    def _get_highlighter(self, stream, colors):
        auto = Highlighter if utils.isatty(stream) else NoHighlighting
        highlighter = {'AUTO': auto,
                       'ON': Highlighter,
                       'FORCE': Highlighter,   # compatibility with 2.5.5 and earlier
                       'OFF': NoHighlighting,
                       'ANSI': AnsiHighlighter}.get(colors.upper(), auto)
        return highlighter(stream)

    def highlight_status(self, status, stream):
        highlighter = self._start_status_highlighting(status, stream)
        stream.write(status)
        highlighter.reset()

    def _start_status_highlighting(self, status, stream):
        highlighter = self._highlighters[stream]
        {'PASS': highlighter.green,
         'FAIL': highlighter.red,
         'ERROR': highlighter.red,
         'WARN': highlighter.yellow}[status]()
        return highlighter

    def highlight(self, text, color, stream):
        highlighter = self._highlighters[stream]
        getattr(highlighter, color)()
        stream.write(text)
        stream.flush()
        highlighter.reset()


class KeywordMarker(object):

    def __init__(self, markers, stdout, highlighter):
        self._stdout = stdout
        self._highlighter = highlighter
        self.marking_enabled = self._marking_enabled(markers, stdout)
        self.marker_count = 0

    def _marking_enabled(self, markers, stdout):
        auto = utils.isatty(stdout)
        return {'AUTO': auto,
                'ON': True,
                'OFF': False}.get(markers.upper(), auto)

    def mark(self, kw):
        if self.marking_enabled:
            marker, color = ('.', 'green') if kw.passed else ('F', 'red')
            self._highlighter.highlight(marker, color, self._stdout)
            self.marker_count += 1

    def reset_count(self):
        self.marker_count = 0


########NEW FILE########
__FILENAME__ = output
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.common.statistics import Statistics

from .listeners import Listeners
from .logger import LOGGER
from .loggerhelper import AbstractLogger
from .debugfile import DebugFile
from .xmllogger import XmlLogger


class Output(AbstractLogger):

    def __init__(self, settings):
        AbstractLogger.__init__(self)
        self._xmllogger = XmlLogger(settings['Output'], settings['LogLevel'])
        self._register_loggers(settings['Listeners'], settings['DebugFile'])
        self._settings = settings

    def _register_loggers(self, listeners, debugfile):
        LOGGER.register_context_changing_logger(self._xmllogger)
        for logger in Listeners(listeners), DebugFile(debugfile):
            if logger: LOGGER.register_logger(logger)
        LOGGER.disable_message_cache()

    def close(self, suite):
        stats = Statistics(suite, self._settings['SuiteStatLevel'],
                           self._settings['TagStatInclude'],
                           self._settings['TagStatExclude'],
                           self._settings['TagStatCombine'],
                           self._settings['TagDoc'],
                           self._settings['TagStatLink'])
        stats.serialize(self._xmllogger)
        self._xmllogger.close()
        LOGGER.unregister_logger(self._xmllogger)
        LOGGER.output_file('Output', self._settings['Output'])

    def start_suite(self, suite):
        LOGGER.start_suite(suite)

    def end_suite(self, suite):
        LOGGER.end_suite(suite)

    def start_test(self, test):
        LOGGER.start_test(test)

    def end_test(self, test):
        LOGGER.end_test(test)

    def start_keyword(self, kw):
        LOGGER.start_keyword(kw)

    def end_keyword(self, kw):
        LOGGER.end_keyword(kw)

    def message(self, msg):
        LOGGER.log_message(msg)

    def set_log_level(self, level):
        # TODO: Module structure should be cleaned up to prevent cyclic imports
        from .pyloggingconf import set_level
        set_level(level)
        return self._xmllogger.set_log_level(level)


########NEW FILE########
__FILENAME__ = pyloggingconf
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import logging

from robot.api import logger
from robot import utils

LEVELS = {'TRACE': logging.NOTSET,
          'DEBUG': logging.DEBUG,
          'INFO': logging.INFO,
          'WARN': logging.WARNING}


def initialize(level):
    logging.raiseExceptions = False
    logging.getLogger().addHandler(RobotHandler())
    set_level(level)


def set_level(level):
    try:
        level = LEVELS[level.upper()]
    except KeyError:
        return
    logging.getLogger().setLevel(level)


class RobotHandler(logging.Handler):

    def emit(self, record):
        message, error = self._get_message(record)
        method = self._get_logger_method(record.levelno)
        method(message)
        if error:
            logger.debug(error)

    def _get_message(self, record):
        try:
            return record.getMessage(), None
        except:
            message = 'Failed to log following message properly: %s' \
                        % utils.unic(record.msg)
            error = '\n'.join(utils.get_error_details())
            return message, error

    def _get_logger_method(self, level):
        if level >= logging.WARNING:
            return logger.warn
        if level >= logging.INFO:
            return logger.info
        if level >= logging.DEBUG:
            return logger.debug
        return logger.trace

########NEW FILE########
__FILENAME__ = stdoutlogsplitter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robot import utils

from .loggerhelper import Message, LEVELS


class StdoutLogSplitter(object):
    """Splits messages logged through stdout (or stderr) into Message objects"""

    _split_from_levels = re.compile('^(?:\*'
                                    '(%s|HTML)'          # Level
                                    '(:\d+(?:\.\d+)?)?'  # Optional timestamp
                                    '\*)' % '|'.join(LEVELS), re.MULTILINE)

    def __init__(self, output):
        self._messages = list(self._get_messages(output.strip()))

    def _get_messages(self, output):
        for level, timestamp, msg in self._split_output(output):
            if timestamp:
                timestamp = self._format_timestamp(timestamp[1:])
            yield Message(msg.strip(), level, timestamp=timestamp)

    def _split_output(self, output):
        tokens = self._split_from_levels.split(output)
        tokens = self._add_initial_level_and_time_if_needed(tokens)
        for i in xrange(0, len(tokens), 3):
            yield tokens[i:i+3]

    def _add_initial_level_and_time_if_needed(self, tokens):
        if self._output_started_with_level(tokens):
            return tokens[1:]
        return ['INFO', None] + tokens

    def _output_started_with_level(self, tokens):
        return tokens[0] == ''

    def _format_timestamp(self, millis):
        return utils.format_time(float(millis)/1000, millissep='.')

    def __iter__(self):
        return iter(self._messages)

########NEW FILE########
__FILENAME__ = xmllogger
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError
from robot.utils import XmlWriter, NullMarkupWriter, get_timestamp, unic
from robot.version import get_full_version

from .loggerhelper import IsLogged


class XmlLogger(object):

    def __init__(self, path, log_level='TRACE', generator='Robot'):
        self._log_message_is_logged = IsLogged(log_level)
        self._error_message_is_logged = IsLogged('WARN')
        self._writer = self._get_writer(path, generator)
        self._errors = []

    def _get_writer(self, path, generator):
        if path == 'NONE':
            return NullMarkupWriter()
        try:
            writer = XmlWriter(path, encoding='UTF-8')
        except EnvironmentError, err:
            raise DataError("Opening output file '%s' failed: %s" %
                            (path, err.strerror))
        writer.start('robot', {'generator': get_full_version(generator),
                               'generated': get_timestamp()})
        return writer

    def close(self):
        self.start_errors()
        for msg in self._errors:
            self._write_message(msg)
        self.end_errors()
        self._writer.end('robot')
        self._writer.close()

    def set_log_level(self, level):
        return self._log_message_is_logged.set_level(level)

    def message(self, msg):
        if self._error_message_is_logged(msg.level):
            self._errors.append(msg)

    def log_message(self, msg):
        if self._log_message_is_logged(msg.level):
            self._write_message(msg)

    def _write_message(self, msg):
        attrs = {'timestamp': msg.timestamp or 'N/A', 'level': msg.level}
        if msg.html:
            attrs['html'] = 'yes'
        self._writer.element('msg', msg.message, attrs)

    def start_keyword(self, kw):
        self._writer.start('kw', {'name': kw.name, 'type': kw.type,
                                  'timeout': str(kw.timeout)})
        self._writer.element('doc', kw.doc)
        self._write_list('arguments', 'arg', (unic(a) for a in kw.args))

    def end_keyword(self, kw):
        self._write_status(kw)
        self._writer.end('kw')

    def start_test(self, test):
        self._writer.start('test', {'id': test.id, 'name': test.name,
                                    'timeout': str(test.timeout)})

    def end_test(self, test):
        self._writer.element('doc', test.doc)
        self._write_list('tags', 'tag', test.tags)
        self._write_status(test, {'critical': 'yes' if test.critical else 'no'})
        self._writer.end('test')

    def start_suite(self, suite):
        attrs = {'id': suite.id, 'name': suite.name}
        if suite.source:
            attrs['source'] = suite.source
        self._writer.start('suite', attrs)

    def end_suite(self, suite):
        self._writer.element('doc', suite.doc)
        self._writer.start('metadata')
        for name, value in suite.metadata.items():
            self._writer.element('item', value, {'name': name})
        self._writer.end('metadata')
        self._write_status(suite)
        self._writer.end('suite')

    def start_statistics(self, stats):
        self._writer.start('statistics')

    def end_statistics(self, stats):
        self._writer.end('statistics')

    def start_total_stats(self, total_stats):
        self._writer.start('total')

    def end_total_stats(self, total_stats):
        self._writer.end('total')

    def start_tag_stats(self, tag_stats):
        self._writer.start('tag')

    def end_tag_stats(self, tag_stats):
        self._writer.end('tag')

    def start_suite_stats(self, tag_stats):
        self._writer.start('suite')

    def end_suite_stats(self, tag_stats):
        self._writer.end('suite')

    def total_stat(self, stat):
        self._stat(stat)

    def suite_stat(self, stat):
        self._stat(stat, stat.longname,
                   attrs={'id': stat.id, 'name': stat.name})

    def tag_stat(self, stat):
        self._stat(stat, attrs={'info': self._get_tag_stat_info(stat),
                                'links': self._get_tag_links(stat),
                                'doc': stat.doc,
                                'combined': stat.combined})

    def _get_tag_links(self, stat):
        return ':::'.join(':'.join([title, url]) for url, title in stat.links)

    def _stat(self, stat, name=None, attrs=None):
        attrs = attrs or {}
        attrs['pass'] = str(stat.passed)
        attrs['fail'] = str(stat.failed)
        self._writer.element('stat', name or stat.name, attrs)

    def _get_tag_stat_info(self, stat):
        if stat.critical:
            return 'critical'
        if stat.non_critical:
            return 'non-critical'
        if stat.combined:
            return 'combined'
        return ''

    def start_errors(self):
        self._writer.start('errors')

    def end_errors(self):
        self._writer.end('errors')

    def _write_list(self, container_tag, item_tag, items):
        self._writer.start(container_tag)
        for item in items:
            self._writer.element(item_tag, item)
        self._writer.end(container_tag)

    def _write_status(self, item, extra_attrs=None):
        attrs = {'status': item.status, 'starttime': item.starttime or 'N/A',
                 'endtime': item.endtime or 'N/A'}
        if not (item.starttime and item.endtime):
            attrs['elapsedtime'] = str(item.elapsedtime)
        if extra_attrs:
            attrs.update(extra_attrs)
        self._writer.element('status', item.message, attrs)

########NEW FILE########
__FILENAME__ = comments
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class CommentCache(object):

    def __init__(self):
        self._comments = []

    def add(self, comment):
        self._comments.append(comment)

    def consume_with(self, function):
        map(function, self._comments)
        self.__init__()


class Comments(object):

    def __init__(self):
        self._comments = []

    def add(self, row):
        if row.comments:
            self._comments.extend(c.strip() for c in row.comments if c.strip())

    @property
    def value(self):
        return self._comments


class Comment(object):

    def __init__(self, comment_data):
        if isinstance(comment_data, basestring):
            comment_data = [comment_data] if comment_data else []
        self._comment = comment_data or []

    def __len__(self):
        return len(self._comment)

    def as_list(self):
        if self._not_commented():
            self._comment[0] = '# ' + self._comment[0]
        return self._comment

    def _not_commented(self):
        return self._comment and self._comment[0] and self._comment[0][0] != '#'

########NEW FILE########
__FILENAME__ = datarow
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re


class DataRow(object):
    _row_continuation_marker = '...'
    _whitespace_regexp = re.compile('\s+')
    _ye_olde_metadata_prefix = 'meta:'

    def __init__(self, cells):
        self.cells, self.comments = self._parse(cells)

    def _parse(self, row):
        data = []
        comments = []
        for cell in row:
            cell = self._collapse_whitespace(cell)
            if cell.startswith('#') or comments:
                comments.append(cell)
            else:
                data.append(cell)
        return self._purge_empty_cells(data), self._purge_empty_cells(comments)

    def _collapse_whitespace(self, cell):
        return self._whitespace_regexp.sub(' ', cell).strip()

    def _purge_empty_cells(self, row):
        while row and not row[-1]:
            row.pop()
        # Cells with only a single backslash are considered empty
        return [cell if cell != '\\' else '' for cell in row]

    @property
    def head(self):
        return self.cells[0] if self.cells else ''

    @property
    def _tail(self):
        return self.cells[1:]

    @property
    def all(self):
        return self.cells

    @property
    def data(self):
        if self.is_continuing():
            index = self.cells.index(self._row_continuation_marker) + 1
            return self.cells[index:]
        return self.cells

    def dedent(self):
        datarow = DataRow([])
        datarow.cells = self._tail
        datarow.comments = self.comments
        return datarow

    def handle_old_style_metadata(self):
        if self._is_metadata_with_olde_prefix(self.head):
            self.cells = self._convert_to_new_style_metadata()

    def _is_metadata_with_olde_prefix(self, value):
        return value.lower().startswith(self._ye_olde_metadata_prefix)

    def _convert_to_new_style_metadata(self):
        return ['Metadata'] + [self.head.split(':', 1)[1].strip()] + self._tail

    def starts_for_loop(self):
        if self.head and self.head.startswith(':'):
            return self.head.replace(':', '').replace(' ', '').upper() == 'FOR'
        return False

    def starts_test_or_user_keyword_setting(self):
        head = self.head
        return head and head[0] == '[' and head[-1] == ']'

    def test_or_user_keyword_setting_name(self):
        return self.head[1:-1].strip()

    def is_indented(self):
        return self.head == ''

    def is_continuing(self):
        for cell in self.cells:
            if cell == self._row_continuation_marker:
                return True
            if cell:
                return False

    def is_commented(self):
        return bool(not self.cells and self.comments)

    def __nonzero__(self):
        return bool(self.cells or self.comments)

########NEW FILE########
__FILENAME__ = htmlreader
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import HTMLParser
from htmlentitydefs import entitydefs


NON_BREAKING_SPACE = u'\xA0'


class HtmlReader(HTMLParser.HTMLParser):
    IGNORE = 0
    INITIAL = 1
    PROCESS = 2

    def __init__(self):
        HTMLParser.HTMLParser.__init__(self)
        self._encoding = 'ISO-8859-1'
        self._handlers = {'table_start' : self.table_start,
                          'table_end'   : self.table_end,
                          'tr_start'    : self.tr_start,
                          'tr_end'      : self.tr_end,
                          'td_start'    : self.td_start,
                          'td_end'      : self.td_end,
                          'th_start'    : self.td_start,
                          'th_end'      : self.td_end,
                          'br_start'    : self.br_start,
                          'meta_start'  : self.meta_start}

    def read(self, htmlfile, populator):
        self.populator = populator
        self.state = self.IGNORE
        self.current_row = None
        self.current_cell = None
        for line in htmlfile.readlines():
            self.feed(self._decode(line))
        # Calling close is required by the HTMLParser but may cause problems
        # if the same instance of our HtmlParser is reused. Currently it's
        # used only once so there's no problem.
        self.close()
        self.populator.eof()

    def _decode(self, line):
        return line.decode(self._encoding)

    def handle_starttag(self, tag, attrs):
        handler = self._handlers.get(tag+'_start')
        if handler is not None:
            handler(attrs)

    def handle_endtag(self, tag):
        handler = self._handlers.get(tag+'_end')
        if handler is not None:
            handler()

    def handle_data(self, data):
        if self.state == self.IGNORE or self.current_cell is None:
            return
        if NON_BREAKING_SPACE in data:
            data = data.replace(NON_BREAKING_SPACE, ' ')
        self.current_cell.append(data)

    def handle_entityref(self, name):
        value = self._handle_entityref(name)
        self.handle_data(value)

    def _handle_entityref(self, name):
        if name == 'apos':  # missing from entitydefs
            return "'"
        try:
            value = entitydefs[name]
        except KeyError:
            return '&'+name+';'
        if value.startswith('&#'):
            return unichr(int(value[2:-1]))
        return value.decode('ISO-8859-1')

    def handle_charref(self, number):
        value = self._handle_charref(number)
        self.handle_data(value)

    def _handle_charref(self, number):
        if number.startswith(('x', 'X')):
            base = 16
            number = number[1:]
        else:
            base = 10
        try:
            return unichr(int(number, base))
        except ValueError:
            return '&#'+number+';'

    def handle_pi(self, data):
        encoding = self._get_encoding_from_pi(data)
        if encoding:
            self._encoding = encoding

    def unknown_decl(self, data):
        # Ignore everything even if it's invalid. This kind of stuff comes
        # at least from MS Excel
        pass

    def table_start(self, attrs=None):
        self.state = self.INITIAL
        self.current_row = None
        self.current_cell = None

    def table_end(self):
        if self.current_row is not None:
            self.tr_end()
        self.state = self.IGNORE

    def tr_start(self, attrs=None):
        if self.current_row is not None:
            self.tr_end()
        self.current_row = []

    def tr_end(self):
        if self.current_row is None:
            return
        if self.current_cell is not None:
            self.td_end()
        if self.state == self.INITIAL:
            accepted = self.populator.start_table(self.current_row)
            self.state = self.PROCESS if accepted else self.IGNORE
        elif self.state == self.PROCESS:
            self.populator.add(self.current_row)
        self.current_row = None

    def td_start(self, attrs=None):
        if self.current_cell is not None:
            self.td_end()
        if self.current_row is None:
            self.tr_start()
        self.current_cell = []

    def td_end(self):
        if self.current_cell is not None and self.state != self.IGNORE:
            cell = ''.join(self.current_cell)
            self.current_row.append(cell)
        self.current_cell = None

    def br_start(self, attrs=None):
        self.handle_data('\n')

    def meta_start(self, attrs):
        encoding = self._get_encoding_from_meta(attrs)
        if encoding:
            self._encoding = encoding

    def _get_encoding_from_meta(self, attrs):
        valid_http_equiv = False
        encoding = None
        for name, value in attrs:
            name = name.lower()
            if name == 'http-equiv' and value.lower() == 'content-type':
                valid_http_equiv = True
            if name == 'content':
                for token in value.split(';'):
                    token = token.strip()
                    if token.lower().startswith('charset='):
                        encoding = token[8:]
        return encoding if valid_http_equiv else None

    def _get_encoding_from_pi(self, data):
        data = data.strip()
        if not data.lower().startswith('xml '):
            return None
        if data.endswith('?'):
            data = data[:-1]
        for token in data.split():
            if token.lower().startswith('encoding='):
                encoding = token[9:]
                if encoding.startswith("'") or encoding.startswith('"'):
                    encoding = encoding[1:-1]
                return encoding
        return None

########NEW FILE########
__FILENAME__ = model
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import copy

from robot.errors import DataError
from robot.variables import is_var
from robot.output import LOGGER
from robot import utils
from robot.writer import DataFileWriter

from .comments import Comment
from .populators import FromFilePopulator, FromDirectoryPopulator
from .settings import (Documentation, Fixture, Timeout, Tags, Metadata, Library,
    Resource, Variables, Arguments, Return, Template, MetadataList, ImportList)


def TestData(parent=None, source=None, include_suites=[],
             warn_on_skipped=False):
    # TODO: can we change the order of parent and source?? source seems mandatory
    """Parses a file or directory to a corresponding model object.

    :param parent: (optional) parent to be used in creation of the model object.
    :param source: path where test data is read from.
    :returns: :class:`~.model.TestDataDirectory`  if `source` is a directory,
        :class:`~.model.TestCaseFile` otherwise.
    """
    if os.path.isdir(source):
        return TestDataDirectory(parent, source).populate(include_suites,
                                                          warn_on_skipped)
    return TestCaseFile(parent, source).populate()


class _TestData(object):
    _setting_table_names = 'Setting', 'Settings', 'Metadata'
    _variable_table_names = 'Variable', 'Variables'
    _testcase_table_names = 'Test Case', 'Test Cases'
    _keyword_table_names = 'Keyword', 'Keywords', 'User Keyword', 'User Keywords'

    def __init__(self, parent=None, source=None):
        self.parent = parent
        self.source = utils.abspath(source) if source else None
        self.children = []
        self._tables = utils.NormalizedDict(self._get_tables())

    def _get_tables(self):
        for names, table in [(self._setting_table_names, self.setting_table),
                             (self._variable_table_names, self.variable_table),
                             (self._testcase_table_names, self.testcase_table),
                             (self._keyword_table_names, self.keyword_table)]:
            for name in names:
                yield name, table

    def start_table(self, header_row):
        try:
            table = self._tables[header_row[0]]
        except (KeyError, IndexError):
            return None
        if not self._table_is_allowed(table):
            return None
        table.set_header(header_row)
        return table

    @property
    def name(self):
        return self._format_name(self._get_basename()) if self.source else None

    def _get_basename(self):
        return os.path.splitext(os.path.basename(self.source))[0]

    def _format_name(self, name):
        name = self._strip_possible_prefix_from_name(name)
        name = name.replace('_', ' ').strip()
        return name.title() if name.islower() else name

    def _strip_possible_prefix_from_name(self, name):
        return name.split('__', 1)[-1]

    @property
    def keywords(self):
        return self.keyword_table.keywords

    @property
    def imports(self):
        return self.setting_table.imports

    def report_invalid_syntax(self, table, message, level='ERROR'):
        initfile = getattr(self, 'initfile', None)
        path = os.path.join(self.source, initfile) if initfile else self.source
        LOGGER.write("Error in file '%s' in table '%s': %s"
                     % (path, table, message), level)

    def save(self, **options):
        """Writes this datafile to disk.

        :param options: Configuration for writing. These are passed to
            :py:class:`~robot.writer.datafilewriter.WritingContext` as
            keyword arguments.

        See also :py:class:`robot.writer.datafilewriter.DataFileWriter`
        """
        return DataFileWriter(**options).write(self)


class TestCaseFile(_TestData):
    """The parsed test case file object."""

    def __init__(self, parent=None, source=None):
        self.directory = os.path.dirname(source) if source else None
        self.setting_table = TestCaseFileSettingTable(self)
        self.variable_table = VariableTable(self)
        self.testcase_table = TestCaseTable(self)
        self.keyword_table = KeywordTable(self)
        _TestData.__init__(self, parent, source)

    def populate(self):
        FromFilePopulator(self).populate(self.source)
        self._validate()
        return self

    def _validate(self):
        if not self.testcase_table.is_started():
            raise DataError('File has no test case table.')

    def _table_is_allowed(self, table):
        return True

    def has_tests(self):
        return True

    def __iter__(self):
        for table in [self.setting_table, self.variable_table,
                      self.testcase_table, self.keyword_table]:
            yield table


class ResourceFile(_TestData):
    """The parsed resource file object."""

    def __init__(self, source=None):
        self.directory = os.path.dirname(source) if source else None
        self.setting_table = ResourceFileSettingTable(self)
        self.variable_table = VariableTable(self)
        self.testcase_table = TestCaseTable(self)
        self.keyword_table = KeywordTable(self)
        _TestData.__init__(self, source=source)

    def populate(self):
        FromFilePopulator(self).populate(self.source)
        self._report_status()
        return self

    def _report_status(self):
        if self.setting_table or self.variable_table or self.keyword_table:
            LOGGER.info("Imported resource file '%s' (%d keywords)."
                        % (self.source, len(self.keyword_table.keywords)))
        else:
            LOGGER.warn("Imported resource file '%s' is empty." % self.source)

    def _table_is_allowed(self, table):
        if table is self.testcase_table:
            raise DataError("Resource file '%s' contains a test case table "
                            "which is not allowed." % self.source)
        return True

    def __iter__(self):
        for table in [self.setting_table, self.variable_table, self.keyword_table]:
            yield table


class TestDataDirectory(_TestData):
    """The parsed test data directory object. Contains hiearchical structure
    of other :py:class:`.TestDataDirectory` and :py:class:`.TestCaseFile`
    objects.
    """

    def __init__(self, parent=None, source=None):
        self.directory = source
        self.initfile = None
        self.setting_table = InitFileSettingTable(self)
        self.variable_table = VariableTable(self)
        self.testcase_table = TestCaseTable(self)
        self.keyword_table = KeywordTable(self)
        _TestData.__init__(self, parent, source)

    def populate(self, include_suites=[], warn_on_skipped=False, recurse=True):
        FromDirectoryPopulator().populate(self.source, self, include_suites,
                                          warn_on_skipped, recurse)
        self.children = [ch for ch in self.children if ch.has_tests()]
        return self

    def _get_basename(self):
        return os.path.basename(self.source)

    def _table_is_allowed(self, table):
        if table is self.testcase_table:
            LOGGER.error("Test suite init file in '%s' contains a test case "
                         "table which is not allowed." % self.source)
            return False
        return True

    def add_child(self, path, include_suites):
        self.children.append(TestData(parent=self,source=path,
                                      include_suites=include_suites))

    def has_tests(self):
        return any(ch.has_tests() for ch in self.children)

    def __iter__(self):
        for table in [self.setting_table, self.variable_table, self.keyword_table]:
            yield table


class _Table(object):

    def __init__(self, parent):
        self.parent = parent
        self._header = None

    def set_header(self, header):
        self._header = self._prune_old_style_headers(header)

    def _prune_old_style_headers(self, header):
        if len(header) < 3:
            return header
        if self._old_header_matcher.match(header):
            return [header[0]]
        return header

    @property
    def header(self):
        return self._header or [self.type.title() + 's']

    @property
    def name(self):
        return self.header[0]

    @property
    def source(self):
        return self.parent.source

    @property
    def directory(self):
        return self.parent.directory

    def report_invalid_syntax(self, message, level='ERROR'):
        self.parent.report_invalid_syntax(self.name, message, level)

    def __nonzero__(self):
        return bool(self._header or len(self))

    def __len__(self):
        return sum(1 for item in self)


class _WithSettings(object):

    def get_setter(self, setting_name):
        normalized = self.normalize(setting_name)
        if normalized in self._setters:
            return self._setters[normalized](self)
        self.report_invalid_syntax("Non-existing setting '%s'." % setting_name)

    def is_setting(self, setting_name):
        return self.normalize(setting_name) in self._setters

    def normalize(self, setting):
        result = utils.normalize(setting)
        return result[0:-1] if result and result[-1]==':' else result


class _SettingTable(_Table, _WithSettings):
    type = 'setting'

    def __init__(self, parent):
        _Table.__init__(self, parent)
        self.doc = Documentation('Documentation', self)
        self.suite_setup = Fixture('Suite Setup', self)
        self.suite_teardown = Fixture('Suite Teardown', self)
        self.test_setup = Fixture('Test Setup', self)
        self.test_teardown = Fixture('Test Teardown', self)
        self.force_tags = Tags('Force Tags', self)
        self.default_tags = Tags('Default Tags', self)
        self.test_template = Template('Test Template', self)
        self.test_timeout = Timeout('Test Timeout', self)
        self.metadata = MetadataList(self)
        self.imports = ImportList(self)

    @property
    def _old_header_matcher(self):
        return OldStyleSettingAndVariableTableHeaderMatcher()

    def add_metadata(self, name, value='', comment=None):
        self.metadata.add(Metadata(self, name, value, comment))
        return self.metadata[-1]

    def add_library(self, name, args=None, comment=None):
        self.imports.add(Library(self, name, args, comment=comment))
        return self.imports[-1]

    def add_resource(self, name, invalid_args=None, comment=None):
        self.imports.add(Resource(self, name, invalid_args, comment=comment))
        return self.imports[-1]

    def add_variables(self, name, args=None, comment=None):
        self.imports.add(Variables(self, name, args, comment=comment))
        return self.imports[-1]

    def __len__(self):
        return sum(1 for setting in self if setting.is_set())


class TestCaseFileSettingTable(_SettingTable):

    _setters = {'documentation': lambda s: s.doc.populate,
                'document': lambda s: s.doc.populate,
                'suitesetup': lambda s: s.suite_setup.populate,
                'suiteprecondition': lambda s: s.suite_setup.populate,
                'suiteteardown': lambda s: s.suite_teardown.populate,
                'suitepostcondition': lambda s: s.suite_teardown.populate,
                'testsetup': lambda s: s.test_setup.populate,
                'testprecondition': lambda s: s.test_setup.populate,
                'testteardown': lambda s: s.test_teardown.populate,
                'testpostcondition': lambda s: s.test_teardown.populate,
                'forcetags': lambda s: s.force_tags.populate,
                'defaulttags': lambda s: s.default_tags.populate,
                'testtemplate': lambda s: s.test_template.populate,
                'testtimeout': lambda s: s.test_timeout.populate,
                'library': lambda s: s.imports.populate_library,
                'resource': lambda s: s.imports.populate_resource,
                'variables': lambda s: s.imports.populate_variables,
                'metadata': lambda s: s.metadata.populate}

    def __iter__(self):
        for setting in [self.doc, self.suite_setup, self.suite_teardown,
                        self.test_setup, self.test_teardown, self.force_tags,
                        self.default_tags, self.test_template, self.test_timeout] \
                        + self.metadata.data + self.imports.data:
            yield setting


class ResourceFileSettingTable(_SettingTable):

    _setters = {'documentation': lambda s: s.doc.populate,
                'document': lambda s: s.doc.populate,
                'library': lambda s: s.imports.populate_library,
                'resource': lambda s: s.imports.populate_resource,
                'variables': lambda s: s.imports.populate_variables}

    def __iter__(self):
        for setting in [self.doc] + self.imports.data:
            yield setting


class InitFileSettingTable(_SettingTable):

    _setters = {'documentation': lambda s: s.doc.populate,
                'document': lambda s: s.doc.populate,
                'suitesetup': lambda s: s.suite_setup.populate,
                'suiteprecondition': lambda s: s.suite_setup.populate,
                'suiteteardown': lambda s: s.suite_teardown.populate,
                'suitepostcondition': lambda s: s.suite_teardown.populate,
                'testsetup': lambda s: s.test_setup.populate,
                'testprecondition': lambda s: s.test_setup.populate,
                'testteardown': lambda s: s.test_teardown.populate,
                'testpostcondition': lambda s: s.test_teardown.populate,
                'testtimeout': lambda s: s.test_timeout.populate,
                'forcetags': lambda s: s.force_tags.populate,
                'library': lambda s: s.imports.populate_library,
                'resource': lambda s: s.imports.populate_resource,
                'variables': lambda s: s.imports.populate_variables,
                'metadata': lambda s: s.metadata.populate}

    def __iter__(self):
        for setting in [self.doc, self.suite_setup, self.suite_teardown,
                        self.test_setup, self.test_teardown, self.force_tags,
                        self.test_timeout] + self.metadata.data + self.imports.data:
            yield setting


class VariableTable(_Table):
    type = 'variable'

    def __init__(self, parent):
        _Table.__init__(self, parent)
        self.variables = []

    @property
    def _old_header_matcher(self):
        return OldStyleSettingAndVariableTableHeaderMatcher()

    def add(self, name, value, comment=None):
        self.variables.append(Variable(name, value, comment))

    def __iter__(self):
        return iter(self.variables)


class TestCaseTable(_Table):
    type = 'test case'

    def __init__(self, parent):
        _Table.__init__(self, parent)
        self.tests = []

    @property
    def _old_header_matcher(self):
        return OldStyleTestAndKeywordTableHeaderMatcher()

    def add(self, name):
        self.tests.append(TestCase(self, name))
        return self.tests[-1]

    def __iter__(self):
        return iter(self.tests)

    def is_started(self):
        return bool(self._header)

    def __nonzero__(self):
        return True


class KeywordTable(_Table):
    type = 'keyword'

    def __init__(self, parent):
        _Table.__init__(self, parent)
        self.keywords = []

    @property
    def _old_header_matcher(self):
        return OldStyleTestAndKeywordTableHeaderMatcher()

    def add(self, name):
        self.keywords.append(UserKeyword(self, name))
        return self.keywords[-1]

    def __iter__(self):
        return iter(self.keywords)


class Variable(object):

    def __init__(self, name, value, comment=None):
        self.name = name.rstrip('= ')
        if name.startswith('$') and value == []:
            value = ''
        if isinstance(value, basestring):
            value = [value]  # Must support scalar lists until RF 2.8 (issue 939)
        self.value = value
        self.comment = Comment(comment)

    def as_list(self):
        if self.has_data():
            return [self.name] + self.value + self.comment.as_list()
        return self.comment.as_list()

    def is_set(self):
        return True

    def is_for_loop(self):
        return False

    def has_data(self):
        return bool(self.name or ''.join(self.value))


class _WithSteps(object):

    def add_step(self, content, comment=None):
        self.steps.append(Step(content, comment))
        return self.steps[-1]

    def copy(self, name):
        new = copy.deepcopy(self)
        new.name = name
        self._add_to_parent(new)
        return new


class TestCase(_WithSteps, _WithSettings):

    def __init__(self, parent, name):
        self.parent = parent
        self.name = name
        self.doc = Documentation('[Documentation]', self)
        self.template = Template('[Template]', self)
        self.tags = Tags('[Tags]', self)
        self.setup = Fixture('[Setup]', self)
        self.teardown = Fixture('[Teardown]', self)
        self.timeout = Timeout('[Timeout]', self)
        self.steps = []

    _setters = {'documentation': lambda s: s.doc.populate,
                'document': lambda s: s.doc.populate,
                'template': lambda s: s.template.populate,
                'setup': lambda s: s.setup.populate,
                'precondition': lambda s: s.setup.populate,
                'teardown': lambda s: s.teardown.populate,
                'postcondition': lambda s: s.teardown.populate,
                'tags': lambda s: s.tags.populate,
                'timeout': lambda s: s.timeout.populate}

    @property
    def source(self):
        return self.parent.source

    @property
    def directory(self):
        return self.parent.directory

    def add_for_loop(self, declaration, comment=None):
        self.steps.append(ForLoop(declaration, comment))
        return self.steps[-1]

    def report_invalid_syntax(self, message, level='ERROR'):
        type_ = 'test case' if type(self) is TestCase else 'keyword'
        message = "Invalid syntax in %s '%s': %s" % (type_, self.name, message)
        self.parent.report_invalid_syntax(message, level)

    def _add_to_parent(self, test):
        self.parent.tests.append(test)

    @property
    def settings(self):
        return [self.doc, self.tags, self.setup, self.template, self.timeout,
                self.teardown]

    def __iter__(self):
        for element in [self.doc, self.tags, self.setup,
                        self.template, self.timeout] \
                        + self.steps + [self.teardown]:
            yield element


class UserKeyword(TestCase):

    def __init__(self, parent, name):
        self.parent = parent
        self.name = name
        self.doc = Documentation('[Documentation]', self)
        self.args = Arguments('[Arguments]', self)
        self.return_ = Return('[Return]', self)
        self.timeout = Timeout('[Timeout]', self)
        self.teardown = Fixture('[Teardown]', self)
        self.steps = []

    _setters = {'documentation': lambda s: s.doc.populate,
                'document': lambda s: s.doc.populate,
                'arguments': lambda s: s.args.populate,
                'return': lambda s: s.return_.populate,
                'timeout': lambda s: s.timeout.populate,
                'teardown': lambda s: s.teardown.populate}

    def _add_to_parent(self, test):
        self.parent.keywords.append(test)

    @property
    def settings(self):
        return [self.args, self.doc, self.timeout, self.teardown, self.return_]

    def __iter__(self):
        for element in [self.args, self.doc, self.timeout] \
                        + self.steps + [self.teardown, self.return_]:
            yield element


class ForLoop(_WithSteps):

    def __init__(self, declaration, comment=None):
        self.range, index = self._get_range_and_index(declaration)
        self.vars = declaration[:index]
        self.items = declaration[index+1:]
        self.comment = Comment(comment)
        self.steps = []

    def _get_range_and_index(self, declaration):
        for index, item in enumerate(declaration):
            item = item.upper().replace(' ', '')
            if item in ['IN', 'INRANGE']:
                return item == 'INRANGE', index
        return False, len(declaration)

    def is_comment(self):
        return False

    def is_for_loop(self):
        return True

    def apply_template(self, template):
        return self

    def as_list(self, indent=False, include_comment=True):
        IN = ['IN RANGE' if self.range else 'IN']
        comments = self.comment.as_list() if include_comment else []
        return  [': FOR'] + self.vars + IN + self.items + comments

    def __iter__(self):
        return iter(self.steps)

    def is_set(self):
        return True


class Step(object):

    def __init__(self, content, comment=None):
        self.assign = list(self._get_assigned_vars(content))
        try:
            self.keyword = content[len(self.assign)]
        except IndexError:
            self.keyword = None
        self.args = content[len(self.assign)+1:]
        self.comment = Comment(comment)

    def _get_assigned_vars(self, content):
        for item in content:
            if not is_var(item.rstrip('= ')):
                return
            yield item

    def is_comment(self):
        return not (self.assign or self.keyword or self.args)

    def is_for_loop(self):
        return False

    def apply_template(self, template):
        if self.is_comment():
            return self
        return Step([template] + self.as_list(include_comment=False))

    def is_set(self):
        return True

    def as_list(self, indent=False, include_comment=True):
        kw = [self.keyword] if self.keyword is not None else []
        comments = self.comment.as_list() if include_comment else []
        data = self.assign + kw + self.args + comments
        if indent:
            data.insert(0, '')
        return data


class OldStyleSettingAndVariableTableHeaderMatcher(object):

    def match(self, header):
        return all((True if e.lower() == 'value' else False)
                    for e in header[1:])


class OldStyleTestAndKeywordTableHeaderMatcher(object):

    def match(self, header):
        if header[1].lower() != 'action':
            return False
        for h in header[2:]:
            if not h.lower().startswith('arg'):
                return False
        return True

########NEW FILE########
__FILENAME__ = populators
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot.errors import DataError
from robot.model import SuiteNamePatterns
from robot.output import LOGGER
from robot.utils import get_error_message, unic

from .datarow import DataRow
from .tablepopulators import (SettingTablePopulator, VariableTablePopulator,
                              TestTablePopulator, KeywordTablePopulator,
                              NullPopulator)
from .htmlreader import HtmlReader
from .tsvreader import TsvReader
from .txtreader import TxtReader
from .restreader import RestReader


READERS = {'html': HtmlReader, 'htm': HtmlReader, 'xhtml': HtmlReader,
           'tsv': TsvReader , 'rst': RestReader, 'rest': RestReader,
           'txt': TxtReader, 'robot': TxtReader}

# Hook for external tools for altering ${CURDIR} processing
PROCESS_CURDIR = True


class FromFilePopulator(object):
    _populators = {'setting': SettingTablePopulator,
                   'variable': VariableTablePopulator,
                   'test case': TestTablePopulator,
                   'keyword': KeywordTablePopulator}

    def __init__(self, datafile):
        self._datafile = datafile
        self._populator = NullPopulator()
        self._curdir = self._get_curdir(datafile.directory)

    def _get_curdir(self, path):
        return path.replace('\\','\\\\') if path else None

    def populate(self, path):
        LOGGER.info("Parsing file '%s'." % path)
        source = self._open(path)
        try:
            self._get_reader(path).read(source, self)
        except:
            raise DataError(get_error_message())
        finally:
            source.close()

    def _open(self, path):
        if not os.path.isfile(path):
            raise DataError("Data source does not exist.")
        try:
            return open(path, 'rb')
        except:
            raise DataError(get_error_message())

    def _get_reader(self, path):
        extension = os.path.splitext(path.lower())[-1][1:]
        try:
            return READERS[extension]()
        except KeyError:
            raise DataError("Unsupported file format '%s'." % extension)

    def start_table(self, header):
        self._populator.populate()
        table = self._datafile.start_table(DataRow(header).all)
        self._populator = self._populators[table.type](table) \
                if table is not None else NullPopulator()
        return bool(self._populator)

    def eof(self):
        self._populator.populate()

    def add(self, row):
        if PROCESS_CURDIR and self._curdir:
            row = self._replace_curdirs_in(row)
        data = DataRow(row)
        if data:
            self._populator.add(data)

    def _replace_curdirs_in(self, row):
        return [cell.replace('${CURDIR}', self._curdir) for cell in row]


class FromDirectoryPopulator(object):
    ignored_prefixes = ('_', '.')
    ignored_dirs = ('CVS',)

    def populate(self, path, datadir, include_suites, warn_on_skipped,
                 recurse=True):
        LOGGER.info("Parsing test data directory '%s'" % path)
        include_suites = self._get_include_suites(path, include_suites)
        init_file, children = self._get_children(path, include_suites)
        if init_file:
            self._populate_init_file(datadir, init_file)
        if recurse:
            self._populate_chidren(datadir, children, include_suites,
                                   warn_on_skipped)

    def _populate_init_file(self, datadir, init_file):
        datadir.initfile = init_file
        try:
            FromFilePopulator(datadir).populate(init_file)
        except DataError, err:
            LOGGER.error(unicode(err))

    def _populate_chidren(self, datadir, children, include_suites, warn_on_skipped):
        for child in children:
            try:
                datadir.add_child(child, include_suites)
            except DataError, err:
                self._log_failed_parsing("Parsing data source '%s' failed: %s"
                            % (child, unicode(err)), warn_on_skipped)

    def _log_failed_parsing(self, message, warn):
        if warn:
            LOGGER.warn(message)
        else:
            LOGGER.info(message)

    def _get_include_suites(self, path, incl_suites):
        if not isinstance(incl_suites, SuiteNamePatterns):
            # Use only the last part of names given like '--suite parent.child'
            incl_suites = SuiteNamePatterns(i.split('.')[-1] for i in incl_suites)
        if not incl_suites:
            return incl_suites
        # If a directory is included, also all its children should be included.
        if self._directory_is_included(path, incl_suites):
            return SuiteNamePatterns()
        return incl_suites

    def _directory_is_included(self, path, incl_suites):
        name = os.path.basename(os.path.normpath(path))
        return self._is_in_included_suites(name, incl_suites)

    def _get_children(self, dirpath, incl_suites):
        init_file = None
        children = []
        for name, path in self._list_dir(dirpath):
            if self._is_init_file(name, path):
                if not init_file:
                    init_file = path
                else:
                    LOGGER.error("Ignoring second test suite init file '%s'." % path)
            elif self._is_included(name, path, incl_suites):
                children.append(path)
            else:
                LOGGER.info("Ignoring file or directory '%s'." % name)
        return init_file, children

    def _list_dir(self, path):
        # os.listdir returns Unicode entries when path is Unicode
        names = os.listdir(unic(path))
        for name in sorted(names, key=unicode.lower):
            # unic needed to handle nfc/nfd normalization on OSX
            yield unic(name), unic(os.path.join(path, name))

    def _is_init_file(self, name, path):
        if not os.path.isfile(path):
            return False
        base, extension = os.path.splitext(name.lower())
        return base == '__init__' and extension[1:] in READERS

    def _is_included(self, name, path, incl_suites):
        if name.startswith(self.ignored_prefixes):
            return False
        if os.path.isdir(path):
            return name not in self.ignored_dirs
        base, extension = os.path.splitext(name.lower())
        return (extension[1:] in READERS and
                self._is_in_included_suites(base, incl_suites))

    def _is_in_included_suites(self, name, incl_suites):
        return not incl_suites or incl_suites.match(self._split_prefix(name))

    def _split_prefix(self, name):
        return name.split('__', 1)[-1]

########NEW FILE########
__FILENAME__ = restreader
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import tempfile
import os

from robot.errors import DataError

from .htmlreader import HtmlReader


def RestReader():
    try:
        from docutils.core import publish_cmdline
        from docutils.parsers.rst import directives
    except ImportError:
        raise DataError("Using reStructuredText test data requires having "
                        "'docutils' module installed.")

    # Ignore custom sourcecode directives at least we use in reST sources.
    # See e.g. ug2html.py for an example how custom directives are created.
    ignorer = lambda *args: []
    ignorer.content = 1
    directives.register_directive('sourcecode', ignorer)

    class RestReader(HtmlReader):

        def read(self, rstfile, rawdata):
            htmlpath = self._rest_to_html(rstfile.name)
            htmlfile = None
            try:
                htmlfile = open(htmlpath, 'rb')
                return HtmlReader.read(self, htmlfile, rawdata)
            finally:
                if htmlfile:
                    htmlfile.close()
                os.remove(htmlpath)

        def _rest_to_html(self, rstpath):
            filedesc, htmlpath = tempfile.mkstemp('.html')
            os.close(filedesc)
            publish_cmdline(writer_name='html', argv=[rstpath, htmlpath])
            return htmlpath

    return RestReader()

########NEW FILE########
__FILENAME__ = settings
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from .comments import Comment


class Setting(object):

    def __init__(self, setting_name, parent=None, comment=None):
        self.setting_name = setting_name
        self.parent = parent
        self._set_initial_value()
        self._set_comment(comment)

    def _set_initial_value(self):
        self.value = []

    def _set_comment(self, comment):
        self.comment = Comment(comment)

    def reset(self):
        self.__init__(self.setting_name, self.parent)

    @property
    def source(self):
        return self.parent.source if self.parent is not None else None

    @property
    def directory(self):
        return self.parent.directory if self.parent is not None else None

    def populate(self, value, comment=None):
        """Mainly used at parsing time, later attributes can be set directly."""
        self._populate(value)
        self._set_comment(comment)

    def _populate(self, value):
        self.value = value

    def is_set(self):
        return bool(self.value)

    def is_for_loop(self):
        return False

    def report_invalid_syntax(self, message, level='ERROR'):
        self.parent.report_invalid_syntax(message, level)

    def _string_value(self, value):
        return value if isinstance(value, basestring) else ' '.join(value)

    def _concat_string_with_value(self, string, value):
        if string:
            return string + ' ' + self._string_value(value)
        return self._string_value(value)

    def as_list(self):
        return self._data_as_list() + self.comment.as_list()

    def _data_as_list(self):
        ret = [self.setting_name]
        if self.value:
            ret.extend(self.value)
        return ret

    def __nonzero__(self):
        return self.is_set()


class StringValueJoiner(object):

    def __init__(self, separator):
        self._separator = separator

    def join_string_with_value(self, string, value):
        if string:
            return string + self._separator + self.string_value(value)
        return self.string_value(value)

    def string_value(self, value):
        if isinstance(value, basestring):
            return value
        return self._separator.join(value)


class Documentation(Setting):

    def _set_initial_value(self):
        self.value = ''

    def _populate(self, value):
        self.value = self._concat_string_with_value(self.value, value)

    def _string_value(self, value):
        return value if isinstance(value, basestring) else ''.join(value)

    def _data_as_list(self):
        return [self.setting_name, self.value]


class Template(Setting):

    def _set_initial_value(self):
        self.value = None

    def _populate(self, value):
        self.value = self._concat_string_with_value(self.value, value)

    def is_set(self):
        return self.value is not None

    def _data_as_list(self):
        ret = [self.setting_name]
        if self.value:
            ret.append(self.value)
        return ret


class Fixture(Setting):

    def _set_initial_value(self):
        self.name = None
        self.args = []

    def _populate(self, value):
        if not self.name:
            self.name = value[0] if value else ''
            value = value[1:]
        self.args.extend(value)

    def is_set(self):
        return self.name is not None

    def _data_as_list(self):
        ret = [self.setting_name]
        if self.name or self.args:
            ret.append(self.name or '')
        if self.args:
            ret.extend(self.args)
        return ret


class Timeout(Setting):

    def _set_initial_value(self):
        self.value = None
        self.message = ''

    def _populate(self, value):
        if not self.value:
            self.value = value[0] if value else ''
            value = value[1:]
        self.message = self._concat_string_with_value(self.message, value)

    def is_set(self):
        return self.value is not None

    def _data_as_list(self):
        ret = [self.setting_name]
        if self.value or self.message:
            ret.append(self.value or '')
        if self.message:
            ret.append(self.message)
        return ret


class Tags(Setting):

    def _set_initial_value(self):
        self.value = None

    def _populate(self, value):
        self.value = (self.value or []) + value

    def is_set(self):
        return self.value is not None

    def __add__(self, other):
        if not isinstance(other, Tags):
            raise TypeError('Tags can only be added with tags')
        tags = Tags('Tags')
        tags.value = (self.value or []) + (other.value or [])
        return tags

    def __len__(self):
        return len(self.value) or 0

    def remove(self, item):
        if item in self.value:
            self.value.remove(item)


class Arguments(Setting):
    pass


class Return(Setting):
    pass


class Metadata(Setting):
    setting_name = 'Metadata'

    def __init__(self, parent, name, value, comment=None, joined=False):
        self.parent = parent
        self.name = name
        joiner = StringValueJoiner('' if joined else ' ')
        self.value = joiner.join_string_with_value('', value)
        self._set_comment(comment)

    def reset(self):
        pass

    def is_set(self):
        return True

    def _data_as_list(self):
        return [self.setting_name, self.name, self.value]


class _Import(Setting):

    def __init__(self, parent, name, args=None, alias=None, comment=None):
        self.parent = parent
        self.name = name
        self.args = args or []
        self.alias = alias
        self._set_comment(comment)

    def reset(self):
        pass

    @property
    def type(self):
        return type(self).__name__

    def is_set(self):
        return True

    def _data_as_list(self):
        return [self.type, self.name] + self.args


class Library(_Import):

    def __init__(self, parent, name, args=None, alias=None, comment=None):
        if args and not alias:
            args, alias = self._split_alias(args)
        _Import.__init__(self, parent, name, args, alias, comment)

    def _split_alias(self, args):
        if len(args) >= 2 and isinstance(args[-2], basestring) \
                and args[-2].upper() == 'WITH NAME':
            return args[:-2], args[-1]
        return args, None

    def _data_as_list(self):
        alias = ['WITH NAME', self.alias] if self.alias else []
        return ['Library', self.name] + self.args + alias


class Resource(_Import):

    def __init__(self, parent, name, invalid_args=None, comment=None):
        if invalid_args:
            name += ' ' + ' '.join(invalid_args)
        _Import.__init__(self, parent, name, comment=comment)


class Variables(_Import):

    def __init__(self, parent, name, args=None, comment=None):
        _Import.__init__(self, parent, name, args, comment=comment)


class _DataList(object):

    def __init__(self, parent):
        self._parent = parent
        self.data = []

    def add(self, meta):
        self._add(meta)

    def _add(self, meta):
        self.data.append(meta)

    def _parse_name_and_value(self, value):
        name = value[0] if value else ''
        return name, value[1:]

    def __getitem__(self, index):
        return self.data[index]

    def __setitem__(self, index, item):
        self.data[index] = item

    def __len__(self):
        return len(self.data)


class ImportList(_DataList):

    def populate_library(self, data, comment):
        self._populate(Library, data, comment)

    def populate_resource(self, data, comment):
        self._populate(Resource, data, comment)

    def populate_variables(self, data, comment):
        self._populate(Variables, data, comment)

    def _populate(self, item_class, data, comment):
        name, value = self._parse_name_and_value(data)
        self._add(item_class(self._parent, name, value, comment=comment))


class MetadataList(_DataList):

    def populate(self, name, value, comment):
        self._add(Metadata(self._parent, name, value, comment, joined=True))

########NEW FILE########
__FILENAME__ = tablepopulators
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from .comments import CommentCache, Comments
from .settings import Documentation, MetadataList


class Populator(object):
    """Explicit interface for all populators."""

    def add(self, row):
        raise NotImplementedError

    def populate(self):
        raise NotImplementedError


class NullPopulator(Populator):

    def add(self, row):
        pass

    def populate(self):
        pass

    def __nonzero__(self):
        return False


class _TablePopulator(Populator):

    def __init__(self, table):
        self._table = table
        self._populator = NullPopulator()
        self._comment_cache = CommentCache()

    def add(self, row):
        if self._is_cacheable_comment_row(row):
            self._comment_cache.add(row)
        else:
            self._add(row)

    def _is_cacheable_comment_row(self, row):
        return row.is_commented()

    def _add(self, row):
        if self._is_continuing(row):
            self._consume_comments()
        else:
            self._populator.populate()
            self._populator = self._get_populator(row)
            self._consume_standalone_comments()
        self._populator.add(row)

    def _is_continuing(self, row):
        return row.is_continuing() and self._populator

    def _get_populator(self, row):
        raise NotImplementedError

    def _consume_comments(self):
        self._comment_cache.consume_with(self._populator.add)

    def _consume_standalone_comments(self):
        self._consume_comments()

    def populate(self):
        self._consume_comments()
        self._populator.populate()


class SettingTablePopulator(_TablePopulator):

    def _get_populator(self, row):
        row.handle_old_style_metadata()
        setter = self._table.get_setter(row.head)
        if not setter:
            return NullPopulator()
        if setter.im_class is Documentation:
            return DocumentationPopulator(setter)
        if setter.im_class is MetadataList:
            return MetadataPopulator(setter)
        return SettingPopulator(setter)


class VariableTablePopulator(_TablePopulator):

    def _get_populator(self, row):
        return VariablePopulator(self._table.add, row.head)

    def _consume_standalone_comments(self):
        self._comment_cache.consume_with(self._populate_standalone_comment)

    def _populate_standalone_comment(self, comment):
        populator = self._get_populator(comment)
        populator.add(comment)
        populator.populate()

    def populate(self):
        self._populator.populate()
        self._consume_standalone_comments()


class _StepContainingTablePopulator(_TablePopulator):

    def _is_continuing(self, row):
        return row.is_indented() and self._populator or row.is_commented()

    def _is_cacheable_comment_row(self, row):
        return row.is_commented() and not self._populator


class TestTablePopulator(_StepContainingTablePopulator):

    def _get_populator(self, row):
        return TestCasePopulator(self._table.add)


class KeywordTablePopulator(_StepContainingTablePopulator):

    def _get_populator(self, row):
        return UserKeywordPopulator(self._table.add)


class ForLoopPopulator(Populator):

    def __init__(self, for_loop_creator):
        self._for_loop_creator = for_loop_creator
        self._loop = None
        self._populator = NullPopulator()
        self._declaration = []
        self._declaration_comments = []

    def add(self, row):
        dedented_row = row.dedent()
        if not self._loop:
            declaration_ready = self._populate_declaration(row)
            if not declaration_ready:
                return
            self._create_for_loop()
        if not row.is_continuing():
            self._populator.populate()
            self._populator = StepPopulator(self._loop.add_step)
        self._populator.add(dedented_row)

    def _populate_declaration(self, row):
        if row.starts_for_loop() or row.is_continuing():
            self._declaration.extend(row.dedent().data)
            self._declaration_comments.extend(row.comments)
            return False
        return True

    def _create_for_loop(self):
        self._loop = self._for_loop_creator(self._declaration,
                                            self._declaration_comments)

    def populate(self):
        if not self._loop:
            self._create_for_loop()
        self._populator.populate()


class _TestCaseUserKeywordPopulator(Populator):

    def __init__(self, test_or_uk_creator):
        self._test_or_uk_creator = test_or_uk_creator
        self._test_or_uk = None
        self._populator = NullPopulator()
        self._comment_cache = CommentCache()

    def add(self, row):
        if row.is_commented():
            self._comment_cache.add(row)
            return
        if not self._test_or_uk:
            self._test_or_uk = self._test_or_uk_creator(row.head)
        dedented_row = row.dedent()
        if dedented_row:
            self._handle_data_row(dedented_row)

    def _handle_data_row(self, row):
        if not self._continues(row):
            self._populator.populate()
            self._populator = self._get_populator(row)
            self._comment_cache.consume_with(self._populate_comment_row)
        else:
            self._comment_cache.consume_with(self._populator.add)
        self._populator.add(row)

    def _populate_comment_row(self, crow):
        populator = StepPopulator(self._test_or_uk.add_step)
        populator.add(crow)
        populator.populate()

    def populate(self):
        self._populator.populate()
        self._comment_cache.consume_with(self._populate_comment_row)

    def _get_populator(self, row):
        if row.starts_test_or_user_keyword_setting():
            setter = self._setting_setter(row)
            if not setter:
                return NullPopulator()
            if setter.im_class is Documentation:
                return DocumentationPopulator(setter)
            return SettingPopulator(setter)
        if row.starts_for_loop():
            return ForLoopPopulator(self._test_or_uk.add_for_loop)
        return StepPopulator(self._test_or_uk.add_step)

    def _continues(self, row):
        return row.is_continuing() and self._populator or \
            (isinstance(self._populator, ForLoopPopulator) and row.is_indented())

    def _setting_setter(self, row):
        setting_name = row.test_or_user_keyword_setting_name()
        return self._test_or_uk.get_setter(setting_name)


class TestCasePopulator(_TestCaseUserKeywordPopulator):
    _item_type = 'test case'


class UserKeywordPopulator(_TestCaseUserKeywordPopulator):
    _item_type = 'keyword'


class _PropertyPopulator(Populator):

    def __init__(self, setter):
        self._setter = setter
        self._value = []
        self._comments = Comments()

    def add(self, row):
        if not row.is_commented():
            self._add(row)
        self._comments.add(row)

    def _add(self, row):
        self._value.extend(row.dedent().data)


class VariablePopulator(_PropertyPopulator):

    def __init__(self, setter, name):
        _PropertyPopulator.__init__(self, setter)
        self._name = name

    def populate(self):
        self._setter(self._name, self._value, self._comments.value)


class SettingPopulator(_PropertyPopulator):

    def populate(self):
        self._setter(self._value, self._comments.value)


class DocumentationPopulator(_PropertyPopulator):
    _end_of_line_escapes = re.compile(r'(\\+)n?$')

    def populate(self):
        self._setter(self._value, self._comments.value)

    def _add(self, row):
        self._add_to_value(row.dedent().data)

    def _add_to_value(self, data):
        joiner = self._row_joiner()
        if joiner:
            self._value.append(joiner)
        self._value.append(' '.join(data))

    def _row_joiner(self):
        if self._is_empty():
            return None
        return self._joiner_based_on_eol_escapes()

    def _is_empty(self):
        return not self._value or \
               (len(self._value) == 1 and self._value[0] == '')

    def _joiner_based_on_eol_escapes(self):
        match = self._end_of_line_escapes.search(self._value[-1])
        if not match or len(match.group(1)) % 2 == 0:
            return '\\n'
        if not match.group(0).endswith('n'):
            return ' '
        return None


class MetadataPopulator(DocumentationPopulator):

    def __init__(self, setter):
        _PropertyPopulator.__init__(self, setter)
        self._name = None

    def populate(self):
        self._setter(self._name, self._value, self._comments.value)

    def _add(self, row):
        data = row.dedent().data
        if self._name is None:
            self._name = data[0] if data else ''
            data = data[1:]
        self._add_to_value(data)


class StepPopulator(_PropertyPopulator):

    def _add(self, row):
        self._value.extend(row.data)

    def populate(self):
        if self._value or self._comments:
            self._setter(self._value, self._comments.value)

########NEW FILE########
__FILENAME__ = tsvreader
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from codecs import BOM_UTF8


NBSP = u'\xA0'


class TsvReader:

    def read(self, tsvfile, populator):
        process = False
        for index, row in enumerate(tsvfile.readlines()):
            row = self._decode_row(row, index == 0)
            cells = [self._process(cell) for cell in self.split_row(row)]
            name = cells and cells[0].strip() or ''
            if name.startswith('*') and \
                    populator.start_table([c.replace('*','') for c in cells]):
                process = True
            elif process:
                populator.add(cells)
        populator.eof()

    def _decode_row(self, row, is_first):
        if is_first and row.startswith(BOM_UTF8):
            row = row[len(BOM_UTF8):]
        row = row.decode('UTF-8')
        if NBSP in row:
            row = row.replace(NBSP, ' ')
        return row.rstrip()

    @classmethod
    def split_row(cls, row):
        return row.split('\t')

    def _process(self, cell):
        if len(cell) > 1 and cell[0] == cell[-1] == '"':
            cell = cell[1:-1].replace('""','"')
        return cell

########NEW FILE########
__FILENAME__ = txtreader
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from .tsvreader import TsvReader


class TxtReader(TsvReader):
    _space_splitter = re.compile(' {2,}')
    _pipe_splitter = re.compile(' \|(?= )')

    @classmethod
    def split_row(cls, row):
        if '\t' in row:
            row = row.replace('\t', '  ')
        if not row.startswith('| '):
            return cls._space_splitter.split(row)
        row = row[1:-1] if row.endswith(' |') else row[1:]
        return [cell.strip() for cell in cls._pipe_splitter.split(row)]

    def _process(self, cell):
        return cell

########NEW FILE########
__FILENAME__ = pythonpathsetter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Module that adds directories needed by Robot to sys.path when imported."""

import os
import sys
import fnmatch
from os.path import abspath, dirname, join

ROBOTDIR = dirname(abspath(__file__))

def add_path(path, end=False):
    if not end:
        remove_path(path)
        sys.path.insert(0, path)
    elif not any(fnmatch.fnmatch(p, path) for p in sys.path):
        sys.path.append(path)

def remove_path(path):
    sys.path = [p for p in sys.path if not fnmatch.fnmatch(p, path)]


# When, for example, robot/run.py is executed as a script, the directory
# containing the robot module is not added to sys.path automatically but
# the robot directory itself is. Former is added to allow importing
# the module and the latter removed to prevent accidentally importing
# internal modules directly.
add_path(dirname(ROBOTDIR))
remove_path(ROBOTDIR)

# Default library search locations.
add_path(join(ROBOTDIR, 'libraries'))
add_path('.', end=True)

# Support libraries/resources in PYTHONPATH also with Jython and IronPython.
for item in os.getenv('PYTHONPATH', '').split(os.pathsep):
    add_path(abspath(item), end=True)


########NEW FILE########
__FILENAME__ = rebot
#!/usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

USAGE = """Rebot -- Robot Framework Report and Log Generator

Version:  <VERSION>

Usage:  rebot|jyrebot|ipyrebot [options] robot_outputs
   or:  python|jython|ipy -m robot.rebot [options] robot_outputs
   or:  python|jython|ipy path/to/robot/rebot.py [options] robot_outputs
   or:  java -jar robotframework.jar rebot [options] robot_outputs

Rebot can be used to generate logs and reports in HTML format. It can also
produce new XML output files which can be further processed with Rebot or
other tools.

Inputs to Rebot are XML output files generated by Robot Framework test runs or
earlier Rebot executions. When more than one input file is given, a new top
level test suite containing suites in the given files is created. This allows
combining multiple outputs together to create higher level reports.

Depending is Robot Framework installed using Python, Jython, or IronPython
interpreter, Rebot can be run using `rebot`, `jyrebot` or `ipyrebot` command,
respectively. Alternatively, it is possible to directly execute `robot.rebot`
module (e.g. `python -m robot.rebot`) or `robot/rebot.py` script using a
selected interpreter. Finally, there is also a standalone JAR distribution.

For more information about Robot Framework run, for example, `pybot --help` or
go to http://robotframework.org.

Options
=======

 -N --name name           Set the name of the top level test suite. Underscores
                          in the name are converted to spaces. Default name is
                          created from the name of the executed data source.
 -D --doc documentation   Set the documentation of the top level test suite.
                          Underscores in the documentation are converted to
                          spaces and it may also contain simple HTML formatting
                          (e.g. *bold* and http://url/).
 -M --metadata name:value *  Set metadata of the top level test suite.
                          Underscores in the name and value are converted to
                          spaces. Value can contain same HTML formatting as
                          --doc. Example: `--metadata version:1.2`
 -G --settag tag *        Sets given tag(s) to all executed test cases.
 -t --test name *         Select test cases to run by name or long name. Name
                          is case and space insensitive and it can also be a
                          simple pattern where `*` matches anything and `?`
                          matches any char. If using `*` and `?` in the console
                          is problematic see --escape and --argumentfile.
 -s --suite name *        Select test suites by name. When this option is used
                          with --test, --include or --exclude, only test cases
                          in matching suites and also matching other filtering
                          criteria are selected. Given name can be a simple
                          pattern similarly as with --test.
 -i --include tag *       Select test cases to run by tag. Similarly as name in
                          --test, tag is case and space insensitive. There are
                          three ways to include test based on tags:
                          1) One tag as a simple pattern. Tests having a tag
                          matching the pattern are included. Example: `it-*`
                          2) Two or more tags (or patterns) separated by `&` or
                          `AND`. Only tests having all these tags are included.
                          Examples: `tag1&tag2`, `smokeANDowner-*ANDit-10`
                          3) Two or more tags (or patterns) separated by `NOT`.
                          Tests having the first tag but not any of the latter
                          ones are included. Example: `it-10NOTsmoke`
 -e --exclude tag *       Select test cases not to run by tag. These tests are
                          not run even if they are included with --include.
                          Tags are excluded using the rules explained in
                          --include.
    --processemptysuite   Processes output also if the top level test suite is
                          empty. Useful e.g. with --include/--exclude when it
                          is not an error that no test matches the condition.
 -c --critical tag *      Tests having given tag are considered critical. If no
                          critical tags are set, all tags are critical. Tags
                          can be given as a pattern like e.g. with --test.
                          Resets possible critical tags set earlier.
 -n --noncritical tag *   Tests with given tag are not critical even if they
                          have a tag set with --critical. Tag can be a pattern.
                          Resets possible non critical tags set earlier.
 -d --outputdir dir       Where to create output files. The default is the
                          directory where Rebot is run from and the given path
                          is considered relative to that unless it is absolute.
 -o --output file         XML output file. Not created unless this option is
                          specified. Given path, similarly as paths given to
                          --log and --report, is relative to --outputdir unless
                          given as an absolute path. Default: output.xml
 -l --log file            HTML log file. Can be disabled by giving a special
                          name `NONE`. Examples: `--log mylog.html`, `-l none`
 -r --report file         HTML report file. Can be disabled with `NONE`
                          similarly as --log. Default is `report.html`.
 -x --xunitfile file      xUnit compatible result file. Not created unless this
                          option is specified.
 -T --timestampoutputs    When this option is used, timestamp in a format
                          `YYYYMMDD-hhmmss` is added to all generated output
                          files between their basename and extension. For
                          example `-T -o output.xml -r report.html -l none`
                          creates files like `output-20070503-154410.xml` and
                          `report-20070503-154410.html`.
    --splitlog            Split log file into smaller pieces that open in
                          browser transparently.
    --logtitle title      Title for the generated test log. The default title
                          is `<Name Of The Suite> Test Log`. Underscores in
                          the title are converted into spaces in all titles.
    --reporttitle title   Title for the generated test report. The default
                          title is `<Name Of The Suite> Test Report`.
    --reportbackground colors  Background colors to use in the report file.
                          Either `all_passed:critical_passed:failed` or
                          `passed:failed`. Both color names and codes work.
                          Examples: --reportbackground green:yellow:red
                                    --reportbackground #00E:#E00
 -L --loglevel level      Threshold for selecting messages. Available levels:
                          TRACE (default), DEBUG, INFO, WARN, NONE (no msgs).
                          Use syntax `LOGLEVEL:DEFAULT` to define the default
                          visible log level in log files.
                          Examples: --loglevel DEBUG
                                    --loglevel DEBUG:INFO
    --suitestatlevel level  How many levels to show in `Statistics by Suite`
                          in log and report. By default all suite levels are
                          shown. Example:  --suitestatlevel 3
    --tagstatinclude tag *  Include only matching tags in `Statistics by Tag`
                          and `Test Details` in log and report. By default all
                          tags set in test cases are shown. Given `tag` can
                          also be a simple pattern (see e.g. --test).
    --tagstatexclude tag *  Exclude matching tags from `Statistics by Tag` and
                          `Test Details`. This option can be used with
                          --tagstatinclude similarly as --exclude is used with
                          --include.
    --tagstatcombine tags:name *  Create combined statistics based on tags.
                          These statistics are added into `Statistics by Tag`
                          and matching tests into `Test Details`. If optional
                          `name` is not given, name of the combined tag is got
                          from the specified tags. Tags are combined using the
                          rules explained in --include.
                          Examples: --tagstatcombine tag1ANDtag2:My_name
                                    --tagstatcombine requirement-*
    --tagdoc pattern:doc *  Add documentation to tags matching given pattern.
                          Documentation is shown in `Test Details` and also as
                          a tooltip in `Statistics by Tag`. Pattern can contain
                          characters `*` (matches anything) and `?` (matches
                          any char). Documentation can contain formatting
                          similarly as with --doc option.
                          Examples: --tagdoc mytag:My_documentation
                                    --tagdoc regression:*See*_http://info.html
                                    --tagdoc owner-*:Original_author
    --tagstatlink pattern:link:title *  Add external links into `Statistics by
                          Tag`. Pattern can contain characters `*` (matches
                          anything) and `?` (matches any char). Characters
                          matching to wildcard expressions can be used in link
                          and title with syntax %N, where N is index of the
                          match (starting from 1). In title underscores are
                          automatically converted to spaces.
                          Examples: --tagstatlink mytag:http://my.domain:Link
                          --tagstatlink bug-*:http://tracker/id=%1:Bug_Tracker
    --removekeywords all|passed|for|wuks *  Remove keyword data from all
                          generated outputs. Keywords containing warnings are
                          not removed except in `all` mode.
                          all:    remove data from all keywords
                          passed: remove data only from keywords in passed
                                  test cases and suites
                          for:    remove passed iterations from for loops
                          wuks:   remove all but last failing keyword from
                                  `Wait Until Keyword Succeeds`
    --starttime timestamp  Set starting time of test execution when creating
                          reports. Timestamp must be given in format
                          `2007-10-01 15:12:42.268` where all separators are
                          optional (e.g. `20071001151242268` is ok too) and
                          parts from milliseconds to hours can be omitted if
                          they are zero (e.g. `2007-10-01`). This can be used
                          to override starttime of the suite when reports are
                          created from a single suite or to set starttime for
                          combined suite, which is otherwise set to `N/A`.
    --endtime timestamp   Same as --starttime but for ending time. If both
                          options are used, elapsed time of the suite is
                          calculated based on them. For combined suites,
                          it is otherwise calculated by adding elapsed times
                          of combined test suites together.
    --nostatusrc          Sets the return code to zero regardless of failures
                          in test cases. Error codes are returned normally.
 -C --monitorcolors auto|on|ansi|off  Use colors on console output or not.
                          auto: use colors when output not redirected (default)
                          on:   always use colors
                          ansi: like `on` but use ANSI colors also on Windows
                          off:  disable colors altogether
                          Note that colors do not work with Jython on Windows.
 -E --escape what:with *  Escape characters which are problematic in console.
                          `what` is the name of the character to escape and
                          `with` is the string to escape it with. Note that
                          all given arguments, incl. data sources, are escaped
                          so escape characters ought to be selected carefully.
                          <---------------------ESCAPES----------------------->
                          Examples:
                          --escape space:_ --metadata X:Value_with_spaces
                          -E space:SP -E quot:Q -v var:QhelloSPworldQ
 -A --argumentfile path *  Text file to read more arguments from. File can have
                          both options and data sources one per line. Contents
                          do not need to be escaped but spaces in the beginning
                          and end of lines are removed. Empty lines and lines
                          starting with a hash character (#) are ignored.
                          Example file:
                          |  --include regression
                          |  --name Regression Tests
                          |  # This is a comment line
                          |  my_tests.html
                          |  path/to/test/directory/
 -h -? --help             Print usage instructions.
 --version                Print version information.

Options that are marked with an asterisk (*) can be specified multiple times.
For example, `--test first --test third` selects test cases with name `first`
and `third`. If other options are given multiple times, the last value is used.

Long option format is case-insensitive. For example, --SuiteStatLevel is
equivalent to but easier to read than --suitestatlevel. Long options can
also be shortened as long as they are unique. For example, `--logti Title`
works while `--lo log.html` does not because the former matches only --logtitle
but the latter matches both --log and --logtitle.

Environment Variables
=====================

ROBOT_SYSLOG_FILE         Path to a file where Robot Framework writes internal
                          information about processed files. Can be useful when
                          debugging problems. If not set, or set to special
                          value `NONE`, writing to the syslog file is disabled.
ROBOT_SYSLOG_LEVEL        Log level to use when writing to the syslog file.
                          Available levels are the same as for --loglevel
                          option to Robot and the default is INFO.

Examples
========

# Simple Rebot run that creates log and report with default names.
$ rebot output.xml

# Using options. Note that this is one long command split into multiple lines.
$ rebot --log smoke_log.html --report smoke_report.html --include smoke
        --ReportTitle Smoke_Tests --ReportBackground green:yellow:red
        --TagStatCombine tag1ANDtag2 path/to/myoutput.xml

# Executing `robot.rebot` module using Python and creating combined outputs.
$ python -m robot.rebot outputs/*.xml

# Running `robot/rebot.py` script with Jython.
$ jython path/robot/rebot.py -N Project_X -l none -r x.html output.xml
"""

import sys

# Allows running as a script. __name__ check needed with multiprocessing:
# http://code.google.com/p/robotframework/issues/detail?id=1137
if 'robot' not in sys.modules and __name__ == '__main__':
    import pythonpathsetter

from robot.conf import RebotSettings
from robot.errors import DataError
from robot.reporting import ResultWriter
from robot.output import LOGGER
from robot.utils import Application
from robot.run import RobotFramework


class Rebot(RobotFramework):

    def __init__(self):
        Application.__init__(self, USAGE, arg_limits=(1,), logger=LOGGER)

    def main(self, datasources, **options):
        settings = RebotSettings(options)
        LOGGER.register_console_logger(colors=settings['MonitorColors'],
                                       stdout=settings['StdOut'],
                                       stderr=settings['StdErr'])
        LOGGER.disable_message_cache()
        rc = ResultWriter(*datasources).write_results(settings)
        if rc < 0:
            raise DataError('No outputs created.')
        return rc


def rebot_cli(arguments):
    """Command line execution entry point for running rebot.

    For programmatic usage the :func:`rebot` method is typically better. It has
    better API for that usage and does not call :func:`sys.exit` like this
    method.
    """
    Rebot().execute_cli(arguments)


def rebot(*datasources, **options):
    """Creates reports/logs from given Robot output files with given options.

    Given input files are paths to Robot output files similarly as when running
    rebot from the command line. Options are given as keywords arguments and
    their names are same as long command line options without hyphens.

    Options that can be given on the command line multiple times can be
    passed as lists like `include=['tag1', 'tag2']`. Starting from 2.7.2,
    when such option is used only once, it can be given also as a single string
    like `include='tag'`.

    To capture stdout and/or stderr streams, pass open file objects in as
    special keyword arguments `stdout` and `stderr`, respectively.

    A return code is returned similarly as when running on the command line.

    Examples:

    .. code-block:: python

        rebot('path/to/output.xml')
        with open('stdout.txt', 'w') as stdout:
            rebot('o1.xml', 'o2.xml', report='r.html', log='NONE', stdout=stdout)

    Equivalent command line usage::

        rebot path/to/output.xml
        rebot --report r.html --log NONE o1.xml o2.xml > stdout.txt
    """
    return Rebot().execute(*datasources, **options)


if __name__ == '__main__':
    rebot_cli(sys.argv[1:])


########NEW FILE########
__FILENAME__ = jsbuildingcontext
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from contextlib import contextmanager
import os.path

from robot.output.loggerhelper import LEVELS
from robot.utils import (html_escape, html_format, get_link_path,
                         timestamp_to_secs)

from .stringcache import StringCache


class JsBuildingContext(object):

    def __init__(self, log_path=None, split_log=False, prune_input=False):
        # log_path can be a custom object in unit tests
        self._log_dir = os.path.dirname(log_path) \
                if isinstance(log_path, basestring) else None
        self._split_log = split_log
        self._prune_input = prune_input
        self._strings = self._top_level_strings = StringCache()
        self.basemillis = None
        self.split_results = []
        self.min_level = 'NONE'
        self._msg_links = {}

    def string(self, string, escape=True):
        if escape and string:   # string can, but should not, be None
            string = html_escape(string)
        return self._strings.add(string)

    def html(self, string):
        return self.string(html_format(string), escape=False)

    def relative_source(self, source):
        rel_source = get_link_path(source, self._log_dir) \
            if self._log_dir and source and os.path.exists(source) else ''
        return self.string(rel_source)

    def timestamp(self, time):
        if not time:
            return None
        # Must use `long` due to http://ironpython.codeplex.com/workitem/31549
        millis = long(round(timestamp_to_secs(time) * 1000))
        if self.basemillis is None:
            self.basemillis = millis
        return millis - self.basemillis

    def message_level(self, level):
        if LEVELS[level] < LEVELS[self.min_level]:
            self.min_level = level

    def create_link_target(self, msg):
        id = self._top_level_strings.add(msg.parent.id)
        self._msg_links[self._link_key(msg)] = id

    def link(self, msg):
        return self._msg_links.get(self._link_key(msg))

    def _link_key(self, msg):
        return (msg.message, msg.level, msg.timestamp)

    @property
    def strings(self):
        return self._strings.dump()

    def start_splitting_if_needed(self, split=False):
        if self._split_log and split:
            self._strings = StringCache()
            return True
        return False

    def end_splitting(self, model):
        self.split_results.append((model, self.strings))
        self._strings = self._top_level_strings
        return len(self.split_results)

    @contextmanager
    def prune_input(self, *items):
        yield
        if self._prune_input:
            for item in items:
                item.clear()

########NEW FILE########
__FILENAME__ = jsexecutionresult
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import time

from robot import utils

from .stringcache import StringIndex


class JsExecutionResult(object):

    def __init__(self, suite, statistics, errors, strings, basemillis=None,
                 split_results=None, min_level=None):
        self.suite = suite
        self.strings = strings
        self.min_level = min_level
        self.data = self._get_data(statistics, errors, basemillis or 0)
        self.split_results = split_results or []

    def _get_data(self, statistics, errors, basemillis):
        gentime = time.localtime()
        return {
            'stats': statistics,
            'errors': errors,
            'baseMillis': basemillis,
            'generatedMillis': long(time.mktime(gentime) * 1000) - basemillis,
            'generatedTimestamp': utils.format_time(gentime, gmtsep=' ')
        }

    def remove_data_not_needed_in_report(self):
        self.data.pop('errors')
        remover = _KeywordRemover()
        self.suite = remover.remove_keywords(self.suite)
        self.suite, self.strings \
                = remover.remove_unused_strings(self.suite, self.strings)


class _KeywordRemover(object):

    def remove_keywords(self, suite):
        return self._remove_keywords_from_suite(suite)

    def _remove_keywords_from_suite(self, suite):
        return suite[:6] + (self._remove_keywords_from_suites(suite[6]),
                            self._remove_keywords_from_tests(suite[7]),
                            (), suite[9])

    def _remove_keywords_from_suites(self, suites):
        return tuple(self._remove_keywords_from_suite(s) for s in suites)

    def _remove_keywords_from_tests(self, tests):
        return tuple(self._remove_keywords_from_test(t) for t in tests)

    def _remove_keywords_from_test(self, test):
        return test[:-1] + ((),)

    def remove_unused_strings(self, model, strings):
        used = set(self._get_used_indices(model))
        remap = {}
        strings = tuple(self._get_used_strings(strings, used, remap))
        model = tuple(self._remap_string_indices(model, remap))
        return model, strings

    def _get_used_indices(self, model):
        for item in model:
            if isinstance(item, StringIndex):
                yield item
            elif isinstance(item, tuple):
                for i in self._get_used_indices(item):
                    yield i

    def _get_used_strings(self, strings, used_indices, remap):
        offset = 0
        for index, string in enumerate(strings):
            if index in used_indices:
                remap[index] = index - offset
                yield string
            else:
                offset += 1

    def _remap_string_indices(self, model, remap):
        for item in model:
            if isinstance(item, StringIndex):
                yield remap[item]
            elif isinstance(item, tuple):
                yield tuple(self._remap_string_indices(item, remap))
            else:
                yield item

########NEW FILE########
__FILENAME__ = jsmodelbuilders
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

from robot.output import LEVELS

from .jsbuildingcontext import JsBuildingContext
from .jsexecutionresult import JsExecutionResult


class JsModelBuilder(object):

    def __init__(self, log_path=None, split_log=False,
                 prune_input_to_save_memory=False):
        self._context = JsBuildingContext(log_path, split_log,
                                          prune_input_to_save_memory)

    def build_from(self, result_from_xml):
        # Statistics must be build first because building suite may prune input.
        return JsExecutionResult(
            statistics=StatisticsBuilder().build(result_from_xml.statistics),
            suite=SuiteBuilder(self._context).build(result_from_xml.suite),
            errors=ErrorsBuilder(self._context).build(result_from_xml.errors),
            strings=self._context.strings,
            basemillis=self._context.basemillis,
            split_results=self._context.split_results,
            min_level=self._context.min_level
        )


class _Builder(object):
    _statuses = {'FAIL': 0, 'PASS': 1, 'NOT_RUN': 2}

    def __init__(self, context):
        self._context = context
        self._string = self._context.string
        self._html = self._context.html
        self._timestamp = self._context.timestamp

    def _get_status(self, item):
        model = (self._statuses[item.status],
                 self._timestamp(item.starttime),
                 item.elapsedtime)
        msg = getattr(item, 'message', '')
        return model if not msg else model + (self._string(msg),)

    def _build_keywords(self, kws, split=False):
        splitting = self._context.start_splitting_if_needed(split)
        model = tuple(self._build_keyword(k) for k in kws)
        return model if not splitting else self._context.end_splitting(model)


class SuiteBuilder(_Builder):

    def __init__(self, context):
        _Builder.__init__(self, context)
        self._build_suite = self.build
        self._build_test = TestBuilder(context).build
        self._build_keyword = KeywordBuilder(context).build

    def build(self, suite):
        with self._context.prune_input(suite.suites, suite.tests, suite.keywords):
            stats = self._get_statistics(suite)  # Must be done before pruning
            return (self._string(suite.name),
                    self._string(suite.source),
                    self._context.relative_source(suite.source),
                    self._html(suite.doc),
                    tuple(self._yield_metadata(suite)),
                    self._get_status(suite),
                    tuple(self._build_suite(s) for s in suite.suites),
                    tuple(self._build_test(t) for t in suite.tests),
                    tuple(self._build_keyword(k, split=True) for k in suite.keywords),
                    stats)

    def _yield_metadata(self, suite):
        for name, value in suite.metadata.iteritems():
            yield self._string(name)
            yield self._html(value)

    def _get_statistics(self, suite):
        stats = suite.statistics  # Access property only once
        return (stats.all.total,
                stats.all.passed,
                stats.critical.total,
                stats.critical.passed)


class TestBuilder(_Builder):

    def __init__(self, context):
        _Builder.__init__(self, context)
        self._build_keyword = KeywordBuilder(context).build

    def build(self, test):
        with self._context.prune_input(test.keywords):
            return (self._string(test.name),
                    self._string(test.timeout),
                    int(test.critical),
                    self._html(test.doc),
                    tuple(self._string(t) for t in test.tags),
                    self._get_status(test),
                    self._build_keywords(test.keywords, split=True))


class KeywordBuilder(_Builder):
    _types = {'kw': 0, 'setup': 1, 'teardown': 2, 'for': 3, 'foritem': 4}

    def __init__(self, context):
        _Builder.__init__(self, context)
        self._build_keyword = self.build
        self._build_message = MessageBuilder(context).build

    def build(self, kw, split=False):
        with self._context.prune_input(kw.messages, kw.keywords):
            return (self._types[kw.type],
                    self._string(kw.name),
                    self._string(kw.timeout),
                    self._html(kw.doc),
                    self._string(', '.join(kw.args)),
                    self._get_status(kw),
                    self._build_keywords(kw.keywords, split),
                    tuple(self._build_message(m) for m in kw.messages))


class MessageBuilder(_Builder):

    def build(self, msg):
        if msg.level == 'WARN':
            self._context.create_link_target(msg)
        self._context.message_level(msg.level)
        return self._build(msg)

    def _build(self, msg):
        return (self._timestamp(msg.timestamp),
                LEVELS[msg.level],
                self._string(msg.html_message, escape=False))


class StatisticsBuilder(object):

    def build(self, statistics):
        return (self._build_stats(statistics.total),
                self._build_stats(statistics.tags),
                self._build_stats(statistics.suite))

    def _build_stats(self, stats):
        return tuple(stat.get_attributes(include_label=True, include_elapsed=True,
                                         exclude_empty=True, html_escape=True)
                     for stat in stats)


class ErrorsBuilder(_Builder):

    def __init__(self, context):
        _Builder.__init__(self, context)
        self._build_message = ErrorMessageBuilder(context).build

    def build(self, errors):
        with self._context.prune_input(errors.messages):
            return tuple(self._build_message(msg) for msg in errors)


class ErrorMessageBuilder(MessageBuilder):

    def build(self, msg):
        model = self._build(msg)
        link = self._context.link(msg)
        return model if link is None else model + (link,)

########NEW FILE########
__FILENAME__ = jswriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot.htmldata import JsonWriter


class JsResultWriter(object):
    _output_attr = 'window.output'
    _settings_attr = 'window.settings'
    _suite_key = 'suite'
    _strings_key = 'strings'

    def __init__(self, output,
                 start_block='<script type="text/javascript">' + os.linesep,
                 end_block='</script>' + os.linesep,
                 split_threshold=9500):
        writer = JsonWriter(output, separator=end_block+start_block)
        self._write = writer.write
        self._write_json = writer.write_json
        self._start_block = start_block
        self._end_block = end_block
        self._split_threshold = split_threshold

    def write(self, result, settings):
        self._start_output_block()
        self._write_suite(result.suite)
        self._write_strings(result.strings)
        self._write_data(result.data)
        self._write_settings_and_end_output_block(settings)

    def _start_output_block(self):
        self._write(self._start_block, postfix='', separator=False)
        self._write('%s = {}' % self._output_attr)

    def _write_suite(self, suite):
        writer = SuiteWriter(self._write_json, self._split_threshold)
        writer.write(suite, self._output_var(self._suite_key))

    def _write_strings(self, strings):
        variable = self._output_var(self._strings_key)
        self._write('%s = []' % variable)
        prefix = '%s = %s.concat(' % (variable, variable)
        postfix = ');' + os.linesep
        threshold = self._split_threshold
        for index in xrange(0, len(strings), threshold):
            self._write_json(prefix, strings[index:index+threshold], postfix)

    def _write_data(self, data):
        for key in data:
            self._write_json('%s = ' % self._output_var(key), data[key])

    def _write_settings_and_end_output_block(self, settings):
        self._write_json('%s = ' % self._settings_attr, settings,
                         separator=False)
        self._write(self._end_block, postfix='', separator=False)

    def _output_var(self, key):
        return '%s["%s"]' % (self._output_attr, key)


class SuiteWriter(object):

    def __init__(self, write_json, split_threshold):
        self._write_json = write_json
        self._split_threshold = split_threshold

    def write(self, suite, variable):
        mapping = {}
        self._write_parts_over_threshold(suite, mapping)
        self._write_json('%s = ' % variable, suite, mapping=mapping)

    def _write_parts_over_threshold(self, data, mapping):
        if not isinstance(data, tuple):
            return 1
        not_written = 1 + sum(self._write_parts_over_threshold(item, mapping)
                              for item in data)
        if not_written > self._split_threshold:
            self._write_part(data, mapping)
            return 1
        return not_written

    def _write_part(self, data, mapping):
        part_name = 'window.sPart%d' % len(mapping)
        self._write_json('%s = ' % part_name, data, mapping=mapping)
        mapping[data] = part_name


class SplitLogWriter(object):

    def __init__(self, output):
        self._writer = JsonWriter(output)

    def write(self, keywords, strings, index, notify):
        self._writer.write_json('window.keywords%d = ' % index, keywords)
        self._writer.write_json('window.strings%d = ' % index, strings)
        self._writer.write('window.fileLoading.notify("%s")' % notify)

########NEW FILE########
__FILENAME__ = logreportwriters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
from os.path import basename, splitext
import codecs

from robot.htmldata import HtmlFileWriter, ModelWriter, LOG, REPORT
from robot.utils import utf8open

from .jswriter import JsResultWriter, SplitLogWriter


class _LogReportWriter(object):

    def __init__(self, js_model):
        self._js_model = js_model

    def _write_file(self, path, config, template):
        outfile = codecs.open(path, 'wb', encoding='UTF-8') \
            if isinstance(path, basestring) else path  # unit test hook
        with outfile:
            model_writer = RobotModelWriter(outfile, self._js_model, config)
            writer = HtmlFileWriter(outfile, model_writer)
            writer.write(template)


class LogWriter(_LogReportWriter):

    def write(self, path, config):
        self._write_file(path, config, LOG)
        if self._js_model.split_results:
            self._write_split_logs(splitext(path)[0])

    def _write_split_logs(self, base):
        for index, (keywords, strings) in enumerate(self._js_model.split_results):
            index += 1  # enumerate accepts start index only in Py 2.6+
            self._write_split_log(index, keywords, strings, '%s-%d.js' % (base, index))

    def _write_split_log(self, index, keywords, strings, path):
        with utf8open(path, 'wb') as outfile:
            writer = SplitLogWriter(outfile)
            writer.write(keywords, strings, index, basename(path))


class ReportWriter(_LogReportWriter):

    def write(self, path, config):
        self._write_file(path, config, REPORT)


class RobotModelWriter(ModelWriter):

    def __init__(self, output, model, config):
        self._output = output
        self._model = model
        self._config = config

    def write(self, line):
        JsResultWriter(self._output).write(self._model, self._config)

########NEW FILE########
__FILENAME__ = outputwriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.output.xmllogger import XmlLogger
from robot.result.visitor import ResultVisitor


# TODO: Unify XmlLogger and ResultVisitor APIs.
# Perhaps XmlLogger could be ResultVisitor.


class OutputWriter(XmlLogger, ResultVisitor):

    def __init__(self, output):
        XmlLogger.__init__(self, output, generator='Rebot')

    def start_message(self, msg):
        self._write_message(msg)

    def close(self):
        self._writer.end('robot')
        self._writer.close()

    def start_errors(self, errors):
        XmlLogger.start_errors(self)

    def end_errors(self, errors):
        XmlLogger.end_errors(self)

    def end_result(self, result):
        self.close()

    start_total_statistics = XmlLogger.start_total_stats
    start_tag_statistics = XmlLogger.start_tag_stats
    start_suite_statistics = XmlLogger.start_suite_stats
    end_total_statistics = XmlLogger.end_total_stats
    end_tag_statistics = XmlLogger.end_tag_stats
    end_suite_statistics = XmlLogger.end_suite_stats

    def visit_stat(self, stat):
        self._writer.element('stat', stat.name,
                             stat.get_attributes(values_as_strings=True))

########NEW FILE########
__FILENAME__ = resultwriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError
from robot.output import LOGGER
from robot.result import ExecutionResult
from robot.utils import unic

from .jsmodelbuilders import JsModelBuilder
from .logreportwriters import LogWriter, ReportWriter
from .xunitwriter import XUnitWriter


class ResultWriter(object):

    def __init__(self, *data_sources):
        self._data_sources = data_sources

    def write_results(self, settings, results=None):
        results = results or Results(self._data_sources, settings)
        if settings.output:
            self._write_output(results.result, settings.output)
        if settings.xunit:
            self._write_xunit(results.result, settings.xunit)
        if settings.log:
            config = dict(settings.log_config, minLevel=results.js_result.min_level)
            self._write_log(results.js_result, settings.log, config)
        if settings.report:
            results.js_result.remove_data_not_needed_in_report()
            self._write_report(results.js_result, settings.report, settings.report_config)
        return results.return_code

    def _write_output(self, result, path):
        self._write('Output', result.save, path)

    def _write_xunit(self, result, path):
        self._write('XUnit', XUnitWriter(result).write, path)

    def _write_log(self, js_result, path, config):
        self._write('Log', LogWriter(js_result).write, path, config)

    def _write_report(self, js_result, path, config):
        self._write('Report', ReportWriter(js_result).write, path, config)

    def _write(self, name, writer, path, *args):
        try:
            writer(path, *args)
        except DataError, err:
            LOGGER.error(unicode(err))
        except EnvironmentError, err:
            # `err.filename` can be different than `path` at least if reading
            # log/report templates or writing split log fails.
            # `unic` is needed due to http://bugs.jython.org/issue1825.
            LOGGER.error("Writing %s file '%s' failed: %s: %s" %
                         (name.lower(), path, err.strerror, unic(err.filename)))
        else:
            LOGGER.output_file(name, path)


class Results(object):

    def __init__(self, data_sources, settings):
        self._data_sources = data_sources \
            if not isinstance(data_sources, basestring) else [data_sources]
        self._settings = settings
        self._result = None
        self._js_result = None
        self.return_code = -1

    @property
    def result(self):
        if self._result is None:
            include_keywords = bool(self._settings.log or
                                    self._settings.output or
                                    self._settings.xunit)
            self._result = ExecutionResult(include_keywords=include_keywords,
                                           *self._data_sources)
            self._result.configure(self._settings.status_rc,
                                   self._settings.suite_config,
                                   self._settings.statistics_config)
            self.return_code = self._result.return_code
        return self._result

    @property
    def js_result(self):
        if self._js_result is None:
            builder = JsModelBuilder(log_path=self._settings.log,
                                     split_log=self._settings.split_log,
                                     prune_input_to_save_memory=True)
            self._js_result = builder.build_from(self.result)
            self._result = None
        return self._js_result

########NEW FILE########
__FILENAME__ = stringcache
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from operator import itemgetter

from robot.utils import compress_text


class StringIndex(long):
    # Methods below are needed due to http://bugs.jython.org/issue1828

    def __str__(self):
        return long.__str__(self).rstrip('L')

    def __nonzero__(self):
        return bool(long(self))


class StringCache(object):
    _compress_threshold = 80
    _use_compressed_threshold = 1.1
    _zero_index = StringIndex(0)

    def __init__(self):
        self._cache = {'*': self._zero_index}

    def add(self, text):
        if not text:
            return self._zero_index
        text = self._encode(text)
        if text not in self._cache:
            self._cache[text] = StringIndex(len(self._cache))
        return self._cache[text]

    def _encode(self, text):
        raw = self._raw(text)
        if raw in self._cache or len(raw) < self._compress_threshold:
            return raw
        compressed = compress_text(text)
        if len(compressed) * self._use_compressed_threshold < len(raw):
            return compressed
        return raw

    def _raw(self, text):
        return '*'+text

    def dump(self):
        return tuple(item[0] for item in sorted(self._cache.iteritems(),
                                                key=itemgetter(1)))

########NEW FILE########
__FILENAME__ = xunitwriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot.result.visitor import ResultVisitor
from robot.utils import XmlWriter


class XUnitWriter(object):

    def __init__(self, execution_result):
        self._execution_result = execution_result

    def write(self, output):
        writer = XUnitFileWriter(XmlWriter(output, encoding='UTF-8'))
        self._execution_result.visit(writer)


class XUnitFileWriter(ResultVisitor):
    """Provides an xUnit-compatible result file.

    Attempts to adhere to the de facto schema guessed by Peter Reilly, see:
    http://marc.info/?l=ant-dev&m=123551933508682
    """

    def __init__(self, xml_writer):
        self._writer = xml_writer
        self._root_suite = None

    def start_suite(self, suite):
        if self._root_suite:
            return
        self._root_suite = suite
        attrs = {'name': suite.name,
                 'tests': str(suite.statistics.all.total),
                 'errors': '0',
                 'failures': str(suite.statistics.all.failed),
                 'skip': '0'}
        self._writer.start('testsuite', attrs)

    def end_suite(self, suite):
        if suite is self._root_suite:
            self._writer.end('testsuite')

    def start_test(self, test):
        attrs = {'classname': test.parent.longname,
                 'name': test.name,
                 'time': self._time_as_seconds(test.elapsedtime)}
        self._writer.start('testcase', attrs)
        if not test.passed:
            test.visit(TestFailureWriter(self._writer))

    def _time_as_seconds(self, millis):
        return str(int(round(millis, -3) / 1000))

    def end_test(self, test):
        self._writer.end('testcase')

    def visit_keyword(self, kw):
        pass

    def end_result(self, result):
        self._writer.close()


class TestFailureWriter(ResultVisitor):

    def __init__(self, writer):
        self._writer = writer

    def start_test(self, test):
        self._writer.start('failure', {'message': test.message,
                                       'type': 'AssertionError'}, newline=False)

    def end_test(self, test):
        self._writer.end('failure')

    def visit_message(self, msg):
        """Populates the <failure> section, normally only with a 'Stacktrace'.

        There is a weakness here because filtering is based on message level:
        - DEBUG level is used by RF for 'Tracebacks' (what is expected here)
        - INFO and TRACE are used for keywords and arguments (not errors)
        - first FAIL message is already reported as <failure> attribute
        """
        if msg.level == 'DEBUG':
            self._writer.content(msg.message + '\n')

########NEW FILE########
__FILENAME__ = configurer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import utils
from robot.errors import DataError


class SuiteConfigurer(object):

    def __init__(self, name=None, doc=None, metadata=None, set_tags=None,
                 include_tags=None, exclude_tags=None, include_suites=None,
                 include_tests=None, process_empty_suite=False,
                 remove_keywords=None, log_level=None, critical=None,
                 noncritical=None, starttime=None, endtime=None):
        self.name = name
        self.doc = doc
        self.metadata = metadata
        self.set_tags = set_tags or []
        self.critical_tags = critical
        self.non_critical_tags = noncritical
        self.include_tags = include_tags
        self.exclude_tags = exclude_tags
        self.include_suites = include_suites
        self.include_tests = include_tests
        self.process_empty_suite = process_empty_suite
        self.remove_keywords = self._get_remove_keywords(remove_keywords)
        self.log_level = log_level
        self.starttime = self._get_time(starttime)
        self.endtime = self._get_time(endtime)

    def _get_remove_keywords(self, value):
        if value is None:
            return []
        if isinstance(value, basestring):
            return [value]
        return value

    @property
    def add_tags(self):
        return [t for t in self.set_tags if not t.startswith('-')]

    @property
    def remove_tags(self):
        return [t[1:] for t in self.set_tags if t.startswith('-')]

    def configure(self, suite):
        self._set_suite_attributes(suite)
        suite.filter(self.include_suites, self.include_tests,
                     self.include_tags, self.exclude_tags)
        if not (suite.test_count or self.process_empty_suite):
            self._raise_no_tests_error(suite.name)
        suite.set_tags(self.add_tags, self.remove_tags)
        for how in self.remove_keywords:
            suite.remove_keywords(how)
        suite.filter_messages(self.log_level)
        suite.set_criticality(self.critical_tags, self.non_critical_tags)

    def _set_suite_attributes(self, suite):
        if self.name:
            suite.name = self.name
        if self.doc:
            suite.doc = self.doc
        if self.metadata:
            suite.metadata.update(self.metadata)
        if self.starttime:
            suite.starttime = self.starttime
        if self.endtime:
            suite.endtime = self.endtime

    def _get_time(self, timestamp):
        if not timestamp:
            return None
        try:
            secs = utils.timestamp_to_secs(timestamp, seps=' :.-_')
        except ValueError:
            return None
        return utils.secs_to_timestamp(secs, millis=True)

    def _raise_no_tests_error(self, suite):
        selectors = '%s %s' % (self._get_test_selector_msgs(),
                               self._get_suite_selector_msg())
        msg = "Suite '%s' contains no tests %s" % (suite, selectors.strip())
        raise DataError(msg.strip() + '.')

    def _get_test_selector_msgs(self):
        parts = []
        for explanation, selector in [('with tags', self.include_tags),
                                      ('without tags', self.exclude_tags),
                                      ('named', self.include_tests)]:
            if selector:
               parts.append(self._format_selector_msg(explanation, selector))
        return utils.seq2str(parts, quote='')

    def _format_selector_msg(self, explanation, selector):
        if isinstance(selector, basestring):
            selector = [selector]
        if len(selector) == 1 and explanation[-1] == 's':
            explanation = explanation[:-1]
        return '%s %s' % (explanation, utils.seq2str(selector, lastsep=' or '))

    def _get_suite_selector_msg(self):
        if not self.include_suites:
            return ''
        return self._format_selector_msg('in suites', self.include_suites)

########NEW FILE########
__FILENAME__ = executionerrors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.model import ItemList
from robot.utils import setter

from .message import Message


class ExecutionErrors(object):
    message_class = Message

    def __init__(self, messages=None):
        self.messages = messages

    @setter
    def messages(self, msgs):
        return ItemList(self.message_class, items=msgs)

    def add(self, other):
        self.messages.extend(other.messages)

    def visit(self, visitor):
        visitor.visit_errors(self)

    def __iter__(self):
        return iter(self.messages)

    def __len__(self):
        return len(self.messages)

########NEW FILE########
__FILENAME__ = executionresult
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

from robot.model import Statistics
from robot.reporting.outputwriter import OutputWriter

from .executionerrors import ExecutionErrors
from .configurer import SuiteConfigurer
from .testsuite import TestSuite


class Result(object):
    """Contains results of test execution.

    :ivar source: Path to the xml file where results are read from.
    :ivar suite: Hierarchical :class:`~.testsuite.TestSuite` results.
    :ivar errors: Execution :class:`~.executionerrors.ExecutionErrors`.
    """

    def __init__(self, source=None, root_suite=None, errors=None):
        self.source = source
        self.suite = root_suite or TestSuite()
        self.errors = errors or ExecutionErrors()
        self.generator = None
        self._status_rc = True
        self._stat_config = {}

    @property
    def statistics(self):
        """Test execution :class:`~robot.model.statistics.Statistics`."""
        return Statistics(self.suite, **self._stat_config)

    @property
    def return_code(self):
        """Return code (integer) of test execution."""
        if self._status_rc:
            return min(self.suite.statistics.critical.failed, 250)
        return 0

    def configure(self, status_rc=True, suite_config={}, stat_config={}):
        SuiteConfigurer(**suite_config).configure(self.suite)
        self._status_rc = status_rc
        self._stat_config = stat_config

    def visit(self, visitor):
        visitor.visit_result(self)

    def save(self, path=None):
        self.visit(OutputWriter(path or self.source))


class CombinedResult(Result):

    def __init__(self, others):
        Result.__init__(self)
        for other in others:
            self.add_result(other)

    def add_result(self, other):
        self.suite.suites.append(other.suite)
        self.errors.add(other.errors)

########NEW FILE########
__FILENAME__ = keyword
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import model, utils

from .message import Message


class Keyword(model.Keyword):
    __slots__ = ['status', 'starttime', 'endtime', 'message']
    message_class = Message

    def __init__(self, name='', doc='', args=None, type='kw', timeout='',
                 status='FAIL', starttime=None, endtime=None):
        """Results of a single keyword.

        :ivar name: Keyword name.
        :ivar parent: :class:`~.testsuite.TestSuite` or
            :class:`~.testcase.TestCase` that contains this keyword.
        :ivar doc: Keyword documentation.
        :ivar args: Keyword arguments, a list of strings.
        :ivar type: 'SETUP', 'TEARDOWN' or 'KW'.
        :ivar timeout: Keyword timeout.
        :ivar messages: Log messages, a list of :class:`~.message.Message`
            instances.
        :ivar keywords: Child keyword results, a list of
            :class:`~.Keyword`. instances
        :ivar status: String 'PASS' of 'FAIL'.
        :ivar starttime: Keyword execution start time as a timestamp.
        :ivar endtime: Keyword execution end time as a timestamp.
        """
        model.Keyword.__init__(self, name, doc, args, type, timeout)
        self.status = status
        self.starttime = starttime
        self.endtime = endtime
        self.message = ''  # only used with suite teardowns

    @property
    def elapsedtime(self):
        return utils.get_elapsed_time(self.starttime, self.endtime)

    @property
    def passed(self):
        return self.status == 'PASS'

########NEW FILE########
__FILENAME__ = keywordremover
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import utils

from robot.model import SuiteVisitor, SkipAllVisitor


def KeywordRemover(how):
    return {
        'PASSED': PassedKeywordRemover,
        'FOR': ForLoopItemsRemover,
        'ALL': AllKeywordsRemover,
        'WUKS': WaitUntilKeywordSucceedsRemover,
    }.get(how.upper(), SkipAllVisitor)()


class _KeywordRemover(SuiteVisitor):
    _message = 'Keyword data removed using --RemoveKeywords option.'

    def __init__(self):
        self._removal_message = RemovalMessage(self._message)

    def _clear_content(self, kw):
        kw.keywords = []
        kw.messages = []
        self._removal_message.set(kw)

    def _failed_or_contains_warning(self, item):
        return not item.passed or self._contains_warning(item)

    def _contains_warning(self, item):
        contains_warning = ContainsWarning()
        item.visit(contains_warning)
        return contains_warning.result


class AllKeywordsRemover(_KeywordRemover):

    def visit_keyword(self, keyword):
        self._clear_content(keyword)


class PassedKeywordRemover(_KeywordRemover):

    def start_suite(self, suite):
        if not suite.statistics.all.failed:
            for keyword in suite.keywords:
                if not self._contains_warning(keyword):
                    self._clear_content(keyword)

    def visit_test(self, test):
        if not self._failed_or_contains_warning(test):
            for keyword in test.keywords:
                self._clear_content(keyword)

    def visit_keyword(self, keyword):
        pass


class ForLoopItemsRemover(_KeywordRemover):
    _message = '%d passing step%s removed using --RemoveKeywords option.'

    def start_keyword(self, kw):
        if kw.type == kw.FOR_LOOP_TYPE:
            before = len(kw.keywords)
            kw.keywords = self._remove_keywords(kw.keywords)
            self._removal_message.set_if_removed(kw, before)

    def _remove_keywords(self, keywords):
        return [kw for kw in keywords
                if self._failed_or_contains_warning(kw) or kw is keywords[-1]]


class WaitUntilKeywordSucceedsRemover(_KeywordRemover):
    _message = '%d failing step%s removed using --RemoveKeywords option.'

    def start_keyword(self, kw):
        if kw.name == 'BuiltIn.Wait Until Keyword Succeeds' and kw.keywords:
            before = len(kw.keywords)
            kw.keywords = self._remove_keywords(list(kw.keywords))
            self._removal_message.set_if_removed(kw, before)

    def _remove_keywords(self, keywords):
        include_from_end = 2 if keywords[-1].passed else 1
        return self._kws_with_warnings(keywords[:-include_from_end]) \
                + keywords[-include_from_end:]

    def _kws_with_warnings(self, keywords):
        return [kw for kw in keywords if self._contains_warning(kw)]


class ContainsWarning(SuiteVisitor):

    def __init__(self):
        self.result = False

    def start_suite(self, suite):
        return not self.result

    def start_test(self, test):
        return not self.result

    def start_keyword(self, keyword):
        return not self.result

    def visit_message(self, msg):
        if msg.level == 'WARN':
            self.result = True


class RemovalMessage(object):

    def __init__(self, message):
        self._message = message

    def set_if_removed(self, kw, len_before):
        removed = len_before - len(kw.keywords)
        if removed:
            self.set(kw, self._message % (removed, utils.plural_or_not(removed)))

    def set(self, kw, message=None):
        kw.doc = ('%s\n\n_%s_' % (kw.doc, message or self._message)).strip()

########NEW FILE########
__FILENAME__ = message
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import model


class Message(model.Message):
    __slots__ = []

########NEW FILE########
__FILENAME__ = messagefilter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.output.loggerhelper import IsLogged

from robot.model import SuiteVisitor


class MessageFilter(SuiteVisitor):

    def __init__(self, loglevel):
        self._is_logged = IsLogged(loglevel or 'TRACE')

    def start_keyword(self, keyword):
        keyword.messages = [msg for msg in keyword.messages
                            if self._is_logged(msg.level)]

########NEW FILE########
__FILENAME__ = resultbuilder
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

from robot.errors import DataError
from robot.utils import ET, ETSource, get_error_message

from .suiteteardownfailed import SuiteTeardownFailureHandler
from .xmlelementhandlers import XmlElementHandler
from .executionresult import Result, CombinedResult


def ExecutionResult(*sources, **options):
    """Constructs :class:`Result` object based on execution result xml file(s).

    :param sources: The Robot Framework output xml file(s).
    :param options: Configuration options passed to
                    :py:class:`~ExecutionResultBuilder` as keyword arguments.
                    New in 2.7.5.
    :returns: :py:class:`~.executionresult.Result` instance.

    See :py:mod:`robot.result` for usage example.
    """
    if not sources:
        raise DataError('One or more data source needed.')
    if len(sources) > 1:
        return _combined_result(sources, options)
    return _single_result(sources[0], options)

def _combined_result(sources, options):
    return CombinedResult(ExecutionResult(src, **options) for src in sources)

def _single_result(source, options):
    ets = ETSource(source)
    try:
        return ExecutionResultBuilder(ets, **options).build(Result(source))
    except IOError, err:
        error = err.strerror
    except:
        error = get_error_message()
    raise DataError("Reading XML source '%s' failed: %s" % (unicode(ets), error))


class ExecutionResultBuilder(object):

    def __init__(self, source, include_keywords=True):
        self._source = source \
            if isinstance(source, ETSource) else ETSource(source)
        self._include_keywords = include_keywords

    def build(self, result):
        # Parsing is performance optimized. Do not change without profiling!
        handler = XmlElementHandler(result)
        with self._source as source:
            self._parse(source, handler.start, handler.end)
        SuiteTeardownFailureHandler(result.generator).visit_suite(result.suite)
        return result

    def _parse(self, source, start, end):
        context = ET.iterparse(source, events=('start', 'end'))
        if not self._include_keywords:
            context = self._omit_keywords(context)
        for event, elem in context:
            if event == 'start':
                start(elem)
            else:
                end(elem)
                elem.clear()

    def _omit_keywords(self, context):
        started_kws = 0
        for event, elem in context:
            start = event == 'start'
            kw = elem.tag == 'kw'
            if kw and start:
                started_kws += 1
            if not started_kws:
                yield event, elem
            elif not start:
                elem.clear()
            if kw and not start:
                started_kws -= 1

########NEW FILE########
__FILENAME__ = suiteteardownfailed
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.model import SuiteVisitor


class SuiteTeardownFailureHandler(SuiteVisitor):

    def __init__(self, suite_generator):
        self._should_handle = suite_generator == 'ROBOT'

    def start_suite(self, suite):
        if not self._should_handle:
            return False

    def end_suite(self, suite):
        teardown = suite.keywords.teardown
        if teardown and not teardown.passed:
            suite.visit(SuiteTeardownFailed(teardown.message))

    def visit_test(self, test):
        pass

    def visit_keyword(self, keyword):
        pass


class SuiteTeardownFailed(SuiteVisitor):
    _normal_msg = 'Teardown of the parent suite failed:\n'
    _also_msg = '\n\nAlso teardown of the parent suite failed:\n'

    def __init__(self, error):
        self._normal_msg += error
        self._also_msg += error

    def visit_test(self, test):
        test.status = 'FAIL'
        test.message += self._also_msg if test.message else self._normal_msg

    def visit_keyword(self, keyword):
        pass

########NEW FILE########
__FILENAME__ = testcase
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import model, utils

from keyword import Keyword


class TestCase(model.TestCase):
    __slots__ = ['status', 'message', 'starttime', 'endtime']
    keyword_class = Keyword

    def __init__(self, name='', doc='', tags=None, timeout='', status='FAIL',
                 message='', starttime=None, endtime=None):
        """Results of a single test case.

        :ivar name: Test case name.
        :ivar parent: :class:`~.testsuite.TestSuite` that contains this test.
        :ivar doc: Test case documentation.
        :ivar tags: Test case tags, a list of strings.
        :ivar timeout: Test case timeout.
        :ivar keywords: Keyword results, a list of :class:`~.keyword.Keyword`.
            instances and contains also possible setup and teardown keywords.
        :ivar status: String 'PASS' of 'FAIL'.
        :ivar message: Possible failure message.
        :ivar starttime: Test case execution start time as a timestamp.
        :ivar endtime: Test case execution end time as a timestamp.
        """
        model.TestCase.__init__(self, name, doc, tags, timeout)
        self.status = status
        self.message = message
        self.starttime = starttime
        self.endtime = endtime

    @property
    def elapsedtime(self):
        return utils.get_elapsed_time(self.starttime, self.endtime)

    @property
    def passed(self):
        return self.status == 'PASS'

########NEW FILE########
__FILENAME__ = testsuite
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from itertools import chain

from robot.model import TotalStatisticsBuilder
from robot import model, utils

from messagefilter import MessageFilter
from keywordremover import KeywordRemover
from testcase import TestCase
from keyword import Keyword


class TestSuite(model.TestSuite):
    __slots__ = ['message', 'starttime', 'endtime']
    test_class = TestCase
    keyword_class = Keyword

    def __init__(self, source='', name='', doc='', metadata=None,
                 message='', starttime=None, endtime=None):
        """Results of a single test suite.

        :ivar parent: Parent :class:`TestSuite` or `None`.
        :ivar source: Path to the source file.
        :ivar name: Test suite name.
        :ivar doc: Test suite documentation.
        :ivar metadata: Test suite metadata as a dictionary.
        :ivar suites: Child suite results.
        :ivar tests: Test case results. a list of :class:`~.testcase.TestCase`
            instances.
        :ivar keywords: A list containing setup and teardown results.
        :ivar message: Possible failure message.
        :ivar starttime: Test suite execution start time as a timestamp.
        :ivar endtime: Test suite execution end time as a timestamp.
        """
        model.TestSuite.__init__(self, source, name, doc, metadata)
        self.message = message
        self.starttime = starttime
        self.endtime = endtime

    @property
    def status(self):
        return 'FAIL' if self.statistics.critical.failed else 'PASS'

    @property
    def statistics(self):
        return TotalStatisticsBuilder(self).stats

    @property
    def full_message(self):
        if not self.message:
            return self.statistics.message
        return '%s\n\n%s' % (self.message, self.statistics.message)

    @property
    def elapsedtime(self):
        if self.starttime and self.endtime:
            return utils.get_elapsed_time(self.starttime, self.endtime)
        return sum(child.elapsedtime for child in
                   chain(self.suites, self.tests, self.keywords))

    def remove_keywords(self, how):
        self.visit(KeywordRemover(how))

    def filter_messages(self, log_level='TRACE'):
        self.visit(MessageFilter(log_level))

########NEW FILE########
__FILENAME__ = visitor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.model import SuiteVisitor


class ResultVisitor(SuiteVisitor):

    def visit_result(self, result):
        if self.start_result(result) is not False:
            result.suite.visit(self)
            result.statistics.visit(self)
            result.errors.visit(self)
            self.end_result(result)

    def start_result(self, result):
        pass

    def end_result(self, result):
        pass

    def visit_statistics(self, stats):
        if self.start_statistics(stats) is not False:
            stats.total.visit(self)
            stats.tags.visit(self)
            stats.suite.visit(self)
            self.end_statistics(stats)

    def start_statistics(self, stats):
        pass

    def end_statistics(self, stats):
        pass

    def visit_total_statistics(self, stats):
        if self.start_total_statistics(stats) is not False:
            for stat in stats:
                stat.visit(self)
            self.end_total_statistics(stats)

    def start_total_statistics(self, stats):
        pass

    def end_total_statistics(self, stats):
        pass

    def visit_tag_statistics(self, stats):
        if self.start_tag_statistics(stats) is not False:
            for stat in stats:
                stat.visit(self)
            self.end_tag_statistics(stats)

    def start_tag_statistics(self, stats):
        pass

    def end_tag_statistics(self, stats):
        pass

    def visit_suite_statistics(self, stats):
        if self.start_suite_statistics(stats) is not False:
            for stat in stats:
                stat.visit(self)
            self.end_suite_statistics(stats)

    def start_suite_statistics(self, stats):
        pass

    def end_suite_statistics(self, suite_stats):
        pass

    def visit_stat(self, stat):
        if self.start_stat(stat) is not False:
            self.end_stat(stat)

    def start_stat(self, stat):
        pass

    def end_stat(self, stat):
        pass

    def visit_errors(self, errors):
        self.start_errors(errors)
        for msg in errors:
            msg.visit(self)
        self.end_errors(errors)

    def start_errors(self, errors):
        pass

    def end_errors(self, errors):
        pass

########NEW FILE########
__FILENAME__ = xmlelementhandlers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError


class XmlElementHandler(object):

    def __init__(self, execution_result, root_handler=None):
        self._stack = [(execution_result, root_handler or RootHandler())]

    def start(self, elem):
        result, handler = self._stack[-1]
        self._stack.append(handler.handle_child(elem, result))

    def end(self, elem):
        result, handler = self._stack.pop()
        handler.end(elem, result)


class _Handler(object):

    def __init__(self):
        self._child_map = dict((c.tag, c) for c in self._children())

    def _children(self):
        return []

    def handle_child(self, elem, result):
        try:
            handler = self._child_map[elem.tag]
        except KeyError:
            raise DataError("Incompatible XML element '%s'" % elem.tag)
        return handler.start(elem, result), handler

    def start(self, elem, result):
        return result

    def end(self, elem, result):
        pass

    def _timestamp(self, elem, attr_name):
        timestamp = elem.get(attr_name)
        return timestamp if timestamp != 'N/A' else None


class RootHandler(_Handler):

    def _children(self):
        return [RobotHandler()]


class RobotHandler(_Handler):
    tag = 'robot'

    def start(self, elem, result):
        result.generator = elem.get('generator', 'unknown').split()[0].upper()
        return result

    def _children(self):
        return [RootSuiteHandler(), StatisticsHandler(), ErrorsHandler()]


class SuiteHandler(_Handler):
    tag = 'suite'

    def start(self, elem, result):
        return result.suites.create(name=elem.get('name'),
                                    source=elem.get('source', ''))

    def _children(self):
        return [DocHandler(), MetadataHandler(), SuiteStatusHandler(),
                KeywordHandler(), TestCaseHandler(), self]


class RootSuiteHandler(SuiteHandler):

    def start(self, elem, result):
        result.suite.name = elem.get('name')
        result.suite.source = elem.get('source', '')
        return result.suite

    def _children(self):
        return SuiteHandler._children(self)[:-1] + [SuiteHandler()]


class TestCaseHandler(_Handler):
    tag = 'test'

    def start(self, elem, result):
        return result.tests.create(name=elem.get('name'),
                                   timeout=elem.get('timeout', ''))

    def _children(self):
        return [DocHandler(), TagsHandler(), TestStatusHandler(), KeywordHandler()]


class KeywordHandler(_Handler):
    tag = 'kw'

    def start(self, elem, result):
        return result.keywords.create(name=elem.get('name'),
                                      timeout=elem.get('timeout'),
                                      type=elem.get('type'))

    def _children(self):
        return [DocHandler(), ArgumentsHandler(), KeywordStatusHandler(),
                MessageHandler(), self]


class MessageHandler(_Handler):
    tag = 'msg'

    def end(self, elem, result):
        result.messages.create(elem.text or '',
                               elem.get('level'),
                               elem.get('html', 'no') == 'yes',
                               self._timestamp(elem, 'timestamp'))


class _StatusHandler(_Handler):
    tag = 'status'

    def _set_status(self, elem, result):
        result.status = elem.get('status', 'FAIL')

    def _set_message(self, elem, result):
        result.message = elem.text or ''

    def _set_times(self, elem, result):
        result.starttime = self._timestamp(elem, 'starttime')
        result.endtime = self._timestamp(elem, 'endtime')


class KeywordStatusHandler(_StatusHandler):

    def end(self, elem, result):
        self._set_status(elem, result)
        self._set_times(elem, result)
        if result.type == result.TEARDOWN_TYPE:
            self._set_message(elem, result)


class SuiteStatusHandler(_StatusHandler):

    def end(self, elem, result):
        self._set_message(elem, result)
        self._set_times(elem, result)


class TestStatusHandler(_StatusHandler):

    def end(self, elem, result):
        self._set_status(elem, result)
        self._set_message(elem, result)
        self._set_times(elem, result)


class DocHandler(_Handler):
    tag = 'doc'

    def end(self, elem, result):
        result.doc = elem.text or ''


class MetadataHandler(_Handler):
    tag = 'metadata'

    def _children(self):
        return [MetadataItemHandler()]


class MetadataItemHandler(_Handler):
    tag = 'item'

    def end(self, elem, result):
        result.metadata[elem.get('name')] = elem.text or ''


class TagsHandler(_Handler):
    tag = 'tags'

    def _children(self):
        return [TagHandler()]


class TagHandler(_Handler):
    tag = 'tag'

    def end(self, elem, result):
        result.tags.add(elem.text or '')


class ArgumentsHandler(_Handler):
    tag = 'arguments'

    def _children(self):
        return [ArgumentHandler()]


class ArgumentHandler(_Handler):
    tag = 'arg'

    def end(self, elem, result):
        result.args.append(elem.text or '')


class ErrorsHandler(_Handler):
    tag = 'errors'

    def start(self, elem, result):
        return result.errors

    def _children(self):
        return [MessageHandler()]


class StatisticsHandler(_Handler):
    tag = 'statistics'

    def handle_child(self, elem, result):
        return result, self

########NEW FILE########
__FILENAME__ = run
#!/usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

USAGE = """Robot Framework -- A keyword-driven test automation framework

Version:  <VERSION>

Usage:  pybot|jybot|ipybot [options] data_sources
   or:  python|jython|ipy -m robot.run [options] data_sources
   or:  python|jython|ipy path/to/robot/run.py [options] data_sources
   or:  java -jar robotframework.jar [options] data_sources

Robot Framework is a Python-based keyword-driven test automation framework for
acceptance level testing and acceptance test-driven development (ATDD). It has
an easy-to-use tabular syntax for creating test cases and its testing
capabilities can be extended by test libraries implemented either with Python
or Java. Users can also create new keywords from existing ones using the same
simple syntax that is used for creating test cases.

Depending is Robot Framework installed using Python, Jython, or IronPython
interpreter, it has a start-up script, `pybot`, `jybot` or `ipybot`,
respectively. Alternatively, it is possible to directly execute `robot.run`
module (e.g. `python -m robot.run`) or `robot/run.py` script using a selected
interpreter. Finally, there is also a standalone JAR distribution.

Data sources given to Robot Framework are either test case files or directories
containing them and/or other directories. Single test case file creates a test
suite containing all the test cases in it and a directory containing test case
files creates a higher level test suite with test case files or other
directories as sub test suites. If multiple data sources are given, a virtual
top level suite containing suites generated from given data sources is created.

By default Robot Framework creates an XML output file and a log and a report in
HTML format, but this can be configured using various options listed below.
Outputs in HTML format are for human consumption and XML output for integration
with other systems. XML outputs can also be combined and otherwise further
processed with `rebot` tool. Run `rebot --help` for more information.

Robot Framework is open source software released under Apache License 2.0.
Its copyrights are owned and development supported by Nokia Siemens Networks.
For more information about the framework see http://robotframework.org.

Options
=======

 -N --name name           Set the name of the top level test suite. Underscores
                          in the name are converted to spaces. Default name is
                          created from the name of the executed data source.
 -D --doc documentation   Set the documentation of the top level test suite.
                          Underscores in the documentation are converted to
                          spaces and it may also contain simple HTML formatting
                          (e.g. *bold* and http://url/).
 -M --metadata name:value *  Set metadata of the top level test suite.
                          Underscores in the name and value are converted to
                          spaces. Value can contain same HTML formatting as
                          --doc. Example: `--metadata version:1.2`
 -G --settag tag *        Sets given tag(s) to all executed test cases.
 -t --test name *         Select test cases to run by name or long name. Name
                          is case and space insensitive and it can also be a
                          simple pattern where `*` matches anything and `?`
                          matches any char. If using `*` and `?` in the console
                          is problematic see --escape and --argumentfile.
 -s --suite name *        Select test suites to run by name. When this option
                          is used with --test, --include or --exclude, only
                          test cases in matching suites and also matching other
                          filtering criteria are selected. Name can be a simple
                          pattern similarly as with --test and it can contain
                          parent name separated with a dot. For example
                          `-s X.Y` selects suite `Y` only if its parent is `X`.
 -i --include tag *       Select test cases to run by tag. Similarly as name in
                          --test, tag is case and space insensitive. There are
                          three ways to include test based on tags:
                          1) One tag as a simple pattern. Tests having a tag
                          matching the pattern are included. Example: `it-*`
                          2) Two or more tags (or patterns) separated by `&` or
                          `AND`. Only tests having all these tags are included.
                          Examples: `tag1&tag2`, `smokeANDowner-*ANDit-10`
                          3) Two or more tags (or patterns) separated by `NOT`.
                          Tests having the first tag but not any of the latter
                          ones are included. Example: `it-10NOTsmoke`
 -e --exclude tag *       Select test cases not to run by tag. These tests are
                          not run even if they are included with --include.
                          Tags are excluded using the rules explained in
                          --include.
 -c --critical tag *      Tests having given tag are considered critical. If no
                          critical tags are set, all tags are critical. Tags
                          can be given as a pattern like e.g. with --test.
 -n --noncritical tag *   Tests with given tag are not critical even if they
                          have a tag set with --critical. Tag can be a pattern.
 -v --variable name:value *  Set variables in the test data. Only scalar
                          variables are supported and name is given without
                          `${}`. See --escape for how to use special characters
                          and --variablefile for a more powerful variable
                          setting mechanism that allows also list variables.
                          Examples:
                          --variable str:Hello  =>  ${str} = `Hello`
                          -v str:Hi_World -E space:_  =>  ${str} = `Hi World`
                          -v x: -v y:42  =>  ${x} = ``, ${y} = `42`
 -V --variablefile path *  File to read variables from (e.g. `path/vars.py`).
                          Example file:
                          |  import random
                          |  __all__ = [`scalar`, `LIST__var`, `integer`]
                          |  scalar = `Hello world!`
                          |  LIST__var = [`Hello`, `list`, `world`]
                          |  integer = random.randint(1,10)
                          =>
                          ${scalar} = `Hello world!`
                          @{var} = [`Hello`,`list`,`world`]
                          ${integer} = <random integer from 1 to 10>
 -d --outputdir dir       Where to create output files. The default is the
                          directory where tests are run from and the given path
                          is considered relative to that unless it is absolute.
 -o --output file         XML output file. Given path, similarly as paths given
                          to --log, --report, --debugfile and --xunitfile, is
                          relative to --outputdir unless given as an absolute
                          path. Other output files are created based on XML
                          output files after the test execution and XML outputs
                          can also be further processed with Rebot tool. Can be
                          disabled by giving a special value `NONE`. In this
                          case, also log and report are automatically disabled.
                          Default: output.xml
 -l --log file            HTML log file. Can be disabled by giving a special
                          value `NONE`. Default: log.html
                          Examples: `--log mylog.html`, `-l NONE`
 -r --report file         HTML report file. Can be disabled with `NONE`
                          similarly as --log. Default: report.html
 -x --xunitfile file      xUnit compatible result file. Not created unless this
                          option is specified.
 -b --debugfile file      Debug file written during execution. Not created
                          unless this option is specified.
 -T --timestampoutputs    When this option is used, timestamp in a format
                          `YYYYMMDD-hhmmss` is added to all generated output
                          files between their basename and extension. For
                          example `-T -o output.xml -r report.html -l none`
                          creates files like `output-20070503-154410.xml` and
                          `report-20070503-154410.html`.
    --splitlog            Split log file into smaller pieces that open in
                          browser transparently.
    --logtitle title      Title for the generated test log. The default title
                          is `<Name Of The Suite> Test Log`. Underscores in
                          the title are converted into spaces in all titles.
    --reporttitle title   Title for the generated test report. The default
                          title is `<Name Of The Suite> Test Report`.
    --reportbackground colors  Background colors to use in the report file.
                          Either `all_passed:critical_passed:failed` or
                          `passed:failed`. Both color names and codes work.
                          Examples: --reportbackground green:yellow:red
                                    --reportbackground #00E:#E00
 -L --loglevel level      Threshold level for logging. Available levels: TRACE,
                          DEBUG, INFO (default), WARN, NONE (no logging). Use
                          syntax `LOGLEVEL:DEFAULT` to define the default
                          visible log level in log files.
                          Examples: --loglevel DEBUG
                                    --loglevel DEBUG:INFO
    --suitestatlevel level  How many levels to show in `Statistics by Suite`
                          in log and report. By default all suite levels are
                          shown. Example:  --suitestatlevel 3
    --tagstatinclude tag *  Include only matching tags in `Statistics by Tag`
                          and `Test Details` in log and report. By default all
                          tags set in test cases are shown. Given `tag` can
                          also be a simple pattern (see e.g. --test).
    --tagstatexclude tag *  Exclude matching tags from `Statistics by Tag` and
                          `Test Details`. This option can be used with
                          --tagstatinclude similarly as --exclude is used with
                          --include.
    --tagstatcombine tags:name *  Create combined statistics based on tags.
                          These statistics are added into `Statistics by Tag`
                          and matching tests into `Test Details`. If optional
                          `name` is not given, name of the combined tag is got
                          from the specified tags. Tags are combined using the
                          rules explained in --include.
                          Examples: --tagstatcombine tag1ANDtag2:My_name
                                    --tagstatcombine requirement-*
    --tagdoc pattern:doc *  Add documentation to tags matching given pattern.
                          Documentation is shown in `Test Details` and also as
                          a tooltip in `Statistics by Tag`. Pattern can contain
                          characters `*` (matches anything) and `?` (matches
                          any char). Documentation can contain formatting
                          similarly as with --doc option.
                          Examples: --tagdoc mytag:My_documentation
                                    --tagdoc regression:*See*_http://info.html
                                    --tagdoc owner-*:Original_author
    --tagstatlink pattern:link:title *  Add external links into `Statistics by
                          Tag`. Pattern can contain characters `*` (matches
                          anything) and `?` (matches any char). Characters
                          matching to wildcard expressions can be used in link
                          and title with syntax %N, where N is index of the
                          match (starting from 1). In title underscores are
                          automatically converted to spaces.
                          Examples: --tagstatlink mytag:http://my.domain:Link
                          --tagstatlink bug-*:http://tracker/id=%1:Bug_Tracker
    --removekeywords all|passed|for|wuks *  Remove keyword data from the
                          generated log file. Keywords containing warnings are
                          not removed except in `all` mode.
                          all:    remove data from all keywords
                          passed: remove data only from keywords in passed
                                  test cases and suites
                          for:    remove passed iterations from for loops
                          wuks:   remove all but last failing keyword from
                                  `Wait Until Keyword Succeeds`
    --listener class *    A class for monitoring test execution. Gets
                          notifications e.g. when a test case starts and ends.
                          Arguments to listener class can be given after class
                          name, using colon as separator. For example:
                          --listener MyListenerClass:arg1:arg2
    --warnonskippedfiles  If this option is used, skipped files will cause a
                          warning that is visible to console output and log
                          files. By default skipped files only cause an info
                          level syslog message.
    --nostatusrc          Sets the return code to zero regardless of failures
                          in test cases. Error codes are returned normally.
    --runemptysuite       Executes tests also if the top level test suite is
                          empty. Useful e.g. with --include/--exclude when it
                          is not an error that no test matches the condition.
    --runmode mode *      Possible values are `Random:Test`, `Random:Suite`,
                          `Random:All`, `ExitOnFailure`, `SkipTeardownOnExit`,
                          and `DryRun` (case-insensitive). First three change
                          the execution order of tests, suites, or both.
                          `ExitOnFailure` stops test execution if a critical
                          test fails. `SkipTeardownOnExit` causes teardowns to
                          be skipped if test execution is stopped prematurely.
                          In the `DryRun` test data is verified and tests run
                          so that library keywords are not executed.
 -W --monitorwidth chars  Width of the monitor output. Default is 78.
 -C --monitorcolors auto|on|ansi|off  Use colors on console output or not.
                          auto: use colors when output not redirected (default)
                          on:   always use colors
                          ansi: like `on` but use ANSI colors also on Windows
                          off:  disable colors altogether
                          Note that colors do not work with Jython on Windows.
 -K --monitormarkers auto|on|off  Show `.` (success) or `F` (failure) on
                          console when top level keywords in test cases end.
                          Values have same semantics as with --monitorcolors.
 -P --pythonpath path *   Additional locations (directories, ZIPs, JARs) where
                          to search test libraries from when they are imported.
                          Multiple paths can be given by separating them with a
                          colon (`:`) or using this option several times. Given
                          path can also be a glob pattern matching multiple
                          paths but then it normally must be escaped or quoted.
                          Examples:
                          --pythonpath libs/
                          --pythonpath /opt/testlibs:mylibs.zip:yourlibs
                          -E star:STAR -P lib/STAR.jar -P mylib.jar
 -E --escape what:with *  Escape characters which are problematic in console.
                          `what` is the name of the character to escape and
                          `with` is the string to escape it with. Note that
                          all given arguments, incl. data sources, are escaped
                          so escape characters ought to be selected carefully.
                          <--------------------ESCAPES------------------------>
                          Examples:
                          --escape space:_ --metadata X:Value_with_spaces
                          -E space:SP -E quot:Q -v var:QhelloSPworldQ
 -A --argumentfile path *  Text file to read more arguments from. Use special
                          path `STDIN` to read contents from the standard input
                          stream. File can have both options and data sources
                          one per line. Contents do not need to be escaped but
                          spaces in the beginning and end of lines are removed.
                          Empty lines and lines starting with a hash character
                          (#) are ignored.
                          Example file:
                          |  --include regression
                          |  --name Regression Tests
                          |  # This is a comment line
                          |  my_tests.html
                          |  path/to/test/directory/
                          Examples:
                          --argumentfile argfile.txt --argumentfile STDIN
 -h -? --help             Print usage instructions.
 --version                Print version information.

Options that are marked with an asterisk (*) can be specified multiple times.
For example, `--test first --test third` selects test cases with name `first`
and `third`. If other options are given multiple times, the last value is used.

Long option format is case-insensitive. For example, --SuiteStatLevel is
equivalent to but easier to read than --suitestatlevel. Long options can
also be shortened as long as they are unique. For example, `--logti Title`
works while `--lo log.html` does not because the former matches only --logtitle
but the latter matches --log, --loglevel and --logtitle.

Environment Variables
=====================

ROBOT_SYSLOG_FILE         Path to a file where Robot Framework writes internal
                          information about parsing test case files and running
                          tests. Can be useful when debugging problems. If not
                          set, or set to special value `NONE`, writing to the
                          syslog file is disabled.
ROBOT_SYSLOG_LEVEL        Log level to use when writing to the syslog file.
                          Available levels are the same as for --loglevel
                          option and the default is INFO.

Examples
========

# Simple test run with `pybot` without options.
$ pybot tests.html

# Using options and running with `jybot`.
$ jybot --include smoke --name Smoke_Tests path/to/tests.txt

# Executing `robot.run` module using Python.
$ python -m robot.run --test test1 --test test2 test_directory

# Running `robot/run.py` script with Jython.
$ jython /path/to/robot/run.py tests.robot

# Executing multiple test case files and using case-insensitive long options.
$ pybot --SuiteStatLevel 2 /my/tests/*.html /your/tests.html

# Setting syslog file before running tests.
$ export ROBOT_SYSLOG_FILE=/tmp/syslog.txt
$ pybot tests.tsv
"""

import sys
import os.path

# Allows running as a script. __name__ check needed with multiprocessing:
# http://code.google.com/p/robotframework/issues/detail?id=1137
if 'robot' not in sys.modules and __name__ == '__main__':
    import pythonpathsetter

from robot.conf import RobotSettings
from robot.errors import DataError
from robot.output import LOGGER, Output, pyloggingconf
from robot.reporting import ResultWriter
from robot.running import TestSuite, STOP_SIGNAL_MONITOR, namespace
from robot.utils import Application, seq2str
from robot.variables import init_global_variables


class RobotFramework(Application):

    def __init__(self):
        Application.__init__(self, USAGE, arg_limits=(1,), logger=LOGGER)

    def main(self, datasources, **options):
        STOP_SIGNAL_MONITOR.start()
        namespace.IMPORTER.reset()
        settings = RobotSettings(options)
        pyloggingconf.initialize(settings['LogLevel'])
        LOGGER.register_console_logger(width=settings['MonitorWidth'],
                                       colors=settings['MonitorColors'],
                                       markers=settings['MonitorMarkers'],
                                       stdout=settings['StdOut'],
                                       stderr=settings['StdErr'])
        init_global_variables(settings)
        suite = TestSuite(datasources, settings)
        output = Output(settings)
        suite.run(output)
        LOGGER.info("Tests execution ended. Statistics:\n%s" % suite.get_stat_message())
        output.close(suite)
        if settings.is_rebot_needed():
            output, settings = settings.get_rebot_datasource_and_settings()
            ResultWriter(output).write_results(settings)
        return suite.return_code

    def validate(self, options, arguments):
        if len(arguments) > 1:
            arguments = self._validate_arguments_exist(arguments)
        return options, arguments

    def _validate_arguments_exist(self, arguments):
        valid = []
        nonex = []
        for arg in arguments:
            (valid if os.path.exists(arg) else nonex).append(arg)
        if nonex:
            s, were = ('s', 'were') if len(nonex) > 1 else ('', 'was')
            LOGGER.warn("Argument%s %s did not exist and %s ignored. "
                        "Validate the used command line syntax."
                        % (s, seq2str(nonex), were))
            if not valid:
                raise DataError('No valid arguments given.')
        return valid


def run_cli(arguments):
    """Command line execution entry point for running tests.

    For programmatic usage the :func:`run` method is typically better. It has
    better API for that usage and does not call :func:`sys.exit` like this
    method.
    """
    RobotFramework().execute_cli(arguments)


def run(*datasources, **options):
    """Executes given Robot Framework data sources with given options.

    Data sources are paths to files and directories, similarly as when running
    pybot/jybot from the command line. Options are given as keywords arguments
    and their names are same as long command line options without hyphens.

    Options that can be given on the command line multiple times can be
    passed as lists like `include=['tag1', 'tag2']`. Starting from 2.7.2,
    when such option is used only once, it can be given also as a single string
    like `include='tag'`.

    To capture stdout and/or stderr streams, pass open file objects in as
    special keyword arguments `stdout` and `stderr`, respectively.

    A return code is returned similarly as when running on the command line.

    Example:

    .. code-block:: python

        run('path/to/tests.html', include=['tag1', 'tag2'])
        with open('stdout.txt', 'w') as stdout:
            run('t1.txt', 't2.txt', report='r.html', log='NONE', stdout=stdout)

    Equivalent command line usage::

        pybot --include tag1 --include tag2 path/to/tests.html
        pybot --report r.html --log NONE t1.txt t2.txt > stdout.txt
    """
    return RobotFramework().execute(*datasources, **options)


if __name__ == '__main__':
    run_cli(sys.argv[1:])


########NEW FILE########
__FILENAME__ = runner
#!/usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys

# Allows running as a script. __name__ check needed with multiprocessing:
# http://code.google.com/p/robotframework/issues/detail?id=1137
if 'robot' not in sys.modules and __name__ == '__main__':
    import pythonpathsetter

from robot import run_cli
from robot.output import LOGGER

LOGGER.warn("'robot/runner.py' entry point is deprecated and will be removed "
            "in Robot Framework 2.8. Use new 'robot/run.py' instead.")

if __name__ == '__main__':
    run_cli(sys.argv[1:])

########NEW FILE########
__FILENAME__ = arguments
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import inspect
from array import ArrayType
from functools import partial

from robot.errors import DataError, FrameworkError
from robot.variables import is_list_var, is_scalar_var
from robot import utils

if utils.is_jython:
    from javaargcoercer import ArgumentCoercer


class _KeywordArguments(object):
    _type = 'Keyword'

    def __init__(self, argument_source, kw_or_lib_name):
        self.name = kw_or_lib_name
        self.names, self.defaults, self.varargs, self.minargs, self.maxargs \
            = self._determine_args(argument_source)
        self._arg_limit_checker = _ArgLimitChecker(self.minargs, self.maxargs,
                                                   kw_or_lib_name, self._type)

    def _determine_args(self, handler_or_argspec):
        args, defaults, varargs = self._get_arg_spec(handler_or_argspec)
        minargs = len(args) - len(defaults)
        maxargs = len(args) if not varargs else sys.maxint
        return args, defaults, varargs, minargs, maxargs

    def resolve(self, args, variables, output=None):
        posargs, namedargs = self._resolve(args, variables, output)
        self.check_arg_limits(posargs, namedargs)
        self._tracelog_args(output, posargs, namedargs)
        return posargs, namedargs

    def _resolve(self, args, variables, output):
        return self._get_argument_resolver().resolve(args, output, variables)

    def check_arg_limits(self, args, namedargs={}):
        self._arg_limit_checker.check_arg_limits(args, namedargs)

    def check_arg_limits_for_dry_run(self, args):
        self._arg_limit_checker.check_arg_limits_for_dry_run(args)

    def _tracelog_args(self, logger, positional, named=None):
        if logger:
            message = partial(self._get_tracelog_arg_message, positional, named)
            logger.trace(message)

    def _get_tracelog_arg_message(self, positional, named):
        args = [utils.safe_repr(arg) for arg in positional]
        if named:
            args += ['%s=%s' % (utils.unic(name), utils.safe_repr(value))
                     for name, value in named.items()]
        return 'Arguments: [ %s ]' % ' | '.join(args)


class PythonKeywordArguments(_KeywordArguments):

    def _get_argument_resolver(self):
        return PythonKeywordArgumentResolver(self)

    def _get_arg_spec(self, handler):
        """Returns info about args in a tuple (args, defaults, varargs)

        args     - list of all accepted arguments except varargs
        defaults - list of default values
        varargs  - name of the argument accepting varargs or None
        """
        args, varargs, _, defaults = inspect.getargspec(handler)
        if inspect.ismethod(handler):
            args = args[1:]  # drop 'self'
        defaults = list(defaults) if defaults else []
        return args, defaults, varargs


class JavaKeywordArguments(_KeywordArguments):

    def __init__(self, handler_method, name):
        _KeywordArguments.__init__(self, handler_method, name)
        self.arg_coercer = ArgumentCoercer(self._get_signatures(handler_method))

    def _get_argument_resolver(self):
        return JavaKeywordArgumentResolver(self)

    def _determine_args(self, handler_method):
        signatures = self._get_signatures(handler_method)
        minargs, maxargs = self._get_arg_limits(signatures)
        return [], [], None, minargs, maxargs

    def _get_signatures(self, handler):
        co = self._get_code_object(handler)
        return co.argslist[:co.nargs]

    def _get_code_object(self, handler):
        try:
            return handler.im_func
        except AttributeError:
            return handler

    def _get_arg_limits(self, signatures):
        if not signatures:
            return self._no_signatures_arg_limits()
        elif len(signatures) == 1:
            return self._get_single_signature_arg_limits(signatures[0])
        else:
            return self._get_multi_signature_arg_limits(signatures)

    def _no_signatures_arg_limits(self):
        # This happens at least if class has no public constructors.
        # Better to accept all arguments and leave error handling for later.
        return 0, sys.maxint

    def _get_single_signature_arg_limits(self, signature):
        args = signature.args
        if len(args) > 0 and args[-1].isArray():
            mina = len(args) - 1
            maxa = sys.maxint
        else:
            mina = maxa = len(args)
        return mina, maxa

    def _get_multi_signature_arg_limits(self, signatures):
        mina = maxa = None
        for sig in signatures:
            argc = len(sig.args)
            if mina is None or argc < mina:
                mina = argc
            if maxa is None or argc > maxa:
                maxa = argc
        return mina, maxa


class DynamicKeywordArguments(_KeywordArguments):

    def _get_argument_resolver(self):
        return PythonKeywordArgumentResolver(self)

    def _get_arg_spec(self, argspec):
        if argspec is None:
            return [], [], '<unknown>'
        try:
            if isinstance(argspec, basestring):
                raise TypeError
            return self._parse_arg_spec(list(argspec))
        except TypeError:
            raise TypeError('Argument spec should be a list/array of strings')

    def _parse_arg_spec(self, argspec):
        if not argspec:
            return [], [], None
        args = []
        defaults = []
        vararg = None
        for token in argspec:
            if vararg is not None:
                raise TypeError
            if token.startswith('*'):
                vararg = token[1:]
                continue
            if '=' in token:
                arg, default = token.split('=', 1)
                args.append(arg)
                defaults.append(default)
                continue
            if defaults:
                raise TypeError
            args.append(token)
        return args, defaults, vararg


class RunKeywordArguments(PythonKeywordArguments):

    def __init__(self, argument_source, name, arg_resolution_index):
        PythonKeywordArguments.__init__(self, argument_source, name)
        self._arg_resolution_index = arg_resolution_index

    def _resolve(self, args, variables, output):
        args = variables.replace_run_kw_info(args, self._arg_resolution_index)
        return args, {}


class PythonInitArguments(PythonKeywordArguments):
    _type = 'Test Library'


class JavaInitArguments(JavaKeywordArguments):
    _type = 'Test Library'

    def resolve(self, args, variables=None):
        if variables:
            args = variables.replace_list(args)
        self.check_arg_limits(args)
        return args, {}


class UserKeywordArguments(object):

    def __init__(self, args, name):
        self.names, self.defaults, self.varargs = self._get_arg_spec(args)
        self.minargs = len(self.names) - len(self.defaults)
        maxargs = len(self.names) if not self.varargs else sys.maxint
        self._arg_limit_checker = _ArgLimitChecker(self.minargs, maxargs,
                                                   name, 'Keyword')

    def _get_arg_spec(self, origargs):
        """Returns argument spec in a tuple (args, defaults, varargs).

        args     - tuple of all accepted arguments
        defaults - tuple of default values
        varargs  - name of the argument accepting varargs or None

        Examples:
          ['${arg1}', '${arg2}']
            => ('${arg1}', '${arg2}'), (), None
          ['${arg1}', '${arg2}=default', '@{varargs}']
            => ('${arg1}', '${arg2}'), ('default',), '@{varargs}'
        """
        args = []
        defaults = []
        varargs = None
        for arg in origargs:
            if varargs:
                raise DataError('Only last argument can be a list')
            if is_list_var(arg):
                varargs = arg
                continue   # should be last round (otherwise DataError in next)
            arg, default = self._split_default(arg)
            if defaults and default is None:
                raise DataError('Non default argument after default arguments')
            if not is_scalar_var(arg):
                raise DataError("Invalid argument '%s'" % arg)
            args.append(arg)
            if default is not None:
                defaults.append(default)
        return args, defaults, varargs

    def _split_default(self, arg):
        if '=' not in arg:
            return arg, None
        return arg.split('=', 1)

    def resolve_arguments_for_dry_run(self, arguments):
        self._arg_limit_checker.check_arg_limits_for_dry_run(arguments)
        required_number_of_args = self.minargs + len(self.defaults)
        needed_args = required_number_of_args - len(arguments)
        if needed_args > 0:
            return self._fill_missing_args(arguments, needed_args)
        return arguments

    def _fill_missing_args(self, arguments, needed):
        return arguments + needed * [None]

    def resolve(self, arguments, variables, output):
        positional, varargs, named = self._resolve_arg_usage(arguments, variables, output)
        self._arg_limit_checker.check_arg_limits(positional+varargs, named)
        argument_values = self._resolve_arg_values(variables, named, positional)
        argument_values += varargs
        self._arg_limit_checker.check_missing_args(argument_values, len(arguments))
        return argument_values

    def _resolve_arg_usage(self, arguments, variables, output):
        resolver = UserKeywordArgumentResolver(self)
        positional, named = resolver.resolve(arguments, output=output)
        positional, named = self._replace_variables(variables, positional, named)
        return self._split_args_and_varargs(positional) + (named,)

    def _resolve_arg_values(self, variables, named, positional):
        template = self._template_for(variables)
        for name, value in named.items():
            template.set_value(self.names.index(name), value)
        for index, value in enumerate(positional):
            template.set_value(index, value)
        return template.as_list()

    def _template_for(self, variables):
        defaults = variables.replace_list(list(self.defaults))
        return UserKeywordArgsTemplate(self.minargs, defaults)

    def _replace_variables(self, variables, positional, named):
        for name in named:
            named[name] = variables.replace_scalar(named[name])
        return variables.replace_list(positional), named

    def set_variables(self, arg_values, variables, output):
        before_varargs, varargs = self._split_args_and_varargs(arg_values)
        for name, value in zip(self.names, before_varargs):
            variables[name] = value
        if self.varargs:
            variables[self.varargs] = varargs
        self._tracelog_args(output, variables)

    def _split_args_and_varargs(self, args):
        if not self.varargs:
            return args, []
        return args[:len(self.names)], args[len(self.names):]

    def _tracelog_args(self, logger, variables):
        logger.trace(partial(self._get_tracelog_arg_message, variables))

    def _get_tracelog_arg_message(self, variables):
        names = self.names + ([self.varargs] if self.varargs else [])
        args =  ['%s=%s' % (name, utils.safe_repr(variables[name]))
                 for name in names]
        return 'Arguments: [ %s ]' % ' | '.join(args)


class _MissingArg(object):
    def __getattr__(self, name):
        raise DataError


class UserKeywordArgsTemplate(object):

    def __init__(self, minargs, defaults):
        self._template = [_MissingArg() for _ in range(minargs)] + defaults
        self._already_set = set()

    def set_value(self, idx, value):
        if idx in self._already_set:
            raise FrameworkError
        self._already_set.add(idx)
        self._template[idx] = value

    def as_list(self):
        return self._template


class _ArgumentResolver(object):

    def __init__(self, arguments):
        self._arguments = arguments
        self._mand_arg_count = len(arguments.names) - len(arguments.defaults)

    def resolve(self, values, output, variables=None):
        positional, named = self._resolve_argument_usage(values, output)
        return self._resolve_variables(positional, named, variables)

    def _resolve_argument_usage(self, values, output):
        named = {}
        last_positional = self._get_last_positional_idx(values)
        used_names = self._arguments.names[:last_positional]
        for arg in values[last_positional:]:
            name, value = self._parse_named(arg)
            if name in named:
                raise DataError('Keyword argument %s repeated.' % name)
            if name in used_names:
                output.warn("Could not resolve named arguments because value "
                            "for argument '%s' was given twice." % name)
                return values, {}
            used_names.append(name)
            named[name] = value
        return values[:last_positional], named

    def _get_last_positional_idx(self, values):
        last_positional_idx = self._mand_arg_count
        named_allowed = True
        for arg in reversed(self._optional(values)):
            if not (named_allowed and self._is_named(arg)):
                named_allowed = False
                last_positional_idx += 1
        return last_positional_idx

    def _optional(self, values):
        return values[self._mand_arg_count:]

    def _is_named(self, arg):
        if self._is_str_with_kwarg_sep(arg):
            name, _ = self._split_from_kwarg_sep(arg)
            return self._is_arg_name(name)
        return False

    def _parse_named(self, arg):
        name, value = self._split_from_kwarg_sep(arg)
        return self._coerce(name), value

    def _is_str_with_kwarg_sep(self, arg):
        if not isinstance(arg, basestring):
            return False
        if '=' not in arg:
            return False
        return True

    def _split_from_kwarg_sep(self, arg):
        return arg.split('=', 1)

    def _is_arg_name(self, name):
        return self._arg_name(name) in self._arguments.names

    def _resolve_variables(self, posargs, kwargs, variables):
        posargs = self._replace_list(posargs, variables)
        for name, value in kwargs.items():
            kwargs[name] = self._replace_scalar(value, variables)
        return posargs, kwargs

    def _replace_list(self, values, variables):
        return variables.replace_list(values) if variables else values

    def _replace_scalar(self, value, variables):
        return variables.replace_scalar(value) if variables else value


class UserKeywordArgumentResolver(_ArgumentResolver):

    def _arg_name(self, name):
        return '${%s}' % name

    def _coerce(self, name):
        return '${%s}' % name


class PythonKeywordArgumentResolver(_ArgumentResolver):

    def _arg_name(self, name):
        return name

    def _coerce(self, name):
        return str(name)


class JavaKeywordArgumentResolver(object):

    def __init__(self, arguments):
        self._arguments = arguments
        self._minargs, self._maxargs = arguments.minargs, arguments.maxargs

    def resolve(self, values, output, variables):
        values = variables.replace_list(values)
        self._arguments.check_arg_limits(values)
        if self._expects_varargs() and self._last_is_not_list(values):
            values[self._minargs:] = [values[self._minargs:]]
        return self._arguments.arg_coercer(values), {}

    def _expects_varargs(self):
        return self._maxargs == sys.maxint

    def _last_is_not_list(self, args):
        return not (len(args) == self._minargs + 1
                    and isinstance(args[-1], (list, tuple, ArrayType)))


class _ArgLimitChecker(object):

    def __init__(self, minargs, maxargs, name, type_):
        self.minargs = minargs
        self.maxargs = maxargs
        self._name = name
        self._type = type_

    def check_arg_limits(self, args, namedargs={}):
        self._check_arg_limits(len(args) + len(namedargs))

    def check_arg_limits_for_dry_run(self, args):
        arg_count = len(args)
        scalar_arg_count = len([a for a in args if not is_list_var(a)])
        if scalar_arg_count <= self.minargs and arg_count - scalar_arg_count:
            arg_count = self.minargs
        self._check_arg_limits(arg_count)

    def _check_arg_limits(self, arg_count):
        if not self.minargs <= arg_count <= self.maxargs:
            self._raise_inv_args(arg_count)

    def check_missing_args(self, args, arg_count):
        for a in args:
            if isinstance(a, _MissingArg):
                self._raise_inv_args(arg_count)

    def _raise_inv_args(self, arg_count):
        minend = utils.plural_or_not(self.minargs)
        if self.minargs == self.maxargs:
            exptxt = "%d argument%s" % (self.minargs, minend)
        elif self.maxargs != sys.maxint:
            exptxt = "%d to %d arguments" % (self.minargs, self.maxargs)
        else:
            exptxt = "at least %d argument%s" % (self.minargs, minend)
        raise DataError("%s '%s' expected %s, got %d."
                        % (self._type, self._name, exptxt, arg_count))

########NEW FILE########
__FILENAME__ = context
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError
from robot.variables import GLOBAL_VARIABLES


class ExecutionContexts(object):

    def __init__(self):
        self._contexts = []

    @property
    def current(self):
        return self._contexts[-1] if self._contexts else None

    def __iter__(self):
        return iter(self._contexts)

    @property
    def namespaces(self):
        return (context.namespace for context in self)

    def start_suite(self, namespace, output, dry_run=False):
        self._contexts.append(_ExecutionContext(namespace, output, dry_run))
        return self.current

    def end_suite(self):
        self._contexts.pop()


# This is ugly but currently needed e.g. by BuiltIn
EXECUTION_CONTEXTS = ExecutionContexts()


class _ExecutionContext(object):
    _started_keywords_threshold = 42  # Jython on Windows don't work with higher

    def __init__(self, namespace, output, dry_run=False):
        self.namespace = namespace
        self.output = output
        self.dry_run = dry_run
        self._in_teardown = 0
        self._started_keywords = 0

    @property
    def teardown(self):
        if self._in_teardown:
            return True
        test_or_suite = self.namespace.test or self.namespace.suite
        return test_or_suite.status != 'RUNNING'

    def start_keyword_teardown(self, error):
        self.namespace.variables['${KEYWORD_STATUS}'] = 'FAIL' if error else 'PASS'
        self.namespace.variables['${KEYWORD_MESSAGE}'] = unicode(error or '')
        self._in_teardown += 1

    def end_keyword_teardown(self):
        self._in_teardown -= 1

    def get_current_vars(self):
        return self.namespace.variables

    def end_test(self, test):
        self.output.end_test(test)
        self.namespace.end_test()

    def end_suite(self, suite):
        self.output.end_suite(suite)
        self.namespace.end_suite()
        EXECUTION_CONTEXTS.end_suite()

    def output_file_changed(self, filename):
        self._set_global_variable('${OUTPUT_FILE}', filename)

    def replace_vars_from_setting(self, name, value, errors):
        return self.namespace.variables.replace_meta(name, value, errors)

    def log_file_changed(self, filename):
        self._set_global_variable('${LOG_FILE}', filename)

    def set_prev_test_variables(self, test):
        self._set_prev_test_variables(self.get_current_vars(), test.name,
                                      test.status, test.message)

    def copy_prev_test_vars_to_global(self):
        varz = self.get_current_vars()
        name, status, message = varz['${PREV_TEST_NAME}'], \
                    varz['${PREV_TEST_STATUS}'], varz['${PREV_TEST_MESSAGE}']
        self._set_prev_test_variables(GLOBAL_VARIABLES, name, status, message)

    def _set_prev_test_variables(self, destination, name, status, message):
        destination['${PREV_TEST_NAME}'] = name
        destination['${PREV_TEST_STATUS}'] = status
        destination['${PREV_TEST_MESSAGE}'] = message

    def _set_global_variable(self, name, value):
        self.namespace.variables.set_global(name, value)

    def report_suite_status(self, status, message):
        self.get_current_vars()['${SUITE_STATUS}'] = status
        self.get_current_vars()['${SUITE_MESSAGE}'] = message

    def start_test(self, test):
        self.namespace.start_test(test)
        self.output.start_test(test)

    def set_test_status_before_teardown(self, message, status):
        self.namespace.set_test_status_before_teardown(message, status)

    def get_handler(self, name):
        return self.namespace.get_handler(name)

    def start_keyword(self, keyword):
        self._started_keywords += 1
        if self._started_keywords > self._started_keywords_threshold:
            raise DataError('Maximum limit of started keywords exceeded.')
        self.output.start_keyword(keyword)

    def end_keyword(self, keyword):
        self.output.end_keyword(keyword)
        self._started_keywords -= 1

    def start_user_keyword(self, kw):
        self.namespace.start_user_keyword(kw)

    def end_user_keyword(self):
        self.namespace.end_user_keyword()

    def warn(self, message):
        self.output.warn(message)

    def trace(self, message):
        self.output.trace(message)

########NEW FILE########
__FILENAME__ = defaultvalues

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from fixture import Setup, Teardown
from timeouts import TestTimeout


class DefaultValues(object):

    def __init__(self, settings, parent_default_values=None):
        self._parent = parent_default_values
        self._setup = settings.test_setup
        self._teardown = settings.test_teardown
        self._timeout = settings.test_timeout
        self._force_tags = settings.force_tags
        self._default_tags = settings.default_tags
        self._test_template = settings.test_template

    def get_setup(self, tc_setup):
        setup = tc_setup if tc_setup.is_set() else self._get_default_setup()
        return Setup(setup.name, setup.args)

    def _get_default_setup(self):
        if self._setup.is_set() or not self._parent:
            return self._setup
        return self._parent._get_default_setup()

    def get_teardown(self, tc_teardown):
        td = tc_teardown if tc_teardown.is_set() else self._get_default_teardown()
        return Teardown(td.name, td.args)

    def _get_default_teardown(self):
        if self._teardown.is_set() or not self._parent:
            return self._teardown
        return self._parent._get_default_teardown()

    def get_timeout(self, tc_timeout):
        timeout = tc_timeout if tc_timeout.is_set() else self._get_default_timeout()
        return TestTimeout(timeout.value, timeout.message)

    def _get_default_timeout(self):
        if self._timeout.is_set() or not self._parent:
            return self._timeout
        return self._parent._get_default_timeout()

    def get_tags(self, tc_tags):
        tags = tc_tags if tc_tags.is_set() else self._default_tags
        return (tags + self._get_force_tags()).value

    def _get_force_tags(self):
        if not self._parent:
            return self._force_tags
        return self._force_tags + self._parent._get_force_tags()

    def get_template(self, template):
        tmpl = (template if template.is_set() else self._test_template).value
        return tmpl if tmpl and tmpl.upper() != 'NONE' else None

########NEW FILE########
__FILENAME__ = fixture
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import ExecutionFailed, DataError

from .keywords import Keyword


class _Fixture(object):

    def __init__(self, name, args):
        self.name = name or ''
        self.args = args
        self._keyword = None

    def replace_variables(self, variables, errors):
        if self.name:
            try:
                self.name = variables.replace_string(self.name)
            except DataError, err:
                errors.append('Replacing variables from %s failed: %s'
                              % (self.__class__.__name__, unicode(err)))
            if self.name.upper() != 'NONE':
                self._keyword = Keyword(self.name, self.args,
                                        type=type(self).__name__.lower())

    def run(self, context):
        if self._keyword:
            try:
                self._keyword.run(context)
            except ExecutionFailed, err:
                return err

    def serialize(self, serializer):
        if self._keyword:
            serializer.start_keyword(self._keyword)
            serializer.end_keyword(self._keyword)


class Setup(_Fixture):
    pass


class Teardown(_Fixture):
    pass

########NEW FILE########
__FILENAME__ = handlers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement

from robot import utils
from robot.errors import DataError
from robot.variables import is_list_var

from .arguments import (PythonKeywordArguments, JavaKeywordArguments,
                        DynamicKeywordArguments, RunKeywordArguments,
                        PythonInitArguments, JavaInitArguments)
from .keywords import Keywords, Keyword
from .outputcapture import OutputCapturer
from .runkwregister import RUN_KW_REGISTER
from .signalhandler import STOP_SIGNAL_MONITOR


if utils.is_jython:
    from org.python.core import PyReflectedFunction, PyReflectedConstructor

    def _is_java_init(init):
        return isinstance(init, PyReflectedConstructor)
    def _is_java_method(method):
        return hasattr(method, 'im_func') \
               and isinstance(method.im_func, PyReflectedFunction)
else:
    _is_java_init = _is_java_method = lambda item: False


def Handler(library, name, method):
    if RUN_KW_REGISTER.is_run_keyword(library.orig_name, name):
        return _RunKeywordHandler(library, name, method)
    if _is_java_method(method):
        return _JavaHandler(library, name, method)
    else:
        return _PythonHandler(library, name, method)


def DynamicHandler(library, name, method, doc, argspec):
    if RUN_KW_REGISTER.is_run_keyword(library.orig_name, name):
        return _DynamicRunKeywordHandler(library, name, method, doc, argspec)
    return _DynamicHandler(library, name, method, doc, argspec)


def InitHandler(library, method, docgetter=None):
    Init = _PythonInitHandler if not _is_java_init(method) else _JavaInitHandler
    return Init(library, '__init__', method, docgetter)


class _BaseHandler(object):
    type = 'library'
    _doc = ''

    def __init__(self, library, handler_name, handler_method):
        self.library = library
        self.name = utils.printable_name(handler_name, code_style=True)
        self.arguments = self._parse_arguments(handler_method)

    def _parse_arguments(self, handler_method):
        raise NotImplementedError(self.__class__.__name__)

    @property
    def doc(self):
        return self._doc

    @property
    def longname(self):
        return '%s.%s' % (self.library.name, self.name)

    @property
    def shortdoc(self):
        return self.doc.splitlines()[0] if self.doc else ''

    @property
    def libname(self):
        return self.library.name


class _RunnableHandler(_BaseHandler):

    def __init__(self, library, handler_name, handler_method):
        _BaseHandler.__init__(self, library, handler_name, handler_method)
        self._handler_name = handler_name
        self._method = self._get_initial_handler(library, handler_name,
                                                 handler_method)

    def _get_initial_handler(self, library, name, method):
        if library.scope == 'GLOBAL':
            return self._get_global_handler(method, name)
        return None

    def init_keyword(self, varz):
        pass

    def run(self, context, args):
        if context.dry_run:
            return self._dry_run(context, args)
        return self._run(context, args)

    def _dry_run(self, context, args):
        if self.longname == 'BuiltIn.Import Library':
            return self._run(context, args)
        self.arguments.check_arg_limits_for_dry_run(args)
        return None

    def _run(self, context, args):
        output = context.output
        positional, named = \
            self.arguments.resolve(args, context.get_current_vars(), output)
        runner = self._runner_for(self._current_handler(), output, positional,
                                  named, self._get_timeout(context.namespace))
        return self._run_with_output_captured_and_signal_monitor(runner, context)

    def _runner_for(self, handler, output, positional, named, timeout):
        if timeout and timeout.active:
            output.debug(timeout.get_message)
            return lambda: timeout.run(handler, args=positional, kwargs=named)
        return lambda: handler(*positional, **named)

    def _run_with_output_captured_and_signal_monitor(self, runner, context):
        with OutputCapturer():
            return self._run_with_signal_monitoring(runner, context)

    def _run_with_signal_monitoring(self, runner, context):
        try:
            STOP_SIGNAL_MONITOR.start_running_keyword(context.teardown)
            return runner()
        finally:
            STOP_SIGNAL_MONITOR.stop_running_keyword()

    def _current_handler(self):
        if self._method:
            return self._method
        return self._get_handler(self.library.get_instance(),
                                 self._handler_name)

    def _get_global_handler(self, method, name):
        return method

    def _get_handler(self, lib_instance, handler_name):
        return getattr(lib_instance, handler_name)

    def _get_timeout(self, namespace):
        timeoutable = self._get_timeoutable_items(namespace)
        if timeoutable:
            return min(item.timeout for item in timeoutable)
        return None

    def _get_timeoutable_items(self, namespace):
        items = namespace.uk_handlers[:]
        if self._test_running_and_not_in_teardown(namespace.test):
            items.append(namespace.test)
        return items

    def _test_running_and_not_in_teardown(self, test):
        return test and test.status == 'RUNNING'


class _PythonHandler(_RunnableHandler):

    def __init__(self, library, handler_name, handler_method):
        _RunnableHandler.__init__(self, library, handler_name, handler_method)
        self._doc = utils.getdoc(handler_method)

    def _parse_arguments(self, handler_method):
        return PythonKeywordArguments(handler_method, self.longname)


class _JavaHandler(_RunnableHandler):

    def _parse_arguments(self, handler_method):
        return JavaKeywordArguments(handler_method, self.longname)


class _DynamicHandler(_RunnableHandler):

    def __init__(self, library, handler_name, handler_method, doc='',
                 argspec=None):
        self._argspec = argspec
        _RunnableHandler.__init__(self, library, handler_name, handler_method)
        self._run_keyword_method_name = handler_method.__name__
        self._doc = doc is not None and utils.unic(doc) or ''

    def _parse_arguments(self, handler_method):
        return DynamicKeywordArguments(self._argspec, self.longname)

    def _get_handler(self, lib_instance, handler_name):
        runner = getattr(lib_instance, self._run_keyword_method_name)
        return self._get_dynamic_handler(runner, handler_name)

    def _get_global_handler(self, method, name):
        return self._get_dynamic_handler(method, name)

    def _get_dynamic_handler(self, runner, name):
        def handler(*args):
            return runner(name, list(args))
        return handler


class _RunKeywordHandler(_PythonHandler):

    def __init__(self, library, handler_name, handler_method):
        _PythonHandler.__init__(self, library, handler_name, handler_method)
        self._handler_method = handler_method

    def _run_with_signal_monitoring(self, runner, context):
        # With run keyword variants, only the keyword to be run can fail
        # and therefore monitoring should not raise exception yet.
        return runner()

    def _parse_arguments(self, handler_method):
        arg_index = self._get_args_to_process()
        return RunKeywordArguments(handler_method, self.longname, arg_index)

    def _get_args_to_process(self):
        return RUN_KW_REGISTER.get_args_to_process(self.library.orig_name,
                                                   self.name)

    def _get_timeout(self, namespace):
        return None

    def _dry_run(self, context, args):
        _RunnableHandler._dry_run(self, context, args)
        keywords = self._get_runnable_dry_run_keywords(context, args)
        keywords.run(context)

    def _get_runnable_dry_run_keywords(self, context, args):
        keywords = Keywords([])
        for keyword in self._get_dry_run_keywords(args):
            if self._variable_syntax_in(keyword.name, context):
                continue
            keywords.add_keyword(keyword)
        return keywords

    def _variable_syntax_in(self, kw_name, context):
        try:
            resolved = context.namespace.variables.replace_string(kw_name)
            #Variable can contain value, but it might be wrong,
            #therefore it cannot be returned
            return resolved != kw_name
        except DataError:
            return True

    def _get_dry_run_keywords(self, args):
        if self._handler_name == 'run_keyword_if':
            return list(self._get_run_kw_if_keywords(args))
        if self._handler_name == 'run_keywords':
            return list(self._get_run_kws_keywords(args))
        if 'name' in self.arguments.names and self._get_args_to_process() > 0:
            return self._get_default_run_kw_keywords(args)
        return []

    def _get_run_kw_if_keywords(self, given_args):
        for kw_call in self._get_run_kw_if_calls(given_args):
            if kw_call:
                yield Keyword(kw_call[0], kw_call[1:])

    def _get_run_kw_if_calls(self, given_args):
        while 'ELSE IF' in given_args:
            kw_call, given_args = self._split_run_kw_if_args(given_args, 'ELSE IF', 2)
            yield kw_call
        if 'ELSE' in given_args:
            kw_call, else_call = self._split_run_kw_if_args(given_args, 'ELSE', 1)
            yield kw_call
            yield else_call
        elif self._validate_kw_call(given_args):
            expr, kw_call = given_args[0], given_args[1:]
            if not is_list_var(expr):
                yield kw_call

    def _split_run_kw_if_args(self, given_args, control_word, required_after):
        index = given_args.index(control_word)
        expr_and_call = given_args[:index]
        remaining = given_args[index+1:]
        if not (self._validate_kw_call(expr_and_call) and
                self._validate_kw_call(remaining, required_after)):
            raise DataError("Invalid 'Run Keyword If' usage.")
        if is_list_var(expr_and_call[0]):
            return [], remaining
        return expr_and_call[1:], remaining

    def _validate_kw_call(self, kw_call, min_length=2):
        if len(kw_call) >= min_length:
            return True
        return any(is_list_var(item) for item in kw_call)

    def _get_run_kws_keywords(self, given_args):
        for kw_call in self._get_run_kws_calls(given_args):
            yield Keyword(kw_call[0], kw_call[1:])

    def _get_run_kws_calls(self, given_args):
        if 'AND' not in given_args:
            for kw_call in given_args:
                yield [kw_call,]
        else:
            while 'AND' in given_args:
                index = given_args.index('AND')
                kw_call, given_args = given_args[:index], given_args[index + 1:]
                yield kw_call
            if given_args:
                yield given_args

    def _get_default_run_kw_keywords(self, given_args):
        index = self.arguments.names.index('name')
        return [Keyword(given_args[index], given_args[index+1:])]


class _XTimesHandler(_RunKeywordHandler):

    def __init__(self, handler, name):
        _RunKeywordHandler.__init__(self, handler.library, handler.name,
                                    handler._handler_method)
        self.name = name
        self._doc = "*DEPRECATED* Replace X times syntax with 'Repeat Keyword'."

    def run(self, context, args):
        resolved_times = context.namespace.variables.replace_string(self.name)
        _RunnableHandler.run(self, context, [resolved_times] + args)

    @property
    def longname(self):
        return self.name


class _DynamicRunKeywordHandler(_DynamicHandler, _RunKeywordHandler):
    _parse_arguments = _RunKeywordHandler._parse_arguments
    _get_timeout = _RunKeywordHandler._get_timeout


class _PythonInitHandler(_PythonHandler):

    def __init__(self, library, handler_name, handler_method, docgetter):
        _PythonHandler.__init__(self, library, handler_name, handler_method)
        self._docgetter = docgetter

    @property
    def doc(self):
        if self._docgetter:
            self._doc = self._docgetter() or self._doc
            self._docgetter = None
        return self._doc

    def _parse_arguments(self, handler_method):
        return PythonInitArguments(handler_method, self.library.name)


class _JavaInitHandler(_BaseHandler):

    def __init__(self, library, handler_name, handler_method, docgetter):
        _BaseHandler.__init__(self, library, handler_name, handler_method)
        self._docgetter = docgetter

    @property
    def doc(self):
        if self._docgetter:
            self._doc = self._docgetter() or self._doc
            self._docgetter = None
        return self._doc

    def _parse_arguments(self, handler_method):
        return JavaInitArguments(handler_method, self.library.name)

########NEW FILE########
__FILENAME__ = importer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os.path
import copy

from robot.output import LOGGER
from robot.parsing import ResourceFile
from robot.errors import FrameworkError
from robot import utils

from .testlibraries import TestLibrary


class Importer(object):

    def __init__(self):
        self._library_cache = ImportCache()
        self._resource_cache = ImportCache()

    def reset(self):
        self.__init__()

    def import_library(self, name, args=None, alias=None, variables=None):
        lib = TestLibrary(name, args, variables, create_handlers=False)
        positional, named = lib.positional_args, lib.named_args
        lib = self._import_library(name, positional, named, lib)
        if alias and name != alias:
            lib = self._copy_library(lib, alias)
            LOGGER.info("Imported library '%s' with name '%s'" % (name, alias))
        return lib

    def import_resource(self, path):
        if path in self._resource_cache:
            LOGGER.info("Found resource file '%s' from cache" % path)
        else:
            resource = ResourceFile(path).populate()
            self._resource_cache[path] = resource
        return self._resource_cache[path]

    def _import_library(self, name, positional, named, lib):
        args = positional + ['%s=%s' % arg for arg in sorted(named.items())]
        key = (name, positional, named)
        if key in self._library_cache:
            LOGGER.info("Found test library '%s' with arguments %s from cache"
                        % (name, utils.seq2str2(args)))
            return self._library_cache[key]
        lib.create_handlers()
        self._library_cache[key] = lib
        self._log_imported_library(name, args, lib)
        return lib

    def _log_imported_library(self, name, args, lib):
        type = lib.__class__.__name__.replace('Library', '').lower()[1:]
        LOGGER.info("Imported library '%s' with arguments %s "
                    "(version %s, %s type, %s scope, %d keywords)"
                    % (name, utils.seq2str2(args), lib.version or '<unknown>',
                       type, lib.scope.lower(), len(lib)))
        if not lib:
            LOGGER.warn("Imported library '%s' contains no keywords" % name)

    def _copy_library(self, lib, newname):
        libcopy = copy.copy(lib)
        libcopy.name = newname
        libcopy.init_scope_handling()
        libcopy.handlers = utils.NormalizedDict(ignore=['_'])
        for handler in lib.handlers.values():
            handcopy = copy.copy(handler)
            handcopy.library = libcopy
            libcopy.handlers[handler.name] = handcopy
        return libcopy


class ImportCache:
    """Keeps track on and optionally caches imported items.

    Handles paths in keys case-insensitively on case-insensitive OSes.
    Unlike dicts, this storage accepts mutable values in keys.
    """

    def __init__(self):
        self._keys = []
        self._items = []

    def __setitem__(self, key, item):
        if not isinstance(key, (basestring, tuple)):
            raise FrameworkError('Invalid key for ImportCache')
        key = self._norm_path_key(key)
        if key not in self._keys:
            self._keys.append(key)
            self._items.append(item)
        else:
            self._items[self._keys.index(key)] = item

    def add(self, key, item=None):
        self.__setitem__(key, item)

    def __getitem__(self, key):
        key = self._norm_path_key(key)
        if key not in self._keys:
            raise KeyError
        return self._items[self._keys.index(key)]

    def __contains__(self, key):
        return self._norm_path_key(key) in self._keys

    def values(self):
        return self._items

    def _norm_path_key(self, key):
        if self._is_path(key):
            return utils.normpath(key)
        if isinstance(key, tuple):
            return tuple(self._norm_path_key(k) for k in key)
        return key

    def _is_path(self, key):
        return isinstance(key, basestring) and os.path.isabs(key) and os.path.exists(key)

########NEW FILE########
__FILENAME__ = javaargcoercer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
from java.lang import Byte, Short, Integer, Long, Boolean, Float, Double


class ArgumentCoercer:

    def __init__(self, signatures):
        types = self._parse_types(signatures)
        self._coercers = [_CoercionFunction(t, i+1) for i, t in types]

    def _parse_types(self, signatures):
        types = {}
        for sig in signatures:
            for index, arg in enumerate(sig.args):
                types.setdefault(index, []).append(arg)
        return sorted(types.items())

    def __call__(self, args):
        return [coercer(arg) for coercer, arg in zip(self._coercers, args)]


class _CoercionFunction:
    _bool_types = [Boolean]
    _int_types = [Byte, Short, Integer, Long]
    _float_types = [Float, Double]
    _bool_primitives = ['boolean']
    _int_primitives = ['byte', 'short', 'int', 'long']
    _float_primitives = ['float', 'double']
    _bool_primitives = ["<type 'boolean'>"]
    _int_primitives = ["<type '%s'>" % p for p in _int_primitives]
    _float_primitives = ["<type '%s'>" % p for p in _float_primitives]

    def __init__(self, arg_types, position):
        self._position = position
        self.__coercer = None
        for arg in arg_types:
            if not (self._set_bool(arg) or
                    self._set_int(arg) or
                    self._set_float(arg)):
                self.__coercer = self._no_coercion

    def __call__(self, arg):
        if not isinstance(arg, basestring):
            return arg
        return self.__coercer(arg)

    def _set_bool(self, arg):
        return self._set_coercer(arg, self._bool_types,
                                 self._bool_primitives, self._to_bool)

    def _set_int(self, arg):
        return self._set_coercer(arg, self._int_types,
                                 self._int_primitives, self._to_int)

    def _set_float(self, arg):
        return self._set_coercer(arg, self._float_types,
                                 self._float_primitives, self._to_float)

    def _set_coercer(self, arg, type_list, primitive_list, coercer):
        if arg in type_list or str(arg) in primitive_list:
            if self.__coercer is None:
                self.__coercer = coercer
            elif self.__coercer != coercer:
                self.__coercer = self._no_coercion
            return True
        return False

    def _to_bool(self, arg):
        try:
            return {'false': False, 'true': True}[arg.lower()]
        except KeyError:
            self._coercion_failed('boolean')

    def _to_int(self, arg):
        try:
            return int(arg)
        except ValueError:
            self._coercion_failed('integer')

    def _to_float(self, arg):
        try:
            return float(arg)
        except ValueError:
            self._coercion_failed('floating point number')

    def _no_coercion(self, arg):
        return arg

    def _coercion_failed(self, arg_type):
        raise ValueError('Argument at position %d cannot be coerced to %s'
                         % (self._position, arg_type))

########NEW FILE########
__FILENAME__ = keywords
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.utils import (format_assign_message, get_elapsed_time,
                         get_error_message, get_timestamp, plural_or_not)
from robot.errors import (DataError, ExecutionFailed, ExecutionFailures,
                          HandlerExecutionFailed)
from robot.common import BaseKeyword
from robot.variables import is_scalar_var, VariableAssigner


class Keywords(object):

    def __init__(self, steps, template=None):
        self._keywords = []
        self._templated = bool(template)
        if self._templated:
            steps = [s.apply_template(template) for s in steps]
        for s in steps:
            self._add_step(s, template)

    def _add_step(self, step, template):
        if step.is_comment():
            return
        if step.is_for_loop():
            keyword = ForLoop(step, template)
        else:
            keyword = Keyword(step.keyword, step.args, step.assign)
        self.add_keyword(keyword)

    def add_keyword(self, keyword):
        self._keywords.append(keyword)

    def run(self, context):
        errors = []
        for kw in self._keywords:
            try:
                kw.run(context)
            except ExecutionFailed, err:
                errors.extend(err.get_errors())
                if not err.can_continue(context.teardown, self._templated,
                                        context.dry_run):
                    break
        if errors:
            raise ExecutionFailures(errors)

    def __nonzero__(self):
        return bool(self._keywords)

    def __iter__(self):
        return iter(self._keywords)


class Keyword(BaseKeyword):

    def __init__(self, name, args, assign=None, type='kw'):
        BaseKeyword.__init__(self, name, args, type=type)
        self.assign = assign or []
        self.handler_name = name

    def run(self, context):
        handler = self._start(context)
        try:
            return_value = self._run(handler, context)
        except ExecutionFailed, err:
            self.status = 'FAIL' if not err.exit_for_loop else 'PASS'
            self._end(context, error=err)
            raise
        else:
            if not (context.dry_run and handler.type == 'library'):
                self.status = 'PASS'
            self._end(context, return_value)
            return return_value

    def _start(self, context):
        handler = context.get_handler(self.handler_name)
        handler.init_keyword(context.get_current_vars())
        self.name = self._get_name(handler.longname)
        self.doc = handler.shortdoc
        self.timeout = getattr(handler, 'timeout', '')
        self.starttime = get_timestamp()
        context.start_keyword(self)
        if self.doc.startswith('*DEPRECATED*'):
            msg = self.doc.replace('*DEPRECATED*', '', 1).strip()
            name = self.name.split('} = ', 1)[-1]  # Remove possible variable
            context.warn("Keyword '%s' is deprecated. %s" % (name, msg))
        return handler

    def _get_name(self, handler_longname):
        if not self.assign:
            return handler_longname
        return '%s = %s' % (', '.join(a.rstrip('= ') for a in self.assign),
                            handler_longname)

    def _run(self, handler, context):
        try:
            return handler.run(context, self.args[:])
        except ExecutionFailed:
            raise
        except:
            self._report_failure(context)

    def _end(self, context, return_value=None, error=None):
        self.endtime = get_timestamp()
        self.elapsedtime = get_elapsed_time(self.starttime, self.endtime)
        if error and self.type == 'teardown':
            self.message = unicode(error)
        try:
            if not error or error.can_continue(context.teardown):
                self._set_variables(context, return_value, error)
        finally:
            context.end_keyword(self)

    def _set_variables(self, context, return_value, error):
        if error:
            return_value = error.return_value
        try:
            VariableAssigner(self.assign).assign(context, return_value)
        except DataError, err:
            self.status = 'FAIL'
            msg = unicode(err)
            context.output.fail(msg)
            raise ExecutionFailed(msg, syntax=True)

    def _report_failure(self, context):
        failure = HandlerExecutionFailed()
        if not failure.exit_for_loop:
            context.output.fail(failure.full_message)
            if failure.traceback:
                context.output.debug(failure.traceback)
        raise failure


class ForLoop(BaseKeyword):

    def __init__(self, forstep, template=None):
        BaseKeyword.__init__(self, self._get_name(forstep), type='for')
        self.vars = forstep.vars
        self.items = forstep.items
        self.range = forstep.range
        self.keywords = Keywords(forstep.steps, template)
        self._templated = bool(template)

    def _get_name(self, data):
        return '%s %s [ %s ]' % (' | '.join(data.vars),
                                 'IN' if not data.range else 'IN RANGE',
                                 ' | '.join(data.items))

    def run(self, context):
        self.starttime = get_timestamp()
        context.start_keyword(self)
        error = self._run_with_error_handling(self._validate_and_run, context)
        self.status = 'PASS' if not error else 'FAIL'
        self.endtime = get_timestamp()
        self.elapsedtime = get_elapsed_time(self.starttime, self.endtime)
        context.end_keyword(self)
        if error:
            raise error

    def _run_with_error_handling(self, runnable, context):
        try:
            runnable(context)
        except ExecutionFailed, err:
            return err
        except DataError, err:
            msg = unicode(err)
            context.output.fail(msg)
            return ExecutionFailed(msg, syntax=True)
        else:
            return None

    def _validate_and_run(self, context):
        self._validate()
        self._run(context)

    def _validate(self):
        if not self.vars:
            raise DataError('FOR loop has no loop variables.')
        for var in self.vars:
            if not is_scalar_var(var):
                raise DataError("Invalid FOR loop variable '%s'." % var)
        if not self.items:
            raise DataError('FOR loop has no loop values.')
        if not self.keywords:
            raise DataError('FOR loop contains no keywords.')

    def _run(self, context):
        errors = []
        items, iteration_steps = self._get_items_and_iteration_steps(context)
        for i in iteration_steps:
            values = items[i:i+len(self.vars)]
            err = self._run_one_round(context, self.vars, values)
            if err:
                if err.exit_for_loop:
                    break
                errors.extend(err.get_errors())
                if not err.can_continue(context.teardown, self._templated,
                                        context.dry_run):
                    break
        if errors:
            raise ExecutionFailures(errors)

    def _get_items_and_iteration_steps(self, context):
        if context.dry_run:
            return self.vars, [0]
        items = self._replace_vars_from_items(context.get_current_vars())
        return items, range(0, len(items), len(self.vars))

    def _run_one_round(self, context, variables, values):
        foritem = _ForItem(variables, values)
        context.start_keyword(foritem)
        for var, value in zip(variables, values):
            context.get_current_vars()[var] = value
        error = self._run_with_error_handling(self.keywords.run, context)
        foritem.end('PASS' if not error or error.exit_for_loop else 'FAIL')
        context.end_keyword(foritem)
        return error

    def _replace_vars_from_items(self, variables):
        items = variables.replace_list(self.items)
        if self.range:
            items = self._get_range_items(items)
        if len(items) % len(self.vars) == 0:
            return items
        raise DataError('Number of FOR loop values should be multiple of '
                        'variables. Got %d variables but %d value%s.'
                        % (len(self.vars), len(items), plural_or_not(items)))

    def _get_range_items(self, items):
        try:
            items = [self._to_int_with_arithmetics(item) for item in items]
        except:
            raise DataError('Converting argument of FOR IN RANGE failed: %s'
                            % get_error_message())
        if not 1 <= len(items) <= 3:
            raise DataError('FOR IN RANGE expected 1-3 arguments, '
                            'got %d instead.' % len(items))
        return range(*items)

    def _to_int_with_arithmetics(self, item):
        item = str(item)
        try:
            return int(item)
        except ValueError:
            return int(eval(item))


class _ForItem(BaseKeyword):

    def __init__(self, vars, items):
        name = ', '.join(format_assign_message(var, item)
                         for var, item in zip(vars, items))
        BaseKeyword.__init__(self, name, type='foritem')
        self.starttime = get_timestamp()

    def end(self, status):
        self.status = status
        self.endtime = get_timestamp()
        self.elapsedtime = get_elapsed_time(self.starttime, self.endtime)

########NEW FILE########
__FILENAME__ = model
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot import utils
from robot.common import BaseTestSuite, BaseTestCase
from robot.parsing import TestData
from robot.errors import ExecutionFailed, DataError
from robot.variables import GLOBAL_VARIABLES
from robot.output import LOGGER

from .fixture import Setup, Teardown
from .keywords import Keywords
from .namespace import Namespace
from .runerrors import SuiteRunErrors, TestRunErrors
from .userkeyword import UserLibrary
from .context import EXECUTION_CONTEXTS
from .defaultvalues import DefaultValues


def TestSuite(datasources, settings):
    """Creates a runnable test suite from given data sources and settings.

    This is a factory method that returns either :class:`RunnableTestSuite`
    or :class:`RunnableMultiTestSuite` depending are one or more data sources
    given. This method, and especially the returned suite, is likely to change
    heavily in version 2.8.

    :param datasources: List of paths to read data from. Starting from 2.7.2,
                        a single datasource can also be given as a string.
    :param settings: Execution configuration.
    :type settings: :class:`~robot.conf.settings.RobotSettings`
    :returns: :class:`RunnableTestSuite`
    """
    if isinstance(datasources, basestring):
        datasources = [datasources]
    datasources = [utils.abspath(path) for path in datasources]
    suite = _get_suite(datasources, settings['SuiteNames'], settings['WarnOnSkipped'])
    suite.set_options(settings)
    _check_suite_contains_tests(suite, settings['RunEmptySuite'])
    return suite

def _get_suite(datasources, include_suites, warn_on_skipped):
    if not datasources:
        raise DataError("No data sources given.")
    if len(datasources) > 1:
        return _get_multisource_suite(datasources, include_suites, warn_on_skipped)
    return RunnableTestSuite(_parse_suite(datasources[0], include_suites, warn_on_skipped))

def _parse_suite(path, include_suites, warn_on_skipped):
    try:
        return TestData(source=path, include_suites=include_suites, warn_on_skipped=warn_on_skipped)
    except DataError, err:
        raise DataError("Parsing '%s' failed: %s" % (path, unicode(err)))

def _get_multisource_suite(datasources, include_suites, warn_on_skipped):
    suitedatas = []
    for datasource in datasources:
        try:
            suitedatas.append(_parse_suite(datasource, include_suites, warn_on_skipped))
        except DataError, err:
            LOGGER.warn(err)
    suite = RunnableMultiTestSuite(suitedatas)
    if suite.get_test_count() == 0:
        raise DataError("Data sources %s contain no test cases."
                        % utils.seq2str(datasources))
    return suite

def _check_suite_contains_tests(suite, run_empty_suites=False):
    suite.filter_empty_suites()
    if not suite.get_test_count() and not run_empty_suites:
        raise DataError("Test suite '%s' contains no test cases." % suite.source)


class RunnableTestSuite(BaseTestSuite):

    def __init__(self, data, parent=None, defaults=None):
        BaseTestSuite.__init__(self, data.name, data.source, parent)
        self.variables = GLOBAL_VARIABLES.copy()
        self.variables.set_from_variable_table(data.variable_table)
        self.source = data.source
        self.doc = data.setting_table.doc.value
        self.metadata = self._get_metadata(data.setting_table.metadata)
        self.imports = data.imports
        self.user_keywords = UserLibrary(data.keywords)
        self.setup = Setup(data.setting_table.suite_setup.name,
                           data.setting_table.suite_setup.args)
        self.teardown = Teardown(data.setting_table.suite_teardown.name,
                                 data.setting_table.suite_teardown.args)
        defaults = DefaultValues(data.setting_table, defaults)
        for suite in data.children:
            RunnableTestSuite(suite, parent=self, defaults=defaults)
        for test in data.testcase_table:
            RunnableTestCase(test, parent=self, defaults=defaults)
        self._exit_on_failure_mode = False
        self._skip_teardowns_on_exit_mode = False
        self._dry_run_mode = False

    def filter_empty_suites(self):
        for suite in self.suites[:]:
            suite.filter_empty_suites()
            if suite.get_test_count() == 0:
                self.suites.remove(suite)
                LOGGER.info("Running test suite '%s' failed: Test suite "
                            "contains no test cases." % suite.source)

    def _get_metadata(self, metadata):
        meta = utils.NormalizedDict()
        for item in metadata:
            meta[item.name] = item.value
        return meta

    def run(self, output, parent_context=None, errors=None):
        if not errors:
            errors = SuiteRunErrors(self._exit_on_failure_mode,
                                    self._skip_teardowns_on_exit_mode)
        context = self._start_run(output, parent_context, errors)
        self._run_setup(context, errors)
        self._run_sub_suites(context, errors)
        self._run_tests(context, errors)
        self._report_status(context, errors)
        self._run_teardown(context, errors)
        self._end_run(context, errors)

    def _start_run(self, output, parent_context, errors):
        errors.start_suite()
        self.status = 'RUNNING'
        self.starttime = utils.get_timestamp()
        variables = parent_context.get_current_vars() if parent_context else None
        ns = Namespace(self, variables)
        context = EXECUTION_CONTEXTS.start_suite(ns, output, self._dry_run_mode)
        if not errors.exit:
            ns.handle_imports()
        self._set_variable_dependent_metadata(context, errors)
        output.start_suite(self)
        return context

    def _set_variable_dependent_metadata(self, context, errors):
        init_errors = []
        self.doc = context.replace_vars_from_setting('Documentation', self.doc,
                                                     init_errors)
        self.setup.replace_variables(context.get_current_vars(), init_errors)
        self.teardown.replace_variables(context.get_current_vars(), init_errors)
        for name, value in self.metadata.items():
            self.metadata[name] = context.replace_vars_from_setting(name, value,
                                                                    init_errors)
        errors.suite_initialized('\n'.join(init_errors))

    def _run_setup(self, context, errors):
        if errors.is_setup_allowed():
            error = self.setup.run(context)
            errors.setup_executed(error)

    def _run_teardown(self, context, errors):
        if errors.is_teardown_allowed():
            error = self.teardown.run(context)
            if error:
                self.suite_teardown_failed(error)

    def _run_sub_suites(self, context, errors):
        for suite in self.suites:
            suite.run(context.output, context, errors)

    def _run_tests(self, context, errors):
        executed_tests = []
        for test in self.tests:
            normname = utils.normalize(test.name)
            if normname in executed_tests:
                LOGGER.warn("Multiple test cases with name '%s' executed in "
                            "test suite '%s'"% (test.name, self.longname))
            executed_tests.append(normname)
            test.run(context, errors)
            context.set_prev_test_variables(test)

    def _report_status(self, context, errors):
        self.set_status()
        self.message = errors.get_suite_error()
        context.report_suite_status(self.status, self.get_full_message())

    def _end_run(self, context, errors):
        self.endtime = utils.get_timestamp()
        self.elapsedtime = utils.get_elapsed_time(self.starttime, self.endtime)
        context.copy_prev_test_vars_to_global()
        context.end_suite(self)
        errors.end_suite()


class RunnableMultiTestSuite(RunnableTestSuite):

    def __init__(self, suitedatas):
        BaseTestSuite.__init__(self, name='')
        self.variables = GLOBAL_VARIABLES.copy()
        self.doc = ''
        self.imports = []
        self.setup = Setup(None, None)
        self.teardown = Teardown(None, None)
        for suite in suitedatas:
            RunnableTestSuite(suite, parent=self)
        self._exit_on_failure_mode = False
        self._skip_teardowns_on_exit_mode = False
        self._dry_run_mode = False


class RunnableTestCase(BaseTestCase):

    def __init__(self, tc_data, parent, defaults):
        BaseTestCase.__init__(self, tc_data.name, parent)
        self.doc = tc_data.doc.value
        self.setup = defaults.get_setup(tc_data.setup)
        self.teardown = defaults.get_teardown(tc_data.teardown)
        self.tags = defaults.get_tags(tc_data.tags)
        self.timeout = defaults.get_timeout(tc_data.timeout)
        self.template = defaults.get_template(tc_data.template)
        self.keywords = Keywords(tc_data.steps, self.template)

    def run(self, context, parent_errors):
        errors = self._start_run(context, parent_errors)
        if errors.is_run_allowed():
            self._run(context, errors)
        else:
            self._not_allowed_to_run(errors)
        self._end_run(context)

    def _start_run(self, context, parent_errors):
        errors = TestRunErrors(parent_errors)
        self.status = 'RUNNING'
        self.starttime = utils.get_timestamp()
        errors.test_initialized(self._init_test(context))
        context.start_test(self)
        return errors

    def _init_test(self, context):
        errors = []
        self.doc = context.replace_vars_from_setting('Documentation', self.doc,
                                                     errors)
        self.setup.replace_variables(context.get_current_vars(), errors)
        self.teardown.replace_variables(context.get_current_vars(), errors)
        tags = context.replace_vars_from_setting('Tags', self.tags, errors)
        self.tags = utils.normalize_tags(tags)
        self.timeout.replace_variables(context.get_current_vars())
        if errors:
            return 'Test case initialization failed:\n%s' % '\n'.join(errors)
        if not self.name:
            return 'Test case name is required.'
        if not self.keywords:
            return 'Test case contains no keywords'
        return None

    def _run(self, context, errors):
        self.timeout.start()
        failed = self._run_setup(context, errors)
        if not failed:
            self._run_keywords(context, errors)
        self._set_status_before_teardown(context, errors)
        failed = self._run_teardown(context, errors)
        self._set_status_after_teardown(failed, errors)

    def _test_failed(self, err, errors):
        self.timeout.set_keyword_timeout(err.timeout)
        errors.test_failed(exit=err.exit, critical=self.critical)

    def _run_setup(self, context, errors):
        error = self.setup.run(context)
        if error:
            errors.setup_failed(error)
            self._test_failed(error, errors)
        return bool(error)

    def _run_keywords(self, context, errors):
        try:
            self.keywords.run(context)
        except ExecutionFailed, err:
            errors.keyword_failed(err)
            self._test_failed(err, errors)

    def _set_status_before_teardown(self, context, errors):
        message = errors.get_message()
        if message:
            self.status = 'FAIL'
            self.message = message
        else:
            self.status = 'PASS'
        context.set_test_status_before_teardown(self.message, self.status)

    def _run_teardown(self, context, errors):
        if not errors.is_teardown_allowed():
            return False
        error = self.teardown.run(context)
        if error:
            errors.teardown_failed(error)
            self._test_failed(error, errors)
        return bool(error)

    def _set_status_after_teardown(self, teardown_failed, errors):
        if teardown_failed:
            self.status = 'FAIL'
            self.message = errors.get_teardown_message(self.message)
        if self.status == 'PASS' and self.timeout.timed_out():
            self.status = 'FAIL'
            self.message = self.timeout.get_message()
        if self.status == 'FAIL':
            errors.test_failed(critical=self.critical)

    def _not_allowed_to_run(self, errors):
        self.status = 'FAIL'
        self.message = errors.get_parent_or_init_error()

    def _end_run(self, context):
        self.endtime = utils.get_timestamp()
        self.elapsedtime = utils.get_elapsed_time(self.starttime, self.endtime)
        context.end_test(self)

########NEW FILE########
__FILENAME__ = namespace
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys
import copy

from robot import utils
from robot.errors import DataError
from robot.variables import GLOBAL_VARIABLES, is_scalar_var
from robot.common import UserErrorHandler
from robot.output import LOGGER
from robot.parsing.settings import Library, Variables, Resource

from .userkeyword import UserLibrary
from .importer import Importer, ImportCache
from .runkwregister import RUN_KW_REGISTER
from .handlers import _XTimesHandler
from .context import EXECUTION_CONTEXTS


STDLIB_NAMES = set(('BuiltIn', 'Collections', 'Dialogs', 'Easter',
                    'OperatingSystem', 'Process', 'Remote', 'Reserved',
                    'Screenshot', 'String', 'Telnet', 'XML'))
IMPORTER = Importer()


class Namespace:
    _default_libraries = ('BuiltIn', 'Reserved', 'Easter')
    _deprecated_libraries = {'BuiltIn': 'DeprecatedBuiltIn',
                             'OperatingSystem': 'DeprecatedOperatingSystem'}
    _library_import_by_path_endings = ('.py', '.java', '.class', '/', os.sep)

    def __init__(self, suite, parent_vars):
        if suite is not None:
            LOGGER.info("Initializing namespace for test suite '%s'" % suite.longname)
        self.variables = self._create_variables(suite, parent_vars)
        self.suite = suite
        self.test = None
        self.uk_handlers = []
        self.library_search_order = []
        self._testlibs = {}
        self._imported_resource_files = ImportCache()
        self._imported_variable_files = ImportCache()

    def handle_imports(self):
        self._import_default_libraries()
        if self.suite.source:
            self._handle_imports(self.suite.imports)

    def _create_variables(self, suite, parent_vars):
        variables = _VariableScopes(suite, parent_vars)
        variables['${SUITE_NAME}'] = suite.longname
        variables['${SUITE_SOURCE}'] = suite.source
        variables['${SUITE_DOCUMENTATION}'] = suite.doc
        variables['${SUITE_METADATA}'] = suite.metadata.copy()
        return variables

    def _import_default_libraries(self):
        for name in self._default_libraries:
            self.import_library(name)

    def _handle_imports(self, import_settings):
        for item in import_settings:
            try:
                if not item.name:
                    raise DataError('%s setting requires a name' % item.type)
                self._import(item)
            except DataError, err:
                item.report_invalid_syntax(unicode(err))

    def _import(self, import_setting):
        action = {'Library': self._import_library,
                  'Resource': self._import_resource,
                  'Variables': self._import_variables}[import_setting.type]
        action(import_setting, self.variables.current)

    def import_resource(self, name, overwrite=True):
        self._import_resource(Resource(None, name), overwrite=overwrite)

    def _import_resource(self, import_setting, variables=None, overwrite=False):
        path = self._resolve_name(import_setting, variables)
        if overwrite or path not in self._imported_resource_files:
            resource = IMPORTER.import_resource(path)
            self.variables.set_from_variable_table(resource.variable_table,
                                                   overwrite)
            self._imported_resource_files[path] \
                = UserLibrary(resource.keyword_table.keywords, resource.source)
            self._handle_imports(resource.setting_table.imports)
        else:
            LOGGER.info("Resource file '%s' already imported by suite '%s'"
                        % (path, self.suite.longname))

    def import_variables(self, name, args, overwrite=False, variables=None):
        self._import_variables(Variables(None, name, args), variables, overwrite)

    def _import_variables(self, import_setting, variables, overwrite=False):
        path = self._resolve_name(import_setting, variables)
        args = self._resolve_args(import_setting, variables)
        if overwrite or (path, args) not in self._imported_variable_files:
            self._imported_variable_files.add((path,args))
            self.variables.set_from_file(path, args, overwrite)
        else:
            msg = "Variable file '%s'" % path
            if args:
                msg += " with arguments %s" % utils.seq2str2(args)
            LOGGER.info("%s already imported by suite '%s'"
                        % (msg, self.suite.longname))

    def import_library(self, name, args=None, alias=None, variables=None):
        self._import_library(Library(None, name, args=args, alias=alias), variables)

    def _import_library(self, import_setting, variables):
        name = self._resolve_name(import_setting, variables)
        lib = IMPORTER.import_library(name, import_setting.args,
                                      import_setting.alias, variables)
        if lib.name in self._testlibs:
            LOGGER.info("Test library '%s' already imported by suite '%s'"
                        % (lib.name, self.suite.longname))
            return
        self._testlibs[lib.name] = lib
        lib.start_suite()
        if self.test:
            lib.start_test()
        self._import_deprecated_standard_libs(lib.name)

    def _resolve_name(self, import_setting, variables):
        name = import_setting.name
        if variables:
            try:
                name = variables.replace_string(name)
            except DataError, err:
                self._raise_replacing_vars_failed(import_setting, err)
        return self._get_path(name, import_setting.directory, import_setting.type)

    def _raise_replacing_vars_failed(self, import_setting, err):
        raise DataError("Replacing variables from setting '%s' failed: %s"
                        % (import_setting.type, unicode(err)))

    def _get_path(self, name, basedir, type):
        if type == 'Library' and not self._is_library_by_path(name):
            return name.replace(' ', '')
        try:
            return self._resolve_path(name.replace('/', os.sep), basedir)
        except DataError:
            self._raise_imported_does_not_exist(type, name)

    def _is_library_by_path(self, path):
        return path.lower().endswith(self._library_import_by_path_endings)

    def _resolve_path(self, path, basedir):
        for base in [basedir] + sys.path:
            if not (base and os.path.isdir(base)):
                continue
            if not isinstance(base, unicode):
                base = utils.decode_from_system(base)
            ret = os.path.abspath(os.path.join(base, path))
            if os.path.isfile(ret):
                return ret
            if os.path.isdir(ret) and os.path.isfile(os.path.join(ret, '__init__.py')):
                return ret
        raise DataError

    def _raise_imported_does_not_exist(self, type, path):
        type = {'Library': 'Test library',
                'Variables': 'Variable file',
                'Resource': 'Resource file'}[type]
        raise DataError("%s '%s' does not exist." % (type, path))

    def _resolve_args(self, import_setting, variables):
        if not variables:
            return import_setting.args
        try:
            return variables.replace_list(import_setting.args)
        except DataError, err:
            self._raise_replacing_vars_failed(import_setting, err)

    def _import_deprecated_standard_libs(self, name):
        if name in self._deprecated_libraries:
            self.import_library(self._deprecated_libraries[name])

    def start_test(self, test):
        self.variables.start_test(test)
        self.test = test
        for lib in self._testlibs.values():
            lib.start_test()
        self.variables['${TEST_NAME}'] = test.name
        self.variables['${TEST_DOCUMENTATION}'] = test.doc
        self.variables['@{TEST_TAGS}'] = test.tags[:]

    def end_test(self):
        self.test = None
        self.variables.end_test()
        self.uk_handlers = []
        for lib in self._testlibs.values():
            lib.end_test()

    def set_test_status_before_teardown(self, message, status):
        self.variables['${TEST_MESSAGE}'] = message
        self.variables['${TEST_STATUS}'] = status

    def end_suite(self):
        self.suite = None
        self.variables.end_suite()
        for lib in self._testlibs.values():
            lib.end_suite()

    def start_user_keyword(self, handler):
        self.variables.start_uk(handler)
        self.uk_handlers.append(handler)

    def end_user_keyword(self):
        self.variables.end_uk()
        self.uk_handlers.pop()

    def get_library_instance(self, libname):
        try:
            return self._testlibs[libname.replace(' ', '')].get_instance()
        except KeyError:
            raise DataError("No library with name '%s' found." % libname)

    def get_handler(self, name):
        try:
            handler = self._get_handler(name)
            if handler is None:
                raise DataError("No keyword with name '%s' found." % name)
        except DataError, err:
            handler = UserErrorHandler(name, unicode(err))
        self._replace_variables_from_user_handlers(handler)
        return handler

    def _replace_variables_from_user_handlers(self, handler):
        if hasattr(handler, 'replace_variables'):
            handler.replace_variables(self.variables)

    def _get_handler(self, name):
        handler = None
        if not name:
            raise DataError('Keyword name cannot be empty.')
        if not isinstance(name, basestring):
            raise DataError('Keyword name must be a string.')
        if '.' in name:
            handler = self._get_explicit_handler(name)
        if not handler:
            handler = self._get_implicit_handler(name)
        if not handler:
            handler = self._get_bdd_style_handler(name)
        if not handler:
            handler = self._get_x_times_handler(name)
        return handler

    def _get_x_times_handler(self, name):
        if not self._is_old_x_times_syntax(name):
            return None
        return _XTimesHandler(self._get_handler('Repeat Keyword'), name)

    def _is_old_x_times_syntax(self, name):
        if not name.lower().endswith('x'):
            return False
        times = name[:-1].strip()
        if is_scalar_var(times):
            return True
        try:
            int(times)
        except ValueError:
            return False
        else:
            return True

    def _get_bdd_style_handler(self, name):
        for prefix in ['given ', 'when ', 'then ', 'and ']:
            if name.lower().startswith(prefix):
                handler = self._get_handler(name[len(prefix):])
                if handler:
                    handler = copy.copy(handler)
                    handler.name = name
                return handler
        return None

    def _get_implicit_handler(self, name):
        for method in [self._get_handler_from_test_case_file_user_keywords,
                       self._get_handler_from_resource_file_user_keywords,
                       self._get_handler_from_library_keywords]:
            handler = method(name)
            if handler:
                return handler
        return None

    def _get_handler_from_test_case_file_user_keywords(self, name):
        if self.suite.user_keywords.has_handler(name):
            return self.suite.user_keywords.get_handler(name)

    def _get_handler_from_resource_file_user_keywords(self, name):
        found = [lib.get_handler(name) for lib
                 in self._imported_resource_files.values()
                 if lib.has_handler(name)]
        if not found:
            return None
        if len(found) > 1:
            found = self._get_handler_based_on_library_search_order(found)
        if len(found) == 1:
            return found[0]
        self._raise_multiple_keywords_found(name, found)

    def _get_handler_from_library_keywords(self, name):
        found = [lib.get_handler(name) for lib in self._testlibs.values()
                 if lib.has_handler(name)]
        if not found:
            return None
        if len(found) > 1:
            found = self._get_handler_based_on_library_search_order(found)
        if len(found) == 2:
            found = self._filter_stdlib_handler(found[0], found[1])
        if len(found) == 1:
            return found[0]
        self._raise_multiple_keywords_found(name, found)

    def _get_handler_based_on_library_search_order(self, handlers):
        for libname in self.library_search_order:
            for handler in handlers:
                if utils.eq(libname, handler.libname):
                    return [handler]
        return handlers

    def _filter_stdlib_handler(self, handler1, handler2):
        if handler1.library.orig_name in STDLIB_NAMES:
            standard, external = handler1, handler2
        elif handler2.library.orig_name in STDLIB_NAMES:
            standard, external = handler2, handler1
        else:
            return [handler1, handler2]
        if not RUN_KW_REGISTER.is_run_keyword(external.library.orig_name, external.name):
            LOGGER.warn(
                "Keyword '%s' found both from a user created test library "
                "'%s' and Robot Framework standard library '%s'. The user "
                "created keyword is used. To select explicitly, and to get "
                "rid of this warning, use either '%s' or '%s'."
                % (standard.name,
                   external.library.orig_name, standard.library.orig_name,
                   external.longname, standard.longname))
        return [external]

    def _get_explicit_handler(self, name):
        libname, kwname = name.rsplit('.', 1)
        # 1) Find matching lib(s)
        libs = [lib for lib
                in self._imported_resource_files.values() + self._testlibs.values()
                if utils.eq(lib.name, libname)]
        if not libs:
            return None
        # 2) Find matching kw from found libs
        found = [lib.get_handler(kwname) for lib in libs
                 if lib.has_handler(kwname)]
        if len(found) > 1:
            self._raise_multiple_keywords_found(name, found, implicit=False)
        return found and found[0] or None

    def _raise_multiple_keywords_found(self, name, found, implicit=True):
        error = "Multiple keywords with name '%s' found.\n" % name
        if implicit:
            error += "Give the full name of the keyword you want to use.\n"
        names = sorted(handler.longname for handler in found)
        error += "Found: %s" % utils.seq2str(names)
        raise DataError(error)


class _VariableScopes:

    def __init__(self, suite, parent_vars):
        # suite and parent are None only when used by copy_all
        if suite is not None:
            suite.variables.update(GLOBAL_VARIABLES)
            self._suite = self.current = suite.variables
        else:
            self._suite = self.current = None
        self._parents = []
        if parent_vars is not None:
            self._parents.append(parent_vars.current)
            self._parents.extend(parent_vars._parents)
        self._test = None
        self._uk_handlers = []

    def __len__(self):
        if self.current:
            return len(self.current)
        return 0

    def copy_all(self):
        vs = _VariableScopes(None, None)
        vs._suite = self._suite
        vs._test = self._test
        vs._uk_handlers = self._uk_handlers[:]
        vs._parents = self._parents[:]
        vs.current = self.current
        return vs

    def replace_list(self, items):
        return self.current.replace_list(items)

    def replace_scalar(self, items):
        return self.current.replace_scalar(items)

    def replace_string(self, string):
        return self.current.replace_string(string)

    def replace_run_kw_info(self, args, needed=sys.maxint):
        # @{list} variables can contain more or less arguments than needed.
        # Therefore we need to go through arguments one by one.
        processed = []
        while len(processed) < needed and args:
            processed.extend(self.current.replace_list([args.pop(0)]))
        # If @{list} variable is opened, arguments going further must be
        # escaped to prevent them being un-escaped twice.
        if len(processed) > needed:
            processed[needed:] = [self._escape_run_kw_arg(arg)
                                    for arg in processed[needed:]]
        return processed + args

    def _escape_run_kw_arg(self, arg):
        arg = utils.escape(arg)
        # Escape also special syntax used by Run Kw If and Run Kws.
        if arg in ('ELSE', 'ELSE IF', 'AND'):
            arg = '\\' + arg
        return arg

    def set_from_file(self, path, args, overwrite=False):
        variables = self._suite.set_from_file(path, args, overwrite)
        if self._test is not None:
            self._test._set_from_file(variables, overwrite=True, path=path)
        for varz in self._uk_handlers:
            varz._set_from_file(variables, overwrite=True, path=path)
        if self._uk_handlers:
            self.current._set_from_file(variables, overwrite=True, path=path)

    def set_from_variable_table(self, rawvariables, overwrite=False):
        self._suite.set_from_variable_table(rawvariables, overwrite)
        if self._test is not None:
            self._test.set_from_variable_table(rawvariables, overwrite)
        for varz in self._uk_handlers:
            varz.set_from_variable_table(rawvariables, overwrite)
        if self._uk_handlers:
            self.current.set_from_variable_table(rawvariables, overwrite)

    def replace_meta(self, name, item, errors):
        error = None
        for varz in [self.current] + self._parents:
            try:
                if name == 'Documentation':
                    return varz.replace_string(item, ignore_errors=True)
                elif isinstance(item, basestring):
                    return varz.replace_string(item)
                return varz.replace_list(item)
            except DataError, error:
                pass
        errors.append("Replacing variables from setting '%s' failed: %s"
                      % (name, error))
        return utils.unescape(item)

    def __getitem__(self, name):
        return self.current[name]

    def __setitem__(self, name, value):
        self.current[name] = value

    def end_suite(self):
        self._suite = self._test = self.current = None

    def start_test(self, test):
        self._test = self.current = self._suite.copy()

    def end_test(self):
        self.current = self._suite

    def start_uk(self, handler):
        self._uk_handlers.append(self.current)
        self.current = self.current.copy()

    def end_uk(self):
        self.current = self._uk_handlers.pop()

    def set_global(self, name, value):
        GLOBAL_VARIABLES.__setitem__(name, value)
        for ns in EXECUTION_CONTEXTS.namespaces:
            ns.variables.set_suite(name, value)

    def set_suite(self, name, value):
        self._suite.__setitem__(name, value)
        self.set_test(name, value, False)

    def set_test(self, name, value, fail_if_no_test=True):
        if self._test is not None:
            self._test.__setitem__(name, value)
        elif fail_if_no_test:
            raise DataError("Cannot set test variable when no test is started")
        for varz in self._uk_handlers:
            varz.__setitem__(name, value)
        self.current.__setitem__(name, value)

    def keys(self):
        return self.current.keys()

    def has_key(self, key):
        return self.current.has_key(key)

    __contains__ = has_key

    def contains(self, name, extended=False):
        return self.current.contains(name, extended)

########NEW FILE########
__FILENAME__ = outputcapture
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
from StringIO import StringIO

from robot.output import LOGGER


class OutputCapturer:

    def __init__(self, library_import=False):
        if library_import:
            LOGGER.enable_library_import_logging()
        self._library_import = library_import
        self._python_out = _PythonCapturer(stdout=True)
        self._python_err = _PythonCapturer(stdout=False)
        self._java_out = _JavaCapturer(stdout=True)
        self._java_err = _JavaCapturer(stdout=False)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_trace):
        self.release_and_log()
        return False

    def release_and_log(self):
        stdout, stderr = self._release()
        if stdout:
            LOGGER.log_output(stdout)
        if stderr:
            LOGGER.log_output(stderr)
            sys.__stderr__.write(stderr+'\n')
        if self._library_import:
            LOGGER.disable_library_import_logging()

    def _release(self):
        py_out = self._python_out.release()
        py_err = self._python_err.release()
        java_out = self._java_out.release()
        java_err = self._java_err.release()
        # This should return both Python and Java stdout/stderr.
        # It is unfortunately not possible to do py_out+java_out here, because
        # java_out is always Unicode and py_out is bytes (=str). When py_out
        # contains non-ASCII bytes catenation fails with UnicodeError.
        # Unfortunately utils.unic(py_out) doesn't work either, because later
        # splitting the output to levels and messages fails. Should investigate
        # why that happens. It also seems that the byte message are never
        # converted to Unicode - at least Message class doesn't do that.
        # It's probably safe to leave this code like it is in RF 2.5, because
        # a) the earlier versions worked the same way, and b) this code is
        # used so that there should never be output both from Python and Java.
        return (py_out, py_err) if (py_out or py_err) else (java_out, java_err)


class _PythonCapturer(object):

    def __init__(self, stdout=True):
        if stdout:
            self._original = sys.stdout
            self._set_stream = self._set_stdout
        else:
            self._original = sys.stderr
            self._set_stream = self._set_stderr
        self._stream = StringIO()
        self._set_stream(self._stream)

    def _set_stdout(self, stream):
        sys.stdout = stream

    def _set_stderr(self, stream):
        sys.stderr = stream

    def release(self):
        # Original stream must be restored before closing the current
        self._set_stream(self._original)
        self._stream.flush()
        output = self._stream.getvalue()
        self._stream.close()
        return output


if not sys.platform.startswith('java'):

    class _JavaCapturer(object):
        def __init__(self, stdout):
            pass
        def release(self):
            return ''

else:

    from java.io import PrintStream, ByteArrayOutputStream
    from java.lang import System


    class _JavaCapturer(object):

        def __init__(self, stdout=True):
            if stdout:
                self._original = System.out
                self._set_stream = System.setOut
            else:
                self._original = System.err
                self._set_stream = System.setErr
            self._bytes = ByteArrayOutputStream()
            self._stream = PrintStream(self._bytes, False, 'UTF-8')
            self._set_stream(self._stream)

        def release(self):
            # Original stream must be restored before closing the current
            self._set_stream(self._original)
            self._stream.close()
            output = self._bytes.toString('UTF-8')
            self._bytes.reset()
            return output

########NEW FILE########
__FILENAME__ = runerrors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

class SuiteRunErrors(object):
    _exit_on_failure_error = ('Critical failure occurred and ExitOnFailure '
                              'option is in use')
    _exit_on_fatal_error = 'Test execution is stopped due to a fatal error'
    _parent_init_error_prefix = 'Initialization of the parent suite failed:\n'
    _parent_setup_error_prefix = 'Setup of the parent suite failed:\n'
    _init_error_prefix = 'Suite initialization failed:\n'
    _setup_error_prefix = 'Suite setup failed:\n'

    def __init__(self, exit_on_failure_mode=False, skip_teardowns_on_exit_mode=False):
        self._exit_on_failure_mode = exit_on_failure_mode
        self._skip_teardowns_on_exit_mode = skip_teardowns_on_exit_mode
        self._earlier_init_errors = []
        self._earlier_setup_errors = []
        self._earlier_setup_executions = []
        self._init_error = None
        self._setup_error = None
        self._setup_executed = False
        self._exit_on_failure = False
        self._exit_on_fatal = False

    @property
    def exit(self):
        return self._exit_on_fatal or self._exit_on_failure

    def start_suite(self):
        self._earlier_init_errors.append(self._init_error)
        self._earlier_setup_errors.append(self._setup_error)
        self._earlier_setup_executions.append(self._setup_executed)
        self._init_error = None
        self._setup_error = None
        self._setup_executed = False

    def end_suite(self):
        self._setup_error = self._earlier_setup_errors.pop()
        self._init_error = self._earlier_init_errors.pop()
        self._setup_executed = self._earlier_setup_executions.pop()

    def is_setup_allowed(self):
        return not (self._init_error or self.exit or
                    any(self._earlier_init_errors + self._earlier_setup_errors))

    def is_teardown_allowed(self):
        return self._setup_executed and not self._skip_teardown()

    def _skip_teardown(self):
        return self._skip_teardowns_on_exit_mode and self.exit

    def suite_initialized(self, error=None):
        if error:
            self._init_error = error

    def setup_executed(self, error=None):
        self._setup_executed = True
        if error:
            self._setup_error = unicode(error)
            if error.exit:
                self._exit_on_fatal = True

    def get_suite_error(self):
        if self._init_error:
            return self._init_error_prefix + self._init_error
        if self._setup_error:
            return self._setup_error_prefix + self._setup_error
        return ''

    def get_child_error(self):
        if self._init_error or any(self._earlier_init_errors):
            return self._get_init_error()
        if self._setup_error or any(self._earlier_setup_errors):
            return self._get_setup_error()
        if self._exit_on_failure:
            return self._exit_on_failure_error
        if self._exit_on_fatal:
            return self._exit_on_fatal_error
        return ''

    def _get_init_error(self):
        error = self._get_error(self._init_error, *self._earlier_init_errors)
        return self._parent_init_error_prefix + error

    def _get_setup_error(self):
        error = self._get_error(self._setup_error, *self._earlier_setup_errors)
        return self._parent_setup_error_prefix + error

    def _get_error(self, *errors):
        for error in errors:
            if error:
                return error

    def test_failed(self, exit=False, critical=False):
        if critical and self._exit_on_failure_mode:
            self._exit_on_failure = True
        if exit:
            self._exit_on_fatal = True


class TestRunErrors(object):

    def __init__(self, parent):
        self._parent = parent
        self._parent_error = parent.get_child_error()
        self._init_error = None
        self._setup_error = None
        self._keyword_error = None
        self._teardown_error = None

    def is_run_allowed(self):
        return not bool(self._parent_error or self._init_error)

    def is_teardown_allowed(self):
        return self._parent.is_teardown_allowed()

    def test_initialized(self, error=None):
        self._init_error = error

    def setup_failed(self, error):
        self._setup_error = unicode(error)

    def keyword_failed(self, error):
        self._keyword_error = unicode(error)

    def teardown_failed(self, error):
        self._teardown_error = unicode(error)

    def test_failed(self, exit=False, critical=False):
        self._parent.test_failed(exit, critical)

    def get_message(self):
        if self._setup_error:
            return 'Setup failed:\n%s' % self._setup_error
        return self._keyword_error

    def get_teardown_message(self, message):
        if not message:
            return 'Teardown failed:\n%s' % self._teardown_error
        return '%s\n\nAlso teardown failed:\n%s' % (message, self._teardown_error)

    def get_parent_or_init_error(self):
        return self._parent_error or self._init_error

########NEW FILE########
__FILENAME__ = runkwregister
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import inspect

from robot.utils import NormalizedDict


class _RunKeywordRegister:

    def __init__(self):
        self._libs = {}

    def register_run_keyword(self, libname, keyword, args_to_process=None):
        if args_to_process is None:
            args_to_process = self._get_args_from_method(keyword)
            keyword = keyword.__name__
        if libname not in self._libs:
            self._libs[libname] = NormalizedDict(ignore=['_'])
        self._libs[libname][keyword] = int(args_to_process)

    def get_args_to_process(self, libname, kwname):
        if libname in self._libs and kwname in self._libs[libname]:
            return self._libs[libname][kwname]
        return -1

    def is_run_keyword(self, libname, kwname):
        return self.get_args_to_process(libname, kwname) >= 0

    def _get_args_from_method(self, method):
        if inspect.ismethod(method):
            return method.im_func.func_code.co_argcount - 1
        elif inspect.isfunction(method):
            return method.func_code.co_argcount
        raise ValueError('Needs function or method')


RUN_KW_REGISTER = _RunKeywordRegister()

########NEW FILE########
__FILENAME__ = signalhandler
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
from threading import currentThread
try:
    import signal
except ImportError:
    signal = None  # IronPython 2.6 doesn't have signal module by default
if sys.platform.startswith('java'):
    from java.lang import IllegalArgumentException
else:
    IllegalArgumentException = None

from robot.errors import ExecutionFailed
from robot.output import LOGGER


class _StopSignalMonitor(object):

    def __init__(self):
        self._signal_count = 0
        self._running_keyword = False

    def __call__(self, signum, frame):
        self._signal_count += 1
        LOGGER.info('Received signal: %s.' % signum)
        if self._signal_count > 1:
            sys.__stderr__.write('Execution forcefully stopped.\n')
            raise SystemExit()
        sys.__stderr__.write('Second signal will force exit.\n')
        if self._running_keyword and not sys.platform.startswith('java'):
            self._stop_execution_gracefully()

    def _stop_execution_gracefully(self):
        raise ExecutionFailed('Execution terminated by signal', exit=True)

    def start(self):
        if signal:
            for signum in signal.SIGINT, signal.SIGTERM:
                self._register_signal_handler(signum)

    def _register_signal_handler(self, signum):
        try:
            signal.signal(signum, self)
        except (ValueError, IllegalArgumentException), err:
            # ValueError occurs e.g. if Robot doesn't run on main thread.
            # IllegalArgumentException is http://bugs.jython.org/issue1729
            if currentThread().getName() == 'MainThread':
                self._warn_about_registeration_error(signum, err)

    def _warn_about_registeration_error(self, signum, err):
        name, ctrlc = {signal.SIGINT: ('INT', 'or with Ctrl-C '),
                       signal.SIGTERM: ('TERM', '')}[signum]
        LOGGER.warn('Registering signal %s failed. Stopping execution '
                    'gracefully with this signal %sis not possible. '
                    'Original error was: %s' % (name, ctrlc, err))

    def start_running_keyword(self, in_teardown):
        self._running_keyword = True
        if self._signal_count and not in_teardown:
            self._stop_execution_gracefully()

    def stop_running_keyword(self):
        self._running_keyword = False


STOP_SIGNAL_MONITOR = _StopSignalMonitor()

########NEW FILE########
__FILENAME__ = testlibraries
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os
import inspect

from robot import utils
from robot.errors import DataError
from robot.common import BaseLibrary
from robot.output import LOGGER

from handlers import Handler, InitHandler, DynamicHandler
from outputcapture import OutputCapturer

if utils.is_jython:
    from org.python.core import PyReflectedFunction, PyReflectedConstructor
    from java.lang import Object
else:
    Object = None


def TestLibrary(name, args=None, variables=None, create_handlers=True):
    with OutputCapturer(library_import=True):
        importer = utils.Importer('test library')
        libcode = importer.import_class_or_module(name)
    libclass = _get_lib_class(libcode)
    lib = libclass(libcode, name, args or [], variables)
    if create_handlers:
        lib.create_handlers()
    return lib


def _get_lib_class(libcode):
    if inspect.ismodule(libcode):
        return _ModuleLibrary
    if _DynamicMethod(libcode, 'get_keyword_names'):
        if _DynamicMethod(libcode, 'run_keyword'):
            return _DynamicLibrary
        else:
            return _HybridLibrary
    return _ClassLibrary


class _DynamicMethod(object):

    def __init__(self, libcode, underscore_name, default=None):
        self._method = self._get_method(libcode, underscore_name)
        self._default = default

    def __call__(self, *args):
        if not self._method:
            return self._default
        try:
            value = self._method(*args)
        except:
            raise DataError("Calling dynamic method '%s' failed: %s" %
                            (self._method.__name__, utils.get_error_message()))
        else:
            return self._to_unicode(value) if value is not None else self._default

    def _to_unicode(self, value):
        if isinstance(value, unicode):
            return value
        if isinstance(value, str):
            return utils.unic(value, 'UTF-8')
        return [self._to_unicode(v) for v in value]

    def __nonzero__(self):
        return self._method is not None

    def _get_method(self, libcode, underscore_name):
        for name in underscore_name, self._getCamelCaseName(underscore_name):
            method = getattr(libcode, name, None)
            if callable(method):
                return method
        return None

    def _getCamelCaseName(self, underscore_name):
        tokens = underscore_name.split('_')
        return ''.join([tokens[0]] + [t.capitalize() for t in tokens[1:]])


class _BaseTestLibrary(BaseLibrary):
    supports_named_arguments = True # this attribute is for libdoc
    _log_success = LOGGER.debug
    _log_failure = LOGGER.info
    _log_failure_details = LOGGER.debug

    def __init__(self, libcode, name, args, variables):
        if os.path.exists(name):
            name = os.path.splitext(os.path.basename(os.path.abspath(name)))[0]
        self.version = self._get_version(libcode)
        self.name = name
        self.orig_name = name # Stores original name also after copying
        self.positional_args = []
        self.named_args = {}
        self._instance_cache = []
        self._libinst = None
        if libcode is not None:
            self._doc = utils.getdoc(libcode)
            self.doc_format = self._get_doc_format(libcode)
            self.scope = self._get_scope(libcode)
            self._libcode = libcode
            self.init =  self._create_init_handler(libcode)
            self.positional_args, self.named_args = self.init.arguments.resolve(args, variables)

    @property
    def doc(self):
        return self._doc

    def create_handlers(self):
        if self._libcode:
            self._libinst = self.get_instance()
            self.handlers = self._create_handlers(self._libinst)
            self.init_scope_handling()

    def start_suite(self):
        pass

    def end_suite(self):
        pass

    def start_test(self):
        pass

    def end_test(self):
        pass

    def _get_version(self, libcode):
        return self._get_attr(libcode, 'ROBOT_LIBRARY_VERSION') \
            or self._get_attr(libcode, '__version__')

    def _get_attr(self, object, attr, default='', upper=False):
        value = utils.unic(getattr(object, attr, default))
        if upper:
            value = utils.normalize(value, ignore='_').upper()
        return value

    def _get_doc_format(self, libcode):
        return self._get_attr(libcode, 'ROBOT_LIBRARY_DOC_FORMAT', upper=True)

    def _get_scope(self, libcode):
        scope = self._get_attr(libcode, 'ROBOT_LIBRARY_SCOPE', upper=True)
        return scope if scope in ['GLOBAL','TESTSUITE'] else 'TESTCASE'

    def _create_init_handler(self, libcode):
        return InitHandler(self, self._resolve_init_method(libcode))

    def _resolve_init_method(self, libcode):
        init_method = getattr(libcode, '__init__', None)
        return init_method if self._valid_init(init_method) else lambda: None

    def _valid_init(self, init_method):
        if inspect.ismethod(init_method):
            return True
        if utils.is_jython and isinstance(init_method, PyReflectedConstructor):
            return True
        return False

    def init_scope_handling(self):
        if self.scope == 'GLOBAL':
            return
        self._libinst = None
        self.start_suite = self._caching_start
        self.end_suite = self._restoring_end
        if self.scope == 'TESTCASE':
            self.start_test = self._caching_start
            self.end_test = self._restoring_end

    def _caching_start(self):
        self._instance_cache.append(self._libinst)
        self._libinst = None

    def _restoring_end(self):
        self._libinst = self._instance_cache.pop()

    def get_instance(self):
        if self._libinst is None:
            self._libinst = self._get_instance()
        return self._libinst

    def _get_instance(self):
        capturer = OutputCapturer(library_import=True)
        try:
            return self._libcode(*self.positional_args, **self.named_args)
        except:
            self._raise_creating_instance_failed()
        finally:
            capturer.release_and_log()

    def _create_handlers(self, libcode):
        handlers = utils.NormalizedDict(ignore=['_'])
        for name in self._get_handler_names(libcode):
            method = self._try_to_get_handler_method(libcode, name)
            if method:
                handler = self._try_to_create_handler(name, method)
                if handler:
                    handlers[name] = handler
                    self._log_success("Created keyword '%s'" % handler.name)
        return handlers

    def _get_handler_names(self, libcode):
        return [name for name in dir(libcode)
                if not name.startswith(('_', 'ROBOT_LIBRARY_'))]

    def _try_to_get_handler_method(self, libcode, name):
        try:
            return self._get_handler_method(libcode, name)
        except:
            self._report_adding_keyword_failed(name)

    def _report_adding_keyword_failed(self, name):
        msg, details = utils.get_error_details()
        self._log_failure("Adding keyword '%s' to library '%s' failed: %s"
                          % (name, self.name, msg))
        if details:
            self._log_failure_details('Details:\n%s' % details)

    def _get_handler_method(self, libcode, name):
        method = getattr(libcode, name)
        if not inspect.isroutine(method):
            raise DataError('Not a method or function')
        return method

    def _try_to_create_handler(self, name, method):
        try:
            return self._create_handler(name, method)
        except:
            self._report_adding_keyword_failed(name)

    def _create_handler(self, handler_name, handler_method):
        return Handler(self, handler_name, handler_method)

    def _raise_creating_instance_failed(self):
        msg, details = utils.get_error_details()
        if self.positional_args:
            args = "argument%s %s" % (utils.plural_or_not(self.positional_args),
                                      utils.seq2str(self.positional_args))
        else:
            args = "no arguments"
        raise DataError("Creating an instance of the test library '%s' with %s "
                        "failed: %s\n%s" % (self.name, args, msg, details))


class _ClassLibrary(_BaseTestLibrary):

    def _get_handler_method(self, libinst, name):
        # Type is checked before using getattr to avoid calling properties,
        # most importantly bean properties generated by Jython (issue 188).
        for item in (libinst,) + inspect.getmro(libinst.__class__):
            if item in (object, Object):
                continue
            if not (hasattr(item, '__dict__') and name in item.__dict__):
                continue
            self._validate_handler(item.__dict__[name])
            return getattr(libinst, name)
        raise DataError('No non-implicit implementation found')

    def _validate_handler(self, handler):
        if not self._is_routine(handler):
            raise DataError('Not a method or function')
        if self._is_implicit_java_or_jython_method(handler):
            raise DataError('Implicit methods are ignored')

    def _is_routine(self, handler):
        # inspect.isroutine doesn't work with methods from Java classes
        # prior to Jython 2.5.2: http://bugs.jython.org/issue1223
        return inspect.isroutine(handler) or self._is_java_method(handler)

    def _is_java_method(self, handler):
        return utils.is_jython and isinstance(handler, PyReflectedFunction)

    def _is_implicit_java_or_jython_method(self, handler):
        if not self._is_java_method(handler):
            return False
        for signature in handler.argslist[:handler.nargs]:
            cls = signature.declaringClass
            if not (cls is Object or self._is_created_by_jython(handler, cls)):
                return False
        return True

    def _is_created_by_jython(self, handler, cls):
        proxy_methods = getattr(cls, '__supernames__', []) + ['classDictInit']
        return handler.__name__ in proxy_methods


class _ModuleLibrary(_BaseTestLibrary):

    def _get_scope(self, libcode):
        return 'GLOBAL'

    def _get_handler_method(self, libcode, name):
        method = _BaseTestLibrary._get_handler_method(self, libcode, name)
        if hasattr(libcode, '__all__') and name not in libcode.__all__:
            raise DataError('Not exposed as a keyword')
        return method

    def get_instance(self):
        self.init.arguments.check_arg_limits(self.positional_args)
        return self._libcode

    def _create_init_handler(self, libcode):
        return InitHandler(self, lambda: None)


class _HybridLibrary(_BaseTestLibrary):
    _log_failure = LOGGER.warn

    def _get_handler_names(self, instance):
        try:
            return instance.get_keyword_names()
        except AttributeError:
            return instance.getKeywordNames()


class _DynamicLibrary(_BaseTestLibrary):
    supports_named_arguments = False # this attribute is for libdoc
    _log_failure = LOGGER.warn

    def __init__(self, libcode, name, args, variables=None):
        _BaseTestLibrary.__init__(self, libcode, name, args, variables)
        self._get_kw_doc = \
            _DynamicMethod(libcode, 'get_keyword_documentation', default='')
        self._get_kw_args = \
            _DynamicMethod(libcode, 'get_keyword_arguments', default=None)

    @property
    def doc(self):
        return self._get_kw_doc(self.get_instance(), '__intro__') or self._doc

    def _get_handler_names(self, instance):
        try:
            return instance.get_keyword_names()
        except AttributeError:
            return instance.getKeywordNames()

    def _get_handler_method(self, instance, name_is_ignored):
        try:
            return instance.run_keyword
        except AttributeError:
            return instance.runKeyword

    def _create_handler(self, handler_name, handler_method):
        doc = self._get_kw_doc(self._libinst, handler_name)
        argspec = self._get_kw_args(self._libinst, handler_name)
        return DynamicHandler(self, handler_name, handler_method, doc, argspec)

    def _create_init_handler(self, libcode):
        docgetter = lambda: self._get_kw_doc(self.get_instance(), '__init__')
        return InitHandler(self, self._resolve_init_method(libcode), docgetter)

########NEW FILE########
__FILENAME__ = stoppablethread
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import threading


class Thread(threading.Thread):
    """A subclass of threading.Thread, with a stop() method.

    Original version posted by Connelly Barnes to python-list and available at
    http://mail.python.org/pipermail/python-list/2004-May/219465.html

    This version mainly has kill() changed to stop() to match java.lang.Thread.

    This is a hack but seems to be the best way the get this done. Only used
    in Python because in Jython we can use java.lang.Thread.
    """

    def __init__(self, runner, name=None):
        threading.Thread.__init__(self, target=runner, name=name)
        self._stopped = False

    def start(self):
        self.__run_backup = self.run
        self.run = self.__run
        threading.Thread.start(self)

    def stop(self):
        self._stopped = True

    def __run(self):
        """Hacked run function, which installs the trace."""
        sys.settrace(self._globaltrace)
        self.__run_backup()
        self.run = self.__run_backup

    def _globaltrace(self, frame, why, arg):
        if why == 'call':
            return self._localtrace
        else:
            return None

    def _localtrace(self, frame, why, arg):
        if self._stopped:
            if why == 'line':
                raise SystemExit()
        return self._localtrace

########NEW FILE########
__FILENAME__ = timeoutsignaling
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from signal import setitimer, signal, SIGALRM, ITIMER_REAL

from robot.errors import TimeoutError


class Timeout(object):

    def __init__(self, timeout, error):
        self._timeout = timeout
        self._error = error

    def execute(self, runnable):
        self._start_timer()
        try:
            return runnable()
        finally:
            self._stop_timer()

    def _start_timer(self):
        signal(SIGALRM, self._raise_timeout_error)
        setitimer(ITIMER_REAL, self._timeout)

    def _raise_timeout_error(self, signum, frame):
        raise TimeoutError(self._error)

    def _stop_timer(self):
        setitimer(ITIMER_REAL, 0)

########NEW FILE########
__FILENAME__ = timeoutthread
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
from threading import Event

from robot.errors import TimeoutError

if sys.platform.startswith('java'):
    from java.lang import Thread, Runnable
else:
    from .stoppablethread import Thread
    Runnable = object


TIMEOUT_THREAD_NAME = 'RobotFrameworkTimeoutThread'


class ThreadedRunner(Runnable):

    def __init__(self, runnable):
        self._runnable = runnable
        self._notifier = Event()
        self._result = None
        self._error = None
        self._traceback = None
        self._thread = None

    def run(self):
        try:
            self._result = self._runnable()
        except:
            self._error, self._traceback = sys.exc_info()[1:]
        self._notifier.set()

    __call__ = run

    def run_in_thread(self, timeout):
        self._thread = Thread(self, name=TIMEOUT_THREAD_NAME)
        self._thread.setDaemon(True)
        self._thread.start()
        self._notifier.wait(timeout)
        return self._notifier.isSet()

    def get_result(self):
        if self._error:
            raise self._error, None, self._traceback
        return self._result

    def stop_thread(self):
        self._thread.stop()


class Timeout(object):

    def __init__(self, timeout, error):
        self._timeout = timeout
        self._error = error

    def execute(self, runnable):
        runner = ThreadedRunner(runnable)
        if runner.run_in_thread(self._timeout):
            return runner.get_result()
        runner.stop_thread()
        raise TimeoutError(self._error)



########NEW FILE########
__FILENAME__ = timeoutwin
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import ctypes
import thread
import time
from threading import Timer

from robot.errors import TimeoutError


class Timeout(object):

    def __init__(self, timeout, timeout_error):
        self._runner_thread_id = thread.get_ident()
        self._timeout_error = self._create_timeout_error_class(timeout_error)
        self._timer = Timer(timeout, self._raise_timeout_error)
        self._timeout_occurred = False

    def _create_timeout_error_class(self, timeout_error):
        return type(TimeoutError.__name__,
                   (TimeoutError,),
                   {'__unicode__': lambda self: timeout_error})

    def execute(self, runnable):
        self._start_timer()
        try:
            return runnable()
        finally:
            self._stop_timer()

    def _start_timer(self):
        self._timer.start()

    def _stop_timer(self):
        self._timer.cancel()
        # In case timeout has occurred but the exception has not yet been
        # thrown we need to do this to ensure that the exception
        # is not thrown in an unsafe location
        if self._timeout_occurred:
            self._cancel_exception()
            raise self._timeout_error()

    def _raise_timeout_error(self):
        self._timeout_occurred = True
        return_code = self._try_to_raise_timeout_error_in_runner_thread()
        # return code tells how many threads have been influenced
        while return_code > 1: # if more than one then cancel and retry
            self._cancel_exception()
            time.sleep(0) # yield so that other threads will get time
            return_code = self._try_to_raise_timeout_error_in_runner_thread()

    def _try_to_raise_timeout_error_in_runner_thread(self):
        return ctypes.pythonapi.PyThreadState_SetAsyncExc(
            self._runner_thread_id,
            ctypes.py_object(self._timeout_error))

    def _cancel_exception(self):
        ctypes.pythonapi.PyThreadState_SetAsyncExc(self._runner_thread_id, None)

########NEW FILE########
__FILENAME__ = usererrorhandler
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.errors import DataError


class UserErrorHandler:
    """Created if creating handlers fail -- running raises DataError.

    The idea is not to raise DataError at processing time and prevent all
    tests in affected test case file from executing. Instead UserErrorHandler
    is created and if it is ever run DataError is raised then.
    """
    type = 'error'

    def __init__(self, name, error):
        self.name = self.longname = name
        self.doc = self.shortdoc = ''
        self.error = error
        self.timeout = ''

    def init_keyword(self, varz):
        pass

    def run(self, *args):
        raise DataError(self.error)

########NEW FILE########
__FILENAME__ = userkeyword
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import re

from robot.common import BaseLibrary, UserErrorHandler
from robot.errors import DataError, ExecutionFailed, UserKeywordExecutionFailed
from robot.variables import is_list_var, VariableSplitter
from robot.output import LOGGER
from robot import utils

from .keywords import Keywords
from .fixture import Teardown
from .timeouts import KeywordTimeout
from .arguments import UserKeywordArguments


class UserLibrary(BaseLibrary):
    supports_named_arguments = True # this attribute is for libdoc

    def __init__(self, user_keywords, path=None):
        self.name = self._get_name_for_resource_file(path)
        self.handlers = utils.NormalizedDict(ignore=['_'])
        self.embedded_arg_handlers = []
        for kw in user_keywords:
            try:
                handler = EmbeddedArgsTemplate(kw, self.name)
            except DataError, err:
                LOGGER.error("Creating user keyword '%s' failed: %s"
                             % (kw.name, unicode(err)))
                continue
            except TypeError:
                handler = UserKeywordHandler(kw, self.name)
            else:
                self.embedded_arg_handlers.append(handler)
            if handler.name in self.handlers:
                error = "Keyword '%s' defined multiple times." % handler.name
                handler = UserErrorHandler(handler.name, error)
            self.handlers[handler.name] = handler

    def _get_name_for_resource_file(self, path):
        if path is None:
            return None
        return os.path.splitext(os.path.basename(path))[0]

    def has_handler(self, name):
        if BaseLibrary.has_handler(self, name):
            return True
        for template in self.embedded_arg_handlers:
            try:
                EmbeddedArgs(name, template)
            except TypeError:
                pass
            else:
                return True
        return False

    def get_handler(self, name):
        try:
            return BaseLibrary.get_handler(self, name)
        except DataError, error:
            found = self._get_embedded_arg_handlers(name)
            if not found:
                raise error
            if len(found) == 1:
                return found[0]
            self._raise_multiple_matching_keywords_found(name, found)

    def _get_embedded_arg_handlers(self, name):
        found = []
        for template in self.embedded_arg_handlers:
            try:
                found.append(EmbeddedArgs(name, template))
            except TypeError:
                pass
        return found

    def _raise_multiple_matching_keywords_found(self, name, found):
        names = utils.seq2str([f.orig_name for f in found])
        if self.name is None:
            where = "Test case file"
        else:
            where = "Resource file '%s'" % self.name
        raise DataError("%s contains multiple keywords matching name '%s'\n"
                        "Found: %s" % (where, name, names))


class UserKeywordHandler(object):
    type = 'user'

    def __init__(self, keyword, libname):
        self.name = keyword.name
        self.keywords = Keywords(keyword.steps)
        self.return_value = keyword.return_.value
        self.teardown = keyword.teardown
        self.libname = libname
        self.doc = self._doc = keyword.doc.value
        self._timeout = keyword.timeout
        self._keyword_args = keyword.args.value

    @property
    def longname(self):
        return '%s.%s' % (self.libname, self.name) if self.libname else self.name

    @property
    def shortdoc(self):
        return self.doc.splitlines()[0] if self.doc else ''

    def init_keyword(self, varz):
        self._errors = []
        self.doc = varz.replace_meta('Documentation', self._doc, self._errors)
        self.timeout = KeywordTimeout(self._timeout.value, self._timeout.message)
        self.timeout.replace_variables(varz)

    def run(self, context, arguments):
        context.start_user_keyword(self)
        try:
            return self._run(context, arguments)
        finally:
            context.end_user_keyword()

    def _run(self, context, argument_values):
        args_spec = UserKeywordArguments(self._keyword_args, self.longname)
        variables = context.get_current_vars()
        if context.dry_run:
            return self._dry_run(context, variables, args_spec, argument_values)
        return self._variable_resolving_run(context, variables, args_spec, argument_values)

    def _dry_run(self, context, variables, args_spec, argument_values):
        resolved_arguments = args_spec.resolve_arguments_for_dry_run(argument_values)
        error = self._execute(context, variables, args_spec, resolved_arguments)
        if error:
            raise error

    def _variable_resolving_run(self, context, variables, args_spec, argument_values):
        resolved_arguments = args_spec.resolve(argument_values, variables,
                                               context.output)
        error = self._execute(context, variables, args_spec, resolved_arguments)
        if error and not error.can_continue(context.teardown):
            raise error
        return_value = self._get_return_value(variables)
        if error:
            error.return_value = return_value
            raise error
        return return_value

    def _execute(self, context, variables, args_spec, resolved_arguments):
        args_spec.set_variables(resolved_arguments, variables, context.output)
        self._verify_keyword_is_valid()
        self.timeout.start()
        try:
            self.keywords.run(context)
        except ExecutionFailed, error:
            pass
        else:
            error = None
        td_error = self._run_teardown(context, error)
        if error or td_error:
            return UserKeywordExecutionFailed(error, td_error)

    def _run_teardown(self, context, error):
        if not self.teardown:
            return None
        teardown = Teardown(self.teardown.name, self.teardown.args)
        teardown.replace_variables(context.get_current_vars(), [])
        context.start_keyword_teardown(error)
        error = teardown.run(context)
        context.end_keyword_teardown()
        return error

    def _verify_keyword_is_valid(self):
        if self._errors:
            raise DataError('User keyword initialization failed:\n%s'
                            % '\n'.join(self._errors))
        if not (self.keywords or self.return_value):
            raise DataError("User keyword '%s' contains no keywords"
                            % self.name)

    def _get_return_value(self, variables):
        if not self.return_value:
            return None
        try:
            ret = variables.replace_list(self.return_value)
        except DataError, err:
            raise DataError('Replacing variables from keyword return value '
                            'failed: %s' % unicode(err))
        if len(ret) != 1 or is_list_var(self.return_value[0]):
            return ret
        return ret[0]


class EmbeddedArgsTemplate(UserKeywordHandler):
    _regexp_extension = re.compile(r'(?<!\\)\(\?.+\)')
    _regexp_group_start = re.compile(r'(?<!\\)\((.*?)\)')
    _regexp_group_escape = r'(?:\1)'
    _default_pattern = '.*?'
    _variable_pattern = r'\$\{[^\}]+\}'

    def __init__(self, keyword, libname):
        if keyword.args.value:
            raise TypeError('Cannot have normal arguments')
        self.embedded_args, self.name_regexp \
                = self._read_embedded_args_and_regexp(keyword.name)
        if not self.embedded_args:
            raise TypeError('Must have embedded arguments')
        UserKeywordHandler.__init__(self, keyword, libname)
        self.keyword = keyword

    def _read_embedded_args_and_regexp(self, string):
        args = []
        full_pattern = ['^']
        while True:
            before, variable, rest = self._split_from_variable(string)
            if before is None:
                break
            variable, pattern = self._get_regexp_pattern(variable)
            args.append('${%s}' % variable)
            full_pattern.extend([re.escape(before), '(%s)' % pattern])
            string = rest
        full_pattern.extend([re.escape(rest), '$'])
        return args, self._compile_regexp(full_pattern)

    def _split_from_variable(self, string):
        var = VariableSplitter(string, identifiers=['$'])
        if var.identifier is None:
            return None, None, string
        return string[:var.start], var.base, string[var.end:]

    def _get_regexp_pattern(self, variable):
        if ':' not in variable:
            return variable, self._default_pattern
        variable, pattern = variable.split(':', 1)
        return variable, self._format_custom_regexp(pattern)

    def _format_custom_regexp(self, pattern):
        for formatter in (self._regexp_extensions_are_not_allowed,
                          self._make_groups_non_capturing,
                          self._unescape_closing_curly,
                          self._add_automatic_variable_pattern):
            pattern = formatter(pattern)
        return pattern

    def _regexp_extensions_are_not_allowed(self, pattern):
        if not self._regexp_extension.search(pattern):
            return pattern
        raise DataError('Regexp extensions are not allowed in embedded '
                        'arguments.')

    def _make_groups_non_capturing(self, pattern):
        return self._regexp_group_start.sub(self._regexp_group_escape, pattern)

    def _unescape_closing_curly(self, pattern):
        return pattern.replace('\\}', '}')

    def _add_automatic_variable_pattern(self, pattern):
        return '%s|%s' % (pattern, self._variable_pattern)

    def _compile_regexp(self, pattern):
        try:
            return re.compile(''.join(pattern), re.IGNORECASE)
        except:
            raise DataError("Compiling embedded arguments regexp failed: %s"
                            % utils.get_error_message())


class EmbeddedArgs(UserKeywordHandler):

    def __init__(self, name, template):
        match = template.name_regexp.match(name)
        if not match:
            raise TypeError('Does not match given name')
        UserKeywordHandler.__init__(self, template.keyword, template.libname)
        self.embedded_args = zip(template.embedded_args, match.groups())
        self.name = name
        self.orig_name = template.name

    def _run(self, context, args):
        if not context.dry_run:
            for name, value in self.embedded_args:
                context.get_current_vars()[name] = \
                    context.get_current_vars().replace_scalar(value)
        return UserKeywordHandler._run(self, context, args)

########NEW FILE########
__FILENAME__ = testdoc
#!/usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

USAGE = """robot.testdoc -- Robot Framework test data documentation tool

Version:  <VERSION>

Usage:  python -m robot.testdoc [options] data_sources output_file

Testdoc generates a high level test documentation based on Robot Framework
test data. Generated documentation includes name, documentation and other
metadata of each test suite and test case, as well as the top-level keywords
and their arguments.

Options
=======

  -T --title title       Set the title of the generated documentation.
                         Underscores in the title are converted to spaces.
                         The default title is the name of the top level suite.
  -N --name name         Override the name of the top level suite.
  -D --doc document      Override the documentation of the top level suite.
  -M --metadata name:value *  Set/override metadata of the top level suite.
  -G --settag tag *      Set given tag(s) to all test cases.
  -t --test name *       Include tests by name.
  -s --suite name *      Include suites by name.
  -i --include tag *     Include tests by tags.
  -e --exclude tag *     Exclude tests by tags.
  -h -? --help           Print this help.

All options except --title have exactly same semantics as same options have
when executing test cases.

Execution
=========

Data can be given as a single file, directory, or as multiple files and
directories. In all these cases, the last argument must be the file where
to write the output. The output is always created in HTML format.

Testdoc works with all interpreters supported by Robot Framework (Python,
Jython and IronPython). It can be executed as an installed module like
`python -m robot.testdoc` or as a script like `python path/robot/testdoc.py`.

Examples:

  python -m robot.testdoc my_test.html testdoc.html
  jython -m robot.testdoc -N smoke_tests -i smoke path/to/my_tests smoke.html
  ipy path/to/robot/testdoc.py first_suite.txt second_suite.txt output.html
"""

import sys
import os
from os.path import abspath, dirname
import codecs
import time

# Allows running as a script. __name__ check needed with multiprocessing:
# http://code.google.com/p/robotframework/issues/detail?id=1137
if 'robot' not in sys.modules and __name__ == '__main__':
    import pythonpathsetter

from robot import utils
from robot.running import TestSuite, Keyword
from robot.conf import RobotSettings
from robot.parsing import disable_curdir_processing
from robot.htmldata import HtmlFileWriter, ModelWriter, JsonWriter, TESTDOC


class TestDoc(utils.Application):

    def __init__(self):
        utils.Application.__init__(self, USAGE, arg_limits=(2,))

    def main(self, args, title=None, **options):
        datasources = args[0:-1]
        outfile = abspath(args[-1])
        suite = TestSuiteFactory(datasources, **options)
        self._write_test_doc(suite, outfile, title)
        self.console(outfile)

    def _write_test_doc(self, suite, outfile, title):
        output = codecs.open(outfile, 'w', 'UTF-8')
        model_writer = TestdocModelWriter(output, suite, title)
        HtmlFileWriter(output, model_writer).write(TESTDOC)
        output.close()


@disable_curdir_processing
def TestSuiteFactory(datasources, **options):
    if isinstance(datasources, basestring):
        datasources = [datasources]
    return TestSuite(datasources, RobotSettings(options))


class TestdocModelWriter(ModelWriter):

    def __init__(self, output, suite, title=None):
        self._output = output
        self._output_path = getattr(output, 'name', None)
        self._suite = suite
        self._title = title.replace('_', ' ') if title else suite.name

    def write(self, line):
        self._output.write('<script type="text/javascript">' + os.linesep)
        self.write_data()
        self._output.write('</script>' + os.linesep)

    def write_data(self):
        generated_time = time.localtime()
        model = {
            'suite': JsonConverter(self._output_path).convert(self._suite),
            'title': self._title,
            'generated': utils.format_time(generated_time, gmtsep=' '),
            'generatedMillis': long(time.mktime(generated_time) * 1000)
        }
        JsonWriter(self._output).write_json('testdoc = ', model)


class JsonConverter(object):

    def __init__(self, output_path=None):
        self._output_path = output_path

    def convert(self, suite):
        return self._convert_suite(suite)

    def _convert_suite(self, suite):
        return {
            'source': suite.source or '',
            'relativeSource': self._get_relative_source(suite.source),
            'id': suite.id,
            'name': suite.name,
            'fullName': suite.longname,
            'doc': self._html(suite.doc),
            'metadata': [(n, self._html(v)) for n, v in suite.metadata.items()],
            'numberOfTests': suite.get_test_count(),
            'suites': self._convert_suites(suite),
            'tests': self._convert_tests(suite),
            'keywords': list(self._convert_keywords(suite))
        }

    def _get_relative_source(self, source):
        if not source or not self._output_path:
            return ''
        return utils.get_link_path(source, dirname(self._output_path))

    def _html(self, item):
        return utils.html_format(utils.unescape(item))

    def _convert_suites(self, suite):
        return [self._convert_suite(s) for s in suite.suites]

    def _convert_tests(self, suite):
        return [self._convert_test(t) for t in suite.tests]

    def _convert_test(self, test):
        return {
            'name': test.name,
            'fullName': test.longname,
            'id': test.id,
            'doc': self._html(test.doc),
            'tags': utils.normalize_tags(test.tags),
            'timeout': self._get_timeout(test.timeout),
            'keywords': list(self._convert_keywords(test))
        }

    def _convert_keywords(self, item):
        if item.setup.name:
            yield self._convert_keyword(item.setup, type='SETUP')
        for kw in getattr(item, 'keywords', []):
            yield self._convert_keyword(kw)
        if item.teardown.name:
            yield self._convert_keyword(item.teardown, type='TEARDOWN')

    def _convert_keyword(self, kw, type=None):
        return {
            'name': kw._get_name(kw.name) if isinstance(kw, Keyword) else kw.name,
            'arguments': ', '.join(kw.args),
            'type': type or {'kw': 'KEYWORD', 'for': 'FOR'}[kw.type]
        }

    def _get_timeout(self, timeout):
        try:
            tout = utils.secs_to_timestr(utils.timestr_to_secs(timeout.string))
        except ValueError:
            tout = timeout.string
        if timeout.message:
            tout += ' :: ' + timeout.message
        return tout


def testdoc_cli(args):
    """Executes testdoc similarly as from the command line.

    :param args: command line arguments as a list of strings.

    Example:
       testdoc_cli(['--title', 'Test Plan', 'mytests', 'plan.html'])
    """
    TestDoc().execute_cli(args)


if __name__ == '__main__':
    testdoc_cli(sys.argv[1:])

########NEW FILE########
__FILENAME__ = tidy
#!/usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

USAGE = """robot.tidy -- Robot Framework test data clean-up tool.

Version:  <VERSION>

Usage:  python -m robot.tidy [options] inputfile
   or:  python -m robot.tidy [options] inputfile [outputfile]
   or:  python -m robot.tidy --inplace [options] inputfile [more input files]
   or:  python -m robot.tidy --recursive [options] directory

Tidy tool can be used to clean up and change format of Robot Framework test
data files. The output is written into the standard output stream by default,
but an optional output file can be given starting from Robot Framework 2.7.5.
Files can also be modified in-place using --inplace or --recursive options.

Options
=======

 -i --inplace    Tidy given file(s) so that original file(s) are overwritten
                 (or removed, if the format is changed). When this option is
                 used, it is possible to give multiple input files.
                 Examples:
                   python -m robot.tidy --inplace tests.html
                   python -m robot.tidy --inplace --format txt *.html
 -r --recursive  Process given directory recursively. Files in the directory
                 are processed in-place similarly as when --inplace option
                 is used.
 -f --format txt|html|tsv|robot
                 Output file format. If omitted, the format of the input
                 file is used.
 -p --usepipes   Use pipe (`|`) as a cell separator in the txt format.
 -s --spacecount number
                 The number of spaces between cells in the txt format.
                 New in Robot Framework 2.7.3.
 -l --lineseparator native|windows|unix
                 Line separator to use in outputs. The default is 'native'.
                 native:  use operating system's native line separators
                 windows: use Windows line separators (CRLF)
                 unix:    use Unix line separators (LF)
                 New in Robot Framework 2.7.6.
 -h -? --help    Show this help.

Cleaning up the test data
=========================

Test case files created with HTML editors or written by hand can be normalized
using Tidy. Tidy always writes consistent headers, consistent order for
settings, and consistent amount of whitespace between cells and tables.

Examples:
  python -m robot.tidy messed_up_tests.html cleaned_tests.html
  python -m robot.tidy --inplace tests.txt

Changing the test data format
=============================

Robot Framework supports test data in HTML, TSV and TXT formats, and Tidy
makes changing between the formats trivial. Input format is always determined
based on the extension of the input file. Output format is got from the
extension of the output file, when used, and can also be set using the --format
option.

Examples:
  python -m robot.tidy tests.html tests.tsv
  python -m robot.tidy --format tsv --inplace tests.html
  python -m robot.tidy --format txt --recursive mytests

Output encoding
===============

All output files are written using UTF-8 encoding. Outputs written to the
console use the current console encoding.

Alternative execution
=====================

In the above examples Tidy is used only with Python, but it works also with
Jython and IronPython. Above it is executed as an installed module, but it
can also be run as a script like `python path/robot/tidy.py`.
"""

import os
import sys
from StringIO import StringIO

# Allows running as a script. __name__ check needed with multiprocessing:
# http://code.google.com/p/robotframework/issues/detail?id=1137
if 'robot' not in sys.modules and __name__ == '__main__':
    import pythonpathsetter

from robot.errors import DataError
from robot.parsing import (ResourceFile, TestDataDirectory, TestCaseFile,
                           disable_curdir_processing)
from robot.utils import Application


class Tidy(object):

    def __init__(self, **options):
        self._options = options

    def file(self, path, output=None):
        data = self._parse_data(path)
        outfile = open(output, 'wb') if output else StringIO()
        try:
            self._save_file(data, outfile)
            if not output:
                return outfile.getvalue().replace('\r\n', '\n').decode('UTF-8')
        finally:
            outfile.close()

    def directory(self, path):
        self._save_directory(self._parse_data(path))

    def inplace(self, path):
        self._save_file(self._parse_data(path))

    @disable_curdir_processing
    def _parse_data(self, path):
        if os.path.isdir(path):
            return TestDataDirectory(source=path).populate()
        if self._is_init_file(path):
            path = os.path.dirname(path)
            return TestDataDirectory(source=path).populate(recurse=False)
        try:
            return TestCaseFile(source=path).populate()
        except DataError:
            try:
                return ResourceFile(source=path).populate()
            except DataError:
                raise DataError("Invalid data source '%s'." % path)

    def _is_init_file(self, path):
        return os.path.splitext(os.path.basename(path))[0].lower() == '__init__'

    def _save_file(self, data, output=None):
        source = data.initfile if self._is_directory(data) else data.source
        if source and not output:
            os.remove(source)
        data.save(output=output, **self._options)

    def _save_directory(self, data):
        if not self._is_directory(data):
            self._save_file(data)
            return
        if data.initfile:
            self._save_file(data)
        for child in data.children:
            self._save_directory(child)

    def _is_directory(self, data):
        return hasattr(data, 'initfile')


class TidyCommandLine(Application):

    def __init__(self):
        Application.__init__(self, USAGE, arg_limits=(1,))

    def main(self, arguments, recursive=False, inplace=False, format='txt',
             usepipes=False, spacecount=4, lineseparator=os.linesep):
        tidy = Tidy(format=format, pipe_separated=usepipes,
                    txt_separating_spaces=spacecount,
                    line_separator=lineseparator)
        if recursive:
            tidy.directory(arguments[0])
        elif inplace:
            for source in arguments:
                tidy.inplace(source)
        else:
            output = tidy.file(*arguments)
            self.console(output)

    def validate(self, opts, args):
        self._validate_mode_and_arguments(args, **opts)
        opts['format'] = self._validate_format(args, **opts)
        opts['lineseparator'] = self._validate_line_sep(**opts)
        if not opts['spacecount']:
            opts.pop('spacecount')
        else:
            opts['spacecount'] = self._validate_spacecount(opts['spacecount'])
        return opts, args

    def _validate_mode_and_arguments(self, args, inplace, recursive, **others):
        if inplace and recursive:
            raise DataError('--recursive and --inplace can not be used together.')
        if recursive and (len(args) > 1 or not os.path.isdir(args[0])):
            raise DataError('--recursive requires exactly one directory as argument.')
        if not (inplace or recursive) and len(args) > 2:
            raise DataError('Default mode requires 1 or 2 arguments.')

    def _validate_format(self, args, format, inplace, recursive, **others):
        if not format:
            if inplace or recursive or len(args) < 2:
                return None
            format = os.path.splitext(args[1])[1][1:]
        format = format.upper()
        if format not in ('TXT', 'TSV', 'HTML', 'ROBOT'):
            raise DataError("Invalid format '%s'." % format)
        return format

    def _validate_line_sep(self, lineseparator, **others):
        if not lineseparator:
            return os.linesep
        values = {'native': os.linesep, 'windows': '\r\n', 'unix': '\n'}
        try:
            return values[lineseparator.lower()]
        except KeyError:
            raise DataError("Invalid line separator '%s'." % lineseparator)

    def _validate_spacecount(self, spacecount):
        try:
            spacecount = int(spacecount)
            if spacecount < 2:
                raise ValueError
        except ValueError:
            raise DataError('--spacecount must be an integer greater than 1.')
        return spacecount


def tidy_cli(args):
    """Executes tidy similarly as from the command line.

    :param args: command line arguments as a list of strings.

    Example:
        tidy_cli(['--format', 'txt', 'mytests.html'])
    """
    TidyCommandLine().execute_cli(args)


if __name__ == '__main__':
    tidy_cli(sys.argv[1:])

########NEW FILE########
__FILENAME__ = application
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import sys
from contextlib import contextmanager

from robot.errors import (INFO_PRINTED, DATA_ERROR, STOPPED_BY_USER,
                          FRAMEWORK_ERROR, Information, DataError)

from .argumentparser import ArgumentParser
from .encoding import encode_output
from .error import get_error_details


class Application(object):

    def __init__(self, usage, name=None, version=None, arg_limits=None,
                 logger=None, **auto_options):
        self._ap = ArgumentParser(usage, name, version, arg_limits,
                                  self.validate, **auto_options)
        self._logger = logger or DefaultLogger()

    def main(self, arguments, **options):
        raise NotImplementedError

    def validate(self, options, arguments):
        return options, arguments

    def execute_cli(self, cli_arguments):
        with self._logging():
            options, arguments = self._parse_arguments(cli_arguments)
            rc = self._execute(arguments, options)
        self._exit(rc)

    def console(self, msg):
        if msg:
            print encode_output(msg)

    @contextmanager
    def _logging(self):
        self._logger.register_file_logger()
        self._logger.info('%s %s' % (self._ap.name, self._ap.version))
        try:
            yield
        finally:
            self._logger.close()

    def _parse_arguments(self, cli_args):
        try:
            options, arguments = self._ap.parse_args(cli_args)
        except Information, msg:
            self._report_info(unicode(msg))
        except DataError, err:
            self._report_error(unicode(err), help=True, exit=True)
        else:
            self._logger.info('Arguments: %s' % ','.join(arguments))
            return options, arguments

    def execute(self, *arguments, **options):
        with self._logging():
            return self._execute(arguments, options)

    def _execute(self, arguments, options):
        try:
            rc = self.main(arguments, **options)
        except DataError, err:
            return self._report_error(unicode(err), help=True)
        except (KeyboardInterrupt, SystemExit):
            return self._report_error('Execution stopped by user.',
                                      rc=STOPPED_BY_USER)
        except:
            error, details = get_error_details()
            return self._report_error('Unexpected error: %s' % error,
                                      details, rc=FRAMEWORK_ERROR)
        else:
            return rc or 0

    def _report_info(self, err):
        self.console(unicode(err))
        self._exit(INFO_PRINTED)

    def _report_error(self, message, details=None, help=False, rc=DATA_ERROR,
                      exit=False):
        if help:
            message += '\n\nTry --help for usage information.'
        if details:
            message += '\n' + details
        self._logger.error(message)
        if exit:
            self._exit(rc)
        return rc

    def _exit(self, rc):
        sys.exit(rc)


class DefaultLogger(object):

    def register_file_logger(self):
        pass

    def info(self, message):
        pass

    def error(self, message):
        print encode_output(message)

    def close(self):
        pass

########NEW FILE########
__FILENAME__ = argumentparser
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import getopt     # optparse was not supported by Jython 2.2
import os
import re
import sys
import glob
import string
import codecs
import textwrap

from robot.errors import DataError, Information, FrameworkError
from robot.version import get_full_version

from .misc import plural_or_not
from .encoding import decode_output, decode_from_system, utf8open


ESCAPES = dict(
    space   = ' ', apos    = "'", quot   = '"', lt     = '<', gt     = '>',
    pipe    = '|', star    = '*', comma  = ',', slash  = '/', semic  = ';',
    colon   = ':', quest   = '?', hash   = '#', amp    = '&', dollar = '$',
    percent = '%', at      = '@', exclam = '!', paren1 = '(', paren2 = ')',
    square1 = '[', square2 = ']', curly1 = '{', curly2 = '}', bslash = '\\'
)


class ArgumentParser:
    _opt_line_re = re.compile('''
    ^\s{1,4}      # 1-4 spaces in the beginning of the line
    ((-\S\s)*)    # all possible short options incl. spaces (group 1)
    --(\S{2,})    # required long option (group 3)
    (\s\S+)?      # optional value (group 4)
    (\s\*)?       # optional '*' telling option allowed multiple times (group 5)
    ''', re.VERBOSE)

    def __init__(self, usage, name=None, version=None, arg_limits=None,
                 validator=None, auto_help=True, auto_version=True,
                 auto_escape=True, auto_pythonpath=True, auto_argumentfile=True):
        """Available options and tool name are read from the usage.

        Tool name is got from the first row of the usage. It is either the
        whole row or anything before first ' -- '.
        """
        if not usage:
            raise FrameworkError('Usage cannot be empty')
        self.name = name or usage.splitlines()[0].split(' -- ')[0].strip()
        self.version = version or get_full_version()
        self._usage = usage
        self._arg_limit_validator = ArgLimitValidator(arg_limits)
        self._validator = validator
        self._auto_help = auto_help
        self._auto_version = auto_version
        self._auto_escape = auto_escape
        self._auto_pythonpath = auto_pythonpath
        self._auto_argumentfile = auto_argumentfile
        self._short_opts = ''
        self._long_opts = []
        self._multi_opts = []
        self._toggle_opts = []
        self._names = []
        self._short_to_long = {}
        self._expected_args = ()
        self._create_options(usage)

    def parse_args(self, args_list):
        """Parse given arguments and return options and positional arguments.

        Arguments must be given as a list and are typically sys.argv[1:].

        Options are retuned as a dictionary where long options are keys. Value
        is a string for those options that can be given only one time (if they
        are given multiple times the last value is used) or None if the option
        is not used at all. Value for options that can be given multiple times
        (denoted with '*' in the usage) is a list which contains all the given
        values and is empty if options are not used. Options not taken
        arguments have value False when they are not set and True otherwise.

        Positional arguments are returned as a list in the order they are given.

        If 'check_args' is True, this method will automatically check that
        correct number of arguments, as parsed from the usage line, are given.
        If the last argument in the usage line ends with the character 's',
        the maximum number of arguments is infinite.

        Possible errors in processing arguments are reported using DataError.

        Some options have a special meaning and are handled automatically
        if defined in the usage and given from the command line:

        --escape option can be used to automatically unescape problematic
        characters given in an escaped format.

        --argumentfile can be used to automatically read arguments from
        a specified file. When --argumentfile is used, the parser always
        allows using it multiple times. Adding '*' to denote that is thus
        recommend. A special value 'stdin' can be used to read arguments from
        stdin instead of a file.

        --pythonpath can be used to add extra path(s) to sys.path.

        --help and --version automatically generate help and version messages.
        Version is generated based on the tool name and version -- see __init__
        for information how to set them. Help contains the whole usage given to
        __init__. Possible <VERSION> text in the usage is replaced with the
        given version. Possible <--ESCAPES--> is replaced with available
        escapes so that they are wrapped to multiple lines but take the same
        amount of horizontal space as <---ESCAPES--->. Both help and version
        are wrapped to Information exception.
        """
        args_list = [decode_from_system(a) for a in args_list]
        if self._auto_argumentfile:
            args_list = self._process_possible_argfile(args_list)
        opts, args = self._parse_args(args_list)
        opts, args = self._handle_special_options(opts, args)
        self._arg_limit_validator(args)
        if self._validator:
            opts, args = self._validator(opts, args)
        return opts, args

    def _handle_special_options(self, opts, args):
        if self._auto_escape and opts.get('escape'):
            opts, args = self._unescape_opts_and_args(opts, args)
        if self._auto_help and opts.get('help'):
            self._raise_help()
        if self._auto_version and opts.get('version'):
            self._raise_version()
        if self._auto_pythonpath and opts.get('pythonpath'):
            sys.path = self._get_pythonpath(opts['pythonpath']) + sys.path
        for auto, opt in [(self._auto_help, 'help'),
                          (self._auto_version, 'version'),
                          (self._auto_escape, 'escape'),
                          (self._auto_pythonpath, 'pythonpath'),
                          (self._auto_argumentfile, 'argumentfile')]:
            if auto and opt in opts:
                opts.pop(opt)
        return opts, args

    def _parse_args(self, args):
        args = [self._lowercase_long_option(a) for a in args]
        try:
            opts, args = getopt.getopt(args, self._short_opts, self._long_opts)
        except getopt.GetoptError, err:
            raise DataError(err.msg)
        return self._process_opts(opts), self._glob_args(args)

    def _lowercase_long_option(self, opt):
        if not opt.startswith('--'):
            return opt
        if '=' not in opt:
            return opt.lower()
        opt, value = opt.split('=', 1)
        return '%s=%s' % (opt.lower(), value)

    def _unescape_opts_and_args(self, opts, args):
        try:
            escape_strings = opts['escape']
        except KeyError:
            raise FrameworkError("No 'escape' in options")
        escapes = self._get_escapes(escape_strings)
        for name, value in opts.items():
            if name != 'escape':
                opts[name] = self._unescape(value, escapes)
        return opts, [self._unescape(arg, escapes) for arg in args]

    def _process_possible_argfile(self, args):
        options = ['--argumentfile']
        for short_opt, long_opt in self._short_to_long.items():
            if long_opt == 'argumentfile':
                options.append('-'+short_opt)
        return ArgFileParser(options).process(args)

    def _get_escapes(self, escape_strings):
        escapes = {}
        for estr in escape_strings:
            try:
                name, value = estr.split(':', 1)
            except ValueError:
                raise DataError("Invalid escape string syntax '%s'. "
                                "Expected: what:with" % estr)
            try:
                escapes[value] = ESCAPES[name.lower()]
            except KeyError:
                raise DataError("Invalid escape '%s'. Available: %s"
                                % (name, self._get_available_escapes()))
        return escapes

    def _unescape(self, value, escapes):
        if value in [None, True, False]:
            return value
        if isinstance(value, list):
            return [self._unescape(item, escapes) for item in value]
        for esc_name, esc_value in escapes.items():
            if esc_name in value:
                value = value.replace(esc_name, esc_value)
        return value

    def _process_opts(self, opt_tuple):
        opts = self._init_opts()
        for name, value in opt_tuple:
            name = self._get_name(name)
            if name in self._multi_opts:
                opts[name].append(value)
            elif name in self._toggle_opts:
                opts[name] = not opts[name]
            else:
                opts[name] = value
        return opts

    def _glob_args(self, args):
        temp = []
        for path in args:
            paths = sorted(glob.glob(path))
            if paths:
                temp.extend(paths)
            else:
                temp.append(path)
        return temp

    def _init_opts(self):
        opts = {}
        for name in self._names:
            if name in self._multi_opts:
                opts[name] = []
            elif name in self._toggle_opts:
                opts[name] = False
            else:
                opts[name] = None
        return opts

    def _get_name(self, name):
        name = name.lstrip('-')
        try:
            return self._short_to_long[name]
        except KeyError:
            return name

    def _create_options(self, usage):
        for line in usage.splitlines():
            res = self._opt_line_re.match(line)
            if res:
                self._create_option(short_opts=[o[1] for o in res.group(1).split()],
                                    long_opt=res.group(3).lower(),
                                    takes_arg=bool(res.group(4)),
                                    is_multi=bool(res.group(5)))

    def _create_option(self, short_opts, long_opt, takes_arg, is_multi):
        if long_opt in self._names:
            self._raise_option_multiple_times_in_usage('--' + long_opt)
        self._names.append(long_opt)
        for sopt in short_opts:
            if self._short_to_long.has_key(sopt):
                self._raise_option_multiple_times_in_usage('-' + sopt)
            self._short_to_long[sopt] = long_opt
        if is_multi:
            self._multi_opts.append(long_opt)
        if takes_arg:
            long_opt += '='
            short_opts = [sopt+':' for sopt in short_opts]
        else:
            self._toggle_opts.append(long_opt)
        self._long_opts.append(long_opt)
        self._short_opts += (''.join(short_opts))

    def _get_pythonpath(self, paths):
        if isinstance(paths, basestring):
            paths = [paths]
        temp = []
        for path in self._split_pythonpath(paths):
            temp.extend(glob.glob(path))
        return [os.path.abspath(path) for path in temp if path]

    def _split_pythonpath(self, paths):
        # paths may already contain ':' as separator
        tokens = ':'.join(paths).split(':')
        if os.sep == '/':
            return tokens
        # Fix paths split like 'c:\temp' -> 'c', '\temp'
        ret = []
        drive = ''
        for item in tokens:
            item = item.replace('/', '\\')
            if drive and item.startswith('\\'):
                ret.append('%s:%s' % (drive, item))
                drive = ''
                continue
            if drive:
                ret.append(drive)
                drive = ''
            if len(item) == 1 and item in string.letters:
                drive = item
            else:
                ret.append(item)
        if drive:
            ret.append(drive)
        return ret

    def _get_available_escapes(self):
        names = sorted(ESCAPES.keys(), key=str.lower)
        return ', '.join('%s (%s)' % (n, ESCAPES[n]) for n in names)

    def _raise_help(self):
        msg = self._usage
        if self.version:
            msg = msg.replace('<VERSION>', self.version)
        def replace_escapes(res):
            escapes = 'Available escapes: ' + self._get_available_escapes()
            lines = textwrap.wrap(escapes, width=len(res.group(2)))
            indent = ' ' * len(res.group(1))
            return '\n'.join(indent + line for line in lines)
        msg = re.sub('( *)(<-+ESCAPES-+>)', replace_escapes, msg)
        raise Information(msg)

    def _raise_version(self):
        raise Information('%s %s' % (self.name, self.version))

    def _raise_option_multiple_times_in_usage(self, opt):
        raise FrameworkError("Option '%s' multiple times in usage" % opt)


class ArgLimitValidator(object):

    def __init__(self, arg_limits):
        self._min_args, self._max_args = self._parse_arg_limits(arg_limits)

    def _parse_arg_limits(self, arg_limits):
        if arg_limits is None:
            return 0, sys.maxint
        if isinstance(arg_limits, int):
            return arg_limits, arg_limits
        if len(arg_limits) == 1:
            return arg_limits[0], sys.maxint
        return arg_limits[0], arg_limits[1]

    def __call__(self, args):
        if not (self._min_args <= len(args) <= self._max_args):
            self._raise_invalid_args(self._min_args, self._max_args, len(args))

    def _raise_invalid_args(self, min_args, max_args, arg_count):
        min_end = plural_or_not(min_args)
        if min_args == max_args:
            expectation = "%d argument%s" % (min_args, min_end)
        elif max_args != sys.maxint:
            expectation = "%d to %d arguments" % (min_args, max_args)
        else:
            expectation = "at least %d argument%s" % (min_args, min_end)
        raise DataError("Expected %s, got %d." % (expectation, arg_count))


class ArgFileParser(object):

    def __init__(self, options):
        self._options = options

    def process(self, args):
        while True:
            index = self._get_index(args)
            if index < 0:
                break
            path = args[index+1]
            args[index:index+2] = self._get_args(path)
        return args

    def _get_index(self, args):
        for opt in self._options:
            if opt in args:
                return args.index(opt)
        return -1

    def _get_args(self, path):
        if path.upper() != 'STDIN':
            content = self._read_from_file(path)
        else:
            content = self._read_from_stdin()
        return self._process_file(content)

    def _read_from_file(self, path):
        try:
            with utf8open(path) as f:
                content = f.read()
        except (IOError, UnicodeError), err:
            raise DataError("Opening argument file '%s' failed: %s"
                            % (path, err))
        if content.startswith(codecs.BOM_UTF8.decode('UTF-8')):
            content = content[1:]
        return content

    def _read_from_stdin(self):
        content = sys.__stdin__.read()
        if sys.platform != 'cli':
            content = decode_output(content)
        return content

    def _process_file(self, content):
        args = []
        for line in content.splitlines():
            line = line.strip()
            if line.startswith('-'):
                args.extend(self._split_option(line))
            elif line and not line.startswith('#'):
                args.append(line)
        return args

    def _split_option(self, line):
        separator = self._get_option_separator(line)
        if not separator:
            return [line]
        option, value = line.split(separator, 1)
        if separator == ' ':
            value = value.strip()
        return [option, value]

    def _get_option_separator(self, line):
        if ' ' not in line and '=' not in line:
            return None
        if '=' not in line:
            return ' '
        if ' ' not in line:
            return '='
        return ' ' if line.index(' ') < line.index('=') else '='

########NEW FILE########
__FILENAME__ = asserts
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""Convenience functions for testing both in unit and higher levels.

Benefits:
  - Integrates 100% with unittest (see example below)
  - Can be easily used without unittest (using unittest.TestCase when you
    only need convenient asserts is not so nice)
  - Saved typing and shorter lines because no need to have 'self.' before
    asserts. These are static functions after all so that is OK.
  - All 'equals' methods (by default) report given values even if optional
    message given. This behavior can be controlled with the optional values
    argument.

Drawbacks:
  - unittest is not able to filter as much non-interesting traceback away
    as with its own methods because AssertionErrors occur outside


Most of the functions are copied more or less directly from unittest.TestCase
which comes with the following license. Further information about unittest in
general can be found from http://pyunit.sourceforge.net/. This module can be
used freely in same terms as unittest.


unittest license::

    Copyright (c) 1999-2003 Steve Purcell
    This module is free software, and you may redistribute it and/or modify
    it under the same terms as Python itself, so long as this copyright message
    and disclaimer are retained in their original form.

    IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
    SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF
    THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGE.

    THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
    AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,
    SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.


Examples:

.. code-block:: python

    import unittest
    from robot.util.asserts import *

    class MyTests(unittest.TestCase):

        def test_old_style(self):
            self.assertEquals(1, 2, 'my msg')

        def test_new_style(self):
            assert_equals(1, 2, 'my msg')


Example output::

    FF
    ======================================================================
    FAIL: test_old_style (__main__.MyTests)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
    File "example.py", line 7, in test_old_style
        self.assertEquals(1, 2, 'my msg')
    AssertionError: my msg

    ======================================================================
    FAIL: test_new_style (__main__.MyTests)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
    File "example.py", line 10, in test_new_style
        assert_equals(1, 2, 'my msg')
    File "/path/to/robot/asserts.py", line 142, in fail_unless_equal
        _report_unequality_failure(first, second, msg, values, '!=')
    File "/path/to/robot/src/robot/asserts.py", line 209, in _report_unequality_failure
        raise _report_failure(msg)
    File "/path/to/robot/src/robot/asserts.py", line 200, in _report_failure
        raise AssertionError(msg)
    AssertionError: my msg: 1 != 2

    ----------------------------------------------------------------------
    Ran 2 tests in 0.000s

    FAILED (failures=2)

"""

from .unic import unic


def fail(msg=None):
    """Fail test immediately with the given message."""
    _report_failure(msg)

def error(msg=None):
    """Error test immediately with the given message."""
    _report_error(msg)

def fail_if(expr, msg=None):
    """Fail the test if the expression is True."""
    if expr: _report_failure(msg)

def fail_unless(expr, msg=None):
    """Fail the test unless the expression is True."""
    if not expr: _report_failure(msg)

def fail_if_none(obj, msg=None, values=True):
    """Fail the test if given object is None."""
    _msg = 'is None'
    if obj is None:
        if msg is None:
            msg = _msg
        elif values is True:
            msg = '%s: %s' % (msg, _msg)
        _report_failure(msg)

def fail_unless_none(obj, msg=None, values=True):
    """Fail the test if given object is not None."""
    _msg = '%r is not None' % obj
    if obj is not None:
        if msg is None:
            msg = _msg
        elif values is True:
            msg = '%s: %s' % (msg, _msg)
        _report_failure(msg)

def fail_unless_raises(exc_class, callable_obj, *args, **kwargs):
    """Fail unless an exception of class exc_class is thrown by callable_obj.

    callable_obj is invoked with arguments args and keyword arguments
    kwargs. If a different type of exception is thrown, it will not be
    caught, and the test case will be deemed to have suffered an
    error, exactly as for an unexpected exception.

    If a correct exception is raised, the exception instance is returned
    by this method.
    """
    try:
        callable_obj(*args, **kwargs)
    except exc_class, err:
        return err
    else:
        if hasattr(exc_class,'__name__'):
            exc_name = exc_class.__name__
        else:
            exc_name = str(exc_class)
        _report_failure('%s not raised' % exc_name)

def fail_unless_raises_with_msg(exc_class, expected_msg, callable_obj, *args,
                                **kwargs):
    """Similar to fail_unless_raises but also checks the exception message."""
    try:
        callable_obj(*args, **kwargs)
    except exc_class, err:
        assert_equal(expected_msg, unic(err), 'Correct exception but wrong message')
    else:
        if hasattr(exc_class,'__name__'):
            exc_name = exc_class.__name__
        else:
            exc_name = str(exc_class)
        _report_failure('%s not raised' % exc_name)


def fail_unless_equal(first, second, msg=None, values=True):
    """Fail if given objects are unequal as determined by the '==' operator."""
    if not first == second:
        _report_unequality_failure(first, second, msg, values, '!=')

def fail_if_equal(first, second, msg=None, values=True):
    """Fail if given objects are equal as determined by the '==' operator."""
    if first == second:
        _report_unequality_failure(first, second, msg, values, '==')

def fail_unless_almost_equal(first, second, places=7, msg=None, values=True):
    """Fail if the two objects are unequal after rounded to given places.

    Unequality is determined by object's difference rounded to the
    given number of decimal places (default 7) and comparing to zero.
    Note that decimal places (from zero) are usually not the same as
    significant digits (measured from the most signficant digit).
    """
    if round(second - first, places) != 0:
        extra = 'within %r places' % places
        _report_unequality_failure(first, second, msg, values, '!=', extra)

def fail_if_almost_equal(first, second, places=7, msg=None, values=True):
    """Fail if the two objects are unequal after rounded to given places.

    Equality is determined by object's difference rounded to to the
    given number of decimal places (default 7) and comparing to zero.
    Note that decimal places (from zero) are usually not the same as
    significant digits (measured from the most signficant digit).
    """
    if round(second-first, places) == 0:
        extra = 'within %r places' % places
        _report_unequality_failure(first, second, msg, values, '==', extra)

# Synonyms for assertion methods

assert_equal = assert_equals = fail_unless_equal
assert_not_equal = assert_not_equals = fail_if_equal
assert_almost_equal = assert_almost_equals = fail_unless_almost_equal
assert_not_almost_equal = assert_not_almost_equals = fail_if_almost_equal
assert_raises = fail_unless_raises
assert_raises_with_msg = fail_unless_raises_with_msg
assert_ = assert_true = fail_unless
assert_false = fail_if
assert_none = fail_unless_none
assert_not_none = fail_if_none

# Helpers

def _report_failure(msg):
    if msg is None:
        raise AssertionError()
    raise AssertionError(msg)

def _report_error(msg):
    if msg is None:
        raise Exception()
    raise Exception(msg)

def _report_unequality_failure(obj1, obj2, msg, values, delim, extra=None):
    if not msg:
        msg = _get_default_message(obj1, obj2, delim)
    elif values:
        msg = '%s: %s' % (msg, _get_default_message(obj1, obj2, delim))
    if values and extra:
        msg += ' ' + extra
    _report_failure(msg)

def _get_default_message(obj1, obj2, delim):
    str1 = unic(obj1)
    str2 = unic(obj2)
    if delim == '!=' and str1 == str2:
        return '%s (%s) != %s (%s)' % (str1, _type_name(obj1),
                                       str2, _type_name(obj2))
    return '%s %s %s' % (str1, delim, str2)

def _type_name(val):
    known_types = {int: 'number', long: 'number', float: 'number',
                   str: 'string', unicode: 'string', bool: 'boolean'}
    return known_types.get(type(val), type(val).__name__)

########NEW FILE########
__FILENAME__ = charwidth
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""A module to handle different character widths on the console.

Some East Asian characters have width of two on console, and combining
characters themselves take no extra space.

See issue 604 [1] for more details about East Asian characters. The issue also
contains `generate_wild_chars.py` script that was originally used to create
`_EAST_ASIAN_WILD_CHARS` mapping. An updated version of the script is attached
to issue 1096. Big thanks for xieyanbo for the script and the original patch.

Note that Python's `unicodedata` module is not used here because importing
it takes several seconds on Jython.

[1] http://code.google.com/p/robotframework/issues/detail?id=604
[2] http://code.google.com/p/robotframework/issues/detail?id=1096
"""

def get_char_width(char):
    char = ord(char)
    if _char_in_map(char, _COMBINING_CHARS):
        return 0
    if _char_in_map(char, _EAST_ASIAN_WILD_CHARS):
        return 2
    return 1

def _char_in_map(char, map):
    for begin, end in map:
        if char < begin:
            break
        if begin <= char <= end:
            return True
    return False


_COMBINING_CHARS = [(768, 879)]

_EAST_ASIAN_WILD_CHARS = [
        (888, 889), (895, 899), (907, 907), (909, 909), (930, 930),
        (1316, 1328), (1367, 1368), (1376, 1376), (1416, 1416),
        (1419, 1424), (1480, 1487), (1515, 1519), (1525, 1535),
        (1540, 1541), (1564, 1565), (1568, 1568), (1631, 1631),
        (1806, 1806), (1867, 1868), (1970, 1983), (2043, 2304),
        (2362, 2363), (2382, 2383), (2389, 2391), (2419, 2426),
        (2432, 2432), (2436, 2436), (2445, 2446), (2449, 2450),
        (2473, 2473), (2481, 2481), (2483, 2485), (2490, 2491),
        (2501, 2502), (2505, 2506), (2511, 2518), (2520, 2523),
        (2526, 2526), (2532, 2533), (2555, 2560), (2564, 2564),
        (2571, 2574), (2577, 2578), (2601, 2601), (2609, 2609),
        (2612, 2612), (2615, 2615), (2618, 2619), (2621, 2621),
        (2627, 2630), (2633, 2634), (2638, 2640), (2642, 2648),
        (2653, 2653), (2655, 2661), (2678, 2688), (2692, 2692),
        (2702, 2702), (2706, 2706), (2729, 2729), (2737, 2737),
        (2740, 2740), (2746, 2747), (2758, 2758), (2762, 2762),
        (2766, 2767), (2769, 2783), (2788, 2789), (2800, 2800),
        (2802, 2816), (2820, 2820), (2829, 2830), (2833, 2834),
        (2857, 2857), (2865, 2865), (2868, 2868), (2874, 2875),
        (2885, 2886), (2889, 2890), (2894, 2901), (2904, 2907),
        (2910, 2910), (2916, 2917), (2930, 2945), (2948, 2948),
        (2955, 2957), (2961, 2961), (2966, 2968), (2971, 2971),
        (2973, 2973), (2976, 2978), (2981, 2983), (2987, 2989),
        (3002, 3005), (3011, 3013), (3017, 3017), (3022, 3023),
        (3025, 3030), (3032, 3045), (3067, 3072), (3076, 3076),
        (3085, 3085), (3089, 3089), (3113, 3113), (3124, 3124),
        (3130, 3132), (3141, 3141), (3145, 3145), (3150, 3156),
        (3159, 3159), (3162, 3167), (3172, 3173), (3184, 3191),
        (3200, 3201), (3204, 3204), (3213, 3213), (3217, 3217),
        (3241, 3241), (3252, 3252), (3258, 3259), (3269, 3269),
        (3273, 3273), (3278, 3284), (3287, 3293), (3295, 3295),
        (3300, 3301), (3312, 3312), (3315, 3329), (3332, 3332),
        (3341, 3341), (3345, 3345), (3369, 3369), (3386, 3388),
        (3397, 3397), (3401, 3401), (3406, 3414), (3416, 3423),
        (3428, 3429), (3446, 3448), (3456, 3457), (3460, 3460),
        (3479, 3481), (3506, 3506), (3516, 3516), (3518, 3519),
        (3527, 3529), (3531, 3534), (3541, 3541), (3543, 3543),
        (3552, 3569), (3573, 3584), (3643, 3646), (3676, 3712),
        (3715, 3715), (3717, 3718), (3721, 3721), (3723, 3724),
        (3726, 3731), (3736, 3736), (3744, 3744), (3748, 3748),
        (3750, 3750), (3752, 3753), (3756, 3756), (3770, 3770),
        (3774, 3775), (3781, 3781), (3783, 3783), (3790, 3791),
        (3802, 3803), (3806, 3839), (3912, 3912), (3949, 3952),
        (3980, 3983), (3992, 3992), (4029, 4029), (4045, 4045),
        (4053, 4095), (4250, 4253), (4294, 4303), (4349, 4447),
        (4515, 4519), (4602, 4607), (4681, 4681), (4686, 4687),
        (4695, 4695), (4697, 4697), (4702, 4703), (4745, 4745),
        (4750, 4751), (4785, 4785), (4790, 4791), (4799, 4799),
        (4801, 4801), (4806, 4807), (4823, 4823), (4881, 4881),
        (4886, 4887), (4955, 4958), (4989, 4991), (5018, 5023),
        (5109, 5120), (5751, 5759), (5789, 5791), (5873, 5887),
        (5901, 5901), (5909, 5919), (5943, 5951), (5972, 5983),
        (5997, 5997), (6001, 6001), (6004, 6015), (6110, 6111),
        (6122, 6127), (6138, 6143), (6159, 6159), (6170, 6175),
        (6264, 6271), (6315, 6399), (6429, 6431), (6444, 6447),
        (6460, 6463), (6465, 6467), (6510, 6511), (6517, 6527),
        (6570, 6575), (6602, 6607), (6618, 6621), (6684, 6685),
        (6688, 6911), (6988, 6991), (7037, 7039), (7083, 7085),
        (7098, 7167), (7224, 7226), (7242, 7244), (7296, 7423),
        (7655, 7677), (7958, 7959), (7966, 7967), (8006, 8007),
        (8014, 8015), (8024, 8024), (8026, 8026), (8028, 8028),
        (8030, 8030), (8062, 8063), (8117, 8117), (8133, 8133),
        (8148, 8149), (8156, 8156), (8176, 8177), (8181, 8181),
        (8191, 8191), (8293, 8297), (8306, 8307), (8335, 8335),
        (8341, 8351), (8374, 8399), (8433, 8447), (8528, 8530),
        (8585, 8591), (9001, 9002), (9192, 9215), (9255, 9279),
        (9291, 9311), (9886, 9887), (9917, 9919), (9924, 9984),
        (9989, 9989), (9994, 9995), (10024, 10024), (10060, 10060),
        (10062, 10062), (10067, 10069), (10071, 10071), (10079, 10080),
        (10133, 10135), (10160, 10160), (10175, 10175), (10187, 10187),
        (10189, 10191), (11085, 11087), (11093, 11263), (11311, 11311),
        (11359, 11359), (11376, 11376), (11390, 11391), (11499, 11512),
        (11558, 11567), (11622, 11630), (11632, 11647), (11671, 11679),
        (11687, 11687), (11695, 11695), (11703, 11703), (11711, 11711),
        (11719, 11719), (11727, 11727), (11735, 11735), (11743, 11743),
        (11825, 12350), (12352, 19903), (19968, 42239), (42540, 42559),
        (42592, 42593), (42612, 42619), (42648, 42751), (42893, 43002),
        (43052, 43071), (43128, 43135), (43205, 43213), (43226, 43263),
        (43348, 43358), (43360, 43519), (43575, 43583), (43598, 43599),
        (43610, 43611), (43616, 55295), (63744, 64255), (64263, 64274),
        (64280, 64284), (64311, 64311), (64317, 64317), (64319, 64319),
        (64322, 64322), (64325, 64325), (64434, 64466), (64832, 64847),
        (64912, 64913), (64968, 65007), (65022, 65023), (65040, 65055),
        (65063, 65135), (65141, 65141), (65277, 65278), (65280, 65376),
        (65471, 65473), (65480, 65481), (65488, 65489), (65496, 65497),
        (65501, 65511), (65519, 65528), (65534, 65535),
        ]

########NEW FILE########
__FILENAME__ = compress
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import base64
import sys


def compress_text(text):
    return base64.b64encode(_compress(text.encode('UTF-8')))


if not sys.platform.startswith('java'):

    import zlib

    def _compress(text):
        return zlib.compress(text, 9)

else:
    # Custom compress implementation needed to avoid memory leak:
    # http://bugs.jython.org/issue1775
    # This is based on the zlib.compress in Jython 2.5.2 but has a memory
    # leak fix and is also a little faster.

    from java.util.zip import Deflater
    import jarray

    _DEFLATOR = Deflater(9, False)

    def _compress(text):
        _DEFLATOR.setInput(text)
        _DEFLATOR.finish()
        buf = jarray.zeros(1024, 'b')
        compressed = []
        while not _DEFLATOR.finished():
            length = _DEFLATOR.deflate(buf, 0, 1024)
            compressed.append(buf[:length].tostring())
        _DEFLATOR.reset()
        return ''.join(compressed)

########NEW FILE########
__FILENAME__ = connectioncache
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from normalizing import NormalizedDict


class ConnectionCache:

    """Connection cache for different Robot test libraries that use connections.

    This cache stores connections and allows switching between them using
    generated indexes or user given aliases. Can be used for example by web
    testing libraries where there's need for multiple concurrent connections.

    Note that in most cases there should be only one instance of this class but
    this is not enforced.
    """

    def __init__(self, no_current_msg='No open connection'):
        self.current = self._no_current = _NoConnection(no_current_msg)
        self.current_index = None
        self._connections = []
        self._aliases = NormalizedDict()
        self._no_current_msg = no_current_msg

    def register(self, connection, alias=None):
        """Registers given connection with optional alias and returns its index.

        Given connection is set to be the current connection. Alias must be
        a string. The index of the first connection after initialization or
        close_all or empty_cache is 1, second is 2, etc.
        """
        self.current = connection
        self._connections.append(connection)
        self.current_index = len(self._connections)
        if isinstance(alias, basestring):
            self._aliases[alias] = self.current_index
        return self.current_index

    def switch(self, index_or_alias):
        """Switches to the connection specified by given index or alias.

        If alias is given it must be a string. Indexes can be either integers
        or strings that can be converted into integer. Raises RuntimeError
        if no connection with given index or alias found.
        """
        try:
            index = self._get_index(index_or_alias)
        except ValueError:
            raise RuntimeError("Non-existing index or alias '%s'" % index_or_alias)
        self.current = self._connections[index-1]
        self.current_index = index
        return self.current

    def close_all(self, closer_method='close'):
        """Closes connections using given closer method and empties cache.

        If simply calling the closer method is not adequate for closing
        connections, clients should close connections themselves and use
        empty_cache afterwards.
        """
        for conn in self._connections:
            getattr(conn, closer_method)()
        self.empty_cache()
        return self.current

    def empty_cache(self):
        """Empties the connections cache.

        Indexes of new connections starts from 1 after this."""
        self.current = self._no_current
        self.current_index = None
        self._connections = []
        self._aliases = NormalizedDict()

    def _get_index(self, index_or_alias):
        try:
            return self._resolve_alias(index_or_alias)
        except ValueError:
            return self._resolve_index(index_or_alias)

    def _resolve_alias(self, alias):
        if isinstance(alias, basestring):
            try:
                return self._aliases[alias]
            except KeyError:
                pass
        raise ValueError

    def _resolve_index(self, index):
        index = int(index)
        if not 0 < index <= len(self._connections):
            raise ValueError
        return index


class _NoConnection:

    def __init__(self, msg):
        self._msg = msg

    def __getattr__(self, name):
        if name.startswith('__') and name.endswith('__'):
            raise AttributeError
        raise RuntimeError(self._msg)

    def __nonzero__(self):
        return False

########NEW FILE########
__FILENAME__ = encoding
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import codecs
from contextlib import contextmanager

from .encodingsniffer import get_output_encoding, get_system_encoding
from .unic import unic


OUTPUT_ENCODING = get_output_encoding()
SYSTEM_ENCODING = get_system_encoding()


def decode_output(string):
    """Decodes bytes from console encoding to Unicode."""
    return unic(string, OUTPUT_ENCODING)

def encode_output(string, errors='replace'):
    """Encodes Unicode to bytes in console encoding."""
    # http://ironpython.codeplex.com/workitem/29487
    if sys.platform == 'cli':
        return string
    return string.encode(OUTPUT_ENCODING, errors)

def decode_from_system(string, can_be_from_java=True):
    """Decodes bytes from system (e.g. cli args or env vars) to Unicode."""
    if sys.platform == 'cli':
        return string
    if sys.platform.startswith('java') and can_be_from_java:
        # http://bugs.jython.org/issue1592
        from java.lang import String
        string = String(string)
    return unic(string, SYSTEM_ENCODING)

def encode_to_system(string, errors='replace'):
    """Encodes Unicode to system encoding (e.g. cli args and env vars)."""
    return string.encode(SYSTEM_ENCODING, errors)

# workaround for Python 2.5.0 bug: http://bugs.python.org/issue1586513
@contextmanager
def utf8open(filename, mode='r'):
    file = codecs.open(filename, mode=mode, encoding='utf8')
    try:
        yield file
    finally:
        file.close()

########NEW FILE########
__FILENAME__ = encodingsniffer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import os


UNIXY = os.sep == '/'
JYTHON = sys.platform.startswith('java')
if UNIXY:
    DEFAULT_SYSTEM_ENCODING = 'UTF-8'
    DEFAULT_OUTPUT_ENCODING = 'UTF-8'
else:
    DEFAULT_SYSTEM_ENCODING = 'cp1252'
    DEFAULT_OUTPUT_ENCODING = 'cp437'


def get_system_encoding():
    encoding = _get_python_file_system_encoding()
    if not encoding and JYTHON:
        encoding = _get_java_file_system_encoding()
    return encoding or DEFAULT_SYSTEM_ENCODING

def _get_python_file_system_encoding():
    encoding = sys.getfilesystemencoding()
    return encoding if _is_valid(encoding) else None

def _get_java_file_system_encoding():
    from java.lang import System
    encoding = System.getProperty('file.encoding')
    return encoding if _is_valid(encoding) else None

def _is_valid(encoding):
    if not encoding:
        return False
    try:
        'test'.encode(encoding)
    except LookupError:
        return False
    else:
        return True


def get_output_encoding():
    if _on_buggy_jython():
        return DEFAULT_OUTPUT_ENCODING
    encoding = _get_encoding_from_standard_streams()
    if not encoding and UNIXY:
        encoding = _get_encoding_from_unix_environment_variables()
    return encoding or DEFAULT_OUTPUT_ENCODING

def _on_buggy_jython():
    # http://bugs.jython.org/issue1568
    if UNIXY or not JYTHON:
        return False
    return sys.platform.startswith('java1.5') or sys.version_info < (2, 5, 2)

def _get_encoding_from_standard_streams():
    # Stream may not have encoding attribute if it is intercepted outside RF
    # in Python. Encoding is None if process's outputs are redirected.
    for stream in sys.__stdout__, sys.__stderr__, sys.__stdin__:
        encoding = getattr(stream, 'encoding', None)
        if _is_valid(encoding):
            return encoding
    return None

def _get_encoding_from_unix_environment_variables():
    for name in 'LANG', 'LC_CTYPE', 'LANGUAGE', 'LC_ALL':
        if name in os.environ:
            # Encoding can be in format like `UTF-8` or `en_US.UTF-8`
            encoding = os.environ[name].split('.')[-1]
            if _is_valid(encoding):
                return encoding
    return None

########NEW FILE########
__FILENAME__ = error
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
import sys
import traceback

from robot.errors import RobotError

from .unic import unic

RERAISED_EXCEPTIONS = (KeyboardInterrupt, SystemExit, MemoryError)
if sys.platform.startswith('java'):
    from java.io import StringWriter, PrintWriter
    from java.lang import Throwable, OutOfMemoryError
    RERAISED_EXCEPTIONS += (OutOfMemoryError,)
else:
    Throwable = ()


def get_error_message():
    """Returns error message of the last occurred exception.

    This method handles also exceptions containing unicode messages. Thus it
    MUST be used to get messages from all exceptions originating outside the
    framework.
    """
    return ErrorDetails().message


def get_error_details():
    """Returns error message and details of the last occurred exception.
    """
    details = ErrorDetails()
    return details.message, details.traceback


def ErrorDetails():
    """This factory returns an object that wraps the last occurred exception

    It has attributes `message`, `traceback` and `error`, where `message`
    contains type and message of the original error, `traceback` contains the
    traceback/stack trace and `error` contains the original error instance.
    """
    exc_type, exc_value, exc_traceback = sys.exc_info()
    if exc_type in RERAISED_EXCEPTIONS:
        raise exc_value
    details = PythonErrorDetails \
            if not isinstance(exc_value, Throwable) else JavaErrorDetails
    return details(exc_type, exc_value, exc_traceback)


class _ErrorDetails(object):
    _generic_exceptions = ('AssertionError', 'AssertionFailedError', 'Exception',
                           'Error', 'RuntimeError', 'RuntimeException',
                           'DataError', 'TimeoutError', 'RemoteError')

    def __init__(self, exc_type, exc_value, exc_traceback):
        self.error = exc_value
        self._exc_value = exc_value
        self._exc_type = exc_type
        self._exc_traceback = exc_traceback
        self._message = None
        self._traceback = None

    @property
    def message(self):
        if self._message is None:
            self._message = self._get_message()
        return self._message

    @property
    def traceback(self):
        if self._traceback is None:
            self._traceback = self._get_details()
        return self._traceback

    def _get_name(self, exc_type):
        try:
            return exc_type.__name__
        except AttributeError:
            return unic(exc_type)

    def _format_message(self, name, message):
        message = unic(message or '')
        message = self._clean_up_message(message, name)
        name = name.split('.')[-1]  # Use only last part of the name
        if not message:
            return name
        if name in self._generic_exceptions:
            return message
        return '%s: %s' % (name, message)

    def _clean_up_message(self, message, name):
        return message


class PythonErrorDetails(_ErrorDetails):

    def _get_message(self):
        # If exception is a "string exception" without a message exc_value is None
        if self._exc_value is None:
            return unic(self._exc_type)
        name = self._get_name(self._exc_type)
        try:
            msg = unicode(self._exc_value)
        except UnicodeError:  # Happens if message is Unicode and version < 2.6
            msg = ' '.join(unic(a) for a in self._exc_value.args)
        return self._format_message(name, msg)

    def _get_details(self):
        if isinstance(self._exc_value, RobotError):
            return self._exc_value.details
        return 'Traceback (most recent call last):\n' + self._get_traceback()

    def _get_traceback(self):
        tb = self._exc_traceback
        while tb and self._is_excluded_traceback(tb):
            tb = tb.tb_next
        return ''.join(traceback.format_tb(tb)).rstrip() or '  None'

    def _is_excluded_traceback(self, traceback):
        module = traceback.tb_frame.f_globals.get('__name__')
        return module and module.startswith('robot.')


class JavaErrorDetails(_ErrorDetails):
    _java_trace_re = re.compile('^\s+at (\w.+)')
    _ignored_java_trace = ('org.python.', 'robot.running.', 'robot$py.',
                           'sun.reflect.', 'java.lang.reflect.')

    def _get_message(self):
        exc_name = self._get_name(self._exc_type)
        # OOME.getMessage and even toString seem to throw NullPointerException
        if not self._is_out_of_memory_error(self._exc_type):
            exc_msg = self._exc_value.getMessage()
        else:
            exc_msg = str(self._exc_value)
        return self._format_message(exc_name, exc_msg)

    def _is_out_of_memory_error(self, exc_type):
        return exc_type is OutOfMemoryError

    def _get_details(self):
        # OOME.printStackTrace seems to throw NullPointerException
        if self._is_out_of_memory_error(self._exc_type):
            return ''
        output = StringWriter()
        self._exc_value.printStackTrace(PrintWriter(output))
        details = '\n'.join(line for line in output.toString().splitlines()
                            if not self._is_ignored_stack_trace_line(line))
        msg = unic(self._exc_value.getMessage() or '')
        if msg:
            details = details.replace(msg, '', 1)
        return details

    def _is_ignored_stack_trace_line(self, line):
        if not line:
            return True
        res = self._java_trace_re.match(line)
        if res is None:
            return False
        location = res.group(1)
        for entry in self._ignored_java_trace:
            if location.startswith(entry):
                return True
        return False

    def _clean_up_message(self, msg, name):
        msg = self._remove_stack_trace_lines(msg)
        return self._remove_exception_name(msg, name).strip()

    def _remove_stack_trace_lines(self, msg):
        lines = msg.splitlines()
        while lines:
            if self._java_trace_re.match(lines[-1]):
                lines.pop()
            else:
                break
        return '\n'.join(lines)

    def _remove_exception_name(self, msg, name):
        tokens = msg.split(':', 1)
        if len(tokens) == 2 and tokens[0] == name:
            msg = tokens[1]
        return msg

########NEW FILE########
__FILENAME__ = escaping
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re


_ESCAPE_RE = re.compile(r'(\\+)([^\\]{0,2})')   # escapes and nextchars
_SEQS_TO_BE_ESCAPED = ('\\', '${', '@{', '%{', '&{', '*{' , '=')


def escape(item):
    if not isinstance(item, basestring):
        return item
    for seq in _SEQS_TO_BE_ESCAPED:
        if seq in item:
            item = item.replace(seq, '\\' + seq)
    return item


def unescape(item):
    if not isinstance(item, basestring):
        return item
    result = []
    unprocessed = item
    while True:
        res = _ESCAPE_RE.search(unprocessed)
        # If no escapes found append string to result and exit loop
        if res is None:
            result.append(unprocessed)
            break
        # Split string to pre match, escapes, nextchars and unprocessed parts
        # (e.g. '<pre><esc><nc><unproc>') where nextchars contains 0-2 chars
        # and unprocessed may contain more escapes. Pre match part contains
        # no escapes can is appended directly to result.
        result.append(unprocessed[:res.start()])
        escapes = res.group(1)
        nextchars = res.group(2)
        unprocessed = unprocessed[res.end():]
        # Append every second escape char to result
        result.append('\\' * (len(escapes) / 2))
        # Handle '\n', '\r' and '\t'. Note that both '\n' and '\n ' are
        # converted to '\n'
        if len(escapes) % 2 == 0 or len(nextchars) == 0 \
                    or nextchars[0] not in ['n','r','t']:
            result.append(nextchars)
        elif nextchars[0] == 'n':
            if len(nextchars) == 1 or nextchars[1] == ' ':
                result.append('\n')
            else:
                result.append('\n' + nextchars[1])
        elif nextchars[0] == 'r':
            result.append('\r' + nextchars[1:])
        else:
            result.append('\t' + nextchars[1:])
    return ''.join(result)

########NEW FILE########
__FILENAME__ = etreewrapper
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import os.path
from StringIO import StringIO


_IRONPYTHON = sys.platform == 'cli'
_ERROR = 'No valid ElementTree XML parser module found'


if not _IRONPYTHON:
    try:
        from xml.etree import cElementTree as ET
    except ImportError:
        try:
            import cElementTree as ET
        except ImportError:
            try:
                from xml.etree import ElementTree as ET
            except ImportError:
                try:
                    from elementtree import ElementTree as ET
                except ImportError:
                    raise ImportError(_ERROR)
else:
    # Cannot use standard ET available on IronPython because it is broken
    # both in 2.7.0 and 2.7.1:
    # http://ironpython.codeplex.com/workitem/31923
    # http://ironpython.codeplex.com/workitem/21407
    try:
        from elementtree import ElementTree as ET
    except ImportError:
        raise ImportError(_ERROR)


# cElementTree.VERSION seems to always be 1.0.6. We want real API version.
if ET.VERSION < '1.3' and hasattr(ET, 'tostringlist'):
    ET.VERSION = '1.3'


class ETSource(object):

    def __init__(self, source):
        self._source = source
        self._opened = None

    def __enter__(self):
        self._opened = self._open_source_if_necessary()
        return self._opened or self._source

    def __exit__(self, exc_type, exc_value, exc_trace):
        if self._opened:
            self._opened.close()

    def __str__(self):
        if self._source_is_file_name():
            return self._source
        if hasattr(self._source, 'name'):
            return self._source.name
        return '<in-memory file>'

    def _source_is_file_name(self):
        return isinstance(self._source, basestring) \
                and not self._source.lstrip().startswith('<')

    def _open_source_if_necessary(self):
        if self._source_is_file_name():
            return self._open_file(self._source)
        if isinstance(self._source, basestring):
            return self._open_string_io(self._source)
        return None

    if not _IRONPYTHON:

        # File is opened, and later closed, because ElementTree had a bug that
        # it didn't close files it had opened. This caused problems with Jython
        # especially on Windows: http://bugs.jython.org/issue1598
        # The bug has now been fixed in ET and worked around in Jython 2.5.2.
        def _open_file(self, source):
            return open(source, 'rb')

        def _open_string_io(self, source):
            return StringIO(source.encode('UTF-8'))

    else:

        # File cannot be opened on IronPython, however, as ET does not seem to
        # handle non-ASCII characters correctly in that case. We want to check
        # that the file exists even in that case, though.
        def _open_file(self, source):
            if not os.path.exists(source):
                raise IOError(2, 'No such file', source)
            return None

        def _open_string_io(self, source):
            return StringIO(source)

########NEW FILE########
__FILENAME__ = htmlformatters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
from functools import partial
from itertools import cycle


class LinkFormatter(object):
    _image_exts = ('.jpg', '.jpeg', '.png', '.gif', '.bmp')
    _link = re.compile('\[(.+?\|.*?)\]')
    _url = re.compile('''
((^|\ ) ["'([]*)           # begin of line or space and opt. any char "'([
(\w{3,9}://[\S]+?)         # url (protocol is any alphanum 3-9 long string)
(?=[])"'.,!?:;]* ($|\ ))   # opt. any char ])"'.,!?:; and end of line or space
''', re.VERBOSE|re.MULTILINE)

    def format_url(self, text):
        return self._format_url(text, format_as_image=False)

    def _format_url(self, text, format_as_image=True):
        if '://' not in text:
            return text
        return self._url.sub(partial(self._replace_url, format_as_image), text)

    def _replace_url(self, format_as_image, match):
        pre = match.group(1)
        url = match.group(3)
        if format_as_image and self._is_image(url):
            return pre + self._get_image(url)
        return pre + self._get_link(url)

    def _get_image(self, src, title=None):
        return '<img src="%s" title="%s">' \
                % (self._quot(src), self._quot(title or src))

    def _get_link(self, href, content=None):
        return '<a href="%s">%s</a>' % (self._quot(href), content or href)

    def _quot(self, attr):
        return attr if '"' not in attr else attr.replace('"', '&quot;')

    def format_link(self, text):
        # 2nd, 4th, etc. token contains link, others surrounding content
        tokens = self._link.split(text)
        formatters = cycle((self._format_url, self._format_link))
        return ''.join(f(t) for f, t in zip(formatters, tokens))

    def _format_link(self, text):
        link, content = [t.strip() for t in text.split('|', 1)]
        if self._is_image(content):
            content = self._get_image(content, link)
        elif self._is_image(link):
            return self._get_image(link, content)
        return self._get_link(link, content)

    def _is_image(self, text):
        return text.lower().endswith(self._image_exts)


class LineFormatter(object):
    handles = lambda self, line: True
    newline = '\n'
    _bold = re.compile('''
(                         # prefix (group 1)
  (^|\ )                  # begin of line or space
  ["'(]* _?               # optionally any char "'( and optional begin of italic
)                         #
\*                        # start of bold
([^\ ].*?)                # no space and then anything (group 3)
\*                        # end of bold
(?=                       # start of postfix (non-capturing group)
  _? ["').,!?:;]*         # optional end of italic and any char "').,!?:;
  ($|\ )                  # end of line or space
)
''', re.VERBOSE)
    _italic = re.compile('''
( (^|\ ) ["'(]* )          # begin of line or space and opt. any char "'(
_                          # start of italic
([^\ _].*?)                # no space or underline and then anything
_                          # end of italic
(?= ["').,!?:;]* ($|\ ) )  # opt. any char "').,!?:; and end of line or space
''', re.VERBOSE)

    def __init__(self):
        self._format_link = LinkFormatter().format_link

    def format(self, line):
        return self._format_link(self._format_italic(self._format_bold(line)))

    def _format_bold(self, line):
        return self._bold.sub('\\1<b>\\3</b>', line) if '*' in line else line

    def _format_italic(self, line):
        return self._italic.sub('\\1<i>\\3</i>', line) if '_' in line else line


class HtmlFormatter(object):

    def __init__(self):
        self._results = []
        self._formatters = [TableFormatter(),
                            PreformattedFormatter(),
                            ListFormatter(),
                            HeaderFormatter(),
                            RulerFormatter()]
        self._formatters.append(ParagraphFormatter(self._formatters[:]))
        self._current = None

    def format(self, text):
        for line in text.splitlines():
            self._process_line(line)
        self._end_current()
        return '\n'.join(self._results)

    def _process_line(self, line):
        if not line.strip():
            self._end_current()
        elif self._current and self._current.handles(line):
            self._current.add(line)
        else:
            self._end_current()
            self._current = self._find_formatter(line)
            self._current.add(line)

    def _end_current(self):
        if self._current:
            self._results.append(self._current.end())
            self._current = None

    def _find_formatter(self, line):
        for formatter in self._formatters:
            if formatter.handles(line):
                return formatter


class _Formatter(object):
    _strip_lines = True

    def __init__(self):
        self._lines = []

    def handles(self, line):
        return self._handles(line.strip() if self._strip_lines else line)

    def _handles(self, line):
        raise NotImplementedError

    def add(self, line):
        self._lines.append(line.strip() if self._strip_lines else line)

    def end(self):
        result = self.format(self._lines)
        self._lines = []
        return result

    def format(self, lines):
        raise NotImplementedError


class _SingleLineFormatter(_Formatter):

    def _handles(self, line):
        return not self._lines and self._match(line)

    def _match(self, line):
        raise NotImplementedError

    def format(self, lines):
        return self.format_line(lines[0])

    def format_line(self, line):
        raise NotImplementedError


class RulerFormatter(_SingleLineFormatter):
    _match = re.compile('^-{3,}$').match

    def format_line(self, line):
        return '<hr>'


class HeaderFormatter(_SingleLineFormatter):
    _match = re.compile(r'^(={1,3})\s+(\S.*?)\s+\1$').match

    def format_line(self, line):
        level, text = self._match(line).groups()
        level = len(level) + 1
        return '<h%d>%s</h%d>' % (level, text, level)


class ParagraphFormatter(_Formatter):
    _format_line = LineFormatter().format

    def __init__(self, other_formatters):
        _Formatter.__init__(self)
        self._other_formatters = other_formatters

    def _handles(self, line):
        return not any(other.handles(line)
                       for other in self._other_formatters)

    def format(self, lines):
        return '<p>%s</p>' % self._format_line(' '.join(lines))


class TableFormatter(_Formatter):
    _table_line = re.compile('^\| (.* |)\|$')
    _line_splitter = re.compile(' \|(?= )')
    _format_cell = LineFormatter().format

    def _handles(self, line):
        return self._table_line.match(line) is not None

    def format(self, lines):
        return self._format_table([self._split_to_cells(l) for l in lines])

    def _split_to_cells(self, line):
        return [cell.strip() for cell in self._line_splitter.split(line[1:-1])]

    def _format_table(self, rows):
        maxlen = max(len(row) for row in rows)
        table = ['<table border="1">']
        for row in rows:
            row += [''] * (maxlen - len(row))  # fix ragged tables
            table.append('<tr>')
            table.extend('<td>%s</td>' % self._format_cell(c) for c in row)
            table.append('</tr>')
        table.append('</table>')
        return '\n'.join(table)


class PreformattedFormatter(_Formatter):
    _format_line = LineFormatter().format

    def _handles(self, line):
        return line.startswith('| ') or line == '|'

    def format(self, lines):
        lines = [self._format_line(line[2:]) for line in lines]
        return '\n'.join(['<pre>'] + lines + ['</pre>'])


class ListFormatter(_Formatter):
    _strip_lines = False
    _format_item = LineFormatter().format

    def _handles(self, line):
        return line.strip().startswith('- ') or \
                line.startswith(' ') and self._lines

    def format(self, lines):
        items = ['<li>%s</li>' % self._format_item(line)
                 for line in self._combine_lines(lines)]
        return '\n'.join(['<ul>'] + items + ['</ul>'])

    def _combine_lines(self, lines):
        current = []
        for line in lines:
            line = line.strip()
            if not line.startswith('- '):
                current.append(line)
                continue
            if current:
                yield ' '.join(current)
            current = [line[2:].strip()]
        yield ' '.join(current)

########NEW FILE########
__FILENAME__ = importer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os
import sys
import inspect
if sys.platform.startswith('java'):
    from java.lang.System import getProperty

from robot.errors import DataError

from .encoding import decode_from_system
from .error import get_error_details
from .robotpath import abspath, normpath


class Importer(object):

    def __init__(self, type=None, logger=None):
        if not logger:
            from robot.output import LOGGER as logger
        self._type = type or ''
        self._logger = logger
        self._importers = (ByPathImporter(logger),
                           NonDottedImporter(logger),
                           DottedImporter(logger))
        self._by_path_importer = self._importers[0]

    def import_class_or_module(self, name, instantiate_with_args=None):
        """Imports Python class/module or Java class with given name.

        Class can either live in a module/package or be standalone Java class.
        In the former case the name is something like 'MyClass' and in the
        latter it could be 'your.package.YourLibrary'. Python classes always
        live in a module, but if the module name is exactly same as the class
        name then simple 'MyLibrary' will import a class.

        Python modules can be imported both using format 'MyModule' and
        'mymodule.submodule'.

        `name` can also be a path to the imported file/directory. In that case
        importing is done using `import_class_or_module_by_path` method.

        If `instantiate_with_args` is not None, imported classes are
        instantiated with the specified arguments automatically.
        """
        try:
            imported, source = self._import_class_or_module(name)
            self._log_import_succeeded(imported, name, source)
            return self._instantiate_if_needed(imported, instantiate_with_args)
        except DataError, err:
            self._raise_import_failed(name, err)

    def _import_class_or_module(self, name):
        for importer in self._importers:
            if importer.handles(name):
                return importer.import_(name)

    def import_class_or_module_by_path(self, path, instantiate_with_args=None):
        """Import a Python module or Java class using a file system path.

        When importing a Python file, the path must end with '.py' and the
        actual file must also exist. When importing a Python module implemented
        as a directory, the path must end with '/' or, on Windows, with '\\'.

        When importing Java classes, the path must end with '.java' or '.class'.
        The class file must exist in both cases and in the former case also
        the source file must exist.

        If `instantiate_with_args` is not None, imported classes are
        instantiated with the specified arguments automatically.
        """
        try:
            imported, source = self._by_path_importer.import_(path)
            self._log_import_succeeded(imported, imported.__name__, source)
            return self._instantiate_if_needed(imported, instantiate_with_args)
        except DataError, err:
            self._raise_import_failed(path, err)

    def _raise_import_failed(self, name, error):
        import_type = '%s ' % self._type if self._type else ''
        msg = "Importing %s'%s' failed: %s" % (import_type, name, error.message)
        if not error.details:
            raise DataError(msg)
        msg = [msg, error.details]
        msg.extend(self._get_items_in('PYTHONPATH', sys.path))
        if sys.platform.startswith('java'):
            classpath = getProperty('java.class.path').split(os.path.pathsep)
            msg.extend(self._get_items_in('CLASSPATH', classpath))
        raise DataError('\n'.join(msg))

    def _get_items_in(self, type, items):
        yield '%s:' % type
        for item in items:
            if item:
                yield '  %s' % (item if isinstance(item, unicode)
                                else decode_from_system(item))

    def _instantiate_if_needed(self, imported, args):
        if args is None:
            return imported
        if inspect.isclass(imported):
            return self._instantiate_class(imported, args)
        if args:
            raise DataError("Modules do not take arguments.")
        return imported

    def _instantiate_class(self, imported, args):
        try:
            return imported(*args)
        except:
            raise DataError('Creating instance failed: %s\n%s' % get_error_details())

    def _log_import_succeeded(self, item, name, source):
        import_type = '%s ' % self._type if self._type else ''
        item_type = 'module' if inspect.ismodule(item) else 'class'
        location = ("'%s'" % source) if source else 'unknown location'
        self._logger.info("Imported %s%s '%s' from %s."
                          % (import_type, item_type, name, location))


class _Importer(object):

    def __init__(self, logger):
        self._logger = logger

    def _import(self, name, fromlist=None, retry=True):
        try:
            try:
                return __import__(name, fromlist=fromlist)
            except ImportError:
                # Hack to support standalone Jython. For more information, see:
                # http://code.google.com/p/robotframework/issues/detail?id=515
                # http://bugs.jython.org/issue1778514
                if sys.platform.startswith('java') and fromlist and retry:
                    __import__('%s.%s' % (name, fromlist[0]))
                    return self._import(name, fromlist, retry=False)
                # Cannot use plain raise due to
                # http://ironpython.codeplex.com/workitem/32332
                raise sys.exc_type, sys.exc_value, sys.exc_traceback
        except:
            raise DataError(*get_error_details())

    def _verify_type(self, imported):
        if inspect.isclass(imported) or inspect.ismodule(imported):
            return imported
        raise DataError('Expected class or module, got <%s>.' % type(imported).__name__)

    def _get_class_from_module(self, module):
        klass = getattr(module, module.__name__, None)
        return klass if inspect.isclass(klass) else None

    def _get_source(self, module):
        source = getattr(module, '__file__', None)
        return abspath(source) if source else None


class ByPathImporter(_Importer):
    _valid_import_extensions = ('.py', '.java', '.class', '')

    def handles(self, path):
        return os.path.isabs(path)

    def import_(self, path):
        self._verify_import_path(path)
        self._remove_wrong_module_from_sys_modules(path)
        module = self._import_by_path(path)
        imported = self._get_class_from_module(module) or module
        return self._verify_type(imported), path

    def _verify_import_path(self, path):
        if not os.path.exists(path):
            raise DataError('File or directory does not exist.')
        if not os.path.isabs(path):
            raise DataError('Import path must be absolute.')
        if not os.path.splitext(path)[1] in self._valid_import_extensions:
            raise DataError('Not a valid file or directory to import.')

    def _remove_wrong_module_from_sys_modules(self, path):
        importing_from, name = self._split_path_to_module(path)
        importing_package = os.path.splitext(path)[1] == ''
        if self._wrong_module_imported(name, importing_from, importing_package):
            del sys.modules[name]
            self._logger.info("Removed module '%s' from sys.modules to import "
                              "fresh module." % name)

    def _split_path_to_module(self, path):
        module_dir, module_file = os.path.split(abspath(path))
        module_name = os.path.splitext(module_file)[0]
        if module_name.endswith('$py'):
            module_name = module_name[:-3]
        return module_dir, module_name

    def _wrong_module_imported(self, name, importing_from, importing_package):
        module = sys.modules.get(name)
        if not module:
            return False
        source = getattr(module, '__file__', None)
        if not source:  # play safe (occurs at least with java based modules)
            return True
        imported_from, imported_package = self._get_import_information(source)
        return ((normpath(importing_from), importing_package) !=
                (normpath(imported_from), imported_package))

    def _get_import_information(self, source):
        imported_from, imported_file = self._split_path_to_module(source)
        imported_package = imported_file == '__init__'
        if imported_package:
            imported_from = os.path.dirname(imported_from)
        return imported_from, imported_package

    def _import_by_path(self, path):
        module_dir, module_name = self._split_path_to_module(path)
        sys.path.insert(0, module_dir)
        try:
            return self._import(module_name)
        finally:
            sys.path.pop(0)


class NonDottedImporter(_Importer):

    def handles(self, name):
        return '.' not in name

    def import_(self, name):
        module = self._import(name)
        imported = self._get_class_from_module(module) or module
        return self._verify_type(imported), self._get_source(module)


class DottedImporter(_Importer):

    def handles(self, name):
        return '.' in name

    def import_(self, name):
        parent_name, lib_name = name.rsplit('.', 1)
        parent = self._import(parent_name, fromlist=[str(lib_name)])
        try:
            imported = getattr(parent, lib_name)
        except AttributeError:
            raise DataError("Module '%s' does not contain '%s'."
                            % (parent_name, lib_name))
        return self._verify_type(imported), self._get_source(parent)

########NEW FILE########
__FILENAME__ = markuputils
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from .htmlformatters import LinkFormatter, HtmlFormatter


_format_url = LinkFormatter().format_url
_generic_escapes = (('&', '&amp;'), ('<', '&lt;'), ('>', '&gt;'))
_attribute_escapes = _generic_escapes \
         + (('"', '&quot;'), ('\n', '&#10;'), ('\r', '&#13;'), ('\t', '&#09;'))
_illegal_chars_in_xml = re.compile(u'[\x00-\x08\x0B\x0C\x0E-\x1F\uFFFE\uFFFF]')


def html_escape(text):
    return _format_url(_escape(text))


def xml_escape(text):
    return _illegal_chars_in_xml.sub('', _escape(text))


def html_format(text):
    return HtmlFormatter().format(_escape(text))


def attribute_escape(attr):
    return _escape(attr, _attribute_escapes)


def _escape(text, escapes=_generic_escapes):
    for name, value in escapes:
        if name in text:  # performance optimization
            text = text.replace(name, value)
    return _illegal_chars_in_xml.sub('', text)

########NEW FILE########
__FILENAME__ = markupwriters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from .markuputils import html_escape, xml_escape, attribute_escape


class _MarkupWriter(object):

    def __init__(self, output, line_separator=os.linesep, encoding=None):
        """
        :param output: Either an opened, file like object, or a path to the
            desired output file. In the latter case, the file is created
            and clients should use :py:meth:`close` method to close it.
        :param line_separator: Defines the used line separator.
        :param encoding: Encoding to be used to encode all text written to the
            output file. If `None`, text will not be encoded.
        """
        if isinstance(output, basestring):
            output = open(output, 'w')
        self.output = output
        self._line_separator = line_separator
        self._encode = self._create_encoder(encoding)
        self._preamble()

    def _create_encoder(self, encoding):
        if encoding is None:
            return lambda text: text
        return lambda text: text.encode(encoding)

    def start(self, name, attrs=None, newline=True):
        self._write('<%s %s>' % (name, self._format_attrs(attrs))
                    if attrs else '<%s>' % name, newline)

    def _format_attrs(self, attrs):
        return ' '.join('%s="%s"' % (name, attribute_escape(attrs[name]))
                        for name in self._order_attrs(attrs))

    def content(self, content=None, escape=True):
        if content:
            self._write(self._escape(content) if escape else content)

    def end(self, name, newline=True):
        self._write('</%s>' % name, newline)

    def element(self, name, content=None, attrs=None, escape=True,
                newline=True):
        self.start(name, attrs, newline=False)
        self.content(content, escape)
        self.end(name, newline)

    def close(self):
        """Closes the underlying output file."""
        self.output.close()

    def _write(self, text, newline=False):
        self.output.write(self._encode(text))
        if newline:
            self.output.write(self._line_separator)


class HtmlWriter(_MarkupWriter):

    def _preamble(self):
        pass

    def _escape(self, content):
        return html_escape(content)

    def _order_attrs(self, attrs):
        return sorted(attrs)  # eases testing


class XmlWriter(_MarkupWriter):

    def __init__(self, output, line_separator='\n', encoding=None):
        _MarkupWriter.__init__(self, output, line_separator, encoding)

    def _preamble(self):
        self._write('<?xml version="1.0" encoding="UTF-8"?>', newline=True)

    def _escape(self, text):
        return xml_escape(text)

    def _order_attrs(self, attrs):
        return attrs


class NullMarkupWriter(object):
    """Null implementation of _MarkupWriter interface"""
    __init__ = start = content = element = end = close = lambda *args: None

########NEW FILE########
__FILENAME__ = match
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
from functools import partial

from .normalizing import normalize


def eq(str1, str2, ignore=(), caseless=True, spaceless=True):
    str1 = normalize(str1, ignore, caseless, spaceless)
    str2 = normalize(str2, ignore, caseless, spaceless)
    return str1 == str2


# TODO: Remove matches and matches_any in 2.8.
# They aren't used much in 2.7 anymore but don't want to remove them after RC.

def matches(string, pattern, ignore=(), caseless=True, spaceless=True):
    """Deprecated!! Use Matcher instead."""
    return Matcher(pattern, ignore, caseless, spaceless).match(string)


def matches_any(string, patterns, ignore=(), caseless=True, spaceless=True):
    """Deprecated!! Use MultiMatcher instead."""
    matcher = MultiMatcher(patterns, ignore, caseless, spaceless)
    return matcher.match(string)


class Matcher(object):
    _pattern_tokenizer = re.compile('(\*|\?)')
    _wildcards = {'*': '.*', '?': '.'}

    def __init__(self, pattern, ignore=(), caseless=True, spaceless=True):
        self.pattern = pattern
        self._normalize = partial(normalize, ignore=ignore, caseless=caseless,
                                  spaceless=spaceless)
        self._regexp = self._get_and_compile_regexp(self._normalize(pattern))

    def _get_and_compile_regexp(self, pattern):
        pattern = '^%s$' % ''.join(self._yield_regexp(pattern))
        return re.compile(pattern, re.DOTALL)

    def _yield_regexp(self, pattern):
        for token in self._pattern_tokenizer.split(pattern):
            if token in self._wildcards:
                yield self._wildcards[token]
            else:
                yield re.escape(token)

    def match(self, string):
        return self._regexp.match(self._normalize(string)) is not None


class MultiMatcher(object):

    def __init__(self, patterns=None, ignore=(), caseless=True, spaceless=True,
                 match_if_no_patterns=False):
        self._matchers = [Matcher(pattern, ignore, caseless, spaceless)
                          for pattern in self._ensure_list(patterns)]
        self._match_if_no_patterns = match_if_no_patterns

    def _ensure_list(self, patterns):
        if patterns is None:
            return []
        if isinstance(patterns, basestring):
            return  [patterns]
        return patterns

    def match(self, string):
        if self._matchers:
            return any(m.match(string) for m in self._matchers)
        return self._match_if_no_patterns

    def __len__(self):
        return len(self._matchers)

    def __iter__(self):
        for matcher in self._matchers:
            yield matcher.pattern

########NEW FILE########
__FILENAME__ = misc
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import inspect
import sys

from .unic import unic


def printable_name(string, code_style=False):
    """Generates and returns printable name from the given string.

    Examples:
    'simple'           -> 'Simple'
    'name with spaces' -> 'Name With Spaces'
    'more   spaces'    -> 'More Spaces'
    'Cases AND spaces' -> 'Cases AND Spaces'
    ''                 -> ''

    If 'code_style' is True:

    'mixedCAPSCamel'   -> 'Mixed CAPS Camel'
    'camelCaseName'    -> 'Camel Case Name'
    'under_score_name' -> 'Under Score Name'
    'under_and space'  -> 'Under And Space'
    'miXed_CAPS_nAMe'  -> 'MiXed CAPS NAMe'
    ''                 -> ''
    """
    if code_style and '_' in string:
        string = string.replace('_', ' ')
    parts = string.split()
    if not parts:
        return ''
    if code_style and len(parts) == 1:
        parts = _splitCamelCaseString(parts[0])
    return ' '.join(part[0].upper() + part[1:] for part in parts if part != '')


def _splitCamelCaseString(string):
    parts = []
    current_part = []
    string = ' ' + string + ' '  # extra spaces make going through string easier
    for i in range(1, len(string)-1):
        # on 1st/last round prev/next is ' ' and char is 1st/last real char
        prev, char, next = string[i-1:i+2]
        if _isWordBoundary(prev, char, next):
            parts.append(''.join(current_part))
            current_part = [char]
        else:
            current_part.append(char)
    parts.append(''.join(current_part))   # append last part
    return parts


def _isWordBoundary(prev, char, next):
    if char.isupper():
        return (prev.islower() or next.islower()) and prev.isalnum()
    if char.isdigit():
        return prev.isalpha()
    return prev.isdigit()


def plural_or_not(item):
    count = item if isinstance(item, (int, long)) else len(item)
    return '' if count == 1 else 's'


def seq2str(sequence, quote="'", sep=', ', lastsep=' and '):
    """Returns sequence in format 'item 1', 'item 2' and 'item 3'"""
    quote_elem = lambda string: quote + unic(string) + quote
    if not sequence:
        return ''
    if len(sequence) == 1:
        return quote_elem(sequence[0])
    elems = [quote_elem(s) for s in sequence[:-2]]
    elems.append(quote_elem(sequence[-2]) + lastsep + quote_elem(sequence[-1]))
    return sep.join(elems)


def seq2str2(sequence):
    """Returns sequence in format [ item 1 | item 2 | ... ] """
    if not sequence:
        return '[ ]'
    return '[ %s ]' % ' | '.join(unic(item) for item in sequence)


def getdoc(item):
    doc = inspect.getdoc(item) or u''
    if isinstance(doc, unicode):
        return doc
    try:
        return doc.decode('UTF-8')
    except UnicodeDecodeError:
        return unic(doc)


# On IronPython sys.stdxxx.isatty() always returns True
if sys.platform != 'cli':

    def isatty(stream):
        return hasattr(stream, 'isatty') and stream.isatty()

else:

    from ctypes import windll

    _HANDLE_IDS = {sys.__stdout__ : -11, sys.__stderr__ : -12}
    _CONSOLE_TYPE = 2

    def isatty(stream):
        if stream not in _HANDLE_IDS:
            return False
        handle = windll.kernel32.GetStdHandle(_HANDLE_IDS[stream])
        return windll.kernel32.GetFileType(handle) == _CONSOLE_TYPE

########NEW FILE########
__FILENAME__ = normalizing
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
import sys
from UserDict import UserDict


_WHITESPACE_REGEXP = re.compile('\s+')


def normalize(string, ignore=(), caseless=True, spaceless=True):
    """Normalizes given string according to given spec.

    By default string is turned to lower case and all whitespace is removed.
    Additional characters can be removed by giving them in `ignore` list.
    """
    if spaceless:
        string = _WHITESPACE_REGEXP.sub('', string)
    if caseless:
        string = lower(string)
        ignore = [lower(i) for i in ignore]
    for ign in ignore:
        if ign in string:  # performance optimization
            string = string.replace(ign, '')
    return string


# IronPython fails to lowercase non-ASCII characters:
# http://ironpython.codeplex.com/workitem/33133
if sys.platform != 'cli':
    def lower(string):
        return string.lower()

else:
    def lower(string):
        if string.islower():
            return string
        if string.isupper():
            return string.swapcase()
        if not _has_uppercase_non_ascii_chars(string):
            return string.lower()
        return ''.join(c if not c.isupper() else c.swapcase() for c in string)

    def _has_uppercase_non_ascii_chars(string):
        for c in string:
            if c >= u'\x80' and c.isupper():
                return True
        return False


# TODO: Move normalizing tags to robot.model.Tags in 2.8.
# Move can be done after all tag related code uses Tags.

def normalize_tags(tags):
    """DEPRECATED!! Use robot.model.Tags instead.

    Returns tags sorted and duplicates, empty, and NONE removed.

    If duplicate tags have different case/space, the one used first wins.
    """
    norm = NormalizedDict(((t, 1) for t in tags), ignore=['_'])
    for removed in '', 'NONE':
        if removed in norm:
            norm.pop(removed)
    return norm.keys()


class NormalizedDict(UserDict):
    """Custom dictionary implementation automatically normalizing keys."""

    def __init__(self, initial=None, ignore=(), caseless=True, spaceless=True):
        """Initializes with possible initial value and normalizing spec.

        Initial values can be either a dictionary or an iterable of name/value
        pairs. In the latter case items are added in the given order.

        Normalizing spec has exact same semantics as with `normalize` method.
        """
        UserDict.__init__(self)
        self._keys = {}
        self._normalize = lambda s: normalize(s, ignore, caseless, spaceless)
        if initial:
            self._add_initial(initial)

    def _add_initial(self, items):
        if hasattr(items, 'items'):
            items = items.items()
        for key, value in items:
            self[key] = value

    def update(self, dict=None, **kwargs):
        if dict:
            for key in dict:
                self.set(key, dict[key])
        if kwargs:
            self.update(kwargs)

    def _add_key(self, key):
        nkey = self._normalize(key)
        self._keys.setdefault(nkey, key)
        return nkey

    def set(self, key, value):
        nkey = self._add_key(key)
        self.data[nkey] = value

    __setitem__ = set

    def get(self, key, default=None):
        try:
            return self.__getitem__(key)
        except KeyError:
            return default

    def __getitem__(self, key):
        return self.data[self._normalize(key)]

    def pop(self, key):
        nkey = self._normalize(key)
        del self._keys[nkey]
        return self.data.pop(nkey)

    __delitem__ = pop

    def clear(self):
        UserDict.clear(self)
        self._keys.clear()

    def has_key(self, key):
        return self.data.has_key(self._normalize(key))

    __contains__ = has_key

    def __iter__(self):
        return (self._keys[norm_key] for norm_key in sorted(self._keys))

    def keys(self):
        return list(self)

    def iterkeys(self):
        return iter(self)

    def values(self):
        return list(self.itervalues())

    def itervalues(self):
        return (self[key] for key in self)

    def items(self):
        return list(self.iteritems())

    def iteritems(self):
        return ((key, self[key]) for key in self)

    def copy(self):
        copy = UserDict.copy(self)
        copy._keys = self._keys.copy()
        return copy

    def __str__(self):
        return str(dict(self.items()))

    def __cmp__(self, other):
        if not isinstance(other, NormalizedDict):
            other = NormalizedDict(other)
        return UserDict.__cmp__(self, other)

########NEW FILE########
__FILENAME__ = robotenv
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys

from .encoding import decode_from_system, encode_to_system
from .unic import unic


def get_env_var(name, default=None):
    value = _get_env_var_from_java(name)
    if value is not None:
        return value
    try:
        value = os.environ[_encode(name)]
    except KeyError:
        return default
    else:
        return _decode(value)

def set_env_var(name, value):
    os.environ[_encode(name)] = _encode(value)

def del_env_var(name):
    # cannot use os.environ.pop() due to http://bugs.python.org/issue1287
    value = get_env_var(name)
    if value is not None:
        del os.environ[_encode(name)]
    return value

def get_env_vars():
    # name is upper-cases consistently on Windows regardless interpreter
    return dict((name if os.sep == '/' else name.upper(), get_env_var(name))
                for name in (_decode(name) for name in os.environ))


def _encode(var):
    if isinstance(var, str):
        return var
    if isinstance(var, unicode):
        return encode_to_system(var)
    return str(var)

def _decode(var):
    return decode_from_system(var, can_be_from_java=False)

# Jython hack below needed due to http://bugs.jython.org/issue1841
if not sys.platform.startswith('java'):
    def _get_env_var_from_java(name):
        return None

else:
    from java.lang import String, System

    def _get_env_var_from_java(name):
        name = name if isinstance(name, basestring) else unic(name)
        value_set_before_execution = System.getenv(name)
        if value_set_before_execution is None:
            return None
        current_value = String(os.environ[name]).toString()
        if value_set_before_execution != current_value:
            return None
        return value_set_before_execution

########NEW FILE########
__FILENAME__ = robotpath
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import urllib

from .encoding import decode_from_system


if os.sep == '\\':
    CASE_INSENSITIVE_FILESYSTEM = True
else:
    try:
        CASE_INSENSITIVE_FILESYSTEM = os.listdir('/tmp') == os.listdir('/TMP')
    except OSError:
        CASE_INSENSITIVE_FILESYSTEM = False


def normpath(path):
    """Returns path in normalized and absolute format.

    On case-insensitive file systems the path is also case normalized.
    If that is not desired, abspath should be used instead.
    """
    path = abspath(path)
    if CASE_INSENSITIVE_FILESYSTEM:
        path = path.lower()
    return path


def abspath(path):
    """Replacement for os.path.abspath with some bug fixes and enhancements.

    1) Converts non-Unicode paths to Unicode using file system encoding
    2) At least Jython 2.5.1 on Windows returns wrong path with 'c:'.
    3) Python until 2.6.5 and at least Jython 2.5.1 don't handle non-ASCII
       characters in the working directory: http://bugs.python.org/issue3426
    """
    if not isinstance(path, unicode):
        path = decode_from_system(path)
    if os.sep == '\\' and len(path) == 2 and path[1] == ':':
        return path + '\\'
    if not os.path.isabs(path):
        path = os.path.join(os.getcwdu(), path)
    return os.path.normpath(path)


def get_link_path(target, base):
    """Returns a relative path to a target from a base.

    If base is an existing file, then its parent directory is considered.
    Otherwise, base is assumed to be a directory.

    Rationale: os.path.relpath is not available before Python 2.6
    """
    path =  _get_pathname(target, base)
    url = urllib.pathname2url(path.encode('UTF-8'))
    if os.path.isabs(path):
        url = 'file:' + url
    # At least Jython seems to use 'C|/Path' and not 'C:/Path'
    if os.sep == '\\' and '|/' in url:
        url = url.replace('|/', ':/', 1)
    return url.replace('%5C', '/').replace('%3A', ':').replace('|', ':')

def _get_pathname(target, base):
    target = abspath(target)
    base = abspath(base)
    if os.path.isfile(base):
        base = os.path.dirname(base)
    if base == target:
        return os.path.basename(target)
    base_drive, base_path = os.path.splitdrive(base)
    # if in Windows and base and link on different drives
    if os.path.splitdrive(target)[0] != base_drive:
        return target
    common_len = len(_common_path(base, target))
    if base_path == os.sep:
        return target[common_len:]
    if common_len == len(base_drive) + len(os.sep):
        common_len -= len(os.sep)
    dirs_up = os.sep.join([os.pardir] * base[common_len:].count(os.sep))
    return os.path.join(dirs_up, target[common_len + len(os.sep):])

def _common_path(p1, p2):
    """Returns the longest path common to p1 and p2.

    Rationale: as os.path.commonprefix is character based, it doesn't consider
    path separators as such, so it may return invalid paths:
    commonprefix(('/foo/bar/', '/foo/baz.txt')) -> '/foo/ba' (instead of /foo)
    """
    while p1 and p2:
        if p1 == p2:
            return p1
        if len(p1) > len(p2):
            p1 = os.path.dirname(p1)
        else:
            p2 = os.path.dirname(p2)
    return ''

########NEW FILE########
__FILENAME__ = robottime
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import time
import datetime

from .normalizing import normalize
from .misc import plural_or_not


def _get_timetuple(epoch_secs=None):
    if epoch_secs is None:  # can also be 0 (at least in unit tests)
        epoch_secs = time.time()
    secs, millis = _float_secs_to_secs_and_millis(epoch_secs)
    timetuple = time.localtime(secs)[:6]  # from year to secs
    return timetuple + (millis,)

def _float_secs_to_secs_and_millis(secs):
    isecs = int(secs)
    millis = int(round((secs - isecs) * 1000))
    return (isecs, millis) if millis < 1000 else (isecs+1, 0)


START_TIME = _get_timetuple()


def timestr_to_secs(timestr):
    """Parses time in format like '1h 10s' and returns time in seconds (float).

    Given time must be in format '1d 2h 3m 4s 5ms' with following rules:

    - Time parts having zero value can be ignored (e.g. '3m 4s' is ok)
    - Format is case and space insensitive
    - Instead of 'd' it is also possible to use 'day' or 'days'
    - Instead of 'h' also 'hour' and 'hours' are ok
    - Instead of 'm' also 'minute', 'minutes', 'min' and 'mins' are ok
    - Instead of 's' also 'second', 'seconds', 'sec' and 'secs' are ok
    - Instead of 'ms' also 'millisecond', 'milliseconds' and 'millis' are ok
    - It is possible to give time only as a float and then it is considered
      to be seconds (e.g. '123', '123.0', '123s', '2min 3s' are all equivelant)
    """
    try:
        secs = _timestr_to_secs(timestr)
    except (ValueError, TypeError):
        raise ValueError("Invalid time string '%s'" % timestr)
    return round(secs, 3)

def _timestr_to_secs(timestr):
    timestr = _normalize_timestr(timestr)
    if timestr == '':
        raise ValueError
    try:
        return float(timestr)
    except ValueError:
        pass
    millis = secs = mins = hours = days = 0
    if timestr[0] == '-':
        sign = -1
        timestr = timestr[1:]
    else:
        sign = 1
    temp = []
    for c in timestr:
        if   c == 'x': millis = float(''.join(temp)); temp = []
        elif c == 's': secs   = float(''.join(temp)); temp = []
        elif c == 'm': mins   = float(''.join(temp)); temp = []
        elif c == 'h': hours  = float(''.join(temp)); temp = []
        elif c == 'p': days   = float(''.join(temp)); temp = []
        else: temp.append(c)
    if temp:
        raise ValueError
    return sign * (millis/1000 + secs + mins*60 + hours*60*60 + days*60*60*24)

def _normalize_timestr(timestr):
    if isinstance(timestr, (int, long, float)):
        return timestr
    timestr = normalize(timestr)
    for item in 'milliseconds', 'millisecond', 'millis':
        timestr = timestr.replace(item, 'ms')
    for item in 'seconds', 'second', 'secs', 'sec':
        timestr = timestr.replace(item, 's')
    for item in 'minutes', 'minute', 'mins', 'min':
        timestr = timestr.replace(item, 'm')
    for item in 'hours', 'hour':
        timestr = timestr.replace(item, 'h')
    for item in 'days', 'day':
        timestr = timestr.replace(item, 'd')
    # 1) 'ms' -> 'x' to ease processing later
    # 2) 'd' -> 'p' because float('1d') returns 1.0 in Jython (bug submitted)
    return timestr.replace('ms','x').replace('d','p')


def secs_to_timestr(secs, compact=False):
    """Converts time in seconds to a string representation.

    Returned string is in format like
    '1 day 2 hours 3 minutes 4 seconds 5 milliseconds' with following rules:

    - Time parts having zero value are not included (e.g. '3 minutes 4 seconds'
      instead of '0 days 0 hours 3 minutes 4 seconds')
    - Hour part has a maximun of 23 and minutes and seconds both have 59
      (e.g. '1 minute 40 seconds' instead of '100 seconds')

    If compact has value 'True', short suffixes are used.
    (e.g. 1d 2h 3min 4s 5ms)
    """
    return _SecsToTimestrHelper(secs, compact).get_value()

class _SecsToTimestrHelper:

    def __init__(self, float_secs, compact):
        self._compact = compact
        self._ret = []
        self._sign, millis, secs, mins, hours, days \
                = self._secs_to_components(float_secs)
        self._add_item(days, 'd', 'day')
        self._add_item(hours, 'h', 'hour')
        self._add_item(mins, 'min', 'minute')
        self._add_item(secs, 's', 'second')
        self._add_item(millis, 'ms', 'millisecond')

    def get_value(self):
        if len(self._ret) > 0:
            return self._sign + ' '.join(self._ret)
        return '0s' if self._compact else '0 seconds'

    def _add_item(self, value, compact_suffix, long_suffix):
        if value == 0:
            return
        if self._compact:
            suffix = compact_suffix
        else:
            suffix = ' %s%s' % (long_suffix, plural_or_not(value))
        self._ret.append('%d%s' % (value, suffix))

    def _secs_to_components(self, float_secs):
        if float_secs < 0:
            sign = '- '
            float_secs = abs(float_secs)
        else:
            sign = ''
        int_secs, millis = _float_secs_to_secs_and_millis(float_secs)
        secs  = int_secs % 60
        mins  = int(int_secs / 60) % 60
        hours = int(int_secs / (60*60)) % 24
        days  = int(int_secs / (60*60*24))
        return sign, millis, secs, mins, hours, days


def format_time(timetuple_or_epochsecs, daysep='', daytimesep=' ', timesep=':',
                millissep=None, gmtsep=None):
    """Returns a timestamp formatted from given time using separators.

    Time can be given either as a timetuple or seconds after epoch.

    Timetuple is (year, month, day, hour, min, sec[, millis]), where parts must
    be integers and millis is required only when millissep is not None.
    Notice that this is not 100% compatible with standard Python timetuples
    which do not have millis.

    Seconds after epoch can be either an integer or a float.
    """
    if isinstance(timetuple_or_epochsecs, (int, long, float)):
        timetuple = _get_timetuple(timetuple_or_epochsecs)
    else:
        timetuple = timetuple_or_epochsecs
    daytimeparts = ['%02d' % t for t in timetuple[:6]]
    day = daysep.join(daytimeparts[:3])
    time_ = timesep.join(daytimeparts[3:6])
    millis = millissep and '%s%03d' % (millissep, timetuple[6]) or ''
    return day + daytimesep + time_ + millis + _diff_to_gmt(gmtsep)

def _diff_to_gmt(sep):
    if not sep:
        return ''
    if time.altzone == 0:
        sign = ''
    elif time.altzone > 0:
        sign = '-'
    else:
        sign = '+'
    minutes = abs(time.altzone) / 60.0
    hours, minutes = divmod(minutes, 60)
    return '%sGMT%s%s%02d:%02d' % (sep, sep, sign, hours, minutes)


def get_time(format='timestamp', time_=None):
    """Return the given or current time in requested format.

    If time is not given, current time is used. How time is returned is
    is deternined based on the given 'format' string as follows. Note that all
    checks are case insensitive.

    - If 'format' contains word 'epoch' the time is returned in seconds after
      the unix epoch.
    - If 'format' contains any of the words 'year', 'month', 'day', 'hour',
      'min' or 'sec' only selected parts are returned. The order of the returned
      parts is always the one in previous sentence and order of words in
      'format' is not significant. Parts are returned as zero padded strings
      (e.g. May -> '05').
    - Otherwise (and by default) the time is returned as a timestamp string in
      format '2006-02-24 15:08:31'
    """
    time_ = int(time_ or time.time())
    format = format.lower()
    # 1) Return time in seconds since epoc
    if 'epoch' in format:
        return time_
    timetuple = time.localtime(time_)
    parts = []
    for i, match in enumerate('year month day hour min sec'.split()):
        if match in format:
            parts.append('%.2d' % timetuple[i])
    # 2) Return time as timestamp
    if not parts:
        return format_time(timetuple, daysep='-')
    # Return requested parts of the time
    elif len(parts) == 1:
        return parts[0]
    else:
        return parts


def parse_time(timestr):
    """Parses the time string and returns its value as seconds since epoch.

    Time can be given in five different formats:

    1) Numbers are interpreted as time since epoch directly. It is possible to
       use also ints and floats, not only strings containing numbers.
    2) Valid timestamp ('YYYY-MM-DD hh:mm:ss' and 'YYYYMMDD hhmmss').
    3) 'NOW' (case-insensitive) is the current local time.
    4) 'UTC' (case-insensitive) is the current time in UTC.
    5) Format 'NOW - 1 day' or 'UTC + 1 hour 30 min' is the current local/UTC
       time plus/minus the time specified with the time string.

    Seconds are rounded down to avoid getting times in the future.
    """
    for method in [_parse_time_epoch,
                   _parse_time_timestamp,
                   _parse_time_now_and_utc]:
        seconds = method(timestr)
        if seconds is not None:
            return int(seconds)
    raise ValueError("Invalid time format '%s'" % timestr)

def _parse_time_epoch(timestr):
    try:
        ret = float(timestr)
    except ValueError:
        return None
    if ret < 0:
        raise ValueError("Epoch time must be positive (got %s)" % timestr)
    return ret

def _parse_time_timestamp(timestr):
    try:
        return timestamp_to_secs(timestr, (' ', ':', '-', '.'))
    except ValueError:
        return None

def _parse_time_now_and_utc(timestr):
    timestr = timestr.replace(' ', '').lower()
    base = _parse_time_now_and_utc_base(timestr[:3])
    if base is not None:
        extra = _parse_time_now_and_utc_extra(timestr[3:])
        if extra is not None:
            return base + extra
    return None

def _parse_time_now_and_utc_base(base):
    now = time.time()
    if base == 'now':
        return now
    if base == 'utc':
        return now + time.altzone
    return None

def _parse_time_now_and_utc_extra(extra):
    if not extra:
        return 0
    if extra[0] not in ['+', '-']:
        return None
    return (1 if extra[0] == '+' else -1) * timestr_to_secs(extra[1:])


def get_timestamp(daysep='', daytimesep=' ', timesep=':', millissep='.'):
    return TIMESTAMP_CACHE.get_timestamp(daysep, daytimesep, timesep, millissep)


def timestamp_to_secs(timestamp, seps=None):
    try:
        secs = _timestamp_to_millis(timestamp, seps) / 1000.0
    except (ValueError, OverflowError):
        raise ValueError("Invalid timestamp '%s'" % timestamp)
    else:
        return round(secs, 3)


def secs_to_timestamp(secs, seps=None, millis=False):
    if not seps:
        seps = ('', ' ', ':', '.' if millis else None)
    ttuple = time.localtime(secs)[:6]
    if millis:
        millis = (secs - int(secs)) * 1000
        ttuple = ttuple + (int(millis),)
    return format_time(ttuple, *seps)


def get_start_timestamp(daysep='', daytimesep=' ', timesep=':', millissep=None):
    return format_time(START_TIME, daysep, daytimesep, timesep, millissep)


def get_elapsed_time(start_time, end_time):
    """Returns the time between given timestamps in milliseconds."""
    if start_time == end_time or not (start_time and end_time):
        return 0
    if start_time[:-4] == end_time[:-4]:
        return int(end_time[-3:]) - int(start_time[-3:])
    start_millis = _timestamp_to_millis(start_time)
    end_millis = _timestamp_to_millis(end_time)
    # start/end_millis can be long but we want to return int when possible
    return int(end_millis - start_millis)


def elapsed_time_to_string(elapsed, include_millis=True):
    """Converts elapsed time in milliseconds to format 'hh:mm:ss.mil'.

    If `include_millis` is True, '.mil' part is omitted.
    """
    prefix = ''
    if elapsed < 0:
        elapsed = abs(elapsed)
        prefix = '-'
    if include_millis:
        return prefix + _elapsed_time_to_string(elapsed)
    return prefix + _elapsed_time_to_string_without_millis(elapsed)

def _elapsed_time_to_string(elapsed):
    secs, millis = divmod(int(round(elapsed)), 1000)
    mins, secs = divmod(secs, 60)
    hours, mins = divmod(mins, 60)
    return '%02d:%02d:%02d.%03d' % (hours, mins, secs, millis)

def _elapsed_time_to_string_without_millis(elapsed):
    secs = int(round(elapsed, -3)) / 1000
    mins, secs = divmod(secs, 60)
    hours, mins = divmod(mins, 60)
    return '%02d:%02d:%02d' % (hours, mins, secs)


def _timestamp_to_millis(timestamp, seps=None):
    if seps:
        timestamp = _normalize_timestamp(timestamp, seps)
    Y, M, D, h, m, s, millis = _split_timestamp(timestamp)
    secs = time.mktime(datetime.datetime(Y, M, D, h, m, s).timetuple())
    return int(round(1000*secs + millis))

def _normalize_timestamp(ts, seps):
    for sep in seps:
        if sep in ts:
            ts = ts.replace(sep, '')
    ts = ts.ljust(17, '0')
    return '%s%s%s %s:%s:%s.%s' % (ts[:4], ts[4:6], ts[6:8], ts[8:10],
                                   ts[10:12], ts[12:14], ts[14:17])

def _split_timestamp(timestamp):
    years = int(timestamp[:4])
    mons = int(timestamp[4:6])
    days = int(timestamp[6:8])
    hours = int(timestamp[9:11])
    mins = int(timestamp[12:14])
    secs = int(timestamp[15:17])
    millis = int(timestamp[18:21])
    return years, mons, days, hours, mins, secs, millis


class TimestampCache(object):

    def __init__(self):
        self._previous_secs = None
        self._previous_separators = None
        self._previous_timestamp = None

    def get_timestamp(self, daysep='', daytimesep=' ', timesep=':', millissep='.'):
        epoch = self._get_epoch()
        secs, millis = _float_secs_to_secs_and_millis(epoch)
        if self._use_cache(secs, daysep, daytimesep, timesep):
            return self._cached_timestamp(millis, millissep)
        timestamp = format_time(epoch, daysep, daytimesep, timesep, millissep)
        self._cache_timestamp(secs, timestamp, daysep, daytimesep, timesep, millissep)
        return timestamp

    # Seam for mocking
    def _get_epoch(self):
        return time.time()

    def _use_cache(self, secs, *separators):
        return self._previous_timestamp \
            and self._previous_secs == secs \
            and self._previous_separators == separators

    def _cached_timestamp(self, millis, millissep):
        if millissep:
            return '%s%s%03d' % (self._previous_timestamp, millissep, millis)
        return self._previous_timestamp

    def _cache_timestamp(self, secs, timestamp, daysep, daytimesep, timesep, millissep):
        self._previous_secs = secs
        self._previous_separators = (daysep, daytimesep, timesep)
        self._previous_timestamp = timestamp[:-4] if millissep else timestamp


TIMESTAMP_CACHE = TimestampCache()

########NEW FILE########
__FILENAME__ = setter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class setter(object):

    def __init__(self, method):
        self.method = method
        self.attr_name = '_setter__' + method.__name__

    def __get__(self, instance, owner):
        if instance is None:
            return self
        try:
            return getattr(instance, self.attr_name)
        except AttributeError:
            raise AttributeError(self.method.__name__)

    def __set__(self, instance, value):
        if instance is None:
            return
        setattr(instance, self.attr_name, self.method(instance, value))


class SetterAwareType(type):

    def __new__(cls, name, bases, dct):
        slots = dct.get('__slots__')
        if slots is not None:
            for item in dct.values():
                if isinstance(item, setter):
                    slots.append(item.attr_name)
        return type.__new__(cls, name, bases, dct)

########NEW FILE########
__FILENAME__ = text
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from unic import unic
from misc import seq2str2
from charwidth import get_char_width


_MAX_ASSIGN_LENGTH = 200
_MAX_ERROR_LINES = 40
_MAX_ERROR_LINE_LENGTH = 78
_ERROR_CUT_EXPLN = ('    [ Message content over the limit has been removed. ]')


def cut_long_message(msg):
    lines = msg.splitlines()
    lengths = _count_line_lenghts(lines)
    if sum(lengths) <= _MAX_ERROR_LINES:
        return msg
    start = _prune_excess_lines(lines, lengths)
    end = _prune_excess_lines(lines, lengths, True)
    return '\n'.join(start + [_ERROR_CUT_EXPLN] + end)

def _prune_excess_lines(lines, lengths, from_end=False):
    if from_end:
        lines.reverse()
        lengths.reverse()
    ret = []
    total = 0
    limit = _MAX_ERROR_LINES/2
    for line, length in zip(lines[:limit], lengths[:limit]):
        if total + length >= limit:
            ret.append(_cut_long_line(line, total, from_end))
            break
        total += length
        ret.append(line)
    if from_end:
        ret.reverse()
    return ret

def _cut_long_line(line, used, from_end):
    available_lines = _MAX_ERROR_LINES/2 - used
    available_chars = available_lines * _MAX_ERROR_LINE_LENGTH - 3
    if len(line) > available_chars:
        if not from_end:
            line = line[:available_chars] + '...'
        else:
            line = '...' + line[-available_chars:]
    return line

def _count_line_lenghts(lines):
    return [ _count_virtual_line_length(line) for line in lines ]

def _count_virtual_line_length(line):
    length = len(line) / _MAX_ERROR_LINE_LENGTH
    if not len(line) % _MAX_ERROR_LINE_LENGTH == 0 or len(line) == 0:
        length += 1
    return length


def format_assign_message(variable, value, cut_long=True):
    value = unic(value) if variable.startswith('$') else seq2str2(value)
    if cut_long and len(value) > _MAX_ASSIGN_LENGTH:
        value = value[:_MAX_ASSIGN_LENGTH] + '...'
    return '%s = %s' % (variable, value)


def get_console_length(text):
    return sum(get_char_width(char) for char in text)


def pad_console_length(text, width):
    if width < 5:
        width = 5
    diff = get_console_length(text) - width
    if diff <= 0:
        return _pad_width(text, width)
    return _pad_width(_lose_width(text, diff+3)+'...', width)

def _pad_width(text, width):
    more = width - get_console_length(text)
    return text + ' ' * more

def _lose_width(text, diff):
    lost = 0
    while lost < diff:
        lost += get_console_length(text[-1])
        text = text[:-1]
    return text

########NEW FILE########
__FILENAME__ = unic
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys


# Need different unic implementations for different Pythons because:
# 1) Importing unicodedata module on Jython takes a very long time, and doesn't
# seem to be necessary as Java probably already handles normalization.
# Furthermore, Jython on Java 1.5 doesn't even have unicodedata.normalize.
# 2) IronPython 2.6 doesn't have unicodedata and probably doesn't need it.
# 3) CPython doesn't automatically normalize Unicode strings.

if sys.platform.startswith('java'):
    from java.lang import Object, Class
    def unic(item, *args):
        # http://bugs.jython.org/issue1564
        if isinstance(item, Object) and not isinstance(item, Class):
            try:
                item = item.toString()  # http://bugs.jython.org/issue1563
            except:
                return _unrepresentable_object(item)
        return _unic(item, *args)

elif sys.platform == 'cli':
    def unic(item, *args):
        return _unic(item, *args)

else:
    from unicodedata import normalize
    def unic(item, *args):
        return normalize('NFC', _unic(item, *args))


def _unic(item, *args):
    # Based on a recipe from http://code.activestate.com/recipes/466341
    try:
        return unicode(item, *args)
    except UnicodeError:
        try:
            ascii_text = str(item).encode('string_escape')
        except:
            return _unrepresentable_object(item)
        else:
            return unicode(ascii_text)
    except:
        return _unrepresentable_object(item)


def safe_repr(item):
    try:
        return unic(repr(item))
    except UnicodeError:
        return repr(unic(item))
    except:
        return _unrepresentable_object(item)

if sys.platform == 'cli':
    # IronPython omits `u` prefix from `repr(u'foo')`. We add it back to have
    # consistent and easier to test log messages.
    _safe_repr = safe_repr

    def safe_repr(item):
        if isinstance(item, list):
            return '[%s]' % ', '.join(safe_repr(i) for i in item)
        ret = _safe_repr(item)
        if isinstance(item, unicode) and not ret.startswith('u'):
            ret = 'u' + ret
        return ret


_unrepresentable_msg = u"<Unrepresentable object '%s'. Error: %s>"

def _unrepresentable_object(item):
    from robot.utils.error import get_error_message
    return _unrepresentable_msg % (item.__class__.__name__, get_error_message())

########NEW FILE########
__FILENAME__ = isvar
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


def is_var(string):
    if not isinstance(string, basestring):
        return False
    length = len(string)
    return length > 3 and string[0] in ['$','@'] and string.rfind('{') == 1 \
            and string.find('}') == length - 1


def is_scalar_var(string):
    return is_var(string) and string[0] == '$'


def is_list_var(string):
    return is_var(string) and string[0] == '@'

########NEW FILE########
__FILENAME__ = variableassigner
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robot.errors import DataError
from robot.utils import safe_repr, format_assign_message, get_error_message

from .isvar import is_list_var, is_scalar_var


class VariableAssigner(object):
    _valid_extended_attr = re.compile('^[_a-zA-Z]\w*$')

    def __init__(self, assign):
        ap = AssignParser(assign)
        self.scalar_vars = ap.scalar_vars
        self.list_var = ap.list_var

    def assign(self, context, return_value):
        context.trace(lambda: 'Return: %s' % safe_repr(return_value))
        if self.scalar_vars or self.list_var:
            self._assign(context, ReturnValue(self.scalar_vars, self.list_var,
                                              return_value))

    def _assign(self, context, return_value):
        variables = context.get_current_vars()
        for name, value in return_value.get_variables_to_set():
            if not self._extended_assign(name, value, variables):
                self._normal_assign(name, value, variables)
            context.output.info(format_assign_message(name, value))

    def _extended_assign(self, name, value, variables):
        if '.' not in name or name.startswith('@') \
                or variables.contains(name, extended=False):
            return False
        base, attr = self._split_extended_assign(name)
        if not variables.contains(base, extended=True):
            return False
        var = variables[base]
        if not (self._variable_supports_extended_assign(var) and
                self._is_valid_extended_attribute(attr)):
            return False
        try:
            setattr(var, attr, value)
        except:
            raise DataError("Setting attribute '%s' to variable '%s' failed: %s"
                            % (attr, base, get_error_message()))
        return True

    def _split_extended_assign(self, name):
        base, attr = name.rsplit('.', 1)
        return base.strip() + '}', attr[:-1].strip()

    def _variable_supports_extended_assign(self, var):
        return not isinstance(var, (basestring, int, long, float))

    def _is_valid_extended_attribute(self, attr):
        return self._valid_extended_attr.match(attr) is not None

    def _normal_assign(self, name, value, variables):
        variables[name] = value


class AssignParser(object):

    def __init__(self, assign):
        self.scalar_vars = []
        self.list_var = None
        self._assign_mark_used = False
        for var in assign:
            self._verify_items_allowed_only_on_last_round()
            var = self._strip_possible_assign_mark(var)
            self._set(var)

    def _verify_items_allowed_only_on_last_round(self):
        if self._assign_mark_used:
            raise DataError("Assign mark '=' can be used only with the last variable.")
        if self.list_var:
            raise DataError('Only the last variable to assign can be a list variable.')

    def _strip_possible_assign_mark(self, variable):
        if not variable.endswith('='):
            return variable
        self._assign_mark_used = True
        return variable.rstrip('= ')

    def _set(self, variable):
        if is_scalar_var(variable):
            self.scalar_vars.append(variable)
        elif is_list_var(variable):
            self.list_var = variable
        else:
            raise DataError('Invalid variable to assign: %s' % variable)


class ReturnValue(object):

    def __init__(self, scalar_vars, list_var, return_value):
        self._scalars = scalar_vars
        self._list = list_var
        self._return = return_value

    def get_variables_to_set(self):
        if self._return is None:
            return self._return_value_is_none(self._scalars, self._list)
        if len(self._scalars) == 1 and not self._list:
            return self._only_one_variable(self._scalars[0], self._return)
        ret = self._convert_to_list(self._return)
        if not self._list:
            return self._only_scalars(self._scalars, ret)
        if not self._scalars:
            return self._only_one_variable(self._list, ret)
        return self._scalars_and_list(self._scalars, self._list, ret)

    def _return_value_is_none(self, scalars, list_):
        ret = [(var, None) for var in scalars]
        if self._list:
            ret.append((list_, []))
        return ret

    def _only_one_variable(self, variable, ret):
        return [(variable, ret)]

    def _convert_to_list(self, ret):
        if isinstance(ret, basestring):
            self._raise_expected_list(ret)
        try:
            return list(ret)
        except TypeError:
            self._raise_expected_list(ret)

    def _only_scalars(self, scalars, ret):
        needed = len(scalars)
        if len(ret) < needed:
            self._raise_too_few_arguments(ret)
        if len(ret) == needed:
            return zip(scalars, ret)
        return zip(scalars[:-1], ret) + [(scalars[-1], ret[needed-1:])]

    def _scalars_and_list(self, scalars, list_, ret):
        if len(ret) < len(scalars):
            self._raise_too_few_arguments(ret)
        return zip(scalars, ret) + [(list_, ret[len(scalars):])]

    def _raise_expected_list(self, ret):
        typ = 'string' if isinstance(ret, basestring) else type(ret).__name__
        self._raise('Expected list-like object, got %s instead.' % typ)

    def _raise_too_few_arguments(self, ret):
        self._raise('Need more values than %d.' % len(ret))

    def _raise(self, error):
        raise DataError('Cannot assign return values: %s' % error)

########NEW FILE########
__FILENAME__ = variables
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
import inspect
from functools import partial
from UserDict import UserDict
try:
    from java.lang.System import getProperty as getJavaSystemProperty
    from java.util import Map
except ImportError:
    getJavaSystemProperty = lambda name: None
    class Map: pass

from robot import utils
from robot.errors import DataError
from robot.output import LOGGER

from .isvar import is_var, is_scalar_var
from .variablesplitter import VariableSplitter


class Variables(utils.NormalizedDict):
    """Represents a set of variables including both ${scalars} and @{lists}.

    Contains methods for replacing variables from list, scalars, and strings.
    On top of ${scalar} and @{list} variables these methods handle also
    %{environment} variables.
    """

    _extended_var_re = re.compile(r'''
    ^\${         # start of the string and "${"
    (.+?)        # base name (group 1)
    ([^\s\w].+)  # extended part (group 2)
    }$           # "}" and end of the string
    ''', re.UNICODE|re.VERBOSE)

    def __init__(self, identifiers=('$','@','%','&','*')):
        utils.NormalizedDict.__init__(self, ignore=['_'])
        self._identifiers = identifiers
        importer = utils.Importer('variable file').import_class_or_module_by_path
        self._import_variable_file = partial(importer, instantiate_with_args=())

    def __setitem__(self, name, value):
        self._validate_var_name(name)
        utils.NormalizedDict.__setitem__(self, name, value)

    def update(self, dict=None, **kwargs):
        if dict:
            self._validate_var_dict(dict)
            UserDict.update(self, dict)
            for key in dict:
                self._add_key(key)
        if kwargs:
            self.update(kwargs)

    def __getitem__(self, name):
        self._validate_var_name(name)
        try: return utils.NormalizedDict.__getitem__(self, name)
        except KeyError:
            try: return self._get_number_var(name)
            except ValueError:
                try: return self._get_list_var_as_scalar(name)
                except ValueError:
                    try: return self._get_extended_var(name)
                    except ValueError:
                        raise DataError("Non-existing variable '%s'." % name)

    def _validate_var_name(self, name):
        if not is_var(name):
            raise DataError("Invalid variable name '%s'." % name)

    def _validate_var_dict(self, dict):
        for name in dict:
            self._validate_var_name(name)

    def _get_list_var_as_scalar(self, name):
        if is_scalar_var(name):
            try:
                return self['@'+name[1:]]
            except DataError:
                pass
        raise ValueError

    def _get_extended_var(self, name):
        err_pre = "Resolving variable '%s' failed: " % name
        res = self._extended_var_re.search(name)
        if res is None:
            raise ValueError
        base_name = res.group(1)
        expression = res.group(2)
        try:
            variable = self['${%s}' % base_name]
        except DataError, err:
            raise DataError(err_pre + unicode(err))
        try:
            return eval('_BASE_VAR_' + expression, {'_BASE_VAR_': variable})
        except:
            raise DataError(err_pre + utils.get_error_message())

    def _get_number_var(self, name):
        if name[0] != '$':
            raise ValueError
        number = self._normalize(name)[2:-1]
        try:
            return self._get_int_var(number)
        except ValueError:
            return float(number)

    def _get_int_var(self, number):
        bases = {'0b': 2, '0o': 8, '0x': 16}
        if number.startswith(tuple(bases)):
            return int(number[2:], bases[number[:2]])
        return int(number)

    def replace_list(self, items):
        """Replaces variables from a list of items.

        If an item in a list is a @{list} variable its value is returned.
        Possible variables from other items are replaced using 'replace_scalar'.
        Result is always a list.
        """
        results = []
        for item in items or []:
            listvar = self._replace_variables_inside_possible_list_var(item)
            if listvar:
                results.extend(self[listvar])
            else:
                item = self.replace_scalar(item)
                results.append(item)
        return results

    def _replace_variables_inside_possible_list_var(self, item):
        if not (isinstance(item, basestring) and
                item.startswith('@{') and item.endswith('}')):
            return None
        var = VariableSplitter(item, self._identifiers)
        if var.start != 0 or var.end != len(item):
            return None
        return '@{%s}' % var.get_replaced_base(self)

    def replace_scalar(self, item):
        """Replaces variables from a scalar item.

        If the item is not a string it is returned as is. If it is a ${scalar}
        variable its value is returned. Otherwise variables are replaced with
        'replace_string'. Result may be any object.
        """
        if self._cannot_have_variables(item):
            return utils.unescape(item)
        var = VariableSplitter(item, self._identifiers)
        if var.identifier and var.base and var.start == 0 and var.end == len(item):
            return self._get_variable(var)
        return self.replace_string(item, var)

    def _cannot_have_variables(self, item):
        return (not isinstance(item, basestring)) or '{' not in item

    def replace_string(self, string, splitted=None, ignore_errors=False):
        """Replaces variables from a string. Result is always a string."""
        if self._cannot_have_variables(string):
            return utils.unescape(string)
        result = []
        if splitted is None:
            splitted = VariableSplitter(string, self._identifiers)
        while True:
            if splitted.identifier is None:
                result.append(utils.unescape(string))
                break
            result.append(utils.unescape(string[:splitted.start]))
            try:
                value = self._get_variable(splitted)
            except DataError:
                if not ignore_errors:
                    raise
                value = string[splitted.start:splitted.end]
            if not isinstance(value, unicode):
                value = utils.unic(value)
            result.append(value)
            string = string[splitted.end:]
            splitted = VariableSplitter(string, self._identifiers)
        result = ''.join(result)
        return result

    def _get_variable(self, var):
        """'var' is an instance of a VariableSplitter"""
        # 1) Handle reserved syntax
        if var.identifier not in ['$','@','%']:
            value = '%s{%s}' % (var.identifier, var.base)
            LOGGER.warn("Syntax '%s' is reserved for future use. Please "
                        "escape it like '\\%s'." % (value, value))
            return value

        # 2) Handle environment variables and Java system properties
        elif var.identifier == '%':
            name = var.get_replaced_base(self).strip()
            if not name:
                return '%%{%s}' % var.base
            value = utils.get_env_var(name)
            if value is not None:
                return value
            value = getJavaSystemProperty(name)
            if value is not None:
                return value
            raise DataError("Environment variable '%s' does not exist" % name)

        # 3) Handle ${scalar} variables and @{list} variables without index
        elif var.index is None:
            name = '%s{%s}' % (var.identifier, var.get_replaced_base(self))
            return self[name]

        # 4) Handle items from list variables e.g. @{var}[1]
        else:
            try:
                index = int(self.replace_string(var.index))
                name = '@{%s}' % var.get_replaced_base(self)
                return self[name][index]
            except (ValueError, DataError, IndexError):
                raise DataError("Non-existing variable '@{%s}[%s]'"
                                % (var.base, var.index))

    def set_from_file(self, path, args=None, overwrite=False):
        LOGGER.info("Importing variable file '%s' with args %s" % (path, args))
        var_file = self._import_variable_file(path)
        try:
            variables = self._get_variables_from_var_file(var_file, args)
            self._set_from_file(variables, overwrite, path)
        except:
            amsg = 'with arguments %s ' % utils.seq2str2(args) if args else ''
            raise DataError("Processing variable file '%s' %sfailed: %s"
                            % (path, amsg, utils.get_error_message()))
        return variables

    # This can be used with variables got from set_from_file directly to
    # prevent importing same file multiple times
    def _set_from_file(self, variables, overwrite, path):
        list_prefix = 'LIST__'
        for name, value in variables:
            if name.startswith(list_prefix):
                name = '@{%s}' % name[len(list_prefix):]
                try:
                    if isinstance(value, basestring):
                        raise TypeError
                    value = list(value)
                except TypeError:
                    raise DataError("List variable '%s' cannot get a non-list "
                                    "value '%s'" % (name, utils.unic(value)))
            else:
                name = '${%s}' % name
            if overwrite or not self.contains(name):
                self.set(name, value)

    def set_from_variable_table(self, variable_table, overwrite=False):
        for variable in variable_table:
            if not variable.has_data():
                continue
            try:
                name, value = self._get_var_table_name_and_value(
                    variable.name, variable.value, variable_table.source)
                if overwrite or not self.contains(name):
                    self.set(name, value)
            except DataError, err:
                variable_table.report_invalid_syntax("Setting variable '%s' failed: %s"
                                                     % (variable.name, unicode(err)))

    def _get_var_table_name_and_value(self, name, value, path=None):
        self._validate_var_name(name)
        value = [self._unescape_leading_trailing_spaces(cell) for cell in value]
        if name[0] == '@':
            return name, self.replace_list(value)
        return name, self._get_var_table_scalar_value(name, value, path)

    def _unescape_leading_trailing_spaces(self, item):
        if item.endswith(' \\'):
            item = item[:-1]
        if item.startswith('\\ '):
            item = item[1:]
        return item

    def _get_var_table_scalar_value(self, name, value, path=None):
        if len(value) == 1:
            return self.replace_scalar(value[0])
        msg = ("Creating a scalar variable with a list value in the Variable "
               "table is deprecated and this functionality will be removed in "
               "Robot Framework 2.7. Create a list variable '@%s' and use "
               "it as a scalar variable '%s' instead" % (name[1:], name))
        if path:
            msg += " in file '%s'" % path
        LOGGER.warn(msg + '.')
        return self.replace_list(value)

    def _get_variables_from_var_file(self, var_file, args):
        variables = self._get_dynamical_variables(var_file, args or ())
        if variables is not None:
            return variables
        names = self._get_static_variable_names(var_file)
        return self._get_static_variables(var_file, names)

    def _get_dynamical_variables(self, var_file, args):
        get_variables = getattr(var_file, 'get_variables', None)
        if not get_variables:
            get_variables = getattr(var_file, 'getVariables', None)
        if not get_variables:
            return None
        variables = get_variables(*args)
        if isinstance(variables, (dict, UserDict)):
            return variables.items()
        if isinstance(variables, Map):
            return [(entry.key, entry.value) for entry in variables.entrySet()]
        raise DataError("Expected mapping but %s returned %s."
                         % (get_variables.__name__, type(variables).__name__))

    def _get_static_variable_names(self, var_file):
        names = [attr for attr in dir(var_file) if not attr.startswith('_')]
        if hasattr(var_file, '__all__'):
            names = [name for name in names if name in var_file.__all__]
        return names

    def _get_static_variables(self, var_file, names):
        variables = [(name, getattr(var_file, name)) for name in names]
        if not inspect.ismodule(var_file):
            variables = [var for var in variables if not callable(var[1])]
        return variables

    def has_key(self, variable):
        try:
            self[variable]
        except DataError:
            return False
        else:
            return True

    __contains__ = has_key

    def contains(self, variable, extended=False):
        if extended:
            return self.has_key(variable)
        return utils.NormalizedDict.has_key(self, variable)

########NEW FILE########
__FILENAME__ = variablesplitter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class VariableSplitter:

    def __init__(self, string, identifiers):
        self.identifier = None
        self.base = None
        self.index = None
        self.start = -1
        self.end = -1
        self._identifiers = identifiers
        self._may_have_internal_variables = False
        try:
            self._split(string)
        except ValueError:
            pass
        else:
            self._finalize()

    def get_replaced_base(self, variables):
        if self._may_have_internal_variables:
            return variables.replace_string(self.base)
        return self.base

    def _finalize(self):
        self.identifier = self._variable_chars[0]
        self.base = ''.join(self._variable_chars[2:-1])
        self.end = self.start + len(self._variable_chars)
        if self._has_list_variable_index():
            self.index = ''.join(self._list_variable_index_chars[1:-1])
            self.end += len(self._list_variable_index_chars)

    def _has_list_variable_index(self):
        return self._list_variable_index_chars \
            and self._list_variable_index_chars[-1] == ']'

    def _split(self, string):
        start_index, max_index = self._find_variable(string)
        self.start = start_index
        self._open_curly = 1
        self._state = self._variable_state
        self._variable_chars = [string[start_index], '{']
        self._list_variable_index_chars = []
        self._string = string
        start_index += 2
        for index, char in enumerate(string[start_index:]):
            index += start_index  # Giving start to enumerate only in Py 2.6+
            try:
                self._state(char, index)
            except StopIteration:
                return
            if index  == max_index and not self._scanning_list_variable_index():
                return

    def _scanning_list_variable_index(self):
        return self._state in [self._waiting_list_variable_index_state,
                               self._list_variable_index_state]

    def _find_variable(self, string):
        max_end_index = string.rfind('}')
        if max_end_index == -1:
            return ValueError('No variable end found')
        if self._is_escaped(string, max_end_index):
            return self._find_variable(string[:max_end_index])
        start_index = self._find_start_index(string, 1, max_end_index)
        if start_index == -1:
            return ValueError('No variable start found')
        return start_index, max_end_index

    def _find_start_index(self, string, start, end):
        index = string.find('{', start, end) - 1
        if index < 0:
            return -1
        if self._start_index_is_ok(string, index):
            return index
        return self._find_start_index(string, index+2, end)

    def _start_index_is_ok(self, string, index):
        return string[index] in self._identifiers \
            and not self._is_escaped(string, index)

    def _is_escaped(self, string, index):
        escaped = False
        while index > 0 and string[index-1] == '\\':
            index -= 1
            escaped = not escaped
        return escaped

    def _variable_state(self, char, index):
        self._variable_chars.append(char)
        if char == '}' and not self._is_escaped(self._string, index):
            self._open_curly -= 1
            if self._open_curly == 0:
                if not self._is_list_variable():
                    raise StopIteration
                self._state = self._waiting_list_variable_index_state
        elif char in self._identifiers:
            self._state = self._internal_variable_start_state

    def _is_list_variable(self):
        return self._variable_chars[0] == '@'

    def _internal_variable_start_state(self, char, index):
        self._state = self._variable_state
        if char == '{':
            self._variable_chars.append(char)
            self._open_curly += 1
            self._may_have_internal_variables = True
        else:
            self._variable_state(char, index)

    def _waiting_list_variable_index_state(self, char, index):
        if char != '[':
            raise StopIteration
        self._list_variable_index_chars.append(char)
        self._state = self._list_variable_index_state

    def _list_variable_index_state(self, char, index):
        self._list_variable_index_chars.append(char)
        if char == ']':
            raise StopIteration

########NEW FILE########
__FILENAME__ = version
# Automatically generated by 'package.py' script.

import sys

VERSION = '2.7.6'
RELEASE = 'final'
TIMESTAMP = '20130107-160853'

def get_version(sep=' '):
    if RELEASE == 'final':
        return VERSION
    return VERSION + sep + RELEASE

def get_full_version(who=''):
    sys_version = sys.version.split()[0]
    version = '%s %s (%s %s on %s)' \
        % (who, get_version(), _get_interpreter(), sys_version, sys.platform)
    return version.strip()

def _get_interpreter():
    if sys.platform.startswith('java'):
        return 'Jython'
    if sys.platform == 'cli':
        return 'IronPython'
    if 'PyPy' in sys.version:
        return 'PyPy'
    return 'Python'

########NEW FILE########
__FILENAME__ = aligners
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from .dataextractor import DataExtractor


class _Aligner(object):

    def __init__(self, widths=None):
        self._widths = widths or []

    def align_rows(self, rows):
        return [self.align_row(r) for r in rows]

    def align_row(self, row):
        for index, col in enumerate(row):
            if len(self._widths) <= index:
                break
            row[index] = row[index].ljust(self._widths[index])
        return row


class FirstColumnAligner(_Aligner):

    def __init__(self, first_column_width):
        _Aligner.__init__(self, [first_column_width])


class ColumnAligner(_Aligner):

    def __init__(self, first_column_width, table):
        _Aligner.__init__(self, self._count_widths(first_column_width, table))

    def _count_widths(self, first_column_width, table):
        result = [first_column_width] + [len(h) for h in table.header[1:]]
        for row in DataExtractor().rows_from_table(table):
            for index, col in enumerate(row[1:]):
                index += 1
                if len(result) <= index:
                    result.append(len(col))
                else:
                    result[index] = max(len(col), result[index])
        return result


class NullAligner(_Aligner):

    def align_rows(self, rows):
        return rows

    def align_row(self, row):
        return row

########NEW FILE########
__FILENAME__ = dataextractor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class DataExtractor(object):
    """Transforms table of a parsed test data file into a list of rows."""

    def __init__(self, want_name_on_first_row=None):
        self._want_name_on_first_row = want_name_on_first_row or \
                                       (lambda t,n: False)

    def rows_from_table(self, table):
        if table.type in ['setting', 'variable']:
            return self._rows_from_item(table)
        return self._rows_from_indented_table(table)

    def _rows_from_indented_table(self, table):
        items = list(table)
        for index, item in enumerate(items):
            for row in self._rows_from_test_or_keyword(item, table):
                yield row
            if not self._last(items, index):
                yield []

    def _rows_from_test_or_keyword(self, test_or_keyword, table):
        rows = list(self._rows_from_item(test_or_keyword, 1))
        for r in self._add_name(test_or_keyword.name, rows, table):
            yield r

    def _add_name(self, name, rows, table):
        if rows and self._want_name_on_first_row(table, name):
            rows[0][0] = name
            return rows
        return [[name]] + rows

    def _rows_from_item(self, item, indent=0):
        for child in item:
            if child.is_set():
                yield [''] * indent + child.as_list()
            if child.is_for_loop():
                for row in self._rows_from_item(child, indent+1):
                    yield row

    def _last(self, items, index):
        return index >= len(items) -1

########NEW FILE########
__FILENAME__ = datafilewriter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os

from robot.errors import DataError

from .filewriters import FileWriter


class DataFileWriter(object):
    """Object to write parsed test data file objects back to disk."""

    def __init__(self, **options):
        """
        :param `**options`: A :class:`.WritingContext` is created based
            on these.
        """
        self._options = options

    def write(self, datafile):
        """Writes given `datafile` using `**options`.

        :param datafile: The parsed test data object to be written
        :type datafile: :py:class:`~robot.parsing.model.TestCaseFile`,
            :py:class:`~robot.parsing.model.ResourceFile`,
            :py:class:`~robot.parsing.model.TestDataDirectory`
        """
        with WritingContext(datafile, **self._options) as ctx:
            FileWriter(ctx).write(datafile)


class WritingContext(object):
    """Contains configuration used in writing a test data file to disk."""
    encoding = 'UTF-8'
    txt_format = 'txt'
    html_format = 'html'
    tsv_format = 'tsv'
    robot_format = 'robot'
    txt_column_count = 8
    html_column_count = 5
    tsv_column_count = 8
    _formats = [txt_format, html_format, tsv_format, robot_format]

    def __init__(self, datafile, format='', output=None, pipe_separated=False,
                 txt_separating_spaces=4, line_separator=os.linesep):
        """
        :param datafile: The datafile to be written.
        :type datafile: :py:class:`~robot.parsing.model.TestCaseFile`,
            :py:class:`~robot.parsing.model.ResourceFile`,
            :py:class:`~robot.parsing.model.TestDataDirectory`
        :param str format: Output file format. If omitted, read from the
            extension of the `source` attribute of the given `datafile`.
        :param output: An open, file-like object used in writing. If
            omitted, value of `source` attribute of the given `datafile` is
            used to construct a new file object.
        :param bool pipe_separated: Whether to use pipes as separator when
            output file format is txt.
        :param int txt_separating_spaces: Number of separating spaces between
            cells in space separated format.
        :param str line_separator: Line separator used in output files.

        If `output` is not given, an output file is created based on the source
        of the given datafile and value of `format`. Examples:

        Write output in a StringIO instance using format of `datafile.source`::

            WriteConfiguration(datafile, output=StringIO)

        Output file is created from `datafile.source` by stripping extension
        and replacing it with `html`::

            WriteConfiguration(datafile, format='html')
        """
        self.datafile = datafile
        self.pipe_separated = pipe_separated
        self.line_separator = line_separator
        self._given_output = output
        self.format = self._validate_format(format) or self._format_from_file()
        self.txt_separating_spaces = txt_separating_spaces
        self.output = output

    def __enter__(self):
        if not self.output:
            self.output = open(self._output_path(), 'wb')
        return self

    def __exit__(self, *exc_info):
        if self._given_output is None:
            self.output.close()

    def _validate_format(self, format):
        format = format.lower() if format else ''
        if format and format not in self._formats:
            raise DataError('Invalid format: %s' % format)
        return format

    def _format_from_file(self):
        return self._format_from_extension(self._source_from_file())

    def _format_from_extension(self, path):
        return os.path.splitext(path)[1][1:].lower()

    def _output_path(self):
        return '%s.%s' % (self._base_name(), self.format)

    def _base_name(self):
        return os.path.splitext(self._source_from_file())[0]

    def _source_from_file(self):
        return getattr(self.datafile, 'initfile', self.datafile.source)

########NEW FILE########
__FILENAME__ = filewriters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

try:
    import csv
except ImportError:
    # csv module is missing from IronPython < 2.7.1
    csv = None

from robot import utils

from .formatters import TsvFormatter, TxtFormatter, PipeFormatter
from .htmlformatter import HtmlFormatter
from .htmltemplate import TEMPLATE_START, TEMPLATE_END


def FileWriter(context):
    """Creates and returns a FileWriter object.

    :param context: Type of returned FileWriter is determined based on
        `context.format`. `context` is also passed to created writer.
    :type context: :py:class:`WritingContext`
    """
    if context.format == context.html_format:
        return HtmlFileWriter(context)
    if context.format == context.tsv_format:
        return TsvFileWriter(context)
    if context.pipe_separated:
        return PipeSeparatedTxtWriter(context)
    return SpaceSeparatedTxtWriter(context)


class _DataFileWriter(object):

    def __init__(self, formatter, configuration):
        self._formatter = formatter
        self._output = configuration.output
        self._line_separator = configuration.line_separator
        self._encoding = configuration.encoding

    def write(self, datafile):
        tables = [table for table in datafile if table]
        for table in tables:
            self._write_table(table, is_last=table is tables[-1])

    def _write_table(self, table, is_last):
        self._write_header(table)
        self._write_rows(self._formatter.format_table(table))
        if not is_last:
            self._write_empty_row(table)

    def _write_header(self, table):
        self._write_row(self._formatter.format_header(table))

    def _write_rows(self, rows):
        for row in rows:
            self._write_row(row)

    def _write_empty_row(self, table):
        self._write_row(self._formatter.empty_row_after(table))

    def _encode(self, row):
        return row.encode(self._encoding)

    def _write_row(self, row):
        raise NotImplementedError


class SpaceSeparatedTxtWriter(_DataFileWriter):

    def __init__(self, configuration):
        formatter = TxtFormatter(configuration.txt_column_count)
        self._separator = ' ' * configuration.txt_separating_spaces
        _DataFileWriter.__init__(self, formatter, configuration)

    def _write_row(self, row):
        line = self._separator.join(row).rstrip() + self._line_separator
        self._output.write(self._encode(line))


class PipeSeparatedTxtWriter(_DataFileWriter):
    _separator = ' | '

    def __init__(self, configuration):
        formatter = PipeFormatter(configuration.txt_column_count)
        _DataFileWriter.__init__(self, formatter, configuration)

    def _write_row(self, row):
        row = self._separator.join(row)
        if row:
            row = '| ' + row + ' |'
        self._output.write(self._encode(row + self._line_separator))


class TsvFileWriter(_DataFileWriter):

    def __init__(self, configuration):
        if not csv:
            raise RuntimeError('No csv module found. '
                               'Writing tab separated format is not possible.')
        formatter = TsvFormatter(configuration.tsv_column_count)
        _DataFileWriter.__init__(self, formatter, configuration)
        self._writer = self._get_writer(configuration)

    def _get_writer(self, configuration):
        # Custom dialect needed as a workaround for
        # http://ironpython.codeplex.com/workitem/33627
        dialect = csv.excel_tab()
        dialect.lineterminator = configuration.line_separator
        return csv.writer(configuration.output, dialect=dialect)

    def _write_row(self, row):
        self._writer.writerow([self._encode(c) for c in row])


class HtmlFileWriter(_DataFileWriter):

    def __init__(self, configuration):
        formatter = HtmlFormatter(configuration.html_column_count)
        _DataFileWriter.__init__(self, formatter, configuration)
        self._name = configuration.datafile.name
        self._writer = utils.HtmlWriter(configuration.output,
                                        configuration.line_separator,
                                        encoding=self._encoding)

    def write(self, datafile):
        self._writer.content(TEMPLATE_START % {'NAME': self._name},
                             escape=False)
        _DataFileWriter.write(self, datafile)
        self._writer.content(TEMPLATE_END, escape=False)

    def _write_table(self, table, is_last):
        self._writer.start('table', {'id': table.type.replace(' ', ''),
                                     'border': '1'})
        _DataFileWriter._write_table(self, table, is_last)
        self._writer.end('table')

    def _write_row(self, row):
        self._writer.start('tr')
        for cell in row:
            self._writer.element(cell.tag, cell.content, cell.attributes,
                                 escape=False)
        self._writer.end('tr')

########NEW FILE########
__FILENAME__ = formatters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from .aligners import FirstColumnAligner, ColumnAligner, NullAligner
from .dataextractor import DataExtractor
from .rowsplitter import RowSplitter


class _DataFileFormatter(object):
    _whitespace = re.compile('\s{2,}')
    _split_multiline_doc = True

    def __init__(self, column_count):
        self._splitter = RowSplitter(column_count, self._split_multiline_doc)
        self._column_count = column_count
        self._extractor = DataExtractor(self._want_names_on_first_content_row)

    def _want_names_on_first_content_row(self, table, name):
        return True

    def empty_row_after(self, table):
        return self._format_row([], table)

    def format_header(self, table):
        header = self._format_row(table.header)
        return self._format_header(header, table)

    def format_table(self, table):
        rows = self._extractor.rows_from_table(table)
        if self._should_split_rows(table):
            rows = self._split_rows(rows, table)
        return (self._format_row(r, table) for r in rows)

    def _should_split_rows(self, table):
        return not self._should_align_columns(table)

    def _split_rows(self, original_rows, table):
        for original in original_rows:
            for split in self._splitter.split(original, table.type):
                yield split

    def _should_align_columns(self, table):
        return self._is_indented_table(table) and bool(table.header[1:])

    def _is_indented_table(self, table):
        return table is not None and table.type in ['test case', 'keyword']

    def _escape_consecutive_whitespace(self, row):
        return [self._whitespace.sub(self._whitespace_escaper,
                                     cell.replace('\n', ' ')) for cell in row]

    def _whitespace_escaper(self, match):
        return '\\'.join(match.group(0))

    def _format_row(self, row, table=None):
        raise NotImplementedError

    def _format_header(self, header, table):
        raise NotImplementedError


class TsvFormatter(_DataFileFormatter):

    def _format_header(self, header, table):
        return [self._format_header_cell(cell) for cell in header]

    def _format_header_cell(self, cell):
        return '*%s*' % cell if cell else ''

    def _format_row(self, row, table=None):
        return self._pad(self._escape(row))

    def _escape(self, row):
        return self._escape_consecutive_whitespace(self._escape_tabs(row))

    def _escape_tabs(self, row):
        return [c.replace('\t', '\\t') for c in row]

    def _pad(self, row):
        row = [cell.replace('\n', ' ') for cell in row]
        return row + [''] * (self._column_count - len(row))


class TxtFormatter(_DataFileFormatter):
    _test_or_keyword_name_width = 18
    _setting_and_variable_name_width = 14

    def _format_row(self, row, table=None):
        row = self._escape(row)
        aligner = self._aligner_for(table)
        return aligner.align_row(row)

    def _aligner_for(self, table):
        if table and table.type in ['setting', 'variable']:
            return FirstColumnAligner(self._setting_and_variable_name_width)
        if self._should_align_columns(table):
            return ColumnAligner(self._test_or_keyword_name_width, table)
        return NullAligner()

    def _format_header(self, header, table):
        header = ['*** %s ***' % header[0]] + header[1:]
        aligner = self._aligner_for(table)
        return aligner.align_row(header)

    def _want_names_on_first_content_row(self, table, name):
        return self._should_align_columns(table) and \
                len(name) <= self._test_or_keyword_name_width

    def _escape(self, row):
        if not row:
            return row
        return self._escape_cells(self._escape_consecutive_whitespace(row))

    def _escape_cells(self, row):
        return [row[0]] + [self._escape_empty(cell) for cell in row[1:]]

    def _escape_empty(self, cell):
        return cell or '\\'


class PipeFormatter(TxtFormatter):

    def _escape_cells(self, row):
        return [self._escape_empty(self._escape_pipes(cell)) for cell in row]

    def _escape_empty(self, cell):
        return cell or '  '

    def _escape_pipes(self, cell):
        if ' | ' in cell:
            cell = cell.replace(' | ', ' \\| ')
        if cell.startswith('| '):
            cell = '\\' + cell
        if cell.endswith(' |'):
            cell = cell[:-1] + '\\|'
        return cell

########NEW FILE########
__FILENAME__ = htmlformatter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robot import utils

from .formatters import _DataFileFormatter


class HtmlFormatter(_DataFileFormatter):
    _split_multiline_doc = False

    def _format_row(self, row, table=None):
        row = self._pad(self._escape_consecutive_whitespace(row), table)
        if self._is_documentation_row(row):
            return self._create_documentation_row(row)
        first_cell = self._create_first_cell(row[0], table)
        if self._is_indented_documentation_row(row[1:], table):
            return self._create_indented_documentation_row(first_cell, row[1:])
        return [first_cell] + [HtmlCell(c) for c in row[1:]]

    def _is_documentation_row(self, row):
        return row[0] == 'Documentation'

    def _create_documentation_row(self, row):
        return [NameCell(row[0]), DocumentationCell(row[1], span=self._column_count-1)]

    def _is_indented_documentation_row(self, cells, table):
        return self._is_indented_table(table) and cells and \
                    cells[0] == '[Documentation]'

    def _create_indented_documentation_row(self, first_cell, cells):
        start = [first_cell, HtmlCell(cells[0])]
        if any(c.startswith('#') for c in cells):
            return start + [HtmlCell(c) for c in cells[1:]]
        return start + [DocumentationCell(cells[1], self._column_count-2)]

    def _create_first_cell(self, cell, table):
        if self._is_indented_table(table) and cell:
            return AnchorNameCell(cell, 'keyword' if table.type == 'keyword'
                                                  else 'test')
        return NameCell(cell)

    def format_header(self, table):
        if not self._should_align_columns(table) or len(table.header) == 1:
            return [HeaderCell(table.header[0], self._column_count)]
        headers = self._pad_header(table)
        return [HeaderCell(hdr) for hdr in headers]

    def _pad_header(self, table):
        header = table.header
        return header + [''] * (self._get_column_count(table) - len(header))

    def _pad(self, row, table):
        return row + [''] * (self._get_column_count(table) - len(row))

    def _get_column_count(self, table):
        if table is None or len(table.header) == 1 \
                or not self._is_indented_table(table):
            return self._column_count
        return max(self._max_column_count(table), len(table.header))

    def _max_column_count(self, table):
        count = 0
        for item in table:
            for child in item:
                count = max(count, len(child.as_list()) + 1)
        return count


class HtmlCell(object):
    _backslash_matcher = re.compile(r'(\\+)n ?')

    def __init__(self, content='', attributes=None, tag='td', escape=True):
        if escape:
            content = utils.html_escape(content)
        self.content = self._replace_newlines(content)
        self.attributes = attributes or {}
        self.tag = tag

    def _replace_newlines(self, content):
        def replacer(match):
            backslash_count = len(match.group(1))
            if backslash_count % 2 == 1:
                return '%sn<br>\n' % match.group(1)
            return match.group()
        return self._backslash_matcher.sub(replacer, content)


class NameCell(HtmlCell):

    def __init__(self, name='', attributes=None):
        HtmlCell.__init__(self, name, {'class': 'name'})


class AnchorNameCell(HtmlCell):

    def __init__(self, name, type_):
        HtmlCell.__init__(self, self._link_from_name(name, type_),
                          {'class': 'name'}, escape=False)

    def _link_from_name(self, name, type_):
        return '<a name="%s_%s">%s</a>' % (type_, utils.html_attr_escape(name),
                                           utils.html_escape(name))


class DocumentationCell(HtmlCell):

    def __init__(self, content, span):
        HtmlCell.__init__(self, content, {'class': 'colspan%d' % span,
                                          'colspan': '%d' % span})


class HeaderCell(HtmlCell):

    def __init__(self, name, span=1):
        HtmlCell.__init__(self, name, {'class': 'name', 'colspan': '%d' % span},
                          tag='th')

########NEW FILE########
__FILENAME__ = htmltemplate
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

TEMPLATE_START = """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
html {
  font-family: Arial,Helvetica,sans-serif;
  background-color: white;
  color: black;
}
table {
  border-collapse: collapse;
  empty-cells: show;
  margin: 1em 0em;
  border: 1px solid black;
}
th, td {
  border: 1px solid black;
  padding: 0.1em 0.2em;
  height: 1.5em;
  width: 12em;
}
td.colspan4, th.colspan4 {
    width: 48em;
}
td.colspan3, th.colspan3 {
    width: 36em;
}
td.colspan2, th.colspan2 {
    width: 24em;
}
th {
  background-color: rgb(192, 192, 192);
  color: black;
  height: 1.7em;
  font-weight: bold;
  text-align: center;
  letter-spacing: 0.1em;
}
td.name {
  background-color: rgb(240, 240, 240);
  letter-spacing: 0.1em;
}
td.name, th.name {
  width: 10em;
}
</style>
<title>%(NAME)s</title>
</head>
<body>
<h1>%(NAME)s</h1>
"""
TEMPLATE_END = """</body>
</html>
"""

########NEW FILE########
__FILENAME__ = rowsplitter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import itertools


class RowSplitter(object):
    _comment_mark = '#'
    _empty_cell_escape = '${EMPTY}'
    _line_continuation = '...'
    _setting_table = 'setting'
    _tc_table = 'test case'
    _kw_table = 'keyword'

    def __init__(self, cols=8, split_multiline_doc=True):
        self._cols = cols
        self._split_multiline_doc = split_multiline_doc

    def split(self, row, table_type):
        if not row:
            return self._split_empty_row()
        indent = self._get_indent(row, table_type)
        if self._split_multiline_doc and self._is_doc_row(row, table_type):
            return self._split_doc_row(row, indent)
        return self._split_row(row, indent)

    def _split_empty_row(self):
        yield []

    def _get_indent(self, row, table_type):
        indent = len(list(itertools.takewhile(lambda x: x == '', row)))
        min_indent = 1 if table_type in [self._tc_table, self._kw_table] else 0
        return max(indent, min_indent)

    def _is_doc_row(self, row, table_type):
        if table_type == self._setting_table:
            return len(row) > 1 and row[0] == 'Documentation'
        if table_type in [self._tc_table, self._kw_table]:
            return len(row) > 2 and row[1] == '[Documentation]'
        return False

    def _split_doc_row(self, row, indent):
        first, rest = self._split_doc(row[indent+1])
        yield row[:indent+1] + [first] + row[indent+2:]
        while rest:
            current, rest = self._split_doc(rest)
            current = [self._line_continuation, current] if current else [self._line_continuation]
            yield self._indent(current, indent)

    def _split_doc(self, doc):
        if '\\n' not in doc:
            return doc, ''
        if '\\n ' in doc:
            doc = doc.replace('\\n ', '\\n')
        return doc.split('\\n', 1)

    def _split_row(self, row, indent):
        while row:
            current, row = self._split(row)
            yield self._escape_last_empty_cell(current)
            if row and indent + 1 < self._cols:
                row = self._indent(row, indent)

    def _split(self, data):
        row, rest = data[:self._cols], data[self._cols:]
        self._in_comment = any(c.startswith(self._comment_mark) for c in row)
        rest = self._add_line_continuation(rest)
        return row, rest

    def _add_line_continuation(self, data):
        if data:
            if self._in_comment and not data[0].startswith(self._comment_mark):
                data[0] = self._comment_mark + data[0]
            data = [self._line_continuation] + data
        return data

    def _escape_last_empty_cell(self, row):
        if not row[-1].strip():
            row[-1] = self._empty_cell_escape
        return row

    def _indent(self, row, indent):
        return [''] * indent + row

########NEW FILE########
__FILENAME__ = pavement
import sys
import os
from os.path import join, isdir, isfile
import csv
import re
import shutil
import tempfile
from urllib2 import urlopen
from string import Template
from StringIO import StringIO
import urllib2
from paver.easy import *
from paver.setuputils import setup, find_package_data


ROOT_DIR = path(__file__).dirname()
SOURCE_DIR = ROOT_DIR/'src'
TEST_DIR = ROOT_DIR/'utest'
DIST_DIR = ROOT_DIR/'dist'
BUILD_DIR = ROOT_DIR/'build'
ROBOTIDE_PACKAGE = ROOT_DIR/'src'/'robotide'
LIB_TARGET = ROBOTIDE_PACKAGE/'lib'
LIB_SOURCE = ROOT_DIR/'lib'
MANIFEST = ROOT_DIR/'MANIFEST.in'

VERSION = open(ROOT_DIR/'VERSION.txt').read().strip()
FINAL_RELEASE = bool(re.match('^(\d*\.){1,2}\d*$', VERSION))

TEST_PROJECT_DIR = 'theproject'
TEST_LIBS_GENERATED = 10

def find_packages(where):
    def is_package(path):
        return isdir(path) and isfile(join(path ,'__init__.py'))
    pkgs = []
    for dirpath, dirs, _ in os.walk(where):
        for dirname in dirs:
            pkg_path = join(dirpath, dirname)
            if is_package(pkg_path):
                pkgs.append('.'.join((pkg_path.split(os.sep)[1:])))
    return pkgs


setup(name         = 'robotframework-ride',
      version      = VERSION,
      description  = 'RIDE :: Robot Framework Test Data Editor',
      long_description ="""
Robot Framework is a generic test automation framework for acceptance
level testing. RIDE is a lightweight and intuitive editor for Robot
Framework test data.
          """.strip(),
      license      = 'Apache License 2.0',
      keywords     = 'robotframework testing testautomation',
      platforms    = 'any',
      classifiers  = """
Development Status :: 5 - Production/Stable
License :: OSI Approved :: Apache Software License
Operating System :: OS Independent
Programming Language :: Python
Topic :: Software Development :: Testing
          """.strip().splitlines(),
      author       = 'Robot Framework Developers',
      author_email = 'robotframework-devel@googlegroups,com',
      url          = 'https://github.com/robotframework/RIDE/',
      download_url = 'https://github.com/robotframework/RIDE/downloads/',
      package_dir  = {'' : str(SOURCE_DIR)},
      packages     = find_packages(str(SOURCE_DIR)) + \
                        ['robotide.lib.%s' % str(name) for name
                         in find_packages(str(LIB_SOURCE))],
      package_data = find_package_data(str(SOURCE_DIR)),
      # Robot Framework package data is not included, but RIDE does not need it.
      # # Always install everything, since we may be switching between versions
      options      = { 'install': { 'force' : True } },
      scripts      = ['src/bin/ride.py', 'ride_postinstall.py'],
      install_requires = ['Pygments']
      )

@task
@consume_args
def run(args):
    """Start development version of RIDE"""
    _set_development_path()
    from robotide import main
    main(*args)

@task
@consume_args
def test(args):
    """Run unit tests (requires nose and mock)"""
    _remove_bytecode_files()
    assert _run_nose(args) is True

options(
    generate_big_project = Bunch(
        dir = "theproject",
        libs = 5,
        keywords=10,
        suites = 1,
        tests=10,
        resourcefiles=1,
        resources=30,
        testdepth=3,
        validity=1,
        upgrade=False
    )
)
@task
@consume_args
@no_help
def generate_big_project(args):
    _remove_bytecode_files()
    if "--upgrade" in args or '--install' in args:
        rfgen_url = "https://raw.github.com/robotframework/Generator/master/rfgen.py"
        print "Installing/upgrading rfgen.py from github."
        f = open('rfgen.py','wb')
        f.write(urllib2.urlopen(rfgen_url).read())
        f.close()
        print "Done."
        sys.exit(0)

    _set_development_path()
    sys.path.insert(0, '.')

    try:
        from rfgen import main
        assert main(args)
    except ImportError:
        print "Error: Did not find 'rfgen' script or installation"
        print "Use 'paver generate_big_project --install'"
        sys.exit(0)


@task
def random_test():
    """Use rtest go_find_bugs.py to randomly test RIDE api"""
    _remove_bytecode_files()
    _set_development_path()
    sys.path.insert(0, '.')
    from rtest.go_find_some_bugs import main
    dir = tempfile.mkdtemp()
    try:
        assert main(dir)
    finally:
        shutil.rmtree(dir, ignore_errors=True)

@task
def test_parallel():
    """Run tests with --processes 4"""
    _remove_bytecode_files()
    excluded_packages = ['^ui', '^settings', '^editor']
    excluded_files = [os.path.join('utest', 'controller', 'test_resource_import'),
                      os.path.join('utest', 'controller', 'test_filecontrollers'),
                      os.path.join('utest', 'plugin', 'test_plugin_settings')]
    args = ['--processes', '4']
    for name in excluded_packages + excluded_files:
        args.extend(['--exclude', os.path.basename(name)])
    success = _run_nose(args)
    args = ['--tests']
    for pkg in excluded_packages:
        args.append(os.path.join('utest', pkg[1:]))
    args.extend(['%s.py' % name for name in excluded_files])
    assert _run_nose(args) and success is True

@task
@needs('_prepare_build', 'setuptools.command.install')
def install():
    """Installs development version and dependencies"""
    try:
        import wxversion
    except ImportError:
        print "No wxPython installation detected!"
        print ""
        print "Please ensure that you have wxPython installed before running RIDE."
        print "You can obtain wxPython 2.8.12.1 from http://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/"

@task
@needs('_prepare_build', 'setuptools.command.register')
def register():
    """Register current version to Python package index"""
    pass

@task
@consume_args
def set_version(args):
    with open('VERSION.txt', 'w') as version_file:
        version_file.write(args[0])

@task
@needs('clean', '_prepare_build', '_release_notes', 'generate_setup', 'minilib',
       'setuptools.command.sdist')
def sdist():
    """Creates source distribution with bundled dependencies"""
    _after_distribution()

@task
@needs('_windows', 'clean', '_prepare_build',
       'setuptools.command.bdist_wininst')
def wininst():
    """Creates Windows installer with bundled dependencies"""
    _after_distribution()

@task
def _windows():
    if os.sep != '\\':
        sys.exit('Windows installers may only be created in Windows')

@task
def _prepare_build():
    _update_version()
    if not LIB_TARGET.exists():
        LIB_SOURCE.copytree(LIB_TARGET)

@task
def _release_notes():
    if FINAL_RELEASE:
        changes = _download_and_format_issues()
        _update_release_notes_plugin(changes)

@task
def clean():
    _clean()

def _clean(keep_dist=False):
    if not keep_dist and DIST_DIR.exists():
        DIST_DIR.rmtree()
    if BUILD_DIR.exists():
        BUILD_DIR.rmtree()
    if LIB_TARGET.exists():
        LIB_TARGET.rmtree()
    for name in 'paver-minilib.zip', 'setup.py':
        p = path(name)
        if p.exists():
            p.remove()

def _remove_bytecode_files():
    for d in LIB_SOURCE, SOURCE_DIR, TEST_DIR:
        for pyc in d.walkfiles(pattern='*.pyc'):
            os.remove(pyc)
        for clazz in d.walkfiles(pattern='*$py.class'):
            os.remove(clazz)

def _run_nose(args):
    from nose import run as noserun
    _set_development_path()
    return noserun(defaultTest=TEST_DIR,
                   argv=['', '--m=^test_'] + args)

def _update_version():
    _log('Using version %s from VERSION.txt' % VERSION)
    with (path(ROBOTIDE_PACKAGE)/'version.py').open('w') as version_file:
        version_file.write("""# Automatically generated by `pavement.py`.
VERSION = '%s'
""" % VERSION)

def _set_development_path():
    sys.path.insert(0, LIB_SOURCE)
    sys.path.insert(0, SOURCE_DIR)

def _after_distribution():
    _announce()
    _clean(keep_dist=True)

def _download_and_format_issues():
    try:
        from robot.utils import HtmlWriter, html_format
    except ImportError:
        sys.exit('creating release requires Robot Framework to be installed.')
    URL = Template('http://code.google.com/p/robotframework-ride/issues/csv?'
                   'sort=priority+type&colspec=ID%20Type%20Priority%20Summary'
                   '&q=target%3A${version}&can=1')
    reader = csv.reader(urlopen(URL.substitute({'version': VERSION})))
    total_issues = 0
    writer = HtmlWriter(StringIO())
    writer.element('h2', 'Release notes for %s' % VERSION)
    writer.start('table', attrs={'border': '1'})
    for row in reader:
        if not row or row[1] == 'Task':
            continue
        row = row[:4]
        writer.start('tr')
        if reader.line_num == 1:
            row = [ '*%s*' % cell for cell in row ]
        else:
            row[0] = '<a href="http://code.google.com/p/robotframework-ride/'\
                     'issues/detail?id=%s">Issue %s</a>' % (row[0], row[0])
            total_issues += 1
        for cell in row:
            if reader.line_num == 1:
                cell = html_format(cell)
            writer.element('td', cell, escape=False)
        writer.end('tr')
    writer.end('table')
    writer.element('p', 'Altogether %d issues.' % total_issues)
    return writer.output.getvalue()

def _update_release_notes_plugin(changes):
    plugin_path = os.path.join(ROBOTIDE_PACKAGE, 'application', 'releasenotes.py')
    content = open(plugin_path).read().rsplit('RELEASE_NOTES =', 1)[0]
    content += 'RELEASE_NOTES = """\n%s"""\n' % changes
    open(plugin_path, 'w').write(content)

def _announce():
    _log('Created:')
    for path in os.listdir(DIST_DIR):
        _log(os.path.abspath(os.path.join(DIST_DIR, path)))

def _log(msg):
    print msg

########NEW FILE########
__FILENAME__ = ride_postinstall
import sys
from os.path import exists, join
from Tkinter import Tk
from tkMessageBox import askyesno


def verify_install():
    try:
        import wxversion
    except ImportError:
        print "No wxPython installation detected!"
        print ""
        print "Please ensure that you have wxPython installed before running RIDE."
        print "You can obtain wxPython 2.8.12.1 from http://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/"
    else:
        print "Installation successful."


def create_desktop_shortcut():
    Tk().withdraw()
    link = join(get_special_folder_path("CSIDL_DESKTOPDIRECTORY"), 'RIDE.lnk')
    icon = join(sys.prefix, 'Lib', 'site-packages', 'robotide', 'widgets', 'robot.ico')
    if exists(link) or askyesno('Setup', 'Create desktop shortcut?'):
        create_shortcut('pythonw', "Robot Framework testdata editor", link,
                        '-c "from robotide import main; main()"', '', icon)
        file_created(link)


if sys.argv[1] == '-install':
    verify_install()
    create_desktop_shortcut()

########NEW FILE########
__FILENAME__ = go_find_some_bugs
#  Copyright 2008-2011 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from math import ceil
import os
import time
import sys
import traceback
from rtest import simplifier


ROOT = os.path.dirname(__file__)
lib = os.path.join(ROOT, '..', 'lib')
src = os.path.join(ROOT, '..', 'src')

sys.path.insert(0, lib)
sys.path.insert(0, src)


from test_runner import Runner


def do_test(seed, path):
    i = None
    try:
        ride_runner = init_ride_runner(seed, path)
        for i in range(10000):
            ride_runner.step()
        return 'PASS', seed, i, path
    except Exception:
        print '-'*80
        traceback.print_exc()
        print 'i = ', i
        print 'seed was', str(seed)
        print 'path was', path
        return 'FAIL', seed, i or 0, path

def init_ride_runner(seed, path):
    return Runner(seed, path, ROOT).initialize()

def split(start, end):
    return int(ceil(float(end - start) / 2)) + start

def skip_steps(runner, number_of_steps):
    for i in range(number_of_steps):
        runner.skip_step()

def debug(seed, path, last_index, trace, start, end):
    print '*'*80
    if last_index == start:
        return trace + [last_index]
    if end <= start:
        return debug(seed, path, last_index, trace + [end], end+1, last_index)
    runner = init_ride_runner(seed, path)
    if trace != []:
        run_trace(runner, trace)
    midpoint = split(start, end)
    runner.skip_steps(midpoint)
    try:
        for j in range(midpoint, last_index):
            runner.step()
        return debug(seed, path, last_index, trace, start, midpoint-1)
    except Exception, err:
        if runner.count == last_index:
            return debug(seed, path, last_index, trace, midpoint, end)
        else:
            print 'New exception during debugging!'
            return debug(seed, path, runner.count, trace, midpoint, runner.count)

def run_trace(runner, trace):
    i = 0
    while i < trace[-1]:
        if i in trace:
            runner.step()
        else:
            runner.skip_step()
        i += 1

def generate_seed():
    seed = long(time.time() * 256)
    if len(sys.argv) == 3:
        seed = long(sys.argv[2])
    return seed

def _debugging(seed, path, i):
    print '='*80
    trace = debug(seed, path, i, [], 0, i)
    print '#'*80
    print trace
    print '%'*80
    print 'seed = ', seed
    run_trace(init_ride_runner(seed, path), trace)

def main(path):
    result, seed, i, path = do_test(generate_seed(), path)
    #_debugging(seed, path, i)
    #???>>>!!! simplifier.simplify(range(i+1), init_ride_runner(seed, path))
    return result != 'FAIL'

if __name__ == '__main__':
    if not main(sys.argv[1]):
        print 'error occurred!'
        sys.exit(1) #indicate failure


########NEW FILE########
__FILENAME__ = model
#  Copyright 2008-2011 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License"self);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os
from robotide.controller.commands import AddTestCaseFile, AddTestCase, AddKeyword, AddVariable, ChangeCellValue, AddRow, DeleteRow, InsertCell, DeleteCell, MoveRowsUp, MoveRowsDown, ExtractKeyword, RenameKeywordOccurrences, RenameTest, Undo, Redo, SaveFile, NullObserver, MoveUp, MoveDown, AddLibrary, AddResource, DeleteItem, InsertArea
from robotide.namespace import Namespace
from robotide.controller.chiefcontroller import ChiefController
from robotide.preferences import RideSettings
from robotide.spec import librarydatabase


class RIDE(object):

    def __init__(self, random, path):
        print 'librarydatabase.initialize_database()'
        print librarydatabase.initialize_database()
        print 'settings = RideSettings()'
        print 'chief = ChiefController(Namespace(settings=settings), settings=settings)'
        settings = RideSettings()
        self._chief = ChiefController(Namespace(settings=settings), settings=settings)
        self._path = path
        self._suite = None
        self._test = None
        self._keyword = None
        self._random = random
        self._skip = False

    def _skip_until_notified(self):
        self._skip = True

    def _do_not_skip(self):
        self._skip = False

    def open_test_dir(self):
        if self._skip:
            return
        self._open(os.path.join(self._path, 'testdir'))
        print 'suite = chief.data.children[0]'
        self._suite = self._chief.data.children[0]
        print 'test = list(t for t in suite.tests)[0]'
        self._test = list(t for t in self._suite.tests)[0]
        print 'keyword = list(k for k in suite.keywords)[0]'
        self._keyword = list(k for k in self._suite.keywords)[0]

    def open_suite_file(self):
        if self._skip:
            return
        self._open(os.path.join(self._path, 'testdir', 'Suite.txt'))
        print 'suite = chief.data'
        self._suite = self._chief.data
        print 'test = list(t for t in suite.tests)[0]'
        self._test = list(t for t in self._suite.tests)[0]
        print 'keyword = list(k for k in suite.keywords)[0]'
        self._keyword = list(k for k in self._suite.keywords)[0]

    def _open_resource_file(self):
        self._open(os.path.join(self._path, 'testdir', 'resources', 'resu.txt'))
        self._suite = None
        self._test = None
        self._keyword = None

    def _open(self, path):
        print 'chief.load_data("%s", NullObserver())' % path
        self._chief.load_data(path, NullObserver())

    def _create_suite(self):
        filename = os.path.join(self._path,'path_to_foo%s.txt' % str(self._rand()))
        print 'suite = chief.data.execute(AddSuite(NewDatafile("%s")))' % filename
        self._suite = self._chief.data.execute(AddTestCaseFile(filename))

    def create_test(self):
        if self._skip:
            self._rand()
            return
        testname = 'foobar'+str(self._rand())
        print 'test = suite.execute(AddTestCase("%s"))' % testname
        self._test = self._suite.execute(AddTestCase(testname))

    def change_test_order(self):
        self._change_order([t.data for t in self._suite.tests], self._suite.tests)

    def _change_order(self, items, controller):
        command = MoveUp if self._rand() > 0.5 else MoveDown
        r = self._rand()
        if self._skip:
            return
        items = list(items)
        if items:
            i = int(r*(len(items)))
            print '%s.execute(%s(items[%d]))' % (controller.__class__.__name__, command.__name__, i)
            controller.execute(command(items[i]))

    def _rand(self):
        return self._random.random()

    def _rand_row(self):
        return self._random.randint(0,100)

    def _rand_col(self):
        return self._random.randint(0, 30)

    def create_keyword(self):
        if self._skip:
            self._rand()
            return
        keyword_name = 'kwFoobar'+str(self._rand())
        print 'keyword = suite.execute(AddKeyword("%s"))' % keyword_name
        self._keyword = self._suite.execute(AddKeyword(keyword_name))

    def change_keyword_order(self):
        pass

    def add_variable(self):
        if self._skip:
            self._rand()
            self._rand()
            return
        command = AddVariable('${var%s}' % str(self._rand()), str(self._rand()), 'comment')
        print 'suite.execute(%s)' % str(command)
        self._suite.execute(command)

    def change_variable_order(self):
        pass

    def write_cell_data(self):
        value = self._random.choice(['# something', 'foobar', ': FOR', '${var}', 'No Operation', '\\',
                                      'zoo%d' % self._rand(), '${%d}' % self._rand()])
        self._macro_execute(ChangeCellValue(self._rand_row(), self._rand_col(), value))

    def write_for_loop(self):
        self._macro_execute(InsertArea((self._rand_row(), 0),
                            [[':FOR', '${i}', 'IN', '1', '2', 'foo'], ['', 'No Operation']]))

    def _macro_execute(self, command):
        macro = self._random.choice([c for c in [self._test, self._keyword] if c])
        if not self._skip:
            print '%s.execute(%s)' % (self._name(macro), str(command))
            macro.execute(command)

    def _name(self, macro):
        if macro == self._test:
            return 'test'
        return 'keyword'

    def add_row(self):
        self._macro_execute(AddRow(self._rand_row()))

    def remove_row(self):
        self._macro_execute(DeleteRow(self._rand_row()))

    def add_cell(self):
        self._macro_execute(InsertCell(self._rand_row(), self._rand_col()))

    def remove_cell(self):
        self._macro_execute(DeleteCell(self._rand_row(), self._rand_col()))

    def move_row_up(self):
        self._macro_execute(MoveRowsUp([self._rand_row()]))

    def move_row_down(self):
        self._macro_execute(MoveRowsDown([self._rand_row()]))

    def extract_keyword(self):
        first_row = self._rand_row()
        self._macro_execute(ExtractKeyword('foo', '', [first_row, first_row+self._random.randint(1,10)]))

    def add_library_import(self):
        if not self._skip:
            print 'suite.imports.execute(AddLibrary(["OperatingSystem", "", ""], "#comment"))'
            self._suite.imports.execute(AddLibrary(['OperatingSystem', '', ''], '#comment'))

    def remove_import(self):
        r = self._rand()
        if self._skip:
            return
        imps = list(self._suite.imports)
        if imps:
            i = int(r*len(imps))
            print 'suite.imports.execute(DeleteItem(%d))' % i
            self._suite.imports.execute(DeleteItem(i))

    def add_resource_import(self):
        if not self._skip:
            print 'suite.imports.execute(AddResource(["SomeNonExisting.txt"], "#comment"))'
            self._suite.imports.execute(AddResource(['SomeNonExisting.txt'], '#comment'))

    def change_import_order(self):
        self._change_order(range(sum(1 for _ in self._suite.imports)), self._suite.imports)

    def rename_keyword(self):
        class Observer(object):
            def notify(self, *args):
                pass
            def finish(self, *args):
                pass
        self._macro_execute(RenameKeywordOccurrences('foo', 'bar', Observer()))

    def rename_test(self):
        if self._skip:
            self._rand()
            return
        self._test.execute(RenameTest('new_name%s' % str(self._rand())))

    def undo(self):
        self._macro_execute(Undo())

    def redo(self):
        self._macro_execute(Redo())

    def save(self):
        if self._skip:
            return
        command = SaveFile()
        print 'suite.execute(%s)' % str(command)
        self._suite.execute(command)

    def get_cell_info(self):
        macro = self._random.choice([c for c in [self._test, self._keyword] if c])
        row = self._rand_row()
        col = self._rand_col()
        if self._skip:
            return
        print '%s.get_cell_info(%s, %s)' % (self._name(macro), row, col)
        macro.get_cell_info(row, col)

########NEW FILE########
__FILENAME__ = simplifier

def simplify(trace, runner):
    try:
        return _simplify(1, trace, runner)
    except ResetSimplify, reset:
        return simplify(reset.trace, runner)

def _simplify(min_i, trace, runner):
    max_i = len(trace)
    if max_i == min_i:
        return trace
    step = (max_i-1)/min_i
    for start in range(0, max_i-1, step):
        new_trace = trace[:start]+trace[start+step:]
        if test_trace(new_trace, runner):
            return _simplify(min_i, new_trace, runner)
    return _simplify(min_i+1, trace, runner)

class ResetSimplify(Exception):

    def __init__(self, trace):
        Exception.__init__(self)
        self.trace = trace


def test_trace(trace, runner):
    print '>'*80
    print '! >>> %d' % len(trace)
    runner.initialize()
    try:
        run_trace(runner, trace)
        return False
    except Exception:
        if runner.count <= trace[-1]:
            raise ResetSimplify([i for i in trace if i < runner.count])
        return True

def run_trace(runner, trace):
    i = 0
    while trace:
        if i == trace[0]:
            runner.step()
            trace = trace[1:]
        else:
            runner.skip_step()
        i += 1

if __name__ == '__main__':
    import random

    class Runner(object):

        def __init__(self, data):
            self._original_data = data
            self._fails = data[-1]
            self._data = data[:-1]
            self.count = 0

        def initialize(self):
            self.__init__(self._original_data)

        def step(self):
            self.count += 1
            if (not self._data) and (not self._fails):
                return
            self._data.pop(0)

        def skip_step(self):
            self.count += 1
            d = self._data.pop(0)
            self._fails &= (not d)


    for z in range(10):
        test_data = [False for _ in xrange(10000)]
        test_data[-1] = True
        for i in range(random.randint(0, 10)):
            test_data[random.randint(0, 9999)] = True
        runner = Runner(test_data)
        trace = range(10000)
        print '!!'
        optimal_trace = simplify(trace, runner)
        print optimal_trace
        print '--'
        for n in optimal_trace:
            assert test_data[n]
        assert len([i for i in test_data if i]) == len(optimal_trace)

########NEW FILE########
__FILENAME__ = test_runner
#  Copyright 2008-2011 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import inspect
from model import RIDE
import random
import shutil
import os

class Runner(object):

    def __init__(self, seed, path, root):
        self._path = path
        self._root = root
        self._seed = seed
        self._model = None
        self._random = random

    def initialize(self):
        shutil.rmtree(self._path, ignore_errors=True)
        shutil.copytree(os.path.join(self._root, 'testdir'), os.path.join(self._path, 'testdir'))
        self._random.seed(self._seed)
        self._model = RIDE(self._random, self._path)
        self._actions = self._actions_from_model()
        self._count = 0
        if self._random.random() > 0.5:
            self._model.open_test_dir()
        else:
            self._model.open_suite_file()
        return self

    def _actions_from_model(self):
        return [name for name,_ in inspect.getmembers(self._model, inspect.ismethod) if not name.startswith('_')]

    def step(self):
        self._count += 1
        self._model._do_not_skip()
        action = self._random.choice(self._actions)
        getattr(self._model, action)()

    def skip_step(self):
        self._count += 1
        self._model._skip_until_notified()
        action = self._random.choice(self._actions)
        getattr(self._model, action)()

    def skip_steps(self, count):
        for i in range(count):
            self.skip_step()

    @property
    def count(self):
        return self._count

########NEW FILE########
__FILENAME__ = ride
#! /usr/bin/env python

#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import sys

from robotide import main

# Must be protected against reimporting
# As multiprocessing has an odd requirement
# and we use multiprocessing
# http://docs.python.org/library/multiprocessing.html#windows
if __name__ == '__main__':
    main(*sys.argv[1:])

########NEW FILE########
__FILENAME__ = action
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

def ActionFactory(action_info):
    if action_info.is_separator():
        return _MenuSeparator(action_info)
    return Action(action_info)


class _Registrable(object):

    def __init__(self, action_info):
        self._registered_to = []
        self.action = None
        self.shortcut = None
        self.icon = None
        self._insertion_point = action_info.insertion_point
        self._enabled = True
        self._enabled_status_listeners = []

    disable = enable = lambda event: None

    def is_separator(self):
        return False

    def get_insertion_index(self, menu):
        return self._insertion_point.get_index(menu)

    def register(self, registerer):
        self._registered_to.append(registerer)

    def unregister(self):
        for registerer in self._registered_to:
            registerer.unregister(self)
        self._registered_to = []

    def has_action(self):
        return self.action is not None

    def has_shortcut(self):
        return bool(self.shortcut)

    def has_icon(self):
        return self.icon is not None

    def inform_changes_in_enabled_status(self, listener):
        self._enabled_status_listeners.append(listener)


class Action(_Registrable):
    """Acts based on user actions if action is enabled. Created from `ActionInfo`.

    If `ActionInfo` contains container, acts and allows to select related UI
    widgets (menu item, toolbar button) and shortcuts only if the focus is in the given 
    container or its children.
    Action can be set enabled or disabled which enables/disables also related UI
    widgets and shortcut.
    """

    def __init__(self, action_info):
        _Registrable.__init__(self, action_info)
        self.menu_name = action_info.menu_name
        self.name = action_info.name
        self.action = action_info.action
        self.container = action_info.container
        self.shortcut = action_info.shortcut
        self.icon = action_info.icon
        self.doc = action_info.doc

    def get_shortcut(self):
        return self.shortcut.printable

    def act(self, event):
        if self.is_active():
            self.action(event)

    def disable(self):
        """Disables action and related menu item, toolbar button and shortcut"""
        self._enabled = False
        self._inform_changes_in_enabled_status()

    def enable(self):
        """Enables action and related menu item, toolbar button and shortcut"""
        self._enabled = True
        self._inform_changes_in_enabled_status()

    def _inform_changes_in_enabled_status(self):
        for listener in self._enabled_status_listeners:
            listener.enabled_status_changed(self)

    def is_active(self):
        if self._is_always_inactive() or not self._enabled:
            return False
        if self._is_always_active():
            return True
        return self._container_is_active()

    def _is_always_inactive(self):
        return self.action is None

    def _is_always_active(self):
        return self.container is None

    def _container_is_active(self):
        if not self.container.IsShownOnScreen():
            return False
        widget = self.container.FindFocus()
        while widget:
            if widget == self.container.Parent:
                return True
            widget = widget.GetParent()
        return False


class _MenuSeparator(_Registrable):

    def __init__(self, action_info):
        _Registrable.__init__(self, action_info)
        self.menu_name = action_info.menu_name
        self.name = '---'

    def is_separator(self):
        return True

########NEW FILE########
__FILENAME__ = actioninfo
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import re

from shortcut import Shortcut
from robotide.widgets import ImageProvider


def ActionInfoCollection(data, event_handler, container=None):
    """Parses the ``data`` into a list of `ActionInfo` and `SeparatorInfo` objects.

    The data is parsed based on the simple DSL documented below.

    :Parameters:
      data
        The data to be parsed into `ActionInfo` and `SeparatorInfo` objects.
      event_handler
        The event handler that implements the actions. See `finding handlers`_
        for more information.
      container
        the wxPython element containing the UI components associated with
        the `ActionInfo`.

    DSL syntax
    ----------
    ::

      [menu]
      name | documentation | shortcut | icon

    Fields
    ------

    menu
      The name of the menu under which the entries below it are inserted.
    name
      The name of the menu entry to be added. If name is ``---``, a
      `SeparatorInfo` object is created instead of an `ActionInfo` object.
      If name is post fixed with shortcuts between parenthesis and separated
      with ' or ', these shortcuts are parsed to machine local presentation
      and shown after the name. This can be used instead of shotrcut-element
      if you want to add shortcuts that you want to bind yourself and/or add
      several shortcuts.
    documentation
      Documentation for the action.
    shortcut
      Keyboard shortcut to invoke the action.
    icon
      Icon for the toolbar button.
    position
      Value for menu item ordering.

    See the `ActionInfo` attributes with same/similar names for more
    information about the fields and their possible values. Three
    last fields are optional.

    Finding handlers
    ----------------

    The given ``event_handler`` must have handler methods that map to the
    specified action names. The mapping is done by prefixing the name with
    ``On``, removing spaces, and capitalizing all words. For example ``Save``
    and ``My Action`` must have handler methods ``OnSave`` and ``OnMyAction``,
    respectively. If name has content between parenthesis at the end, this
    content is ignored when creating handler mapping.

    Specifying container
    --------------------

    By default the given ``container`` is passed to the `ActionInfo.__init__`
    method directly. This can be altered by prefixing the ``name`` with an
    exclamation mark (e.g. ``!Save`` or ``!My Action``) to make that action
    global. With these actions the container given to the `ActionInfo.__init__`
    is always ``None``.

    Example
    -------
    ::

        [File]
        !&Open | Open file containing tests | Ctrl-O | ART_FILE_OPEN
        !Open &Resource | Open a resource file | Ctrl-R
        ---
        &Save | Save selected datafile | Ctrl-S | ART_FILE_SAVE

        [Tools]
        !Manage Plugins  | | | | POSITION-80

        [Content]
        Content Assist (Ctrl-Space or Ctrl-Alt-Space) | Has two shortcuts.
    """

    menu = None
    actions = []
    for row in data.splitlines():
        row = row.strip()
        if not row:
            continue
        elif row.startswith('[') and row.endswith(']'):
            menu = row[1:-1].strip()
        else:
            actions.append(_create_action_info(event_handler, menu, container,
                                               row))
    return actions


def _create_action_info(eventhandler, menu, container, row):
    if row.startswith('---'):
        return SeparatorInfo(menu)
    tokens = [ t.strip() for t in row.split('|') ]
    tokens += [''] * (5-len(tokens))
    name, doc, shortcut, icon, position =  tokens
    if name.startswith('!'):
        name = name[1:]
        container = None
    eventhandler_name, name = _get_eventhandler_name_and_parsed_name(name)
    action = getattr(eventhandler, eventhandler_name)
    return ActionInfo(menu, name, action, container, shortcut, icon, doc, position)

def _get_eventhandler_name_and_parsed_name(name):
    eventhandler_name, name = _parse_shortcuts_from_name(name)
    return ('On%s' % eventhandler_name.replace(' ', '').replace('&', '') ,
            name)

def _parse_shortcuts_from_name(name):
    if '(' in name:
        eventhandler_name, shortcuts = name.split('(', 1)
        shortcuts = shortcuts.split(')')[0]
        elements = shortcuts.split(' or ')
        name = '%s (%s)' % (eventhandler_name,
                            ' or '.join(Shortcut(e).printable for e in elements))
        return eventhandler_name, name
    return name, name

class MenuInfo(object):
    """Base class for `ActionInfo` and `SeparatorInfo`."""

    def __init__(self):
        self.insertion_point = _InsertionPoint()

    def is_separator(self):
        return False

    def set_menu_position(self, before=None, after=None):
        """Sets the position of this menu entry.

        :Parameters:
          before
            Place this menu entry before the specified entry.
          after
            Place this menu entry after the specified entry.

        Use either ``before`` or ``after`` and give the name without the
        possible shortcut.
        """
        self.insertion_point = _InsertionPoint(before, after)


class ActionInfo(MenuInfo):
    """Used to create menu entries, keyboard shortcuts and/or toolbar buttons."""

    def __init__(self, menu_name, name, action=None, container=None,
                 shortcut=None, icon=None, doc='', position=-1):
        """Initializes information needed to create actions..

        :Parameters:
          menu_name
            The name of the menu where the new entry will be added. The menu is
            created if it does not exist.
          name
            The name of the new menu entry. The name may contain an accelerator
            key prefixed by an ampersand like ``New &Action``. If an accelerator
            is not specified, or the one requested is already taken, the next
            free key is selected.
          action
            The callable which will be called when a user does any of the
            associated UI actions.
          container
            The wxPython element containing the UI components associated with
            the ``action``. When any of the registered UI actions is executed,
            the ``action`` is called only if the ``container`` or any of its
            child components has focus. It is possible to make the ``action``
            always active by using ``None`` as the ``container``.
          shortcut
            The keyboard shortcut associated to the ``action``. The ``shortcut``
            must be a string constructed from optional modifiers (``Ctrl, Shift,
            Alt``) and the actual shortcut key separating the parts with a hyphen.
            The shortcut key can be either a single character or any of the
            `wx keycodes`__ without the ``WXK_`` prefix. Examples: ``Ctrl-C``,
            ``Shift-Ctrl-6``, ``Alt-Left``, ``F6``.
          icon
            The icon added to the toolbar as a toolbar button. It can be either
            a 16x16 bitmap or a string presenting one of the icons provided by
            `wxPython's ArtProvider`__ like ``ART_FILE_OPEN``.
          doc
            The documentation shown on the statusbar when selection is on
            the associated menu entry or toolbar button.
          position
            The positional value of an item in the menu. Provided for ordering
            Tools menu. Defaults to -1.

        __ http://docs.wxwidgets.org/stable/wx_keycodes.html#keycodes
        __ http://www.wxpython.org/docs/api/wx.ArtProvider-class.html
        """
        MenuInfo.__init__(self)
        self.menu_name = menu_name
        self.name = name
        self.action = action
        self.container = container
        self.shortcut = Shortcut(shortcut)
        self._icon = None
        self._icon_source = icon
        self.doc = doc
        self._position = position

    @property
    def icon(self):
        if not self._icon:
            self._icon = self._get_icon()
        return self._icon

    def _get_icon(self):
        if not self._icon_source:
            return None
        if isinstance(self._icon_source, basestring):
            if self._icon_source.startswith("CUSTOM_"):
                return ImageProvider().get_image_by_name(self._icon_source[len("CUSTOM_"):])
            return wx.ArtProvider.GetBitmap(getattr(wx, self._icon_source),
                                            wx.ART_TOOLBAR, (16, 16))
        return self._icon_source

    @property
    def position(self):
        if isinstance(self._position, int):
            return self._position
        elif isinstance(self._position, str):
            if len(self._position) > 0:
                return int(self._position.split("POSITION-")[-1])
        return -1

class SeparatorInfo(MenuInfo):
    """Used to create separators to menus."""

    def __init__(self, menu_name):
        """Initializes information needed to add separators to menus.

        :Parameters:
          menu_name
            The name of the menu where the separator will be added. If menu does
            not exist, it is created automatically.
        """
        MenuInfo.__init__(self)
        self.menu_name = menu_name

    def is_separator(self):
        return True


class _InsertionPoint(object):
    _shortcut_remover = re.compile(' {2,}\([^()]+\)$')

    def __init__(self, before=None, after=None):
        self._item = before or after
        self._insert_before = before is not None

    def get_index(self, menu):
        if not self._item:
            return menu.GetMenuItemCount()
        index = self._find_position_in_menu(menu)
        if not index:
            return menu.GetMenuItemCount()
        if not self._insert_before:
            index += 1
        return index

    def _find_position_in_menu(self, menu):
        for index in range(0, menu.GetMenuItemCount()):
            item = menu.FindItemByPosition(index)
            if self._get_menu_item_name(item).lower() == self._item.lower():
                return index
        return None

    def _get_menu_item_name(self, item):
        return self._shortcut_remover.split(item.GetLabel())[0]

########NEW FILE########
__FILENAME__ = shortcut
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from robotide.context import IS_MAC


CMD_CHAR = u'\u2318'
SHIFT_CHAR = u'\u21E7'
OPTION_CHAR = u'\u2325'
CTRL_CHAR = u'\u2303'
SPACE_CHAR = u'\u2423'
LEFT_CHAR = u'\u2190'
RIGHT_CHAR = u'\u2192'
DEL_CHAR = u'\u2326'
ENTER_CHAR = u'\u2324'
RETURN_CHAR = u'\u21A9'
ESC_CHAR = u'\u238B'
UP_CHAR = u'\u2191'
DOWN_CHAR = u'\u2193'

_REPLACE = {
    'Cmd': CMD_CHAR,
    'Shift': SHIFT_CHAR,
    'Alt': OPTION_CHAR,
    'Ctrl': CTRL_CHAR,
    'Space': SPACE_CHAR,
    'Left': LEFT_CHAR,
    'Right': RIGHT_CHAR,
    'Delete': DEL_CHAR,
    'Enter': ENTER_CHAR,
    'Return': RETURN_CHAR,
    'Escape': ESC_CHAR,
    '-': '',
    'Up': UP_CHAR,
    'Down': DOWN_CHAR
}

def localize_shortcuts(string):
    if IS_MAC:
        string = string.replace('CtrlCmd', 'Cmd')
    else:
        string = string.replace('CtrlCmd', 'Ctrl')
    return _replace_mac_chars(string)

def _replace_mac_chars(string):
    if not IS_MAC or not string:
        return string
    for key, value in _REPLACE.items():
        string = string.replace(key, value)
    return string


class Shortcut(object):

    def __init__(self, shortcut):
        self.value = self._normalize(shortcut)
        self.printable = self._get_printable(self.value)

    def _get_printable(self, value):
        return self._replace_chars_in_mac(value)

    def _replace_chars_in_mac(self, shortcut):
        return _replace_mac_chars(shortcut)

    def __nonzero__(self):
        return bool(self.value)

    def _normalize(self, shortcut):
        if not shortcut:
            return None
        order = ['Shift', 'Ctrl', 'Cmd', 'Alt']
        keys = [ self._normalize_key(key) for key in self._split(shortcut) ]
        keys.sort(key=lambda t: t in order and order.index(t) or 42)
        return '-'.join(keys)

    def _split(self, shortcut):
        return shortcut.replace('+', '-').split('-')

    def _normalize_key(self, key):
        key = key.title()
        key = self._handle_ctrlcmd(key)
        return {'Del': 'Delete', 'Ins': 'Insert',
                'Enter': 'Return', 'Esc':'Escape'}.get(key, key)

    def _handle_ctrlcmd(self, key):
        if key != 'Ctrlcmd':
            return key
        if IS_MAC:
            return 'Cmd'
        return 'Ctrl'

    def parse(self):
        keys = self._split(self.value)
        if len(keys) == 1:
            flags = wx.ACCEL_NORMAL
        else:
            flags = sum(self._get_wx_key_constant('ACCEL', key)
                        for key in keys[:-1])
        return flags, self._get_key(keys[-1])

    def _get_wx_key_constant(self, prefix, name):
        attr = '%s_%s' % (prefix, name.upper().replace(' ', ''))
        try:
            return getattr(wx, attr)
        except AttributeError:
            raise ValueError('Invalid shortcut key: %s' % name)

    def _get_key(self, key):
        if len(key) == 1:
            return ord(key.upper())
        return self._get_wx_key_constant('WXK', self._normalize_key(key))

########NEW FILE########
__FILENAME__ = application
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org:licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import with_statement
import os
import wx
from contextlib import contextmanager
from robotide.application.updatenotifier import UpdateNotifierController, UpdateDialog

from robotide.namespace import Namespace
from robotide.controller import ChiefController
from robotide.spec import librarydatabase
from robotide.ui import LoadProgressObserver
from robotide.ui.mainframe import RideFrame
from robotide.pluginapi import RideLogMessage
from robotide import context, contrib
from robotide.preferences import Preferences, RideSettings

from pluginloader import PluginLoader
from editorprovider import EditorProvider
from robotide.application.releasenotes import ReleaseNotes

class RIDE(wx.App):

    def __init__(self, path=None, updatecheck=True):
        self._initial_path = path
        self._updatecheck = updatecheck
        context.APP = self
        wx.App.__init__(self, redirect=False)

    def OnInit(self):
        self.settings = RideSettings()
        librarydatabase.initialize_database()
        self.preferences = Preferences(self.settings)
        self.namespace = Namespace(self.settings)
        self._controller = ChiefController(self.namespace, self.settings)
        self.frame = RideFrame(self, self._controller)
        self._editor_provider = EditorProvider()
        self._plugin_loader = PluginLoader(self, self._get_plugin_dirs(),
                                           context.get_core_plugins())
        self._plugin_loader.enable_plugins()
        self.editor = self._get_editor()
        self.editor.show()
        self._load_data()
        self.frame.tree.populate(self.model)
        self.frame.tree.set_editor(self.editor)
        self._publish_system_info()
        if self._updatecheck:
            UpdateNotifierController(self.settings).notify_update_if_needed(UpdateDialog)
        wx.CallLater(200, ReleaseNotes(self).bring_to_front)
        return True

    def _publish_system_info(self):
        RideLogMessage(context.SYSTEM_INFO).publish()

    @property
    def model(self):
        return self._controller

    def _get_plugin_dirs(self):
        return [self.settings.get_path('plugins'),
                os.path.join(self.settings['install root'], 'site-plugins'),
                contrib.CONTRIB_PATH]

    def _get_editor(self):
        from robotide.editor import EditorPlugin
        for pl in self._plugin_loader.plugins:
            if isinstance(pl._plugin, EditorPlugin):
                return pl._plugin

    def _load_data(self):
        path = self._initial_path or self._get_latest_path()
        if path:
            with self.active_event_loop():
                observer = LoadProgressObserver(self.frame)
                self._controller.load_data(path, observer)

    def _get_latest_path(self):
        recent = self._get_recentfiles_plugin()
        if not recent or not recent.recent_files:
            return None
        return recent.recent_files[0]

    def _get_recentfiles_plugin(self):
        from robotide.recentfiles import RecentFilesPlugin
        for pl in self.get_plugins():
            if isinstance(pl._plugin, RecentFilesPlugin):
                return pl._plugin

    def get_plugins(self):
        return self._plugin_loader.plugins

    def register_preference_panel(self, panel_class):
        '''Add the given panel class to the list of known preference panels'''
        self.preferences.add(panel_class)

    def unregister_preference_panel(self, panel_class):
        '''Remove the given panel class from the list of known preference panels'''
        self.preferences.remove(panel_class)

    def register_editor(self, object_class, editor_class, activate):
        self._editor_provider.register_editor(object_class, editor_class,
                                              activate)

    def unregister_editor(self, object_class, editor_class):
        self._editor_provider.unregister_editor(object_class, editor_class)

    def activate_editor(self, object_class, editor_class):
        self._editor_provider.set_active_editor(object_class, editor_class)

    def get_editors(self, object_class):
        return self._editor_provider.get_editors(object_class)

    def get_editor(self, object_class):
        return self._editor_provider.get_editor(object_class)

    @contextmanager
    def active_event_loop(self):
        # With wxPython 2.9.1, ProgressBar.Pulse breaks if there's no active
        # event loop.
        # See http://code.google.com/p/robotframework-ride/issues/detail?id=798
        loop = wx.EventLoop()
        wx.EventLoop.SetActive(loop)
        yield
        del loop

########NEW FILE########
__FILENAME__ = editorprovider
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org:licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


class EditorProvider(object):

    def __init__(self):
        self._editors = {}

    def register_editor(self, key, editor, default=True):
        if key not in self._editors:
            self._editors[key] = _EditorList()
        self._editors[key].add(editor, default)

    def unregister_editor(self, key, editor):
        self._editors[key].remove(editor)

    def set_active_editor(self, key, editor):
        self._editors[key].set_default(editor)

    def get_editor(self, key):
        return self._editors[key].get()

    def get_editors(self, key):
        return self._editors[key].get_all()


class _EditorList(object):

    def __init__(self):
        self._editors = []

    def add(self, editor, default=True):
        if editor in self._editors:
            return
        if default:
            self._editors.append(editor)
        else:
            self._editors.insert(0, editor)

    def set_default(self, editor):
        if not self._editors.index(editor) == -1:
            self._editors.remove(editor)
            self._editors.append(editor)

    def remove(self, editor):
        self._editors.remove(editor)

    def get(self):
        return self._editors[-1]

    def get_all(self):
        return self._editors

########NEW FILE########
__FILENAME__ = pluginconnector
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.context import LOG
from robotide import utils


def PluginFactory(application, plugin_class):
    try:
        plugin = plugin_class(application)
    except Exception, err:
        return BrokenPlugin(str(err), plugin_class)
    else:
        return PluginConnector(plugin, application)


class _PluginConnector(object):

    def __init__(self, name, doc='', error=None):
        self.name = name
        self.doc = doc
        self.error = error
        self.enabled = False
        self.metadata = {}
        self.config_panel = lambda self: None


class PluginConnector(_PluginConnector):

    def __init__(self, plugin, application):
        _PluginConnector.__init__(self, plugin.name, plugin.doc)
        self._plugin = plugin
        self._settings = application.settings['Plugins'].add_section(plugin.name)
        self.config_panel = plugin.config_panel
        self.metadata = plugin.metadata

    def enable_on_startup(self):
        if self._settings.get('_enabled', self._plugin.initially_enabled):
            self.enable()

    def enable(self):
        self._settings.set('_enabled', True)
        self.enabled = True
        self._plugin.enable()

    def disable(self):
        if self.enabled:
            self._settings.set('_enabled', False)
            self.enabled = False
            self._plugin.disable()


class BrokenPlugin(_PluginConnector):

    def __init__(self, error, plugin_class):
        name = utils.name_from_class(plugin_class, 'Plugin')
        doc = 'This plugin is disabled because it failed to load properly.\n' \
               + 'Error: ' + error
        _PluginConnector.__init__(self, name, doc=doc, error=error)
        LOG.error("Taking %s plugin into use failed:\n%s" % (name, error))

    def enable_on_startup(self):
        pass

########NEW FILE########
__FILENAME__ = pluginloader
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import imp
import inspect

from robotide.context import LOG
from robotide.pluginapi import Plugin

from pluginconnector import PluginFactory


class PluginLoader(object):

    def __init__(self, application, load_dirs, standard_classes):
        self._load_errors = []
        self.plugins = [ PluginFactory(application, cls) for cls in
                         standard_classes + self._find_classes(load_dirs) ]
        if self._load_errors:
            LOG.error('\n\n'.join(self._load_errors))

    def enable_plugins(self):
        for p in self.plugins:
            p.enable_on_startup()

    def _find_classes(self, load_dirs):
        classes = []
        for path in self._find_python_files(load_dirs):
            for cls in self._import_classes(path):
                if self._is_plugin_class(path, cls):
                    classes.append(cls)
        return classes

    def _is_plugin_class(self, path, cls):
        try:
            return issubclass(cls, Plugin) and cls is not Plugin
        except Exception, err:
            msg = "Finding classes from module '%s' failed: %s"
            self._load_errors.append(msg % (path, err))

    def _find_python_files(self, load_dirs):
        files = []
        for path in load_dirs:
            if not os.path.exists(path):
                continue
            for filename in os.listdir(path):
                full_path = os.path.join(path, filename)
                if filename[0].isalpha() and \
                        os.path.splitext(filename)[1].lower() == ".py":
                    files.append(full_path)
                elif os.path.isdir(full_path):
                    files.extend(self._find_python_files([full_path]))
        return files

    def _import_classes(self, path):
        dirpath, filename = os.path.split(path)
        modulename = os.path.splitext(filename)[0]
        try:
            file, imppath, description = imp.find_module(modulename, [dirpath])
        except ImportError:
            return []
        try:
            try:
                module = imp.load_module(modulename, file, imppath,
                                         description)
            except Exception, err:
                self._load_errors.append("Importing plugin module '%s' failed:\n%s"
                                         % (path, err))
                return []
        finally:
            if file:
                file.close()
        return [ cls for _, cls in
                 inspect.getmembers(module, predicate=inspect.isclass) ]

########NEW FILE########
__FILENAME__ = releasenotes
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx.lib.ClickableHtmlWindow import PyClickableHtmlWindow

from robotide.version import VERSION
from robotide.pluginapi import ActionInfo


class ReleaseNotes(object):
    """Shows release notes of the current version.

    The release notes tab will automatically be shown once per release.
    The user can also view them on demand by selecting "Release Notes"
    from the help menu.
    """

    def __init__(self, application):
        self.application = application
        settings =  application.settings
        self.version_shown = settings.get('version_shown', '')
        self._view = None
        self.enable()

    def enable(self):
        self.application.frame.actions.register_action(ActionInfo('Help', 'Release Notes', self.show,
                                        doc='Show the release notes'))
        self.show_if_updated()

    def show_if_updated(self):
        if self.version_shown != VERSION:
            self.show()
            self.application.settings['version_shown'] = VERSION

    def show(self, event=None):
        if not self._view:
            self._view = self._create_view()
            self.application.frame.notebook.AddPage(self._view, "Release Notes", select=False)
        self.application.frame.notebook.show_tab(self._view)

    def bring_to_front(self):
        if self._view:
            self.application.frame.notebook.show_tab(self._view)

    def _create_view(self):
        panel = wx.Panel(self.application.frame.notebook)
        html_win = PyClickableHtmlWindow(panel, -1)
        html_win.SetStandardFonts()
        html_win.SetPage(WELCOME_TEXT + RELEASE_NOTES)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(html_win, 1, wx.EXPAND|wx.ALL, border=8)
        panel.SetSizer(sizer)
        return panel


WELCOME_TEXT = """
<h2>Welcome to use RIDE version %s</h2>

<p>Thank you for using the Robot Framework IDE (RIDE).</p>

<p>Visit RIDE on the web:</p>

<ul>
  <li><a href="https://github.com/robotframework/RIDE">
      RIDE project page on github</a></li>
  <li><a href="https://github.com/robotframework/RIDE/wiki/Installation-Instructions">
      Installation instructions</a></li>
  <li><a href="https://github.com/robotframework/RIDE/wiki/Release-notes">
      Release notes</a></li>
</ul>
""" % VERSION

# *** DO NOT EDIT THE CODE BELOW MANUALLY ***
# Release notes are updated automatically by package.py script whenever
# a numbered distribution is created.
RELEASE_NOTES = """
<h2>Release notes for 1.2.3</h2>
<table border="1">
<tr>
<td><p><b>ID</b></p></td>
<td><p><b>Type</b></p></td>
<td><p><b>Priority</b></p></td>
<td><p><b>Summary</b></p></td>
</tr>
<tr>
<td><a href="http://code.google.com/p/robotframework-ride/issues/detail?id=1290">Issue 1290</a></td>
<td>Defect</td>
<td>Medium</td>
<td>RIDE runs not selected (with checkboxes) tests</td>
</tr>
<tr>
<td><a href="http://code.google.com/p/robotframework-ride/issues/detail?id=1306">Issue 1306</a></td>
<td>Defect</td>
<td>Medium</td>
<td>[RIDE 1.2.2 running on Python 2.7.5.] - Unable to insert cell in RIDE, if the TC contains FOR loop.</td>
</tr>
<tr>
<td><a href="http://code.google.com/p/robotframework-ride/issues/detail?id=1307">Issue 1307</a></td>
<td>Enhancement</td>
<td>Medium</td>
<td>Possibility to create new folder with right click</td>
</tr>
</table>
<p>Altogether 3 issues.</p>
"""

########NEW FILE########
__FILENAME__ = updatenotifier
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Configure wx version to allow running test app in __main__


import wx, wx.html
from robotide.utils.versioncomparator import cmp_versions
from robotide.widgets.button import ButtonWithHandler

import time
import urllib2
import xmlrpclib
import robotide.version as version

_CHECK_FOR_UPDATES_SETTING = 'check for updates'
_LAST_UPDATE_CHECK_SETTING = 'last update check'

class UpdateNotifierController(object):

    VERSION = version.VERSION
    SECONDS_IN_WEEK = 60*60*24*7

    def __init__(self, settings):
        self._settings = settings

    def notify_update_if_needed(self, update_notification_callback):
        if self._should_check() and self._is_new_version_available():
            update_notification_callback(self._newest_version, self._download_url, self._settings)

    def _should_check(self):
        if self._settings.get(_CHECK_FOR_UPDATES_SETTING, None) is None:
            self._settings[_CHECK_FOR_UPDATES_SETTING] = True
            return True
        return self._settings[_CHECK_FOR_UPDATES_SETTING] and \
               time.time() - self._settings.get(_LAST_UPDATE_CHECK_SETTING, 0) > self.SECONDS_IN_WEEK

    def _is_new_version_available(self):
        self._settings[_LAST_UPDATE_CHECK_SETTING] = time.time()
        try:
            self._newest_version = self._get_newest_version()
            self._download_url = self._get_download_url(self._newest_version)
        except Exception, e:
            print e
            #There are many possible errors:
            # - Timeout
            # - Corrupted data
            # - Server fault message
            # - Unexpected change in dataformat
            return False
        return cmp_versions(self.VERSION, self._newest_version) == -1

    def _get_newest_version(self):
        return self._get_response(('robotframework-ride',), 'package_releases')[0]

    def _get_download_url(self, version):
        return self._get_response(('robotframework-ride', version), 'release_data')['download_url']

    def _get_response(self, params, method):
        req = urllib2.Request('http://pypi.python.org/pypi', xmlrpclib.dumps(params, method), {'Content-Type':'text/xml'})
        return xmlrpclib.loads(urllib2.urlopen(req, timeout=1).read())[0][0]


class HtmlWindow(wx.html.HtmlWindow):
    def __init__(self, parent, id, size=(600,400)):
        wx.html.HtmlWindow.__init__(self,parent, id, size=size)
        if "gtk2" in wx.PlatformInfo:
            self.SetStandardFonts()

    def OnLinkClicked(self, link):
        wx.LaunchDefaultBrowser(link.GetHref())


class UpdateDialog(wx.Dialog):

    def __init__(self, version, url, settings):
        self._settings = settings
        wx.Dialog.__init__(self, None, -1, "Update available")
        sizer = wx.BoxSizer(orient=wx.VERTICAL)
        hwin = HtmlWindow(self, -1, size=(400,200))
        hwin.SetPage('New version %s available from <a href="%s">%s</a>' % (version, url, url))
        irep = hwin.GetInternalRepresentation()
        hwin.SetSize((irep.GetWidth()+25, irep.GetHeight()+20))
        sizer.Add(hwin)
        checkbox = wx.CheckBox(self, -1, label='I\'m using another method for RIDE updates\n and do not need automatic update checks')
        checkbox.Bind(wx.EVT_CHECKBOX, handler=self.OnCheckboxChange)
        sizer.Add(checkbox)
        button = ButtonWithHandler(self, label='remind me later', handler=self.OnRemindMeLater)
        sizer.Add(button)
        self.SetSizer(sizer)
        self.CentreOnParent(wx.BOTH)
        self.Fit()
        self.SetFocus()
        self.ShowModal()
        self.Destroy()

    def OnRemindMeLater(self, event):
        self.Close(True)

    def OnCheckboxChange(self, event):
        self._settings[_CHECK_FOR_UPDATES_SETTING] = not event.IsChecked()
        event.Skip()

########NEW FILE########
__FILENAME__ = coreplugins
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


def get_core_plugins():
    from robotide.run import RunAnything
    from robotide.recentfiles import RecentFilesPlugin
    from robotide.ui.preview import PreviewPlugin
    from robotide.ui.keywordsearch import KeywordSearch
    from robotide.editor import EditorPlugin
    from robotide.editor.texteditor import TextEditorPlugin
    from robotide.log import LogPlugin
    from robotide.searchtests.searchtests import TestSearchPlugin
    from robotide.spec.specimporter import SpecImporterPlugin

    return [RunAnything, RecentFilesPlugin, PreviewPlugin, SpecImporterPlugin,
            EditorPlugin, TextEditorPlugin, KeywordSearch, LogPlugin, TestSearchPlugin]


########NEW FILE########
__FILENAME__ = logger
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
import sys
import wx

from robotide.widgets import Dialog


class Logger(object):
    empty_suite_init_file_warn = re.compile("Test suite directory initialization "
                                            "file '.*' contains no test data.")

    def __init__(self):
        self._messages = []

    def report_parsing_errors(self):
        errors = [m[0] for m in self._messages]
        if errors:
            # Warnings from robot.variables.Variables.set_from_variable_table
            # are present multiple times, issue 486.
            errors = set(errors)
            dlg = ParsingErrorDialog('\n'.join(self._format_parsing_error_line(line)
                                               for line in errors))
            dlg.ShowModal()
            dlg.Destroy()
        self._messages = []

    def _format_parsing_error_line(self, line):
        if ':' not in line:
            return line
        index = line.index(':') + 1
        return line[:index] + '\n\t' + line[index:]

    def warn(self, msg=''):
        self._write(msg, 'WARN')

    def error(self, msg=''):
        self._write(msg, 'ERROR')

    def message(self, msg):
        message, level = msg.message, msg.level.upper()
        if self._is_logged(level):
            self._messages.append((message, level))

    def _write(self, msg, level):
        level = level.upper()
        if self._is_logged(level) and not self._is_ignored_warning(msg):
            self._show_message(msg, level)

    def _is_logged(self, level):
        return level.upper() in ['ERROR', 'WARN']

    def _is_ignored_warning(self, msg):
        return self.empty_suite_init_file_warn.search(msg)

    def _show_message(self, msg, level):
        try:
            icon = level == 'ERROR' and wx.ICON_ERROR or wx.ICON_WARNING
            wx.MessageBox(msg, level, icon)
        except wx.PyNoAppError:
            sys.stderr.write('%s: %s\n' % (level, msg))


class ParsingErrorDialog(Dialog):

    def __init__(self, message):
        Dialog.__init__(self, title='Parsing errors', size=(700, 400),
                        style=wx.DEFAULT_FRAME_STYLE)
        area = wx.TextCtrl(self, size=(700,400), style=wx.TE_MULTILINE|wx.TE_DONTWRAP|wx.TE_READONLY)
        area.SetValue(message)

########NEW FILE########
__FILENAME__ = platform
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys
import wx

IS_WINDOWS = os.sep == '\\'
IS_MAC = sys.platform == 'darwin'
WX_VERSION = wx.VERSION_STRING


def ctrl_or_cmd():
    if IS_MAC:
        return wx.ACCEL_CMD
    return wx.ACCEL_CTRL

def bind_keys_to_evt_menu(target, actions):
    accelrators = []
    for accel, keycode, handler in actions:
        id = wx.NewId()
        target.Bind(wx.EVT_MENU, handler, id=id)
        accelrators.append((accel, keycode, id))
    target.SetAcceleratorTable(wx.AcceleratorTable(accelrators))

########NEW FILE########
__FILENAME__ = runprofiles
# Copyright 2010 Orbitz WorldWide
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

'''runProfiles.py

This module contains profiles for running robot tests via the
runnerPlugin.

Each class that is a subclass as BaseProfile will appear in a
drop-down list within the plugin. The chosen profile will be used to
build up a command that will be passed in the tests to run as well as
any additional arguments.
'''

import wx
from wx.lib.filebrowsebutton import FileBrowseButton
import os
from robot.errors import DataError, Information, FrameworkError
from robotide.contrib.testrunner.usages import USAGE
from robot.utils.argumentparser import ArgumentParser
from robot.utils.encoding import SYSTEM_ENCODING
from robotide.utils import overrides

from robotide.widgets import Label


class BaseProfile(object):
    '''Base class for all test runner profiles

    At a minimum each profile must set the name attribute, which is
    how the profile will appear in the dropdown list.

    In case some settings are needed, provide default_settings class attribute
    with default values.

    This class (BaseProfile) will _not_ appear as one of the choices.
    Think of it as an abstract class, if Python 2.5 had such a thing.
    '''

    # this will be set to the plugin instance at runtime
    plugin = None
    default_settings = {}

    def __init__(self, plugin):
        '''plugin is required so that the profiles can save their settings'''
        self.plugin = plugin

    def get_toolbar(self, parent):
        '''Returns a panel with toolbar controls to be shown for this profile'''
        return wx.Panel(parent, wx.ID_ANY)

    def delete_pressed(self):
        '''Handle delete key pressing'''
        pass

    def get_custom_args(self):
        '''Return a list of arguments unique to this profile.

        Returned arguments are in format accepted by Robot Framework's argument
        file.
        '''
        return []

    def get_command_prefix(self):
        '''Returns a command and any special arguments for this profile'''
        return ["pybot.bat" if os.name == "nt" else "pybot"]

    def set_setting(self, name, value):
        '''Sets a plugin setting

        setting is automatically prefixed with profile's name and it can be
        accessed with direct attribute access. See also __getattr__.
        '''
        self.plugin.save_setting(self._get_setting_name(name), value, delay=2)

    def __getattr__(self, name):
        """Provides attribute access to profile's settings

        If for example default_settings = {'setting1' = ""} is defined
        then setting1 value can be used like self.setting1
        set_setting is used to store the value.
        """
        try:
            return getattr(self.plugin, self._get_setting_name(name))
        except AttributeError:
            try:
                return getattr(self.plugin, name) #Support users old saved values
            except AttributeError:
                if self.default_settings.has_key(name):
                    return self.default_settings[name]
                raise

    def _get_setting_name(self, name):
        """Adds profile's name to the setting."""
        return "%s_%s" % (self.name.replace(' ', '_'), name)


class PybotProfile(BaseProfile):
    '''A runner profile which uses pybot

    It is assumed that pybot is on the path
    '''
    name = "pybot"
    default_settings = {"arguments": u"",
                        "include_tags": "",
                        "exclude_tags": "",
                        "apply_include_tags": False,
                        "apply_exclude_tags": False}

    def __init__(self, plugin):
        BaseProfile.__init__(self, plugin)
        self._toolbar = None

    def get_command_prefix(self):
        '''Returns a command and any special arguments for this profile'''
        return [self.get_command()] + self._get_arguments()

    def _get_arguments(self):
        return self.arguments.split()

    def get_command(self):
        return "pybot.bat" if os.name == "nt" else "pybot"

    def get_custom_args(self):
        args = []
        if self.apply_include_tags and self.include_tags:
            for include in self._get_tags_from_string(self.include_tags):
                args.append("--include=%s" % include)
        if self.apply_exclude_tags and self.exclude_tags:
            for exclude in self._get_tags_from_string(self.exclude_tags):
                args.append("--exclude=%s" % exclude)
        return args

    def _get_tags_from_string(self, tag_string):
        tags = []
        for tag in tag_string.split(","):
            tag = tag.strip().replace(' ', '')
            if len(tag) > 0:
                tags.append(tag)
        return tags

    def get_toolbar(self, parent):
        if self._toolbar is None:
            self._toolbar = self._get_toolbar(parent)
        return self._toolbar

    def _get_toolbar(self, parent):
        panel = wx.Panel(parent, wx.ID_ANY)
        sizer = wx.BoxSizer(wx.VERTICAL)
        for item in self.get_toolbar_items():
            sizer.Add(item(panel), 0, wx.ALL|wx.EXPAND)
        panel.SetSizerAndFit(sizer)
        return panel

    def get_toolbar_items(self):
        return [self.ArgumentsPanel, self.TagsPanel]

    @overrides(BaseProfile)
    def delete_pressed(self):
        focused = wx.Window.FindFocus()
        if focused not in [self._arguments, self._include_tags, self._exclude_tags]:
            return
        start, end = focused.GetSelection()
        focused.Remove(start, max(end, start+1))

    def ArgumentsPanel(self, parent):
        panel = wx.Panel(parent, wx.ID_ANY)
        label = Label(panel, label="Arguments: ")
        self._arguments = wx.TextCtrl(panel, wx.ID_ANY, size=(-1,-1),
                                     value=self.arguments)
        self._arguments.SetToolTipString("Arguments for the test run. Arguments are space separated list.")
        self._arguments.Bind(wx.EVT_TEXT, self.OnArgumentsChanged)
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(label, 0, wx.ALL|wx.EXPAND)
        sizer.Add(self._arguments, 1, wx.ALL|wx.EXPAND)
        panel.SetSizerAndFit(sizer)
        self._validate_arguments(self.arguments or u'')
        return panel

    def TagsPanel(self, parent):
        '''Create a panel to input include/exclude tags'''
        panel = wx.Panel(parent, wx.ID_ANY)
        include_cb = self._create_checkbox(panel, self.apply_include_tags,
                                           "Only run tests with these tags")
        exclude_cb = self._create_checkbox(panel, self.apply_exclude_tags,
                                           "Skip tests with these tags")
        self._include_tags = wx.TextCtrl(panel, wx.ID_ANY, size=(150,-1),
                                         value=self.include_tags)
        self._exclude_tags = wx.TextCtrl(panel, wx.ID_ANY, size=(150,-1),
                                         value=self.exclude_tags)

        panel.Bind(wx.EVT_CHECKBOX, self.OnIncludeCheckbox, include_cb)
        panel.Bind(wx.EVT_CHECKBOX, self.OnExcludeCheckbox, exclude_cb)
        self._include_tags.Bind(wx.EVT_TEXT, self.OnIncludeTagsChanged)
        self._exclude_tags.Bind(wx.EVT_TEXT, self.OnExcludeTagsChanged)

        panelsizer = wx.GridBagSizer(2,2)
        panelsizer.Add(include_cb, (0,0), flag=wx.EXPAND)
        panelsizer.Add(exclude_cb, (0,1), flag=wx.EXPAND)
        panelsizer.Add(self._include_tags, (1,0), flag=wx.EXPAND)
        panelsizer.Add(self._exclude_tags, (1,1), flag=wx.EXPAND)
        panelsizer.AddGrowableCol(0)
        panelsizer.AddGrowableCol(1)
        panel.SetSizerAndFit(panelsizer)
        return panel

    def _create_checkbox(self, parent, value, title):
        checkbox = wx.CheckBox(parent, wx.ID_ANY, title)
        checkbox.SetValue(value)
        return checkbox

    def OnArgumentsChanged(self, evt):
        args = self._arguments.GetValue()
        self._validate_arguments(args or u'')
        self.set_setting("arguments", args)

    def _validate_arguments(self, args):
        assert type(args) is unicode
        invalid_message = self._get_invalid_message(args)
        self._arguments.SetBackgroundColour('red' if invalid_message else 'white')
        self._arguments.SetForegroundColour('white' if invalid_message else 'black')
        self._arguments.SetToolTipString(invalid_message or 'Arguments for the test run. Arguments are space separated list.')

    def _get_invalid_message(self, args):
        try:
            args = args.encode(SYSTEM_ENCODING)
            _, invalid = ArgumentParser(USAGE).parse_args(args.split())
            if bool(invalid):
                return 'Unknown option(s): '+' '.join(invalid)
            return None
        except DataError, e:
            return e.message
        except Information:
            return 'Does not execute - help or version option given'

    def OnExcludeCheckbox(self, evt):
        self.set_setting("apply_exclude_tags", evt.IsChecked())

    def OnIncludeCheckbox(self, evt):
        self.set_setting("apply_include_tags", evt.IsChecked())

    def OnIncludeTagsChanged(self, evt):
        self.set_setting("include_tags", self._include_tags.GetValue())

    def OnExcludeTagsChanged(self, evt):
        self.set_setting("exclude_tags", self._exclude_tags.GetValue())


class CustomScriptProfile(PybotProfile):
    '''A runner profile which uses script given by the user'''

    name = "custom script"
    default_settings = dict(PybotProfile.default_settings, runner_script="")

    def get_command(self):
        return self.runner_script

    def get_cwd(self):
        return os.path.dirname(self.runner_script)

    def get_toolbar_items(self):
        return [self.RunScriptPanel, self.ArgumentsPanel, self.TagsPanel]

    def _validate_arguments(self, args):
        #Can't say anything about custom script argument validity
        pass

    def RunScriptPanel(self, parent):
        panel = wx.Panel(parent, wx.ID_ANY)
        self._script = FileBrowseButton(panel, labelText="Script to run tests:",
                                        size=(-1, -1), fileMask="*",
                                        changeCallback=self.OnCustomScriptChanged)
        self._script.SetValue(self.runner_script)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self._script, 0, wx.ALL|wx.EXPAND)
        panel.SetSizerAndFit(sizer)
        return panel

    def OnCustomScriptChanged(self, evt):
        self.set_setting("runner_script", self._script.GetValue())

########NEW FILE########
__FILENAME__ = testrunner
# Copyright 2010 Orbitz WorldWide
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Modified by NSN
#  Copyright 2010-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import SocketServer
import atexit
import codecs
import os
import shutil
import socket
import subprocess
import tempfile
import threading
import signal
import sys
import robotide.utils as utils
from Queue import Empty, Queue
from robot.output.loggerhelper import LEVELS
from robot.utils.encoding import SYSTEM_ENCODING
from robotide.context.platform import IS_WINDOWS
from robotide.contrib.testrunner import TestRunnerAgent
from robotide.controller.testexecutionresults import TestExecutionResults

ATEXIT_LOCK = threading.RLock()

class TestRunner(object):

    def __init__(self, chief):
        self._output_dir = None
        self._process = None
        self._server = None
        self._server_thread = None
        self._pause_on_failure = False
        self._pid_to_kill = None
        self._results = TestExecutionResults()
        self.port = None
        self._chief = chief
        self.profiles = {}

    def enable(self, result_handler):
        self._start_listener_server(result_handler)
        self._create_temporary_directory()

    def _create_temporary_directory(self):
        self._output_dir = tempfile.mkdtemp(".d", "RIDE")
        atexit.register(self._remove_temporary_directory)
        # this plugin creates a temporary directory which _should_
        # get reaped at exit. Sometimes things happen which might
        # cause it to not get deleted. Maybe this would be a good
        # place to check for temporary directories that match the
        # signature and delete them if they are more than a few
        # days old...

    def _remove_temporary_directory(self):
        with ATEXIT_LOCK:
            if os.path.exists(self._output_dir):
                shutil.rmtree(self._output_dir)

    def add_profile(self, name, item):
        self.profiles[name] = item

    def get_profile(self, name):
        return self.profiles[name]

    def get_profile_names(self):
        return sorted(self.profiles.keys())

    def _start_listener_server(self, result_handler):
        def handle(*args):
            self._result_handler(*args)
            result_handler(*args)
        self._server = RideListenerServer(RideListenerHandler, handle)
        self._server_thread = threading.Thread(
            target=self._server.serve_forever)
        self._server_thread.setDaemon(True)
        self._server_thread.start()
        self.port = self._server.server_address[1]

    def _result_handler(self, event, *args):
        if event == 'pid':
            self._pid_to_kill = int(args[0])
        if event == 'port' and self._process:
            self._process.set_port(args[0])
        if event == 'start_test':
            longname = args[1]['longname']
            testname = args[0]
            self._results.set_running(self._get_test_controller(longname,
                                                                testname))
        if event == 'end_test':
            longname = args[1]['longname']
            testname = args[0]
            if args[1]['status'] == 'PASS':
                self._results.set_passed(self._get_test_controller(longname,
                                                                   testname))
            else:
                self._results.set_failed(self._get_test_controller(longname,
                                                                   testname))

    def _get_test_controller(self, longname, testname = None):
        ret = self._chief.find_controller_by_longname(longname, testname)
        return ret

    def clear_server(self):
        self._server = None

    def shutdown_server(self):
        if self._server:
            self._server.shutdown()

    def test_execution_started(self):
        self._results.test_execution_started()

    def kill_process(self):
        if self._process:
            self._process.kill(force=True)

    def set_pause_on_failure(self, pause):
        self._pause_on_failure = pause
        self._send_pause_on_failure_information()

    def _send_pause_on_failure_information(self):
        if self._process:
            self._process.pause_on_failure(self._pause_on_failure)

    def send_stop_signal(self):
        if self._process:
            self._process.kill(killer_pid=self._pid_to_kill)

    def send_pause_signal(self):
        if self._process:
            self._process.pause()

    def send_continue_signal(self):
        if self._process:
            self._process.resume()

    def send_step_next_signal(self):
        if self._process:
            self._process.step_next()

    def send_step_over_signal(self):
        if self._process:
            self._process.step_over()

    def run_command(self, command, cwd):
        self._pid_to_kill = None
        self._process = Process(cwd)
        self._process.run_command(command)

    def get_command(self, profile, pythonpath, monitor_width, names_to_run):
        '''Return the command (as a list) used to run the test'''
        command = profile.get_command_prefix()[:]
        argfile = os.path.join(self._output_dir, "argfile.txt")
        command.extend(["--argumentfile", argfile])
        command.extend(["--listener", self._get_listener_to_cmd()])
        command.append(self._get_suite_source_for_command())
        self._write_argfile(argfile, self._create_standard_args(command, profile, pythonpath, monitor_width, names_to_run))
        return command

    @staticmethod
    def get_message_log_level(command):
        min_log_level_number = LEVELS['INFO']
        if '-L' in command:
            switch = '-L'
        elif '--loglevel' in command:
            switch = '--loglevel'
        else:
            return min_log_level_number
        i = command.index(switch)
        if len(command) == i:
            return
        level = command[i+1].upper().split(':')[0]
        return LEVELS.get(level, min_log_level_number)

    def _get_listener_to_cmd(self):
        path = os.path.abspath(TestRunnerAgent.__file__)
        if path[-1] in ['c', 'o']:
            path = path[:-1]
        return '%s:%s:%s' % (path, self.port, self._pause_on_failure)

    def _get_suite_source_for_command(self):
        cur = os.path.abspath(os.path.curdir)
        source = os.path.abspath(self._chief.suite.source)
        if not utils.is_same_drive(cur, source):
            return source
        return os.path.abspath(self._chief.suite.source)

    def _create_standard_args(self, command, profile, pythonpath, monitor_width, names_to_run):
        standard_args = []
        standard_args.extend(profile.get_custom_args())
        self._add_tmp_outputdir_if_not_given_by_user(command, standard_args)
        self._add_pythonpath_if_in_settings_and_not_given_by_user(command,
                                                                  standard_args,
                                                                  pythonpath)
        standard_args.extend(["--monitorcolors", "off"])
        standard_args.extend(["--monitorwidth", monitor_width])
        for suite, test in names_to_run:
            standard_args += ['--suite', suite, '--test', test]
        return standard_args

    def _add_tmp_outputdir_if_not_given_by_user(self, command, standard_args):
        if "--outputdir" not in command and "-d" not in command:
            standard_args.extend(["--outputdir", self._output_dir])

    @staticmethod
    def _add_pythonpath_if_in_settings_and_not_given_by_user(
        command, standard_args, pythonpath):
        if '--pythonpath' in command:
            return
        if '-P' in command:
            return
        if not pythonpath:
            return
        standard_args.extend(['--pythonpath', ':'.join(pythonpath)])

    @staticmethod
    def _write_argfile(argfile, args):
        f = codecs.open(argfile, "w", "utf-8")
        f.write("\n".join(args))
        f.close()

    def get_output_and_errors(self):
        return self._process.get_output(), self._process.get_errors()

    def is_running(self):
        return self._process and self._process.is_alive()

    def command_ended(self):
        self._process = None


class Process(object):

    def __init__(self, cwd):
        self._process = None
        self._error_stream = None
        self._output_stream = None
        self._cwd = cwd
        self._port = None
        self._sock = None
        self._kill_called = False

    def run_command(self, command):
        # We need to supply stdin for subprocess, because otherways in pythonw
        # subprocess will try using sys.stdin which causes an error in windows
        subprocess_args = dict(bufsize=0,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        stdin=subprocess.PIPE,
                        cwd=self._cwd.encode(SYSTEM_ENCODING))
        if IS_WINDOWS:
            startupinfo = subprocess.STARTUPINFO()
            try:
                import _subprocess
                startupinfo.dwFlags |= _subprocess.STARTF_USESHOWWINDOW
            except ImportError:
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            subprocess_args['startupinfo'] = startupinfo
        else:
            subprocess_args['preexec_fn'] = os.setsid
            subprocess_args['shell'] = True
        self._process = subprocess.Popen(command.encode(SYSTEM_ENCODING),
                                         **subprocess_args)
        self._process.stdin.close()
        self._output_stream = StreamReaderThread(self._process.stdout)
        self._error_stream = StreamReaderThread(self._process.stderr)
        self._output_stream.run()
        self._error_stream.run()
        self._kill_called = False

    def set_port(self, port):
        self._port = port

    def get_output(self):
        return self._output_stream.pop()

    def get_errors(self):
        return self._error_stream.pop()

    def is_alive(self):
        return self._process.poll() is None

    def wait(self):
        self._process.wait()

    def kill(self, force=False, killer_pid=None):
        if not self._process:
            return
        if force:
            self._process.kill()
        self.resume() # Send so that RF is not blocked
        if IS_WINDOWS and not self._kill_called and self._port is not None:
            self._signal_kill_with_listener_server()
            self._kill_called = True
        else:
            self._kill(killer_pid or self._process.pid)

    def _signal_kill_with_listener_server(self):
        self._send_socket('kill')

    def _send_socket(self, data):
        if self._port is None:
            return  # Silent failure..
        sock = None
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect(('localhost', self._port))
            sock.send(data)
        finally:
            sock.close()

    def pause(self):
        self._send_socket('pause')

    def pause_on_failure(self, pause):
        if pause:
            self._send_socket('pause_on_failure')
        else:
            self._send_socket('do_not_pause_on_failure')

    def resume(self):
        self._send_socket('resume')

    def step_next(self):
        self._send_socket('step_next')

    def step_over(self):
        self._send_socket('step_over')

    def _kill(self, pid):
        if pid:
            try:
                if os.name == 'nt' and sys.version_info < (2,7):
                    import ctypes
                    ctypes.windll.kernel32.TerminateProcess(
                        int(self._process._handle), -1)
                else:
                    os.kill(pid, signal.SIGINT)
            except OSError:
                pass


class StreamReaderThread(object):

    def __init__(self, stream):
        self._queue = Queue()
        self._thread = None
        self._stream = stream

    def run(self):
        self._thread = threading.Thread(target=self._enqueue_output,
                                        args=(self._stream,))
        self._thread.daemon = True
        self._thread.start()

    def _enqueue_output(self, out):
        for line in iter(out.readline, b''):
            self._queue.put(line)

    def pop(self):
        result = ""
        for _ in xrange(self._queue.qsize()):
            try:
                result += self._queue.get_nowait()
            except Empty:
                pass
        return result.decode('UTF-8')


# The following two classes implement a small line-buffered socket
# server. It is designed to run in a separate thread, read data
# from the given port and update the UI -- hopefully all in a
# thread-safe manner.
class RideListenerServer(SocketServer.TCPServer):
    """Implements a simple line-buffered socket server"""
    allow_reuse_address = True
    def __init__(self, RequestHandlerClass, callback):
        SocketServer.TCPServer.__init__(self, ("",0), RequestHandlerClass)
        self.callback = callback

class RideListenerHandler(SocketServer.StreamRequestHandler):
    def handle(self):
        decoder = TestRunnerAgent.StreamHandler(self.request.makefile('r'))
        while True:
            try:
                (name, args) = decoder.load()
                self.server.callback(name, *args)
            except (EOFError, IOError):
                # I should log this...
                break

########NEW FILE########
__FILENAME__ = TestRunnerAgent
# Copyright 2010 Orbitz WorldWide
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Modified by Mikko Korpela under NSN copyrights
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Ammended by Timothy Alexander <dragonfyre13@gmail.com>
# (StreamHandler class added)
#   Copyright 2013 Timothy Alexander
#   Licensed under the Apache License, Version 2.0
#      http://www.apache.org/licenses/LICENSE-2.0

'''A Robot Framework listener that sends information to a socket

This uses a custom streamhandler module, preferring json but sending either
json or pickle to send objects to the listening server. It should probably be
refactored to call an XMLRPC server.
'''

import os
import sys
import socket
import threading
import SocketServer

from robot.running.signalhandler import STOP_SIGNAL_MONITOR
from robot.errors import ExecutionFailed

if sys.hexversion > 0x2060000:
    import json
    _JSONAVAIL=True
else:
    try:
        import simplejson as json
        _JSONAVAIL=True
    except ImportError:
        _JSONAVAIL=False

try:
    import cPickle as pickle
except ImportError:
    import pickle as pickle

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

HOST = "localhost"

try:
    # RF 2.7.5
    from robot.running import EXECUTION_CONTEXTS
    def _is_logged(level):
        current = EXECUTION_CONTEXTS.current
        if current is None:
            return True
        out = current.output
        if out is None:
            return True
        return out._xmllogger._log_message_is_logged(level)
except ImportError:
    # RF 2.5.6
    # RF 2.6.3
    def _is_logged(level):
        # Needs to be imported in the function as OUTPUT is not a constant
        from robot.output import OUTPUT
        if OUTPUT is None:
            return True
        return OUTPUT._xmllogger._log_message_is_logged(level)

# Setting Output encoding to UTF-8 and ignoring the platform specs
# RIDE will expect UTF-8
import robot.utils.encoding
# Set output encoding to UTF-8 for piped output streams
robot.utils.encoding.OUTPUT_ENCODING = 'UTF-8'
# RF 2.6.3 and RF 2.5.7
robot.utils.encoding._output_encoding = robot.utils.encoding.OUTPUT_ENCODING

class TestRunnerAgent:
    """Pass all listener events to a remote listener

    If called with one argument, that argument is a port
    If called with two, the first is a hostname, the second is a port
    """
    ROBOT_LISTENER_API_VERSION = 2

    def __init__(self, *args):
        self.port = int(args[0])
        self.host = HOST
        self.sock = None
        self.filehandler = None
        self.streamhandler = None
        self._connect()
        self._send_pid()
        self._create_debugger((len(args)>=2) and (args[1] == 'True'))
        self._create_kill_server()

    def _create_debugger(self, pause_on_failure):
        self._debugger = RobotDebugger(pause_on_failure)

    def _create_kill_server(self):
        self._killer = RobotKillerServer(self._debugger)
        self._server_thread = threading.Thread(
            target=self._killer.serve_forever)
        self._server_thread.setDaemon(True)
        self._server_thread.start()
        self._send_server_port(self._killer.server_address[1])

    def _send_pid(self):
        self._send_socket("pid", os.getpid())

    def _send_server_port(self, port):
        self._send_socket("port", port)

    def start_test(self, name, attrs):
        self._send_socket("start_test", name, attrs)

    def end_test(self, name, attrs):
        self._send_socket("end_test", name, attrs)

    def start_suite(self, name, attrs):
        self._send_socket("start_suite", name, attrs)

    def end_suite(self, name, attrs):
        self._send_socket("end_suite", name, attrs)

    def start_keyword(self, name, attrs):
        self._send_socket("start_keyword", name, attrs)
        if self._debugger.is_breakpoint(name, attrs):
            self._debugger.pause()
        paused = self._debugger.is_paused()
        if paused:
            self._send_socket('paused')
        self._debugger.start_keyword()
        if paused:
            self._send_socket('continue')

    def end_keyword(self, name, attrs):
        self._send_socket("end_keyword", name, attrs)
        self._debugger.end_keyword(attrs['status']=='PASS')

    def message(self, message):
        pass

    def log_message(self, message):
        if _is_logged(message['level']):
            self._send_socket("log_message", message)

    def log_file(self, path):
        self._send_socket("log_file", path)

    def output_file(self, path):
        pass

    def report_file(self, path):
        self._send_socket("report_file", path)

    def summary_file(self, path):
        pass

    def debug_file(self, path):
        pass

    def close(self):
        self._send_socket("close")
        if self.sock:
            self.filehandler.close()
            self.sock.close()

    def _connect(self):
        '''Establish a connection for sending data'''
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            # Iron python does not return right object type if not binary mode
            self.filehandler = self.sock.makefile('wb')
            self.streamhandler = StreamHandler(self.filehandler)
        except socket.error, e:
            print('unable to open socket to "%s:%s" error: %s'
                  % (self.host, self.port, str(e)))
            self.sock = None
            self.filehandler = None

    def _send_socket(self, name, *args):
        try:
            if self.filehandler:
                packet = (name, args)
                self.streamhandler.dump(packet)
                self.filehandler.flush()
        except Exception:
            import traceback
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()
            raise


class RobotDebugger(object):

    def __init__(self, pause_on_failure=False):
        self._state = 'running'
        self._keyword_level = 0
        self._pause_when_on_level = -1
        self._pause_on_failure = pause_on_failure
        self._resume = threading.Event()

    @staticmethod
    def is_breakpoint(name, attrs):
        return name == 'BuiltIn.Comment' and attrs['args'] == ['PAUSE']

    def pause(self):
        self._resume.clear()
        self._state = 'pause'

    def pause_on_failure(self, pause):
        self._pause_on_failure = pause

    def resume(self):
        self._state = 'running'
        self._pause_when_on_level = -1
        self._resume.set()

    def step_next(self):
        self._state = 'step_next'
        self._resume.set()

    def step_over(self):
        self._state = 'step_over'
        self._resume.set()

    def start_keyword(self):
        while self._state == 'pause':
            self._resume.wait()
            self._resume.clear()
        if self._state == 'step_next':
            self._state = 'pause'
        elif self._state == 'step_over':
            self._pause_when_on_level = self._keyword_level
            self._state = 'resume'
        self._keyword_level += 1

    def end_keyword(self, passed=True):
        self._keyword_level -= 1
        if self._keyword_level == self._pause_when_on_level \
        or (self._pause_on_failure and not passed):
            self._state = 'pause'

    def is_paused(self):
        return self._state == 'pause'


class RobotKillerServer(SocketServer.TCPServer):
    allow_reuse_address = True
    def __init__(self, debugger):
        SocketServer.TCPServer.__init__(self, ("",0), RobotKillerHandler)
        self.debugger = debugger

class RobotKillerHandler(SocketServer.StreamRequestHandler):
    def handle(self):
        data = self.request.makefile('r').read().strip()
        if data == 'kill':
            self._signal_kill()
        elif data == 'pause':
            self.server.debugger.pause()
        elif data == 'resume':
            self.server.debugger.resume()
        elif data == 'step_next':
            self.server.debugger.step_next()
        elif data == 'step_over':
            self.server.debugger.step_over()
        elif data == 'pause_on_failure':
            self.server.debugger.pause_on_failure(True)
        elif data == 'do_not_pause_on_failure':
            self.server.debugger.pause_on_failure(False)

    @staticmethod
    def _signal_kill():
        try:
            STOP_SIGNAL_MONITOR(1,'')
        except ExecutionFailed:
            pass


# NOTE: Moved to bottom of TestRunnerAgent per feedback in pull request,
#       so jybot doesn't encounter issues. Special imports at top of file.
class StreamError(Exception):
    """
    Base class for EncodeError and DecodeError
    """
    pass


class EncodeError(StreamError):
    """
    This exception is raised when an unencodable object is passed to the
    dump() method or function.
    """
    wrapped_exceptions = (pickle.PicklingError, )


class DecodeError(StreamError):
    """
    This exception is raised when there is a problem decoding an object,
    such as a security violation.

    Note that other exceptions may also be raised during decoding, including
    AttributeError, EOFError, ImportError, and IndexError.
    """
    # NOTE: No JSONDecodeError in json in stdlib for python >= 2.6
    wrapped_exceptions = (pickle.UnpicklingError,)
    if _JSONAVAIL:
        if hasattr(json, 'JSONDecodeError'):
            wrapped_exceptions = (pickle.UnpicklingError, json.JSONDecodeError)

def dump(obj, fp):
    StreamHandler(fp).dump(obj)

def load(fp):
    return StreamHandler(fp).load()

def dumps(obj):
    """
    Similar method to json dumps, prepending data with message length
    header. Replaces pickle.dumps, so can be used in place without
    the memory leaks on receiving side in pickle.loads (related to
    memoization of data)
    
    NOTE: Protocol is ignored when json representation is used
    """
    fp = StringIO()
    StreamHandler(fp).dump(obj)
    return fp.getvalue()

def loads(s):
    """
    Reads in json message or pickle message prepended with message length
    header from a string. Message is expected to be encoded by this class as
    well, to have same message length header type.
    
    Specifically replaces pickle.loads as that function/method has serious
    memory leak issues with long term use of same Unpickler object for
    encoding data to send, specifically related to memoization of data to
    encode.
    """
    fp = StringIO(s)
    return StreamHandler(fp).load()


class StreamHandler(object):
    '''
    This class provides a common streaming approach for the purpose
    of reliably sending data over a socket interface. Replaces usage of
    Unpickler.load where possible with JSON format prepended by message length
    header. Uses json in python stdlib (in python >= 2.6) or simplejson (in
    python < 2.6). If neither are available, falls back to pickle.Pickler and
    pickle.Unpickler, attempting to eliminate memory leakage where possible at
    the expense of CPU usage (by not re-using Pickler or Unpickler objects).
    
    NOTE: StreamHandler currently assumes that same python version is installed
    on both sides of reading/writing (or simplejson is loaded in case of one
    side or other using python < 2.6). This could be resolved by requiring an
    initial header with json vs pickle determination from the writing side, but
    would considerably complicate the protocol(s) further (handshake would need
    to occur at least, and assumes encoding is used over a socket, etc.)
    
    json.raw_decode could be used rather than prepending with a message header
    in theory (assuming json is available), but performance of repeatedly
    failing to parse written data would make this an unworkable solution in
    many cases.
    '''
    loads = staticmethod(loads)
    dumps = staticmethod(dumps)
    
    def __init__(self, fp):
        """
        Stream handler that encodes objects as either JSON (if available) with
        message length header prepended for sending over a socket, or as a
        pickled object if using python < 2.6 and simplejson is not installed.
        
        Since pickle.load has memory leak issues with memoization (remembers
        absolutely everything decoded since instantiation), json is a preferred
        method to encode/decode for long running processes which pass large
        amounts of data back and forth.
        """
        if _JSONAVAIL:
            self._json_encoder = json.JSONEncoder(separators=(',', ':'),
                                        sort_keys=True).encode
            self._json_decoder = json.JSONDecoder(strict=False).decode
        else:
            def json_not_impl(dummy):
                raise NotImplementedError(
                    'Python version < 2.6 and simplejson not installed. Please'
                    ' install simplejson.')
            self._json_decoder = staticmethod(json_not_impl)
            self._json_encoder = staticmethod(json_not_impl)
        self.fp = fp

    def dump(self, obj):
        """
        Similar method to json dump, prepending data with message length
        header. Replaces pickle.dump, so can be used in place without
        the memory leaks on receiving side in pickle.load (related to
        memoization of data)
        
        NOTE: Protocol is ignored when json representation is used
        """
        # NOTE: Slightly less efficient than doing iterencode directly into the
        #       fp, however difference is negligable and reduces complexity of
        #       of the StreamHandler class (treating pickle and json the same)
        write_list = []
        if _JSONAVAIL:
            write_list.append('J')
            s = self._json_encoder(obj)
            write_list.extend([str(len(s)), '|', s])
        else:
            write_list.append('P')
            s = pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)
            write_list.extend([str(len(s)), '|', s])
        self.fp.write(''.join(write_list))
        #self.fp.flush()

    def load(self):
        """
        Reads in json message prepended with message length header from a file
        (or socket, or other .read() enabled object). Message is expected to be
        encoded by this class as well, to have same message length header type.
        
        Specifically replaces pickle.load as that function/method has serious
        memory leak issues with long term use of same Unpickler object for
        encoding data to send, specifically related to memoization of data to
        encode.
        """
        header = self._load_header()
        msgtype = header[0]
        msglen = header[1:]
        if not msglen.isdigit():
            raise DecodeError('Message header not valid: %r' % header)
        msglen = int(msglen)
        buff = StringIO()
        # Don't use StringIO.len for sizing, reports string len not bytes
        buff.write(self.fp.read(msglen))
        try:
            if msgtype == 'J':
                return self._json_decoder(buff.getvalue())
            elif msgtype == 'P':
                return pickle.loads(buff.getvalue())
            else:
                raise DecodeError("Message type %r not supported" % msgtype)
        except DecodeError.wrapped_exceptions, e:
            raise DecodeError(str(e))
        
    def _load_header(self):
        """
        Load in just the header bit from a socket/file pointer
        """
        buff = StringIO()
        while len(buff.getvalue()) == 0 or buff.getvalue()[-1] != '|':
            recv_char = self.fp.read(1)
            if not recv_char:
                raise EOFError('File/Socket closed while reading load header')
            buff.write(recv_char)
        return buff.getvalue()[:-1]

########NEW FILE########
__FILENAME__ = testrunnerplugin
# Copyright 2010 Orbitz WorldWide
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Modified by NSN
#  Copyright 2010-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

'''A plugin for running tests from within RIDE

Some icons courtesy Mark James and provided under a creative commons
license.  See http://www.famfamfam.com/lab/icons/silk

Note: this plugin creates a temporary directory for use while a test
is running. This directory is normally removed when RIDE exists. If
RIDE is shut down abnormally this directory may not get removed. The
directories that are created match the pattern RIDE*.d and are in a
temporary directory appropriate for the platform (for example, on
linux it's /tmp).

You can safely manually remove these directories, except for the one
being used for a currently running test.
'''
from Queue import Queue
import datetime
import time
import os
import sys
import posixpath
import re
from posixpath import curdir, sep, pardir, join
from robot.output import LEVELS
from robot.utils import robottime
from robotide.action.shortcut import localize_shortcuts
from robotide.contrib.testrunner.runprofiles import CustomScriptProfile
from robotide.contrib.testrunner.testrunner import TestRunner
from robotide.publish.messages import RideTestSelectedForRunningChanged, RideNewProject

ON_POSIX = 'posix' in sys.builtin_module_names

import wx
import wx.stc
from wx.lib.embeddedimage import PyEmbeddedImage
from robotide.pluginapi import Plugin, ActionInfo
from robotide.contrib.testrunner import runprofiles
from robotide.widgets import Label, ImageProvider
from robotide.context import IS_WINDOWS, IS_MAC

ID_RUN = wx.NewId()
ID_STOP = wx.NewId()
ID_PAUSE = wx.NewId()
ID_CONTINUE = wx.NewId()
ID_STEP_NEXT = wx.NewId()
ID_STEP_OVER = wx.NewId()
ID_SHOW_REPORT = wx.NewId()
ID_SHOW_LOG = wx.NewId()
ID_AUTOSAVE = wx.NewId()
ID_PAUSE_ON_FAILURE = wx.NewId()
ID_SHOW_MESSAGE_LOG = wx.NewId()
STYLE_STDERR = 2


try:
    from os.path import relpath
except ImportError:
    # the python 2.6 os.path package provides a relpath() function,
    # but we're running 2.5 so we have to roll our own
    def relpath(path, start=curdir):
        """Return a relative version of a path"""
        if not path:
            raise ValueError("no path specified")
        start_list = posixpath.abspath(start).split(sep)
        path_list = posixpath.abspath(path).split(sep)
        # Work out how much of the filepath is shared by start and path.
        i = len(posixpath.commonprefix([start_list, path_list]))
        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]
        if not rel_list:
            return curdir
        return join(*rel_list)

def _RunProfile(name, run_prefix):
    return type('Profile', (runprofiles.PybotProfile,),
                {'name': name, 'get_command': lambda self: run_prefix})


class TestRunnerPlugin(Plugin):
    """A plugin for running tests from within RIDE"""
    defaults = {"auto_save": False,
                "show_message_log": True,
                "profile": "pybot",
                "sash_position": 200,
                "runprofiles": [('jybot', 'jybot' + ('.bat' if os.name == 'nt' else ''))]}
    report_regex = re.compile("^Report: {2}(.*\.html)$", re.MULTILINE)
    log_regex = re.compile("^Log: {5}(.*\.html)$", re.MULTILINE)
    title = "Run"

    def __init__(self, application=None):
        Plugin.__init__(self, application, initially_enabled=True,
                        default_settings=self.defaults)
        self.version = "3.01"
        self.metadata = {"url": "http://code.google.com/p/robotframework-ride/wiki/TestRunnerPlugin"}
        self._reload_timer = None
        self._frame = application.frame
        self._report_file = None
        self._log_file = None
        self._controls = {}
        self._running = False
        self._currently_executing_keyword = None
        self._test_runner = TestRunner(application.model)
        self._register_shortcuts()
        self._min_log_level_number = LEVELS['INFO']
        self._names_to_run = set()

    def _register_shortcuts(self):
        self.register_shortcut('CtrlCmd-C', self._copy_from_out)
        self.register_shortcut('CtrlCmd-L', self.OnShowLog)
        self.register_shortcut('CtrlCmd-R', self.OnShowReport)
        if IS_WINDOWS or IS_MAC:
            self.register_shortcut('Del', self._delete_pressed)

    def _delete_pressed(self, event):
        if self.notebook.current_page_title != self.title:
            return
        self.get_current_profile().delete_pressed()

    def _copy_from_out(self, event):
        if self.notebook.current_page_title != self.title:
            return
        if self.out.GetSTCFocus():
            self.out.Copy()
            return
        if self.message_log.GetSTCFocus():
            self.message_log.Copy()
            return

    def enable(self):
        self.tree.set_checkboxes_for_tests()
        self._read_run_profiles()
        self._register_actions()
        self._build_ui()
        self.SetProfile(self.profile)
        self._subscribe_to_events()
        self._test_runner.enable(self._post_result)
        self._set_stopped()

    def _register_actions(self):
        run_action_info = ActionInfo("Tools", "Run Tests", self.OnRun, None,
                                     "F8", ImageProvider().TOOLBAR_PLAY, "Run the selected tests", position=10)
        self._run_action = self.register_action(run_action_info)
        stop_action_info = ActionInfo("Tools", "Stop Test Run", self.OnStop, None,
                                      "CtrlCmd-F8", ImageProvider().TOOLBAR_STOP, "Stop a running test",position=11)
        self._stop_action = self.register_action(stop_action_info)

    def _read_run_profiles(self):
        self._read_run_profiles_from_config()
        self._read_run_profiles_from_classes()

    def _read_run_profiles_from_config(self):
        #Have to keep reference so that these classes are not garbage collected
        self._profile_classes_from_config = [_RunProfile(name, run_prefix)
                                             for name, run_prefix in self.runprofiles]

    def _read_run_profiles_from_classes(self):
        for profile in self._get_all_subclasses(runprofiles.BaseProfile):
            self._test_runner.add_profile(profile.name, profile(plugin=self))

    def _get_all_subclasses(self, class_):
        classes = []
        for sub_class in class_.__subclasses__():
            classes += [sub_class] + self._get_all_subclasses(sub_class)
        return classes

    def _subscribe_to_events(self):
        self.subscribe(self.OnTestSelectedForRunningChanged, RideTestSelectedForRunningChanged)

    def OnTestSelectedForRunningChanged(self, message):
        self._names_to_run = message.tests

    def disable(self):
        self._remove_from_notebook()
        self._test_runner.clear_server()
        self.unsubscribe_all()
        self.unregister_actions()

    def OnClose(self, evt):
        '''Shut down the running services and processes'''
        self._test_runner.kill_process()
        if self._process_timer:
            self._process_timer.Stop()
        self._test_runner.shutdown_server()

    def OnAutoSaveCheckbox(self, evt):
        '''Called when the user clicks on the "Auto Save" checkbox'''
        self.save_setting("auto_save", evt.IsChecked())

    def OnShowHideMessageLog(self, evt):
        checked = evt.IsChecked()
        self.save_setting("show_message_log", checked)
        if checked:
            self._show_message_log()
        else:
            self._hide_message_log()

    def OnPauseOnFailureCheckbox(self, evt):
        self._test_runner.set_pause_on_failure(evt.IsChecked())

    def _show_message_log(self):
        self.message_log = self._create_output_textctrl()
        self._right_panel.GetSizer().Add(self.message_log, 1, wx.EXPAND)
        self._right_panel.GetSizer().Layout()

    def _hide_message_log(self):
        self._clear_text(self.message_log)
        self._right_panel.RemoveChild(self.message_log)
        self.message_log.Destroy()
        self.message_log = None
        self._right_panel.GetSizer().Layout()

    def OnStop(self, event):
        """Called when the user clicks the "Stop" button

        This sends a SIGINT to the running process, with the
        same effect as typing control-c when running from the
        command line."""
        self._AppendText(self.out, '[ SENDING STOP SIGNAL ]\n', source='stderr')
        self._test_runner.send_stop_signal()

    def OnPause(self, event):
        self._AppendText(self.out, '[ SENDING PAUSE SIGNAL ]\n')
        self._test_runner.send_pause_signal()

    def OnContinue(self, event):
        self._AppendText(self.out, '[ SENDING CONTINUE SIGNAL ]\n')
        self._test_runner.send_continue_signal()

    def OnStepNext(self, event):
        self._AppendText(self.out, '[ SENDING STEP NEXT SIGNAL ]\n')
        self._test_runner.send_step_next_signal()

    def OnStepOver(self, event):
        self._AppendText(self.out, '[ SENDING STEP OVER SIGNAL ]\n')
        self._test_runner.send_step_over_signal()

    def OnRun(self, event):
        '''Called when the user clicks the "Run" button'''
        if not self._can_start_running_tests():
            return
        self._initialize_ui_for_running()
        command = self._create_command()
        self._output("command: %s\n" % command)
        try:
            self._test_runner.run_command(command, self._get_current_working_dir())
            self._process_timer.Start(41) # roughly 24fps
            self._set_running()
            self._progress_bar.Start()
        except Exception, e:
            self._set_stopped()
            self._output(str(e))
            wx.MessageBox("Could not start running tests with command '%s'" % command, "Error", wx.ICON_ERROR)

    def _create_command(self):
        command_as_list = self._test_runner.get_command(
            self.get_current_profile(),
            self.global_settings.get('pythonpath', None),
            self._get_monitor_width(),
            self._names_to_run)
        self._min_log_level_number = self._test_runner.get_message_log_level(command_as_list)
        command = self._format_command(command_as_list)
        return command

    def _get_current_working_dir(self):
        profile = self.get_current_profile()
        if profile.name == CustomScriptProfile.name:
            return profile.get_cwd()
        if not os.path.isdir(self.model.suite.source):
            return os.path.dirname(self.model.suite.source)
        return self.model.suite.source

    def _can_start_running_tests(self):
        if self._running or self.model.suite is None:
            return False
        if not self.is_unsaved_changes():
            return True
        if self.auto_save or self._ask_user_to_save_before_running():
            self.save_all_unsaved_changes()
            return True
        return False

    def _ask_user_to_save_before_running(self):
        ret = wx.MessageBox('There are unsaved modifications.\n'
                            'Do you want to save all changes and run the tests?',
                            'Unsaved Modifications',
                            wx.ICON_QUESTION|wx.YES_NO)
        return ret == wx.YES

    def _initialize_ui_for_running(self):
        self._show_notebook_tab()
        self._clear_output_window()
        self.local_toolbar.EnableTool(ID_SHOW_REPORT, False)
        self.local_toolbar.EnableTool(ID_SHOW_LOG, False)
        self._report_file = self._log_file = None
        self._messages_log_texts = Queue()

    def _clear_output_window(self):
        self._clear_text(self.out)
        if self.message_log:
            self._clear_text(self.message_log)

    def _clear_text(self, textctrl):
        textctrl.SetReadOnly(False)
        textctrl.ClearAll()
        textctrl.SetReadOnly(True)

    def OnShowReport(self, evt):
        '''Called when the user clicks on the "Report" button'''
        if self._report_file:
            wx.LaunchDefaultBrowser("file:%s" % os.path.abspath(self._report_file))

    def OnShowLog(self, evt):
        '''Called when the user clicks on the "Log" button'''
        if self._log_file:
            wx.LaunchDefaultBrowser("file:%s" % os.path.abspath(self._log_file))

    def OnProfileSelection(self, event):
        self.save_setting("profile", event.GetString())
        self.SetProfile(self.profile)

    def OnProcessEnded(self, evt):
        output, errors = self._test_runner.get_output_and_errors()
        self._output(output)
        self._read_report_and_log_from_stdout_if_needed()
        if len(errors) > 0:
            self._output("unexpected error: " + errors)
        self._progress_bar.Stop()
        if self._process_timer:
            self._process_timer.Stop()
        self._set_stopped()
        self._progress_bar.Stop()
        now = datetime.datetime.now()
        self._output("\ntest finished %s" % robottime.format_time(now.timetuple()))
        self._set_stopped()
        self._test_runner.command_ended()

    def _read_report_and_log_from_stdout_if_needed(self):
        output = self.out.GetText()
        if not self._report_file:
            self._report_file = self._get_report_or_log(output, self.report_regex)
            if self._report_file:
                self.local_toolbar.EnableTool(ID_SHOW_REPORT, True)
        if not self._log_file:
            self._log_file = self._get_report_or_log(output, self.log_regex)
            if self._log_file:
                self.local_toolbar.EnableTool(ID_SHOW_LOG, True)

    def _get_report_or_log(self, output, regex):
        res = regex.search(output)
        return res.group(1) if res and os.path.isfile(res.group(1)) else None

    def OnTimer(self, evt):
        """Get process output"""
        if not self._test_runner.is_running():
            self.OnProcessEnded(None)
            return
        out_buffer, err_buffer = self._test_runner.get_output_and_errors()
        if len(out_buffer) > 0:
            self._output(out_buffer, source="stdout")
        if len(err_buffer) > 0:
            if self.GetLastOutputChar() != "\n":
                # Robot prints partial lines to stdout to make the
                # interactive experience better. It all goes to
                # heck in a handbasket if something shows up on
                # stderr. So, to fix that we'll add a newline if
                # the previous character isn't a newline.
                self._output("\n", source="stdout")
            self._output(err_buffer, source="stderr")
        if self.message_log and not self._messages_log_texts.empty():
            texts = []
            while not self._messages_log_texts.empty():
                texts += [self._messages_log_texts.get()]
            self._AppendText(self.message_log, '\n'+'\n'.join(texts))

    def GetLastOutputChar(self):
        '''Return the last character in the output window'''
        pos = self.out.PositionBefore(self.out.GetLength())
        char = self.out.GetCharAt(pos)
        return chr(char)

    def _format_command(self, argv):
        '''Quote a list as if it were a command line command

        This isn't perfect but seems to work for the normal use
        cases. I'm not entirely sure what the perfect algorithm
        is since *nix and windows have different quoting
        behaviors.
        '''
        result = []
        for arg in argv:
            if "'" in arg or " " in arg:
                # for windows, if there are spaces we need to use
                # double quotes. Single quotes cause problems
                result.append('"%s"' % arg)
            elif '"' in arg:
                result.append("'%s'" % arg)
            else:
                result.append(arg)
        return " ".join(result)

    def _show_notebook_tab(self):
        '''Show the Run notebook tab'''
        if not self.panel:
            self._build_notebook_tab()
            self._reload_model()
        self.show_tab(self.panel)

    def _AppendText(self, textctrl, string, source="stdout"):
        if not self.panel or not textctrl:
            return
        textctrl.update_scroll_width(string)
        # we need this information to decide whether to autoscroll or not
        new_text_start = textctrl.GetLength()
        linecount = textctrl.GetLineCount()
        lastVisibleLine = textctrl.GetFirstVisibleLine() + textctrl.LinesOnScreen() - 1

        textctrl.SetReadOnly(False)
        try:
            textctrl.AppendText(string)
        except UnicodeDecodeError,e:
            # I'm not sure why I sometimes get this, and I don't know what I can
            # do other than to ignore it.
            pass

        new_text_end = textctrl.GetLength()

        textctrl.StartStyling(new_text_start, 0x1f)
        if source == "stderr":
            textctrl.SetStyling(new_text_end-new_text_start, STYLE_STDERR)

        textctrl.SetReadOnly(True)
        if lastVisibleLine >= linecount-4:
            linecount = textctrl.GetLineCount()
            textctrl.ScrollToLine(linecount)

    def _get_monitor_width(self):
        # robot wants to know a fixed size for output, so calculate the
        # width of the window based on average width of a character. A
        # little is subtracted just to make sure there's a little margin
        out_width, _ = self.out.GetSizeTuple()
        char_width = self.out.GetCharWidth()
        return str(int(out_width/char_width)-10)

    def _build_ui(self):
        """Creates the UI for this plugin"""
        self._build_notebook_tab()

    def _remove_from_notebook(self):
        """Remove the tab for this plugin from the notebook"""
        if self.notebook:
            self.notebook.allow_closing(self.panel)
            self.notebook.delete_tab(self.panel)

    def _build_config_panel(self, parent):
        """Builds the configuration panel for this plugin"""
        panel = wx.Panel(parent, wx.ID_ANY, style=wx.BORDER_NONE|wx.TAB_TRAVERSAL)
        self.config_sizer = wx.BoxSizer(wx.VERTICAL)
        panel.SetSizer(self.config_sizer)
        self.config_panel = panel
        return panel

    def _output(self, string, source="stdout"):
        '''Put output to the text control'''
        self._AppendText(self.out, string, source)

    def _build_runner_toolbar(self):
        toolbar = wx.ToolBar(self.panel, wx.ID_ANY, style=wx.TB_HORIZONTAL|wx.TB_HORZ_TEXT)
        toolbar.AddLabelTool(ID_RUN,"Start", ImageProvider().TOOLBAR_PLAY, shortHelp="Start robot",
                             longHelp="Start running the robot test suite")
        toolbar.AddLabelTool(ID_STOP,"Stop", ImageProvider().TOOLBAR_STOP,
                             shortHelp="Stop a running test",
                             longHelp="Stop a running test")
        toolbar.AddLabelTool(ID_PAUSE, "Pause", ImageProvider().TOOLBAR_PAUSE,
            shortHelp="Pause test execution", longHelp="Pause test execution")
        toolbar.AddLabelTool(ID_CONTINUE, "Continue", ImageProvider().TOOLBAR_CONTINUE,
            shortHelp="Continue test execution", longHelp="Continue test execution")
        toolbar.AddLabelTool(ID_STEP_NEXT, "Next", ImageProvider().TOOLBAR_NEXT,
                    shortHelp="Step next", longHelp="Step next")
        toolbar.AddLabelTool(ID_STEP_OVER, "Step over", ImageProvider().TOOLBAR_NEXT,
                    shortHelp="Step over", longHelp="Step over")
        toolbar.Realize()
        self._bind_runner_toolbar_events(toolbar)
        return toolbar

    def _bind_runner_toolbar_events(self, toolbar):
        for event, callback, id in (
            (wx.EVT_TOOL, self.OnRun, ID_RUN),
            (wx.EVT_TOOL, self.OnStop, ID_STOP),
            (wx.EVT_TOOL, self.OnPause, ID_PAUSE),
            (wx.EVT_TOOL, self.OnContinue, ID_CONTINUE),
            (wx.EVT_TOOL, self.OnStepNext, ID_STEP_NEXT),
            (wx.EVT_TOOL, self.OnStepOver, ID_STEP_OVER)):
            toolbar.Bind(event, callback, id=id)

    def _build_local_toolbar(self):
        toolbar = wx.ToolBar(self.panel, wx.ID_ANY, style=wx.TB_HORIZONTAL|wx.TB_HORZ_TEXT)
        profileLabel = Label(toolbar, label="Execution Profile:  ")
        choices = self._test_runner.get_profile_names()
        self.choice = wx.Choice(toolbar, wx.ID_ANY, choices=choices)
        self.choice.SetToolTip(wx.ToolTip("Choose which method to use for running the tests"))
        toolbar.AddControl(profileLabel)
        toolbar.AddControl(self.choice)
        toolbar.AddSeparator()
        reportImage = getReportIconBitmap()
        logImage = getLogIconBitmap()
        toolbar.AddLabelTool(ID_SHOW_REPORT, " Report", reportImage,
                             shortHelp = localize_shortcuts("View Robot Report in Browser (CtrlCmd-R)"))
        toolbar.AddLabelTool(ID_SHOW_LOG, " Log", logImage,
                             shortHelp = localize_shortcuts("View Robot Log in Browser (CtrlCmd-L)"))
        toolbar.AddSeparator()
        # the toolbar API doesn't give us a way to specify padding which
        # is why the label has a couple spaces after the colon. gross,
        # but effective.
        self.savecb = wx.CheckBox(toolbar, ID_AUTOSAVE, " Autosave  ")
        self.savecb.SetToolTip(wx.ToolTip("Automatically save all changes before running"))
        self.savecb.SetValue(self.auto_save)
        toolbar.AddControl(self.savecb)

        self.pause_after_failure_cb = wx.CheckBox(toolbar, ID_PAUSE_ON_FAILURE, " Pause on failure  ")
        self.pause_after_failure_cb.SetToolTip(wx.ToolTip("Automatically pause after failing keyword"))
        self.pause_after_failure_cb.SetValue(False)
        toolbar.AddControl(self.pause_after_failure_cb)

        self.show_log_messages_checkbox = wx.CheckBox(toolbar, ID_SHOW_MESSAGE_LOG, ' Show message log  ')
        self.show_log_messages_checkbox.SetToolTip(wx.ToolTip('Show or hide message log'))
        self.show_log_messages_checkbox.SetValue(self.show_message_log)
        toolbar.AddControl(self.show_log_messages_checkbox)
        toolbar.EnableTool(ID_SHOW_LOG, False)
        toolbar.EnableTool(ID_SHOW_REPORT, False)
        toolbar.Realize()
        self._bind_toolbar_events(toolbar)
        return toolbar

    def _bind_toolbar_events(self, toolbar):
        for event, callback, id in (
            (wx.EVT_TOOL, self.OnShowReport, ID_SHOW_REPORT),
            (wx.EVT_TOOL, self.OnShowLog, ID_SHOW_LOG)):
            toolbar.Bind(event, callback, id=id)
        toolbar.Bind(wx.EVT_CHECKBOX, self.OnAutoSaveCheckbox, self.savecb)
        toolbar.Bind(wx.EVT_CHECKBOX, self.OnShowHideMessageLog, self.show_log_messages_checkbox)
        toolbar.Bind(wx.EVT_CHECKBOX, self.OnPauseOnFailureCheckbox, self.pause_after_failure_cb)
        toolbar.Bind(wx.EVT_CHOICE, self.OnProfileSelection, self.choice)

    def get_current_profile(self):
        return self._test_runner.get_profile(self.choice.GetStringSelection())

    def SetProfile(self, profile):
        '''Set the profile to be used to run tests'''
        items = self.choice.GetItems()
        if profile not in items:
            return
        choice_index = items.index(profile)
        self.choice.Select(choice_index)
        p = self._test_runner.get_profile(profile)
        for child in self.config_sizer.GetChildren():
            child.GetWindow().Hide()
            self.config_sizer.Remove(child.GetWindow())
        toolbar = p.get_toolbar(self.config_panel)

        if toolbar:
            self.config_sizer.Add(toolbar, 0, wx.EXPAND)
            self.config_sizer.ShowItems(True)
            self.config_sizer.Layout()
            parent = self.config_panel.Parent
            parent_sizer = parent.GetSizer()
            parent_sizer.Layout()

    def _build_notebook_tab(self):
        panel = wx.Panel(self.notebook)
        self.panel = panel
        self.runner_toolbar = self._build_runner_toolbar()
        self.local_toolbar = self._build_local_toolbar()
        self.header_panel = wx.Panel(self.panel)
        self.configPanel = self._build_config_panel(panel)
        self._right_panel = wx.Panel(self.panel)
        self.out = self._create_output_textctrl()
        self.message_log = self._create_output_textctrl() if self.show_message_log else None
        self._clear_output_window()

        self._progress_bar = ProgressBar(self._right_panel)

        right_panel_sizer = wx.BoxSizer(wx.VERTICAL)
        right_panel_sizer.Add(self._progress_bar, 0, wx.EXPAND)
        right_panel_sizer.Add(self.out, 1, wx.EXPAND)
        if self.message_log:
            right_panel_sizer.Add(self.message_log, 1, wx.EXPAND)
        self._right_panel.SetSizer(right_panel_sizer)

        header_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.header_panel.SetSizer(header_sizer)

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.local_toolbar, 0, wx.EXPAND)
        sizer.Add(self.runner_toolbar, 0, wx.EXPAND)
        sizer.Add(self.configPanel, 0, wx.EXPAND|wx.TOP|wx.RIGHT, 4)
        sizer.Add(wx.StaticLine(self.panel), 0, wx.EXPAND|wx.BOTTOM|wx.TOP, 2)
        sizer.Add(self.header_panel, 0, wx.EXPAND|wx.RIGHT, 10)
        sizer.Add(self._right_panel, 1, wx.EXPAND|wx.RIGHT, 8)
        panel.SetSizer(sizer)

        self._process_timer = wx.Timer(self.panel)
        self.panel.Bind(wx.EVT_TIMER, self.OnTimer)

        self.panel.Bind(wx.EVT_WINDOW_DESTROY, self.OnClose)

        self.add_tab(panel, self.title, allow_closing=False)

    def _create_output_textctrl(self):
        textctrl = OutputStyledTextCtrl(self._right_panel)
        font = self._create_font()
        face = font.GetFaceName()
        size = font.GetPointSize()
        textctrl.SetFont(font)
        textctrl.StyleSetSpec(wx.stc.STC_STYLE_DEFAULT,"face:%s,size:%d" % (face, size))
        textctrl.StyleSetSpec(STYLE_STDERR, "fore:#b22222") # firebrick
        textctrl.SetScrollWidth(100)
        self._set_margins(textctrl)
        textctrl.SetReadOnly(True)
        return textctrl

    def _set_margins(self, out):
        out.SetMarginLeft(10)
        out.SetMarginWidth(0,0)
        out.SetMarginWidth(1,0)
        out.SetMarginWidth(2,0)
        out.SetMarginWidth(3,0)

    def _create_font(self):
        font=wx.SystemSettings.GetFont(wx.SYS_SYSTEM_FIXED_FONT)
        if not font.IsFixedWidth():
            # fixed width fonts are typically a little bigger than their variable width
            # peers so subtract one from the point size.
            font = wx.Font(font.GetPointSize()-1, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
        return font

    def _post_result(self, event, *args):
        '''Endpoint of the listener interface

        This is called via the listener interface. It has an event such as "start_suite",
        "start_test", etc, along with metadata about the event. We use this data to update
        the tree and statusbar.'''
        if not self.panel:
            # this should only happen if the notebook tab got deleted
            # out from under us. In the immortal words of Jar Jar
            # Binks, "How rude!"
            return
        if event == 'start_test':
            self._handle_start_test(args)
        if event == 'end_test':
            self._handle_end_test(args)
        if event == 'report_file':
            self._handle_report_file(args)
        if event == 'log_file':
            self._handle_log_file(args)
        if event == 'start_keyword':
            self._handle_start_keyword(args)
        if event == 'end_keyword':
            self._handle_end_keyword()
        if event == 'log_message':
            self._handle_log_message(args)
        if event == 'paused':
            wx.CallAfter(self._set_paused)
            self._append_to_message_log('<<  PAUSED  >>')
        if event == 'continue':
            wx.CallAfter(self._set_continue)
            self._append_to_message_log('<< CONTINUE >>')

    def _handle_start_test(self, args):
        longname = args[1]['longname']
        self._append_to_message_log('Starting test: %s' % longname)

    def _append_to_message_log(self, text):
        if self.show_message_log:
            self._messages_log_texts.put(text)

    def _handle_end_test(self, args):
        longname = args[1]['longname']
        self._append_to_message_log('Ending test:   %s\n' % longname)
        if args[1]['status'] == 'PASS':
            self._progress_bar.add_pass()
        else:
            self._progress_bar.add_fail()

    def _handle_report_file(self, args):
        self._report_file = args[0]
        wx.CallAfter(self.local_toolbar.EnableTool, ID_SHOW_REPORT, True)

    def _handle_log_file(self, args):
        self._log_file = args[0]
        wx.CallAfter(self.local_toolbar.EnableTool, ID_SHOW_LOG, True)

    def _handle_start_keyword(self, args):
        self._progress_bar.set_current_keyword(args[0])

    def _handle_end_keyword(self):
        self._progress_bar.empty_current_keyword()

    def _handle_log_message(self, args):
        a = args[0]
        if self.show_message_log and LEVELS[a['level']] >= self._min_log_level_number:
            prefix = '%s : %s : ' % (a['timestamp'], a['level'].rjust(5))
            message = a['message']
            if '\n' in message:
                message = '\n'+message
            self._messages_log_texts.put(prefix+message)

    def _set_running(self):
        self._run_action.disable()
        self._stop_action.enable()
        self._enable_toolbar(False, True)
        self._running = True
        self._test_runner.test_execution_started()

    def _set_paused(self):
        self._run_action.disable()
        self._stop_action.enable()
        self._enable_toolbar(False, False)

    def _set_continue(self):
        self._run_action.disable()
        self._stop_action.enable()
        self._enable_toolbar(False, True)

    def _set_stopped(self):
        self._run_action.enable()
        self._stop_action.disable()
        self._enable_toolbar(True, False)
        self._running = False

    def _enable_toolbar(self, run, paused):
        stop = not run
        debug = stop and not paused
        for id, enabled in ((ID_RUN, run),
                            (ID_STOP, stop),
                            (ID_PAUSE, paused),
                            (ID_CONTINUE, debug),
                            (ID_STEP_NEXT, debug),
                            (ID_STEP_OVER, debug)):
            self.runner_toolbar.EnableTool(id, enabled)


class ProgressBar(wx.Panel):
    '''A progress bar for the test runner plugin'''
    def __init__(self, parent):
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        self._sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._gauge = wx.Gauge(self, size=(100, 10))
        self._label = Label(self)
        self._sizer.Add(self._label, 1, wx.EXPAND|wx.LEFT, 10)
        self._sizer.Add(self._gauge, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 10)
        self._sizer.Layout()
        self.SetSizer(self._sizer)
        self._gauge.Hide()
        self._default_colour = parent.GetBackgroundColour()
        self._timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self._initialize_state()

    def _initialize_state(self):
        self._pass = 0
        self._fail = 0
        self._current_keywords = []

    def set_current_keyword(self, name):
        self._current_keywords.append(name)

    def empty_current_keyword(self):
        self._current_keywords.pop()

    def OnTimer(self, event):
        '''A handler for timer events; it updates the statusbar'''
        self._gauge.Show()
        self._gauge.Pulse()
        self._update_message()

    def Start(self):
        '''Signals the start of a test run; initialize progressbar.'''
        self._initialize_state()
        self._start_time = time.time()
        self._gauge.Show()
        self._sizer.Layout()
        self.SetBackgroundColour(self._default_colour)
        self._timer.Start(50)

    def Stop(self):
        '''Signals the end of a test run'''
        self._gauge.Hide()
        self._timer.Stop()

    def add_pass(self):
        '''Add one to the passed count'''
        self._pass += 1

    def add_fail(self):
        '''Add one to the failed count'''
        self._fail += 1

    def _update_message(self):
        '''Update the displayed elapsed time, passed and failed counts'''
        elapsed = time.time()-self._start_time
        message = "elapsed time: %s     pass: %s     fail: %s" % (
            secondsToString(elapsed), self._pass, self._fail)
        message += self._get_current_keyword_text()
        self._label.SetLabel(message)
        if self._fail > 0:
            self.SetBackgroundColour("#FF8E8E")
        elif self._pass > 0:
            self.SetBackgroundColour("#9FCC9F")
        # not sure why this is required, but without it the background
        # colors don't look right on Windows
        self.Refresh()

    def _get_current_keyword_text(self):
        if not self._current_keywords:
            return ''
        return '     current keyword: '+self._fix_size(' -> '.join(self._current_keywords), 50)

    def _fix_size(self, text, max_length):
        if len(text) <= max_length:
            return text
        return '...'+text[3-max_length:]


class OutputStyledTextCtrl(wx.stc.StyledTextCtrl):

    def __init__(self, parent):
        wx.stc.StyledTextCtrl.__init__(self, parent, wx.ID_ANY, style=wx.SUNKEN_BORDER)
        self._max_row_len = 0

    def update_scroll_width(self, string):
        string_max_len = max(len(s) for s in string.split('\n'))
        if string_max_len <= self._max_row_len:
            return
        self._max_row_len = string_max_len
        try:
            width, _ = self.GetTextExtent(string)
            if self.GetScrollWidth() < width + 50:
                self.SetScrollWidth(width + 50)
        except UnicodeDecodeError:
            pass


# stole this off the internet. Nifty.
def secondsToString(t):
    '''Convert a number of seconds to a string of the form HH:MM:SS'''
    return "%d:%02d:%02d" % \
        reduce(lambda ll,b : divmod(ll[0],b) + ll[1:],
            [(t,),60, 60])



Robot = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAnNJ"
    "REFUOI2Vkb1Pk3EQxz/PW6EvUN6sEQFBIwUlMBgTMZFZJzcXEzeJiXE1MXFi4g8gGhjcHDA4"
    "iFGDKNFojBoJaqQItgrlpYUW0ZZSaJ/ndw5INQZIvMttd5/73vcQEbYrpRSPes5K7NsrUaK2"
    "7RERdHaJnLeV4tL9u7XsDNA0qKhrw19erf0nQABBRBEeGyT86YUgIKjtF4nIP+PC0tsRGb11"
    "g+hcnAqvl6ZjrQQ7r664ygIV/8opAATIpr53fui53psZfoqsZcn5TEyXjlrPQcNBvMdO0XG5"
    "S4M/GPNvWnQ23Ptg4hW1xxsxLAssE0MHHIWgM/f+Me35a1iWmy1IASCOw+f+XhwMQuML/Eik"
    "WVA6mlLU6A7+AwEqKxSjN7vlxJUubUtEwcTJ8XF5PfAA23ZIJTMkppdoathLS7CO5EyS1M8M"
    "GjpDdwcR/vhWUHAo2KjtaWmWeWeJtlNH0DqamPwSxTQtTl88g21nWUlG6bhwficThWQsKpfO"
    "tWMkBFGQXc9j6RYuw8F0WXgOe+i7F9LQTLZu0Au/V8Lzh32UFBfjK3dRWlVEoMaDf59JSbUH"
    "d5ULv7uI+7e7RZT9+2+gC5sZ/Tom4U/P8PgMViVHWjZYNxxsl7Bh2uDTCFT7+Dw2ROjdw9/C"
    "BfN7fEp+LLxkMrxIKp0mGDxAc8s6dXvrQRc0TUfTYSocxs7rxBOrfHxzh3J/Tvz7TmImYhMs"
    "Rl4zG1lDicOT4RBHWyr5GBrH0DcvdGxFWUme+Zk0tY2lzM3NshyfxHDXo0fCEQb6R4hMx3Bs"
    "hTiCKMFtpsmoLHl7Ga8fRATHEcRRrCxnGBocIR6L8Qu2hlAKJu0L3QAAAABJRU5ErkJggg==")
getRobotBitmap = Robot.GetBitmap


MenuButton = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAKxJ"
    "REFUOI3t0jEKg0AUBNAxhmXX9QD2adLnJt7E2luIeB/PkCoQCG5lK8ifdZtNHyQRLGwy5Yd5"
    "/GKSGCP25LSr/QcAAOfPQ9/3MYSAZVngvQdJiAhEhFVVZT8BkpKmaZbnOZRS0FojhIBpmh6b"
    "Ppjn+ULyqZSyxhiM44hhGEiyXAOStSG1bVuIyMtaq51zJHltmsZtBgCgruuC5N17f+u6brX8"
    "Fdia43dwPPAGncZYbvceeuMAAAAASUVORK5CYII=")
getMenuButtonBitmap = MenuButton.GetBitmap


ProcessStop = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0"
    "RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJJSURBVDjLpZNNbxJRFIb7A/wF"
    "/A5YunRDovsmRk3cmLAxcdG0uiFuXDSmkBlLFNOmtYFKgibUtqlJG6UjiGksU0oZPgQs0KEw"
    "Mw4Dw8dQjnPuMCNq48abvJub87zn4547BQBTk7q2CDZdDl1OXdNjOcd3tj/jJ8Eruuxzb2RX"
    "+NMpHT/MMUfHJwKbSgv7Bxnm9YciPRMSXRiDsb8ZjOGrwWjNzZ4UOL4pg6IOQLsYEbU6fajW"
    "RYgdpLilnYIbY00T08COcCrzTen2NMCj9ocgKgMQdLV7Q3KnqH3YTyQV/1YWTezEAPvCsjGz"
    "CTfkPtR/9IGXDNWkHlTFnmWysxfj7q/x2I4NDRxh5juNZf8LPm12ifBkimdAheI0smjgjH3N"
    "MtgzlmqCNx5tGnq4Abe9LIHLjS7IHQ3OJRWW1zcYZNFgOnl0LOCwmq0BgTEjgqbQoHSuQrGu"
    "EqO+dgFrgXUBWWJwyKaIAZaPcEXoWvD1uQjc8rBQ4FUio4oBLK+8sgycH7+kGUnpQUvVrF4x"
    "K4KomwuGQf6sQ14mV5GA8gesFhyB3TxdrjZhNAKSwSzXzIpgrtaBbLUDg+EI9j6nwe3btIZo"
    "exBsuHajCU6QjSlfBmaqbZIgr2f3Pl/l7vpyxjOai0S9Zd2R91GFF41Aqa1Z1eAyYeZcRQSP"
    "P6jMUlu/FmlylecDCfdqKMLFk3ko8zKZCfacLgmwHWVhnlriZrzv/l7lyc9072XJ9fjFNv10"
    "cYWhnvmEBS8tPPH4mVlPmL5DZy7/TP/znX8C6zgR9sd1gukAAAAASUVORK5CYII=")
getProcessStopBitmap = ProcessStop.GetBitmap

# page_white.png from http://www.famfamfam.com/lab/icons/silk
ReportIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0"
    "RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC4SURBVCjPdZFbDsIgEEWnrsMm"
    "7oGGfZrohxvU+Iq1TyjU60Bf1pac4Yc5YS4ZAtGWBMk/drQBOVwJlZrWYkLhsB8UV9K0BUrP"
    "Gy9cWbng2CtEEUmLGppPjRwpbixUKHBiZRS0p+ZGhvs4irNEvWD8heHpbsyDXznPhYFOyTjJ"
    "c13olIqzZCHBouE0FRMUjA+s1gTjaRgVFpqRwC8mfoXPPEVPS7LbRaJL2y7bOifRCTEli3U7"
    "BMWgLzKlW/CuebZPAAAAAElFTkSuQmCC")
getReportIconBitmap = ReportIcon.GetBitmap

# page_white_text.png from http://www.famfamfam.com/lab/icons/silk
LogIcon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0"
    "RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAADoSURBVBgZBcExblNBGAbA2cee"
    "gTRBuIKOgiihSZNTcC5LUHAihNJR0kGKCDcYJY6D3/77MdOinTvzAgCw8ysThIvn/VojIyMj"
    "IyPP+bS1sUQIV2s95pBDDvmbP/mdkft83tpYguZq5Jh/OeaYh+yzy8hTHvNlaxNNczm+la9O"
    "Tlar1UdA/+C2A4trRCnD3jS8BB1obq2Gk6GU6QbQAS4BUaYSQAf4bhhKKTFdAzrAOwAxEUAH"
    "+KEM01SY3gM6wBsEAQB0gJ+maZoC3gI6iPYaAIBJsiRmHU0AALOeFC3aK2cWAACUXe7+AwO0"
    "lc9eTHYTAAAAAElFTkSuQmCC")
getLogIconBitmap = LogIcon.GetBitmap


########NEW FILE########
__FILENAME__ = usages
USAGE = """\
Robot Framework -- A generic test automation framework

Usage:  pybot|jybot|ipybot [options] data_sources
   or:  python|jython|ipy -m robot.run [options] data_sources
   or:  python|jython|ipy path/to/robot/run.py [options] data_sources
   or:  java -jar robotframework.jar run [options] data_sources

Robot Framework is a Python-based keyword-driven test automation framework for
acceptance level testing and acceptance test-driven development (ATDD). It has
an easy-to-use tabular syntax for creating test cases and its testing
capabilities can be extended by test libraries implemented either with Python
or Java. Users can also create new keywords from existing ones using the same
simple syntax that is used for creating test cases.

Depending is Robot Framework installed using Python, Jython, or IronPython
interpreter, it has a start-up script, `pybot`, `jybot` or `ipybot`,
respectively. Alternatively, it is possible to directly execute `robot.run`
module (e.g. `python -m robot.run`) or `robot/run.py` script using a selected
interpreter. Finally, there is also a standalone JAR distribution.

Data sources given to Robot Framework are either test case files or directories
containing them and/or other directories. Single test case file creates a test
suite containing all the test cases in it and a directory containing test case
files creates a higher level test suite with test case files or other
directories as sub test suites. If multiple data sources are given, a virtual
top level suite containing suites generated from given data sources is created.

By default Robot Framework creates an XML output file and a log and a report in
HTML format, but this can be configured using various options listed below.
Outputs in HTML format are for human consumption and XML output for integration
with other systems. XML outputs can also be combined and otherwise further
processed with `rebot` tool. Run `rebot --help` for more information.

Robot Framework is open source software released under Apache License 2.0.
Its copyrights are owned and development supported by Nokia Siemens Networks.
For more information about the framework see http://robotframework.org.

Options
=======

 -N --name name           Set the name of the top level test suite. Underscores
                          in the name are converted to spaces. Default name is
                          created from the name of the executed data source.
 -D --doc documentation   Set the documentation of the top level test suite.
                          Underscores in the documentation are converted to
                          spaces and it may also contain simple HTML formatting
                          (e.g. *bold* and http://url/).
 -M --metadata name:value *  Set metadata of the top level test suite.
                          Underscores in the name and value are converted to
                          spaces. Value can contain same HTML formatting as
                          --doc. Example: `--metadata version:1.2`
 -G --settag tag *        Sets given tag(s) to all executed test cases.
 -t --test name *         Select test cases to run by name or long name. Name
                          is case and space insensitive and it can also be a
                          simple pattern where `*` matches anything and `?`
                          matches any char. If using `*` and `?` in the console
                          is problematic see --escape and --argumentfile.
 -s --suite name *        Select test suites to run by name. When this option
                          is used with --test, --include or --exclude, only
                          test cases in matching suites and also matching other
                          filtering criteria are selected. Name can be a simple
                          pattern similarly as with --test and it can contain
                          parent name separated with a dot. For example
                          `-s X.Y` selects suite `Y` only if its parent is `X`.
 -i --include tag *       Select test cases to run by tag. Similarly as name in
                          --test, tag is case and space insensitive. There are
                          three ways to include test based on tags:
                          1) One tag as a simple pattern. Tests having a tag
                          matching the pattern are included. Example: `it-*`
                          2) Two or more tags (or patterns) separated by `&` or
                          `AND`. Only tests having all these tags are included.
                          Examples: `tag1&tag2`, `smokeANDowner-*ANDit-10`
                          3) Two or more tags (or patterns) separated by `NOT`.
                          Tests having the first tag but not any of the latter
                          ones are included. Example: `it-10NOTsmoke`
 -e --exclude tag *       Select test cases not to run by tag. These tests are
                          not run even if they are included with --include.
                          Tags are excluded using the rules explained in
                          --include.
 -R --runfailed output    Select failed tests from an earlier output file to be
                          re-executed. Equivalent to selecting same tests
                          individually using --test option.
 -c --critical tag *      Tests having given tag are considered critical. If no
                          critical tags are set, all tags are critical. Tags
                          can be given as a pattern like e.g. with --test.
 -n --noncritical tag *   Tests with given tag are not critical even if they
                          have a tag set with --critical. Tag can be a pattern.
 -v --variable name:value *  Set variables in the test data. Only scalar
                          variables are supported and name is given without
                          `${}`. See --escape for how to use special characters
                          and --variablefile for a more powerful variable
                          setting mechanism that allows also list variables.
                          Examples:
                          --variable str:Hello  =>  ${str} = `Hello`
                          -v str:Hi_World -E space:_  =>  ${str} = `Hi World`
                          -v x: -v y:42  =>  ${x} = ``, ${y} = `42`
 -V --variablefile path *  File to read variables from (e.g. `path/vars.py`).
                          Example file:
                          |  import random
                          |  __all__ = [`scalar`, `LIST__var`, `integer`]
                          |  scalar = `Hello world!`
                          |  LIST__var = [`Hello`, `list`, `world`]
                          |  integer = random.randint(1,10)
                          =>
                          ${scalar} = `Hello world!`
                          @{var} = [`Hello`,`list`,`world`]
                          ${integer} = <random integer from 1 to 10>
 -d --outputdir dir       Where to create output files. The default is the
                          directory where tests are run from and the given path
                          is considered relative to that unless it is absolute.
 -o --output file         XML output file. Given path, similarly as paths given
                          to --log, --report, --xunit, and --debugfile, is
                          relative to --outputdir unless given as an absolute
                          path. Other output files are created based on XML
                          output files after the test execution and XML outputs
                          can also be further processed with Rebot tool. Can be
                          disabled by giving a special value `NONE`. In this
                          case, also log and report are automatically disabled.
                          Default: output.xml
 -l --log file            HTML log file. Can be disabled by giving a special
                          value `NONE`. Default: log.html
                          Examples: `--log mylog.html`, `-l NONE`
 -r --report file         HTML report file. Can be disabled with `NONE`
                          similarly as --log. Default: report.html
 -x --xunit file          xUnit compatible result file. Not created unless this
                          option is specified.
    --xunitfile file      Deprecated. Use --xunit instead.
    --xunitskipnoncritical  Mark non-critical tests on xUnit output as skipped.
 -b --debugfile file      Debug file written during execution. Not created
                          unless this option is specified.
 -T --timestampoutputs    When this option is used, timestamp in a format
                          `YYYYMMDD-hhmmss` is added to all generated output
                          files between their basename and extension. For
                          example `-T -o output.xml -r report.html -l none`
                          creates files like `output-20070503-154410.xml` and
                          `report-20070503-154410.html`.
    --splitlog            Split log file into smaller pieces that open in
                          browser transparently.
    --logtitle title      Title for the generated test log. The default title
                          is `<Name Of The Suite> Test Log`. Underscores in
                          the title are converted into spaces in all titles.
    --reporttitle title   Title for the generated test report. The default
                          title is `<Name Of The Suite> Test Report`.
    --reportbackground colors  Background colors to use in the report file.
                          Either `all_passed:critical_passed:failed` or
                          `passed:failed`. Both color names and codes work.
                          Examples: --reportbackground green:yellow:red
                                    --reportbackground #00E:#E00
 -L --loglevel level      Threshold level for logging. Available levels: TRACE,
                          DEBUG, INFO (default), WARN, NONE (no logging). Use
                          syntax `LOGLEVEL:DEFAULT` to define the default
                          visible log level in log files.
                          Examples: --loglevel DEBUG
                                    --loglevel DEBUG:INFO
    --suitestatlevel level  How many levels to show in `Statistics by Suite`
                          in log and report. By default all suite levels are
                          shown. Example:  --suitestatlevel 3
    --tagstatinclude tag *  Include only matching tags in `Statistics by Tag`
                          and `Test Details` in log and report. By default all
                          tags set in test cases are shown. Given `tag` can
                          also be a simple pattern (see e.g. --test).
    --tagstatexclude tag *  Exclude matching tags from `Statistics by Tag` and
                          `Test Details`. This option can be used with
                          --tagstatinclude similarly as --exclude is used with
                          --include.
    --tagstatcombine tags:name *  Create combined statistics based on tags.
                          These statistics are added into `Statistics by Tag`
                          and matching tests into `Test Details`. If optional
                          `name` is not given, name of the combined tag is got
                          from the specified tags. Tags are combined using the
                          rules explained in --include.
                          Examples: --tagstatcombine tag1ANDtag2:My_name
                                    --tagstatcombine requirement-*
    --tagdoc pattern:doc *  Add documentation to tags matching given pattern.
                          Documentation is shown in `Test Details` and also as
                          a tooltip in `Statistics by Tag`. Pattern can contain
                          characters `*` (matches anything) and `?` (matches
                          any char). Documentation can contain formatting
                          similarly as with --doc option.
                          Examples: --tagdoc mytag:My_documentation
                                    --tagdoc regression:*See*_http://info.html
                                    --tagdoc owner-*:Original_author
    --tagstatlink pattern:link:title *  Add external links into `Statistics by
                          Tag`. Pattern can contain characters `*` (matches
                          anything) and `?` (matches any char). Characters
                          matching to wildcard expressions can be used in link
                          and title with syntax %N, where N is index of the
                          match (starting from 1). In title underscores are
                          automatically converted to spaces.
                          Examples: --tagstatlink mytag:http://my.domain:Link
                          --tagstatlink bug-*:http://tracker/id=%1:Bug_Tracker
    --removekeywords all|passed|for|wuks|name:<pattern> *  Remove keyword data
                          from the generated log file. Keywords containing
                          warnings are not removed except in `all` mode.
                          all:            remove data from all keywords
                          passed:         remove data only from keywords in
                                          passed test cases and suites
                          for:            remove passed iterations from for
                                          loops
                          wuks:           remove all but last failing keyword
                                          from `Wait Until Keyword Succeeds`
                          name:<pattern>: remove those keywords that matches
                                          pattern. Pattern can be the full name
                                          of the keyword with spaces removed or
                                          `*` wildcard.
    --listener class *    A class for monitoring test execution. Gets
                          notifications e.g. when a test case starts and ends.
                          Arguments to listener class can be given after class
                          name, using colon as separator. For example:
                          --listener MyListenerClass:arg1:arg2
    --warnonskippedfiles  If this option is used, skipped files will cause a
                          warning that is visible to console output and log
                          files. By default skipped files only cause an info
                          level syslog message.
    --nostatusrc          Sets the return code to zero regardless of failures
                          in test cases. Error codes are returned normally.
    --runemptysuite       Executes tests also if the top level test suite is
                          empty. Useful e.g. with --include/--exclude when it
                          is not an error that no test matches the condition.
    --dryrun              Verifies test data and runs tests so that library
                          keywords are not executed.
    --exitonfailure       Stops test execution if ant critical test fails.
    --skipteardownonexit  Causes teardowns to be skipped if test execution is
                          stopped prematurely.
    --randomize all|suites|tests|none  Randomizes the test execution order.
                          all:    randomizes both suites and tests
                          suites: randomizes suites
                          tests:  randomizes tests
                          none:   no randomization (default)
    --runmode mode *      Deprecated in version 2.8. Use individual options
                          --dryrun, --exitonfailure, --skipteardownonexit, or
                          --randomize instead.
 -W --monitorwidth chars  Width of the monitor output. Default is 78.
 -C --monitorcolors auto|on|ansi|off  Use colors on console output or not.
                          auto: use colors when output not redirected (default)
                          on:   always use colors
                          ansi: like `on` but use ANSI colors also on Windows
                          off:  disable colors altogether
                          Note that colors do not work with Jython on Windows.
 -K --monitormarkers auto|on|off  Show `.` (success) or `F` (failure) on
                          console when top level keywords in test cases end.
                          Values have same semantics as with --monitorcolors.
 -P --pythonpath path *   Additional locations (directories, ZIPs, JARs) where
                          to search test libraries from when they are imported.
                          Multiple paths can be given by separating them with a
                          colon (`:`) or using this option several times. Given
                          path can also be a glob pattern matching multiple
                          paths but then it normally must be escaped or quoted.
                          Examples:
                          --pythonpath libs/
                          --pythonpath /opt/testlibs:mylibs.zip:yourlibs
                          -E star:STAR -P lib/STAR.jar -P mylib.jar
 -E --escape what:with *  Escape characters which are problematic in console.
                          `what` is the name of the character to escape and
                          `with` is the string to escape it with. Note that
                          all given arguments, incl. data sources, are escaped
                          so escape characters ought to be selected carefully.
                          Available escapes: amp (&), apos ('), at (@), bslash
                          (\), colon (:), comma (,), curly1 ({), curly2 (}),
                          dollar ($), exclam (!), gt (>), hash (#), lt (<),
                          paren1 ((), paren2 ()), percent (%), pipe (|), quest
                          (?), quot ("), semic (;), slash (/), space ( ),
                          square1 ([), square2 (]), star (*)
                          Examples:
                          --escape space:_ --metadata X:Value_with_spaces
                          -E space:SP -E quot:Q -v var:QhelloSPworldQ
 -A --argumentfile path *  Text file to read more arguments from. Use special
                          path `STDIN` to read contents from the standard input
                          stream. File can have both options and data sources
                          one per line. Contents do not need to be escaped but
                          spaces in the beginning and end of lines are removed.
                          Empty lines and lines starting with a hash character
                          (#) are ignored.
                          Example file:
                          |  --include regression
                          |  --name Regression Tests
                          |  # This is a comment line
                          |  my_tests.html
                          |  path/to/test/directory/
                          Examples:
                          --argumentfile argfile.txt --argumentfile STDIN
 -h -? --help             Print usage instructions.
 --version                Print version information.

Options that are marked with an asterisk (*) can be specified multiple times.
For example, `--test first --test third` selects test cases with name `first`
and `third`. If other options are given multiple times, the last value is used.

Long option format is case-insensitive. For example, --SuiteStatLevel is
equivalent to but easier to read than --suitestatlevel. Long options can
also be shortened as long as they are unique. For example, `--logti Title`
works while `--lo log.html` does not because the former matches only --logtitle
but the latter matches --log, --loglevel and --logtitle.

Environment Variables
=====================

ROBOT_SYSLOG_FILE         Path to a file where Robot Framework writes internal
                          information about parsing test case files and running
                          tests. Can be useful when debugging problems. If not
                          set, or set to special value `NONE`, writing to the
                          syslog file is disabled.
ROBOT_SYSLOG_LEVEL        Log level to use when writing to the syslog file.
                          Available levels are the same as for --loglevel
                          command line option and the default is INFO.

Examples
========

# Simple test run with `pybot` without options.
$ pybot tests.html

# Using options and running with `jybot`.
$ jybot --include smoke --name Smoke_Tests path/to/tests.txt

# Executing `robot.run` module using Python.
$ python -m robot.run --test test1 --test test2 test_directory

# Running `robot/run.py` script with Jython.
$ jython /path/to/robot/run.py tests.robot

# Executing multiple test case files and using case-insensitive long options.
$ pybot --SuiteStatLevel 2 /my/tests/*.html /your/tests.html

# Setting syslog file before running tests.
$ export ROBOT_SYSLOG_FILE=/tmp/syslog.txt
$ pybot tests.tsv
"""
########NEW FILE########
__FILENAME__ = arguments
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robotide.robotapi import is_var
from robotide.utils import find_variable_basenames, is_scalar_variable


def parse_arguments_to_var_dict(args, name):
    result = {}
    for arg in args:
        parsed = parse_argument(arg)
        if parsed:
            result[parsed[0]] = parsed[1]
    if not args and name:
        for var in find_variable_basenames(name):
            if is_scalar_variable(var):
                result[var] = None
    return result

default_val_regexp = re.compile(r'([$@]\{.*\})\s*=\s*(.*)')

def parse_argument(argument):
    match = default_val_regexp.match(argument)
    if match:
        return (match.group(1), match.group(2))
    if is_var(argument):
        return (argument, None)
    return None
########NEW FILE########
__FILENAME__ = basecontroller
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.publish.messages import RideModificationPrevented


class _BaseController(object):

    @property
    def display_name(self):
        return self.data.name

    def execute(self, command):
        if not command.modifying or self.is_modifiable():
            return command.execute(self)
        else:
            RideModificationPrevented(controller=self).publish()

    def is_modifiable(self):
        return True

    def is_excluded(self):
        return False


class ControllerWithParent(_BaseController):

    @property
    def parent(self):
        return self._parent

    def set_parent(self, new_parent):
        self._parent = new_parent

    def mark_dirty(self):
        if self._parent:
            self._parent.mark_dirty()

    @property
    def dirty(self):
        return self._parent.dirty

    @property
    def datafile_controller(self):
        return self._parent.datafile_controller

    @property
    def datafile(self):
        return self._parent.datafile

    @property
    def datafiles(self):
        return self._parent.datafiles

    def is_modifiable(self):
        return self.datafile_controller.is_modifiable()


class WithNamespace(object):
    _namespace = None # Ensure namespace exists

    def _set_namespace_from(self, controller):
        self._set_namespace(controller._namespace)

    def _set_namespace(self, namespace):
        self._namespace = namespace

    def update_namespace(self):
        if not self._namespace:
            return
        self._namespace.update()

    def register_for_namespace_updates(self, listener):
        if not self._namespace:
            return
        self._namespace.register_update_listener(listener)

    def unregister_namespace_updates(self, listener):
        if not self._namespace:
            return
        self._namespace.unregister_update_listener(listener)

    def clear_namespace_update_listeners(self):
        self._namespace.clear_update_listeners()

    def is_user_keyword(self, datafile, value):
        return self._namespace.is_user_keyword(datafile, value)

    def is_library_keyword(self, datafile, value):
        return self._namespace.is_library_keyword(datafile, value)

    def get_all_keywords_from(self, *datafiles):
        return self._namespace.get_all_keywords(*datafiles)

    def get_all_cached_library_names(self):
        return self._namespace.get_all_cached_library_names()

    def keyword_info(self, datafile, keyword_name):
        return self._namespace.find_keyword(datafile, keyword_name)

    def is_library_import_ok(self, imp):
        return self._namespace.is_library_import_ok(self.datafile, imp)

    def is_variables_import_ok(self, imp):
        return self._namespace.is_variables_import_ok(self.datafile, imp)


class WithUndoRedoStacks(object):

    @property
    def _undo(self):
        if not hasattr(self, '_undo_stack'):
            self._undo_stack = []
        return self._undo_stack

    @property
    def _redo(self):
        if not hasattr(self, '_redo_stack'):
            self._redo_stack = []
        return self._redo_stack

    def clear_undo(self):
        self._undo_stack = []

    def is_undo_empty(self):
        return self._undo == []

    def pop_from_undo(self):
        return self._undo.pop()

    def push_to_undo(self, command):
        self._undo.append(command)

    def clear_redo(self):
        self._redo_stack = []

    def is_redo_empty(self):
        return self._redo == []

    def pop_from_redo(self):
        return self._redo.pop()

    def push_to_redo(self, command):
        self._redo.append(command)

########NEW FILE########
__FILENAME__ = cellinfo
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.utils import highlight_matcher, html_escape


class CellInfo(object):

    def __init__(self, cell_content, cell_position, for_loop=False):
        self._cell_content = cell_content
        self._cell_position = cell_position
        self.for_loop = for_loop

    @property
    def content_type(self):
        return self._cell_content.type

    @property
    def cell_type(self):
        return self._cell_position.type

    @property
    def source(self):
        return self._cell_content.source

    @property
    def arg_name(self):
        return self._cell_position.argument_name

    def has_error(self):
        return self.argument_missing() or self.too_many_arguments()

    def argument_missing(self):
        return self.cell_type == CellType.MANDATORY \
            and self.content_type in [ContentType.EMPTY, ContentType.COMMENTED]

    def too_many_arguments(self):
        return self.cell_type == CellType.MUST_BE_EMPTY \
            and self.content_type not in [ContentType.EMPTY, ContentType.COMMENTED]

    def matches(self, value):
        return highlight_matcher(value, self._cell_content.value)


def TipMessage(cell):
    if not cell:
        return ''
    tip = _TooltipMessage(cell) if not cell.for_loop \
            else _ForLoopTooltipMessage(cell)
    return html_escape(unicode(tip))


class _TooltipMessage(object):

    TOO_MANY_ARGUMENTS = "Too many arguments"
    KEYWORD_NOT_FOUND = "Keyword not found! For possible corrections press <ctrl>"
    VARIABLE_ASSIGMENT = "Variable assignment"
    UNKNOWN_VARIABLE = "\n\nUnknown variable"

    ARGUMENT = "Argument:  %s"
    OPTIONAL_ARGUMENT = "Optional argument:  %s"
    MISSING_ARGUMENT = "Missing argument:  %s"

    KEYWORD = "Keyword from:  %s\n\nPress <ctrl> for details"

    def __init__(self, cell):
        self.message = self._get_message(cell)

    def _get_message(self, cell):
        unknown_variable_message = '' if cell.content_type != ContentType.UNKNOWN_VARIABLE else self.UNKNOWN_VARIABLE
        handlers = {
            CellType.ASSIGN: self._assign,
            CellType.KEYWORD: self._keyword,
            CellType.MANDATORY: self._mandatory,
            CellType.OPTIONAL: self._optional,
            CellType.MUST_BE_EMPTY: self._must_be_empty,
            CellType.UNKNOWN: self._unknown,
        }
        return (handlers[cell.cell_type](cell) + unknown_variable_message).strip()

    def _must_be_empty(self, cell):
        if cell.too_many_arguments():
            return self.TOO_MANY_ARGUMENTS
        return ''

    def _mandatory(self, cell):
        if cell.argument_missing():
            return self.MISSING_ARGUMENT % cell.arg_name
        return self.ARGUMENT % cell.arg_name

    def _optional(self, cell):
        return self.OPTIONAL_ARGUMENT % cell.arg_name

    def _keyword(self, cell):
        if cell.content_type == ContentType.STRING:
            return self.KEYWORD_NOT_FOUND
        if cell.content_type in ContentType.KEYWORDS:
            return self.KEYWORD % cell.source
        return ''

    def _assign(self, cell):
        return self.VARIABLE_ASSIGMENT

    def _unknown(self, cell):
        return ''

    def __nonzero__(self):
        return bool(self.message)

    def __str__(self):
        return self.message


class _ForLoopTooltipMessage(_TooltipMessage):

    TOO_MANY_ARGUMENTS = "Too many parameters in for loop"

    def _get_message(self, cell):
        if cell.too_many_arguments():
            return self.TOO_MANY_ARGUMENTS
        return ''


class CellContent(object):

    def __init__(self, type, value, source=None):
        self.type = type
        self.value = value
        self.source = source


class CellPosition(object):

    def __init__(self, type, argument_name):
        self.type= type
        self.argument_name = argument_name


class ContentType:
    USER_KEYWORD = 'USER_KEYWORD'
    LIBRARY_KEYWORD = 'LIBRARY_KEYWORD'
    KEYWORDS = (USER_KEYWORD, LIBRARY_KEYWORD)
    VARIABLE = 'VARIABLE'
    UNKNOWN_VARIABLE = 'UNKNOWN_VARIABLE'
    COMMENTED = 'COMMENTED'
    STRING = 'STRING'
    EMPTY = 'EMPTY'


class CellType:
    ASSIGN = 'ASSIGN'
    KEYWORD = 'KEYWORD'
    MANDATORY = 'MANDATORY'
    OPTIONAL = 'OPTIONAL'
    MUST_BE_EMPTY = 'MUST_BE_EMPTY'
    UNKNOWN = 'UNKNOWN'

########NEW FILE########
__FILENAME__ = chiefcontroller
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from __future__ import with_statement

import os
import shutil
import tempfile

from robotide.context import LOG
from robotide.controller.commands import NullObserver, SaveFile
from robotide.publish.messages import RideOpenSuite, RideNewProject, RideFileNameChanged

from .basecontroller import WithNamespace, _BaseController
from .dataloader import DataLoader
from .filecontrollers import DataController, ResourceFileControllerFactory
from .robotdata import NewTestCaseFile, NewTestDataDirectory
from robotide.spec.librarydatabase import DATABASE_FILE
from robotide.spec.librarymanager import LibraryManager
from robotide.spec.xmlreaders import SpecInitializer
from robotide.utils import overrides


class ChiefController(_BaseController, WithNamespace):

    def __init__(self, namespace=None, settings=None, library_manager=None):
        self._library_manager = self._construct_library_manager(library_manager, settings)
        if not self._library_manager.is_alive():
            self._library_manager.start()
        self._set_namespace(namespace)
        self._settings = settings
        self._loader = DataLoader(namespace, settings)
        self._controller = None
        self.name = None
        self.external_resources = []
        self._resource_file_controller_factory = ResourceFileControllerFactory(namespace, self)
        self._serializer = Serializer(settings, LOG)

    def _construct_library_manager(self, library_manager, settings):
        return library_manager or LibraryManager(DATABASE_FILE,
                                                 SpecInitializer(settings.get('library xml directories', [])[:]))

    def __del__(self):
        if self._library_manager:
            self.close()

    def close(self):
        self._library_manager.stop()
        self._library_manager = None

    @overrides(WithNamespace)
    def _set_namespace(self, namespace):
        namespace.set_library_manager(self._library_manager)
        WithNamespace._set_namespace(self, namespace)

    @property
    def display_name(self):
        return 'Chief'

    @property
    def default_dir(self):
        return os.path.abspath(self._settings['default directory'])

    def update_default_dir(self, path):
        default_dir = path if os.path.isdir(path) else os.path.dirname(path)
        self._settings.set('default directory', default_dir)

    # TODO: in all other controllers data returns a robot data model object.
    @property
    def data(self):
        return self._controller

    @property
    def suite(self):
        return self._controller.data if self._controller else None

    @property
    def datafiles(self):
        return self._suites() + self.resources

    @property
    def resources(self):
        return self._resource_file_controller_factory.resources

    @property
    def resource_file_controller_factory(self):
        return self._resource_file_controller_factory

    def find_controller_by_longname(self, longname, testname = None):
        return self._controller.find_controller_by_longname(longname, testname)

    def new_directory_project(self, path):
        self._new_project(NewTestDataDirectory(path))

    def new_file_project(self, path):
        self._new_project(NewTestCaseFile(path))

    def _new_project(self, datafile):
        self.update_default_dir(datafile.directory)
        self._controller = DataController(datafile, self)
        self._resource_file_controller_factory = ResourceFileControllerFactory(self._namespace, self)
        RideNewProject(path=datafile.source, datafile=datafile).publish()

    def new_resource(self, path, parent=None):
        res = self._namespace.new_resource(path)
        self.update_default_dir(path)
        resource_controller = self._create_resource_controller(res, parent)
        return resource_controller

    def load_data(self, path, load_observer=None):
        load_observer = load_observer or NullObserver()
        if self._load_initfile(path, load_observer):
            return
        if self._load_datafile(path, load_observer):
            return
        if self._load_resource(path, load_observer):
            return
        load_observer.error("Given file '%s' is not a valid Robot Framework "
                            "test case or resource file." % path)

    def is_excluded(self, source):
        return self._settings.excludes.contains(source) if self._settings else False

    def _load_initfile(self, path, load_observer):
        if not os.path.splitext(os.path.split(path)[1])[0] == '__init__':
            return None
        initfile = self._loader.load_initfile(path, load_observer)
        if not initfile:
            return None
        self._populate_from_datafile(path, initfile, load_observer)
        return initfile

    def load_datafile(self, path, load_observer):
        datafile = self._load_datafile(path, load_observer)
        if datafile:
            return datafile
        load_observer.error("Invalid data file '%s'." % path)

    def _load_datafile(self, path, load_observer):
        datafile = self._loader.load_datafile(path, load_observer)
        if not datafile:
            return None
        self._populate_from_datafile(path, datafile, load_observer)
        return datafile

    def _populate_from_datafile(self, path, datafile, load_observer):
        self.__init__(self._namespace, self._settings, library_manager=self._library_manager)
        resources = self._loader.resources_for(datafile, load_observer)
        self._create_controllers(datafile, resources)
        RideOpenSuite(path=path, datafile=self._controller).publish()
        load_observer.finish()

    def _create_controllers(self, datafile, resources):
        self.clear_namespace_update_listeners()
        self._controller = DataController(datafile, self)
        new_resource_controllers = []
        for r in resources:
            self._create_resource_controller(r, resource_created_callback=lambda controller: new_resource_controllers.append(controller))
        for controller in new_resource_controllers:
            self._inform_resource_created(controller)

    def load_resource(self, path, load_observer):
        resource = self._load_resource(path, load_observer)
        if resource:
            return resource
        load_observer.error("Invalid resource file '%s'." % path)

    def _load_resource(self, path, load_observer):
        resource = self._namespace.get_resource(path)
        if not resource:
            return None
        ctrl = self._create_resource_controller(resource)
        load_observer.finish()
        return ctrl

    def _create_resource_controller(self, parsed_resource, parent=None, resource_created_callback=None):
        old = self._resource_file_controller_factory.find(parsed_resource)
        if old:
            return old
        controller = self._resource_file_controller_factory.create(parsed_resource, parent=parent)
        self.insert_into_suite_structure(controller)
        resource_created_callback = resource_created_callback or self._inform_resource_created
        resource_created_callback(controller)
        return controller

    def _inform_resource_created(self, controller):
        controller.notify_opened()

    def insert_into_suite_structure(self, resource):
        if self._controller and self._controller.is_inside_top_suite(resource):
            self._controller.insert_to_test_data_directory(resource)
        else:
            self.external_resources.append(resource)
            self._sort_external_resources()

    def _sort_external_resources(self):
        self.external_resources.sort(key=lambda resource: resource.name.lower())

    def get_all_keywords(self):
        return self.get_all_keywords_from(ctrl.datafile for ctrl in self.datafiles if ctrl.datafile)

    def all_testcases(self):
        for df in self._suites():
            for test in df.tests:
                yield test

    def get_files_without_format(self, controller=None):
        if controller:
            controller_list = [controller]
        else:
            controller_list = self._get_all_dirty_controllers()
        return [ dc for dc in controller_list if dc.dirty and not dc.has_format() ]

    def get_root_suite_dir_path(self):
        return self.suite.get_dir_path()

    def is_dirty(self):
        if self.data and self.is_datafile_dirty(self.data):
            return True
        for res in self.resources:
            if res.dirty:
                return True
        return False

    def is_datafile_dirty(self, datafile):
        if datafile.dirty:
            return True
        for df in datafile.children:
            if self.is_datafile_dirty(df):
                return True
        return False

    def change_format(self, controller, format):
        if controller.is_same_format(format):
            return
        old_path = controller.filename
        controller.set_format(format)
        controller.execute(SaveFile())
        if old_path:
            self._remove_file(old_path)
            RideFileNameChanged(old_filename=old_path,
                                datafile=controller).publish()

    def _remove_file(self, path):
        if path and os.path.isfile(path):
            os.remove(path)

    def change_format_recursive(self, controller, format):
        for datafile in controller.iter_datafiles():
            self.change_format(datafile, format)

    def remove_datafile(self, controller):
        if controller is self._controller:
            self._controller = None
        else:
            self._controller.remove_child(controller)

    def remove_resource(self, controller):
        self._resource_file_controller_factory.remove(controller)

    def save(self, controller):
        assert controller is not None
        self._serializer.serialize_file(controller)

    def _get_all_dirty_controllers(self):
        return [controller for controller in self.datafiles if controller.dirty]

    def _suites(self):
        if not self.data:
            return []
        return [df for df in self.data.iter_datafiles() if not df in self.resources]

    def resource_import_modified(self, path, directory):
        resource = self._namespace.get_resource(path, directory)
        if resource:
            return self._create_resource_controller(resource)


class Serializer(object):

    def __init__(self, settings, logger):
        self._settings = settings
        self._logger = logger
        self._errors = []

    def serialize_file(self, controller):
        try:
            self._serialize_file(controller)
        finally:
            self._log_errors()

    def _serialize_file(self, controller):
        with Backup(controller):
            try:
                controller.datafile.save(**self._get_options())
            except Exception, err:
                self._cache_error(controller, err)
                raise

    def _get_options(self):
        return {'line_separator': self._get_line_separator(),
                'pipe_separated': self._get_pipe_separated(),
                'txt_separating_spaces': self._get_separating_spaces()}

    def _get_line_separator(self):
        setting = self._settings.get('line separator', 'native').lower()
        if setting in ('crlf', 'windows'):
            return '\r\n'
        if setting in ('lf', 'unix'):
            return '\n'
        return os.linesep

    def _get_pipe_separated(self):
        return self._settings.get('txt format separator', 'space') == 'pipe'

    def _get_separating_spaces(self):
        return self._settings.get('txt number of spaces', 4)

    def _cache_error(self, data, error):
        self._errors.append("Error in serializing '%s':\n%s"
                            % (data.data.source, unicode(error)))

    def _log_errors(self):
        if self._errors:
            self._logger.error('\n\n'.join(self._errors))
            self._errors = []


class Backup(object):

    def __init__(self, file_controller):
        self._path = file_controller.filename
        self._file_controller = file_controller
        self._backup = self._get_backup_name(self._path)

    def _get_backup_name(self, path):
        if not os.path.isfile(path):
            return None
        self._backup_dir = tempfile.mkdtemp(dir=os.path.dirname(path))
        return os.path.join(self._backup_dir, os.path.basename(path))

    def __enter__(self):
        self._make_backup()

    def _make_backup(self):
        if self._backup:
            try:
                self._move(self._path, self._backup)
            except IOError:
                self._backup = None
                self._remove_backup_dir()

    def __exit__(self, *args):
        if any(args):
            self._restore_backup()
        else:
            self._remove_backup()

    def _remove_backup(self):
        if self._backup:
            os.remove(self._backup)
            self._remove_backup_dir()

    def _restore_backup(self):
        if self._backup:
            self._move(self._backup, self._path)
            self._file_controller.refresh_stat()
            self._remove_backup_dir()

    def _move(self, from_path, to_path):
        shutil.move(from_path, to_path)

    def _remove_backup_dir(self):
        os.rmdir(self._backup_dir)

########NEW FILE########
__FILENAME__ = commands
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from itertools import chain
import time
import os

from robotide.namespace.embeddedargs import EmbeddedArgsHandler
from robotide.publish.messages import RideSelectResource, RideFileNameChanged, RideSaving, RideSaved, RideSaveAll, RideExcludesChanged
from robotide.namespace.namespace import _VariableStash

from .filecontrollers import ResourceFileController
from .macrocontrollers import KeywordNameController, ForLoopStepController, TestCaseController
from robotide.utils import overrides, is_variable
from robotide.utils.variablematcher import contains_scalar_variable
from .settingcontrollers import _SettingController, VariableController
from .tablecontrollers import VariableTableController
from .validators import BaseNameValidator


class Occurrence(object):

    def __init__(self, item, value):
        self._item = item
        self._value = value
        self._replaced = False
        self.count = 1

    def __eq__(self, other):
        if not isinstance(other, Occurrence):
            return False
        return (self.parent is other.parent and
                self._in_steps() and other._in_steps())

    @property
    def item(self):
        return self._item

    @property
    def source(self):
        return self.datafile.source

    @property
    def datafile(self):
        return self._item.datafile

    @property
    def parent(self):
        if self._in_for_loop():
            return self._item.parent.parent
        return self._item.parent

    @property
    def location(self):
        return self._item.parent.name

    @property
    def usage(self):
        if self._in_variable_table():
            return "Variable Table"
        elif self._in_settings():
            return self._item.label
        elif self._in_kw_name():
            return 'Keyword Name'
        return 'Steps' if self.count == 1 else 'Steps (%d usages)' % self.count

    def _in_settings(self):
        return isinstance(self._item, _SettingController)

    def _in_variable_table(self):
        return isinstance(self._item, VariableTableController)

    def _in_kw_name(self):
        return isinstance(self._item, KeywordNameController)

    def _in_steps(self):
        return not (self._in_settings() or self._in_kw_name())

    def _in_for_loop(self):
        return isinstance(self._item.parent, ForLoopStepController)

    def replace_keyword(self, new_name):
        self._item.replace_keyword(*self._get_replace_values(new_name))
        self._replaced = not self._replaced

    def _get_replace_values(self, new_name):
        if self._replaced:
            return self._value, new_name
        return new_name, self._value

    def notify_value_changed(self):
        self._item.notify_value_changed()


class _Command(object):

    modifying = True

    def execute(self, context):
        raise NotImplementedError(self.__class__)

    def __str__(self):
        return '%s(%s)' % (self.__class__.__name__, self._params_str())

    def _params_str(self):
        return ', '.join(self._format_param(p) for p in self._params())

    def _format_param(self, param):
        if isinstance(param, basestring):
            return '"%s"' % param
        return str(param)

    def _params(self):
        return []


class CopyMacroAs(_Command):

    def __init__(self, new_name):
        self._new_name = new_name

    def execute(self, context):
        context.copy(self._new_name)

    def _params(self):
        return [self._new_name]


class ChangeTag(_Command):

    def __init__(self, tag, value):
        self._tag = tag
        self._value = value.strip()

    def _params(self):
        return (self._tag, self._value)

    def execute(self, context):
        tags = [tag for tag in context if tag.controller == context]
        context.set_value(self._create_value(tags))
        context.notify_value_changed()

    def _create_value(self, old_values):
        if old_values == [] and self._tag.is_empty():
            return self._value
        return ' | '.join(value for value in
                          self._create_value_list(old_values)
                          if value != '')

    def _create_value_list(self, old_values):
        if self._tag.is_empty():
            return [v.name for v in old_values]+[self._value]
        else:
            new_list = []
            for v in old_values:
                if v != self._tag:
                    new_list.append(v.name)
            if self._value not in new_list:
                new_list += [self._value]
            return new_list

class DeleteTag(_Command):

    def execute(self, tag):
        tag.delete()
        tag.controller.notify_value_changed()

class _ReversibleCommand(_Command):

    def execute(self, context):
        result = self._execute_without_redo_clear(context)
        context.clear_redo()
        return result

    def _execute_without_redo_clear(self, context):
        result = self._execute(context)
        context.push_to_undo(self._get_undo_command())
        return result

    @property
    def _get_undo_command(self):
        raise NotImplementedError(self.__class__.__name__)


class Undo(_Command):

    def execute(self, context):
        if not context.is_undo_empty():
            result = context.pop_from_undo()._execute_without_redo_clear(context)
            redo_command = context.pop_from_undo()
            context.push_to_redo(redo_command)
            return result


class Redo(_Command):

    def execute(self, context):
        if not context.is_redo_empty():
            return context.pop_from_redo()._execute_without_redo_clear(context)


class MoveTo(_Command):

    def __init__(self, destination):
        self._destination = destination

    def _params(self):
        return [self._destination]

    def execute(self, context):
        context.delete()
        self._destination.add_test_or_keyword(context)


class CreateNewResource(_Command):

    def __init__(self, path):
        self._path = path

    def execute(self, context):
        res = context.new_resource(self._path)
        RideSelectResource(item=res).publish()
        return res


class SetDataFile(_Command):

    def __init__(self, datafile):
        self._datafile = datafile

    def execute(self, context):
        context.mark_dirty()
        context.set_datafile(self._datafile)


class _StepsChangingCommand(_ReversibleCommand):

    def _execute(self, context):
        if self.change_steps(context):
            context.notify_steps_changed()
            return True
        return False

    def change_steps(self, context):
        '''Return True if steps changed, False otherwise'''
        raise NotImplementedError(self.__class__.__name__)

    def _step(self, context):
        try:
            return context.steps[self._row]
        except IndexError:
            return NonExistingStep()


class NonExistingStep(object):
    def __getattr__(self, name):
        return lambda *args: ''


class NullObserver(object):
    notify = finish = lambda x:None


class RenameKeywordOccurrences(_ReversibleCommand):

    def __init__(self, original_name, new_name, observer, keyword_info=None):
        self._original_name = original_name
        self._new_name = new_name
        self._observer = observer
        self._keyword_info = keyword_info
        self._occurrences = None

    def _params(self):
        return (self._original_name, self._new_name, self._observer, self._keyword_info)

    def _execute(self, context):
        self._observer.notify()
        self._occurrences = self._find_occurrences(context) if self._occurrences is None \
                            else self._occurrences
        self._replace_keywords_in(self._occurrences)
        context.update_namespace()
        self._notify_values_changed(self._occurrences)
        self._observer.finish()

    def _find_occurrences(self, context):
        occurrences = []
        for occ in context.execute(FindOccurrences(self._original_name, keyword_info=self._keyword_info)):
            self._observer.notify()
            occurrences.append(occ)
        self._observer.notify()
        return occurrences

    def _replace_keywords_in(self, occurrences):
        for oc in occurrences:
            oc.replace_keyword(self._new_name)
            self._observer.notify()

    def _notify_values_changed(self, occurrences):
        for oc in occurrences:
            oc.notify_value_changed()
            self._observer.notify()

    def _get_undo_command(self):
        self._observer = NullObserver()
        return self


class RenameTest(_ReversibleCommand):

    def __init__(self, new_name):
        self._new_name = new_name

    def _params(self):
        return (self._new_name)

    def _execute(self, context):
        context.test_name.rename(self._new_name)
        context.test_name.notify_value_changed()

    def _get_undo_command(self):
        return self


class RenameFile(_Command):

    def __init__(self, new_basename):
        self._new_basename = new_basename
        self._validator = BaseNameValidator(new_basename)

    def execute(self, context):
        validation_result = self._validator.validate(context)
        if validation_result:
            old_filename = context.filename
            context.set_basename(self._new_basename.strip())
            RideFileNameChanged(datafile=context,
                                old_filename=old_filename).publish()
        return validation_result


class Include(_Command):

    def execute(self, excluded_controller):
        directory_controller = excluded_controller.remove_from_excludes()
        RideExcludesChanged(old_controller=excluded_controller, new_controller=directory_controller).publish()


class Exclude(_Command):

    def execute(self, directory_controller):
        excluded_controller = directory_controller.exclude()
        RideExcludesChanged(old_controller=directory_controller, new_controller=excluded_controller).publish()

class RenameResourceFile(_Command):

    def __init__(self, new_basename, get_should_modify_imports):
        self._new_basename = new_basename
        self._should_modify_imports = get_should_modify_imports

    def execute(self, context):
        validation_result = BaseNameValidator(self._new_basename).validate(context)
        if validation_result:
            old_filename = context.filename
            modify_imports = self._should_modify_imports()
            if modify_imports is None:
                return
            if modify_imports:
                context.set_basename_and_modify_imports(self._new_basename)
            else:
                context.set_basename(self._new_basename)
            RideFileNameChanged(datafile=context,
                                old_filename=old_filename).publish()
        return validation_result

class SortKeywords(_ReversibleCommand):
    index_difference = None
    
    def _execute(self, context):
        index_difference = context.sort_keywords()
        self._undo_command = RestoreKeywordOrder(index_difference)

    def _get_undo_command(self):
        return self._undo_command

class RestoreKeywordOrder(_ReversibleCommand):
    
    def __init__(self, index_difference):
        self._index_difference = index_difference
    
    def _execute(self, context):
        context.restore_keyword_order(self._index_difference)

    def _get_undo_command(self):
        return SortKeywords()


class _ItemCommand(_Command):

    def __init__(self, item):
        self._item = item


class UpdateDocumentation(_ItemCommand):

    def execute(self, context):
        context.editable_value = self._item


class MoveUp(_ItemCommand):

    def execute(self, context):
        context.move_up(self._item)


class MoveDown(_ItemCommand):

    def execute(self, context):
        context.move_down(self._item)


class DeleteItem(_ItemCommand):

    def execute(self, context):
        context.delete(self._item)


class ClearSetting(_Command):

    def execute(self, context):
        context.clear()


class DeleteFile(_Command):

    def execute(self, context):
        context.remove_from_filesystem()
        context.remove()


class DeleteFolder(_Command):

    def execute(self, context):
        context.remove_folder_from_filesystem()
        context.remove_from_model()


class SetValues(_Command):

    def __init__(self, values, comment):
        self._values = values
        self._comment = comment

    def execute(self, context):
        context.set_value(*self._values)
        context.set_comment(self._comment)


class AddLibrary(_Command):

    def __init__(self, values, comment):
        self._values = values
        self._comment = comment

    def execute(self, context):
        lib = context.add_library(*self._values)
        lib.set_comment(self._comment)
        return lib


class AddResource(_Command):

    def __init__(self, values, comment):
        self._values = values
        self._comment = comment

    def execute(self, context):
        res = context.add_resource(*self._values)
        res.set_comment(self._comment)
        return res


class AddVariablesFileImport(_Command):

    def __init__(self, values, comment):
        self._values = values
        self._comment = comment

    def execute(self, context):
        var = context.add_variables(*self._values)
        var.set_comment(self._comment)
        return var


class DeleteResourceAndImports(DeleteFile):

    def execute(self, context):
        context.remove_static_imports_to_this()
        DeleteFile.execute(self, context)


class DeleteFolderAndImports(DeleteFolder):

    def execute(self, context):
        context.remove_static_imports_to_this()
        DeleteFolder.execute(self, context)


class UpdateVariable(_Command):

    def __init__(self, new_name, new_value, new_comment):
        self._new_name = new_name
        self._new_value = new_value
        self._new_comment = new_comment

    def execute(self, context):
        has_data = context.has_data()
        context.set_value(self._new_name, self._new_value)
        context.set_comment(self._new_comment)
        if has_data:
            context.notify_value_changed()
        else:
            context.notify_variable_added()


class UpdateVariableName(_Command):

    def __init__(self, new_name):
        self._new_name = new_name

    def execute(self, context):
        context.execute(UpdateVariable(self._new_name, context.value,
                                       context.comment))


class FindOccurrences(_Command):
    modifying = False

    def __init__(self, keyword_name, keyword_info=None):
        if keyword_name.strip() == '':
            raise ValueError('Keyword name can not be "%s"' % keyword_name)
        self._keyword_name = keyword_name
        self._keyword_info = keyword_info
        self._keyword_regexp = self._create_regexp(keyword_name)

    def _create_regexp(self, keyword_name):
        if contains_scalar_variable(keyword_name) and not is_variable(keyword_name):
            kw = lambda: 0
            kw.arguments = None
            kw.name = keyword_name
            return EmbeddedArgsHandler(kw).name_regexp

    def execute(self, context):
        self._keyword_source = self._keyword_info and self._keyword_info.source or \
                               self._find_keyword_source(context.datafile_controller)
        return self._find_occurrences_in(self._items_from(context))

    def _items_from(self, context):
        for df in context.datafiles:
            self._yield_for_other_threads()
            if self._items_from_datafile_should_be_checked(df):
                for item in self._items_from_datafile(df):
                    yield item

    def _items_from_datafile_should_be_checked(self, datafile):
        if datafile.filename and \
           os.path.basename(datafile.filename) == self._keyword_source:
            return True
        return self._find_keyword_source(datafile) == self._keyword_source

    def _items_from_datafile(self, df):
        for setting in df.settings:
            yield setting
        for items_from_test in (self._items_from_test(test) for test in df.tests):
            for item in items_from_test:
                yield item
        for items_from_keyword in (self._items_from_keyword(kw) for kw in df.keywords):
            for item in items_from_keyword:
                yield item

    def _items_from_keyword(self, kw):
        return chain([kw.keyword_name] if kw.source == self._keyword_source else [], kw.steps, [kw.teardown] if kw.teardown else [])

    def _items_from_test(self, test):
        return chain(test.settings, test.steps)

    def _find_keyword_source(self, datafile_controller):
        item_info = datafile_controller.keyword_info(self._keyword_name)
        return item_info.source if item_info else None

    def _find_occurrences_in(self, items):
        return (Occurrence(item, self._keyword_name) for item in items
            if self._contains_item(item))

    def _contains_item(self, item):
        self._yield_for_other_threads()
        return item.contains_keyword(self._keyword_regexp or self._keyword_name)

    def _yield_for_other_threads(self):
        # GIL !?#!!!
        # THIS IS TO ENSURE THAT OTHER THREADS WILL GET SOME SPACE ALSO
        time.sleep(0)


class FindVariableOccurrences(FindOccurrences):

    @overrides(FindOccurrences)
    def _contains_item(self, item):
        self._yield_for_other_threads()
        return item.contains_variable(self._keyword_name)

    def _items_from_datafile(self, df):
        for itm in FindOccurrences._items_from_datafile(self, df):
            yield itm
        yield df.variables

    def _items_from_controller(self, ctrl):
        if isinstance(ctrl, TestCaseController):
            return self._items_from_test(ctrl)
        else:
            return self._items_from_keyword(ctrl)

    def _items_from_keyword(self, kw):
        return chain([kw.keyword_name], kw.steps, kw.settings)

    def _items_from(self, context):
        self._context = context
        if self._is_local_variable(self._keyword_name, context):
            for item in self._items_from_controller(context):
                yield item
        else:
            for df in context.datafiles:
                self._yield_for_other_threads()
                if self._items_from_datafile_should_be_checked(df):
                    for item in self._items_from_datafile(df):
                        yield item

    def _items_from_datafile_should_be_checked(self, datafile):
        if self._is_file_variable(self._keyword_name, self._context):
            return datafile in [self._context.datafile_controller] + \
                                self._get_all_where_used(self._context)
        elif self._is_imported_variable(self._keyword_name, self._context):
            return datafile in [self._get_source_of_imported_var(
                                    self._keyword_name, self._context)] + \
                                self._get_all_where_used(
                                    self._get_source_of_imported_var(
                                        self._keyword_name, self._context))
        else:
            return True

    def _is_local_variable(self, name, context):
        if isinstance(context, VariableController):
            return False
        return name in context.get_local_variables() or \
                any(step.contains_variable_assignment(name)
                    for step in context.steps)

    def _is_file_variable(self, name, context):
        return context.datafile_controller.variables.contains_variable(name)
    
    def _is_imported_variable(self, name, context):
        return self._get_source_of_imported_var(name, context) not in \
                                        [None, context.datafile_controller]
    
    def _is_builtin_variable(self, name):
        return name in _VariableStash.global_variables.keys()
    
    def _get_source_of_imported_var(self, name, context):
        for df in self._get_all_imported(context):
            if df.variables.contains_variable(name):
                return df
        return None

    def _get_all_imported(self, context):
        files = [context.datafile_controller]
        for f in files:
            files += [imp.get_imported_controller() 
                        for imp in f.imports if imp.is_resource and 
                            imp.get_imported_controller() not in files]
        return files

    def _get_all_where_used(self, context):
        files = [context.datafile_controller]
        for f in files:
            if isinstance(f, ResourceFileController):
                files += [imp.datafile_controller for imp in f.get_where_used()]
        return files


def AddKeywordFromCells(cells):
    if not cells:
        raise ValueError('Keyword can not be empty')
    while cells[0] == '':
        cells.pop(0)
    name = cells[0]
    args = cells[1:]
    argstr = ' | '.join(('${arg%s}' % (i + 1) for i in range(len(args))))
    return AddKeyword(name, argstr)


class AddKeyword(_ReversibleCommand):

    def __init__(self, new_kw_name, args=None):
        self._kw_name = new_kw_name
        self._args = args or []

    def _execute(self, context):
        kw = context.create_keyword(self._kw_name, self._args)
        self._undo_command = RemoveMacro(kw)
        return kw

    def _get_undo_command(self):
        return self._undo_command


class AddTestCase(_Command):

    def __init__(self, new_test_name):
        self._test_name = new_test_name

    def execute(self, context):
        return context.create_test(self._test_name)


class _AddDataFile(_Command):

    def __init__(self, path):
        self._path = path

    def execute(self, context):
        ctrl = self._add_data_file(context)
        context.notify_suite_added(ctrl)
        return ctrl

    def _add_data_file(self, context):
        raise NotImplementedError(self.__class__.__name__)

class AddTestCaseFile(_AddDataFile):

    def _add_data_file(self, context):
        return context.new_test_case_file(self._path)

class AddTestDataDirectory(_AddDataFile):

    def _add_data_file(self, context):
        return context.new_test_data_directory(self._path)


class CreateNewFileProject(_Command):

    def __init__(self, path):
        self._path = path

    def execute(self, context):
        context.new_file_project(self._path)


class CreateNewDirectoryProject(_Command):

    def __init__(self, path):
        self._path = path

    def execute(self, context):
        context.new_directory_project(self._path)


class SetFileFormat(_Command):

    def __init__(self, format):
        self._format = format

    def execute(self, context):
        context.save_with_new_format(self._format)


class SetFileFormatRecuresively(_Command):

    def __init__(self, format):
        self._format = format

    def execute(self, context):
        context.save_with_new_format_recursive(self._format)


class RemoveVariable(_ReversibleCommand):

    def __init__(self, var_controller):
        self._var_controller = var_controller
        self._undo_command = AddVariable(var_controller.name,
                                         var_controller.value,
                                         var_controller.comment)

    def _execute(self, context):
        context.datafile_controller.\
            variables.remove_var(self._var_controller)

    def _get_undo_command(self):
        return self._undo_command


class AddVariable(_ReversibleCommand):

    def __init__(self, name, value, comment):
        self._name = name
        self._value = value
        self._comment = comment

    def _execute(self, context):
        var_controller = context.datafile_controller.\
            variables.add_variable(self._name, self._value, self._comment)
        self._undo_command = RemoveVariable(var_controller)
        return var_controller

    def _get_undo_command(self):
        return self._undo_command

    def __str__(self):
        return 'AddVariable("%s", "%s", "%s")' % (self._name, self._value, self._comment)


class RecreateMacro(_ReversibleCommand):

    def __init__(self, user_script):
        self._user_script = user_script

    def _execute(self, context):
        self._user_script.recreate()

    def _get_undo_command(self):
        return RemoveMacro(self._user_script)


class RemoveMacro(_ReversibleCommand):

    def __init__(self, item):
        self._item = item

    def _execute(self, context):
        self._item.delete()

    def _get_undo_command(self):
        return RecreateMacro(self._item)


class ExtractKeyword(_Command):

    def __init__(self, new_kw_name, new_kw_args, step_range):
        self._name = new_kw_name
        self._args = new_kw_args
        self._rows = step_range

    def _params(self):
        return (self._name, self._args, self._rows)

    def execute(self, context):
        context.extract_keyword(self._name, self._args, self._rows)
        context.notify_steps_changed()
        context.clear_undo()


def ExtractScalar(name, value, comment, cell):
    return CompositeCommand(AddVariable(name, value, comment),
                            ChangeCellValue(cell[0], cell[1], name))


def ExtractList(name, value, comment, cells):
    row, col = cells[0]
    return CompositeCommand(AddVariable(name, value, comment),
                            ChangeCellValue(row, col, name),
                            DeleteCells((row, col+1), (row, col+len(cells)-1)))


class ChangeCellValue(_StepsChangingCommand):

    def __init__(self, row, col, value):
        self._row = row
        self._col = col
        self._value = value

    def change_steps(self, context):
        steps = context.steps
        while len(steps) <= self._row:
            context.add_step(len(steps))
            steps = context.steps
        step = self._step(context)
        self._undo_command = ChangeCellValue(self._row, self._col, step.get_value(self._col))
        step.change(self._col, self._value)
        self._step(context).remove_empty_columns_from_end()
        assert self._validate_postcondition(context), \
            'Should have correct value after change'
        return True

    def _validate_postcondition(self, context):
        value = self._step(context).get_value(self._col).strip()
        should_be = self._value.strip()
        if value == should_be:
            return True
        return self._col == 0 and \
               value.replace(' ', '').upper() == ':FOR' and \
               should_be.replace(' ', '').upper() == ':FOR'

    def _get_undo_command(self):
        return self._undo_command

    def __str__(self):
        return '%s(%s, %s, "%s")' % (self.__class__.__name__, self._row, self._col, self._value)


class SaveFile(_Command):

    def execute(self, context):
        RideSaving(path=context.filename, datafile=context).publish()
        datafile_controller = context.datafile_controller
        for macro_controller in chain(datafile_controller.tests, datafile_controller.keywords):
            macro_controller.execute(Purify())
        datafile_controller.save()
        datafile_controller.unmark_dirty()
        RideSaved(path=context.filename).publish()


class SaveAll(_Command):

    def execute(self, context):
        for datafile_controller in context._get_all_dirty_controllers():
            if datafile_controller.has_format():
                datafile_controller.execute(SaveFile())
        RideSaveAll().publish()


class Purify(_Command):

    def execute(self, context):
        i = 0
        while True:
            if len(context.steps) <= i:
                break
            step = context.steps[i] # Steps can changes during this operation
            # this is why index based iteration - step reference can be stale
            step.remove_empty_columns_from_end()
            if step.has_only_comment():
                step.remove_empty_columns_from_beginning()
            i += 1
        context.execute(DeleteRows(context.get_empty_rows()))
        context.notify_steps_changed()


class InsertCell(_StepsChangingCommand):

    def __init__(self, row, col):
        self._row = row
        self._col = col

    def _params_str(self):
        return '%s, %s' % (self._row, self._col)

    def change_steps(self, context):
        self._step(context).shift_right(self._col)
        assert self._step(context).get_value(self._col) == '', 'Should have an empty value after insert'
        return True

    def _get_undo_command(self):
        return DeleteCell(self._row, self._col)


class DeleteCell(_StepsChangingCommand):

    def __init__(self, row, col):
        self._row = row
        self._col = col

    def _params(self):
        return (self._row, self._col)

    def change_steps(self, context):
        step = self._step(context)
        self._undo_command = StepsChangingCompositeCommand(InsertCell(self._row, self._col),
                                              ChangeCellValue(self._row, self._col,
                                                              step.get_value(self._col)))
        step.shift_left(self._col)
        return True

    def _get_undo_command(self):
        return self._undo_command


class _RowChangingCommand(_StepsChangingCommand):

    def __init__(self, row):
        '''Command that will operate on a given logical `row` of test/user keyword.

        Giving -1 as `row` means that operation is done on the last row.
        '''
        self._row = row

    def change_steps(self, context):
        if len(context.steps) <= self._row:
            return False
        self._change_value(context)
        return True

    def __str__(self):
        return '%s(%s)' % (self.__class__.__name__, self._row)


class DeleteRow(_RowChangingCommand):

    def _change_value(self, context):
        step = context.steps[self._row]
        self._undo_command = StepsChangingCompositeCommand(AddRow(self._row), PasteArea((self._row, 0), [step.as_list()]))
        context.remove_step(self._row)

    def _get_undo_command(self):
        if hasattr(self, '_undo_command'):
            return self._undo_command
        return AddRow(self._row)


class AddRow(_RowChangingCommand):

    def _change_value(self, context):
        row = self._row if self._row != -1 else len(context.steps)
        context.add_step(row)
        assert not(any(i for i in self._step(context).as_list() if i)), \
            'Should have an empty row after add instead %r' % self._step(context).as_list()

    def _get_undo_command(self):
        return DeleteRow(self._row)


class CommentRow(_RowChangingCommand):

    def _change_value(self, context):
        self._step(context).comment()
        return True

    def _get_undo_command(self):
        return UncommentRow(self._row)


class UncommentRow(_RowChangingCommand):

    def _change_value(self, context):
        self._step(context).uncomment()
        return True

    def _get_undo_command(self):
        return CommentRow(self._row)


class MoveRowsUp(_StepsChangingCommand):

    def __init__(self, rows):
        self._rows = rows

    def _params(self):
        return [self._rows]

    def change_steps(self, context):
        if len(self._rows) == 0 or self._last_row > len(context.steps)-1 or self._first_row == 0:
            return False
        number_of_steps_before = len(context.steps)
        for row in self._rows:
            context.move_step_up(row)
        assert len(context.steps) == number_of_steps_before
        return True

    @property
    def _last_row(self):
        return self._rows[-1]

    @property
    def _first_row(self):
        return self._rows[0]

    def _get_undo_command(self):
        return MoveRowsDown([r-1 for r in self._rows if r > 0])


class MoveRowsDown(_StepsChangingCommand):

    def __init__(self, rows):
        self._rows = rows

    def _params(self):
        return [self._rows]

    def change_steps(self, context):
        if len(self._rows) == 0 or self._last_row >= len(context.steps)-1:
            return False
        number_of_steps_before = len(context.steps)
        for row in reversed(self._rows):
            context.move_step_down(row)
        assert len(context.steps) == number_of_steps_before
        return True

    @property
    def _last_row(self):
        return self._rows[-1]

    def _get_undo_command(self):
        return MoveRowsUp([r+1 for r in self._rows])


class CompositeCommand(_ReversibleCommand):

    def __init__(self, *commands):
        self._commands = commands

    def _execute(self, context):
        executions = self._executions(context)
        undos = [undo for _, undo in executions]
        undos.reverse()
        self._undo_command = self._create_undo_command(undos)
        return [result for result, _ in executions]

    def _get_undo_command(self):
        return self._undo_command

    def _create_undo_command(self, undos):
        return CompositeCommand(*undos)

    def _executions(self, context):
        return [(cmd._execute(context), cmd._get_undo_command()) for cmd in self._commands]


class StepsChangingCompositeCommand(_StepsChangingCommand, CompositeCommand):

    def __init__(self, *commands):
        self._commands = commands

    def change_steps(self, context):
        return any(changed for changed in CompositeCommand._execute(self, context))

    def _get_undo_command(self):
        return self._undo_command

    def _create_undo_command(self, undos):
        return StepsChangingCompositeCommand(*undos)

    def _executions(self, context):
        return [(cmd.change_steps(context), cmd._get_undo_command()) for cmd in self._commands]


def DeleteRows(rows):
    return StepsChangingCompositeCommand(*[DeleteRow(r) for r in reversed(sorted(rows))])


def AddRows(rows):
    #TODO: Refactor to use AddRows(_StepsChangingCommand) command
    first_row = sorted(rows)[0]
    return StepsChangingCompositeCommand(*[AddRow(first_row) for _ in rows])


def CommentRows(rows):
    return StepsChangingCompositeCommand(*[CommentRow(r) for r in rows])


def UncommentRows(rows):
    return StepsChangingCompositeCommand(*[UncommentRow(r) for r in rows])


def ClearArea(top_left, bottom_right):
    row_s, col_s = top_left
    row_e, col_e = bottom_right
    return StepsChangingCompositeCommand(*[ChangeCellValue(row, col, '')
                              for row in range(row_s,row_e+1)
                              for col in range(col_s, col_e+1)])


def PasteArea(top_left, content):
    row_s, col_s = top_left
    return StepsChangingCompositeCommand(*[ChangeCellValue(row+row_s, col+col_s, content[row][col])
                              for row in range(len(content))
                              for col in range(len(content[row]))])

def InsertArea(top_left, content):
    row, _ = top_left
    return StepsChangingCompositeCommand(
        AddRows([row+i for i in range(len(content))]),
            PasteArea(top_left, content))

def _rows_from_selection(selection):
    res = []
    for row, col in selection:
        if row not in res:
            res += [row]
    return res

def _cols_from_selection(selection):
    res = []
    for row, col in selection:
        if col not in res:
            res += [col]
    return res

def InsertCells(top_left, bottom_right):
    row_s, col_s = top_left
    row_e, col_e = bottom_right
    return StepsChangingCompositeCommand(*[InsertCell(row, col)
                              for row in range(row_s,row_e+1)
                              for col in range(col_s, col_e+1)])


def DeleteCells(top_left, bottom_right):
    row_s, col_s = top_left
    row_e, col_e = bottom_right
    return StepsChangingCompositeCommand(*[DeleteCell(row, col_s)
                              for row in range(row_s,row_e+1)
                              for _ in range(col_s, col_e+1)])

########NEW FILE########
__FILENAME__ = dataloader
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
from threading import Thread

from robot.parsing.model import TestDataDirectory, TestCaseFile
from robot.parsing.populators import FromFilePopulator, FromDirectoryPopulator


class DataLoader(object):

    def __init__(self, namespace, settings):
        self._namespace = namespace
        self._namespace.reset_resource_and_library_cache()
        self._settings = settings

    def load_datafile(self, path, load_observer):
        return self._load(_DataLoader(path, self._settings), load_observer)

    def load_initfile(self, path, load_observer):
        return self._load(_InitFileLoader(path), load_observer)

    def resources_for(self, datafile, load_observer):
        return self._load(_ResourceLoader(datafile, self._namespace.get_resources), load_observer)

    def _load(self, loader, load_observer):
        self._wait_until_loaded(loader, load_observer)
        return loader.result

    def _wait_until_loaded(self, loader, load_observer):
        loader.start()
        load_observer.notify()
        while loader.isAlive():
            loader.join(0.1)
            load_observer.notify()


class _DataLoaderThread(Thread):

    def __init__(self):
        Thread.__init__(self)
        self.result = None

    def run(self):
        try:
            self.result = self._run()
        except Exception:
            pass # TODO: Log this error somehow


class _DataLoader(_DataLoaderThread):

    def __init__(self, path, settings):
        _DataLoaderThread.__init__(self)
        self._path = path
        self._settings = settings

    def _run(self):
        return TestData(source=self._path, settings=self._settings)


class _InitFileLoader(_DataLoaderThread):

    def __init__(self, path):
        _DataLoaderThread.__init__(self)
        self._path = path

    def _run(self):
        result = TestDataDirectory(source=os.path.dirname(self._path))
        result.initfile = self._path
        FromFilePopulator(result).populate(self._path)
        return result


class _ResourceLoader(_DataLoaderThread):

    def __init__(self, datafile, resource_loader):
        _DataLoaderThread.__init__(self)
        self._datafile = datafile
        self._loader = resource_loader

    def _run(self):
        return self._loader(self._datafile)


class TestDataDirectoryWithExcludes(TestDataDirectory):

    def __init__(self, parent, source, settings):
        self._settings = settings
        TestDataDirectory.__init__(self, parent, source)

    def add_child(self, path, include_suites):
        if not self._settings.excludes.contains(path):
            self.children.append(TestData(parent=self, source=path, settings=self._settings))
        else:
            self.children.append(ExcludedDirectory(self, path))

def TestData(source, parent=None, settings=None):
    """Parses a file or directory to a corresponding model object.

    :param source: path where test data is read from.
    :returns: :class:`~.model.TestDataDirectory`  if `source` is a directory,
        :class:`~.model.TestCaseFile` otherwise.
    """
    if os.path.isdir(source):
        data = TestDataDirectoryWithExcludes(parent, source, settings)
        data.populate()
        return data
    return TestCaseFile(parent, source).populate()

class ExcludedDirectory(TestDataDirectory):
    def __init__(self, parent, path):
        self._parent = parent
        self._path = path
        TestDataDirectory.__init__(self, parent, path)

    def has_tests(self):
        return True
########NEW FILE########
__FILENAME__ = filecontrollers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
from itertools import chain
import shutil
import commands
from robotide.controller.dataloader import ExcludedDirectory, TestData

from robotide.publish import (RideDataFileRemoved, RideInitFileRemoved,
        RideDataChangedToDirty, RideDataDirtyCleared, RideSuiteAdded,
        RideItemSettingsChanged)
from robotide.publish.messages import RideDataFileSet, RideOpenResource
from robotide.robotapi import TestDataDirectory, TestCaseFile, ResourceFile
from robotide import utils

from .basecontroller import WithUndoRedoStacks, _BaseController, WithNamespace, ControllerWithParent
from .macrocontrollers import UserKeywordController
from .robotdata import NewTestCaseFile, NewTestDataDirectory
from robotide.utils import overrides
from .settingcontrollers import (DocumentationController, FixtureController,
        TimeoutController, TemplateController, DefaultTagsController,
        ForceTagsController)
from .tablecontrollers import (VariableTableController, TestCaseTableController,
        KeywordTableController, ImportSettingsController,
        MetadataListController, TestCaseController)


def _get_controller(chief, data, parent):
    if isinstance(data, TestCaseFile):
        return TestCaseFileController(data, chief, parent)
    if isinstance(data, ExcludedDirectory):
        return ExcludedDirectoryController(data, chief, parent)
    return TestDataDirectoryController(data, chief, parent)


def DataController(data, chief, parent=None):
    return _get_controller(chief, data, parent)


class _FileSystemElement(object):

    def __init__(self, filename, directory):
        self.filename = filename
        self.directory = directory
        self._stat = self._get_stat(filename)

    def _get_stat(self, path):
        if path and os.path.isfile(path):
            stat = os.stat(path)
            return stat.st_mtime, stat.st_size
        return 0, 0

    def refresh_stat(self):
        self._stat = self._get_stat(self.filename)

    def has_been_modified_on_disk(self):
        return self._get_stat(self.filename) != self._stat

    def has_been_removed_from_disk(self):
        return self._stat != (0, 0) and not self.exists()

    def relative_path_to(self, other):
        other_path = os.path.join(other.directory, other.filename)
        return os.path.relpath(other_path, start=self.directory).replace('\\', '/')

    def is_readonly(self):
        return not os.access(self.filename, os.W_OK)

    def exists(self):
        return self.filename and os.path.isfile(self.filename)

    @property
    def basename(self):
        return os.path.splitext(os.path.basename(self.filename))[0]

    @property
    def source(self):
        """Deprecated, use ``filename`` or ``directory`` instead."""
        # Todo: remove when backwards compatibility with plugin API can break
        return self.filename or self.directory


class _DataController(_BaseController, WithUndoRedoStacks, WithNamespace):

    def __init__(self, data, chief_controller=None, parent=None):
        self._chief_controller = chief_controller
        if chief_controller:
            self._set_namespace_from(chief_controller)
            self._resource_file_controller_factory =\
                chief_controller.resource_file_controller_factory
        else:
            self._resource_file_controller_factory = None
        self.parent = parent
        self.set_datafile(data)
        self.dirty = False
        self.children = self._children(data)

    def set_datafile(self, datafile):
        self.data = datafile
        self._variables_table_controller = None
        self._testcase_table_controller = None
        self._keywords_table_controller = None
        self._imports = None
        RideDataFileSet(item=self).publish()

    def _children(self, data):
        return []

    @property
    def name(self):
        return self.data.name

    @property
    def settings(self):
        return self._settings()

    def _settings(self):
        ss = self.data.setting_table
        return [DocumentationController(self, ss.doc),
                FixtureController(self, ss.suite_setup),
                FixtureController(self, ss.suite_teardown),
                FixtureController(self, ss.test_setup),
                FixtureController(self, ss.test_teardown),
                self.force_tags]

    @property
    def _setting_table(self):
        return self.data.setting_table

    @property
    def force_tags(self):
        return ForceTagsController(self, self._setting_table.force_tags)

    @property
    def variables(self):
        if self._variables_table_controller is None:
            self._variables_table_controller = \
                    VariableTableController(self, self.data.variable_table)
        return self._variables_table_controller

    @property
    def tests(self):
        if self._testcase_table_controller is None:
            self._testcase_table_controller = \
                    TestCaseTableController(self, self.data.testcase_table)
        return self._testcase_table_controller

    @property
    def datafile(self):
        return self.data

    @property
    def datafiles(self):
        return chain([self], (df for df in self._chief_controller.datafiles
                              if df != self))

    @property
    def datafile_controller(self):
        return self

    @property
    def keywords(self):
        if self._keywords_table_controller is None:
            self._keywords_table_controller = \
                    KeywordTableController(self, self.data.keyword_table)
        return self._keywords_table_controller

    @property
    def imports(self):
        if not self._imports:
            self._imports = ImportSettingsController(self, self.data.setting_table,
                                    self._resource_file_controller_factory)
        return self._imports

    @property
    def metadata(self):
        return MetadataListController(self, self.data.setting_table)

    def is_user_keyword(self, value):
        return WithNamespace.is_user_keyword(self, self.datafile, value)

    def is_library_keyword(self, value):
        return WithNamespace.is_library_keyword(self, self.datafile, value)

    def keyword_info(self, keyword_name):
        return WithNamespace.keyword_info(self, self.data, keyword_name)

    def mark_dirty(self):
        if not self.dirty:
            self.dirty = True
            RideDataChangedToDirty(datafile=self).publish()

    def unmark_dirty(self):
        self.refresh_stat()
        if self.dirty:
            self.dirty = False
            RideDataDirtyCleared(datafile=self).publish()

    def create_keyword(self, name, argstr=''):
        return self.keywords.new(name, argstr)

    def add_test_or_keyword(self, item):
        if isinstance(item, TestCaseController):
            self.tests.add(item)
            item.set_parent(self.tests)
        elif isinstance(item, UserKeywordController):
            self.keywords.add(item)
            item.set_parent(self.keywords)
        else:
            self.variables.add_variable(item.name, item.value, item.comment)

    def sort_keywords(self):
        if self.keywords:
            index_difference = self.keywords.sort()
            self.mark_dirty()
            RideDataFileSet(item=self).publish() #TODO: Use a more gentle message
            return index_difference
        return None

    def restore_keyword_order(self, index_difference):
        if self.keywords and index_difference:
            self.keywords.restore_keyword_order(index_difference)
            self.mark_dirty()
            RideDataFileSet(item=self).publish() #TODO: Use a more gentle message

    def get_keyword_names(self):
        if self.keywords:
            return [kw.name for kw in self.keywords._items]
        return None

    def has_format(self):
        return True

    def get_format(self):
        if not self.filename:
            return None
        return os.path.splitext(self.filename)[1].replace('.', '')

    def set_format(self, format):
        self.data.source = utils.replace_extension(self.filename, format)
        self.filename = self.data.source

    def is_same_format(self, format):
        if format and self.has_format():
            return format.lower() == self.get_format().lower()
        return False

    def set_basename(self, basename):
        old_file = self.filename
        self.data.source = os.path.join(self.directory, '%s.%s' % (basename, self.get_format()))
        self.filename = self.data.source
        self.execute(commands.SaveFile())
        if old_file != self.filename:
            self.remove_from_filesystem(old_file)

    def remove_from_filesystem(self, path=None):
        path = path or self.filename
        if os.path.exists(path):
            os.remove(path)

    def remove_folder_from_filesystem(self, path=None):
        shutil.rmtree(path or self.data.directory)

    def save_with_new_format(self, format):
        self._chief_controller.change_format(self, format)

    def save_with_new_format_recursive(self, format):
        self._chief_controller.change_format_recursive(self, format)

    def validate_keyword_name(self, name):
        return self.keywords.validate_name(name)

    def is_directory_suite(self):
        return False

    def resource_import_modified(self, path):
        return self._chief_controller.resource_import_modified(path, self.directory)

    def notify_settings_changed(self):
        RideItemSettingsChanged(item=self).publish()

    def notify_steps_changed(self):
        for test in self.tests:
            test.notify_steps_changed()

    def iter_datafiles(self):
        yield self
        for child in self.children:
            for datafile in child.iter_datafiles():
                yield datafile

    def save(self):
        self._chief_controller.save(self)

    def get_local_variables(self):
        return {}

    def is_inside_top_suite(self, res):
        return False


class TestDataDirectoryController(_DataController, _FileSystemElement, _BaseController):

    def __init__(self, data, chief_controller=None, parent=None):
        dir_ = data.directory
        dir_ = os.path.abspath(dir_) if isinstance(dir_, basestring) else dir_
        _FileSystemElement.__init__(self, self._filename(data), dir_)
        _DataController.__init__(self, data, chief_controller, parent)
        self._dir_controllers = {}

    def _filename(self, data):
        return data.initfile

    @property
    def default_dir(self):
        return self.data.source

    @property
    def display_name(self):
        return self.data.name

    @property
    def longname(self):
        if self.parent:
            return self.parent.longname + '.' + self.display_name
        return self.display_name

    @property
    def suites(self):
        return [child for child in self.children if
                    isinstance(child, TestDataDirectoryController) or
                    isinstance(child, TestCaseFileController)]

    def add_child(self, child):
        self.children.append(child)

    def contains_tests(self):
        for suite in self.suites:
            if suite.contains_tests():
                return True
        return False

    def find_controller_by_longname(self, longname, testname = None):
        return self.find_controller_by_names(longname.split("."), testname)

    def find_controller_by_names(self, names, testname):
        namestring = '.'.join(names)
        if not namestring.startswith(self.name):
            return None
        if namestring == self.name:
            return self
        for suite in self.suites:
            res = suite.find_controller_by_names(namestring[len(self.name)+1:].split('.'), testname)
            if res:
                return res

    def is_excluded(self):
        return self._chief_controller.is_excluded(self.source) if self._chief_controller else False

    def _children(self, data):
        children = [DataController(child, self._chief_controller, self) for child in data.children]
        if self._can_add_directory_children(data):
            self._add_directory_children(children, data.source, data.initfile)
        return children

    def _can_add_directory_children(self, data):
        return data.source and os.path.isdir(data.source) and self._namespace

    def _add_directory_children(self, children, path, initfile):
        for filename in self._get_unknown_files_in_directory(children, path, initfile):
            if not self._is_robot_ignored_name(filename):
                self._add_directory_child(children, filename)

    def _is_robot_ignored_name(self, filename):
        base = os.path.basename(filename)
        return any(base.startswith(c) for c in '_.')

    def _add_directory_child(self, children, filename):
        if os.path.isdir(filename):
            children.append(self._directory_controller(filename))
        else:
            r = self._namespace.get_resource(filename, report_status=False)
            if self._is_valid_resource(r):
                children.append(self._resource_controller(r))

    def _directory_controller(self, path):
        dc = TestDataDirectoryController(TestDataDirectory(source=path),
                                         chief_controller=self._chief_controller,
                                         parent=self)
        self._add_directory_children(dc.children, dc.source, None)
        return dc

    def _is_valid_resource(self, resource):
        return resource and (resource.setting_table or resource.variable_table or resource.keyword_table or os.stat(resource.source)[6]==0)

    def _resource_controller(self, resource):
        resource_control =  self._resource_file_controller_factory.create(resource)
        resource_control.parent = self
        return resource_control

    def _get_unknown_files_in_directory(self, children, path, initfile):
        already_in_use = [c.filename for c in children] + [initfile]
        already_in_use += [c.directory for c in children]
        return [f for f in self._get_filenames_in_directory(path) if f not in already_in_use]

    def _get_filenames_in_directory(self, path):
        return [os.path.join(path, f) for f in os.listdir(path)]

    def add_child(self, controller):
        assert controller not in self.children
        self.children.append(controller)

    def has_format(self):
        return self.data.initfile is not None

    def set_format(self, format):
        self.data.initfile = os.path.join(self.data.source, '__init__.%s'
                                          % format.lower())
        self.filename = self.data.initfile

    def new_test_case_file(self, path):
        ctrl = self._new_data_controller(NewTestCaseFile(path))
        ctrl.mark_dirty()
        return ctrl

    def new_test_data_directory(self, path):
        return self._new_data_controller(NewTestDataDirectory(path))

    def _new_data_controller(self, datafile):
        self.data.children.append(datafile)
        datafile.parent = self.data
        self.children.append(DataController(datafile, self._chief_controller, self))
        return self.children[-1]

    def notify_suite_added(self, suite):
        RideSuiteAdded(parent=self, suite=suite).publish()

    def is_directory_suite(self):
        return True

    def reload(self):
        self.__init__(TestDataDirectory(source=self.directory, parent=self.data.parent).populate(),
                      self._chief_controller, parent=self.parent)

    def remove(self):
        path = self.filename
        self.data.initfile = None
        self._stat = self._get_stat(None)
        self.reload()
        RideInitFileRemoved(path=path, datafile=self).publish()

    def _remove_resources(self):
        for resource in self._find_resources_recursively(self):
            self._chief_controller.remove_resource(resource)
            RideDataFileRemoved(path=resource.filename, datafile=resource).publish()

    def remove_from_model(self):
        self._chief_controller.remove_datafile(self)
        self._remove_resources()
        RideDataFileRemoved(path=self.filename, datafile=self).publish()

    def remove_child(self, controller):
        if controller in self.children:
            self.children.remove(controller)
        else:
            for child in self.children:
                child.remove_child(controller)

    def is_inside_top_suite(self, ctrl):
        return ctrl.filename.startswith(self.directory)

    def _is_inside_test_data_directory(self, directory):
        return any(True for s in [self] + self.children
                   if s.is_directory_suite() and s.directory == directory)

    def remove_static_imports_to_this(self):
        for resource_import in self.get_where_used():
            resource_import[1].remove()

    def get_where_used(self):
        for imp in self._get_recursive_imports():
            yield imp

    def _all_imports(self):
        for df in self.datafiles:
            for imp in df.imports:
                yield imp

    def _get_recursive_imports(self):
        all_imports = self._all_imports()
        ctrls = self._find_controllers_recursively(self)
        for res in self._find_resources_recursively(self):
            for imp in all_imports:
                if imp.get_imported_controller() == res and imp.parent.parent not in ctrls:
                    yield res, imp

    def _find_resources_recursively(self, controller):
        resources = []
        if controller.children:
            for child in controller.children:
                resources += self._find_resources_recursively(child)
        elif isinstance(controller, ResourceFileController):
            resources.append(controller)
        return resources

    def _find_controllers_recursively(self, controller):
        resources = []
        if controller.children:
            for child in controller.children:
                resources += self._find_controllers_recursively(child)
        resources.append(controller)
        return resources

    def insert_to_test_data_directory(self, res):
        res_dir = os.path.dirname(res.filename)
        if res_dir in self._dir_controllers:
            self._dir_controllers[res_dir].add_child(res)
        else:
            target = self._find_closest_directory(res)
            if target is self:
                self._create_target_dir_controller(res, res_dir, target)
            else:
                target.insert_to_test_data_directory(res)

    def _find_closest_directory(self, res):
        target = self
        for s in self.iter_datafiles():
            if not isinstance(s, TestDataDirectoryController):
                continue
            if res.filename.startswith(s.directory):
                target = s
        return target

    def _create_target_dir_controller(self, res, res_dir, target):
        for dirname in res_dir[len(self.directory):].split(os.sep):
            if not dirname:
                continue
            target_dir = os.path.join(target.directory, dirname)
            dir_ctrl = TestDataDirectoryController(TestDataDirectory(source=target_dir), self._chief_controller, self)
            target._dir_controllers[target.directory] = dir_ctrl
            target.add_child(dir_ctrl)
            if target_dir == res_dir:
                dir_ctrl.add_child(res)
                return
            target = dir_ctrl
        if res not in self.children:
            self.add_child(res)

    def new_resource(self, path):
        ctrl = self._chief_controller.new_resource(path, parent=self)
        ctrl.mark_dirty()
        return ctrl

    def exclude(self):
        if self._chief_controller.is_datafile_dirty(self):
            raise DirtyRobotDataException()
        self._chief_controller._settings.excludes.update_excludes([self.directory])
        index = self.parent.children.index(self)
        result = ExcludedDirectoryController(self.data, self._chief_controller, self.parent)
        self.parent.children[index] = result
        return result


class DirtyRobotDataException(Exception):
    """
    Raised when data is dirty and you are trying to do an operation that requires undirty data.
    """
    pass


class TestCaseFileController(_FileSystemElement, _DataController):

    def __init__(self, data, chief_controller=None, parent=None):
        _FileSystemElement.__init__(self, data.source if data else None, data.directory)
        _DataController.__init__(self, data, chief_controller, parent)

    def _settings(self):
        ss = self._setting_table
        sett = _DataController._settings(self)
        sett.insert(-1, TemplateController(self, ss.test_template))
        sett.insert(-1, TimeoutController(self, ss.test_timeout))
        return sett + [self.default_tags]

    @property
    def longname(self):
        if self.parent:
            return self.parent.longname + '.' + self.name
        return self.name

    @property
    def suites(self):
        return ()

    def contains_tests(self):
        return bool(self.tests)

    def find_controller_by_longname(self, longname, node_testname = None):
        return self.find_controller_by_names(longname.split("."), node_testname)


    def find_controller_by_names(self, names, node_testname = None):
        names = '.'.join(names)
        if not names.startswith(self.name):
            return None
        if len(self.name) < len(names) and not names.startswith(self.name+'.'):
            return None
        if len(names) == 1:
            return self
        for test in self.tests:
            if test.name == node_testname:
                return test
        return None

    @property
    def default_tags(self):
        return DefaultTagsController(self, self._setting_table.default_tags)

    def is_modifiable(self):
        return not self.exists() or not self.is_readonly()

    def create_test(self, name):
        return self.tests.new(name)

    def validate_test_name(self, name):
        return self.tests.validate_name(name)

    def remove_child(self, controller):
        if controller is self:
            self.remove()

    def remove(self):
        self._chief_controller.remove_datafile(self)
        RideDataFileRemoved(path=self.filename, datafile=self).publish()

    def reload(self):
        self.__init__(TestCaseFile(parent=self.data.parent, source=self.filename).populate(),
                      chief_controller=self._chief_controller,
                      parent=self.parent)

    def get_template(self):
        return self.data.setting_table.test_template


class ResourceFileControllerFactory(object):

    def __init__(self, namespace, chief_controller):
        self._resources = []
        self._namespace = namespace
        self._chief_controller = chief_controller
        self._all_resource_imports_resolved = False

    @property
    def resources(self):
        return self._resources

    def find(self, data):
        return self._find_with_source(data.source)

    def _find_with_source(self, source):
        for other in self.resources:
            if other.filename == source:
                return other
        return None

    def find_with_import(self, import_):
        resource_model = self._namespace.find_resource_with_import(import_)
        if not resource_model:
            return None
        res = self.find(resource_model)
        if not res:
            res = self.create(resource_model)
            self._chief_controller.insert_into_suite_structure(res)
        assert(res is not None)
        return res

    def create(self, data, parent=None):
        rfc = ResourceFileController(data, self._chief_controller, parent, self)
        self.resources.append(rfc)
        self.set_all_resource_imports_unresolved()
        return rfc

    def set_all_resource_imports_resolved(self):
        self._all_resource_imports_resolved = True

    def set_all_resource_imports_unresolved(self):
        self._all_resource_imports_resolved = False

    def is_all_resource_file_imports_resolved(self):
        return self._all_resource_imports_resolved

    def remove(self, controller):
        self._resources.remove(controller)
        self.set_all_resource_imports_unresolved()


class ResourceFileController(_FileSystemElement, _DataController):

    def __init__(self, data, chief_controller=None, parent=None, resource_file_controller_factory=None):
        self._resource_file_controller_factory = resource_file_controller_factory
        self._known_imports = set()
        _FileSystemElement.__init__(self, data.source if data else None, data.directory)
        _DataController.__init__(self, data, chief_controller,
                                 parent or self._find_parent_for(chief_controller, data.source))
        if self.parent and self not in self.parent.children:
            self.parent.add_child(self)
        self._unresolve_all_if_none_existing()

    def _unresolve_all_if_none_existing(self):
        if not self.exists() and self._resource_file_controller_factory:
            self._resource_file_controller_factory.set_all_resource_imports_unresolved() # Some import may have referred to this none existing resource

    def _find_parent_for(self, chief_controller, source):
        if not chief_controller:
            return None
        dir = os.path.dirname(source)
        for ctrl in chief_controller.datafiles:
            if ctrl.is_directory_suite() and self._to_os_style(ctrl.directory) == dir:
                return ctrl
        return None

    def _to_os_style(self, path):
        return path.replace('/', os.sep)

    @property
    def display_name(self):
        _, tail = os.path.split(self.data.source)
        return tail

    def is_modifiable(self):
        return not self.exists() or not self.is_readonly()

    def set_format(self, format):
        self._modify_file_name(lambda: _DataController.set_format(self, format),
                               lambda imp: imp.change_format(format))

    def set_basename(self, basename):
        self._modify_file_name(lambda: _DataController.set_basename(self, basename),
                               lambda imp: imp.unresolve())

    def set_basename_and_modify_imports(self, basename):
        old = self.filename
        self._modify_file_name(lambda: _DataController.set_basename(self, basename),
                               lambda imp: imp.change_name(os.path.basename(old), os.path.basename(self.filename)))

    def remove_static_imports_to_this(self):
        name = os.path.basename(self.filename)
        # have to resolve imports before deleting
        # see: http://code.google.com/p/robotframework-ride/issues/detail?id=1119
        imports = [import_ for import_ in self.get_where_used()]
        for resource_import in imports:
            if resource_import.name.endswith(name):
                resource_import.remove()

    def _modify_file_name(self, modification, notification):
        old = self.filename
        modification()
        resource_imports = [resource_import_ for resource_import_ in self.get_where_used()]
        for resource_import in resource_imports:
            notification(resource_import)
        self._namespace.resource_filename_changed(old, self.filename)

    def _settings(self):
        return [DocumentationController(self, self.data.setting_table.doc)]

    def validate_name(self, name):
        for uk in self.data.keyword_table.keywords:
            if uk != name and utils.eq(uk.name, name):
                return 'User keyword with this name already exists.'
        return None

    def reload(self):
        self.__init__(ResourceFile(source=self.filename).populate(), self._chief_controller, parent=self.parent)

    def remove(self):
        self._chief_controller.remove_resource(self)
        RideDataFileRemoved(path=self.filename, datafile=self).publish()

    def remove_known_import(self, _import):
        self._known_imports.remove(_import)

    def add_known_import(self, _import):
        self._known_imports.add(_import)

    def notify_opened(self):
        RideOpenResource(path=self.filename, datafile=self).publish()
        for _import in [ imp for imp in self.imports if imp.is_resource ]:
            _import.import_loaded_or_modified()

    def is_used(self):
        if self._known_imports:
            return True
        if self._resource_file_controller_factory.is_all_resource_file_imports_resolved():
            return False
        return any(self._resolve_known_imports())

    def get_where_used(self):
        if self._resource_file_controller_factory.is_all_resource_file_imports_resolved():
            source = self._known_imports
        else:
            source = self._resolve_known_imports()

        for usage in source:
            yield usage


    def _resolve_known_imports(self):
        for imp in self._all_imports():
            if imp.get_imported_controller() is self:
                yield imp
        self._resource_file_controller_factory.set_all_resource_imports_resolved()

    def _all_imports(self):
        for df in self.datafiles:
            for imp in df.imports:
                yield imp

    def remove_child(self, controller):
        pass

class ExcludedDirectoryController(_FileSystemElement, ControllerWithParent, WithNamespace):

    def __init__(self, data, chief, parent):
        self.data = data
        self._chief_controller = chief
        if self._chief_controller:
            self._set_namespace_from(self._chief_controller)
            self._resource_file_controller_factory =\
            self._chief_controller.resource_file_controller_factory
        else:
            self._resource_file_controller_factory = None
        self._parent = parent
        self.children = []
        self.keywords = []
        self.variables = tuple()
        self.tests = tuple()
        self.imports = tuple()
        _FileSystemElement.__init__(self, '', data.directory)

    @property
    def settings(self):
        return self._settings()

    def _settings(self):
        ss = self.data.setting_table
        return [DocumentationController(self, ss.doc),
                FixtureController(self, ss.suite_setup),
                FixtureController(self, ss.suite_teardown),
                FixtureController(self, ss.test_setup),
                FixtureController(self, ss.test_teardown),
                self.force_tags]

    @property
    def _setting_table(self):
        return self.data.setting_table

    @property
    def force_tags(self):
        return ForceTagsController(self, self._setting_table.force_tags)

    @property
    def dirty(self):
        return False

    def keyword_info(self, keyword_name):
        return WithNamespace.keyword_info(self, self.data, keyword_name)

    @overrides(_BaseController)
    def is_excluded(self):
        return True

    def remove_from_excludes(self):
        self._chief_controller._settings.excludes.remove_path(self.source)
        index = self.parent.children.index(self)
        td = TestData(self.data.source, self.parent.data, self._chief_controller._settings)
        result = TestDataDirectoryController(td, self._chief_controller, self.parent)
        self.parent.children[index] = result
        return result

    def iter_datafiles(self):
        return [self]

    @property
    def name(self):
        return self.data.name

    def is_directory_suite(self):
        return True

    def add_child(self, child):
        self.children.append(child)

########NEW FILE########
__FILENAME__ = macrocontrollers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from itertools import chain

from robot.parsing.tablepopulators import UserKeywordPopulator, TestCasePopulator
from robot.parsing.model import Step, ResourceFile

from robotide.controller.basecontroller import ControllerWithParent,\
    _BaseController
from robotide.controller.settingcontrollers import (DocumentationController,
        FixtureController, TagsController, TimeoutController,
        TemplateController, ArgumentsController, ReturnValueController)
from robotide.controller.arguments import parse_arguments_to_var_dict
from robotide.controller.basecontroller import WithUndoRedoStacks
from robotide.namespace.local_namespace import LocalNamespace
from robotide.publish.messages import RideItemStepsChanged, RideItemNameChanged,\
    RideItemSettingsChanged
from robotide.controller.stepcontrollers import ForLoopStepController,\
    StepController, IntendedStepController
import os
from robotide.spec.iteminfo import ResourceUserKeywordInfo, TestCaseUserKeywordInfo
from robotide.controller.tags import Tag
from robotide import utils


KEYWORD_NAME_FIELD = 'Keyword Name'
TESTCASE_NAME_FIELD = 'Test Case Name'

def _empty_step():
    return Step([])


class ItemNameController(object):

    def __init__(self, item):
        self._item = item

    def contains_keyword(self, name):
        if isinstance(name, basestring):
            return self._item.name == name
        return name.match(self._item.name)

    def contains_variable(self, name):
        return utils.value_contains_variable(self._item.name, name)

    def replace_keyword(self, new_name, old_value=None):
        self._item.rename(new_name)

    def rename(self, new_name):
        self._item.rename(new_name)

    def notify_value_changed(self):
        self._item.notify_name_changed()

    @property
    def parent(self):
        return self._item


class KeywordNameController(ItemNameController):
    _name_field = KEYWORD_NAME_FIELD


class TestCaseNameController(ItemNameController):
    _name_field = TESTCASE_NAME_FIELD


class _WithStepsController(ControllerWithParent, WithUndoRedoStacks):

    def __init__(self, parent_controller, data):
        self._parent = parent_controller
        self.data = data
        self._init(data)
        self._has_steps_changed = True
        self._steps_cached = None
        self.datafile_controller.register_for_namespace_updates(self._clear_cached_steps)

    @property
    def source(self):
        return os.path.basename(self.data.source) if self.data.source else ''

    @property
    def name(self):
        return self.data.name

    @property
    def steps(self):
        if self._has_steps_changed:
            self._recreate_steps()
        return self._steps_cached

    def set_parent(self, new_parent):
        self._clear_cached_steps()
        ControllerWithParent.set_parent(self, new_parent)

    def _recreate_steps(self):
        flattened_steps = []
        for step in self.data.steps:
            if step.is_for_loop():
                for_loop = ForLoopStepController(self, step)
                flattened_steps.append(for_loop)
                flattened_steps.extend(for_loop.steps)
            else:
                flattened_steps.append(StepController(self, step))
        self._steps_cached = flattened_steps
        self._has_steps_changed = False

    def _clear_cached_steps(self):
        self._has_steps_changed = True
        self._steps_cached = None

    @property
    def max_columns(self):
        return max(chain((len(step.as_list()) for step in self.steps) , [0]))

    def has_template(self):
        return False

    def step(self, index):
        return self.steps[index]

    def index_of_step(self, step):
        return [s._step for s in self.steps].index(step)

    def replace_step(self, index, new_step):
        corrected_index = index
        for i in range(index):
            if isinstance(self.step(i), IntendedStepController):
                corrected_index -= 1
        self.data.steps[corrected_index] = new_step
        self._has_steps_changed = True

    def move_step_up(self, index):
        self.step(index).move_up()
        self._has_steps_changed = True

    def move_step_down(self, index):
        self.step(index).move_down()
        self._has_steps_changed = True

    def set_steps(self, steps):
        self.data.steps = steps
        self._has_steps_changed = True

    def update_namespace(self):
        self.datafile_controller.update_namespace()

    def get_local_namespace(self):
        return LocalNamespace(self, self.datafile_controller._namespace)

    def get_local_namespace_for_row(self, row):
        return LocalNamespace(self, self.datafile_controller._namespace, row)

    def get_cell_info(self, row, col):
        steps = self.steps
        if row < 0 or len(steps) <= row:
            return None
        return steps[row].get_cell_info(col)

    def get_keyword_info(self, kw_name):
        return self.datafile_controller.keyword_info(kw_name)

    def is_user_keyword(self, value):
        return self.datafile_controller.is_user_keyword(value)

    def is_library_keyword(self, value):
        return self.datafile_controller.is_library_keyword(value)

    def delete(self):
        self.datafile_controller.unregister_namespace_updates(self._clear_cached_steps)
        return self._parent.delete(self)

    def rename(self, new_name):
        self.data.name = new_name.strip()
        self.mark_dirty()

    def copy(self, name):
        new = self._parent.new(name)
        for orig, copied in zip(self.settings, new.settings):
            copied.set_from(orig)
        new.data.steps = [Step(s.as_list()) for s in self.steps]
        new.notify_steps_changed()
        return new

    def get_empty_rows(self):
        return [index for index, step in enumerate(self.steps) if self._is_empty_step(step)]

    def _is_empty_step(self, step):
        return step.as_list() == []

    def remove_step(self, index):
        self._remove_step(self.steps[index])
        self._has_steps_changed = True

    def recreate(self):
        self._parent.add(self)

    def _remove_step(self, step):
        step.remove()
        self._has_steps_changed = True

    def add_step(self, index, step=None):
        if step is None:
            step = _empty_step()
        if index == len(self.steps):
            self.data.steps.append(step)
        else:
            previous_step = self.step(index)
            previous_step.insert_before(step)
        self._has_steps_changed = True

    def create_keyword(self, name, argstr):
        name = self._remove_bdd_prefix(name)
        validation = self.datafile_controller.validate_keyword_name(name)
        if validation.error_message:
            raise ValueError(validation.error_message)
        return self.datafile_controller.create_keyword(name, argstr)

    def _remove_bdd_prefix(self, name):
        matcher = name.lower()
        for match in ['given ', 'when ', 'then ', 'and ']:
            if matcher.startswith(match):
                return name[len(match):]
        return name

    def create_test(self, name):
        return self.datafile_controller.create_test(name)

    def extract_keyword(self, name, argstr, step_range):
        extracted_steps = self._extract_steps(step_range)
        self._replace_steps_with_kw(name, step_range)
        self._create_extracted_kw(name, argstr, extracted_steps)

    def get_raw_steps(self):
        self._has_steps_changed = True # Reveales inner state so can't be sure if cache is up to date
        return self.data.steps

    def set_raw_steps(self, steps):
        self.data.steps = steps
        self._has_steps_changed = True

    def _extract_steps(self, step_range):
        rem_start, rem_end = step_range
        extracted_steps = self.steps[rem_start:rem_end + 1]
        return self._convert_controller_to_steps(extracted_steps)

    def _convert_controller_to_steps(self, step_controllers):
        return [Step(s.as_list()) for s in step_controllers]

    def _replace_steps_with_kw(self, name, step_range):
        steps_before_extraction_point = self._convert_controller_to_steps(self.steps[:step_range[0]])
        extracted_kw_step = [Step([name])]
        steps_after_extraction_point = self._convert_controller_to_steps(self.steps[step_range[1] + 1:])
        self.set_steps(steps_before_extraction_point + extracted_kw_step +
                       steps_after_extraction_point)

    def _create_extracted_kw(self, name, argstr, extracted_steps):
        controller = self.datafile_controller.create_keyword(name, argstr)
        controller.set_steps(extracted_steps)
        return controller

    def validate_name(self, name):
        return self._parent.validate_name(name, self)

    def notify_name_changed(self):
        self.update_namespace()
        self._notify(RideItemNameChanged)

    def notify_settings_changed(self):
        self.update_namespace()
        self._notify(RideItemSettingsChanged)

    def notify_steps_changed(self):
        self._has_steps_changed = True
        self._notify(RideItemStepsChanged)

    def _notify(self, messageclass):
        self.mark_dirty()
        messageclass(item=self).publish()


class TestCaseController(_WithStepsController):

    _populator = TestCasePopulator
    filename = ""

    def _init(self, test):
        self._test = test

    def __eq__(self, other):
        if self is other : return True
        if other.__class__ != self.__class__ : return False
        return self._test == other._test

    @property
    def longname(self):
        return self.parent.parent.longname+'.'+self.data.name

    @property
    def test_name(self):
        return TestCaseNameController(self)

    @property
    def tags(self):
        return TagsController(self, self._test.tags)

    @property
    def force_tags(self):
        return self.datafile_controller.force_tags

    @property
    def default_tags(self):
        return self.datafile_controller.default_tags

    def add_tag(self, name):
        self.tags.add(Tag(name))

    @property
    def settings(self):
        return [self.documentation,
                FixtureController(self, self._test.setup),
                FixtureController(self, self._test.teardown),
                TimeoutController(self, self._test.timeout),
                TemplateController(self, self._test.template),
                self.tags]

    @property
    def documentation(self):
        return DocumentationController(self, self._test.doc)

    def move_up(self):
        return self._parent.move_up(self._test)

    def move_down(self):
        return self._parent.move_down(self._test)

    def validate_test_name(self, name):
        return self._parent.validate_name(name)

    def validate_keyword_name(self, name):
        return self.datafile_controller.validate_keyword_name(name)

    def get_local_variables(self):
        return {}

    def has_template(self):
        template = self._get_template()
        if not template:
            return False
        return bool(template.value)

    def _get_template(self):
        template = self._test.template
        if template.value is not None:
            return template
        return self.datafile_controller.get_template()


class UserKeywordController(_WithStepsController):
    _populator = UserKeywordPopulator
    _TEARDOWN_NOT_SET = object()
    _teardown = _TEARDOWN_NOT_SET

    def _init(self, kw):
        self._kw = kw

    def __eq__(self, other):
        if self is other:
            return True
        if other.__class__ != self.__class__:
            return False
        return self._kw == other._kw

    @property
    def info(self):
        if isinstance(self.datafile, ResourceFile):
            return ResourceUserKeywordInfo(self.data)
        return TestCaseUserKeywordInfo(self.data)

    @property
    def keyword_name(self):
        return KeywordNameController(self)

    def move_up(self):
        return self._parent.move_up(self._kw)

    def move_down(self):
        return self._parent.move_down(self._kw)

    @property
    def settings(self):
        result = [DocumentationController(self, self._kw.doc),
                  ArgumentsController(self, self._kw.args),
                  TimeoutController(self, self._kw.timeout),
                  ReturnValueController(self, self._kw.return_)]
        if hasattr(self._kw, 'teardown'):
            result = result[:2] + \
                     [self.teardown] + result[2:]
        return result

    @property
    def teardown(self):
        if self._teardown == self._TEARDOWN_NOT_SET:
            self._teardown = None
            if hasattr(self._kw, 'teardown'):
                self._teardown = FixtureController(self, self._kw.teardown)
        return self._teardown

    @property
    def arguments(self):
        return ArgumentsController(self, self._kw.args)

    def validate_keyword_name(self, name):
        return self._parent.validate_name(name)

    def get_local_variables(self):
        return parse_arguments_to_var_dict(self._kw.args.value, self._kw.name)

########NEW FILE########
__FILENAME__ = robotdata
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot.parsing.model import TestCaseFile, TestDataDirectory


def NewTestCaseFile(path):
    datafile = TestCaseFile(source=path)
    _create_missing_directories(datafile.directory)
    return datafile


def NewTestDataDirectory(path):
    dirname = os.path.dirname(path)
    datafile = TestDataDirectory(source=dirname)
    datafile.initfile = path
    _create_missing_directories(dirname)
    return datafile


def _create_missing_directories(dirname):
    if not os.path.isdir(dirname):
        os.makedirs(dirname)

########NEW FILE########
__FILENAME__ = settingcontrollers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
from itertools import chain
from robot.parsing.settings import Comment

from robotide.publish.messages import (RideImportSettingChanged,
        RideImportSettingRemoved, RideVariableUpdated, RideItemSettingsChanged, RideImportSettingAdded)
from robotide import utils
from robotide.utils import overrides

from .tags import Tag, ForcedTag, DefaultTag
from .basecontroller import ControllerWithParent


class _SettingController(ControllerWithParent):
    def __init__(self, parent_controller, data):
        self._parent = parent_controller
        self._data = data
        self.label = self._label(self._data)
        self._init(self._data)

    def _label(self, data):
        label = data.setting_name
        if label.startswith('['):
            return label[1:-1]
        return label

    @property
    def _value(self):
        return [v.replace('|', '\\|') for v in self.as_list()[1:]]

    @property
    def value(self):
        value = self._value
        if self._data.comment:
            value.pop()
        return ' | '.join(value)

    @property
    def display_value(self):
        return ' | ' .join(self._value)

    def as_list(self):
        return self._data.as_list()

    @property
    def comment(self):
        return self._data.comment

    @property
    def keyword_name(self):
        return ''

    def contains_keyword(self, name):
        return self._contains_keyword(name.match if not isinstance(name, basestring) else lambda i: utils.eq(i, name))

    def _contains_keyword(self, matcher_function):
        return any(matcher_function(item or '') for item in self.as_list())

    def contains_variable(self, name):
        return utils.value_contains_variable(self.value, name)

    @property
    def is_set(self):
        return self._data.is_set()

    def set_from(self, other):
        if other.is_set:
            self.set_value(other.value)
        self.set_comment(other.comment)

    def set_value(self, value):
        if self._changed(value):
            self._set(value)
            self.mark_dirty()
            RideItemSettingsChanged(item=self._parent).publish()

    def set_comment(self, comment):
        if comment != self.comment:
            if not isinstance(comment, Comment):
                comment = Comment(comment)
            self._data.comment = comment
            self.mark_dirty()

    def notify_value_changed(self):
        self._parent.notify_settings_changed()

    def clear(self):
        self._data.reset()
        self.mark_dirty()

    def _changed(self, value):
        return value != self._data.value

    def _set(self, value):
        self._data.value = value

    def _split_from_separators(self, value):
        return utils.split_value(value)


class DocumentationController(_SettingController):
    newline_regexps = (re.compile(r'(\\+)r\\n'),
                       re.compile(r'(\\+)n'),
                       re.compile(r'(\\+)r'))

    def _init(self, doc):
        self._doc = doc

    @property
    def value(self):
        return self._doc.value

    @overrides(_SettingController)
    def contains_keyword(self, name):
        return False

    def _get_editable_value(self):
        return self._unescape_newlines_and_handle_escaped_backslashes(self.value)

    def _set_editable_value(self, value):
        self.set_value(self._escape_newlines_and_leading_hash(value))

    editable_value = property(_get_editable_value, _set_editable_value)

    @property
    def visible_value(self):
        return utils.html_format(utils.unescape(self.value))

    def _unescape_newlines_and_handle_escaped_backslashes(self, item):
        for regexp in self.newline_regexps:
            item = regexp.sub(self._newline_replacer, item)
        return item

    def _newline_replacer(self, match):
        blashes = len(match.group(1))
        if blashes % 2 == 1:
            return '\\' * (blashes - 1) + '\n'
        return match.group()

    def _escape_newlines_and_leading_hash(self, item):
        for newline in ('\r\n', '\n', '\r'):
            item = item.replace(newline, '\\n')
        if item.strip().startswith('#'):
            item = '\\' + item
        return item


class FixtureController(_SettingController):

    def _init(self, fixture):
        self._fixture = fixture

    @property
    def keyword_name(self):
        return self._fixture.name

    def replace_keyword(self, new_name, old_value=None):
        self._fixture.name = new_name
        self.mark_dirty()

    def _changed(self, value):
        name, args = self._parse(value)
        return self._fixture.name != name or self._fixture.args != args

    def _set(self, value):
        name, args = self._parse(value)
        self._fixture.name = name
        self._fixture.args = args

    def _parse(self, value):
        value = self._split_from_separators(value)
        return (value[0], value[1:]) if value else ('', [])


class TagsController(_SettingController):

    def _init(self, tags):
        self._tags = tags

    def empty_tag(self):
        return Tag(None, controller=self)

    def _changed(self, value):
        return self._tags.value != self._split_from_separators(value)

    def set_from(self, other):
        if other.is_set and other._tags.value is not None:
            self.set_value(other.value)
        self.set_comment(other.comment)

    def _set(self, value):
        self._tags.value = self._split_from_separators(value)

    def add(self, tag):
        if self._tags.value is None:
            self._tags.value = []
        tag.set_index(len(self._tags.value))
        self._tags.value.append(tag.name)

    def __iter__(self):
        forced = self._parent.force_tags
        if self._tags.value is None:
            return chain(forced,
                    self._parent.default_tags).__iter__()
        if len(self._tags.value) == 0:
            return chain(forced, [Tag('', controller=self)])
        return chain(forced,
                (Tag(t, index, self) for index, t in enumerate(self._tags.value))).__iter__()

    @property
    def is_set(self):
        return any(self)

    @property
    def display_value(self):
        return ' | ' .join(tag.name.replace('|', '\\|') for tag in self)


class DefaultTagsController(TagsController):

    def empty_tag(self):
        return DefaultTag(None, controller=self)

    def __iter__(self):
        if self._tags.value is None:
            return [].__iter__()
        return (DefaultTag(t, index, self) for index, t in enumerate(self._tags.value)).__iter__()


class ForceTagsController(TagsController):

    def empty_tag(self):
        return ForcedTag(None, controller=self)

    def __iter__(self):
        return self._recursive_gather_from(self.parent, []).__iter__()

    def __eq__(self, other):
        if self is other:
            return True
        if other is None:
            return False
        if not isinstance(other, self.__class__):
            return False
        return self._tags == other._tags

    def _recursive_gather_from(self, obj, result):
        if obj is None:
            return result
        force_tags = obj._setting_table.force_tags
        return self._recursive_gather_from(obj.parent,
                                           self._gather_from_data(force_tags, obj.force_tags)+
                                           result)

    def _gather_from_data(self, tags, parent):
        if tags.value is None:
            return []
        return [ForcedTag(t, index, parent) for index, t in enumerate(tags.value)]


class TimeoutController(_SettingController):

    def _init(self, timeout):
        self._timeout = timeout

    def _changed(self, value):
        val, msg = self._parse(value)
        return self._timeout.value != val or self._timeout.message != msg

    def _set(self, value):
        value, message = self._parse(value)
        self._timeout.value = value
        self._timeout.message = message

    def _parse(self, value):
        parts = value.split('|', 1)
        val = parts[0].strip() if parts else ''
        msg = parts[1].strip() if len(parts) == 2 else ''
        return val, msg


class TemplateController(_SettingController):

    def _init(self, template):
        self._template = template

    def _set(self, value):
        _SettingController._set(self, value)
        self._parent.notify_steps_changed()

    def clear(self):
        _SettingController.clear(self)
        self._parent.notify_steps_changed()

    @property
    def keyword_name(self):
        return self._template.value

    def replace_keyword(self, new_name, old_name=None):
        self._template.value = new_name
        self.mark_dirty()


class ArgumentsController(_SettingController):

    def _init(self, args):
        self._args = args

    def _changed(self, value):
        return self._args.value != self._split_from_separators(value)

    def _set(self, value):
        self._args.value = self._split_from_separators(value)
        self._parent.notify_settings_changed()

    def clear(self):
        _SettingController.clear(self)
        self._parent.notify_settings_changed()

class ReturnValueController(_SettingController):

    def _init(self, return_):
        self._return = return_

    def _label(self, data):
        return 'Return Value'

    def _changed(self, value):
        return self._return.value != self._split_from_separators(value)

    def _set(self, value):
        self._return.value = self._split_from_separators(value)


class MetadataController(_SettingController):

    def _init(self, meta):
        self._meta = meta

    @property
    def name(self):
        return self._meta.name

    @property
    def value(self):
        return self._meta.value

    def set_value(self, name, value):
        self._meta.name = name
        self._meta.value = value
        self._parent.mark_dirty()


class VariableController(_SettingController):

    def _init(self, var):
        self._var = var

    def _label(self, data):
        return ''

    def __eq__(self, other):
        if not other:
            return False
        if self is other:
            return True
        if self._var == other._var:
            return True
        return False

    def __ne__(self, other):
        return not (self == other)

    @property
    def name(self):
        return self._var.name

    @property
    def value(self):
        return self._var.value

    @property
    def comment(self):
        return self._var.comment

    @property
    def data(self):
        return self._data

    @property
    def index(self):
        return self.parent.index(self)

    def set_value(self, name, value):
        value = [value] if isinstance(value, basestring) else value
        self._var.name = name
        self._var.value = value
        self._parent.mark_dirty()

    def has_data(self):
        return self._data.has_data()

    def delete(self):
        self._parent.remove_var(self)

    def notify_value_changed(self):
        RideVariableUpdated(item=self).publish()

    def notify_variable_added(self):
        self.parent.notify_variable_added(self)

    def validate_name(self, new_name):
        if utils.is_scalar_variable(self.name):
            return self.parent.validate_scalar_variable_name(new_name, self)
        return self.parent.validate_list_variable_name(new_name, self)

    def __eq__(self, other):
        if self is other : return True
        if other.__class__ != self.__class__ : return False
        return self._var == other._var

    def __hash__(self):
        return hash(self._var)+1


def ImportController(parent, import_):
    if import_.type == 'Resource':
        return ResourceImportController(parent, import_)
    elif import_.type == 'Library':
        return LibraryImportController(parent, import_)
    return VariablesImportController(parent, import_)


class _ImportController(_SettingController):

    def _init(self, import_):
        self._import = import_
        self.type = self._import.type

    def _label(self, data):
        return data.type

    @property
    def name(self):
        return self._import.name

    @property
    def alias(self):
        return self._import.alias or ''

    @property
    def args(self):
        return self._import.args or []

    @property
    def display_value(self):
        value = self.args + (['WITH NAME' , self.alias] if self.alias else [])
        return ' | '.join(value)

    @property
    def dirty(self):
        return self._parent.dirty

    def has_error(self):
        return False

    def get_imported_controller(self):
        return None

    def set_value(self, name, args=None, alias=''):
        self._import.name = name
        self._import.args = utils.split_value(args or [])
        self._import.alias = alias
        self._parent.mark_dirty()
        self.publish_edited()
        self.import_loaded_or_modified()
        return self

    def import_loaded_or_modified(self):
        self._parent.notify_imports_modified()
        if not self.is_resource:
            return
        self._parent.resource_import_modified(self.name)

    def remove(self):
        self.parent.remove_import_data(self._import)

    def publish_added(self):
        RideImportSettingAdded(datafile=self.datafile_controller,
            import_controller=self, type=self.type.lower()).publish()

    def publish_edited(self):
        RideImportSettingChanged(datafile=self.datafile_controller,
            import_controller=self, type=self.type.lower()).publish()

    def publish_removed(self):
        RideImportSettingRemoved(datafile=self.datafile_controller,
                                 import_controller=self,
                                 type=self.type.lower()).publish()


class ResourceImportController(_ImportController):
    is_resource = True
    _resolved_import = False
    _previous_imported_controller = None

    def set_value(self, name, args=None, alias=''):
        self._previous_imported_controller = self.get_imported_controller()
        self.unresolve()
        _ImportController.set_value(self, name, args, alias)

    def get_imported_controller(self):
        if not self._resolved_import:
            self._imported_resource_controller = \
                self.parent.resource_file_controller_factory.find_with_import(self._import)
            if self._imported_resource_controller:
                self._imported_resource_controller.add_known_import(self)
            self._resolved_import = True
        return self._imported_resource_controller

    @overrides(_ImportController)
    def has_error(self):
        return self.get_imported_controller() is None

    @overrides(_ImportController)
    def publish_added(self):
        self.get_imported_controller() #Resolve the import <-> ResourceFileController link
        _ImportController.publish_added(self)

    @overrides(_ImportController)
    def publish_removed(self):
        self._previous_imported_controller = self.get_imported_controller()
        self.unresolve() #Unresolve the import <-> ResourceFileController link
        self._prevent_resolve()
        _ImportController.publish_removed(self)

    def _prevent_resolve(self):
        self._resolved_import = True
        self._imported_resource_controller = None

    def get_previous_imported_controller(self):
        return self._previous_imported_controller

    def unresolve(self):
        if self._resolved_import and self._imported_resource_controller:
            self._imported_resource_controller.remove_known_import(self)
        self._resolved_import = False

    def contains_filename(self, filename):
        return self.name.endswith(filename)

    def change_name(self, old_name, new_name):
        if self.contains_filename(old_name):
            self.set_value(self.name[:-len(old_name)] + new_name)
        else:
            # If original result has changed and this import relays on variables
            # can't know if import is still resolved
            self.unresolve()

    def change_format(self, format):
        if self._has_format():
            self.set_value(utils.replace_extension(self.name, format))
        else:
            self.unresolve()

    def _has_format(self):
        parts = self.name.rsplit('.', 1)
        if len(parts) == 1:
            return False
        return parts[-1].lower() in ['html', 'txt', 'tsv', 'robot']


class LibraryImportController(_ImportController):
    is_resource = False

    @overrides(_ImportController)
    def has_error(self):
        return not self.parent.parent.is_library_import_ok(self._data)


class VariablesImportController(_ImportController):
    is_resource = False

    @overrides(_ImportController)
    def has_error(self):
        return not self.parent.parent.is_variables_import_ok(self._data)

########NEW FILE########
__FILENAME__ = stepcontrollers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from robot.parsing.model import Step, ForLoop
from robotide import utils
from robotide.controller.basecontroller import _BaseController
from robotide.controller.cellinfo import (CellPosition, CellType, CellInfo,
                                          CellContent, ContentType)
from robotide.namespace.local_namespace import LocalNamespace
from robotide.utils import overrides


class StepController(_BaseController):

    _GIVEN_WHEN_THEN_MATCHER = re.compile(r'^(given|when|then|and)\s*', re.I)

    def __init__(self, parent, step):
        self._init(parent, step)
        self._step.args = self._change_last_empty_to_empty_var(self._step.args, self._step.comment)

    def _init(self, parent, step):
        self.parent = parent
        self._step = step
        self._cell_info_cache = {}

    @property
    def display_name(self):
        return 'Step'

    @property
    def datafile_controller(self):
        return self.parent.datafile_controller

    def _change_last_empty_to_empty_var(self, args, comment):
        if comment:
            return args
        return args[:-1] + ['${EMPTY}'] if args and args[-1] == '' else args

    def get_keyword_info(self, kw):
        if not kw:
            return None
        return self.parent.get_keyword_info(kw)

    def __eq__(self, other):
        if self is other : return True
        return self._steps_are_equal(self._step, other._step)

    def _steps_are_equal(self, fst, snd):
        if fst is snd: return True
        if not snd: return False
        return (fst.assign == snd.assign and
                fst.keyword == snd.keyword and
                fst.args == snd.args)

    def get_value(self, col):
        values = self.as_list()
        if len(values) <= col :
            return ''
        return values[col]

    def get_cell_info(self, col):
        if col not in self._cell_info_cache:
            position = self._get_cell_position(col)
            content = self._get_content_with_type(col, position)
            self._cell_info_cache[col] = self._build_cell_info(content, position)
        return self._cell_info_cache[col]

    @property
    def assignments(self):
        return self._step.assign

    def is_assigning(self, value):
        for assignment in self.assignments:
            if assignment.replace('=', '').strip() == value.replace('=', '').strip():
                return True
        return False

    def _build_cell_info(self, content, position):
        return CellInfo(content, position)

    def _get_cell_position(self, col):
        # TODO: refactor
        if self.parent.has_template():
            return CellPosition(CellType.UNKNOWN, None)
        col -= len(self._step.assign)
        if col < 0:
            return CellPosition(CellType.ASSIGN, None)
        if col == 0:
            return CellPosition(CellType.KEYWORD, None)
        info = self.get_keyword_info(self._step.keyword)
        if not info:
            return CellPosition(CellType.UNKNOWN, None)
        args = info.arguments
        args_amount = len(args)
        if args_amount == 0:
            return CellPosition(CellType.MUST_BE_EMPTY, None)
        if col >= args_amount and self._last_argument_is_varargs(args):
            return CellPosition(CellType.OPTIONAL, args[-1])
        if self._has_list_var_value_before(col-1):
            return CellPosition(CellType.UNKNOWN, None)
        if col > args_amount:
            return CellPosition(CellType.MUST_BE_EMPTY, None)
        if col <= self._number_of_mandatory_arguments(args, args_amount):
            return CellPosition(CellType.MANDATORY, args[col-1])
        return CellPosition(CellType.OPTIONAL, args[col-1])

    def _number_of_mandatory_arguments(self, args, args_amount):
        defaults = [arg for arg in args if '=' in arg]
        n = args_amount - len(defaults)
        if self._last_argument_is_varargs(args):
            n -= 1
        return n

    def _last_argument_is_varargs(self, args):
        return args[-1].startswith('*')

    def _has_list_var_value_before(self, arg_index):
        for idx, value in enumerate(self.args):
            if idx > arg_index:
                return False
            if utils.is_list_variable(value) and \
               not utils.is_list_variable_subitem(value):
                return True
        return False

    def _get_content_with_type(self, col, position):
        value = self.get_value(col)
        if self._is_commented(col):
            return CellContent(ContentType.COMMENTED, value)
        if self._get_last_none_empty_col_idx() < col:
            return CellContent(ContentType.EMPTY, value)
        if utils.is_variable(value):
            if self._is_unknow_variable(value, position):
                return CellContent(ContentType.UNKNOWN_VARIABLE, value)
            return CellContent(ContentType.VARIABLE, value)
        if self.is_user_keyword(value):
            return CellContent(ContentType.USER_KEYWORD, value, self.get_keyword_info(value).source)
        if self.is_library_keyword(value):
            return CellContent(ContentType.LIBRARY_KEYWORD, value, self.get_keyword_info(value).source)
        return CellContent(ContentType.STRING, value)

    def _is_unknow_variable(self, value, position):
        if position.type == CellType.ASSIGN:
            return False
        is_known = self._get_local_namespace().has_name(value)
        if is_known:
            return False
        inner_value = value[2:-1]
        modified = re.split(r'\W', inner_value, 1)[0]
        return not self._get_local_namespace().has_name('%s{%s}' % (value[0],modified))

    def _get_local_namespace(self):
        index = self.parent.index_of_step(self._step)
        return LocalNamespace(self.parent, self.datafile_controller._namespace, index)

    def _get_last_none_empty_col_idx(self):
        values = self.as_list()
        for i in reversed(range(len(values))):
            if values[i].strip() != '':
                return i
        return None

    def is_modifiable(self):
        return self.datafile_controller.is_modifiable()

    def is_user_keyword(self, value):
        return self.parent.is_user_keyword(value)

    def is_library_keyword(self, value):
        return self.parent.is_library_keyword(value)

    def as_list(self):
        return self._step.as_list()

    def contains_variable(self, name):
        return any(utils.value_contains_variable(item, name) for item in self.as_list())

    def contains_variable_assignment(self, name):
        return any(utils.value_contains_variable(item, "%s=" % name) for item in self.as_list())

    def contains_keyword(self, name):
        return any(self._kw_name_match(item, name) for item in [self.keyword or ''] + self.args)

    def _kw_name_match(self, item, expected):
        if isinstance(expected, basestring):
            return utils.eq(item, expected) or (
                self._GIVEN_WHEN_THEN_MATCHER.match(item) and
                utils.eq(self._GIVEN_WHEN_THEN_MATCHER.sub('', item), expected))
        return expected.match(item)

    def replace_keyword(self, new_name, old_name):
        if self._kw_name_match(self.keyword or '', old_name):
            self._step.keyword = self._kw_name_replace(self.keyword, new_name, old_name)
        for index, value in enumerate(self.args):
            if self._kw_name_match(value, old_name):
                self._step.args[index] = self._kw_name_replace(value, new_name, old_name)

    def _kw_name_replace(self, old_value, new_match, old_match):
        old_prefix_matcher = self._GIVEN_WHEN_THEN_MATCHER.match(old_value)
        if not old_prefix_matcher:
            return new_match
        old_prefix = old_prefix_matcher.group(0)
        old_match_matcher = self._GIVEN_WHEN_THEN_MATCHER.match(old_match)
        if old_match_matcher and old_match_matcher.group(0) == old_prefix:
            return new_match
        return old_prefix+new_match

    @property
    def datafile(self):
        return self.parent.datafile

    @property
    def keyword(self):
        return self._step.keyword

    @property
    def assign(self):
        return self._step.assign

    @property
    def args(self):
        return self._step.args

    @property
    def vars(self):
        return self._step.vars

    def change(self, col, new_value):
        cells = self.as_list()
        if col >= len(cells) :
            cells = cells + ['' for _ in range(col - len(cells) + 1)]
        cells[col] = new_value
        comment = self._get_comment(cells)
        if comment:
            cells.pop()
        self._recreate(cells, comment)

    def comment(self):
        self.shift_right(0)
        self.change(0, 'Comment')

    def _is_commented(self, col):
        if self._has_comment_keyword():
            return col > self._keyword_column
        for i in range(min(col+1, len(self.as_list()))):
            if self.get_value(i).strip().startswith('#'):
                return True
        return False

    @property
    def _keyword_column(self):
        return 0

    def _has_comment_keyword(self):
        if self.keyword is None:
            return False
        return self.keyword.strip().lower() == "comment"

    def uncomment(self):
        if self._step.keyword == 'Comment':
            self.shift_left(0)

    def shift_right(self, from_column):
        cells = self.as_list()
        comment = self._get_comment(cells)
        if len(cells) > from_column:
            if comment:
                cells.pop()
            cells = cells[:from_column] + [''] + cells[from_column:]
            self._recreate(cells, comment)

    def shift_left(self, from_column):
        cells = self.as_list()
        comment = self._get_comment(cells)
        if len(cells) > from_column:
            if comment:
                cells.pop()
            cells = cells[:from_column] + cells[from_column+1:]
            self._recreate(cells, comment)

    def insert_before(self, new_step):
        steps = self.parent.get_raw_steps()
        index = steps.index(self._step)
        self.parent.set_raw_steps(steps[:index]+[new_step]+steps[index:])

    def insert_after(self, new_step):
        steps = self.parent.get_raw_steps()
        index = steps.index(self._step)+1
        self.parent.set_raw_steps(steps[:index]+[new_step]+steps[index:])

    def remove_empty_columns_from_end(self):
        cells = self.as_list()
        while cells != [] and cells[-1].strip() == '':
            cells.pop()
        self._recreate(cells)

    def remove_empty_columns_from_beginning(self):
        cells = self._step.as_list()
        while cells != [] and cells[0].strip() == '':
            cells = cells[1:]
        self._recreate(cells)

    def remove(self):
        self.parent.data.steps.remove(self._step)
        self.parent._clear_cached_steps()

    def move_up(self):
        previous_step = self.parent.step(self._index()-1)
        self.remove()
        previous_step.insert_before(self._step)

    def move_down(self):
        next_step = self.parent.step(self._index()+1)
        self.remove()
        next_step.insert_after(self._step)

    def _index(self):
        return self.parent.index_of_step(self._step)

    def has_only_comment(self):
        non_empty_cells = [cell for cell in self._step.as_list() if cell.strip() != '']
        return len(non_empty_cells) == 1 and non_empty_cells[0].startswith('# ')

    def _get_comment(self, cells):
        if not cells:
            return None
        return cells[-1][2:].strip() if cells[-1].startswith('# ') else None

    def _recreate(self, cells, comment=None):
        if self._is_partial_for_loop_step(cells):
            self._recreate_as_partial_for_loop(cells, comment)
        elif self._is_intended_step(cells):
            i = self._index()
            previous_step = self.parent.step(i-1)
            if type(previous_step) == ForLoopStepController:
                self._recreate_as_intended_step(previous_step, cells, comment, i)
            elif type(previous_step) == IntendedStepController:
                self._recreate_as_intended_step(previous_step.parent, cells, comment, i)
            else:
                self._step.__init__(cells, comment)
        else:
            self._step.__init__(cells, comment)

    def _is_partial_for_loop_step(self, cells):
        return cells and cells[0].replace(' ', '').upper() == ':FOR'

    def _is_intended_step(self, cells):
        return cells and not cells[0].strip() and \
               any(c.strip() for c in cells) and self._index() > 0

    def _recreate_as_partial_for_loop(self, cells, comment):
        index = self._index()
        self.parent.replace_step(index, PartialForLoop(cells[1:], first_cell=cells[0], comment=comment))
        self._recreate_next_step(index)

    def _recreate_as_intended_step(self, for_loop_step, cells, comment, index):
        self.remove()
        for_loop_step.add_step(Step(cells[1:], comment))
        self._recreate_next_step(index)

    def _recreate_next_step(self, index):
        if len(self.parent.steps) > index+1:
                next_step = self.parent.step(index+1)
                next_step._recreate(next_step.as_list())

    def notify_value_changed(self):
        self.parent.notify_steps_changed()


class PartialForLoop(ForLoop):

    def __init__(self, cells, first_cell=':FOR', comment=None):
        self._cells = cells
        self._first_cell = first_cell
        ForLoop.__init__(self, cells, comment)

    def as_list(self, indent=False, include_comment=False):
        return [self._first_cell]+self._cells+self.comment.as_list()


class ForLoopStepController(StepController):

    def __init__(self, parent, step):
        self._init(parent, step)

    @property
    def name(self):
        return self.parent.name

    @property
    def assignments(self):
        return self._step.vars

    def move_up(self):
        previous_step = self.parent.step(self._index()-1)
        if isinstance(previous_step, ForLoopStepController):
            self._swap_forloop_headers(previous_step)
        else:
            self.get_raw_steps().insert(0, previous_step._step)
            previous_step.remove()

    def _swap_forloop_headers(self, previous_step):
        previous_step._step.steps = self._step.steps
        self._step.steps = []
        steps = self.parent.get_raw_steps()
        i = steps.index(self._step)
        steps[i - 1] = self._step
        steps[i] = previous_step._step
        self.parent.set_raw_steps(steps)

    def move_down(self):
        next_step = self.step(self._index()+1)
        next_step.move_up()
        if len(self._step.steps) == 0:
            self._recreate_complete_for_loop_header(cells=self.as_list())

    def insert_after(self, new_step):
        self.get_raw_steps().insert(0, new_step)

    def step(self, index):
        return self.parent.step(index)

    def _has_comment_keyword(self):
        return False

    def get_raw_steps(self):
        return self._step.steps

    def set_raw_steps(self, steps):
        self._step.steps = steps

    def _get_cell_position(self, col):
        until_range = len(self._step.vars)+1
        if col == 0:
            return CellPosition(CellType.MANDATORY, None)
        if col < until_range:
            return CellPosition(CellType.ASSIGN, None)
        if col == until_range:
            return CellPosition(CellType.MANDATORY, None)
        if not self._step.range:
            return CellPosition(CellType.OPTIONAL, None)
        if col <= until_range+1:
            return CellPosition(CellType.MANDATORY, None)
        if col <= until_range+3:
            return CellPosition(CellType.OPTIONAL, None)
        return CellPosition(CellType.MUST_BE_EMPTY, None)

    def _build_cell_info(self, content, position):
        return CellInfo(content, position, for_loop=True)

    @property
    def steps(self):
        return [IntendedStepController(self, sub_step) for sub_step in self.get_raw_steps()]

    def index_of_step(self, step):
        index_in_for_loop = self.get_raw_steps().index(step)
        return self._index()+index_in_for_loop+1

    def _get_comment(self, cells):
        return None

    def comment(self):
        self._replace_with_new_cells(['Comment']+self.as_list())

    def uncomment(self):
        pass

    def contains_keyword(self, name):
        return False

    def add_step(self, step):
        self.get_raw_steps().append(step)

    def _recreate(self, cells, comment=None):
        if not self._represent_valid_for_loop_header(cells):
            self._recreate_partial_for_loop_header(cells, comment)
        else:
            self._recreate_complete_for_loop_header(cells)

    def _recreate_complete_for_loop_header(self, cells):
        steps = self.get_raw_steps()
        self._step.__init__(cells[1:])
        self.set_raw_steps(steps)

    def _recreate_partial_for_loop_header(self, cells, comment):
        if not cells or cells[0].replace(' ', '').upper() != ':FOR':
            self._replace_with_new_cells(cells)
        else:
            steps = self.get_raw_steps()
            i = self._index()
            StepController._recreate_as_partial_for_loop(self, cells, comment)
            self.parent.step(i).set_raw_steps(steps)

    def remove(self):
        steps = self.parent.data.steps
        index = steps.index(self._step)
        steps.remove(self._step)
        self.parent.data.steps = steps[:index] + self.get_raw_steps() + steps[index:]
        self._step.steps = []

    def _represent_valid_for_loop_header(self, cells):
        if not cells:
            return False
        if cells[0] != self.as_list()[0]:
            return False
        in_token_index = len(self.vars)+1
        if len(cells) <= in_token_index:
            return False
        if len(self.as_list()) <= in_token_index:
            return False
        if cells[in_token_index] != self.as_list()[in_token_index]:
            return False
        return True

    def _replace_with_new_cells(self, cells):
        index = self.parent.index_of_step(self._step)
        self.parent.replace_step(index, Step(cells))
        self.get_raw_steps().reverse()
        for substep in self.steps:
            self.parent.add_step(index+1, Step(substep.as_list()))

    def notify_steps_changed(self):
        self.notify_value_changed()

    def has_template(self):
        return self.parent.has_template()


class IntendedStepController(StepController):

    _invalid = False

    @property
    def _keyword_column(self):
        return 1

    def as_list(self):
        return ['']+self._step.as_list()

    def _get_cell_position(self, col):
        if col == 0:
            return CellPosition(CellType.MUST_BE_EMPTY, None)
        return StepController._get_cell_position(self, col-1)

    def _get_local_namespace(self):
        p = self.parent.parent
        index = p.index_of_step(self._step)
        return LocalNamespace(p, self.datafile_controller._namespace, index)

    def _get_content_with_type(self, col, position):
        if col == 0:
            return CellContent(ContentType.EMPTY, None)
        return StepController._get_content_with_type(self, col, position)

    def comment(self):
        self._step.__init__(['Comment'] + self._step.as_list())

    def uncomment(self):
        if self._step.keyword == 'Comment':
            self._step.__init__(self._step.as_list()[1:])

    def _recreate(self, cells, comment=None):
        if cells == [] or cells[0] == '':
            self._step.__init__(cells[1:], comment=comment)
            if self._step not in self.parent.get_raw_steps():
                self.parent.add_step(self._step)
        else:
            self._recreate_as_normal_step(cells, comment)
            self._invalid = True

    def _recreate_as_normal_step(self, cells, comment=None):
        steps = self.parent.steps
        index = [s._step for s in steps].index(self._step)
        for i, step in reversed(list(enumerate(steps))):
            if i == index:
                break
            step._replace_with_normal_step(i)
        self._replace_with_normal_step(index, cells, comment)

    def _replace_with_normal_step(self, index, cells=None, comment=None):
        index_of_parent = self.parent.parent.index_of_step(self.parent._step)
        self.parent.parent.add_step(index_of_parent+index+2, Step(cells or self.as_list(), comment=comment))
        self.parent.get_raw_steps().pop(index)

    def remove(self):
        self.parent.get_raw_steps().remove(self._step)

    @overrides(StepController)
    def remove_empty_columns_from_end(self):
        if self._invalid:
            return
        StepController.remove_empty_columns_from_end(self)

########NEW FILE########
__FILENAME__ = tablecontrollers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.publish import (RideTestCaseRemoved, RideVariableAdded,
        RideVariableRemoved, RideVariableMovedUp, RideVariableMovedDown,
        RideImportSettingAdded, RideUserKeywordRemoved, RideUserKeywordAdded,
        RideTestCaseAdded)
from robotide.publish.messages import RideItemMovedUp, RideItemMovedDown
from robotide.robotapi import is_list_var, is_scalar_var
from robotide import utils

from .basecontroller import ControllerWithParent
from .macrocontrollers import TestCaseController, UserKeywordController
from robotide.utils import overrides
from .settingcontrollers import (MetadataController, ImportController,
        VariableController)


class _WithListOperations(object):

    def move_up(self, index):
        if index > 0:
            self._swap(index - 1, index)

    def move_down(self, index):
        if index < len(self._items) - 1:
            self._swap(index, index + 1)

    def _swap(self, ind1, ind2):
        self._items[ind1], self._items[ind2] = self._items[ind2], self._items[ind1]
        self.mark_dirty()

    def delete(self, index):
        if isinstance(self._items, list):
            self._items.pop(index)
        else:
            self._items.data.pop(index)
        self.mark_dirty()

    @property
    def _items(self):
        raise NotImplementedError(self.__class__)

    def mark_dirty(self):
        raise NotImplementedError(self.__class__)


class _TableController(ControllerWithParent):

    def __init__(self, parent_controller, table):
        self._parent = parent_controller
        self._table = table


class VariableTableController(_TableController, _WithListOperations):

    def __init__(self, parent_controller, table):
        _TableController.__init__(self, parent_controller, table)
        self._variable_cache = {}

    def _get(self, variable):
        if variable not in self._variable_cache:
            self._variable_cache[variable] = VariableController(self, variable)
        return self._variable_cache[variable]

    def __iter__(self):
        return iter(self._get(v) for v in self._table)

    def __getitem__(self, index):
        return self._get(self._items[index])

    def index(self, ctrl):
        return [v for v in self].index(ctrl)

    @property
    def _items(self):
        return self._table.variables

    def move_up(self, index):
        ctrl = self[index]
        _WithListOperations.move_up(self, index)
        other = self[index]
        self.mark_dirty()
        RideVariableMovedUp(item=ctrl, other=other).publish()

    def move_down(self, index):
        ctrl = self[index]
        _WithListOperations.move_down(self, index)
        other = self[index]
        self.mark_dirty()
        RideVariableMovedDown(item=ctrl, other=other).publish()

    def add_variable(self, name, value, comment=None):
        self._table.add(name, value, comment)
        self.mark_dirty()
        var_controller = self[-1]
        self.notify_variable_added(var_controller)
        return var_controller

    def validate_scalar_variable_name(self, name, item=None):
        return self._validate_name(_ScalarVarValidator(), name, item)

    def validate_list_variable_name(self, name, item=None):
        return self._validate_name(_ListVarValidator(), name, item)

    def _validate_name(self, validator, name, item=None):
        return VariableNameValidation(self, validator, name, item)

    def delete(self, index):
        self.remove_var(self[index])

    def remove_var(self, var_controller):
        self._items.remove(var_controller.data)
        del self._variable_cache[var_controller.data]
        self.mark_dirty()
        self.notify_variable_removed(var_controller)

    def notify_variable_added(self, ctrl):
        self.datafile_controller.update_namespace()
        RideVariableAdded(datafile=self.datafile,
                          name=ctrl.name, item=ctrl,
                          index=ctrl.index).publish()

    def notify_variable_removed(self, ctrl):
        self.datafile_controller.update_namespace()
        RideVariableRemoved(datafile=self.datafile,
                            name=ctrl.name, item=ctrl).publish()

    def contains_variable(self, name):
        vars_as_list = []
        for var in self._items:
            vars_as_list += var.as_list()
        return any(utils.value_contains_variable(string, name) for string in vars_as_list)


class _ScalarVarValidator(object):
    __call__ = lambda self, name: is_scalar_var(name)
    name = 'Scalar'
    prefix = '$'


class _ListVarValidator(object):
    __call__ = lambda self, name: is_list_var(name)
    name = 'List'
    prefix = '@'


class _NameValidation(object):

    def __init__(self, table, name, named_ctrl=None):
        self._table = table
        self.error_message = ''
        self._named_ctrl = named_ctrl
        self._validate(name.strip())

    def _name_taken(self, name):
        return any(utils.eq(name, item.name, ignore=['_'])
                   for item in self._table if item != self._named_ctrl)


class VariableNameValidation(_NameValidation):

    def __init__(self, table, validator, name, named_ctrl=None):
        self._validator = validator
        _NameValidation.__init__(self, table, name, named_ctrl)

    def _validate(self, name):
        if not self._validator(name):
            self.error_message = '%s variable name must be in format %s{name}' % \
                    (self._validator.name, self._validator.prefix)
        if self._name_taken(name):
            self.error_message = 'Variable with this name already exists.'


class MacroNameValidation(_NameValidation):

    def _validate(self, name):
        if not name:
            self.error_message = '%s name cannot be empty.' % \
                    self._table.item_type
        if self._name_taken(name):
            self.error_message = '%s with this name already exists.' % \
                    self._table.item_type
        if "\n" in name:
            self.error_message = '%s name contains newlines' % \
                    self._table.item_type


class _MacroTable(_TableController):

    @property
    def _items(self):
        raise NotImplementedError(self.__class__)

    def __iter__(self):
        return iter(self._create_controller(item) for item in self._table)

    def _create_controller(self, item):
        if item not in self._item_to_controller:
            self._item_to_controller[item] = self._controller_class(self, item)
        return self._item_to_controller[item]

    @property
    def _item_to_controller(self):
        if not hasattr(self, '_item_to_controller_attribute'):
            self._item_to_controller_attribute = {}
        return self._item_to_controller_attribute

    def __len__(self):
        return len(self._items)

    def __getitem__(self, index):
        return self._create_controller(self._items[index])

    def move_up(self, item):
        items = self._items
        idx = items.index(item)
        if idx == 0:
            return False
        upper = idx - 1
        items[upper], items[idx] = items[idx], items[upper]
        self.mark_dirty()
        RideItemMovedUp(item=self._create_controller(item)).publish()
        return True

    def move_down(self, item):
        items = self._items
        idx = items.index(item)
        if idx + 1 == len(items):
            return False
        lower = idx + 1
        items[idx], items[lower] = items[lower], items[idx]
        self.mark_dirty()
        RideItemMovedDown(item=self._create_controller(item)).publish()
        return True

    def validate_name(self, name, named_ctrl=None):
        return MacroNameValidation(self, name, named_ctrl)

    def delete(self, ctrl):
        self._items.remove(ctrl.data)
        if ctrl.data in self._item_to_controller:
            del self._item_to_controller[ctrl.data]
        self.datafile_controller.update_namespace()
        self.mark_dirty()
        self._notify_removal(ctrl)

    def add(self, ctrl):
        item = ctrl.data
        item.parent = self._table
        self._items.append(item)
        new_controller = self._create_controller(item)
        self.datafile_controller.update_namespace()
        self.mark_dirty()
        self._notify_creation(new_controller.name, new_controller)

    def _create_new(self, name, config=None):
        name = name.strip()
        ctrl = self._create_controller(self._table.add(name))
        self._configure_controller(ctrl, config)
        self.datafile_controller.update_namespace()
        self.mark_dirty()
        self._notify_creation(name, ctrl)
        return ctrl

    def _configure_controller(self, ctrl, config):
        pass


class TestCaseTableController(_MacroTable):
    item_type = 'Test case'
    _controller_class = TestCaseController

    @property
    def _items(self):
        return self._table.tests

    def _notify_creation(self, name, ctrl):
        RideTestCaseAdded(datafile=self.datafile, name=name, item=ctrl).publish()

    def _notify_removal(self, item):
        RideTestCaseRemoved(datafile=self.datafile, name=item.name, item=item).publish()

    def new(self, name):
        return self._create_new(name)


class KeywordTableController(_MacroTable):
    item_type = 'User keyword'
    _controller_class = UserKeywordController

    @property
    def _items(self):
        return self._table.keywords

    def _notify_creation(self, name, ctrl):
        RideUserKeywordAdded(datafile=self.datafile, name=name, item=ctrl).publish()

    def _notify_removal(self, item):
        RideUserKeywordRemoved(datafile=self.datafile, name=item.name, item=item).publish()

    def new(self, name, argstr=''):
        return self._create_new(name, argstr)

    def _configure_controller(self, ctrl, config):
        if config:
            ctrl.arguments.set_value(config)

    def sort(self):
        """Sorts the keywords of the controller by name"""
        keywords_sorted = sorted(self._table.keywords, key=lambda userkeyword: userkeyword.name)
        index_difference = self._index_difference(self._table.keywords, keywords_sorted)
        self._table.keywords = keywords_sorted
        return index_difference

    def _index_difference(self, original_list, sorted_list):
        """Determines the difference in sorting order for undo/redo"""
        index_difference = []
        for kw in original_list:
            counter = 0
            for kw2 in sorted_list:
                if kw.name == kw2.name:
                    index_difference.append(counter)
                    break
                counter += 1
        return index_difference

    def restore_keyword_order(self, list):
        """Restores the old order of the keyword list"""
        keywords_temp = []
        for i in list:
            keywords_temp.append(self._table.keywords[i])
        self._table.keywords = keywords_temp


class ImportSettingsController(_TableController, _WithListOperations):

    def __init__(self, parent_controller, table, resource_file_controller_factory=None):
        _TableController.__init__(self, parent_controller, table)
        self._resource_file_controller_factory = resource_file_controller_factory
        self.__import_controllers = None

    def __iter__(self):
        return iter(self._import_controllers)

    def __getitem__(self, index):
        return self._import_controllers[index]

    @property
    def _import_controllers(self):
        if self.__import_controllers is None:
            self.__import_controllers = [self._import_controller(imp) for imp in self._items]
        return self.__import_controllers

    def _import_controller(self, import_):
        return ImportController(self, import_)

    @property
    def _items(self):
        return self._table.imports

    @property
    def resource_file_controller_factory(self):
        return self._resource_file_controller_factory

    @overrides(_WithListOperations)
    def _swap(self, ind1, ind2):
        imps = self._import_controllers
        imps[ind1], imps[ind2] = imps[ind2], imps[ind1]
        _WithListOperations._swap(self, ind1, ind2)

    def remove_import_data(self, imp):
        self.delete(self._items.data.index(imp))

    def delete(self, index):
        item = self[index]
        _WithListOperations.delete(self, index)
        self._import_controllers.pop(index)
        item.publish_removed()
        self.notify_imports_modified()

    def add_library(self, name, argstr, alias, comment=None):
        self._import_controllers # Call property since it has to exist before adding new
        import_ = self._table.add_library(name, utils.split_value(argstr),
                                          comment)
        import_.alias = alias
        self._parent.mark_dirty()
        self._add_controller(import_)
        self.notify_imports_modified()
        return self[-1]

    def _add_controller(self, import_):
        ctrl = self._import_controller(import_)
        ctrl.publish_added()
        self._import_controllers.append(ctrl)

    def add_resource(self, path, comment=None):
        self._import_controllers # Have to exist before adding new
        import_ = self._table.add_resource(path, comment)
        self._parent.mark_dirty()
        self.resource_import_modified(path)
        self._add_controller(import_)
        self.notify_imports_modified()
        return self[-1]

    def add_variables(self, path, argstr, comment=None):
        self._import_controllers # Have to exist before adding new
        import_ = self._table.add_variables(path, utils.split_value(argstr), comment)
        self._parent.mark_dirty()
        self._add_controller(import_)
        return self[-1]

    def notify_imports_modified(self):
        self.datafile_controller.update_namespace()

    def resource_import_modified(self, path):
        return self._parent.resource_import_modified(path)


class MetadataListController(_TableController, _WithListOperations):

    def __iter__(self):
        return iter(MetadataController(self, m) for m in self._items)

    def __getitem__(self, index):
        return MetadataController(self, self._items[index])

    @property
    def _items(self):
        return self._table.metadata

    def add_metadata(self, name, value, comment=None):
        self._table.add_metadata(name, value, comment)
        self._parent.mark_dirty()
        return self[-1]

########NEW FILE########
__FILENAME__ = tags
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.controller.basecontroller import _BaseController

class Tag(_BaseController):
    tooltip = "Test case's tag"

    def __init__(self, name, index=None, controller=None):
        self.name = name
        self.controller = controller
        self._index = index

    def set_index(self, index):
        self._index = index

    def is_empty(self):
        return self.name is None

    def __eq__(self, other):
        return self.name == other.name and self._index == other._index

    def __ne__(self, other):
        return not (self == other)

    def __str__(self):
        return self.name

    def choose(self, mapping):
        return mapping[self.__class__]

    def delete(self):
        self.controller._tags.remove(unicode(self.name))
        if type(self) is Tag and len(self.controller._tags) == 0:
            if len(self.controller.parent.default_tags.value) > 0:
                self.controller.set_value("")
            else:
                self.controller.clear()


class ForcedTag(Tag):

    @property
    def tooltip(self):
        return 'Force tag from suite '+self.controller.datafile_controller.name

class DefaultTag(Tag):

    @property
    def tooltip(self):
        return 'Default tag from suite '+self.controller.datafile_controller.name

########NEW FILE########
__FILENAME__ = testexecutionresults
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.publish.messages import RideTestExecutionStarted, RideTestPassed, RideTestFailed, RideTestRunning

class TestExecutionResults(object):
    RUNNING = 'Running'
    PASSED = 'Passed'
    FAILED = 'Failed'

    def __init__(self):
        self.clear()

    def test_execution_started(self):
        self.clear()
        RideTestExecutionStarted(results=self).publish()

    def clear(self):
        self._results = {}

    def set_running(self, test):
        self._results[test] = self.RUNNING
        RideTestRunning(item=test).publish()

    def set_passed(self, test):
        self._results[test] = self.PASSED
        RideTestPassed(item=test).publish()

    def set_failed(self, test):
        self._results[test] = self.FAILED
        RideTestFailed(item=test).publish()

    def is_running(self, test):
        return test in self._results and self._results[test] == self.RUNNING

    def has_passed(self, test):
        return test in self._results and self._results[test] == self.PASSED

    def has_failed(self, test):
        return test in self._results and self._results[test] == self.FAILED


########NEW FILE########
__FILENAME__ = treecontroller
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import wx
from robot import utils
from robotide.action.actioninfo import ActionInfoCollection, ActionInfo
from robotide.context.platform import IS_WINDOWS, ctrl_or_cmd, bind_keys_to_evt_menu
from robotide.controller.commands import ChangeTag
from robotide.controller.tags import Tag, DefaultTag
from robotide.publish import RideTestSelectedForRunningChanged, PUBLISHER, RideNewProject, RideOpenSuite
from robotide.widgets import Dialog

tree_actions ="""
[Navigate]
!Go &Back | Go back to previous location in tree | Alt-%s | ART_GO_BACK
!Go &Forward | Go forward to next location in tree | Alt-%s | ART_GO_FORWARD
""" % (('Left', 'Right') if IS_WINDOWS else ('Z', 'X'))
# Left and right cannot be overridden in tree on non Windows OSses, issue 354


class TreeController(object):

    def __init__(self, tree, action_registerer, settings, test_selection, history=None):
        self._tree = tree
        self._action_registerer = action_registerer
        self.settings = settings
        self._history = history or _History()
        self._test_selection = test_selection

    def register_tree_actions(self):
        actions = ActionInfoCollection(tree_actions, self, self._tree)
        self._action_registerer.register_actions(actions)
        self._action_registerer.register_action(ActionInfo(menu_name='Edit', name='Add Tag to selected', action=self.OnAddTagToSelected))
        self._action_registerer.register_action(ActionInfo(menu_name='Edit', name='Clear Selected', action=self.OnClearSelected))

    def OnGoBack(self, event):
        node = self._history.back()
        if node:
            self._tree.SelectItem(node)

    def OnAddTagToSelected(self, event):
        if self._test_selection.is_empty():
            return
        name = wx.GetTextFromUser(message='Enter Tag Name', caption='Add Tag To Selected')
        if name:
            self._test_selection.add_tag(name)

    def OnClearSelected(self, event):
        self._tree.DeselectAllTests(self._tree._root)

    def OnGoForward(self, event):
        node = self._history.forward()
        if node:
            self._tree.SelectItem(node)

    def add_to_history(self, node):
        self._history.change(node)

    def mark_controller_dirty(self, controller):
        if not controller.dirty:
            return
        node = self.find_node_by_controller(controller)
        if node:
            self.mark_node_dirty(node)

    def mark_node_dirty(self, node):
        text = self._tree.GetItemText(node)
        if not text.startswith('*'):
             self._tree.SetItemText(node, '*' + text)

    def find_node_by_controller(self, controller):
        def match_handler(n):
            handler = self.get_handler(n)
            return handler and controller is handler.controller
        return self._find_node_with_predicate(self._tree._root, match_handler)

    def find_node_with_label(self, node, label):
        matcher = lambda n: utils.eq(self._tree.GetItemText(n), label)
        return self._find_node_with_predicate(node, matcher)

    def _find_node_with_predicate(self, node, predicate):
        if node != self._tree._root and predicate(node):
            return node
        item, cookie = self._tree.GetFirstChild(node)
        while item:
            if predicate(item):
                return item
            if self._tree.ItemHasChildren(item):
                result = self._find_node_with_predicate(item, predicate)
                if result:
                    return result
            item, cookie = self._tree.GetNextChild(node, cookie)
        return None

    def get_handler(self, node=None):
        return self._tree.GetItemPyData(node or self._tree.GetSelection())

    def bind_keys(self):
        bind_keys_to_evt_menu(self._tree, self._get_bind_keys())

    def _get_bind_keys(self):
        bindings = [
            (ctrl_or_cmd(), wx.WXK_UP, self._tree.OnMoveUp),
            (ctrl_or_cmd(), wx.WXK_DOWN, self._tree.OnMoveDown),
            (wx.ACCEL_NORMAL, wx.WXK_F2, self._tree.label_editor.OnLabelEdit),
            (wx.ACCEL_NORMAL, wx.WXK_WINDOWS_MENU, self._tree.OnRightClick),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('d'), lambda event: self._expanded_handler().OnSafeDelete(event)),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('f'),
                lambda event: self._expanded_handler().OnNewSuite(event)),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('k'),
                lambda event: self._expanded_handler().OnNewUserKeyword(event)),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('t'),
                lambda event: self._expanded_handler().OnNewTestCase(event)),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('v'),
                lambda event: self._expanded_handler().OnNewScalar(event)),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('l'),
                lambda event: self._expanded_handler().OnNewListVariable(event)),
            (ctrl_or_cmd() | wx.ACCEL_SHIFT, ord('c'),
                lambda event: self._expanded_handler().OnCopy(event))
        ]
        if not IS_WINDOWS:
            bindings.append((wx.ACCEL_NORMAL, wx.WXK_LEFT, self._tree.OnLeftArrow))
        return bindings

    def _expanded_handler(self):
        handler = self.get_handler()
        if not self._tree.IsExpanded(handler.node):
            self._tree.Expand(handler.node)
        return handler


class _History(object):

    def __init__(self):
        self._back = []
        self._forward = []

    def change(self, state):
        if not self._back or state != self._back[-1]:
            self._back.append(state)
            self._forward = []

    def back(self):
        if not self._back:
            return None
        if len(self._back) > 1:
            self._forward.append(self._back.pop())
        return self._back[-1]

    def forward(self):
        if not self._forward:
            return None
        state = self._forward.pop()
        self._back.append(state)
        return state

    def top(self):
        return self._back and self._back[-1] or None


class TestSelectionController(object):

    def __init__(self):
        self._tests = {}

    def is_empty(self):
        return not bool(self._tests)

    def clear_all(self, message=None):
        self._tests = {}
        self.send_selection_changed_message()

    def unselect_all(self, tests):
        for test in tests:
            self.select(test, False)

    def select(self, test, selected=True):
        if selected:
            self._tests[test.longname] = test
        elif test.longname in self._tests:
            del self._tests[test.longname]
        self.send_selection_changed_message()

    def send_selection_changed_message(self):
        RideTestSelectedForRunningChanged(tests=set([(t.datafile_controller.longname, t.longname)
                                                     for t in self._tests.values()])).publish()

    def add_tag(self, name):
        for test in self._tests.values():
            self._add_tag_to_test(name, test)

    def _add_tag_to_test(self, name, test):
        if name not in [t.name for t in test.tags]:
            self._move_default_tags_to_test(test)
            self._add_tag(test, name)

    def _move_default_tags_to_test(self, test):
        for tag in test.tags:
            if isinstance(tag, DefaultTag):
                self._add_tag(test, tag.name)

    def _add_tag(self, test, name):
        test.tags.execute(ChangeTag(Tag(None), name))

########NEW FILE########
__FILENAME__ = validators
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robotide.publish.messages import RideInputValidationError

ERROR_ILLEGAL_CHARACTERS = "Filename contains illegal characters"
ERROR_EMPTY_FILENAME = "Empty filename"
ERROR_NEWLINES_IN_THE_FILENAME = "Newlines in the filename"
ERROR_FILE_ALREADY_EXISTS = "File %s already exists"

class BaseNameValidator(object):

    def __init__(self, new_basename):
        self._new_basename = new_basename

    def validate(self, context):
        # Try-except is needed to check if file can be created if named like this, using open()
        # http://code.google.com/p/robotframework-ride/issues/detail?id=1111
        try:
            name = '%s.%s' % (self._new_basename, context.get_format())
            filename = os.path.join(context.directory, name)
            if self._file_exists(filename):
                RideInputValidationError(message=ERROR_FILE_ALREADY_EXISTS % filename).publish()
                return False
            if '\\n' in self._new_basename or '\n' in self._new_basename:
                RideInputValidationError(message=ERROR_NEWLINES_IN_THE_FILENAME).publish()
                return False
            if len(self._new_basename.strip()) == 0:
                RideInputValidationError(message=ERROR_EMPTY_FILENAME).publish()
                return False
            try:
                open(name,"w").close()
            finally:
                os.remove(name)
            return True
        except (IOError, OSError):
            RideInputValidationError(message=ERROR_ILLEGAL_CHARACTERS).publish()
            return False

    def _file_exists(self, filename):
        return os.path.exists(filename)

########NEW FILE########
__FILENAME__ = clipboard
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import wx
from robotide.context import IS_WINDOWS


class _ClipboardHandler(object):

    def __init__(self, grid):
        self._grid = grid
        self._clipboard = _GridClipboard()

    def clipboard_content(self):
        return self._clipboard.get_contents()

    def copy(self):
        """Copy the contents of the selected cell(s). This does a normal copy
        action if the user is editing a cell, otherwise it places the selected
        range of cells on the data.
        """
        if not self._edit_control_shown():
            self._add_selected_data_to_clipboard()

    def cut(self):
        """Cuts the contents of the selected cell(s). This does a normal cut
        action if the user is editing a cell, otherwise it places the selected
        range of cells on the clipboard.
        """
        self._add_selected_data_to_clipboard()

    def _add_selected_data_to_clipboard(self):
        self._clipboard.set_contents(self._grid.get_selected_content())

    def paste(self):
        """Paste the contents of the clipboard. If a cell is being edited just
        do a normal paste. If a cell is not being edited, paste whole rows.
        """
        if not self._edit_control_shown():
            self._paste_to_grid()

    def _paste_to_cell_editor(self):
        clipboard = self._clipboard.get_contents()
        if isinstance(clipboard, list):
            cells_as_text = ' '.join([' '.join(row) for row in clipboard])
            self._get_edit_control().WriteText(cells_as_text)

    def _paste_to_grid(self):
        clipboard = self._clipboard.get_contents()
        if not clipboard:
            return
        cell = self._get_starting_cell()
        if not isinstance(clipboard, list):
            self._write_cell(cell.row, cell.col, clipboard)
        else:
            row = cell.row
            for datarow in clipboard:
                col = cell.col
                for value in datarow:
                    self._write_cell(row, col, value)
                    col += 1
                row += 1

    def _get_starting_cell(self):
        return self._grid.selection.topleft

    def _write_cell(self, row, col, value):
        self._grid.write_cell(row, col, value, update_history=False)

    def _get_edit_control(self):
        return self._grid.get_cell_edit_control()

    def _edit_control_shown(self):
        return self._grid.IsCellEditControlShown()


class _WindowsClipboardHandler(_ClipboardHandler):

    def copy(self):
        if self._edit_control_shown():
            self._get_edit_control().Copy()
        else:
            _ClipboardHandler.copy(self)

    def cut(self):
        if self._edit_control_shown():
            self._get_edit_control().Cut()
        else:
            _ClipboardHandler.copy(self)

    def _paste_to_cell_editor(self):
        self._get_edit_control().Paste()


ClipboardHandler = IS_WINDOWS and _WindowsClipboardHandler\
                                    or _ClipboardHandler


class _GridClipboard(object):
    """Implements a "smart" clipboard."""

    def set_contents(self, data):
        """Insert `data` to the system clipboard

        `data` may be either a string or list of lists representing rows of
        grid data. Other data is ignored
        """
        data = self._format_data(data)
        if not (data and wx.TheClipboard.Open()):
            return
        try:
            tdo = wx.TextDataObject()
            tdo.SetText(data)
            wx.TheClipboard.SetData(tdo)
        finally:
            wx.TheClipboard.Close()

    def _format_data(self, data):
        if isinstance(data, list):
            return os.linesep.join('\t'.join(row) for row in data)
        if isinstance(data, basestring):
            return data
        return None

    def get_contents(self):
        """Gets contents of the clipboard.

        Returns either a string or a list of rows to be pasted into clipboard.
        """
        return self._split_string_from_tabs_and_newlines(self._get_contents())

    def _get_contents(self):
        if not wx.TheClipboard.Open():
            return ''
        try:
            tdo = wx.TextDataObject()
            wx.TheClipboard.GetData(tdo)
            return tdo.GetText() or ''
        finally:
            wx.TheClipboard.Close()

    def _split_string_from_tabs_and_newlines(self, string):
        return [line.split('\t') for line in string.splitlines()]

########NEW FILE########
__FILENAME__ = contentassist
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os

import wx
from wx.lib.expando import ExpandoTextCtrl
from wx.lib.filebrowsebutton import FileBrowseButton
from robot.utils.normalizing import normalize
from os.path import relpath, dirname, isdir
from robotide.spec.iteminfo import VariableInfo

from robotide import context
from robotide.namespace.suggesters import SuggestionSource

from .popupwindow import RidePopupWindow, HtmlPopupWindow
import robotide.utils as utils
from robotide.context import IS_WINDOWS


_PREFERRED_POPUP_SIZE = (400, 200)


class _ContentAssistTextCtrlBase(object):

    def __init__(self, suggestion_source):
        self._popup = ContentAssistPopup(self, suggestion_source)
        self.Bind(wx.EVT_KEY_DOWN, self.OnChar)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnFocusLost)
        self.Bind(wx.EVT_MOVE, self.OnFocusLost)
        self._showing_content_assist = False
        self._row = None

    def set_row(self, row):
        self._row = row

    def OnChar(self, event):
        # TODO: This might benefit from some cleanup
        keycode = event.GetKeyCode()
        # Ctrl-Space handling needed for dialogs
        if keycode == wx.WXK_SPACE and event.ControlDown():
            self.show_content_assist()
            return
        if keycode in [wx.WXK_UP, wx.WXK_DOWN, wx.WXK_PAGEUP, wx.WXK_PAGEDOWN] \
                and self._popup.is_shown():
            self._popup.select_and_scroll(keycode)
            return
        elif keycode == wx.WXK_RETURN and self._popup.is_shown():
            self.OnFocusLost(event)
            return
        elif keycode == wx.WXK_TAB:
            self.OnFocusLost(event, False)
        elif keycode == wx.WXK_ESCAPE and self._popup.is_shown():
            self._popup.hide()
            return
        elif self._popup.is_shown() and keycode < 256:
            self._populate_content_assist(event)
        elif keycode in (ord('1'), ord('2')) and event.ControlDown() and not event.AltDown():
            self.execute_variable_creator(list_variable=(keycode==ord('2')))
        event.Skip()

    def execute_variable_creator(self, list_variable=False):
        from_, to_ = self.GetSelection()
        symbol = '@' if list_variable else '$'
        self.SetValue(self._variable_creator_value(self.Value, symbol, from_, to_))
        if from_ == to_:
            self.SetInsertionPoint(from_ + 2)
        else:
            self.SetSelection(from_ + 2, to_ + 2)

    def _variable_creator_value(self, value, symbol, from_, to_):
        return value[:from_]+symbol+'{'+value[from_:to_]+'}'+value[to_:]

    def OnFocusLost(self, event, set_value=True):
        if not self._popup.is_shown():
            return
        value = self._popup.get_value()
        if set_value and value:
            self.SetValue(value)
            self.SetInsertionPoint(len(self.Value))
        else:
            self.Clear()
        self.hide()

    def reset(self):
        self._popup.reset()
        self._showing_content_assist = False

    def show_content_assist(self):
        if self._showing_content_assist:
            return
        self._showing_content_assist = True
        if self._populate_content_assist():
            self._show_content_assist()

    def _populate_content_assist(self, event=None):
        value = self.GetValue()
        if event is not None:
            if event.GetKeyCode() == wx.WXK_BACK:
                value = value[:-1]
            elif event.GetKeyCode() == wx.WXK_DELETE:
                pos = self.GetInsertionPoint()
                value = value[:pos] + value[pos + 1:]
            elif event.GetKeyCode() == wx.WXK_ESCAPE:
                self.hide()
                return False
            else:
                value += unichr(event.GetRawKeyCode())
        return self._popup.content_assist_for(value, row=self._row)

    def _show_content_assist(self):
        height = self.GetSizeTuple()[1]
        x, y = self.ClientToScreenXY(0, 0)
        self._popup.show(x, y, height)

    def content_assist_value(self):
        return self._popup.content_assist_value(self.Value)

    def hide(self):
        self._popup.hide()
        self._showing_content_assist = False


class ExpandingContentAssistTextCtrl(_ContentAssistTextCtrlBase, ExpandoTextCtrl):

    def __init__(self, parent, plugin, controller):
        ExpandoTextCtrl.__init__(self, parent, size=wx.DefaultSize, style=wx.WANTS_CHARS)
        _ContentAssistTextCtrlBase.__init__(self, SuggestionSource(plugin, controller))


class ContentAssistTextCtrl(_ContentAssistTextCtrlBase, wx.TextCtrl):

    def __init__(self, parent, suggestion_source, size=wx.DefaultSize):
        wx.TextCtrl.__init__(self, parent, size=size, style=wx.WANTS_CHARS)
        _ContentAssistTextCtrlBase.__init__(self, suggestion_source)


class ContentAssistFileButton(_ContentAssistTextCtrlBase, FileBrowseButton):

    def __init__(self, parent, suggestion_source, label, controller, size=wx.DefaultSize):
        FileBrowseButton.__init__(self, parent, labelText=label,
            size=size, fileMask="*",
            changeCallback=self.OnFileChanged)
        self._parent = parent
        self._controller = controller
        self._browsed = False
        _ContentAssistTextCtrlBase.__init__(self, suggestion_source)

    def Bind(self, *args):
        self.textControl.Bind(*args)

    def SetInsertionPoint(self, pos):
        self.textControl.SetInsertionPoint(pos)

    @property
    def Value(self):
        return self.textControl.Value

    def AppendText(self, *args):
        return self.textControl.AppendText(*args)

    def OnBrowse(self, evt):
        self._browsed = True
        FileBrowseButton.OnBrowse(self, evt)
        self._browsed = False

    def OnFileChanged(self, evt):
        if self._browsed:
            self._browsed = False
            self.SetValue(self._relative_path(self.GetValue()))
            self._parent.setFocusToOK()

    def SelectAll(self):
        self.textControl.SelectAll()

    def _relative_path(self, value):
        src = self._controller.datafile.source
        if utils.is_same_drive(src, value):
            path =  relpath(value, src if isdir(src) else dirname(src))
        else:
            path = value
        return path.replace('\\', '/') if IS_WINDOWS else path.replace('\\', '\\\\')


class Suggestions(object):

    def __init__(self, suggestion_source):
        self._suggestion_source = suggestion_source
        self._previous_value = None
        self._previous_choices = []

    def get_for(self, value, row=None):
        self._previous_choices = self._get_choices(value, row)
        self._previous_value = value
        return [k for k,_ in self._previous_choices]

    def get_item(self, name):
        for k, v in self._previous_choices:
            if k == name:
                return v
        raise Exception('Item not in choices "%s"' % (name))

    def _get_choices(self, value, row):
        if self._previous_value and value.startswith(self._previous_value):
            return [(key, val) for key, val in self._previous_choices
                                    if normalize(key).startswith(normalize(value))]
        choices = self._suggestion_source.get_suggestions(value, row)
        duplicate_names = self._get_duplicate_names(choices)
        return self._format_choices(choices, value, duplicate_names)

    def _get_duplicate_names(self, choices):
        results = set()
        normalized_names = [normalize(ch.name) for ch in choices]
        for choice in choices:
            normalized = normalize(choice.name)
            if normalized_names.count(normalized) > 1:
                results.add(normalized)
        return results

    def _format_choices(self, choices, prefix, duplicate_names):
        return [(self._format(val, prefix, duplicate_names), val) for val in choices]

    def _format(self, choice, prefix, duplicate_names):
        return choice.name if self._matches_unique_shortname(choice, prefix, duplicate_names) else choice.longname

    def _matches_unique_shortname(self, choice, prefix, duplicate_names):
        if isinstance(choice, VariableInfo):
            return True
        if not normalize(choice.name).startswith(normalize(prefix)):
            return False
        if normalize(choice.name) in duplicate_names:
            return False
        return True


class ContentAssistPopup(object):

    def __init__(self, parent, suggestion_source):
        self._parent = parent
        self._main_popup = RidePopupWindow(parent, _PREFERRED_POPUP_SIZE)
        self._details_popup = HtmlPopupWindow(parent, _PREFERRED_POPUP_SIZE)
        self._selection = -1
        self._list = ContentAssistList(self._main_popup, self.OnListItemSelected,
                                       self.OnListItemActivated)
        self._suggestions = Suggestions(suggestion_source)

    def reset(self):
        self._selection = -1

    def get_value(self):
        return self._selection != -1 and self._list.get_text(self._selection) or None

    def content_assist_for(self, value, row=None):
        self._choices = self._suggestions.get_for(value, row=row)
        if not self._choices:
            self._list.ClearAll()
            self._parent.hide()
            return False
        self._list.populate(self._choices)
        return True

    def _starts(self, val1, val2):
        return val1.lower().startswith(val2.lower())

    def content_assist_value(self, value):
        if self._selection > -1:
            return self._list.GetItem(self._selection).GetText()
        return None

    def show(self, xcoord, ycoord, cell_height):
        self._main_popup.SetPosition((xcoord, self._move_y_where_room(ycoord, cell_height)))
        self._details_popup.SetPosition((self._move_x_where_room(xcoord),
                                         self._move_y_where_room(ycoord, cell_height)))
        self._main_popup.Show()
        self._list.SetFocus()

    def _move_x_where_room(self, start_x):
        width = _PREFERRED_POPUP_SIZE[0]
        max_horizontal = wx.GetDisplaySize()[0]
        free_right = max_horizontal - start_x - width
        free_left = start_x - width
        if max_horizontal - start_x < 2 * width:
            if free_left > free_right:
                return start_x - width
        return start_x + width

    def _move_y_where_room(self, start_y, cell_height):
        height = _PREFERRED_POPUP_SIZE[1]
        max_vertical = wx.GetDisplaySize()[1]
        if max_vertical - start_y - cell_height < height:
            return start_y - height
        return start_y + cell_height

    def is_shown(self):
        return self._main_popup.IsShown()

    def select_and_scroll(self, keycode):
        sel = self._list.GetFirstSelected()
        if keycode == wx.WXK_DOWN :
            if sel < (self._list.GetItemCount() - 1):
                self._select_and_scroll(sel + 1)
            else:
                self._select_and_scroll(0)
        elif keycode == wx.WXK_UP:
            if sel > 0 :
                self._select_and_scroll(sel - 1)
            else:
                self._select_and_scroll(self._list.GetItemCount() - 1)
        elif keycode == wx.WXK_PAGEDOWN:
            if self._list.ItemCount - self._selection > 14:
                self._select_and_scroll(self._selection + 14)
            else:
                self._select_and_scroll(self._list.ItemCount - 1)
        elif keycode == wx.WXK_PAGEUP:
            if self._selection > 14:
                self._select_and_scroll(self._selection - 14)
            else:
                self._select_and_scroll(0)

    def _select_and_scroll(self, selection):
        self._selection = selection
        self._list.Select(self._selection)
        self._list.EnsureVisible(self._selection)

    def hide(self):
        self._selection = -1
        self._main_popup.Show(False)
        self._details_popup.Show(False)

    def OnListItemActivated(self, event):
        self._parent.OnFocusLost(event)

    def OnListItemSelected(self, event):
        self._selection = event.GetIndex()
        item = self._suggestions.get_item(event.GetText())
        if item.details:
            self._details_popup.Show()
            self._details_popup.set_content(item.details, item.name)
        elif self._details_popup.IsShown():
            self._details_popup.Show(False)


class ContentAssistList(wx.ListCtrl):

    def __init__(self, parent, selection_callback, activation_callback=None):
        style = wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_NO_HEADER
        wx.ListCtrl.__init__(self, parent, style=style)
        self._selection_callback = selection_callback
        self._activation_callback = activation_callback
        self.SetSize(parent.GetSize())
        self.SetBackgroundColour(context.POPUP_BACKGROUND)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, selection_callback)
        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, activation_callback)

    def populate(self, data):
        self.ClearAll()
        self.InsertColumn(0, '', width=self.Size[0])
        for row, item in enumerate(data):
            self.InsertStringItem(row, item)
        self.Select(0)

    def get_text(self, index):
        return self.GetItem(index).GetText()

########NEW FILE########
__FILENAME__ = dialoghelps
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

def get_help(title):
    return '\n'.join(_HELPS[title])


_HELPS = {}
_EXAMPLES = {
'ESCAPE': "Possible pipes in the value must be escaped with a backslash like '\|'.",
'TAG': "Separate tags with a pipe character like 'tag | second tag | 3rd'.",
'FIXTURE': "Separate possible arguments with a pipe character like 'My Keyword | arg 1 | arg 2'.",
'TIMEOUT': ("Use time syntax like '1min 10s' or '2 hours' or give the value as seconds.\n"
            "Optional message can be specified like '3 minutes | My message here'."),
'ARGUMENTS': ("Specify the arguments separated with a pipe character like '${arg1} | ${arg2}'.\n"
              "Default values are given using equal sign and the last argument can be a list variable.\n"
              "Example: '${arg1} | ${arg2}=default value | @{rest}'.\n"
              "Note. You can use variable shortcuts in this field.")
}

for row in """
Scalar Variable
Give name and value of the variable.

List Variable
Give name and value of the variable. Input list variable items into separate cells.

Library
Give name, optional arguments and optional alias of the library to import.
Separate multiple arguments with a pipe character like 'arg 1 | arg 2'.
Alias can be used to import same library multiple times with different names.

Variables
Give path and optional arguments of the variable file to import.
Separate multiple arguments with a pipe character like 'arg 1 | arg 2'.
%(ESCAPE)s

Resource
Give path to the resource file to import.
Existing resources will be automatically loaded to the resource tree.
New resources must be created separately.

Documentation
Give the documentation.
Simple formatting like *bold* and _italic_ can be used.
Additionally, URLs are converted to clickable links.

Force Tags
These tags are set to all test cases in this test suite.
Inherited tags are not shown in this view.
%(TAG)s
%(ESCAPE)s

Default Tags
These tags are set to all test cases in this test suite unless test cases have their own tags.
%(TAG)s
%(ESCAPE)s

Tags
These tags are set to this test case in addition to Force Tags and they override possible Default Tags.
Inherited tags are not shown in this view.
%(TAG)s
%(ESCAPE)s

Suite Setup
This keyword is executed before executing any of the test cases or lower level suites.
%(FIXTURE)s
%(ESCAPE)s

Suite Teardown
This keyword is executed after all test cases and lower level suites have been executed.
%(FIXTURE)s
%(ESCAPE)s

Test Setup
This keyword is executed before every test case in this suite unless test cases override it.
%(FIXTURE)s
%(ESCAPE)s

Test Teardown
This keyword is executed after every test case in this suite unless test cases override it.
%(FIXTURE)s
%(ESCAPE)s

Setup
This keyword is executed before other keywords in this test case.
Overrides possible Test Setup set on the suite level.
%(FIXTURE)s
%(ESCAPE)s

Teardown
This keyword is executed after other keywords in this test case even if the test fails.
Overrides possible Test Teardown set on the suite level.
%(FIXTURE)s
%(ESCAPE)s

Test Template
Specifies the default template keyword used by tests in this suite.
The test cases will contain only data to use as arguments to that keyword.

Template
Specifies the template keyword to use.
The test itself will contain only data to use as arguments to that keyword.

Arguments
%(ARGUMENTS)s
%(ESCAPE)s

Return Value
Specify the return value. Use a pipe character to separate multiple values.
%(ESCAPE)s

Test Timeout
Maximum time test cases in this suite are allowed to execute before aborting them forcefully.
Can be overridden by individual test cases using Timeout setting.
%(TIMEOUT)s

Timeout
Maximum time this test/keyword is allowed to execute before aborting it forcefully.
With test cases this setting overrides Test Timeout set on the suite level.
%(TIMEOUT)s

Metadata
Give a name and a value for the suite metadata.

New Test Case
Give a name for the new test case.

New User Keyword
Give a name and arguments for the new user keyword.
%(ARGUMENTS)s

Copy User Keyword
Give a name for the new user keyword.
""".splitlines():
    row = row.strip()
    if not row:
        current = None
    elif current is None:
        current = _HELPS.setdefault(row, [])
    else:
        current.append(row % _EXAMPLES)

########NEW FILE########
__FILENAME__ = editorcreator
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


from robot.parsing.model import (TestCase, TestDataDirectory, ResourceFile,
        TestCaseFile, UserKeyword, Variable)

from robotide.controller.chiefcontroller import ChiefController
from robotide.controller.dataloader import TestDataDirectoryWithExcludes
from robotide.controller.filecontrollers import ExcludedDirectoryController
from robotide.controller.settingcontrollers import VariableController

from .editors import (InitFileEditor, TestCaseFileEditor, WelcomePage,
        ResourceFileEditor)
from .macroeditors import TestCaseEditor, UserKeywordEditor


def VariableEditorChooser(plugin, parent, controller, tree):
    controller = controller.datafile_controller
    editor_class = plugin.get_editor(controller.data.__class__)
    return editor_class(plugin, parent, controller, tree)


class EditorCreator(object):
    # TODO: Should not use robot.model classes here
    _EDITORS = ((TestDataDirectory, InitFileEditor),
                (ResourceFile, ResourceFileEditor),
                (TestCase, TestCaseEditor),
                (TestCaseFile, TestCaseFileEditor),
                (UserKeyword, UserKeywordEditor),
                (Variable, VariableEditorChooser),
                (TestDataDirectoryWithExcludes, InitFileEditor))

    def __init__(self, editor_registerer):
        self._editor_registerer = editor_registerer
        self._editor = None

    def register_editors(self):
        for item, editorclass in self._EDITORS:
            self._editor_registerer(item, editorclass)

    def editor_for(self, plugin, editor_panel, tree):
        self._editor = self._create_editor(editor_panel, plugin, tree)
        return self._editor

    def _create_editor(self, editor_panel, plugin, tree):
        controller = plugin.get_selected_item()
        if self._invalid(controller):
            # see http://code.google.com/p/robotframework-ride/issues/detail?id=1092
            if self._editor and tree and (not tree._datafile_nodes or self._only_resource_files(tree)):
                self._editor.destroy()
                self._editor = None
                return None
            if self._editor:
                return self._editor
            return WelcomePage(editor_panel)
        if self._should_use_old_editor(controller):
            return self._editor
        return self._create_new_editor(controller, editor_panel, plugin, tree)

    def _invalid(self, controller):
        return not controller or not controller.data or \
               isinstance(controller, ChiefController) or isinstance(controller, ExcludedDirectoryController)

    def _should_use_old_editor(self, controller):
        return self._editor and \
               isinstance(controller, VariableController) and \
               controller.datafile_controller is self._editor.controller

    def _create_new_editor(self, controller, editor_panel, plugin, tree):
        editor_class = plugin.get_editor(controller.data.__class__)
        if self._editor:
            self._editor.destroy()
        editor_panel.Show(False)
        return editor_class(plugin, editor_panel, controller, tree)

    def _only_resource_files(self, tree):
        return all([tree.node_is_resource_file(node) for node in tree._datafile_nodes])

########NEW FILE########
__FILENAME__ = editordialogs
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from robotide.namespace.suggesters import ResourceSuggester, LibrariesSuggester, HistorySuggester

from robotide.validators import (ScalarVariableNameValidator,
    ListVariableNameValidator, TimeoutValidator, ArgumentsValidator,
    TestCaseNameValidator, UserKeywordNameValidator)
from robotide import utils
from robotide.widgets import HelpLabel, Dialog

from fieldeditors import ValueEditor, ListValueEditor, MultiLineEditor,\
    ContentAssistEditor, VariableNameEditor, ArgumentEditor, FileNameEditor
from formatters import ListToStringFormatter
from dialoghelps import get_help


def EditorDialog(obj):
    return globals()[obj.label.replace(' ', '') + 'Dialog']


class _Dialog(Dialog):
    _title = property(lambda self: utils.name_from_class(self, drop='Dialog'))

    def __init__(self, controller, item=None, plugin=None):
        # TODO: Get rid of item, everything should be in controller
        Dialog.__init__(self, self._title)
        self.SetExtraStyle(wx.WS_EX_VALIDATE_RECURSIVELY)
        self._controller = controller
        self.plugin = plugin
        self._sizer = wx.BoxSizer(wx.VERTICAL)
        self._editors = self._get_editors(item)
        for editor in self._editors:
            self._sizer.Add(editor, editor.expand_factor, wx.EXPAND)
        self._add_comment_editor(item)
        self._create_help()
        self._create_line()
        self._create_buttons()
        self.SetSizer(self._sizer)
        self._sizer.Fit(self)
        self._editors[0].set_focus()

    def _add_comment_editor(self, item):
        comment = ListToStringFormatter(item.comment).value if item else ''
        self._comment_editor = ValueEditor(self, comment, 'Comment')
        self._sizer.Add(self._comment_editor)

    def _create_line(self):
        line = wx.StaticLine(self, size=(20,-1), style=wx.LI_HORIZONTAL)
        self._sizer.Add(line, 0, wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.TOP, 5)

    def _create_help(self):
        self._sizer.Add(HelpLabel(self, label=get_help(self._title)),
                        flag=wx.ALL, border=2)

    def _create_buttons(self):
        buttons = self.CreateStdDialogButtonSizer(wx.OK|wx.CANCEL)
        self._sizer.Add(buttons, 0, wx.ALIGN_CENTER|wx.ALL, 5)

    def get_value(self):
        return [ e.get_value() for e in self._editors ]

    def get_comment(self):
        return self._comment_editor.get_value()

    def setFocusToOK(self):
        self.FindWindowById(wx.ID_OK).SetFocus()


class ScalarVariableDialog(_Dialog):

    def _get_editors(self, var):
        name = var.name if var and var.name else '${}'
        value = var.value[0] if var else ''
        validator = ScalarVariableNameValidator(self._controller, name)
        return [VariableNameEditor(self, name, 'Name', validator),
                ValueEditor(self, value, 'Value')]

class ListVariableDialog(_Dialog):

    def _get_editors(self, var):
        name = var.name if var and var.name else '@{}'
        value = var.value if var and var.value else ''
        validator = ListVariableNameValidator(self._controller, name)
        return [VariableNameEditor(self, name, 'Name', validator),
                ListValueEditor(self, value, 'Value',
                                settings=self.plugin.global_settings)]


class LibraryDialog(_Dialog):

    _history_suggester = HistorySuggester()

    def _get_editors(self, item):
        name = item and item.name or ''
        args = item and utils.join_value(item.args) or ''
        alias = item.alias if item else ''
        self._suggester = LibrariesSuggester(self._controller, self._history_suggester)
        return [FileNameEditor(self, name, 'Name', self._controller, suggestion_source=self._suggester),
                ValueEditor(self, args, 'Args'),
                ValueEditor(self, alias, 'Alias')]

    def get_value(self):
        values = _Dialog.get_value(self)
        self._history_suggester.store(values[0])
        return values


class VariablesDialog(LibraryDialog):

    _history_suggester = HistorySuggester()

    def _get_editors(self, item):
        path = item and item.name or ''
        args = item and utils.join_value(item.args) or ''
        return [FileNameEditor(self, path, 'Path', self._controller, suggestion_source=self._history_suggester),
               ValueEditor(self, args, 'Args')]


class ResourceDialog(_Dialog):

    def _get_editors(self, item):
        name = item and item.name or ''
        return [FileNameEditor(self, name, 'Path', self._controller, suggestion_source=ResourceSuggester(self._controller))]


class DocumentationDialog(_Dialog):

    def _get_editors(self, doc):
        return [MultiLineEditor(self, doc)]

    def _add_comment_editor(self, item):
        pass

    def get_value(self):
        return _Dialog.get_value(self)

    def get_comment(self):
        return ''


class _SettingDialog(_Dialog):
    _validator = None

    def _get_editors(self, item):
        editor = ValueEditor(self, item.value)
        if self._validator:
            editor.set_validator(self._validator())
        return [editor]


class ForceTagsDialog(_SettingDialog):
    pass

class DefaultTagsDialog(_SettingDialog):
    pass

class TagsDialog(_SettingDialog):
    pass


class _FixtureDialog(_SettingDialog):

    def _get_editors(self, item):
        return [ContentAssistEditor(self, item.value)]

class SuiteSetupDialog(_FixtureDialog): pass

class SuiteTeardownDialog(_FixtureDialog): pass

class TestSetupDialog(_FixtureDialog): pass

class TestTeardownDialog(_FixtureDialog): pass

class SetupDialog(_FixtureDialog): pass

class TeardownDialog(_FixtureDialog): pass

class TemplateDialog(_FixtureDialog): pass

class TestTemplateDialog(_FixtureDialog): pass


class ArgumentsDialog(_SettingDialog):
    def _get_editors(self, item):
        return [ArgumentEditor(self, item.value, 'Arguments', ArgumentsValidator())]

class ReturnValueDialog(_SettingDialog):
    pass

class TestTimeoutDialog(_SettingDialog):
    _validator = TimeoutValidator

class TimeoutDialog(TestTimeoutDialog):
    pass


class MetadataDialog(_Dialog):

    def _get_editors(self, item):
        name, value = item and (item.name, item.value) or ('', '')
        return [ValueEditor(self, name, 'Name'),
                ValueEditor(self, value, 'Value')]


class TestCaseNameDialog(_Dialog):
    _title = 'New Test Case'

    def _add_comment_editor(self, item):
        pass

    def _get_editors(self, test):
        value = test.name if test else ''
        return [ValueEditor(self, value, 'Name',
                            TestCaseNameValidator(self._controller))]

    def get_name(self):
        return _Dialog.get_value(self)[0]


class CopyUserKeywordDialog(_Dialog):
    _title = 'Copy User Keyword'

    def _add_comment_editor(self, item):
        pass

    def _get_editors(self, uk):
        value = uk.name if uk else ''
        return [ValueEditor(self, value, 'Name',
                            UserKeywordNameValidator(self._controller))]

    def get_name(self):
        return _Dialog.get_value(self)[0]


class UserKeywordNameDialog(_Dialog):
    _title = 'New User Keyword'

    def _add_comment_editor(self, item):
        pass

    def _get_editors(self, uk):
        value = uk.name if uk else ''
        return [ValueEditor(self, value, 'Name',
                            UserKeywordNameValidator(self._controller)),
                ArgumentEditor(self, '', 'Arguments', ArgumentsValidator())]

    def get_name(self):
        return _Dialog.get_value(self)[0]

    def get_args(self):
        return _Dialog.get_value(self)[1]

########NEW FILE########
__FILENAME__ = editors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from robot.parsing.settings import Setting

from robotide import context
from robotide.controller.settingcontrollers import (DocumentationController,
    VariableController, TagsController)
from robotide.usages.UsageRunner import ResourceFileUsages
from robotide.publish import (RideItemSettingsChanged, RideInitFileRemoved,
                              RideFileNameChanged)
from robotide.widgets import (ButtonWithHandler, Label, HeaderLabel,
        HorizontalSizer, HtmlWindow)

from .settingeditors import (DocumentationEditor, SettingEditor, TagsEditor,
        ImportSettingListEditor, VariablesListEditor, MetadataListEditor)


class WelcomePage(HtmlWindow):
    undo = cut = copy = paste = delete = comment = uncomment = save \
        = show_content_assist = tree_item_selected = lambda *args: None

    def __init__(self, parent):
        HtmlWindow.__init__(self, parent, text=context.ABOUT_RIDE)

    def close(self):
        self.Show(False)

    def destroy(self):
        self.close()
        self.Destroy()


class EditorPanel(wx.Panel):
    """Base class for all editor panels"""
    # TODO: Move outside default editor package, document
    name = doc = ''
    title = None
    undo = cut = copy = paste = delete = comment = uncomment = save \
        = show_content_assist = lambda self: None

    def __init__(self, plugin, parent, controller, tree):
        wx.Panel.__init__(self, parent)
        self.plugin = plugin
        self.controller = controller
        self._tree = tree

    def tree_item_selected(self, item):
        pass


class _RobotTableEditor(EditorPanel):
    name = 'table'
    doc = 'table editor'
    _settings_open_id = 'robot table settings open'

    def __init__(self, plugin, parent, controller, tree):
        EditorPanel.__init__(self, plugin, parent, controller, tree)
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.Bind(wx.EVT_IDLE, self.OnIdle)
        self.SetSizer(self.sizer)
        if self.title:
            self.sizer.Add(self._create_header(self.title),
                           0, wx.EXPAND|wx.ALL, 5)
            self.sizer.Add((0,10))
        self._editors = []
        self._reset_last_show_tooltip()
        self._populate()
        self.plugin.subscribe(self._settings_changed, RideItemSettingsChanged)

    def _should_settings_be_open(self):
        if self._settings_open_id not in self.plugin.global_settings:
            return False
        return self.plugin.global_settings[self._settings_open_id]

    def _store_settings_open_status(self):
        self.plugin.global_settings[self._settings_open_id] = self._settings.IsExpanded()

    def _settings_changed(self, data):
        if data.item == self.controller:
            for editor in self._editors:
                editor.update_value()

    def OnIdle(self, event):
        if self._last_shown_tooltip and self._mouse_outside_tooltip():
            self._last_shown_tooltip.hide()
            self._reset_last_show_tooltip()

    def _mouse_outside_tooltip(self):
        mx, my = wx.GetMousePosition()
        tx, ty = self._last_shown_tooltip.screen_position
        dx, dy = self._last_shown_tooltip.size
        return (mx<tx or mx>tx+dx) or (my<ty or my>ty+dy)

    def tooltip_allowed(self, tooltip):
        if wx.GetMouseState().ControlDown() or \
                self._last_shown_tooltip is tooltip:
            return False
        self._last_shown_tooltip = tooltip
        return True

    def _reset_last_show_tooltip(self):
        self._last_shown_tooltip = None

    def close(self):
        self.plugin.unsubscribe(self._settings_changed, RideItemSettingsChanged)
        self.Unbind(wx.EVT_MOTION)
        self.Show(False)

    def destroy(self):
        self.close()
        self.Destroy()

    def _create_header(self, text, readonly=False):
        if readonly:
            text += ' (READ ONLY)'
        self._title_display = HeaderLabel(self, text)
        return self._title_display

    def _add_settings(self):
        self._settings = self._create_settings()
        self._restore_settings_open_status()
        self._editors.append(self._settings)
        self.sizer.Add(self._settings, 0, wx.ALL|wx.EXPAND, 2)

    def _create_settings(self):
        settings = Settings(self, self.plugin, self._tree)
        settings.Bind(wx.EVT_COLLAPSIBLEPANE_CHANGED, self._collabsible_changed)
        for setting in self.controller.settings:
            editor = settings.create_editor_for(setting)
            settings.add(editor)
        settings.build()
        return settings

    def _restore_settings_open_status(self):
        if self._should_settings_be_open():
            self._settings.Expand()
            wx.CallLater(200, self._collabsible_changed)
        else:
            self._settings.Collapse()

    def _collabsible_changed(self, event=None):
        self._store_settings_open_status()
        self.GetSizer().Layout()
        self.Refresh()
        if event:
            event.Skip()

    def highlight_cell(self, obj, row, column):
        '''Highlight the given object at the given row and column'''
        if isinstance(obj, Setting):
            setting_editor = self._get_settings_editor(obj)
            if setting_editor and hasattr(setting_editor, "highlight"):
                setting_editor.highlight(column)
        elif row >= 0 and column >= 0:
            self.kweditor.select(row, column)

    def _get_settings_editor(self, setting):
        '''Return the settings editor for the given setting object'''
        for child in self.GetChildren():
            if isinstance(child, SettingEditor):
                if child._item == setting:
                    return child
        return None

    def highlight(self, text, expand=True):
        for editor in self._editors:
            editor.highlight(text, expand=expand)


class Settings(wx.CollapsiblePane):
    BORDER = 2

    def __init__(self, parent, plugin, tree):
        wx.CollapsiblePane.__init__(self, parent, wx.ID_ANY, 'Settings',
                                    style=wx.CP_DEFAULT_STYLE|wx.CP_NO_TLW_RESIZE)
        self._sizer = wx.BoxSizer(wx.VERTICAL)
        self._plugin = plugin
        self._tree = tree
        self._editors = []
        self.Bind(wx.EVT_SIZE, self._recalc_size)

    def Expand(self):
        wx.CollapsiblePane.Expand(self)

    def GetPane(self):
        pane = wx.CollapsiblePane.GetPane(self)
        pane.tooltip_allowed = self.GetParent().tooltip_allowed
        return pane

    def close(self):
        for editor in self._editors:
            editor.close()

    def update_value(self):
        for editor in self._editors:
            editor.update_value()

    def create_editor_for(self, controller):
        editor_cls = self._get_editor_class(controller)
        return editor_cls(self.GetPane(), controller, self._plugin, self._tree)

    def _get_editor_class(self, controller):
        if isinstance(controller, DocumentationController):
            return DocumentationEditor
        if isinstance(controller, TagsController):
            return TagsEditor
        return SettingEditor

    def add(self, editor):
        self._sizer.Add(editor, 0, wx.ALL|wx.EXPAND, self.BORDER)
        self._editors.append(editor)

    def build(self):
        self.GetPane().SetSizer(self._sizer)
        self._sizer.SetSizeHints(self.GetPane())

    def _recalc_size(self, event=None):
        if self.IsExpanded():
            expand_button_height = 32  # good guess...
            height = sum(editor.Size[1]+2*self.BORDER for editor in self._editors)
            self.SetSizeHints(-1, height + expand_button_height)
        if event:
            event.Skip()

    def highlight(self, text, expand=True):
        match = False
        for editor in self._editors:
            if editor.contains(text):
                editor.highlight(text)
                match = True
            else:
                editor.clear_highlight()
        if match and expand:
            self.Expand()
            self.Parent.GetSizer().Layout()


class _FileEditor(_RobotTableEditor):

    def __init__(self, *args):
        _RobotTableEditor.__init__(self, *args)
        self.plugin.subscribe(self._update_source_and_name, RideFileNameChanged)

    def _update_source(self, message=None):
        self._source.SetValue(self.controller.data.source)

    def _update_source_and_name(self, message):
        self._title_display.SetLabel(self.controller.name)
        self._update_source()

    def tree_item_selected(self, item):
        if isinstance(item, VariableController):
            self._var_editor.select(item.name)

    def _populate(self):
        datafile = self.controller.data
        self.sizer.Add(self._create_header(datafile.name, not self.controller.is_modifiable()), 0, wx.EXPAND|wx.ALL, 5)
        self.sizer.Add(self._create_source_label(datafile.source), 0, wx.EXPAND|wx.ALL, 1)
        self.sizer.Add((0, 10))
        self._add_settings()
        self._add_import_settings()
        self._add_variable_table()

    def _create_source_label(self, source):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add((5,0))
        sizer.Add(Label(self, label='Source',
                        size=(context.SETTING_LABEL_WIDTH,
                              context.SETTING_ROW_HEIGTH)))
        self._source = wx.TextCtrl(self, style=wx.TE_READONLY|wx.NO_BORDER)
        self._source.SetBackgroundColour(self.BackgroundColour)
        self._source.SetValue(source)
        self._source.SetMaxSize(wx.Size(-1, context.SETTING_ROW_HEIGTH))
        sizer.Add(self._source, 1, wx.EXPAND)
        return sizer

    def _add_import_settings(self):
        import_editor = ImportSettingListEditor(self, self._tree, self.controller.imports)
        self.sizer.Add(import_editor, 1, wx.EXPAND)
        self._editors.append(import_editor)

    def _add_variable_table(self):
        self._var_editor = VariablesListEditor(self, self._tree, self.controller.variables)
        self.sizer.Add(self._var_editor, 1, wx.EXPAND)
        self._editors.append(self._var_editor)

    def close(self):
        self.plugin.unsubscribe(self._update_source_and_name, RideFileNameChanged)
        for editor in self._editors:
            editor.close()
        self._editors = []
        _RobotTableEditor.close(self)

    delete_rows = insert_rows = lambda s:0 #Stubs so that ctrl+d ctrl+i don't throw exceptions


class FindUsagesHeader(HorizontalSizer):

    def __init__(self, parent, header, usages_callback):
        HorizontalSizer.__init__(self)
        self._header = HeaderLabel(parent, header)
        self.add_expanding(self._header)
        self.add(ButtonWithHandler(parent, 'Find Usages', usages_callback))

    def SetLabel(self, label):
        self._header.SetLabel(label)


class ResourceFileEditor(_FileEditor):
    _settings_open_id = 'resource file settings open'

    def _create_header(self, text, readonly=False):
        if readonly:
            text += ' (READ ONLY)'
        def cb(event):
            ResourceFileUsages(self.controller, self._tree.highlight).show()
        self._title_display = FindUsagesHeader(self, text, cb)
        return self._title_display


class TestCaseFileEditor(_FileEditor):
    _settings_open_id = 'test case file settings open'

    def _populate(self):
        _FileEditor._populate(self)
        self.sizer.Add((0, 10))
        self._add_metadata()

    def _add_metadata(self):
        metadata_editor = MetadataListEditor(self, self._tree, self.controller.metadata)
        self.sizer.Add(metadata_editor, 1, wx.EXPAND)
        self._editors.append(metadata_editor)


class InitFileEditor(TestCaseFileEditor):
    _settings_open_id = 'init file settings open'

    def _populate(self):
        TestCaseFileEditor._populate(self)
        self.plugin.subscribe(self._init_file_removed, RideInitFileRemoved)

    def _init_file_removed(self, message):
        for setting, editor in zip(self.controller.settings, self._editors):
            editor.refresh(setting)

########NEW FILE########
__FILENAME__ = fieldeditors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import wx.grid

from robotide.context import ctrl_or_cmd, bind_keys_to_evt_menu
from robotide.editor.contentassist import ContentAssistFileButton
from robotide.namespace.suggesters import SuggestionSource
from robotide.widgets import Label

from .contentassist import ContentAssistTextCtrl
from .grid import GridEditor


class ValueEditor(wx.Panel):
    expand_factor = 0
    _sizer_flags_for_editor = wx.ALL
    _sizer_flags_for_label = wx.ALL

    def __init__(self, parent, value, label=None, validator=None, settings=None):
        wx.Panel.__init__(self, parent)
        self._label = label
        self._sizer = wx.BoxSizer(wx.VERTICAL)
        self._create_editor(value, label, settings)
        if validator:
            self.set_validator(validator)
        self.SetSizer(self._sizer)

    def _create_editor(self, value, label, settings):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        if self._label:
            sizer.Add(Label(self, label=self._label, size=(80, -1)), 0, self._sizer_flags_for_label, 5)
        self._editor = self._get_text_ctrl()
        self._editor.AppendText(value)
        sizer.Add(self._editor, 1, self._sizer_flags_for_editor, 3)
        self._sizer.Add(sizer, 1, wx.EXPAND)
        wx.EVT_KEY_DOWN(self._editor, self.on_key_down)

    def _get_text_ctrl(self):
        return wx.TextCtrl(self, size=(600, -1))

    def set_validator(self, validator):
        self._editor.SetValidator(validator)

    def get_value(self):
        return self._editor.GetValue()

    def set_focus(self):
        self._editor.SetFocus()
        self._editor.SelectAll()

    def on_key_down(self, event):
        character = None
        keycode, control_down = event.GetKeyCode(), event.CmdDown()
        if  event.CmdDown() and event.GetKeyCode() == ord('1'):
            character = '$'
        elif event.CmdDown() and event.GetKeyCode() == ord('2'):
            character = '@'
        if character:
            if len(self.get_value()) == 0:
                self._editor.WriteText(character + "{}")
            else:
                self._editor.AppendText(" | " + character + "{}")
            _from, _ = self._editor.GetSelection()
            self._editor.SetInsertionPoint(_from-1)
        else:
            event.Skip()


class ArgumentEditor(ValueEditor):

    def _create_editor(self, value, label, settings):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        if self._label:
            sizer.Add(Label(self, label=self._label, size=(80, -1)), 0, self._sizer_flags_for_label, 5)
        self._editor = self._get_text_ctrl()
        self._editor.AppendText(value)
        sizer.Add(self._editor, 1, self._sizer_flags_for_editor, 3)
        self._sizer.Add(sizer, 1, wx.EXPAND)


class FileNameEditor(ValueEditor):

    _sizer_flags_for_editor = 0
    _sizer_flags_for_label =  wx.TOP|wx.BOTTOM|wx.LEFT

    def __init__(self, parent, value, label, controller, validator=None, settings=None, suggestion_source=None):
        self._suggestion_source = suggestion_source or SuggestionSource(parent.plugin, None)
        self._controller = controller
        self._label = label
        self._parent = parent
        ValueEditor.__init__(self, parent, value, label, validator, settings)

    def setFocusToOK(self):
        self._parent.setFocusToOK()

    def _get_text_ctrl(self):
        return ContentAssistFileButton(self, self._suggestion_source, '', self._controller, (500, -1))


class VariableNameEditor(ValueEditor):

    def _get_text_ctrl(self):
        textctrl = ValueEditor._get_text_ctrl(self)
        textctrl.Bind(wx.EVT_SET_FOCUS, self.OnFocus)
        return textctrl

    def OnFocus(self, event):
        wx.CallAfter(self.SetSelection, event.GetEventObject())

    def SetSelection(self, event):
        self._editor.SetSelection(2, len(self._editor.Value) - 1)


class ListValueEditor(ValueEditor):
    expand_factor = 1
    _sizer_flags_for_editor = wx.ALL | wx.EXPAND

    def _create_editor(self, value, label, settings):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._settings = settings
        cols = self._settings['list variable columns']
        sizer.Add(self._create_components(label, cols))
        self._editor = _EditorGrid(self, value, cols)
        sizer.Add(self._editor, 1, self._sizer_flags_for_editor, 3)
        self._sizer.Add(sizer, 1, wx.EXPAND)
        self.Bind(wx.EVT_SIZE, self.OnSize)

    def _create_components(self, label, cols):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self._create_label(label), 0, wx.ALL, 5)
        sizer.Add((-1, 10))
        sizer.Add(self._create_column_selector(cols))
        return sizer

    def _create_label(self, label_text):
        return Label(self, label=label_text, size=(80, -1))

    def _create_column_selector(self, cols):
        sizer = wx.BoxSizer(wx.VERTICAL)
        col_label = Label(self, label='Columns', size=(80, -1))
        sizer.Add(col_label, 0, wx.ALL, 5)
        combo = wx.ComboBox(self, value=str(cols), size=(60, 25),
                            choices=[str(i) for i in range(1, 11)])
        combo.SetToolTip(wx.ToolTip('Number of columns that are shown in this '
                                    'editor. Selected value is stored and used '
                                    'globally.'))
        self.Bind(wx.EVT_COMBOBOX, self.OnColumns, source=combo)
        sizer.Add(combo)
        return sizer

    def OnColumns(self, event):
        num_cols = int(event.String)
        self._settings['list variable columns'] = num_cols
        self._editor.set_number_of_columns(num_cols)

    def OnAddRow(self, event):
        self._editor.add_row()

    def OnSize(self, event):
        self._editor.resize_columns(event.Size[0] - 110)
        event.Skip()

    def get_value(self):
        return self._editor.get_value()


class _EditorGrid(GridEditor):
    _col_add_threshold = 0

    def __init__(self, parent, value, num_cols):
        num_rows = len(value) / num_cols + 2
        GridEditor.__init__(self, parent, num_rows, num_cols)
        self._set_default_sizes()
        self._bind_actions()
        self._write_content(value)

    def _set_default_sizes(self):
        self.SetColLabelSize(0)
        self.SetRowLabelSize(0)
        self.SetDefaultColSize(175)

    def _bind_actions(self):
        bind_keys_to_evt_menu(self, self._get_bind_keys())
        self.Bind(wx.grid.EVT_GRID_EDITOR_SHOWN, self.OnEditorShown)

    def _get_bind_keys(self):
        return [(ctrl_or_cmd(), ord('c'), self.OnCopy),
                (ctrl_or_cmd(), ord('x'), self.OnCut),
                (ctrl_or_cmd(), ord('v'), self.OnPaste),
                (ctrl_or_cmd(), ord('z'), self.OnUndo),
                (ctrl_or_cmd(), ord('a'), self.OnSelectAll),
                (wx.ACCEL_NORMAL, wx.WXK_DELETE, self.OnDelete)]


    def _write_content(self, value):
        self.ClearGrid()
        for index, item in enumerate(value):
            row, col = divmod(index, self.NumberCols)
            self.write_cell(row, col, item, False)
        self.AutoSizeRows()

    def get_value(self):
        value = []
        for row in range(self.NumberRows):
            for col in range(self.NumberCols):
                value.append(self.GetCellValue(row, col))
        while value and not value[-1]:
            value.pop()
        return value

    def OnEditorShown(self, event):
        if event.Row >= self.NumberRows - 1:
            self.AppendRows(1)

    def OnInsertCells(self, event):
        if len(self.selection.rows()) != 1:
            self._insert_cells_to_multiple_rows(event)
            return
        def insert_cells(data, start, end):
            return data[:start] + [''] * (end - start) + data[start:]
        self._insert_or_delete_cells_on_single_row(insert_cells, event)

    def OnDeleteCells(self, event):
        if len(self.selection.rows()) != 1:
            self._delete_cells_from_multiple_rows(event)
            return
        def delete_cells(data, start, end):
            return data[:start] + data[end:]
        self._insert_or_delete_cells_on_single_row(delete_cells, event)

    def _insert_or_delete_cells_on_single_row(self, action, event):
        self._update_history()
        value = self.get_value()
        row, col = self.selection.cell
        start = row * self.NumberCols + col
        data = action(value, start, start + len(self.selection.cols()))
        self._write_content(data)
        event.Skip()

    def _insert_cells_to_multiple_rows(self, event):
        GridEditor.OnInsertCells(self, event)

    def _delete_cells_from_multiple_rows(self, event):
        GridEditor.OnDeleteCells(self, event)

    def OnCopy(self, event):
        self.copy()

    def OnCut(self, event):
        self.cut()

    def OnPaste(self, event):
        self.paste()

    def OnDelete(self, event):
        self.delete()

    def OnUndo(self, event):
        self.undo()

    def OnSelectAll(self, event):
        self.SelectAll()

    def resize_columns(self, width):
        self.SetDefaultColSize(max(width / self.NumberCols, 100), True)

    def set_number_of_columns(self, columns):
        new_cols = columns - self.NumberCols
        if not new_cols:
            return
        width = self.NumberCols * self.GetDefaultColSize()
        data = self.get_value()
        self._set_cols(new_cols)
        self.resize_columns(width)
        self._write_content(data)

    def _set_cols(self, new_cols):
        if new_cols > 0:
            self.AppendCols(numCols=new_cols)
        else:
            self.DeleteCols(numCols= -new_cols)


class MultiLineEditor(ValueEditor):
    _sizer_flags_for_editor = wx.ALL | wx.EXPAND

    def _get_text_ctrl(self):
        return wx.TextCtrl(self, style=wx.TE_MULTILINE, size=(600, 400))


class ContentAssistEditor(ValueEditor):

    def __init__(self, parent, value, label=None, validator=None, settings=None, suggestion_source=None):
        self._suggestion_source = suggestion_source or SuggestionSource(parent.plugin, None)
        ValueEditor.__init__(self, parent, value, label, validator, settings)

    def _get_text_ctrl(self):
        return ContentAssistTextCtrl(self, self._suggestion_source, (500, -1))

########NEW FILE########
__FILENAME__ = flowsizer
#-------------------------------------------------------------------------------
#  Class: FlowSizer
#  Defines a horizontal or vertical flow layout sizer for wxPython
#  Written by: David C. Morrill
#  Date: 01/12/2006
#  (c) Copyright 2006 by Enthought, Inc.
#  License: BSD Style.
#-------------------------------------------------------------------------------

# This code has been modified after inclusion and is no longer generic.
# You should probably not use this in your own projects.

import wx

class HorizontalFlowSizer(wx.PySizer):
    """
    A sizer which lays out component left to right top to bottom. Java uses
    these quite heavily
    """
    _DEFAUL_WIDTH = 200

    def __init__(self):
        '''
        Initializes the object:
        '''
        wx.PySizer.__init__(self)
        self._frozen       = False
        self._needed_size  = None
        self._height = 0

    def CalcMin(self):
        """
        Calculates the minimum size needed by the sizer.
        """
        return wx.Size(0, 0)

    def RecalcSizes(self):
        """
        Layout the contents of the sizer based on the sizer's current size
        and position.
        """
        x0, y0 = self.GetPosition()
        dx, dy = self.GetSize()
        dy = self._height or dy
        if self._is_error_width(dx):
            dx = HorizontalFlowSizer._DEFAUL_WIDTH
        else:
            HorizontalFlowSizer._DEFAUL_WIDTH = dx
        x_border = x0 + dx
        x, y = x0, y0
        mdy = sdy = 0
        cur_max = 0
        for item in self.GetChildren():
            idx, idy = item.CalcMin()
            expand  = item.GetFlag() & wx.EXPAND
            if (x > x0) and ((x + idx) > x_border):
                x   = x0
                y  += (mdy + sdy)
                mdy = sdy = 0
            cur_max = max(idy, cur_max)
            if expand:
                idy = cur_max
            if item.IsSpacer():
                sdy = max(sdy, idy)
                if x == x0:
                    idx = 0
            item.SetDimension(wx.Point(x, y), wx.Size(idx, idy))
            item.Show(True)
            x += idx
            mdy = max(mdy, idy)
        newheight = y + mdy + sdy - y0
        if newheight != self._height:
            self._height = newheight
            # Enforce that the parent window recalculates needed height
            self._send_resize_event()

    def _send_resize_event(self):
        frame = self.GetContainingWindow().GetTopLevelParent()
        frame.ProcessEvent(wx.SizeEvent(frame.Size, frame.Id))

    def _is_error_width(self, dx):
        # It seems that there are several widths that notify that the width
        # calculation was unsuccessful. The erroneous widths are:
        # 94 in windows xp
        # 100 in windows 7
        # 0 everywhere
        return dx in [0, 94, 100]

    @property
    def height(self):
        return self._height + 25

########NEW FILE########
__FILENAME__ = formatters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

class ListToStringFormatter(object):

    def __init__(self, data):
        self._data = data

    @property
    def value(self):
        return ' | '.join(self._data.as_list())

########NEW FILE########
__FILENAME__ = grid
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx import grid

from robotide.widgets import PopupCreator, PopupMenuItems
from robotide.context import IS_WINDOWS
from clipboard import ClipboardHandler


class GridEditor(grid.Grid):
    _col_add_threshold = 1
    _popup_items = ['Insert Cells\tCtrl-Shift-I', 'Delete Cells\tCtrl-Shift-D',
                    'Insert Rows\tCtrl-I', 'Delete Rows\tCtrl-D',
                    '---', 'Select All\tCtrl-A',
                    '---', 'Cut\tCtrl-X', 'Copy\tCtrl-C',
                    'Paste\tCtrl-V',
                    'Insert\tCtrl-Shift-V',
                    '---', 'Delete\tDel']

    def __init__(self, parent, num_rows, num_cols, popup_creator=None):
        grid.Grid.__init__(self, parent)
        self._bind_to_events()
        self.selection = _GridSelection(self)
        self.SetDefaultRenderer(grid.GridCellAutoWrapStringRenderer())
        self._clipboard_handler = ClipboardHandler(self)
        self._history = _GridState()
        self.CreateGrid(num_rows, num_cols)
        self._popup_creator = popup_creator or PopupCreator()

    def _bind_to_events(self):
        self.Bind(grid.EVT_GRID_SELECT_CELL, self.OnSelectCell)
        self.Bind(grid.EVT_GRID_RANGE_SELECT, self.OnRangeSelect)
        self.Bind(grid.EVT_GRID_CELL_RIGHT_CLICK, self.OnCellRightClick)

    def register_context_menu_hook(self, callable):
        self._popup_creator.add_hook(callable)

    def unregister_context_menu_hook(self, callable):
        self._popup_creator.remove_hook(callable)

    def write_cell(self, row, col, value, update_history=True):
        if update_history:
            self._update_history()
        self._expand_if_necessary(row, col)
        self.SetCellValue(row, col, value)

    def _expand_if_necessary(self, row, col):
        while row >= self.NumberRows - 1:
            self.AppendRows(1)
        while col >= self.NumberCols - self._col_add_threshold:
            self.AppendCols(1)

    def has_focus(self):
        return self.FindFocus() == self.GridWindow

    def _update_history(self):
        self._history.change(self._get_all_content())

    def _get_all_content(self):
        return self._get_block_content(range(self.NumberRows),
                                       range(self.NumberCols))

    @property
    def cell_under_cursor(self):
        x, y = self.ScreenToClient(wx.GetMousePosition())
        x -= self.RowLabelSize
        return self.XYToCell(*self.CalcUnscrolledPosition(x, y))

    def select(self, row, column):
        self.SelectBlock(row, column, row, column)
        self.SetGridCursor(row, column)
        self.MakeCellVisible(row, column)

    def copy(self):
        self._clipboard_handler.copy()

    def cut(self):
        self._update_history()
        self._clipboard_handler.cut()
        self._clear_selected_cells()

    def _clear_selected_cells(self):
        for row, col in self.selection.cells():
            self.write_cell(row, col, '', update_history=False)

    def paste(self):
        self._update_history()
        self._clipboard_handler.paste()

    def delete(self):
        self._update_history()
        if self.IsCellEditControlShown():
            if IS_WINDOWS:
                self._delete_from_cell_editor()
        else:
            self._clear_selected_cells()

    def _delete_from_cell_editor(self):
        editor = self.get_cell_edit_control()
        start, end = editor.Selection
        if start == end:
            end += 1
        editor.Remove(start, end)

    def _is_whole_row_selection(self):
        return self.SelectedRows

    def get_cell_edit_control(self):
        return self.GetCellEditor(*self.selection.cell).GetControl()

    def get_selected_content(self):
        return self._get_block_content(self.selection.rows(),
                                       self.selection.cols())

    def get_single_selection_content(self):
        cells = self.get_selected_content()
        if len(cells) != 1 or len(cells[0]) != 1:
            return None
        return cells[0][0]

    def _current_cell_value(self):
        return self.GetCellValue(*self.selection.cell)

    def _get_block_content(self, row_range, col_range):
        return [[self.GetCellValue(row, col) for col in col_range]
                 for row in row_range]

    def _strip_trailing_empty_cells(self, rowdata):
        while rowdata and not rowdata[-1]:
            rowdata.pop()
        return rowdata

    def undo(self):
        prev_data = self._history.back()
        if prev_data:
            self.ClearGrid()
            self._write_data(prev_data, update_history=False)

    def _write_data(self, data, update_history=True):
        for row_index, row_data in enumerate(data):
            for col_index, cell_value in enumerate(row_data):
                self.write_cell(row_index, col_index, cell_value, update_history)
        self.AutoSizeColumns()
        self.AutoSizeRows()

    def OnSelectCell(self, event):
        if self._is_whole_row_selection():
            self.SelectBlock(self.selection.topleft.row, self.selection.topleft.col,self.selection.bottomright.row, self.selection.bottomright.col, addToSelected=True)
        else:
            self.selection.set_from_single_selection(event)
        self.AutoSizeRows()
        event.Skip()

    def OnRangeSelect(self, event):
        if not event.Selecting():
            self.selection.clear()
            return
        if event.ControlDown():
            self.SetGridCursor(event.TopRow, event.LeftCol)
            self.SelectBlock(event.TopRow, event.LeftCol,
                             event.BottomRow, event.RightCol, addToSelected=False)
        else:
            self.selection.set_from_range_selection(self, event)
            self._ensure_selected_row_is_visible(event.BottomRow)

    def _ensure_selected_row_is_visible(self, bottom_row):
        if not self.IsVisible(bottom_row , 0) and bottom_row < self.NumberRows and self._is_whole_row_selection():
            self.MakeCellVisible(bottom_row, 0)

    def OnCellRightClick(self, event):
        if hasattr(event, 'Row') and hasattr(event, 'Col'):
            if not (event.Row, event.Col) in self.selection.cells():
                self.select(event.Row, event.Col)
                self.selection.set_from_single_selection(event)
        self._popup_creator.show(self, PopupMenuItems(self, self._popup_items),
                                 self.get_selected_content())

    def OnInsertCells(self, event):
        self._insert_or_delete_cells(self._insert_cells, event)

    def OnDeleteCells(self, event):
        self._insert_or_delete_cells(self._delete_cells, event)

    def _insert_or_delete_cells(self, action, event):
        self._update_history()
        for index in self.selection.rows():
            data = action(self._row_data(index))
            self._write_row(index, data)
        self._refresh_layout()
        event.Skip()

    def _insert_cells(self, data):
        cols = self.selection.cols()
        left = right = cols[0]
        data[left:right] = [''] * len(cols)
        return self._strip_trailing_empty_cells(data)

    def _delete_cells(self, data):
        cols = self.selection.cols()
        left, right = cols[0], cols[-1] + 1
        data[left:right] = []
        return data + [''] * len(cols)

    def _row_data(self, row):
        return [self.GetCellValue(row, col) for col in range(self.NumberCols)]

    def _write_row(self, row, data):
        for col, value in enumerate(data):
            self.write_cell(row, col, value, update_history=False)

    def _refresh_layout(self):
        self.SetFocus()
        self.SetGridCursor(*self.selection.cell)
        self.GetParent().Sizer.Layout()


# TODO: refactor this internal state away if possible
class _GridSelection(object):
    cell = property(lambda self: (self.topleft.row, self.topleft.col))

    def __init__(self, grid):
        self._set((0, 0))
        self._grid = grid

    def _set(self, topleft, bottomright=None):
        self.topleft = _Cell(topleft[0], topleft[1])
        self.bottomright = self._count_bottomright(topleft, bottomright)

    def _count_bottomright(self, topleft, bottomright):
        if not bottomright:
            return _Cell(topleft[0], topleft[1])
        return _Cell(min(self._grid.NumberRows - 1, bottomright[0]),
                     min(self._grid.NumberCols - 1, bottomright[1]))

    def set_from_single_selection(self, event):
        self._set((event.Row, event.Col))

    def set_from_range_selection(self, grid, event):
        self._set(*self._get_bounding_coordinates(grid, event))

    def clear(self):
        selection = (self._grid.GetGridCursorRow(), self._grid.GetGridCursorCol())
        self._set(selection)

    def _get_bounding_coordinates(self, grid, event):
        whole_row_selection = sorted(grid.SelectedRows)
        if whole_row_selection:
            return (whole_row_selection[0], 0), \
                   (whole_row_selection[-1], grid.NumberCols - 1)
        return (event.TopLeftCoords.Row, event.TopLeftCoords.Col), \
               (event.BottomRightCoords.Row, event.BottomRightCoords.Col)

    def rows(self):
        """Returns a list containing indices of rows currently selected."""
        return range(self.topleft.row, self.bottomright.row + 1)

    def cols(self):
        """Returns a list containing indices of columns currently selected."""
        return range(self.topleft.col, self.bottomright.col + 1)

    def cells(self):
        """Return selected cells as a list of tuples (row, column)."""
        return [(row, col) for col in self.cols()
                           for row in self.rows()]


class _Cell(object):

    def __init__(self, row, col):
        self.row = row
        self.col = col

    def __iter__(self):
        for item in self.row, self.col:
            yield item


class _GridState(object):

    def __init__(self):
        self._back = []
        self._forward = []

    def change(self, state):
        if not self._back or state != self._back[-1]:
            self._back.append(state)
            self._forward = []

    def back(self):
        if not self._back:
            return None
        self._forward.append(self._back.pop())
        return self._forward[-1]

    def forward(self):
        if not self._forward:
            return None
        state = self._forward.pop()
        self._back.append(state)
        return state

########NEW FILE########
__FILENAME__ = gridcolorizer
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.controller.cellinfo import CellType
import wx
# this import fails in HUDSON
# from wxPython._gdi import wxFONTWEIGHT_BOLD, wxFONTWEIGHT_NORMAL
wxFONTWEIGHT_BOLD = 92
wxFONTWEIGHT_NORMAL = 90

class Colorizer(object):

    def __init__(self, grid, controller, colors):
        self._grid = grid
        self._controller = controller
        self._colors=colors
        self._current_task_id = 0
        self._timer = None

    def close(self):
        self._grid = None

    def colorize(self, selection_content):
        self._current_task_id += 1
        if self._timer is None:
            self._timer = wx.CallLater(1, self._coloring_task, self._current_task_id, selection_content)
        else:
            self._timer.Restart(50, self._current_task_id, selection_content)

    def _coloring_task(self, task_index, selection_content, row=0, col=0):
        if task_index != self._current_task_id or self._grid is None:
            return
        if row >= self._grid.NumberRows:
            self._grid.ForceRefresh()
            self._grid.AutoSizeRows()
        elif col < self._grid.NumberCols:
            self._colorize_cell(row, col, selection_content)
            wx.CallAfter(self._coloring_task, task_index, selection_content, row, col+1)
        else:
            self._coloring_task(task_index, selection_content, row+1, 0)

    def _colorize_cell(self, row, col, selection_content):
        cell_info = self._controller.get_cell_info(row, col)
        if cell_info is None:
            self._set_default_colors(row, col)
            return
        self._grid.SetCellTextColour(row, col, self._get_text_color(cell_info))
        self._grid.SetCellBackgroundColour(row, col, self._get_background_color(cell_info, selection_content))
        self._grid.SetCellFont(row, col, self._get_cell_font(row, col, cell_info))

    def _set_default_colors(self, row, col):
        self._grid.SetCellTextColour(row, col, self._colors.DEFAULT_TEXT)
        self._grid.SetCellBackgroundColour(row, col, self._colors.DEFAULT_BACKGROUND)

    def _get_text_color(self, cell_info):
        return self._colors.get_text_color(cell_info.content_type)

    def _get_background_color(self, cell_info, selection_content):
        if cell_info.matches(selection_content):
            return self._colors.get_highlight_color()
        if cell_info.has_error():
            return self._colors.get_error_color()
        return self._colors.get_background_color(cell_info.cell_type)

    def _get_cell_font(self, row, col, cell_info):
        font = self._grid.GetCellFont(row, col)
        font.SetWeight(self._get_weight(cell_info))
        return font

    def _get_weight(self, cell_info):
        if cell_info.cell_type == CellType.KEYWORD:
            return wxFONTWEIGHT_BOLD
        return wxFONTWEIGHT_NORMAL


class ColorizationSettings(object):

    DEFAULT_TEXT = 'black'
    DEFAULT_BACKGROUND = 'white'

    def __init__(self, settings=None):
        self._settings = settings

    def get_background_color(self, type):
        if not self._settings:
            return self.DEFAULT_BACKGROUND
        return self._get('background %s' % type)

    def get_text_color(self, type):
        if not self._settings:
            return self.DEFAULT_TEXT
        return self._get('text %s' % type)

    def get_highlight_color(self):
        return self.get_background_color('highlight')

    def get_error_color(self):
        return self.get_background_color('error')

    def _get(self, name):
        return self._settings['Grid Colors'][name.lower().replace('_',' ')]

########NEW FILE########
__FILENAME__ = kweditor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx import grid
from robot.parsing.model import Variable

from robotide.context import IS_MAC
from robotide.controller.commands import (ChangeCellValue, ClearArea, PasteArea,
        DeleteRows, AddRows, CommentRows, InsertCells, DeleteCells,
        UncommentRows, Undo, Redo, RenameKeywordOccurrences, ExtractKeyword,
        AddKeywordFromCells, MoveRowsUp, MoveRowsDown, ExtractScalar, ExtractList,
        InsertArea)
from robotide.controller.cellinfo import TipMessage, ContentType, CellType
from robotide.publish import (RideItemStepsChanged,
                              RideSettingsChanged, PUBLISHER)
from robotide.usages.UsageRunner import Usages, VariableUsages
from robotide.ui.progress import RenameProgressObserver
from robotide import utils
from robotide.utils import RideEventHandler, overrides, is_variable
from robotide.widgets import PopupMenu, PopupMenuItems

from .grid import GridEditor
from .tooltips import GridToolTips
from .editordialogs import (UserKeywordNameDialog, ScalarVariableDialog,
        ListVariableDialog)
from .contentassist import ExpandingContentAssistTextCtrl
from .gridcolorizer import Colorizer, ColorizationSettings

_DEFAULT_FONT_SIZE=11

def requires_focus(function):
    def _row_header_selected_on_linux(self):
        return self.FindFocus() is None
    def decorated_function(self, *args):
        if self.has_focus() or self.IsCellEditControlShown() or _row_header_selected_on_linux(self):
            function(self, *args)
    return decorated_function


class KeywordEditor(GridEditor, RideEventHandler):
    _no_cell = (-1,-1)
    _popup_menu_shown = False
    dirty = property(lambda self: self._controller.dirty)
    update_value = lambda *args: None
    _popup_items = ['Create Keyword', 'Extract Keyword', 'Extract Variable',
                    'Rename Keyword', 'Find Where Used', '---',
                    'Make Variable\tCtrl-1',
                    'Make List Variable\tCtrl-2', '---',
                    'Go to Definition\tCtrl-B', '---'] + GridEditor._popup_items

    def __init__(self, parent, controller, tree):
        try:
            GridEditor.__init__(self, parent, len(controller.steps) + 5,
                                max((controller.max_columns + 1), 5),
                                parent.plugin._grid_popup_creator)
            self._parent = parent
            self._plugin = parent.plugin
            self._cell_selected = False
            self._colorizer = Colorizer(self, controller,
                                        ColorizationSettings(self._plugin.global_settings))
            self._controller = controller
            self._configure_grid()
            PUBLISHER.subscribe(self._data_changed, RideItemStepsChanged)
            PUBLISHER.subscribe(self.OnSettingsChanged, RideSettingsChanged)
            self._updating_namespace = False
            self._controller.datafile_controller.register_for_namespace_updates(self._namespace_updated)
            self._tooltips = GridToolTips(self)
            self._marked_cell = None
            self._make_bindings()
            self._write_steps(self._controller)
            self._tree = tree
            self._has_been_clicked = False
            font_size = self._plugin.global_settings.get('font size', _DEFAULT_FONT_SIZE)
            self.SetDefaultCellFont(wx.Font(font_size, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
        except Exception, e:
            print 'Exception in initializing KeywordEditor: %s' % e
            raise

    def _namespace_updated(self):
        if not self._updating_namespace:
            self._updating_namespace = True
            # See following issue for history of the next line:
            # http://code.google.com/p/robotframework-ride/issues/detail?id=1108
            wx.CallAfter(wx.CallLater, 200, self._update_based_on_namespace_change)

    def _update_based_on_namespace_change(self):
        try:
            self._colorize_grid()
        finally:
            self._updating_namespace = False

    def _configure_grid(self):
        self.SetRowLabelSize(25)
        self.SetColLabelSize(0)
        self.SetDefaultColSize(170)
        self.SetDefaultCellOverflow(False)
        self.SetDefaultEditor(ContentAssistCellEditor(self._plugin, self._controller))

    def _make_bindings(self):
        self.Bind(grid.EVT_GRID_EDITOR_SHOWN, self.OnEditor)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(grid.EVT_GRID_CELL_LEFT_CLICK, self.OnCellLeftClick)
        self.Bind(grid.EVT_GRID_CELL_LEFT_DCLICK, self.OnCellLeftDClick)
        self.Bind(grid.EVT_GRID_LABEL_RIGHT_CLICK, self.OnLabelRightClick)
        self.Bind(grid.EVT_GRID_LABEL_LEFT_CLICK, self.OnLabelLeftClick)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)

    def get_tooltip_content(self):
        if self.IsCellEditControlShown() or self._popup_menu_shown:
            return ''
        cell = self.cell_under_cursor
        cell_info = self._controller.get_cell_info(cell.Row, cell.Col)
        return TipMessage(cell_info)

    def OnSettingsChanged(self, data):
        '''Redraw the colors if the color settings are modified'''
        if data.keys[0] == "Grid Colors":
            self._colorize_grid()

    def OnSelectCell(self, event):
        self._cell_selected = True
        GridEditor.OnSelectCell(self, event)
        self._colorize_grid()
        event.Skip()

    def OnKillFocus(self, event):
        self._tooltips.hide()
        self._hide_link_if_necessary()

    def _execute(self, command):
        return self._controller.execute(command)

    def _toggle_underlined(self, cell):
        font = self.GetCellFont(cell.Row, cell.Col)
        font.SetUnderlined(not font.Underlined)
        self.SetCellFont(cell.Row, cell.Col, font)
        self.Refresh()

    def OnLabelRightClick(self, event):
        if event.Col == -1:
            self._row_label_right_click(event)
        else:
            self._col_label_right_click(event)

    def _row_label_right_click(self, event):
        selected_row = event.GetRow()
        selected_rows = self.selection.rows()
        if selected_row not in selected_rows:
            self.SelectRow(selected_row, addToSelected=False)
            self.SetGridCursor(event.Row, 0)
        popupitems = ['Insert Rows\tCtrl-I', 'Delete Rows\tCtrl-D',
                      'Comment Rows\tCtrl-3', 'Uncomment Rows\tCtrl-4',
                      'Move Rows Up\tAlt-Up', 'Move Rows Down\tAlt-Down']
        PopupMenu(self, PopupMenuItems(self, popupitems))
        event.Skip()

    def _col_label_right_click(self, event):
        pass

    def OnLabelLeftClick(self, event):
        if event.Col == -1:
            self._row_label_left_click(event)
        else:
            self._col_label_left_click(event)

    def _row_label_left_click(self, event):
        if event.ShiftDown() or event.ControlDown():
            self.ClearSelection()
            cursor_row = self.GetGridCursorRow()
            event_row = event.Row
            start, end = (cursor_row, event_row) if cursor_row < event_row else (event_row, cursor_row)
            for row in range(start, end+1):
                self.SelectRow(row, addToSelected=True)
        else:
            self.SelectRow(event.Row, addToSelected=False)
            self.SetGridCursor(event.Row, 0)

    def _col_label_left_click(self, event):
        pass

    def OnInsertRows(self, event):
        self._execute(AddRows(self.selection.rows()))
        self.ClearSelection()
        self._skip_except_on_mac(event)

    def _skip_except_on_mac(self, event):
        if event is not None and not IS_MAC:
            event.Skip()

    def OnInsertCells(self, event=None):
        self._execute(InsertCells(self.selection.topleft,
                                  self.selection.bottomright))
        self._skip_except_on_mac(event)

    def OnDeleteCells(self, event=None):
        self._execute(DeleteCells(self.selection.topleft,
                                  self.selection.bottomright))
        self._skip_except_on_mac(event)

    @requires_focus
    def OnCommentRows(self, event=None):
        self._execute(CommentRows(self.selection.rows()))
        self._skip_except_on_mac(event)

    @requires_focus
    def OnUncommentRows(self, event=None):
        self._execute(UncommentRows(self.selection.rows()))
        self._skip_except_on_mac(event)

    def OnMoveRowsUp(self, event=None):
        self._row_move(MoveRowsUp, -1)

    def OnMoveRowsDown(self, event=None):
        self._row_move(MoveRowsDown, 1)

    def _row_move(self, command, change):
        rows = self.selection.rows()
        if self._execute(command(rows)):
            wx.CallAfter(self._select_rows, [r+change for r in rows])

    def _select_rows(self, rows):
        self.ClearSelection()
        for r in rows:
            self.SelectRow(r, True)

    def OnMotion(self, event):
        pass

    def _data_changed(self, data):
        if self._controller == data.item:
            self._write_steps(data.item)

    def _write_steps(self, controller):
        data = []
        self._write_headers(controller)
        for step in controller.steps:
            data.append(self._format_comments(step.as_list()))
        self.ClearGrid()
        self._write_data(data, update_history=False)
        self._colorize_grid()

    def _write_headers(self, controller):
        headers = controller.data.parent.header[1:]
        if not headers:
            self.SetColLabelSize(0)
            return
        self.SetColLabelSize(25)
        for col, header in enumerate(headers):
            self.SetColLabelValue(col, header)
        for empty_col in range(col+1, self.NumberCols+1):
            self.SetColLabelValue(empty_col, '')

    def _colorize_grid(self):
        selection_content = self._get_single_selection_content_or_none_on_first_call()
        if selection_content is None:
            self.highlight(None)
        else:
            self._parent.highlight(selection_content, expand=False)

    def highlight(self, text, expand=True):
        self._colorizer.colorize(text)

    def _get_single_selection_content_or_none_on_first_call(self):
        if self._cell_selected:
            return self.get_single_selection_content()

    def _format_comments(self, data):
        # TODO: This should be moved to robot.model
        in_comment = False
        ret = []
        for cell in data:
            if cell.strip().startswith('#'):
                in_comment = True
            if in_comment:
                cell = cell.replace(' |', '')
            ret.append(cell)
        return ret

    def cell_value_edited(self, row, col, value):
        self._execute(ChangeCellValue(row, col, value))

    def get_selected_datafile_controller(self):
        return self._controller.datafile_controller

    @requires_focus
    def OnCopy(self, event=None):
        self.copy()

    @requires_focus
    def OnCut(self, event=None):
        self._clipboard_handler.cut()
        self.OnDelete(event)

    def OnDelete(self, event=None):
        if self.IsCellEditControlShown():
            # On Windows, Delete key does not work in TextCtrl automatically
            self.delete()
        elif self.has_focus():
            self._execute(ClearArea(self.selection.topleft,
                                    self.selection.bottomright))

    @requires_focus
    def OnPaste(self, event=None):
        self._execute_clipboard_command(PasteArea)

    def _execute_clipboard_command(self, command_class):
        if not self.IsCellEditControlShown():
            data = self._clipboard_handler.clipboard_content()
            if data:
                data = [[data]] if isinstance(data, basestring) else data
                self._execute(command_class(self.selection.topleft, data))

    @requires_focus
    def OnInsert(self, event=None):
        self._execute_clipboard_command(InsertArea)

    def OnDeleteRows(self, event):
        self._execute(DeleteRows(self.selection.rows()))
        self.ClearSelection()
        self._skip_except_on_mac(event)

    @requires_focus
    def OnUndo(self, event=None):
        if not self.IsCellEditControlShown():
            self._execute(Undo())
        else:
            self.GetCellEditor(*self.selection.cell).Reset()

    @requires_focus
    def OnRedo(self, event=None):
        self._execute(Redo())

    def close(self):
        self._colorizer.close()
        self.save()
        PUBLISHER.unsubscribe(self._data_changed, RideItemStepsChanged)
        if self._namespace_updated:
            #Prevent re-entry to unregister method
            self._controller.datafile_controller.unregister_namespace_updates(self._namespace_updated)
        self._namespace_updated = None

    def save(self):
        self._tooltips.hide()
        if self.IsCellEditControlShown():
            cell_editor = self.GetCellEditor(*self.selection.cell)
            cell_editor.EndEdit(self.selection.topleft.row,
                                self.selection.topleft.col, self)

    def show_content_assist(self):
        if self.IsCellEditControlShown():
            self.GetCellEditor(*self.selection.cell).show_content_assist(self.selection.topleft.row)

    def refresh_datafile(self, item, event):
        self._tree.refresh_datafile(item, event)

    def _calculate_position(self):
        x, y = wx.GetMousePosition()
        return x, y + 20

    def OnEditor(self, event):
        self._tooltips.hide()
        row_height = self.GetRowSize(self.selection.topleft.row)
        self.GetCellEditor(*self.selection.cell).SetHeight(row_height)
        event.Skip()

    def _move_cursor_down(self, event):
        self.DisableCellEditControl()
        self.MoveCursorDown(event.ShiftDown())

    def OnKeyDown(self, event):
        keycode, control_down = event.GetKeyCode(), event.CmdDown()
        if keycode == wx.WXK_CONTROL:
            self._show_cell_information()
        elif keycode == ord('A') and control_down:
            self.OnSelectAll(event)
        elif event.AltDown() and keycode in [wx.WXK_DOWN, wx.WXK_UP]:
            self._move_rows(keycode)
        elif event.AltDown() and keycode == wx.WXK_RETURN:
            self._move_cursor_down(event)
        elif keycode == wx.WXK_WINDOWS_MENU:
            self.OnCellRightClick(event)
        elif keycode in [wx.WXK_RETURN, wx.WXK_BACK]:
            self._move_grid_cursor(event, keycode)
        elif control_down and keycode == wx.WXK_SPACE:
            self._open_cell_editor_with_content_assist()
        elif control_down and not event.AltDown() and keycode in (ord('1'), ord('2')):
            self._open_cell_editor_and_execute_variable_creator(list_variable=(keycode==ord('2')))
        elif control_down and event.ShiftDown() and keycode == ord('I'):
            self.OnInsertCells()
        elif control_down and event.ShiftDown() and keycode == ord('D'):
            self.OnDeleteCells()
        elif control_down and keycode == ord('B'):
            self._navigate_to_matching_user_keyword(self.GetGridCursorRow(), self.GetGridCursorCol())
        else:
            event.Skip()

    def OnGoToDefinition(self, event):
        self._navigate_to_matching_user_keyword(self.GetGridCursorRow(), self.GetGridCursorCol())

    def _show_cell_information(self):
        cell = self.cell_under_cursor
        value = self._cell_value(cell)
        if value:
            self._show_user_keyword_link(cell, value)
            self._show_keyword_details(cell, value)

    def _cell_value(self, cell):
        if cell == self._no_cell:
            return None
        return self.GetCellValue(cell.Row, cell.Col)

    def _show_user_keyword_link(self, cell, value):
        if cell != self._marked_cell and self._plugin.get_user_keyword(value):
            self._toggle_underlined(cell)
            self._marked_cell = cell

    def _show_keyword_details(self, cell, value):
        details = self._plugin.get_keyword_details(value)
        if not details:
            info = self._controller.get_cell_info(cell.Row, cell.Col)
            if info.cell_type == CellType.KEYWORD and info.content_type == ContentType.STRING:
                details = """\
        <b>Keyword was not detected by RIDE</b>
        <br>Possible corrections:<br>
        <ul>
            <li>Import library or resource file containing the keyword.</li>
            <li>For library import errors: Consider importing library spec XML
            (Tools / Import Library Spec XML or by adding the XML file with the
            correct name to PYTHONPATH) to enable keyword completion
            for example for Java libraries.
            Library spec XML can be created using libdoc tool from Robot Framework.</li>
        </ul>"""
        if details:
            self._tooltips.show_info_at(details, value,
                                    self._cell_to_screen_coordinates(cell))

    def _cell_to_screen_coordinates(self, cell):
        point = self.CellToRect(cell.Row, cell.Col).GetTopRight()
        point.x += self.GetRowLabelSize() + 5
        return self.ClientToScreen(self.CalcScrolledPosition(point))

    def _move_rows(self, keycode):
        if keycode == wx.WXK_UP:
            self.OnMoveRowsUp()
        else:
            self.OnMoveRowsDown()

    def _move_grid_cursor(self, event, keycode):
        self.DisableCellEditControl()
        if keycode == wx.WXK_RETURN:
            self.MoveCursorRight(event.ShiftDown())
        else:
            self.MoveCursorLeft(event.ShiftDown())

    def OnKeyUp(self, event):
        self._tooltips.hide()
        self._hide_link_if_necessary()
        event.Skip()

    def _open_cell_editor_with_content_assist(self):
        if not self.IsCellEditControlEnabled():
            self.EnableCellEditControl()
        row = self.GetGridCursorRow()
        celleditor = self.GetCellEditor(self.GetGridCursorCol(), row)
        celleditor.Show(True)
        wx.CallAfter(celleditor.show_content_assist)

    def _open_cell_editor_and_execute_variable_creator(self, list_variable=False):
        if not self.IsCellEditControlEnabled():
            self.EnableCellEditControl()
        row = self.GetGridCursorRow()
        celleditor = self.GetCellEditor(self.GetGridCursorCol(), row)
        celleditor.Show(True)
        wx.CallAfter(celleditor.execute_variable_creator, list_variable)

    def OnMakeVariable(self, event):
        self._open_cell_editor_and_execute_variable_creator(list_variable=False)

    def OnMakeListVariable(self, event):
        self._open_cell_editor_and_execute_variable_creator(list_variable=True)

    def OnCellRightClick(self, event):
        self._tooltips.hide()
        self._popup_menu_shown = True
        GridEditor.OnCellRightClick(self, event)
        self._popup_menu_shown = False

    def OnSelectAll(self, event):
        self.SelectAll()

    def OnCellLeftClick(self, event):
        self._tooltips.hide()
        if event.ControlDown() or event.CmdDown():
            if self._navigate_to_matching_user_keyword(event.Row, event.Col):
                return
        if not self._has_been_clicked:
            self.SetGridCursor(event.Row, event.Col)
            self._has_been_clicked = True
        else:
            event.Skip()

    def OnCellLeftDClick(self, event):
        self._tooltips.hide()
        if not self._navigate_to_matching_user_keyword(event.Row, event.Col):
            event.Skip()

    def _navigate_to_matching_user_keyword(self, row, col):
        value = self.GetCellValue(row, col)
        uk = self._plugin.get_user_keyword(value)
        if uk:
            self._toggle_underlined((grid.GridCellCoords(row, col)))
            self._marked_cell = None
            wx.CallAfter(self._tree.select_user_keyword_node, uk)
            return True
        return False

    def _is_active_window(self):
        return self.IsShownOnScreen() and self.FindFocus()

    def _hide_link_if_necessary(self):
        if not self._marked_cell:
            return
        self._toggle_underlined(self._marked_cell)
        self._marked_cell = None

    def OnCreateKeyword(self, event):
        cells = self._data_cells_from_current_row()
        if not cells:
            return
        try:
            self._execute(AddKeywordFromCells(cells))
        except ValueError, err:
            wx.MessageBox(unicode(err))

    def _data_cells_from_current_row(self):
        currow, curcol = self.selection.cell
        rowdata = self._row_data(currow)[curcol:]
        return self._strip_trailing_empty_cells(self._remove_comments(rowdata))

    def _remove_comments(self, data):
        for index, cell in enumerate(data):
            if cell.strip().startswith('#'):
                return data[:index]
        return data

    def OnExtractKeyword(self, event):
        dlg = UserKeywordNameDialog(self._controller)
        if dlg.ShowModal() == wx.ID_OK:
            name, args = dlg.get_value()
            rows = self.selection.topleft.row, self.selection.bottomright.row
            self._execute(ExtractKeyword(name, args, rows))

    def OnExtractVariable(self, event):
        cells = self.selection.cells()
        if len(cells) == 1:
            self._extract_scalar(cells[0])
        elif min(row for row, _ in cells) == max(row for row, _ in cells):
            self._extract_list(cells)

    def OnFindWhereUsed(self, event):
        is_variable, searchstring = self._get_is_variable_and_searchstring()
        if searchstring:
            self._execute_find_where_used(is_variable, searchstring)

    def _get_is_variable_and_searchstring(self):
        cellvalue = self.GetCellValue(*self.selection.cells()[0])
        if self._cell_value_contains_multiple_search_items(cellvalue):
            choice_dialog = ChooseUsageSearchStringDialog(cellvalue)
            choice_dialog.ShowModal()
            is_var, value = choice_dialog.GetStringSelection()
            choice_dialog.Destroy()
            return is_var, value
        else:
            return utils.is_variable(cellvalue), cellvalue

    def _execute_find_where_used(self, is_variable, searchstring):
        usages_dialog_class = VariableUsages if is_variable else Usages
        usages_dialog_class(self._controller, self._tree.highlight, searchstring).show()

    def _cell_value_contains_multiple_search_items(self, value):
        variables = utils.find_variable_basenames(value)
        return variables and variables[0] != value

    def _extract_scalar(self, cell):
        var = Variable('', self.GetCellValue(*cell), '')
        dlg = ScalarVariableDialog(self._controller.datafile_controller.variables, var)
        if dlg.ShowModal() == wx.ID_OK:
            name, value = dlg.get_value()
            comment = dlg.get_comment()
            self._execute(ExtractScalar(name, value, comment, cell))

    def _extract_list(self, cells):
        var = Variable('', [self.GetCellValue(*cell) for cell in cells], '')
        dlg = ListVariableDialog(self._controller.datafile_controller.variables,
                                 var, self._plugin)
        if dlg.ShowModal() == wx.ID_OK:
            name, value = dlg.get_value()
            comment = dlg.get_comment()
            self._execute(ExtractList(name, value, comment, cells))

    def OnRenameKeyword(self, event):
        old_name = self._current_cell_value()
        if not old_name.strip() or is_variable(old_name):
            return
        new_name = wx.GetTextFromUser('New name', 'Rename Keyword',
                                      default_value=old_name)
        if new_name:
            self._execute(RenameKeywordOccurrences(old_name, new_name,
                                                   RenameProgressObserver(self.GetParent())))


class ContentAssistCellEditor(grid.PyGridCellEditor):

    def __init__(self, plugin, controller):
        grid.PyGridCellEditor.__init__(self)
        self._plugin = plugin
        self._controller = controller
        self._grid = None

    def show_content_assist(self, args=None):
        self._tc.show_content_assist()

    def execute_variable_creator(self, list_variable=False):
        self._tc.execute_variable_creator(list_variable)

    def Create(self, parent, id, evthandler):
        self._tc = ExpandingContentAssistTextCtrl(parent, self._plugin, self._controller)
        self.SetControl(self._tc)
        if evthandler:
            self._tc.PushEventHandler(evthandler)

    def SetSize(self, rect):
        self._tc.SetDimensions(rect.x, rect.y, rect.width + 2, rect.height + 2,
                               wx.SIZE_ALLOW_MINUS_ONE)

    def SetHeight(self, height):
        self._height = height

    def BeginEdit(self, row, col, grid):
        self._tc.SetSize((-1, self._height))
        self._tc.set_row(row)
        self._original_value = grid.GetCellValue(row, col)
        self._grid = grid
        self.StartingClick()

    def EndEdit(self, row, col, grid, *ignored):
        value = self._get_value()
        if value != self._original_value:
            grid.cell_value_edited(row, col, value)
        self._tc.hide()
        grid.SetFocus()
        return True

    def _get_value(self):
        suggestion = self._tc.content_assist_value()
        return suggestion or self._tc.GetValue()

    def Reset(self):
        self._tc.SetValue(self._original_value)
        self._tc.reset()

    def StartingKey(self, event):
        key = event.GetKeyCode()
        if key is wx.WXK_DELETE or key > 255:
            self._grid.HideCellEditControl()
            return
        self._tc.SetValue(unichr(key))
        self._tc.SetFocus()
        self._tc.SetInsertionPointEnd()

    def StartingClick(self):
        self._tc.SetValue(self._original_value)
        self._tc.SelectAll()
        self._tc.SetFocus()

    def Clone(self):
        return ContentAssistCellEditor()


class ChooseUsageSearchStringDialog(wx.Dialog):

    def __init__(self, cellvalue):
        wx.Dialog.__init__(self, None, wx.ID_ANY, "Find Where Used", style=wx.DEFAULT_DIALOG_STYLE)
        self.caption = "Please select what you want to check for usage"
        variables = utils.find_variable_basenames(cellvalue)
        self.choices = [(False, cellvalue)] + [(True, v) for v in variables]
        self.choices_string = ["Complete cell content"] + ["Variable " + var for var in variables]
        self._build_ui()

    def _build_ui(self):
        self.radiobox_choices = wx.RadioBox(self, choices=self.choices_string,
                                            style=wx.RA_SPECIFY_COLS, majorDimension=1)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(wx.StaticText(self, label=self.caption), 0, wx.ALL|wx.EXPAND, 5)
        sizer.Add(self.radiobox_choices, 0, wx.ALL|wx.EXPAND, 5)
        sizer.Add(wx.Button(self, wx.ID_OK, label="Search"), 0, wx.ALL|wx.ALIGN_CENTER, 5)
        big_sizer = wx.BoxSizer(wx.VERTICAL)
        big_sizer.Add(sizer, 0, wx.ALL, 10)
        self.SetSizer(big_sizer)
        self.Fit()
        self.CenterOnParent()

    def GetStringSelection(self):
        return self.choices[self.radiobox_choices.GetSelection()]

########NEW FILE########
__FILENAME__ = listeditor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx.lib.mixins.listctrl import ListCtrlAutoWidthMixin
from robotide.controller.commands import MoveUp, MoveDown, DeleteItem

from robotide.utils import RideEventHandler
from robotide.widgets import PopupMenu, PopupMenuItems, ButtonWithHandler, Font
from robotide.context.platform import ctrl_or_cmd, bind_keys_to_evt_menu, IS_WINDOWS


class ListEditorBase(wx.Panel):
    _menu = ['Edit', 'Move Up\tCtrl-Up', 'Move Down\tCtrl-Down', '---', 'Delete']
    _buttons = []

    def __init__(self, parent, columns, controller):
        wx.Panel.__init__(self, parent)
        self._controller = controller
        self._selection = wx.NOT_FOUND
        self._create_ui(columns, controller)
        self._make_bindings()
        self._bind_keys()

    def _create_ui(self, columns, data):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._list = self._create_list(columns, data)
        sizer.Add(self._list, 1, wx.EXPAND)
        sizer.Add((5,0))
        sizer.Add(self._create_buttons())
        sizer.Add((5,0))
        self.SetSizer(sizer)
        sizer.Layout()

    def _create_list(self, columns, data):
        return AutoWidthColumnList(self, columns, data)

    def _create_buttons(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        for label in self._buttons:
            sizer.Add(ButtonWithHandler(self, label, width=120), 0, wx.ALL, 1)
        return sizer

    def _make_bindings(self):
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected)
        self.Bind(wx.EVT_LIST_ITEM_DESELECTED , self.OnItemDeselected)
        self.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.OnEdit)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.OnRightClick)
        if IS_WINDOWS:
            self.Bind(wx.EVT_COMMAND_LEFT_CLICK, self.OnLeftClick)
        else:
            self._list.Bind(wx.EVT_LEFT_UP, self.OnLeftClick)

    def OnItemSelected(self, event):
        self._selection = event.GetIndex()

    def OnItemDeselected(self, event):
        self._selection = wx.NOT_FOUND

    def OnEdit(self, event):
        pass

    def OnRightClick(self, event):
        PopupMenu(self, PopupMenuItems(self, self._menu))

    def OnLeftClick(self, event):
        pass

    def _bind_keys(self):
        bind_keys_to_evt_menu(self, self._get_bind_keys())

    def _get_bind_keys(self):
        return [(ctrl_or_cmd(), wx.WXK_UP, self.OnMoveUp),
                (ctrl_or_cmd(), wx.WXK_DOWN, self.OnMoveDown),
                (wx.ACCEL_NORMAL, wx.WXK_WINDOWS_MENU, self.OnRightClick),
                (wx.ACCEL_NORMAL, wx.WXK_DELETE, self.OnDelete)]

    def OnMoveUp(self, event):
        if self._selection < 1:
            return
        self._controller.execute(MoveUp(self._selection))
        self.update_data()
        self._list.Select(self._selection-1, True)

    def OnMoveDown(self, event):
        if self._selection == self._list.GetItemCount() - 1 or not self.is_selected:
            return
        self._controller.execute(MoveDown(self._selection))
        self.update_data()
        self._list.Select(self._selection+1, True)

    def OnDelete(self, event):
        if self.is_selected:
            self._with_column_width_preservation(self._delete_selected)

    def _with_column_width_preservation(self, func):
        widths = []
        for i in range(self._list.GetColumnCount()):
            widths.append(self._list.GetColumnWidth(i))
        func()
        for i in range(self._list.GetColumnCount()):
            self._list.SetColumnWidth(i, widths[i])

    def _delete_selected(self):
        self._controller.execute(DeleteItem(self._selection))
        self._calculate_selection()
        self.update_data()

    def _calculate_selection(self):
        self._selection = min(self._selection,
                              sum(1 for _ in self._controller)-1)

    @property
    def is_selected(self):
        return self._selection != wx.NOT_FOUND

    def update_data(self):
        self._list.DeleteAllItems()
        self._list.insert_data(self._controller)
        self._list.select_and_ensure_visibility(self._selection)

    def select(self, text):
        self._list.select(text)

    def has_link_target(self, controller):
        return False

    def has_error(self, controller):
        return False


class ListEditor(ListEditorBase, RideEventHandler): pass


class AutoWidthColumnList(wx.ListCtrl, ListCtrlAutoWidthMixin):

    def __init__(self, parent, columns, data=None):
        wx.ListCtrl.__init__(self, parent,
                             style=wx.LC_REPORT|wx.NO_BORDER|wx.LC_SINGLE_SEL|wx.LC_HRULES)
        ListCtrlAutoWidthMixin.__init__(self)
        self._parent = parent
        self.populate(columns, data or [])

    def populate(self, columns, data):
        for i, name in enumerate(columns):
            self.InsertColumn(i, name)
        self.insert_data(data)

    def insert_data(self, data):
        self._insert_data(data)
        self._set_column_widths()

    def _insert_data(self, data):
        for row, item in enumerate(data):
            rowdata = self._parent.get_column_values(item)
            self.InsertStringItem(row, rowdata[0])
            for i in range(1, len(rowdata)):
                data = rowdata[i] is not None and rowdata[i] or ''
                self.SetStringItem(row, i, data)
            self._add_style(row, item)

    def _set_column_widths(self):
        min_width = self._parent.Parent.plugin.global_settings['list col min width']
        max_width = self._parent.Parent.plugin.global_settings['list col max width']
        for i in range(self.ColumnCount):
            self.SetColumnWidth(i, -1)
            if self.GetColumnWidth(i) < min_width:
                self.SetColumnWidth(i, min_width)
            if self.GetColumnWidth(i) > max_width:
                self.SetColumnWidth(i, max_width)

    def _add_style(self, row, item):
        if self._parent.has_link_target(item):
            self._add_link_style(row)
        if self._parent.has_error(item):
            self._add_error_style(row)

    def _add_link_style(self, row):
        self._set_row_style(row, font=self._underlined_font(), colour=wx.BLUE)

    def _add_error_style(self, row):
        self._set_row_style(row, colour=wx.RED)

    def _set_row_style(self, row, font=None, colour=None):
        list_item = self.GetItem(row)
        if font:
            list_item.SetFont(font)
        if colour:
            list_item.SetTextColour(colour)
        self.SetItem(list_item)

    def _underlined_font(self):
        font = Font().underlined
        if IS_WINDOWS:
            font.SetPointSize(8)
        return font

    def select(self, text):
        index = self.FindItem(0, text)
        self.select_and_ensure_visibility(index)

    def select_and_ensure_visibility(self, index):
        if index >= 0:
            self.Select(index, on=True)
            self.EnsureVisible(index)
            self.Focus(index)


########NEW FILE########
__FILENAME__ = macroeditors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import wx

from robotide.usages.UsageRunner import Usages
from robotide.publish.messages import RideItemNameChanged

from .kweditor import KeywordEditor
from .editors import _RobotTableEditor, FindUsagesHeader


class TestCaseEditor(_RobotTableEditor):
    _settings_open_id = 'test case settings open'

    def _populate(self):
        self.header = self._create_header(self.controller.name)
        self.sizer.Add(self.header, 0, wx.EXPAND|wx.ALL, 5)
        self._add_settings()
        self.sizer.Add((0,10))
        self._create_kweditor()
        self.plugin.subscribe(self._name_changed, RideItemNameChanged)

    def _create_kweditor(self):
        self.kweditor = KeywordEditor(self, self.controller, self._tree)
        self.sizer.Add(self.kweditor, 1, wx.EXPAND|wx.ALL, 2)
        self._editors.append(self.kweditor)

    def _name_changed(self, data):
        if data.item == self.controller:
            self.header.SetLabel(data.item.name)

    def close(self):
        for editor in self._editors:
            editor.close()
        _RobotTableEditor.close(self)
        self.kweditor.close()
        self.plugin.unsubscribe(self._name_changed, RideItemNameChanged)

    def save(self):
        self.kweditor.save()

    def undo(self):
        self.kweditor.OnUndo()

    def redo(self):
        self.kweditor.OnRedo()

    def cut(self):
        self.kweditor.OnCut()

    def copy(self):
        self.kweditor.OnCopy()

    def paste(self):
        self.kweditor.OnPaste()

    def insert(self):
        self.kweditor.OnInsert()

    def insert_cells(self):
        self.kweditor.OnInsertCells()

    def delete_cells(self):
        self.kweditor.OnDeleteCells()

    def insert_rows(self):
        self.kweditor.OnInsertRows()

    def delete_rows(self):
        self.kweditor.OnDeleteRows()

    def delete(self):
        self.kweditor.OnDelete()

    def comment(self):
        self.kweditor.OnCommentRows()

    def uncomment(self):
        self.kweditor.OnUncommentRows()

    def show_content_assist(self):
        self.kweditor.show_content_assist()

    def view(self):
        _RobotTableEditor.view(self)
        self.kweditor.SetFocus()


class UserKeywordEditor(TestCaseEditor):
    _settings_open_id = 'user keyword settings open'

    def _create_header(self, name):
        def cb(event):
            Usages(self.controller, self._tree.highlight).show()
        return FindUsagesHeader(self, name, cb)

########NEW FILE########
__FILENAME__ = popupwindow
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

from robotide.context import POPUP_BACKGROUND, IS_WINDOWS
from robotide import utils
from robotide.widgets import Dialog, VerticalSizer, HtmlWindow


class _PopupWindowBase(object):

    def __init__(self, size, detachable=True, autohide=False):
        self.panel = self._create_ui(size)
        if autohide:
            self._set_auto_hiding()
        if detachable:
            self._set_detachable()
        self.SetSize(size)

    def _create_ui(self, size):
        panel = wx.Panel(self)
        panel.SetBackgroundColour(POPUP_BACKGROUND)
        szr = VerticalSizer()
        self._details = HtmlWindow(self, size=size)
        szr.add_expanding(self._details)
        panel.SetSizer(szr)
        panel.Fit()
        return panel

    def _set_detachable(self):
        self._details.Bind(wx.EVT_LEFT_UP, self._detach)

    def _detach(self, event):
        self.hide()
        dlg = HtmlDialog(self._detached_title, self._current_details)
        dlg.SetPosition((wx.GetMouseState().x, wx.GetMouseState().y))
        dlg.Show()
        if IS_WINDOWS:
            event.Skip()

    def show_at(self, position):
        if not self.IsShown():
            self.SetPosition(position)
            self.Show()

    def hide(self, event=None):
        self.Show(False)

    @property
    def screen_position(self):
        return self.ScreenPosition

    @property
    def size(self):
        return self.Size

    def set_content(self, content, title=None):
        color = ''.join(hex(item)[2:] for item in POPUP_BACKGROUND)
        self._current_details = '<body bgcolor=#%s>%s</body>' % (color, content)
        self._details.SetPage(self._current_details)
        self._detached_title = title


class RidePopupWindow(wx.PopupWindow, _PopupWindowBase):

    def __init__(self, parent, size):
        wx.PopupWindow.__init__(self, parent)
        self.SetSize(size)

    def _set_auto_hiding(self):
        # EVT_LEAVE is triggered on different components on different OSes.
        component_to_hide = self.panel if IS_WINDOWS else self
        component_to_hide.Bind(wx.EVT_LEAVE_WINDOW, self.hide)


class HtmlPopupWindow(RidePopupWindow):

    def __init__(self, parent, size, detachable=True, autohide=False):
        RidePopupWindow.__init__(self, parent, size)
        _PopupWindowBase.__init__(self, size, detachable, autohide)


class MacRidePopupWindow(wx.Frame, _PopupWindowBase):

    def __init__(self, parent, size, detachable=True, autohide=False):
        wx.Frame.__init__(self, parent, style=wx.SIMPLE_BORDER)
        _PopupWindowBase.__init__(self, size, detachable, autohide)
        self.hide()

    def _set_auto_hiding(self):
        self._details.Bind(wx.EVT_MOTION, lambda evt: self.hide())

    def OnKey(self, *params):
        pass


class HtmlDialog(Dialog):

    def __init__(self, title, content):
        Dialog.__init__(self, title)
        szr = VerticalSizer()
        szr.add_expanding(HtmlWindow(self, text=content, size=self.Size))
        self.SetSizer(szr)

    def OnKey(self, event):
        pass


if wx.PlatformInfo[0] == '__WXMAC__':
    RidePopupWindow = HtmlPopupWindow = MacRidePopupWindow
del MacRidePopupWindow

########NEW FILE########
__FILENAME__ = robotframeworklexer
#  Copyright 2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re

from pygments.lexer import Lexer
from pygments.token import Token


HEADING = Token.Generic.Heading
SETTING = Token.Keyword.Namespace
IMPORT = Token.Name.Namespace
TC_KW_NAME = Token.Generic.Subheading
KEYWORD = Token.Name.Function
ARGUMENT = Token.String
VARIABLE = Token.Name.Variable
COMMENT = Token.Comment
SEPARATOR = Token.Punctuation
SYNTAX = Token.Punctuation
GHERKIN = Token.Generic.Emph
ERROR = Token.Error


def normalize(string, remove=''):
    string = string.lower()
    for char in remove + ' ':
        if char in string:
            string = string.replace(char, '')
    return string


class RobotFrameworkLexer(Lexer):
    """
    For `Robot Framework <http://robotframework.org>`_ test data.

    Supports both space and pipe separated plain text formats.
    """
    name = 'RobotFramework'
    aliases = ['RobotFramework', 'robotframework']
    filenames = ['*.txt']
    mimetypes = ['text/x-robotframework']

    def __init__(self):
        Lexer.__init__(self, tabsize=2, encoding='UTF-8')

    def get_tokens_unprocessed(self, text):
        row_tokenizer = RowTokenizer()
        var_tokenizer = VariableTokenizer()
        index = 0
        for row in text.splitlines():
            for value, token in row_tokenizer.tokenize(row):
                for value, token in var_tokenizer.tokenize(value, token):
                    if value:
                        yield index, token, unicode(value)
                        index += len(value)


class VariableTokenizer(object):

    def tokenize(self, string, token):
        var = VariableSplitter(string, identifiers='$@%')
        if var.start < 0 or token in (COMMENT, ERROR):
            yield string, token
            return
        for value, token in self._tokenize(var, string, token):
            if value:
                yield value, token

    def _tokenize(self, var, string, orig_token):
        before = string[:var.start]
        yield before, orig_token
        yield var.identifier + '{', SYNTAX
        for value, token in self.tokenize(var.base, VARIABLE):
            yield value, token
        yield '}', SYNTAX
        if var.index:
            yield '[', SYNTAX
            for value, token in self.tokenize(var.index, VARIABLE):
                yield value, token
            yield ']', SYNTAX
        for value, token in self.tokenize(string[var.end:], orig_token):
            yield value, token


class RowTokenizer(object):

    def __init__(self):
        self._table = UnknownTable()
        self._splitter = RowSplitter()
        testcases = TestCaseTable()
        settings = SettingTable(testcases.set_default_template)
        variables = VariableTable()
        keywords = KeywordTable()
        self._tables = {'settings': settings, 'setting': settings,
                        'metadata': settings,
                        'variables': variables, 'variable': variables,
                        'testcases': testcases, 'testcase': testcases,
                        'keywords': keywords, 'keyword': keywords,
                        'userkeywords': keywords, 'userkeyword': keywords}

    def tokenize(self, row):
        commented = False
        heading = False
        for index, value in enumerate(self._splitter.split(row)):
            # First value, and every second after that, is a separator.
            index, separator = divmod(index-1, 2)
            if value.startswith('#'):
                commented = True
            elif index == 0 and value.startswith('*'):
                self._table = self._start_table(value)
                heading = True
            for value, token in self._tokenize(value, index, commented,
                                               separator, heading):
                yield value, token
        self._table.end_row()

    def _start_table(self, header):
        name = normalize(header, remove='*')
        return self._tables.get(name, UnknownTable())

    def _tokenize(self, value, index, commented, separator, heading):
        if commented:
            yield value, COMMENT
        elif separator:
            yield value, SEPARATOR
        elif heading:
            yield value, HEADING
        else:
            for value, token in self._table.tokenize(value, index):
                yield value, token


class RowSplitter(object):
    _space_splitter = re.compile('( {2,})')
    _pipe_splitter = re.compile('((?:^| +)\|(?: +|$))')

    def split(self, row):
        splitter = self._split_from_spaces \
            if not row.startswith('| ') else self._split_from_pipes
        for value in splitter(row):
            yield value
        yield '\n'

    def _split_from_spaces(self, row):
        yield ''  # Start with (pseudo)separator similarly as with pipes
        for value in self._space_splitter.split(row):
            yield value

    def _split_from_pipes(self, row):
        _, separator, rest = self._pipe_splitter.split(row, 1)
        yield separator
        while self._pipe_splitter.search(rest):
            cell, separator, rest = self._pipe_splitter.split(rest, 1)
            yield cell
            yield separator
        yield rest


class Tokenizer(object):
    _tokens = None

    def __init__(self):
        self._index = 0

    def tokenize(self, value):
        values_and_tokens = self._tokenize(value, self._index)
        self._index += 1
        if isinstance(values_and_tokens, type(Token)):
            values_and_tokens = [(value, values_and_tokens)]
        return values_and_tokens

    def _tokenize(self, value, index):
        index = min(index, len(self._tokens) - 1)
        return self._tokens[index]

    def _is_assign(self, value):
        if value.endswith('='):
            value = value[:-1].strip()
        var = VariableSplitter(value, identifiers='$@')
        return var.start == 0 and var.end == len(value)


class Comment(Tokenizer):
    _tokens = (COMMENT,)


class Setting(Tokenizer):
    _tokens = (SETTING, ARGUMENT)
    _keyword_settings = ('suitesetup', 'suiteprecondition', 'suiteteardown',
                         'suitepostcondition', 'testsetup', 'testprecondition',
                         'testteardown', 'testpostcondition', 'testtemplate')
    _import_settings = ('library', 'resource', 'variables')
    _other_settings = ('documentation', 'metadata', 'forcetags', 'defaulttags',
                       'testtimeout')
    _custom_tokenizer = None

    def __init__(self, template_setter=None):
        Tokenizer.__init__(self)
        self._template_setter = template_setter

    def _tokenize(self, value, index):
        if index == 1 and self._template_setter:
            self._template_setter(value)
        if index == 0:
            normalized = normalize(value)
            if normalized in self._keyword_settings:
                self._custom_tokenizer = KeywordCall(support_assign=False)
            elif normalized in self._import_settings:
                self._custom_tokenizer = ImportSetting()
            elif normalized not in self._other_settings:
                return ERROR
        elif self._custom_tokenizer:
            return self._custom_tokenizer.tokenize(value)
        return Tokenizer._tokenize(self, value, index)


class ImportSetting(Tokenizer):
    _tokens = (IMPORT, ARGUMENT)


class TestCaseSetting(Setting):
    _keyword_settings = ('setup', 'precondition', 'teardown', 'postcondition',
                         'template')
    _import_settings = ()
    _other_settings = ('documentation', 'tags', 'timeout')

    def _tokenize(self, value, index):
        if index == 0:
            type = Setting._tokenize(self, value[1:-1], index)
            return [('[', SYNTAX), (value[1:-1], type), (']', SYNTAX)]
        return Setting._tokenize(self, value, index)


class KeywordSetting(TestCaseSetting):
    _keyword_settings = ('teardown',)
    _other_settings = ('documentation', 'arguments', 'return', 'timeout')


class Variable(Tokenizer):
    _tokens = (SYNTAX, ARGUMENT)

    def _tokenize(self, value, index):
        if index == 0 and not self._is_assign(value):
            return ERROR
        return Tokenizer._tokenize(self, value, index)


class KeywordCall(Tokenizer):
    _tokens = (KEYWORD, ARGUMENT)

    def __init__(self, support_assign=True):
        Tokenizer.__init__(self)
        self._keyword_found = not support_assign
        self._assigns = 0

    def _tokenize(self, value, index):
        if not self._keyword_found and self._is_assign(value):
            self._assigns += 1
            return SYNTAX  # VariableTokenizer tokenizes this later.
        if self._keyword_found:
            return Tokenizer._tokenize(self, value, index - self._assigns)
        self._keyword_found = True
        return GherkinTokenizer().tokenize(value, KEYWORD)


class GherkinTokenizer(object):
    _gherkin_prefix = re.compile('^(Given|When|Then|And) ', re.IGNORECASE)

    def tokenize(self, value, token):
        match = self._gherkin_prefix.match(value)
        if not match:
            return [(value, token)]
        end = match.end()
        return [(value[:end], GHERKIN), (value[end:], token)]


class TemplatedKeywordCall(Tokenizer):
    _tokens = (ARGUMENT,)


class ForLoop(Tokenizer):

    def __init__(self):
        Tokenizer.__init__(self)
        self._in_arguments = False

    def _tokenize(self, value, index):
        token = ARGUMENT if self._in_arguments else SYNTAX
        if value.upper() in ('IN', 'IN RANGE'):
            self._in_arguments = True
        return token


class _Table(object):
    _tokenizer_class = None

    def __init__(self, prev_tokenizer=None):
        self._tokenizer = self._tokenizer_class()
        self._prev_tokenizer = prev_tokenizer
        self._prev_values_on_row = []

    def tokenize(self, value, index):
        if self._continues(value, index):
            self._tokenizer = self._prev_tokenizer
            yield value, SYNTAX
        else:
            for value_and_token in self._tokenize(value, index):
                yield value_and_token
        self._prev_values_on_row.append(value)

    def _continues(self, value, index):
        return value == '...' and all(self._is_empty(t)
            for t in self._prev_values_on_row)

    def _is_empty(self, value):
        return value in ('', '\\')

    def _tokenize(self, value, index):
        return self._tokenizer.tokenize(value)

    def end_row(self):
        self.__init__(prev_tokenizer=self._tokenizer)


class UnknownTable(_Table):
    _tokenizer_class = Comment

    def _continues(self, value, index):
        return False


class VariableTable(_Table):
    _tokenizer_class = Variable


class SettingTable(_Table):
    _tokenizer_class = Setting

    def __init__(self, template_setter, prev_tokenizer=None):
        _Table.__init__(self, prev_tokenizer)
        self._template_setter = template_setter

    def _tokenize(self, value, index):
        if index == 0 and normalize(value) == 'testtemplate':
            self._tokenizer = Setting(self._template_setter)
        return _Table._tokenize(self, value, index)

    def end_row(self):
        self.__init__(self._template_setter, prev_tokenizer=self._tokenizer)


class TestCaseTable(_Table):
    _setting_class = TestCaseSetting
    _test_template = None
    _default_template = None

    @property
    def _tokenizer_class(self):
        if self._test_template or (self._default_template and
                                           self._test_template is not False):
            return TemplatedKeywordCall
        return KeywordCall

    def _continues(self, value, index):
        return index > 0 and _Table._continues(self, value, index)

    def _tokenize(self, value, index):
        if index == 0:
            if value:
                self._test_template = None
            return GherkinTokenizer().tokenize(value, TC_KW_NAME)
        if index == 1 and self._is_setting(value):
            if self._is_template(value):
                self._test_template = False
                self._tokenizer = self._setting_class(self.set_test_template)
            else:
                self._tokenizer = self._setting_class()
        if index == 1 and self._is_for_loop(value):
            self._tokenizer = ForLoop()
        if index == 1 and self._is_empty(value):
            return [(value, SYNTAX)]
        return _Table._tokenize(self, value, index)

    def _is_setting(self, value):
        return value.startswith('[') and value.endswith(']')

    def _is_template(self, value):
        return normalize(value) == '[template]'

    def _is_for_loop(self, value):
        return value.startswith(':') and normalize(value, remove=':') == 'for'

    def set_test_template(self, template):
        self._test_template = self._is_template_set(template)

    def set_default_template(self, template):
        self._default_template = self._is_template_set(template)

    def _is_template_set(self, template):
        return normalize(template) not in ('', '\\', 'none', '${empty}')


class KeywordTable(TestCaseTable):
    _tokenizer_class = KeywordCall
    _setting_class = KeywordSetting

    def _is_template(self, value):
        return False


# Following code copied directly from Robot Framework 2.7.5.

class VariableSplitter:

    def __init__(self, string, identifiers):
        self.identifier = None
        self.base = None
        self.index = None
        self.start = -1
        self.end = -1
        self._identifiers = identifiers
        self._may_have_internal_variables = False
        try:
            self._split(string)
        except ValueError:
            pass
        else:
            self._finalize()

    def get_replaced_base(self, variables):
        if self._may_have_internal_variables:
            return variables.replace_string(self.base)
        return self.base

    def _finalize(self):
        self.identifier = self._variable_chars[0]
        self.base = ''.join(self._variable_chars[2:-1])
        self.end = self.start + len(self._variable_chars)
        if self._has_list_variable_index():
            self.index = ''.join(self._list_variable_index_chars[1:-1])
            self.end += len(self._list_variable_index_chars)

    def _has_list_variable_index(self):
        return self._list_variable_index_chars \
            and self._list_variable_index_chars[-1] == ']'

    def _split(self, string):
        start_index, max_index = self._find_variable(string)
        self.start = start_index
        self._open_curly = 1
        self._state = self._variable_state
        self._variable_chars = [string[start_index], '{']
        self._list_variable_index_chars = []
        self._string = string
        start_index += 2
        for index, char in enumerate(string[start_index:]):
            index += start_index  # Giving start to enumerate only in Py 2.6+
            try:
                self._state(char, index)
            except StopIteration:
                return
            if index  == max_index and not self._scanning_list_variable_index():
                return

    def _scanning_list_variable_index(self):
        return self._state in [self._waiting_list_variable_index_state,
                               self._list_variable_index_state]

    def _find_variable(self, string):
        max_end_index = string.rfind('}')
        if max_end_index == -1:
            return ValueError('No variable end found')
        if self._is_escaped(string, max_end_index):
            return self._find_variable(string[:max_end_index])
        start_index = self._find_start_index(string, 1, max_end_index)
        if start_index == -1:
            return ValueError('No variable start found')
        return start_index, max_end_index

    def _find_start_index(self, string, start, end):
        index = string.find('{', start, end) - 1
        if index < 0:
            return -1
        if self._start_index_is_ok(string, index):
            return index
        return self._find_start_index(string, index+2, end)

    def _start_index_is_ok(self, string, index):
        return string[index] in self._identifiers \
            and not self._is_escaped(string, index)

    def _is_escaped(self, string, index):
        escaped = False
        while index > 0 and string[index-1] == '\\':
            index -= 1
            escaped = not escaped
        return escaped

    def _variable_state(self, char, index):
        self._variable_chars.append(char)
        if char == '}' and not self._is_escaped(self._string, index):
            self._open_curly -= 1
            if self._open_curly == 0:
                if not self._is_list_variable():
                    raise StopIteration
                self._state = self._waiting_list_variable_index_state
        elif char in self._identifiers:
            self._state = self._internal_variable_start_state

    def _is_list_variable(self):
        return self._variable_chars[0] == '@'

    def _internal_variable_start_state(self, char, index):
        self._state = self._variable_state
        if char == '{':
            self._variable_chars.append(char)
            self._open_curly += 1
            self._may_have_internal_variables = True
        else:
            self._variable_state(char, index)

    def _waiting_list_variable_index_state(self, char, index):
        if char != '[':
            raise StopIteration
        self._list_variable_index_chars.append(char)
        self._state = self._list_variable_index_state

    def _list_variable_index_state(self, char, index):
        self._list_variable_index_chars.append(char)
        if char == ']':
            raise StopIteration
########NEW FILE########
__FILENAME__ = settingeditors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

from robotide import context
from robotide.controller.commands import (UpdateVariable, UpdateDocumentation,
        SetValues, AddLibrary, AddResource, AddVariablesFileImport,
        ClearSetting)
from robotide.editor.listeditor import ListEditorBase
from robotide.publish.messages import RideImportSetting, RideOpenVariableDialog, RideExecuteSpecXmlImport, RideSaving
from robotide.utils import overrides
from robotide.widgets import ButtonWithHandler, Label, HtmlWindow, PopupMenu, PopupMenuItems
from robotide.publish import PUBLISHER
from robotide import utils

from .formatters import ListToStringFormatter
from .gridcolorizer import ColorizationSettings
from .editordialogs import (EditorDialog, DocumentationDialog, MetadataDialog,
        ScalarVariableDialog, ListVariableDialog, LibraryDialog,
        ResourceDialog, VariablesDialog)
from .listeditor import ListEditor
from .popupwindow import HtmlPopupWindow, HtmlDialog
from .tags import TagsDisplay


class SettingEditor(wx.Panel, utils.RideEventHandler):

    def __init__(self, parent, controller, plugin, tree):
        wx.Panel.__init__(self, parent)
        self._controller = controller
        self.plugin = plugin
        self._datafile = controller.datafile
        self._create_controls()
        self._tree = tree
        self._editing = False
        self.plugin.subscribe(self.update_value, RideImportSetting)

    def _create_controls(self):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add((5,0))
        sizer.Add(Label(self, label=self._controller.label,
                                size=(context.SETTING_LABEL_WIDTH,
                                      context.SETTING_ROW_HEIGTH)))
        self._value_display = self._create_value_display()
        self.update_value()
        self._tooltip = self._get_tooltip()
        sizer.Add(self._value_display, 1, wx.EXPAND)
        self._add_edit(sizer)
        sizer.Add(ButtonWithHandler(self, 'Clear'))
        sizer.Layout()
        self.SetSizer(sizer)

    def _add_edit(self, sizer):
        sizer.Add(ButtonWithHandler(self, 'Edit'), flag=wx.LEFT|wx.RIGHT, border=5)

    def _create_value_display(self):
        display = self._value_display_control()
        display.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow)
        display.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        display.Bind(wx.EVT_MOTION, self.OnDisplayMotion)
        return display

    def _value_display_control(self):
        ctrl = SettingValueDisplay(self)
        ctrl.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        ctrl.Bind(wx.EVT_KEY_DOWN, self.OnKey)
        return ctrl

    def _get_tooltip(self):
        return HtmlPopupWindow(self, (500, 350))

    def OnKey(self, event):
        self._tooltip.hide()
        event.Skip()

    def OnDisplayMotion(self, event):
        self._tooltip.hide()

    def refresh(self, controller):
        self._controller = controller
        self.update_value()

    def refresh_datafile(self, item, event):
        self._tree.refresh_datafile(item, event)

    def OnEdit(self, event=None):
        self._hide_tooltip()
        self._editing = True
        dlg = self._crete_editor_dialog()
        if dlg.ShowModal() == wx.ID_OK:
            self._set_value(dlg.get_value(), dlg.get_comment())
            self._update_and_notify()
        dlg.Destroy()
        self._editing = False

    def _crete_editor_dialog(self):
        dlg_class = EditorDialog(self._controller)
        return dlg_class(self._datafile, self._controller, self.plugin)

    def _set_value(self, value_list, comment):
        self._controller.execute(SetValues(value_list, comment))

    def _hide_tooltip(self):
        self._stop_popup_timer()
        self._tooltip.hide()

    def _stop_popup_timer(self):
        if hasattr(self, 'popup_timer'):
            self.popup_timer.Stop()

    def OnEnterWindow(self, event):
        if self._mainframe_has_focus():
            self.popup_timer = wx.CallLater(500, self.OnPopupTimer)

    def _mainframe_has_focus(self):
        return wx.GetTopLevelParent(self.FindFocus()) == \
                wx.GetTopLevelParent(self)

    def OnLeaveWindow(self, event):
        self._stop_popup_timer()

    def OnPopupTimer(self, event):
        if self.Parent.tooltip_allowed(self._tooltip):
            details, title = self._get_details_for_tooltip()
            if details:
                self._tooltip.set_content(details, title)
                self._tooltip.show_at(self._tooltip_position())

    def _get_details_for_tooltip(self):
        kw = self._controller.keyword_name
        return self.plugin.get_keyword_details(kw), kw

    def _tooltip_position(self):
        ms = wx.GetMouseState()
        # ensure that the popup gets focus immediately
        return ms.x-3, ms.y-3

    def OnLeftUp(self, event):
        if event.ControlDown() or event.CmdDown():
            self._navigate_to_user_keyword()
        else:
            if self._has_selected_area() and not self._editing:
                wx.CallAfter(self.OnEdit, event)
            event.Skip()

    def _has_selected_area(self):
        selection = self._value_display.GetSelection()
        if selection is None:
            return False
        return selection[0] == selection[1]

    def _navigate_to_user_keyword(self):
        uk = self.plugin.get_user_keyword(self._controller.keyword_name)
        if uk:
            self._tree.select_user_keyword_node(uk)

    def _update_and_notify(self):
        self.update_value()

    def OnClear(self, event):
        self._controller.execute(ClearSetting())
        self._update_and_notify()

    def update_value(self, event=None):
        if self._controller is None:
            return
        if self._controller.is_set:
            self._value_display.set_value(self._controller, self.plugin)
        else:
            self._value_display.clear()

    def get_selected_datafile_controller(self):
        return self._controller.datafile_controller

    def close(self):
        self._controller = None
        self.plugin.unsubscribe(self.update_value, RideImportSetting)

    def highlight(self, text):
        return self._value_display.highlight(text)

    def clear_highlight(self):
        return self._value_display.clear_highlight()

    def contains(self, text):
        return self._value_display.contains(text)


class SettingValueDisplay(wx.TextCtrl):

    def __init__(self, parent):
        wx.TextCtrl.__init__(self, parent, size=(-1, context.SETTING_ROW_HEIGTH),
                             style=wx.TE_RICH|wx.TE_MULTILINE)
        self.SetEditable(False)
        self._colour_provider = ColorizationSettings(parent.plugin.global_settings)
        self._empty_values()

    def _empty_values(self):
        self._value = None
        self._is_user_keyword = False

    def set_value(self, controller, plugin):
        self._value = controller.display_value
        self._keyword_name = controller.keyword_name
        self._is_user_keyword = plugin.is_user_keyword(self._keyword_name)
        self.SetValue(self._value)
        self._colorize_data()

    def _colorize_data(self, match=None):
        self._colorize_background(match)
        self._colorize_possible_user_keyword()

    def _colorize_background(self, match=None):
        self.SetBackgroundColour(self._get_background_colour(match))

    def _get_background_colour(self, match=None):
        if self._value is None:
            return 'light grey'
        if match is not None and self.contains(match):
            return self._colour_provider.get_highlight_color()
        return 'white'

    def _colorize_possible_user_keyword(self):
        if not self._is_user_keyword:
            return
        font = self.GetFont()
        font.SetUnderlined(True)
        self.SetStyle(0, len(self._keyword_name),
                      wx.TextAttr('blue', self._get_background_colour(), font))

    def clear(self):
        self.Clear()
        self._empty_values()
        self._colorize_background()

    def contains(self, text):
        if self._value is None:
            return False
        return [item for item in self._value.split(' | ') if utils.highlight_matcher(text, item)] != []

    def highlight(self, text):
        self._colorize_data(match=text)

    def clear_highlight(self):
        self._colorize_data()


class DocumentationEditor(SettingEditor):

    def _value_display_control(self):
        ctrl = HtmlWindow(self, (-1, 100))
        ctrl.Bind(wx.EVT_LEFT_DOWN, self.OnEdit)
        return ctrl

    def update_value(self, event=None):
        if self._controller:
            self._value_display.SetPage(self._controller.visible_value)

    def _get_tooltip(self):
        return HtmlPopupWindow(self, (500, 350), detachable=False)

    def _get_details_for_tooltip(self):
        return self._controller.visible_value, None

    def _crete_editor_dialog(self):
        return DocumentationDialog(self._datafile,
                                   self._controller.editable_value)

    def _set_value(self, value_list, comment):
        if value_list:
            self._controller.execute(UpdateDocumentation(value_list[0]))

    def contains(self, text):
        return False

    def highlight(self, text):
        pass

    def clear_highlight(self):
        pass


class TagsEditor(SettingEditor):

    def __init__(self, parent, controller, plugin, tree):
        SettingEditor.__init__(self, parent, controller, plugin, tree)
        self.plugin.subscribe(self._saving, RideSaving)
        self.Bind(wx.EVT_SIZE, self.OnSize)

    def _saving(self, message):
        self._tags_display.saving()

    def OnSize(self, event):
        self.SetSizeHints(-1, max(self._tags_display.get_height(), 25))
        event.Skip()

    def _value_display_control(self):
        self._tags_display = TagsDisplay(self, self._controller)
        self._tags_display.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self._tags_display.Bind(wx.EVT_KEY_DOWN, self.OnKey)
        return self._tags_display

    def contains(self, text):
        return False

    def highlight(self, text):
        pass

    def clear_highlight(self):
        pass

    def close(self):
        self._tags_display.close()
        self.plugin.unsubscribe(self._saving, RideSaving)
        SettingEditor.close(self)


class _AbstractListEditor(ListEditor):

    def __init__(self, parent, tree, controller):
        ListEditor.__init__(self, parent, self._titles, controller)
        self._datafile = controller.datafile
        self._tree = tree

    def get_selected_datafile_controller(self):
        return self._controller.datafile_controller

    def refresh_datafile(self, item, event):
        self._tree.refresh_datafile(item, event)

    def update_data(self):
        ListEditor.update_data(self)

    def update_value(self):
        pass

    def close(self):
        pass

    def highlight(self, text, expand=False):
        pass


class VariablesListEditor(_AbstractListEditor):
    _titles = ['Variable', 'Value', 'Comment']
    _buttons = ['Add Scalar', 'Add List']

    def __init__(self, parent, tree, controller):
        PUBLISHER.subscribe(self._update_vars, 'ride.variable.added', key=self)
        PUBLISHER.subscribe(self._update_vars, 'ride.variable.updated', key=self)
        PUBLISHER.subscribe(self._update_vars, 'ride.variable.removed', key=self)
        PUBLISHER.subscribe(self._open_variable_dialog, RideOpenVariableDialog)
        _AbstractListEditor.__init__(self, parent, tree, controller)

    def _update_vars(self, event):
        ListEditor.update_data(self)

    def get_column_values(self, item):
        return [item.name, item.value if isinstance(item.value, basestring)
                            else ' | '.join(item.value), ListToStringFormatter(item.comment).value]

    def OnMoveUp(self, event):
        _AbstractListEditor.OnMoveUp(self, event)
        self._list.SetFocus()

    def OnMoveDown(self, event):
        _AbstractListEditor.OnMoveDown(self, event)
        self._list.SetFocus()

    def OnAddScalar(self, event):
        dlg = ScalarVariableDialog(self._controller)
        if dlg.ShowModal() == wx.ID_OK:
            ctrl = self._controller.add_variable(*dlg.get_value())
            ctrl.set_comment(dlg.get_comment())
            self.update_data()
        dlg.Destroy()

    def OnAddList(self, event):
        dlg = ListVariableDialog(self._controller, plugin=self.Parent.plugin)
        if dlg.ShowModal() == wx.ID_OK:
            ctrl = self._controller.add_variable(*dlg.get_value())
            ctrl.set_comment(dlg.get_comment())
            self.update_data()
        dlg.Destroy()

    def OnEdit(self, event):
        var = self._controller[self._selection]
        self._open_var_dialog(var)

    def _open_variable_dialog(self, message):
        self._open_var_dialog(message.controller)

    def _open_var_dialog(self, var):
        if var.name.startswith('${'):
            dlg = ScalarVariableDialog(self._controller, item=var)
        else:
            dlg = ListVariableDialog(self._controller, item=var,
                                     plugin=self.Parent.plugin)
        if dlg.ShowModal() == wx.ID_OK:
            name, value = dlg.get_value()
            var.execute(UpdateVariable(name, value, dlg.get_comment()))
            self.update_data()
        dlg.Destroy()

    def close(self):
        PUBLISHER.unsubscribe_all(key=self)


class ImportSettingListEditor(_AbstractListEditor):
    _titles = ['Import', 'Name / Path', 'Arguments', 'Comment']
    _buttons = ['Library', 'Resource', 'Variables', 'Import Failed Help']

    def __init__(self, parent, tree, controller):
        self._import_failed_shown = False
        _AbstractListEditor.__init__(self, parent, tree, controller)

    @overrides(ListEditorBase)
    def _create_buttons(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(Label(self, label='Add Import', size=wx.Size(120, 20), style=wx.ALIGN_CENTER))
        for label in self._buttons:
            sizer.Add(ButtonWithHandler(self, label, width=120), 0, wx.ALL, 1)
        return sizer

    def OnLeftClick(self, event):
        if not self.is_selected:
            return
        if wx.GetMouseState().ControlDown() or wx.GetMouseState().CmdDown():
            self.navigate_to_tree()

    def navigate_to_tree(self):
        setting = self._get_setting()
        if self.has_link_target(setting):
            self._tree.select_node_by_data(setting.get_imported_controller())

    def has_link_target(self, controller):
        return controller.is_resource and controller.get_imported_controller()

    @overrides(ListEditorBase)
    def has_error(self, controller):
        return controller.has_error()

    @overrides(ListEditorBase)
    def OnRightClick(self, event):
        PopupMenu(self, PopupMenuItems(self, self._create_item_menu()))

    def _create_item_menu(self):
        menu = self._menu
        item = self._controller[self._selection]
        if item.has_error() and item.type == 'Library':
            menu = menu[:] + ['Import Library Spec XML']
        return menu

    def OnImportLibrarySpecXml(self, event):
        RideExecuteSpecXmlImport().publish()

    def OnEdit(self, event):
        setting = self._get_setting()
        self._show_import_editor_dialog(EditorDialog(setting),
                                        lambda v, c: setting.execute(SetValues(v, c)),
                                        setting,
                                        on_empty=self._delete_selected)

    def OnLibrary(self, event):
        self._show_import_editor_dialog(LibraryDialog,
                                        lambda v, c: self._controller.execute(AddLibrary(v, c)))

    def OnResource(self, event):
        self._show_import_editor_dialog(ResourceDialog,
                                        lambda v, c: self._controller.execute(AddResource(v, c)))

    def OnVariables(self, event):
        self._show_import_editor_dialog(VariablesDialog,
                                        lambda v, c: self._controller.execute(AddVariablesFileImport(v, c)))

    def OnImportFailedHelp(self, event):
        if self._import_failed_shown:
            return
        dialog = HtmlDialog('Import failure handling', '''
        <br>Possible corrections and notes:<br>
        <ul>
            <li>Import failure is shown with red color.</li>
            <li>See Tools / View RIDE Log for detailed information about the failure.</li>
            <li>If the import contains a variable that RIDE has not initialized, consider adding the variable
            to variable table with a default value.</li>
            <li>For library import failure: Consider importing library spec XML (Tools / Import Library Spec XML or by
            adding the XML file with the correct name to PYTHONPATH) to enable keyword completion
            for example for Java libraries.
            Library spec XML can be created using libdoc tool from Robot Framework.
            For more information see <a href="https://github.com/robotframework/RIDE/wiki/Keyword-Completion#wiki-using-library-specs">wiki</a>.
            </li>
        </ul>''')
        dialog.Bind(wx.EVT_CLOSE, self._import_failed_help_closed)
        dialog.Show()
        self._import_failed_shown = True

    def _import_failed_help_closed(self, event):
        self._import_failed_shown = False
        event.Skip()

    def _get_setting(self):
        return self._controller[self._selection]

    def _show_import_editor_dialog(self, dialog, creator_or_setter, item=None, on_empty=None):
        dlg = dialog(self._controller, item=item)
        if dlg.ShowModal() == wx.ID_OK:
            value = dlg.get_value()
            if not self._empty_name(value):
                creator_or_setter(value, dlg.get_comment())
            elif on_empty:
                on_empty()
            self.update_data()
        dlg.Destroy()

    def _empty_name(self, value):
        return not value[0]

    def get_column_values(self, item):
        return [item.type, item.name, item.display_value, ListToStringFormatter(item.comment).value]


class MetadataListEditor(_AbstractListEditor):
    _titles = ['Metadata', 'Value', 'Comment']
    _buttons = ['Add Metadata']
    _sortable = False

    def OnEdit(self, event):
        meta = self._controller[self._selection]
        dlg = MetadataDialog(self._controller.datafile, item=meta)
        if dlg.ShowModal() == wx.ID_OK:
            meta.set_value(*dlg.get_value())
            meta.set_comment(dlg.get_comment())
            self.update_data()
        dlg.Destroy()

    def OnAddMetadata(self, event):
        dlg = MetadataDialog(self._controller.datafile)
        if dlg.ShowModal() == wx.ID_OK:
            ctrl = self._controller.add_metadata(*dlg.get_value())
            ctrl.set_comment(dlg.get_comment())
            self.update_data()
        dlg.Destroy()

    def get_column_values(self, item):
        return [item.name, utils.html_escape(item.value), ListToStringFormatter(item.comment).value]

########NEW FILE########
__FILENAME__ = tags
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Configure wx version to allow running test app in __main__
if __name__ == '__main__':
    import robotide as _

import wx

from robotide.editor.flowsizer import HorizontalFlowSizer
from robotide.controller.commands import ChangeTag
from robotide.controller.tags import ForcedTag, DefaultTag, Tag


class TagsDisplay(wx.Panel):

    def __init__(self, parent, controller):
        wx.Panel.__init__(self, parent, wx.ID_ANY)
        self._controller = controller
        self._sizer = HorizontalFlowSizer()
        self._tag_boxes = []
        self.SetSizer(self._sizer)

    def add_tag(self, tag):
        self._add_tagbox(Properties(tag, self._controller))

    def _add_tagbox(self, properties):
        tagbox = TagBox(self, properties)
        self._sizer.Add(tagbox)
        self._tag_boxes.append(tagbox)

    def build(self):
        if not (self._tag_boxes and self._tag_boxes[-1].add_new):
            self.add_new_tag_tagbox(rebuild=False)
        self._sizer.SetSizeHints(self)
        parent_sizer = self.GetParent().GetSizer()
        if parent_sizer:
            parent_sizer.Layout()

    def clear(self):
        self.set_value(self._controller)

    def close(self):
        for tag_box in self._tag_boxes:
            tag_box.close()

    def saving(self):
        for tag_box in self._tag_boxes:
            tag_box.saving()

    def set_value(self, controller, plugin=None):
        if not self._tag_boxes:
            self._add_tags(list(controller))
        else:
            #in GTK you can have focus in a dead object
            #  .. this causes Segmentation Faults
            # Thus instead of clearing old values and adding new ones
            # modify the ones that exist
            self._modify_values(controller)
        self.build()

    def add_new_tag_tagbox(self, rebuild=True):
        self._add_tagbox(AddTagBoxProperties(self._controller.empty_tag(), self))
        if rebuild:
            self.build()

    def _add_tags(self, tags):
        for tag in tags:
            self.add_tag(tag)

    def _modify_values(self, controller):
        self._remove_empty_tagboxes()
        self._set_tags(list(controller), self._tag_boxes[:], controller)

    def _remove_empty_tagboxes(self):
        for tb in self._tag_boxes[:]:
            if tb.value == '':
                self._destroy_tagbox(tb)

    def _set_tags(self, tags, tagboxes, controller):
        if not tags:
            self._destroy_tagboxes(tagboxes)
        elif not tagboxes:
            self._add_tags(tags)
        else:
            tagboxes[0].set_properties(Properties(tags[0], controller))
            self._set_tags(tags[1:], tagboxes[1:], controller)

    def _destroy_tagboxes(self, tagboxes):
        for tb in tagboxes:
            if not tb.add_new:
                self._destroy_tagbox(tb)

    def _destroy_tagbox(self, tagbox):
        tagbox.Destroy()
        self._tag_boxes.remove(tagbox)

    def GetSelection(self):
        return None

    def get_height(self):
        return self._sizer.height


class TagBox(wx.TextCtrl):

    def __init__(self, parent, properties):
        wx.TextCtrl.__init__(self, parent, wx.ID_ANY, '', style=wx.TE_CENTER)
        self._bind()
        self.set_properties(properties)

    def _bind(self):
        for event, handler in [(wx.EVT_SET_FOCUS, self.OnSetFocus),
                               (wx.EVT_KILL_FOCUS, self.OnKillFocus),
                               (wx.EVT_LEFT_UP, self.OnSetFocus),
                               (wx.EVT_KEY_UP, self.OnKeyUp),
                               (wx.EVT_CHAR, self.OnChar)]:
            self.Bind(event, handler)

    def set_properties(self, properties):
        self._properties = properties
        self._apply_properties()

    def _apply_properties(self):
        self.SetValue(self._properties.text)
        self.SetToolTipString(self._properties.tooltip)
        self.SetEditable(self._properties.enabled)
        size = self._get_size()
        self.SetMaxSize(size)
        self.SetMinSize(size)
        self._colorize()

    def _get_size(self):
        size = self.GetTextExtent(self.value)
        return wx.Size(max(size[0]+10, 70), max(size[1]+3, 25))

    def _colorize(self):
        self.SetForegroundColour(self._properties.foreground_color)
        self.SetBackgroundColour(self._properties.background_color)

    def close(self):
        self._update_value()

    def saving(self):
        self._update_value()

    def OnKeyUp(self, event):
        if self._properties.modifiable:
            if event.GetKeyCode() == wx.WXK_ESCAPE:
                self._cancel_editing()
            elif event.GetKeyCode() == wx.WXK_RETURN:
                self._update_value()
                # FIXME: Is this needed?
                return # Crashes RIDE on Linux if event.Skip is called
            elif event.GetKeyCode() == wx.WXK_DELETE:
                self.SetValue('')
        event.Skip()

    def _cancel_editing(self):
        self.SetValue(self._properties.text)
        self._colorize()

    def OnChar(self, event):
        # For some reason at least ESC and F<num> keys are considered chars.
        # We only special case ESC, though.
        if event.GetKeyCode() != wx.WXK_ESCAPE:
            self._properties.activate(self)
        event.Skip()

    def OnKillFocus(self, event):
        self._update_value()
        # event.Skip() Can't skip on Linux as this causes crash

    def _update_value(self):
        self._properties.change_value(self.value)

    def OnSetFocus(self, event):
        if self._properties.add_new:
            wx.CallAfter(self.SelectAll)
        event.Skip()

    @property
    def value(self):
        return self.GetValue().strip()

    @property
    def add_new(self):
        return self._properties.add_new


def Properties(tag, controller):
    if tag.controller == controller:
        return TagBoxProperties(tag)
    return tag.choose({ForcedTag: ForcedTagBoxProperties,
                       DefaultTag: DefaultTagBoxProperties})(tag)


class _TagBoxProperties(object):
    foreground_color = 'black'
    background_color = 'white'
    enabled = True
    add_new = False

    def __init__(self, tag):
        self._tag = tag

    @property
    def text(self):
        return self._tag.name or ''

    @property
    def tooltip(self):
        return self._tag.tooltip

    @property
    def modifiable(self):
        return self.enabled

    def change_value(self, value):
        if self.modifiable and value != self.text:
            self._tag.controller.execute(ChangeTag(self._tag, value))

    def activate(self, tagbox):
        pass


class TagBoxProperties(_TagBoxProperties):
    pass


class AddTagBoxProperties(_TagBoxProperties):
    foreground_color = 'gray'
    text = '<Add New>'
    tooltip = 'Click to add new tag'
    modifiable = False
    add_new = True

    def __init__(self, tag, display):
        _TagBoxProperties.__init__(self, tag)
        self._display = display

    def activate(self, tagbox):
        tagbox.set_properties(TagBoxProperties(self._tag))
        self._display.add_new_tag_tagbox()


class ForcedTagBoxProperties(_TagBoxProperties):
    foreground_color = 'red'
    background_color = '#D3D3D3'
    enabled = False


class DefaultTagBoxProperties(_TagBoxProperties):
    foreground_color = '#666666'
    background_color = '#D3D3D3'
    enabled = False


if __name__ == '__main__':
    class MyFrame(wx.Frame):
        def __init__(self, parent, id, title):
            wx.Frame.__init__(self, parent, id, title)
    class MyMenuApp( wx.App):
        def OnInit(self):
            frame = MyFrame(None , -1, 'Frame Window Demo')
            sz = wx.BoxSizer()
            display = TagsDisplay(frame, None)
            display.add_tag(ForcedTag('forced'), False)
            display.add_tag(DefaultTag('default'), False)
            for name in ['foo', 'bar', 'foobo', 'jee', 'huu', 'asb', 'sdfajkd', 'Sprint-1']:
                display.add_tag(Tag(name), True)
            display.add_tag(Tag(''), False)
            display.build()
            sz.Add(display, 0, wx.GROW|wx.ALL, 5)
            frame.Show(True)
            self.SetTopWindow(frame)
            return True
    # Run program
    app=MyMenuApp(0)
    app.MainLoop()

########NEW FILE########
__FILENAME__ = texteditor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from time import time
from robotide.context.platform import IS_WINDOWS, IS_MAC
import wx
from wx import stc
from StringIO import StringIO
import string

from robot.parsing.model import TestDataDirectory
from robot.parsing.populators import FromFilePopulator
from robot.parsing.txtreader import TxtReader

from robotide.controller.commands import SetDataFile
from robotide.controller.dataloader import TestDataDirectoryWithExcludes
from robotide.publish.messages import RideMessage
from robotide.widgets import VerticalSizer, HorizontalSizer, ButtonWithHandler
from robotide.pluginapi import (Plugin, RideSaving, TreeAwarePluginMixin,
        RideTreeSelection, RideNotebookTabChanging, RideDataChanged,
        RideOpenSuite, RideDataChangedToDirty)
from robotide.widgets.text import TextField
from robotide.widgets.label import Label

try:
    from . import robotframeworklexer
except Exception as e:
    robotframeworklexer = None

from popupwindow import HtmlDialog

class TextEditorPlugin(Plugin, TreeAwarePluginMixin):
    title = 'Text Edit'

    def __init__(self, application):
        Plugin.__init__(self, application)
        self._editor_component = None

    @property
    def _editor(self):
        if not self._editor_component:
            self._editor_component = SourceEditor(self.notebook,
                                                  self.title,
                                                  DataValidationHandler(self))
            self._refresh_timer = wx.Timer(self._editor_component)
            self._editor_component.Bind(wx.EVT_TIMER, self._on_timer)
        return self._editor_component

    def enable(self):
        self.add_self_as_tree_aware_plugin()
        self.subscribe(self.OnSaving, RideSaving)
        self.subscribe(self.OnTreeSelection, RideTreeSelection)
        self.subscribe(self.OnDataChanged, RideMessage)
        self.subscribe(self.OnTabChange, RideNotebookTabChanging)
        self._register_shortcuts()
        self._open()

    def _register_shortcuts(self):
        def focused(func):
            def f(event):
                if self.is_focused() and self._editor.is_focused():
                    func(event)
            return f
        self.register_shortcut('CtrlCmd-X', focused(lambda e: self._editor.cut()))
        self.register_shortcut('CtrlCmd-C', focused(lambda e: self._editor.copy()))
        if IS_MAC: # Mac needs this key binding
            self.register_shortcut('CtrlCmd-A', focused(lambda e: self._editor.select_all()))
        if IS_WINDOWS or IS_MAC: # Linux does not need this key binding
            self.register_shortcut('CtrlCmd-V', focused(lambda e: self._editor.paste()))
        self.register_shortcut('CtrlCmd-Z', focused(lambda e: self._editor.undo()))
        self.register_shortcut('CtrlCmd-Y', focused(lambda e: self._editor.redo()))
        self.register_shortcut('Del', focused(lambda e: self._editor.delete()))
        self.register_shortcut('CtrlCmd-F', lambda e: self._editor._search_field.SetFocus())
        self.register_shortcut('CtrlCmd-G', lambda e: self._editor.OnFind(e))
        self.register_shortcut('CtrlCmd-Shift-G', lambda e: self._editor.OnFindBackwards(e))

    def disable(self):
        self.remove_self_from_tree_aware_plugins()
        self.unsubscribe_all()
        self.unregister_actions()
        self.delete_tab(self._editor)
        self._editor_component = None

    def OnOpen(self, event):
        self._open()

    def _open(self):
        datafile_controller = self.tree.get_selected_datafile_controller()
        if datafile_controller:
            self._open_data_for_controller(datafile_controller)
        self.show_tab(self._editor)

    def OnSaving(self, message):
        if self.is_focused():
            self._editor.save()

    def OnDataChanged(self, message):
        if self._should_process_data_changed_message(message):
            if isinstance(message, RideOpenSuite):
                self._editor.reset()
            if self._editor.dirty:
                self._apply_txt_changes_to_model()
            self._refresh_timer.Start(500, True) # For performance reasons only run after all the data changes

    def _on_timer(self, event):
        self._open_tree_selection_in_editor()
        event.Skip()

    def _should_process_data_changed_message(self, message):
        return isinstance(message, RideDataChanged) and \
               not isinstance(message, RideDataChangedToDirty)

    def OnTreeSelection(self, message):
        self._editor.store_position()
        if self.is_focused():
            next_datafile_controller = message.item and message.item.datafile_controller
            if self._editor.dirty:
                if not self._apply_txt_changes_to_model():
                    if self._editor.datafile_controller != next_datafile_controller:
                        self.tree.select_controller_node(self._editor.datafile_controller)
                    return
            if next_datafile_controller:
                self._open_data_for_controller(next_datafile_controller)
                self._editor.set_editor_caret_position()

    def _open_tree_selection_in_editor(self):
        datafile_controller = self.tree.get_selected_datafile_controller()
        if datafile_controller:
            self._editor.open(DataFileWrapper(datafile_controller,
                                              self.global_settings))

    def _open_data_for_controller(self, datafile_controller):
        self._editor.selected(DataFileWrapper(datafile_controller,
                                              self.global_settings))

    def OnTabChange(self, message):
        if message.newtab == self.title:
            self._open()
            self._editor.set_editor_caret_position()
        elif message.oldtab == self.title:
            self._editor.remove_and_store_state()


    def _apply_txt_changes_to_model(self):
        if not self._editor.save():
            return False
        self._editor.reset()
        return True

    def is_focused(self):
        return self.notebook.current_page_title == self.title


class DataValidationHandler(object):

    def __init__(self, plugin):
        self._plugin = plugin
        self._last_answer = None
        self._last_answer_time = 0

    def set_editor(self, editor):
        self._editor = editor

    def validate_and_update(self, data, text):
        if not self._sanity_check(data, text):
            self._handle_sanity_check_failure()
            return False
        else:
            self._editor.reset()
            data.update_from(text)
            return True

    def _sanity_check(self, data, text):
        formatted_text = data.format_text(text).encode('UTF-8')
        c = self._normalize(formatted_text)
        e = self._normalize(text)
        return len(c) == len(e)

    def _normalize(self, text):
        for item in tuple(string.whitespace) + ('...', '*'):
            if item in text:
                text = text.replace(item, '')
        return text

    def _handle_sanity_check_failure(self):
        if self._last_answer == wx.ID_NO and \
            time() - self._last_answer_time <= 0.2:
            self._editor._mark_file_dirty()
            return
        # TODO: use widgets.Dialog
        id = wx.MessageDialog(self._editor,
                         'ERROR: Data sanity check failed!\n'\
                         'Reset changes?',
                         'Can not apply changes from Txt Editor',
                          style=wx.YES|wx.NO).ShowModal()
        self._last_answer = id
        self._last_answer_time = time()
        if id == wx.ID_NO:
            self._editor._mark_file_dirty()
        else:
            self._editor._revert()


class DataFileWrapper(object): # TODO: bad class name

    def __init__(self, data, settings):
        self._data = data
        self._settings = settings

    def __eq__(self, other):
        if other is None:
            return False
        return self._data == other._data

    def update_from(self, content):
        self._data.execute(SetDataFile(self._create_target_from(content)))

    def _create_target_from(self, content):
        src = StringIO(content)
        target = self._create_target()
        FromStringIOPopulator(target).populate(src)
        return target

    def format_text(self, text):
        return self._txt_data(self._create_target_from(text))

    def mark_data_dirty(self):
        self._data.mark_dirty()

    def _create_target(self):
        data = self._data.data
        target_class = type(data)
        if isinstance(data, TestDataDirectory):
            target = TestDataDirectory(source=self._data.directory)
            target.initfile = data.initfile
            return target
        return target_class(source=self._data.source)

    @property
    def content(self):
        return self._txt_data(self._data.data)

    def _txt_data(self, data):
        output = StringIO()
        data.save(output=output, format='txt',
                  txt_separating_spaces=self._settings['txt number of spaces'])
        return output.getvalue().decode('UTF-8')


class SourceEditor(wx.Panel):

    def __init__(self, parent, title, data_validator):
        wx.Panel.__init__(self, parent)
        self._syntax_colorization_help_exists = False
        self._data_validator = data_validator
        self._data_validator.set_editor(self)
        self._parent = parent
        self._create_ui(title)
        self._data = None
        self._dirty = False
        self._positions = {}

    def is_focused(self):
        foc = wx.Window.FindFocus()
        return any(elem == foc for elem in [self]+list(self.GetChildren()))

    def _create_ui(self, title):
        self.SetSizer(VerticalSizer())
        self._create_editor_toolbar()
        self._create_editor_text_control()
        self._parent.add_tab(self, title, allow_closing=False)

    def _create_editor_toolbar(self):
        # needs extra container, since we might add helper text about syntax colorization
        self.editor_toolbar = HorizontalSizer()
        default_components = HorizontalSizer()
        default_components.add_with_padding(
            ButtonWithHandler(self, 'Apply Changes', handler=lambda e: self.save()))
        self._create_search(default_components)
        self.editor_toolbar.add_expanding(default_components)
        self.Sizer.add_expanding(self.editor_toolbar, propotion=0)

    def _create_search(self, container_sizer):
        container_sizer.AddSpacer(20)
        self._search_field = TextField(self, '', process_enters=True)
        self._search_field.Bind(wx.EVT_TEXT_ENTER, self.OnFind)
        container_sizer.add_with_padding(self._search_field)
        container_sizer.add_with_padding(
            ButtonWithHandler(self, 'Search', handler=self.OnFind))
        self._search_field_notification = Label(self, label='')
        container_sizer.add_with_padding(self._search_field_notification)

    def create_syntax_colorization_help(self):
        if self._syntax_colorization_help_exists:
            return
        label = Label(self, label="Syntax colorization disabled due to missing requirements.")
        link = wx.HyperlinkCtrl(self, -1, label="Get help", url="")
        link.Bind(wx.EVT_HYPERLINK, self.show_help_dialog)
        flags = wx.ALIGN_CENTER_VERTICAL|wx.ALIGN_RIGHT
        syntax_colorization_help_sizer = wx.BoxSizer(wx.VERTICAL)
        syntax_colorization_help_sizer.AddMany([
            (label, 0, flags),
            (link, 0, flags)
        ])
        self.editor_toolbar.add_expanding(syntax_colorization_help_sizer)
        self.Layout()
        self._syntax_colorization_help_exists = True

    def show_help_dialog(self, event):
        content = """<h1>Syntax colorization</h1>
        <p>
        Syntax colorization for Text Edit uses <a href='http://pygments.org/'>Pygments</a> syntax highlighter.
        </p>
        <p>
        Install Pygments from command line with:
        <pre>
            pip install pygments
        </pre>
        Or:
        <pre>
            easy_install pygments
        </pre>
        Then, restart RIDE.
        </p>
        <p>
        If you do not have pip or easy_install,
        <a href='http://pythonhosted.org/an_example_pypi_project/setuptools.html#installing-setuptools-and-easy-install'>follow
        these instructions</a>.
        </p>
        <p>
        For more information about installing Pygments, <a href='http://pygments.org/download/'>see the site</a>.
        </p>
        """
        HtmlDialog("Getting syntax colorization", content).Show()

    def store_position(self):
        if self._editor:
            self._positions[self.datafile_controller] = self._editor.GetCurrentPos()

    def set_editor_caret_position(self):
        position = self._positions.get(self.datafile_controller, None)
        if position:
            self._editor.SetFocus()
            self._editor.SetCurrentPos(position)
            self._editor.SetSelection(position, position)

    @property
    def dirty(self):
        return self._dirty

    @property
    def datafile_controller(self):
        return self._data._data if self._data else None


    def OnFind(self, event):
        if self._editor:
            self._find()

    def OnFindBackwards(self, event):
        if self._editor:
            self._find(forward=False)

    def _find(self, forward=True):
        txt = self._search_field.GetValue()
        position = self._find_text_position(forward, txt)
        self._show_search_results(position, txt)

    # FIXME: This must be cleaned up
    def _find_text_position(self, forward, txt):
        file_end = len(self._editor.utf8_text)
        search_end = file_end if forward else 0
        anchor = self._editor.GetAnchor()
        anchor += 1 if forward else 0
        position = self._editor.FindText(anchor, search_end, txt, 0)
        if position == -1:
            start, end = (0, file_end) if forward else (file_end - 1, 0)
            position = self._editor.FindText(start, end, txt, 0)
        return position

    def _show_search_results(self, position, txt):
        if position != -1:
            self._editor.SetSelection(position, position + len(txt))
            self._search_field_notification.SetLabel('')
        else:
            self._search_field_notification.SetLabel('No matches found.')

    def open(self, data):
        self.reset()
        self._data = data
        if not self._editor:
            self._stored_text = self._data.content
        else:
            self._editor.set_text(self._data.content)
            self.set_editor_caret_position()

    def selected(self, data):
        if not self._editor:
            self._create_editor_text_control(self._stored_text)
        if self._data == data:
            return
        self.open(data)

    def reset(self):
        self._dirty = False

    def save(self, *args):
        if self.dirty:
            if not self._data_validator.validate_and_update(self._data,
                                                     self._editor.utf8_text):
                return False
        return True

    def delete(self):
        if self._editor.GetSelectionStart() == self._editor.GetSelectionEnd():
            self._editor.CharRight()
        self._editor.DeleteBack()

    def cut(self):
        self._editor.Cut()

    def copy(self):
        self._editor.Copy()

    def paste(self):
        focus = wx.Window.FindFocus()
        if focus == self._editor:
            self._editor.Paste()
        elif focus == self._search_field:
            self._search_field.Paste()

    def select_all(self):
        self._editor.SelectAll()

    def undo(self):
        self._editor.Undo()

    def redo(self):
        self._editor.Redo()

    def remove_and_store_state(self):
        if self._editor:
            self.store_position()
            self._stored_text = self._editor.GetText()
            self._editor.Destroy()
            self._editor = None

    def _create_editor_text_control(self, text=None):
        self._editor = RobotDataEditor(self)
        self.Sizer.add_expanding(self._editor)
        self.Sizer.Layout()
        if text is not None:
            self._editor.set_text(text)
        self._editor.Bind(wx.EVT_KEY_UP, self.OnEditorKey)
        self._editor.Bind(wx.EVT_KILL_FOCUS, self.LeaveFocus)
        self._editor.Bind(wx.EVT_SET_FOCUS, self.GetFocus)

    def LeaveFocus(self, event):
        self._editor.SetCaretPeriod(0)
        self.save()

    def GetFocus(self, event):
        self._editor.SetCaretPeriod(500)
        event.Skip()

    def _revert(self):
        self.reset()
        self._editor.set_text(self._data.content)

    def OnEditorKey(self, event):
        if not self.dirty and self._editor.GetModify():
            self._mark_file_dirty()
        event.Skip()

    def _mark_file_dirty(self):
        if self._data:
            self._dirty = True
            self._data.mark_data_dirty()


class RobotDataEditor(stc.StyledTextCtrl):

    def __init__(self, parent):
        stc.StyledTextCtrl.__init__(self, parent)
        self.SetMarginType(0, stc.STC_MARGIN_NUMBER)
        self.SetMarginWidth(0, self.TextWidth(stc.STC_STYLE_LINENUMBER,'1234'))
        self.SetReadOnly(True)
        self.SetLexer(stc.STC_LEX_CONTAINER)
        self.Bind(stc.EVT_STC_STYLENEEDED, self.OnStyle)
        self.stylizer = RobotStylizer(self, parent._parent._app.settings)

    def set_text(self, text):
        self.SetReadOnly(False)
        self.SetText(text)
        self.stylizer.stylize()
        self.EmptyUndoBuffer()

    @property
    def utf8_text(self):
        return self.GetText().encode('UTF-8')

    def OnStyle(self, event):
        self.stylizer.stylize()


class FromStringIOPopulator(FromFilePopulator):

    def populate(self, content):
        TxtReader().read(content, self)

class RobotStylizer(object):
    def __init__(self, editor, settings):
        self.editor = editor
        self.lexer = None
        self.settings = settings
        self.font_size = settings.get('text edit font size', 8)
        if robotframeworklexer:
            self.lexer = robotframeworklexer.RobotFrameworkLexer()
            self._set_styles()
        else:
            self.editor.GetParent().create_syntax_colorization_help()

    def _set_styles(self):
        color_settings = self.settings.get_without_default('Text Edit Colors')
        styles = {
            robotframeworklexer.ARGUMENT: {
                'fore': color_settings['argument']
            },
            robotframeworklexer.COMMENT: {
                'fore': color_settings['comment']
            },
            robotframeworklexer.ERROR: {
                'fore': color_settings['error']
            },
            robotframeworklexer.GHERKIN: {
                'fore': color_settings['gherkin']
            },
            robotframeworklexer.HEADING: {
                'fore': color_settings['heading'],
                'bold': 'true'
            },
            robotframeworklexer.IMPORT: {
                'fore': color_settings['import']
            },
            robotframeworklexer.KEYWORD: {
                'fore': color_settings['keyword'],
                'bold': 'true'
            },
            robotframeworklexer.SEPARATOR: {
                'fore': color_settings['separator']
            },
            robotframeworklexer.SETTING: {
                'fore': color_settings['setting'],
                'bold': 'true'
            },
            robotframeworklexer.SYNTAX: {
                'fore': color_settings['syntax']
            },
            robotframeworklexer.TC_KW_NAME: {
                'fore': color_settings['tc_kw_name']
            },
            robotframeworklexer.VARIABLE: {
                'fore': color_settings['variable']
            }
        }
        self.tokens = {}
        for index, token in enumerate(styles):
            self.tokens[token] = index
            self.editor.StyleSetSpec(index, self._get_style_string(**styles[token]))

    def _get_word_and_length(self, current_position):
        word = self.editor.GetTextRange(current_position, self.editor.WordEndPosition(current_position, False))
        return word, len(word)

    def _get_style_string(self, back='#FFFFFF', face='Courier', fore='#000000', bold='', underline=''):
        settings = locals()
        settings.update(size=self.font_size)
        return ','.join('%s:%s' % (name, value) for name, value in settings.items() if value)

    def stylize(self):
        if not self.lexer:
            return
        self.editor.ConvertEOLs(2)
        shift = 0
        for position, token, value in self.lexer.get_tokens_unprocessed(self.editor.GetText()):
            self.editor.StartStyling(position+shift, 31)
            self.editor.SetStyling(len(value.encode('utf-8')), self.tokens[token])
            shift += len(value.encode('utf-8'))-len(value)


########NEW FILE########
__FILENAME__ = tooltips
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import wx.grid

from popupwindow import HtmlPopupWindow


class GridToolTips(object):

    def __init__(self, grid):
        self._tooltip = HtmlPopupWindow(grid, (250, 80), False, True)
        self._information_popup = HtmlPopupWindow(grid, (450, 300))
        self._grid = grid
        self._tooltip_timer = wx.Timer(grid.GetGridWindow())
        grid.GetGridWindow().Bind(wx.EVT_MOTION, self.OnMouseMotion)
        grid.GetGridWindow().Bind(wx.EVT_TIMER, self.OnShowToolTip)
        grid.Bind(wx.grid.EVT_GRID_EDITOR_HIDDEN, self.OnGridEditorHidden)

    def OnMouseMotion(self, event):
        self._hide_tooltip()
        self._start_tooltip_timer()
        event.Skip()

    def _start_tooltip_timer(self):
        self._tooltip_timer.Start(1000, True)

    def OnShowToolTip(self, event):
        self._hide_tooltip()
        content = self._grid.get_tooltip_content()
        if content and self._application_has_focus():
            self._show_tooltip_at(content, self._calculate_tooltip_position())
            self._grid.SetFocus()

    def _application_has_focus(self):
        window = wx.Window.FindFocus()
        if window is None:
            return False
        rect = window.GetTopLevelParent().GetScreenRect()
        return rect.Inside(wx.GetMousePosition())

    def OnGridEditorHidden(self, event):
        cell = event.Row, event.Col
        if cell == self._grid.cell_under_cursor:
            self._start_tooltip_timer()

    def _show_tooltip_at(self, content, position):
        if not self._information_popup.IsShown():
            self._tooltip.set_content(content)
            self._tooltip.show_at(position)

    def _calculate_tooltip_position(self):
        x, y = wx.GetMousePosition()
        return x + 16, y + 16   # don't place tooltip under cursor

    def _hide_tooltip(self):
        self._tooltip.hide()

    def hide_information(self):
        self._information_popup.hide()

    def hide(self):
        self._hide_tooltip()
        self.hide_information()

    def show_info_at(self, info, title, position):
        self._tooltip.hide()
        self._information_popup.set_content(info, title)
        self._information_popup.show_at(position)

########NEW FILE########
__FILENAME__ = log
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import wx

from robotide.pluginapi import Plugin, ActionInfo, RideLog
from robotide.widgets import Font

def _message_to_string(msg):
    return '%s [%s]: %s\n\n' % (msg.timestamp, msg.level, msg.message)

class LogPlugin(Plugin):
    """Viewer for internal log messages."""

    def __init__(self, app):
        Plugin.__init__(self, app, default_settings={'log_to_console': False})
        self._log = []
        self._window = None

    def enable(self):
        self._create_menu()
        self.subscribe(self._log_message, RideLog)

    def disable(self):
        self.unsubscribe_all()
        self.unregister_actions()
        if self._window:
            self._window.close(self.notebook)

    def _create_menu(self):
        self.unregister_actions()
        self.register_action(ActionInfo('Tools', 'View RIDE Log',
                                        self.OnViewLog, position=84))

    def _log_message(self, log_event):
        self._log.append(log_event)
        if self._window:
            self._window.update_log()
        if self.log_to_console:
            print _message_to_string(log_event)

    def OnViewLog(self, event):
        if not self._window:
            self._window = _LogWindow(self.notebook, self._log)
            self._window.update_log()
            self.register_shortcut('CtrlCmd-C', lambda e: self._window.Copy())
            self.register_shortcut('CtrlCmd-A', lambda e: self._window.SelectAll())
        else:
            self.notebook.show_tab(self._window)


class _LogWindow(wx.TextCtrl):

    def __init__(self, notebook, log):
        wx.TextCtrl.__init__(self, notebook, style=wx.TE_READONLY | wx.TE_MULTILINE)
        self._log = log
        self._create_ui()
        self._add_to_notebook(notebook)
        self.SetFont(Font().fixed_log)

    def _create_ui(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self)
        self.SetSizer(sizer)

    def _add_to_notebook(self, notebook):
        notebook.add_tab(self, 'Log', allow_closing=True)
        notebook.show_tab(self)

    def close(self, notebook):
        notebook.delete_tab(self)

    def update_log(self):
        self.SetValue(self._decode_log(self._log))

    def _decode_log(self, log):
        result = ''
        for msg in log:
            result += _message_to_string(msg)
        return result

########NEW FILE########
__FILENAME__ = cache
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import time

from robotide.robotapi import normpath


class LibraryCache(object):

    def __init__(self, settings, libraries_need_refresh_listener, library_manager):
        self._settings = settings
        if library_manager:
            self.set_library_manager(library_manager)
        self._libraries_need_refresh_listener = libraries_need_refresh_listener
        self._library_keywords = {}
        self.__default_libraries = None
        self.__default_kws = None

    def set_library_manager(self, library_manager):
        self._library_manager = library_manager

    def expire(self):
        self.__init__(self._settings, self._libraries_need_refresh_listener, self._library_manager)

    @property
    def _default_libraries(self):
        if self.__default_libraries is None:
            self.__default_libraries = self._get_default_libraries()
        return self.__default_libraries

    @property
    def _default_kws(self):
        if self.__default_kws is None:
            self.__default_kws = self._build_default_kws()
        return self.__default_kws

    def get_all_cached_library_names(self):
        return [name for name, _ in self._library_keywords]

    def _get_library(self, name, args):
        library_database = self._library_manager.get_new_connection_to_library_database()
        try:
            last_updated = library_database.get_library_last_updated(name, args)
            if last_updated:
                if time.time() - last_updated > 10.0:
                    self._library_manager.fetch_keywords(name, args, self._libraries_need_refresh_listener)
                return library_database.fetch_library_keywords(name, args)
            return self._library_manager.get_and_insert_keywords(name, args)
        finally:
            library_database.close()

    def _key(self, name, args):
        return name, unicode(tuple(args or ''))

    def get_library_keywords(self, name, args=None, alias=None):
        args_with_alias = self._alias_to_args(alias, args)
        key = self._key(name, args_with_alias)
        if not self._library_keywords.has_key(key):
            self._library_keywords[key] = [k.with_alias(alias) for k in self._get_library(name, args)]
        return self._library_keywords[key]

    def _alias_to_args(self, alias, args):
        if alias:
            if args:
                args = tuple(args) + ('WITH NAME', alias)
            else:
                args = ('WITH NAME', alias)
        return args

    def get_default_keywords(self):
        return self._default_kws[:]

    def _build_default_kws(self):
        kws = []
        for keywords_in_library in self._default_libraries.values():
            kws.extend(keywords_in_library)
        return kws

    def _get_default_libraries(self):
        default_libs = {}
        for libsetting in self._settings['auto imports'] + ['BuiltIn']:
            name, args = self._get_name_and_args(libsetting)
            default_libs[name] = self._get_library(name, args)
        return default_libs

    def _get_name_and_args(self, libsetting):
        parts = libsetting.split('|')
        if len(parts) == 1:
            return parts[0], None
        return parts[0], parts[1:]


class ExpiringCache(object):

    def __init__(self, timeout=0.5):
        self._cache = {}
        self._timeout = timeout

    def get(self, key):
        if key in self._cache:
            key_time, values = self._cache[key]
            if self._is_valid(key_time):
                return values
        return None

    def _is_valid(self, key_time):
        return (time.time() - key_time) < self._timeout

    def put(self, key, values):
        self._cache[key] = (time.time(), values)


    def _get_from_cache(self, source, name):
        try:
            return self._resource_files[name]
        except KeyError:
            path = normpath(os.path.join(os.path.dirname(source), name))
            return self._resource_files[path]

########NEW FILE########
__FILENAME__ = embeddedargs
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robot.running.userkeyword import EmbeddedArgsTemplate


class EmbeddedArgsHandler(EmbeddedArgsTemplate):

    def __init__(self, keyword):
        if keyword.arguments:
            raise TypeError('Cannot have normal arguments')
        self.embedded_args, self.name_regexp \
                = self._read_embedded_args_and_regexp(keyword.name)
        if not self.embedded_args:
            raise TypeError('Must have embedded arguments')

########NEW FILE########
__FILENAME__ = local_namespace
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robot.utils import normalize
from robotide.spec.iteminfo import LocalVariableInfo

def LocalNamespace(controller, namespace, row=None):
   if row is not None: # can be 0!
       return LocalRowNamespace(controller, namespace, row)
   return LocalMacroNamespace(controller, namespace)

class LocalMacroNamespace(object):

    def __init__(self, controller, namespace):
        self._controller = controller
        self._namespace = namespace

    def get_suggestions(self, start):
        return self._namespace.get_suggestions_for(self._controller, start)

    def has_name(self, value):
        for sug in self._namespace.get_suggestions_for(self._controller, value):
            if sug.name == value:
                return True
        return False

class LocalRowNamespace(LocalMacroNamespace):

    def __init__(self, controller, namespace, row):
        LocalMacroNamespace.__init__(self, controller, namespace)
        self._row = row

    def get_suggestions(self, start):
        suggestions = LocalMacroNamespace.get_suggestions(self, start)
        if self._could_be_variable(start):
            suggestions = self._harvest_local_variables(start, suggestions)
        else:
            suggestions = self._harvest_local_variables('${'+start, suggestions)
            suggestions = self._harvest_local_variables('@{'+start, suggestions)
        return suggestions

    def _harvest_local_variables(self, start, suggestions):
        matching_assignments = set()
        for row, step in enumerate(self._controller.steps):
            if self._row == row:
                break
            matching_assignments = matching_assignments.union(
                val.replace('=','').strip() for val in step.assignments if
                val.startswith(start))
        if matching_assignments:
            locals = [LocalVariableInfo(name) for name in matching_assignments]
            suggestions = sorted(self._remove_duplicates(suggestions, locals))
        return suggestions

    def _could_be_variable(self, start):
        return len(start) == 0 or start.startswith('$') or start.startswith('@')

    def has_name(self, value):
        if self._row is not None:
            for row, step in enumerate(self._controller.steps):
                if self._row == row:
                    break
                if step.is_assigning(value):
                    return True
        return LocalMacroNamespace.has_name(self, value)

    def _remove_duplicates(self, suggestions, locals):
        checked = [gvar for gvar in suggestions
                        if normalize(gvar.name) not in
                            [normalize(lvar.name) for lvar in locals]]
        return checked + locals

########NEW FILE########
__FILENAME__ = namespace
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import re
import operator
import tempfile
from itertools import chain

from robot.errors import DataError
from robot.parsing.model import ResourceFile
from robot.parsing.settings import Library, Resource, Variables
from robot.utils.normalizing import normalize
from robot.variables import Variables as RobotVariables
from robotide.namespace import variablefetcher
from robotide.namespace.cache import LibraryCache, ExpiringCache
from robotide.namespace.resourcefactory import ResourceFactory
from robotide.spec.iteminfo import (TestCaseUserKeywordInfo,
                                    ResourceUserKeywordInfo,
                                    VariableInfo, _UserKeywordInfo,
    ArgumentInfo)
from robotide.robotapi import NormalizedDict, is_var
from robotide.namespace.embeddedargs import EmbeddedArgsHandler


class Namespace(object):

    def __init__(self, settings):
        self._settings = settings
        self._library_manager = None
        self._init_caches()
        self._content_assist_hooks = []
        self._update_listeners = set()

    def _init_caches(self):
        self._lib_cache = LibraryCache(self._settings, self.update, self._library_manager)
        self._resource_factory = ResourceFactory(self._settings)
        self._retriever = DatafileRetriever(self._lib_cache, self._resource_factory)
        self._context_factory = _RetrieverContextFactory()

    def set_library_manager(self, library_manager):
        self._library_manager = library_manager
        self._lib_cache.set_library_manager(library_manager)

    def update(self, *args):
        self._retriever.expire_cache()
        self._context_factory = _RetrieverContextFactory()
        for listener in self._update_listeners:
            listener()

    def resource_filename_changed(self, old_name, new_name):
        self._resource_factory.resource_filename_changed(old_name, new_name)

    def reset_resource_and_library_cache(self):
        self._init_caches()

    def register_update_listener(self, listener):
        self._update_listeners.add(listener)

    def unregister_update_listener(self, listener):
        if listener in self._update_listeners:
            self._update_listeners.remove(listener)

    def clear_update_listeners(self):
        self._update_listeners.clear()

    def register_content_assist_hook(self, hook):
        self._content_assist_hooks.append(hook)

    def get_all_keywords(self, testsuites):
        kws = set()
        kws.update(self._get_default_keywords())
        kws.update(self._retriever.get_keywords_from_several(testsuites))
        return list(kws)

    def _get_default_keywords(self):
        return self._lib_cache.get_default_keywords()

    def get_suggestions_for(self, controller, start):
        datafile = controller.datafile
        ctx = self._context_factory.ctx_for_controller(controller)
        sugs = set()
        sugs.update(self._get_suggestions_from_hooks(datafile, start))
        if self._blank(start) or self._looks_like_variable(start):
            sugs.update(self._variable_suggestions(controller, start, ctx))
        else:
            sugs.update(self._variable_suggestions(controller, '${'+start, ctx))
            sugs.update(self._variable_suggestions(controller, '@{'+start, ctx))
        if self._blank(start) or not self._looks_like_variable(start):
            sugs.update(self._keyword_suggestions(datafile, start, ctx))
        sugs_list = list(sugs)
        sugs_list.sort()
        return sugs_list

    def _get_suggestions_from_hooks(self, datafile, start):
        sugs = []
        for hook in self._content_assist_hooks:
            sugs.extend(hook(datafile, start))
        return sugs

    def get_all_cached_library_names(self):
        return self._retriever.get_all_cached_library_names()

    def _blank(self, start):
        return start == ''

    def _looks_like_variable(self, start):
        return (len(start) == 1 and start.startswith('$') or start.startswith('@')) \
            or (len(start) >= 2 and start.startswith('${') or start.startswith('@{'))

    def _variable_suggestions(self, controller, start, ctx):
        datafile = controller.datafile
        start_normalized = normalize(start)
        self._add_kw_arg_vars(controller, ctx.vars)
        vars = self._retriever.get_variables_from(datafile, ctx)
        return (v for v in vars
                if normalize(v.name).startswith(start_normalized))

    def _add_kw_arg_vars(self, controller, vars):
        for name, value in controller.get_local_variables().iteritems():
            vars.set_argument(name, value)

    def _keyword_suggestions(self, datafile, start, ctx):
        start_normalized = normalize(start)
        return (sug for sug in chain(self._get_default_keywords(),
                                           self._retriever.get_keywords_from(datafile, ctx))
                      if sug.name_begins_with(start_normalized) or
                         sug.longname_begins_with(start_normalized))

    def get_resources(self, datafile):
        return self._retriever.get_resources_from(datafile)

    def get_resource(self, path, directory='', report_status=True):
        return self._resource_factory.get_resource(directory, path, report_status=report_status)

    def find_resource_with_import(self, imp):
        ctx = self._context_factory.ctx_for_datafile(imp.parent.parent)
        return self._resource_factory.get_resource_from_import(imp, ctx)

    def new_resource(self, path, directory=''):
        return self._resource_factory.new_resource(directory, path)

    def find_user_keyword(self, datafile, kw_name):
        kw = self.find_keyword(datafile, kw_name)
        return kw if isinstance(kw, _UserKeywordInfo) else None

    def is_user_keyword(self, datafile, kw_name):
        return bool(self.find_user_keyword(datafile, kw_name))

    def find_library_keyword(self, datafile, kw_name):
        kw = self.find_keyword(datafile, kw_name)
        return kw if kw and kw.is_library_keyword() else None

    def is_library_import_ok(self, datafile, imp):
        return self._retriever.is_library_import_ok(datafile, imp, self._context_factory.ctx_for_datafile(datafile))

    def is_variables_import_ok(self, datafile, imp):
        return self._retriever.is_variables_import_ok(datafile, imp, self._context_factory.ctx_for_datafile(datafile))

    def find_keyword(self, datafile, kw_name):
        if not kw_name:
            return None
        kwds = self._retriever.get_keywords_cached(datafile,
                                                   self._context_factory)
        return kwds.get(kw_name)

    def is_library_keyword(self, datafile, kw_name):
        return bool(self.find_library_keyword(datafile, kw_name))

    def keyword_details(self, datafile, name):
        kw = self.find_keyword(datafile, name)
        return kw.details if kw else None


class _RetrieverContextFactory(object):

    def __init__(self):
        self._context_cache = {}

    def ctx_for_controller(self, controller):
        if controller not in self._context_cache:
            self._context_cache[controller] = RetrieverContext()
            self._context_cache[controller.datafile] = self._context_cache[controller]
        return self._context_cache[controller]

    def ctx_for_datafile(self, datafile):
        if datafile not in self._context_cache:
            ctx = RetrieverContext()
            ctx.set_variables_from_datafile_variable_table(datafile)
            self._context_cache[datafile] = ctx
        return self._context_cache[datafile]


class RetrieverContext(object):

    def __init__(self):
        self.vars = _VariableStash()
        self.parsed = set()

    def set_variables_from_datafile_variable_table(self, datafile):
        self.vars.set_from_variable_table(datafile.variable_table)

    def replace_variables(self, text):
        return self.vars.replace_variables(text)

    def allow_going_through_resources_again(self):
        """Resets the parsed-cache.
        Normally all resources that have been handled are added to 'parsed' and
        then not handled again, to prevent looping forever. If this same context
        is used for going through the resources again, then you should call
        this.
        """
        self.parsed = set()


class _VariableStash(object):
    # Global variables copied from robot.variables.__init__.py
    global_variables =  {'${TEMPDIR}': os.path.normpath(tempfile.gettempdir()),
                         '${EXECDIR}': os.path.abspath('.'),
                         '${/}': os.sep,
                         '${:}': os.pathsep,
                         '${SPACE}': ' ',
                         '${EMPTY}': '',
                         '${True}': True,
                         '${False}': False,
                         '${None}': None,
                         '${null}': None,
                         '${OUTPUT_DIR}': '',
                         '${OUTPUT_FILE}': '',
                         '${SUMMARY_FILE}': '',
                         '${REPORT_FILE}': '',
                         '${LOG_FILE}': '',
                         '${DEBUG_FILE}': '',
                         '${PREV_TEST_NAME}': '',
                         '${PREV_TEST_STATUS}': '',
                         '${PREV_TEST_MESSAGE}': '',
                         '${CURDIR}': '.',
                         '${TEST_NAME}': '',
                         '@{TEST_TAGS}': '',
                         '${TEST_STATUS}': '',
                         '${TEST_MESSAGE}': '',
                         '${SUITE_NAME}': '',
                         '${SUITE_SOURCE}': '',
                         '${SUITE_STATUS}': '',
                         '${SUITE_MESSAGE}': ''}

    ARGUMENT_SOURCE = object()

    def __init__(self):
        self._vars = RobotVariables()
        self._sources = {}
        for k, v in self.global_variables.iteritems():
            self.set(k, v, 'built-in')

    def set(self, name, value, source):
        self._vars[name] = value
        self._sources[name] = source

    def set_argument(self, name, value):
        self.set(name, value, self.ARGUMENT_SOURCE)

    def replace_variables(self, value):
        try:
            return self._vars.replace_scalar(value)
        except DataError:
            return self._vars.replace_string(value, ignore_errors=True)

    def set_from_variable_table(self, variable_table):
        for variable in variable_table:
            try:
                if not self._vars.has_key(variable.name):
                    _, value = self._vars._get_var_table_name_and_value(
                        variable.name,
                        variable.value)
                    self.set(variable.name, value, variable_table.source)
            except DataError:
                if is_var(variable.name):
                    self.set(variable.name, '', variable_table.source)

    def set_from_file(self, varfile_path, args):
        for item in variablefetcher.import_varfile(varfile_path, args):
            self.set(*item)

    def __iter__(self):
        for name, value in self._vars.items():
            source = self._sources[name]
            if source == self.ARGUMENT_SOURCE:
                yield ArgumentInfo(name, value)
            else:
                yield VariableInfo(name, value, source)


class DatafileRetriever(object):

    def __init__(self, lib_cache, resource_factory):
        self._lib_cache = lib_cache
        self._resource_factory = resource_factory
        self.keyword_cache = ExpiringCache()
        self._default_kws = None

    def get_all_cached_library_names(self):
        return self._lib_cache.get_all_cached_library_names()

    @property
    def default_kws(self):
        if self._default_kws is None:
            self._default_kws = self._lib_cache.get_default_keywords()
        return self._default_kws

    def expire_cache(self):
        self.keyword_cache = ExpiringCache()
        self._lib_cache.expire()

    def get_keywords_from_several(self, datafiles):
        kws = set()
        kws.update(self.default_kws)
        for df in datafiles:
            kws.update(self.get_keywords_from(df, RetrieverContext()))
        return kws

    def get_keywords_from(self, datafile, ctx):
        self._get_vars_recursive(datafile, ctx)
        ctx.allow_going_through_resources_again()
        return sorted(set(self._get_datafile_keywords(datafile) +\
              self._get_imported_resource_keywords(datafile, ctx) +\
              self._get_imported_library_keywords(datafile, ctx)))

    def is_library_import_ok(self, datafile, imp, ctx):
        self._get_vars_recursive(datafile, ctx)
        return bool(self._lib_kw_getter(imp, ctx))

    def is_variables_import_ok(self, datafile, imp, ctx):
        self._get_vars_recursive(datafile, ctx)
        return self._import_vars(ctx, datafile, imp)

    def _get_datafile_keywords(self, datafile):
        if isinstance(datafile, ResourceFile):
            return [ResourceUserKeywordInfo(kw) for kw in datafile.keywords]
        return [TestCaseUserKeywordInfo(kw) for kw in datafile.keywords]

    def _get_imported_library_keywords(self, datafile, ctx):
        return self._collect_kws_from_imports(datafile, Library,
                                              self._lib_kw_getter, ctx)

    def _collect_kws_from_imports(self, datafile, instance_type, getter, ctx):
        kws = []
        for imp in self._collect_import_of_type(datafile, instance_type):
            kws.extend(getter(imp, ctx))
        return kws

    def _lib_kw_getter(self, imp, ctx):
        name = ctx.replace_variables(imp.name)
        name = self._convert_to_absolute_path(name, imp)
        args = [ctx.replace_variables(a) for a in imp.args]
        alias = ctx.replace_variables(imp.alias) if imp.alias else None
        return self._lib_cache.get_library_keywords(name, args, alias)

    def _convert_to_absolute_path(self, name, import_):
        full_name = os.path.join(import_.directory, name)
        if os.path.exists(full_name):
            return full_name
        return name

    def _collect_import_of_type(self, datafile, instance_type):
        return [imp for imp in datafile.imports
                if isinstance(imp, instance_type)]

    def _get_imported_resource_keywords(self, datafile, ctx):
        return self._collect_kws_from_imports(datafile, Resource,
                                              self._res_kw_recursive_getter, ctx)

    def _res_kw_recursive_getter(self, imp, ctx):
        kws = []
        res = self._resource_factory.get_resource_from_import(imp, ctx)
        if not res or res in ctx.parsed:
            return kws
        ctx.parsed.add(res)
        ctx.set_variables_from_datafile_variable_table(res)
        for child in self._collect_import_of_type(res, Resource):
            kws.extend(self._res_kw_recursive_getter(child, ctx))
        kws.extend(self._get_imported_library_keywords(res, ctx))
        return [ResourceUserKeywordInfo(kw) for kw in res.keywords] + kws

    def get_variables_from(self, datafile, ctx=None):
        return self._get_vars_recursive(datafile, ctx or RetrieverContext()).vars

    def _get_vars_recursive(self, datafile, ctx):
        ctx.set_variables_from_datafile_variable_table(datafile)
        self._collect_vars_from_variable_files(datafile, ctx)
        self._collect_each_res_import(datafile, ctx, self._var_collector)
        return ctx

    def _collect_vars_from_variable_files(self, datafile, ctx):
        for imp in self._collect_import_of_type(datafile, Variables):
            self._import_vars(ctx, datafile, imp)

    def _import_vars(self, ctx, datafile, imp):
        varfile_path = os.path.join(datafile.directory,
            ctx.replace_variables(imp.name))
        args = [ctx.replace_variables(a) for a in imp.args]
        try:
            ctx.vars.set_from_file(varfile_path, args)
            return True
        except DataError:
            return False # TODO: log somewhere

    def _var_collector(self, res, ctx, items):
        self._get_vars_recursive(res, ctx)

    def get_keywords_cached(self, datafile, context_factory):
        values = self.keyword_cache.get(datafile.source)
        if not values:
            words = self.get_keywords_from(datafile, context_factory.ctx_for_datafile(datafile))
            words.extend(self.default_kws)
            values = _Keywords(words)
            self.keyword_cache.put(datafile.source, values)
        return values

    def _get_user_keywords_from(self, datafile):
        return list(self._get_user_keywords_recursive(datafile, RetrieverContext()))

    def _get_user_keywords_recursive(self, datafile, ctx):
        kws = set()
        kws.update(datafile.keywords)
        kws_from_res = self._collect_each_res_import(datafile, ctx,
            lambda res, ctx, kws: kws.update(self._get_user_keywords_recursive(res, ctx)))
        kws.update(kws_from_res)
        return kws

    def _collect_each_res_import(self, datafile, ctx, collector):
        items = set()
        ctx.set_variables_from_datafile_variable_table(datafile)
        for imp in self._collect_import_of_type(datafile, Resource):
            res = self._resource_factory.get_resource_from_import(imp, ctx)
            if res and res not in ctx.parsed:
                ctx.parsed.add(res)
                collector(res, ctx, items)
        return items

    def get_resources_from(self, datafile):
        resources = list(self._get_resources_recursive(datafile, RetrieverContext()))
        resources.sort(key=operator.attrgetter('name'))
        return resources

    def _get_resources_recursive(self, datafile, ctx):
        resources = set()
        res = self._collect_each_res_import(datafile, ctx, self._add_resource)
        resources.update(res)
        for child in datafile.children:
            resources.update(self.get_resources_from(child))

        return resources

    def _add_resource(self, res, ctx, items):
        items.add(res)
        items.update(self._get_resources_recursive(res, ctx))


class _Keywords(object):

    regexp = re.compile("\s*(given|when|then|and)\s*(.*)", re.IGNORECASE)

    def __init__(self, keywords):
        self.keywords = NormalizedDict(ignore=['_'])
        self.embedded_keywords = {}
        self._add_keywords(keywords)

    def _add_keywords(self, keywords):
        for kw in keywords:
            self._add_keyword(kw)

    def _add_keyword(self, kw):
        # TODO: this hack creates a preference for local keywords over resources and libraries
        # Namespace should be rewritten to handle keyword preference order
        if kw.name not in self.keywords:
            self.keywords[kw.name] = kw
            self._add_embedded(kw)
        self.keywords[kw.longname] = kw

    def _add_embedded(self, kw):
        if '$' not in kw.name:
            return
        try:
            handler = EmbeddedArgsHandler(kw)
            self.embedded_keywords[handler.name_regexp] = kw
        except Exception:
            pass

    def get(self, kw_name):
        if kw_name in self.keywords:
            return self.keywords[kw_name]
        bdd_name = self._get_bdd_name(kw_name)
        if bdd_name and bdd_name in self.keywords:
            return self.keywords[bdd_name]
        for regexp in self.embedded_keywords:
            if regexp.match(kw_name) or (bdd_name and regexp.match(bdd_name)):
                return self.embedded_keywords[regexp]
        return None

    def _get_bdd_name(self, kw_name):
        match = self.regexp.match(kw_name)
        return match.group(2) if match else None


########NEW FILE########
__FILENAME__ = resourcefactory
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys
from robot.parsing.model import ResourceFile
from robot.parsing.populators import FromFilePopulator

from robotide import utils


class ResourceFactory(object):
    _IGNORE_RESOURCE_DIRECTORY_SETTING_NAME = 'ignored resource directory'

    def __init__(self, settings):
        self.cache = {}
        self.python_path_cache = {}
        self._excludes = settings.excludes
        self.check_path_from_excludes = self._excludes.contains
        self._set_pythonpath(settings.get('pythonpath', []))
        settings.add_change_listener(self)

    def _with_separator(self, dir):
        return os.path.abspath(dir)+os.path.sep

    def _set_pythonpath(self, values):
        for path in values:
            if path not in sys.path:
                sys.path.insert(0, path.replace('/', os.sep))

    def setting_changed(self, name, old_value, new_value):
        if name == 'pythonpath':
            self._set_pythonpath(new_value)

    def get_resource(self, directory, name, report_status=True):
        path = self._build_path(directory, name)
        res = self._get_resource(path, report_status=report_status)
        if res:
            return res
        path_from_pythonpath = self._get_python_path(name)
        if path_from_pythonpath:
            return self._get_resource(path_from_pythonpath, report_status=report_status)
        return None

    def _build_path(self, directory, name):
        path = os.path.join(directory, name) if directory else name
        return os.path.abspath(path)

    def get_resource_from_import(self, import_, retriever_context):
        resolved_name = retriever_context.vars.replace_variables(import_.name)
        return self.get_resource(import_.directory, resolved_name)

    def new_resource(self, directory, name):
        path = os.path.join(directory, name) if directory else name
        path = self._normalize(path)
        resource = ResourceFile(source=path)
        self.cache[path] = resource
        return resource

    def resource_filename_changed(self, old_name, new_name):
        self.cache[self._normalize(new_name)] = self._get_resource(old_name, report_status=True)
        del self.cache[self._normalize(old_name)]

    def _get_python_path(self, name):
        if name not in self.python_path_cache:
            path_from_pythonpath = utils.find_from_pythonpath(name)
            self.python_path_cache[name] = path_from_pythonpath
        return self.python_path_cache[name]

    def _get_resource(self, path, report_status):
        normalized = self._normalize(path)
        if self.check_path_from_excludes(path) or self.check_path_from_excludes(normalized):
            return None
        if normalized not in self.cache:
            try:
                self.cache[normalized] = self._load_resource(path, report_status=report_status)
            except Exception:
                self.cache[normalized] = None
                return None
        return self.cache[normalized]

    def _load_resource(self, path, report_status):
        r = ResourceFile(path)
        if os.stat(path)[6]!=0 and report_status:
            return r.populate()
        FromFilePopulator(r).populate(r.source)
        return r

    def _normalize(self, path):
        return os.path.normcase(os.path.normpath(os.path.abspath(path)))

########NEW FILE########
__FILENAME__ = suggesters
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robot.running.namespace import STDLIB_NAMES


class SuggestionSource(object):

    def __init__(self, plugin, controller):
        self._plugin = plugin
        self._controller = controller

    def get_suggestions(self, value, row=None):
        if self._controller:
            return self._controller.get_local_namespace_for_row(row).get_suggestions(value)
        return self._plugin.content_assist_values(value) # TODO: Remove old functionality when no more needed


class _Suggester(object):

    def _suggestion(self, name):
        s = lambda:0
        s.name = name
        s.longname = name
        s.details = None
        return s


class HistorySuggester(_Suggester):

    def __init__(self):
        self._suggestions = []

    def get_suggestions(self, name, *args):
        return [s for s in self._suggestions if name is None or name.lower() in s.name.lower()]

    def store(self, name):
        self._suggestions += [self._suggestion(name)]
        self._suggestions.sort()


class _ImportSuggester(_Suggester):

    def __init__(self, controller):
        self._df_controller = controller.datafile_controller

    def get_suggestions(self, name, *args):
        already_imported = self._get_already_imported()
        all_resources = self._get_all_available()
        suggestion_names = all_resources - already_imported
        return [self._suggestion(n) for n in sorted(suggestion_names) if name in n]

    def _get_already_imported(self):
        return set(imp.name  for imp in self._df_controller.imports)


class ResourceSuggester(_ImportSuggester):

    def _get_all_available(self):
        return set(self._df_controller.relative_path_to(r) for r in self._df_controller._chief_controller.resources)


class CachedLibrarySuggester(_ImportSuggester):

    def _get_all_available(self):
        return set(self._df_controller.get_all_cached_library_names())


class BuiltInLibrariesSuggester(_Suggester):

    def get_suggestions(self, name, *args):
        return [self._suggestion(n) for n in sorted(STDLIB_NAMES)
                if name.lower() in n.lower() and n not in ['BuiltIn', 'Reserved', 'Easter']]


class LibrariesSuggester(_Suggester):

    def __init__(self, controller, history_suggester):
        self._history_suggester = history_suggester
        self._cached_suggester = CachedLibrarySuggester(controller)
        self._builtin_suggester = BuiltInLibrariesSuggester()

    def get_suggestions(self, name, *args):
        history = set(h.name for h in self._history_suggester.get_suggestions(name, *args))
        cached = set(c.name for c in self._cached_suggester.get_suggestions(name, *args))
        builtin = set(b.name for b in self._builtin_suggester.get_suggestions(name, *args))
        already_imported = self._cached_suggester._get_already_imported()
        return [self._suggestion(s)
                for s in sorted((history | cached | builtin)-already_imported,
                key=lambda s: s.lower())]

########NEW FILE########
__FILENAME__ = variablefetcher
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robot.errors import DataError
from robot.variables import Variables as RobotVariables

# NOTE! This is in own module to reduce the number of dependencies as this is executed in another process

def import_varfile(varfile_path, args):
    temp = RobotVariables()
    try:
        temp.set_from_file(varfile_path, args)
    except SystemExit:
        raise DataError('Variable file import failed')
    return [(name, _format_value(value), varfile_path) for (name, value) in temp.items()]

# Must be pickable
def _format_value(value):
    if isinstance(value, basestring):
        return value
    if isinstance(value, list):
        return u'[ %s ]' % u' | '.join(unicode(v) for v in value)
    return unicode(value)

########NEW FILE########
__FILENAME__ = plugin
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import inspect
from robotide.action.actioninfo import ActionInfo

from robotide.publish import PUBLISHER
from robotide import utils


class Plugin(object):
    """Entry point to RIDE plugin API -- all plugins must extend this class.

    Plugins can use the helper methods implemented in this class to interact
    with the core application. The methods and their arguments are kept stable
    across the different RIDE releases to the extent that it is possible.

    If the provided methods are not enough, plugins can also interact with the
    core directly using properties `tree`, `menubar`, `toolbar`, `notebook` and
    `model`. Although these attributes themselves are stable, the functionality
    behind them may still change between releases. Users are thus recommended
    to propose new helper methods, preferably with patches, for often needed
    functionality that is only available through these properties.

    :IVariables:
      name
        Plugin name. Set in `__init__` based on the given name or the class name.
      doc
        Plugin documentation. Set in `__init__` based on the given doc or
        the class docstring.
      metadata
        Plugin metadata. Set in `__init__` based on the given metadata.
      initially_enabled
        Specifies should the plugin be enabled when first loaded.
        Set in `__init__`.
    """

    tree = property(lambda self: self.__frame.tree,
                    doc='Provides access to the suite and resource tree')
    menubar = property(lambda self: self.__frame.GetMenuBar(),
                       doc='Provides access to the application menubar')
    toolbar = property(lambda self: self.__frame.GetToolBar(),
                       doc='Provides access to the application toolbar')
    notebook = property(lambda self: self.__frame.notebook,
                        doc='Provides access to the tabbed notebook')
    model = property(lambda self: self.__app.model,
                     doc='Provides access to the data model')
    frame = property(lambda self: self.__frame,
                     doc='Reference to the RIDE main frame')
    datafile = property(lambda self: self.get_selected_datafile(),
                        doc='Currently selected datafile')
    global_settings = property(lambda self: self.__app.settings,
                               doc='Settings read from settings.cfg')

    def __init__(self, application, name=None, doc=None, metadata=None,
                 default_settings=None, initially_enabled=True):
        """Initialize the plugin with the provided data.

        The provided information is mainly used by the plugin manager. Simple
        plugins are often fine with the defaults. If this method is overridden,
        the plugin must call it explicitly::

            from robotide.pluginapi import Plugin

            class MyCoolPluginExample(Plugin):
                \"\"\"This extra cool docstring is used as the plugin doc.\"\"\"
                def __init__(self, application):
                    Plugin.__init__(self, application, metadata={'version': '0.1'},
                                    default_settings={'color': 'red', 'x': 42})

        Plugins should not create any user interface elements at this point but
        wait until the `enable` method is called.

        :Parameters:
          application
            RIDE application reference.
          name
            Name of the plugin. If not specified, the name is got from the
            plugin class name dropping possible ``Plugin`` from the end.
          doc
            Plugin documentation. If not specified, the doc is got from the
            plugin class docstring.
          metadata
            A dictionary of free metadata shown on the plugin manager. Values
            containing URLs will be shown as links.
          default_settings
            A dictionary of settings and their default values. Settings are
            automatically stored onto RIDE configuration file, can be
            accessed using direct attribute access via `__getattr__`, and new
            settings can be saved using `save_setting`.
          initially_enabled
            Specifies should the plugin be enabled when loaded for the first
            time. Users can change the status later from the plugin manager.
        """
        self.name = name or utils.name_from_class(self, drop='Plugin')
        self.doc = self._get_doc(doc)
        self.metadata = metadata or {}
        self.initially_enabled = initially_enabled
        self._save_timer = None
        self.__app = application
        self.__frame = application.frame
        self.__namespace = application.namespace
        self.__settings = application.settings['Plugins'].add_section(self.name)
        self.__settings.set_defaults(default_settings)
        self.__actions = []

    def _get_doc(self, given_doc):
        if given_doc:
            return given_doc
        if self.__doc__ == Plugin.__doc__:
            return ''
        return inspect.getdoc(self) or ''

    def __getattr__(self, name):
        """Provides convenient attribute access to saved settings.

        For example, setting ``color`` can be accessed directly like
        ``self.color``.
        """
        if '__settings' not in name and self.__settings.has_setting(name):
            return self.__settings[name]
        raise AttributeError("No attribute or settings with name '%s' found" % name)

    def save_setting(self, name, value, override=True, delay=0):
        """Saves the specified setting into the RIDE configuration file.

        ``override`` controls whether a possibly already existing value is
        overridden or not. Saved settings can be accessed using direct attribute
        access via `__getattr__`.
        ``delay`` is number defining how many seconds is waited before setting
        is saved. This can be used to prevent saving the value while user is
        typing it.
        """
        self.__settings.set(name, value, autosave=delay == 0, override=override)
        self._delay_saving(delay)

    def _delay_saving(self, delay):
        if not delay:
            return
        delay = delay * 1000
        if not self._save_timer:
            self._save_timer = wx.CallLater(delay, self._save_setting_after_delay)
        else:
            self._save_timer.Restart(delay)

    def _save_setting_after_delay(self):
        self.__settings.save()
        self._save_timer = None

    def enable(self):
        """This method is called by RIDE when the plugin is enabled.

        Possible integration to UI should be done in this method and removed
        when the `disable` method is called.
        """
        pass

    def disable(self):
        """Called by RIDE when the plugin is disabled.

        Undo whatever was done in the `enable` method.
        """
        pass

    def config_panel(self, parent):
        """Called by RIDE to get the plugin configuration panel.

        The panel returned will be integrated into the plugin manager UI, and
        can be used e.g. to display configurable settings.

        By default there is no configuration panel.
        """
        return None

    def register_action(self, action_info):
        """Registers a menu entry and optionally a shortcut and a toolbar icon.

        ``action_info`` is an instance of `ActionInfo` class containing needed
        information to create menu entry, keyboard shortcut and/or toolbar
        button for the action.

        All registered actions can be un-registered using the
        `unregister_actions` method.

        If register action is used in menu event handler and it modifies the
        menu that triggered the event, it is safest to wrap register action
        call inside wx.CallAfter function.

        Returns created `Action` object.
        """
        action = self.__frame.actions.register_action(action_info)
        self.__actions.append(action)
        return action

    def register_shortcut(self, shortcut, callback):
        action_info = ActionInfo(None, None, action=callback, shortcut=shortcut)
        action = self.__frame.actions.register_shortcut(action_info)
        self.__actions.append(action)
        return action

    def register_actions(self, action_infos):
        """Registers multiple menu entries and shortcuts/icons.

        ``action_infos`` is a list of same `ActionInfo` objects that
        `register_action` method accepts.

        Returns list of created `Action` objects.
        """
        return [self.register_action(info) for info in action_infos]

    def register_search_action(self, description, handler, icon, default=False):
        self.__frame.toolbar.register_search_handler(description, handler, icon, default=default)

    def unregister_actions(self):
        """Unregisters all actions registered by this plugin."""
        for action in self.__actions:
            action.unregister()
        self.__actions = []

    def add_tab(self, tab, title, allow_closing=True):
        """Adds the ``tab`` with the ``title`` to the tabbed notebook and shows it.

        The ``tab`` can be any wxPython container. ``allow_closing`` defines
        can users close the tab while the plugin is enabled.
        """
        self.notebook.add_tab(tab, title, allow_closing)

    def show_tab(self, tab):
        """Makes the ``tab`` added using `add_tab` visible."""
        self.notebook.show_tab(tab)

    def delete_tab(self, tab):
        """Deletes the ``tab`` added using `add_tab`."""
        self.notebook.delete_tab(tab)

    def allow_tab_closing(self, tab):
        """Allows closing a tab that has been created using allow_closing=False."""
        self.notebook.allow_closing(tab)

    def disallow_tab_closing(self, tab):
        """Disallows closing a tab by user"""
        self.notebook.disallow_closing(tab)

    def tab_is_visible(self, tab):
        """Returns is the ``tab`` added using `add_tab` visible or not."""
        return self.notebook.tab_is_visible(tab)

    def new_suite_can_be_opened(self):
        """Checks are there modified files and asks user what to do if there are.

        Returns False if there were modified files and user canceled the dialog,
        otherwise returns True.
        """
        return self.__app.ok_to_open_new()

    def open_suite(self, path):
        """Opens a test suite specified by the ``path``.

        No suite is opened if parsing the suite fails.
        """
        self.__frame.open_suite(path)

    def get_selected_datafile(self):
        """Returns the data file that is currently selected in the tree.

        If a test case or a keyword is selected, the data file containing the
        selected item is returned.

        :rtype:
            `InitFile`, `TestCaseFile` or `ResourceFile`
        """
        return self.tree.get_selected_datafile()

    def save_selected_datafile(self):
        """Saves the data file that is currently selected in the tree.

        If a test case or a keyword is selected, the data file containing the
        selected item is saved.
        """
        self.__frame.save(self.tree.get_selected_datafile_controller())

    def is_unsaved_changes(self):
        """Returns True if there is any unsaved changes, otherwise False"""
        return self.__frame.has_unsaved_changes()

    def save_all_unsaved_changes(self):
        """Saves all the data files that are modified."""
        self.__frame.save_all()


    def get_selected_item(self):
        """Returns the item that is currently selected in the tree.

        The item can be a test suite, a resource file, a test case or a keyword.

        :rtype:
            `InitFile`, `TestCaseFile`, `ResourceFile`, `TestCase` or `UserKeyword`
        """
        return self.tree.get_selected_item()

    def content_assist_values(self, value=''):
        """Returns content assist values for currently selected item."""
        return self.__namespace.get_suggestions_for(self.get_selected_item(), value)

    def get_user_keyword(self, name):
        """Returns user keyword instance whose name is ``name`` or None."""
        keyword_info = self.__namespace.find_user_keyword(self.datafile, name)
        return keyword_info.item if keyword_info else None

    def select_user_keyword_node(self, uk):
        """Selects node containing the given ``uk`` in the tree."""
        self.tree.select_user_keyword_node(uk)

    def get_keyword(self, name):
        """Returns the keyword object with the given name or None"""
        return self.__namespace.find_keyword(self.datafile, name)

    def get_keyword_details(self, name):
        """Returns details (documentation, source) of keyword with name ``name``.

        Returns None if no matching keyword is found.
        """
        return self.__namespace.keyword_details(self.datafile, name)

    def is_user_keyword(self, name):
        """Returns whether ``name`` is a user keyword of current datafile.

        Checks both the datafile's own and imported user keywords for match.
        """
        return self.__namespace.is_user_keyword(self.datafile, name)

    def is_library_keyword(self, name):
        """Returns whether ``name`` is a keyword imported by current datafile."""
        return self.__namespace.is_library_keyword(self.datafile, name)

    def all_testcases(self):
        """Returns all test cases from all suites in one, unsorted list"""
        return self.model.all_testcases()

    def register_content_assist_hook(self, hook):
        """Allows plugin to insert values in content assist dialog.

        ``hook`` must be a callable, which should take two arguments and
        return a list of instances of `ItemInfo` class. When content
        assist is requested by user, ``hook`` will be called with the current
        dataitem and current value of cell as parameters.
        """
        self.__namespace.register_content_assist_hook(hook)

    def get_plugins(self):
        """Returns list containing plugin wrapper for every loaded plugin.

        Wrapper is an instance of `PluginConnector` if the plugin has loaded
        successfully, otherwise it's an instance of `BrokenPlugin`."""
        return self.__app.get_plugins()

    def publish(self, topic, data):
        """Publishes a message with given topic and client data.

        Purpose of this method is to support inter-plugin communication which
        is not possible to achieve using custom message classes.

        `data` will be passed as an argument to registered listener methods.
        """
        PUBLISHER.publish(topic, data)

    def subscribe(self, listener, *topics):
        """Start to listen to messages with the given ``topics``.

        See the documentation of the `robotide.publish` module for more
        information about subscribing to messages and the messaging system

        `unsubscribe` and `unsubscribe_all` can be used to stop listening to
        certain or all messages.
        """
        for topic in topics:
            PUBLISHER.subscribe(listener, topic, key=self)

    def unsubscribe(self, listener, *topics):
        """Stops listening to messages with the given ``topics``.

        ``listener`` and ``topics`` have the same meaning as in `subscribe`
        and a listener/topic combination is unsubscribed only when both of them
        match.
        """
        for topic in topics:
            PUBLISHER.unsubscribe(listener, topic, key=self)

    def unsubscribe_all(self):
        """Stops to listen to all messages this plugin has subscribed to."""
        PUBLISHER.unsubscribe_all(key=self)

    def register_editor(self, item_class, editor_class, activate=True):
        """Register ``editor_class`` as an editor class for model items of type ``item_class``

        If ``activate`` is True, the given editor is automatically activated
        using `set_active_editor`.
        """
        self.__app.register_editor(item_class, editor_class, activate)

    def unregister_editor(self, item_class, editor_class):
        """Unregisters ``editor_class`` as an editor class for model items of type ``item_class``"""
        self.__app.unregister_editor(item_class, editor_class)

    def set_active_editor(self, item_class, editor_class):
        """Activates the specified editor to be used with the specified model item.

        The editor must have been registered first by using `register_editor`.
        """
        self.__app.activate_editor(item_class, editor_class)

    def get_editors(self, item_class):
        """Return all registered editors for the given model item class.

        The last editor in the list is the currently active editor.
        """
        return self.__app.get_editors(item_class)

    def get_editor(self, item_class):
        """Return the current editor class for the given model item class"""
        return self.__app.get_editor(item_class)

    def highlight_cell(self, tcuk, obj=None, row=-1, column=-1):
        '''Highlight a specific row/column of a test case or user keyword'''
        self.tree.select_node_by_data(tcuk)
        self.__app.editor.highlight_cell(obj, row, column)

    def highlight(self, data, text):
        '''Highlight a specific text of a given data's editor'''
        self.tree.highlight(data, text)

########NEW FILE########
__FILENAME__ = tree_aware_plugin_mixin
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.publish.messages import RideMessage


class RideTreeAwarePluginAdded(RideMessage):
    data = ['plugin']


class TreeAwarePluginMixin(object):
    """
    Mixin to help solve if tree aware plugin has focus

    The plugin that inherits this Mixin must be a Plugin and also it must
    offer a method #is_focused -> bool

    To properly initialize this Mixin the Plugin in question must
    #add_self_as_tree_aware_plugin

    To properly teardown this Mixin the Plugin in question must
    #remove_self_from_tree_aware_plugins

    To check if one of the other three aware plugins has focus
    #is_focus_on_tree_aware_plugin

    NOTE: Could be used for more generic purpose for grouping
    plugins and interacting with them
    """

    _tree_aware_plugins_set = None

    def is_focus_on_tree_aware_plugin(self):
        return any(twb.is_focused() for twb in self._tree_aware_plugins)

    def add_self_as_tree_aware_plugin(self):
        RideTreeAwarePluginAdded(plugin=self).publish()
        self.subscribe(self._tree_aware_plugin_added, RideTreeAwarePluginAdded)

    def remove_self_from_tree_aware_plugins(self):
        self.unsubscribe(self._tree_aware_plugin_added, RideTreeAwarePluginAdded)
        for other in self._tree_aware_plugins:
            other.remove_tree_aware_plugin(self)

    def add_tree_aware_plugin(self, other):
        self._tree_aware_plugins.add(other)

    def remove_tree_aware_plugin(self, other):
        self._tree_aware_plugins.remove(other)

    def _tree_aware_plugin_added(self, message=None):
        self.add_tree_aware_plugin(message.plugin)
        message.plugin.add_tree_aware_plugin(self)

    @property
    def _tree_aware_plugins(self):
        if self._tree_aware_plugins_set is None:
            self._tree_aware_plugins_set = set()
        return self._tree_aware_plugins_set

########NEW FILE########
__FILENAME__ = colors
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import ConfigParser
import wx
from os.path import abspath, dirname, join

from robotide.preferences import PreferencesPanel, PreferencesColorPicker
from robotide.preferences.saving import IntegerChoiceEditor


class ColorPreferences(PreferencesPanel):

    def __init__(self, font_label, font_setting_key, settings, *args, **kwargs):
        super(ColorPreferences, self).__init__(*args, **kwargs)
        self._settings = settings
        # N.B. There really ought to be a "reset colors to defaults"
        # button, in case the user gets things hopelessly mixed up

        # what would make this UI much more usable is if there were a
        # preview window in the dialog that showed all the colors. I
        # don't have the time to do that right now, so this will have
        # to suffice.

        font_size_sizer = self._create_font_size_sizer(settings, font_setting_key, font_label)
        colors_sizer = self.create_colors_sizer()
        main_sizer = wx.FlexGridSizer(rows=2, cols=1, hgap=10)
        main_sizer.Add(font_size_sizer)
        main_sizer.Add(colors_sizer)
        self.SetSizer(main_sizer)

    def _create_font_size_sizer(self, settings, settings_key, title='Font Size'):
        f = IntegerChoiceEditor(settings,
                                settings_key,
                                title,
                                [str(i) for i in range(8, 49)]
        )
        font_size_sizer = wx.FlexGridSizer(rows=1, cols=1)
        font_size_sizer.AddMany([f.label(self), (f.chooser(self),)])
        return font_size_sizer

    def create_colors_sizer(self):
        raise NotImplementedError('Implement me')

class TextEditColorPreferences(ColorPreferences):
    location = ("Text Edit Colors and Font Size",)
    title = "Text Edit Colors and Font Size"

    def __init__(self, settings, *args, **kwargs):
        self._color_pickers = [] # must be before super class constructor call
        super(TextEditColorPreferences, self).__init__('Text Edit Font Size',
                                                       'text edit font size', settings, *args, **kwargs)


    def create_colors_sizer(self):
        container = wx.GridBagSizer()
        column = 0
        row = 0
        for settings_key, label_text in (
            ('argument',  'Argument foreground'),
            ('comment', 'Comment foreground'),
            ('error',  'Error foreground'),
            ('gherkin', 'Gherkin keyword foreground'),
            ('heading', 'Heading foreground'),
            ('import', 'Import foreground'),
            ('separator', 'Separator'),
            ('setting',  'Setting foreground'),
            ('syntax', 'Syntax characters'),
            ('tc_kw_name', 'Keyword definition foreground'),
            ('variable',  'Variable foreground'),
        ):
            if column == 4:
                column = 0
                row += 1
            label = wx.StaticText(self, wx.ID_ANY, label_text)
            button = PreferencesColorPicker(self, wx.ID_ANY, self._settings['Text Edit Colors'], settings_key)
            container.Add(button, (row, column), flag=wx.ALL|wx.ALIGN_CENTER_VERTICAL, border=4)
            self._color_pickers.append(button)
            column += 1
            container.Add(label, (row, column), flag=wx.ALIGN_CENTER_VERTICAL|wx.LEFT, border=4)
            column += 1
        reset = wx.Button(self, wx.ID_ANY, 'Reset colors to default')
        self.Bind(wx.EVT_BUTTON, self.OnReset)
        container.Add(reset, (row + 1, 0))
        return container

    def OnReset(self, event):
        defaults = self._read_defaults()
        for picker in self._color_pickers:
            picker.SetColour(defaults[picker.key])

    def _read_defaults(self):
        settings = [s.strip() for s in open(self._get_path(), 'r').readlines()]
        start_index = settings.index('[Text Edit Colors]') + 1
        defaults = {}
        for line in settings[start_index:]:
            if line.startswith('['):
                break
            if not line:
                continue
            key, value = [s.strip().strip('\'') for s in line.split("=")]
            defaults[key] = value
        return defaults

    def _get_path(self):
        return join(dirname(abspath(__file__)), 'settings.cfg')


class GridColorPreferences(ColorPreferences):
    location = ("Grid Colors and Font Size",)
    title = "Grid Colors and Font Size"

    def __init__(self, settings, *args, **kwargs):
        super(GridColorPreferences, self).__init__('Grid Font Size', 'font size', settings, *args, **kwargs)

    def create_colors_sizer(self):
        colors_sizer = wx.GridBagSizer()
        self._create_foreground_pickers(colors_sizer)
        self._create_background_pickers(colors_sizer)
        return colors_sizer

    def _create_foreground_pickers(self, colors_sizer):
        row = 0
        for key, label in (
            ('text user keyword', 'User Keyword Foreground'),
            ('text library keyword', 'Library Keyword Foreground'),
            ('text commented', 'Comments Foreground'),
            ('text variable', 'Variable Foreground'),
            ('text string', 'Default Foreground'),
            ('text empty', 'Empty Foreground'),
        ):
            lbl = wx.StaticText(self, wx.ID_ANY, label)
            btn = PreferencesColorPicker(self, wx.ID_ANY, self._settings['Grid Colors'], key)
            colors_sizer.Add(btn, (row, 0), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, border=4)
            colors_sizer.Add(lbl, (row, 1), flag=wx.ALIGN_CENTER_VERTICAL | wx.LEFT, border=4)
            row += 1

    def _create_background_pickers(self, colors_sizer):
        row = 0
        for key, label in (
            ('background assign', 'Variable Background'),
            ('background keyword', 'Keyword Background'),
            ('background mandatory', 'Mandatory Field Background'),
            ('background optional', 'Optional Field Background'),
            ('background must be empty', 'Mandatory Empty Field Background'),
            ('background unknown', 'Unknown Background'),
            ('background error', 'Error Background'),
            ('background highlight', 'Highlight Background')
        ):
            lbl = wx.StaticText(self, wx.ID_ANY, label)
            btn = PreferencesColorPicker(self, wx.ID_ANY, self._settings['Grid Colors'], key)
            colors_sizer.Add(btn, (row, 2), flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL, border=4)
            colors_sizer.Add(lbl, (row, 3), flag=wx.ALIGN_CENTER_VERTICAL | wx.LEFT, border=4)
            row += 1
########NEW FILE########
__FILENAME__ = configobj
# configobj.py
# A config file reader/writer that supports nested sections in config files.
# Copyright (C) 2005-2009 Michael Foord, Nicola Larosa
# E-mail: fuzzyman AT voidspace DOT org DOT uk
#         nico AT tekNico DOT net

# ConfigObj 4
# http://www.voidspace.org.uk/python/configobj.html

# Released subject to the BSD License
# Please see http://www.voidspace.org.uk/python/license.shtml

# Scripts maintained at http://www.voidspace.org.uk/python/index.shtml
# For information about bugfixes, updates and support, please join the
# ConfigObj mailing list:
# http://lists.sourceforge.net/lists/listinfo/configobj-develop
# Comments, suggestions and bug reports welcome.
#
# Note! All TO DOs and FIX MEs removed from the original source, by RIDE-project

from __future__ import generators

import sys
import os
import re

compiler = None
try:
    import compiler
except ImportError:
    # for IronPython
    pass


try:
    from codecs import BOM_UTF8, BOM_UTF16, BOM_UTF16_BE, BOM_UTF16_LE
except ImportError:
    # Python 2.2 does not have these
    # UTF-8
    BOM_UTF8 = '\xef\xbb\xbf'
    # UTF-16, little endian
    BOM_UTF16_LE = '\xff\xfe'
    # UTF-16, big endian
    BOM_UTF16_BE = '\xfe\xff'
    if sys.byteorder == 'little':
        # UTF-16, native endianness
        BOM_UTF16 = BOM_UTF16_LE
    else:
        # UTF-16, native endianness
        BOM_UTF16 = BOM_UTF16_BE

# A dictionary mapping BOM to
# the encoding to decode with, and what to set the
# encoding attribute to.
BOMS = {
    BOM_UTF8: ('utf_8', None),
    BOM_UTF16_BE: ('utf16_be', 'utf_16'),
    BOM_UTF16_LE: ('utf16_le', 'utf_16'),
    BOM_UTF16: ('utf_16', 'utf_16'),
    }
# All legal variants of the BOM codecs.
BOM_LIST = {
    'utf_16': 'utf_16',
    'u16': 'utf_16',
    'utf16': 'utf_16',
    'utf-16': 'utf_16',
    'utf16_be': 'utf16_be',
    'utf_16_be': 'utf16_be',
    'utf-16be': 'utf16_be',
    'utf16_le': 'utf16_le',
    'utf_16_le': 'utf16_le',
    'utf-16le': 'utf16_le',
    'utf_8': 'utf_8',
    'u8': 'utf_8',
    'utf': 'utf_8',
    'utf8': 'utf_8',
    'utf-8': 'utf_8',
    }

# Map of encodings to the BOM to write.
BOM_SET = {
    'utf_8': BOM_UTF8,
    'utf_16': BOM_UTF16,
    'utf16_be': BOM_UTF16_BE,
    'utf16_le': BOM_UTF16_LE,
    None: BOM_UTF8
    }


def match_utf8(encoding):
    return BOM_LIST.get(encoding.lower()) == 'utf_8'


# Quote strings used for writing values
squot = "'%s'"
dquot = '"%s"'
noquot = "%s"
wspace_plus = ' \r\n\v\t\'"'
tsquot = '"""%s"""'
tdquot = "'''%s'''"

try:
    enumerate
except NameError:
    def enumerate(obj):
        """enumerate for Python 2.2."""
        i = -1
        for item in obj:
            i += 1
            yield i, item

# Sentinel for use in getattr calls to replace hasattr
MISSING = object()

__version__ = '4.6.0'

__revision__ = '$Id: configobj.py 156 2006-01-31 14:57:08Z fuzzyman $'

__docformat__ = "restructuredtext en"

__all__ = (
    '__version__',
    'DEFAULT_INDENT_TYPE',
    'DEFAULT_INTERPOLATION',
    'ConfigObjError',
    'NestingError',
    'ParseError',
    'DuplicateError',
    'ConfigspecError',
    'ConfigObj',
    'SimpleVal',
    'InterpolationError',
    'InterpolationLoopError',
    'MissingInterpolationOption',
    'RepeatSectionError',
    'ReloadError',
    'UnreprError',
    'UnknownType',
    '__docformat__',
    'flatten_errors',
)

DEFAULT_INTERPOLATION = 'configparser'
DEFAULT_INDENT_TYPE = '    '
MAX_INTERPOL_DEPTH = 10

OPTION_DEFAULTS = {
    'interpolation': True,
    'raise_errors': False,
    'list_values': True,
    'create_empty': False,
    'file_error': False,
    'configspec': None,
    'stringify': True,
    # option may be set to one of ('', ' ', '\t')
    'indent_type': None,
    'encoding': None,
    'default_encoding': None,
    'unrepr': False,
    'write_empty_values': False,
}



def getObj(s):
    s = "a=" + s
    if compiler is None:
        raise ImportError('compiler module not available')
    p = compiler.parse(s)
    return p.getChildren()[1].getChildren()[0].getChildren()[1]


class UnknownType(Exception):
    pass


class Builder(object):

    def build(self, o):
        m = getattr(self, 'build_' + o.__class__.__name__, None)
        if m is None:
            raise UnknownType(o.__class__.__name__)
        return m(o)

    def build_List(self, o):
        return map(self.build, o.getChildren())

    def build_Const(self, o):
        return o.value

    def build_Dict(self, o):
        d = {}
        i = iter(map(self.build, o.getChildren()))
        for el in i:
            d[el] = i.next()
        return d

    def build_Tuple(self, o):
        return tuple(self.build_List(o))

    def build_Name(self, o):
        if o.name == 'None':
            return None
        if o.name == 'True':
            return True
        if o.name == 'False':
            return False

        # An undefined Name
        raise UnknownType('Undefined Name')

    def build_Add(self, o):
        real, imag = map(self.build_Const, o.getChildren())
        try:
            real = float(real)
        except TypeError:
            raise UnknownType('Add')
        if not isinstance(imag, complex) or imag.real != 0.0:
            raise UnknownType('Add')
        return real+imag

    def build_Getattr(self, o):
        parent = self.build(o.expr)
        return getattr(parent, o.attrname)

    def build_UnarySub(self, o):
        return -self.build_Const(o.getChildren()[0])

    def build_UnaryAdd(self, o):
        return self.build_Const(o.getChildren()[0])


_builder = Builder()


def unrepr(s):
    if not s:
        return s
    return _builder.build(getObj(s))



class ConfigObjError(SyntaxError):
    """
    This is the base class for all errors that ConfigObj raises.
    It is a subclass of SyntaxError.
    """
    def __init__(self, message='', line_number=None, line=''):
        self.line = line
        self.line_number = line_number
        SyntaxError.__init__(self, message)


class NestingError(ConfigObjError):
    """
    This error indicates a level of nesting that doesn't match.
    """


class ParseError(ConfigObjError):
    """
    This error indicates that a line is badly written.
    It is neither a valid ``key = value`` line,
    nor a valid section marker line.
    """


class ReloadError(IOError):
    """
    A 'reload' operation failed.
    This exception is a subclass of ``IOError``.
    """
    def __init__(self):
        IOError.__init__(self, 'reload failed, filename is not set.')


class DuplicateError(ConfigObjError):
    """
    The keyword or section specified already exists.
    """


class ConfigspecError(ConfigObjError):
    """
    An error occured whilst parsing a configspec.
    """


class InterpolationError(ConfigObjError):
    """Base class for the two interpolation errors."""


class InterpolationLoopError(InterpolationError):
    """Maximum interpolation depth exceeded in string interpolation."""

    def __init__(self, option):
        InterpolationError.__init__(
            self,
            'interpolation loop detected in value "%s".' % option)


class RepeatSectionError(ConfigObjError):
    """
    This error indicates additional sections in a section with a
    ``__many__`` (repeated) section.
    """


class MissingInterpolationOption(InterpolationError):
    """A value specified for interpolation was missing."""

    def __init__(self, option):
        InterpolationError.__init__(
            self,
            'missing option "%s" in interpolation.' % option)


class UnreprError(ConfigObjError):
    """An error parsing in unrepr mode."""



class InterpolationEngine(object):
    """
    A helper class to help perform string interpolation.

    This class is an abstract base class; its descendants perform
    the actual work.
    """

    # compiled regexp to use in self.interpolate()
    _KEYCRE = re.compile(r"%\(([^)]*)\)s")

    def __init__(self, section):
        # the Section instance that "owns" this engine
        self.section = section


    def interpolate(self, key, value):
        def recursive_interpolate(key, value, section, backtrail):
            """The function that does the actual work.

            ``value``: the string we're trying to interpolate.
            ``section``: the section in which that string was found
            ``backtrail``: a dict to keep track of where we've been,
            to detect and prevent infinite recursion loops

            This is similar to a depth-first-search algorithm.
            """
            # Have we been here already?
            if backtrail.has_key((key, section.name)):
                # Yes - infinite loop detected
                raise InterpolationLoopError(key)
            # Place a marker on our backtrail so we won't come back here again
            backtrail[(key, section.name)] = 1

            # Now start the actual work
            match = self._KEYCRE.search(value)
            while match:
                # The actual parsing of the match is implementation-dependent,
                # so delegate to our helper function
                k, v, s = self._parse_match(match)
                if k is None:
                    # That's the signal that no further interpolation is needed
                    replacement = v
                else:
                    # Further interpolation may be needed to obtain final value
                    replacement = recursive_interpolate(k, v, s, backtrail)
                # Replace the matched string with its final value
                start, end = match.span()
                value = ''.join((value[:start], replacement, value[end:]))
                new_search_start = start + len(replacement)
                # Pick up the next interpolation key, if any, for next time
                # through the while loop
                match = self._KEYCRE.search(value, new_search_start)

            # Now safe to come back here again; remove marker from backtrail
            del backtrail[(key, section.name)]

            return value

        # Back in interpolate(), all we have to do is kick off the recursive
        # function with appropriate starting values
        value = recursive_interpolate(key, value, self.section, {})
        return value


    def _fetch(self, key):
        """Helper function to fetch values from owning section.

        Returns a 2-tuple: the value, and the section where it was found.
        """
        # switch off interpolation before we try and fetch anything !
        save_interp = self.section.main.interpolation
        self.section.main.interpolation = False

        # Start at section that "owns" this InterpolationEngine
        current_section = self.section
        while True:
            # try the current section first
            val = current_section.get(key)
            if val is not None:
                break
            # try "DEFAULT" next
            val = current_section.get('DEFAULT', {}).get(key)
            if val is not None:
                break
            # move up to parent and try again
            # top-level's parent is itself
            if current_section.parent is current_section:
                # reached top level, time to give up
                break
            current_section = current_section.parent

        # restore interpolation to previous value before returning
        self.section.main.interpolation = save_interp
        if val is None:
            raise MissingInterpolationOption(key)
        return val, current_section


    def _parse_match(self, match):
        """Implementation-dependent helper function.

        Will be passed a match object corresponding to the interpolation
        key we just found (e.g., "%(foo)s" or "$foo"). Should look up that
        key in the appropriate config file section (using the ``_fetch()``
        helper function) and return a 3-tuple: (key, value, section)

        ``key`` is the name of the key we're looking for
        ``value`` is the value found for that key
        ``section`` is a reference to the section where it was found

        ``key`` and ``section`` should be None if no further
        interpolation should be performed on the resulting value
        (e.g., if we interpolated "$$" and returned "$").
        """
        raise NotImplementedError()



class ConfigParserInterpolation(InterpolationEngine):
    """Behaves like ConfigParser."""
    _KEYCRE = re.compile(r"%\(([^)]*)\)s")

    def _parse_match(self, match):
        key = match.group(1)
        value, section = self._fetch(key)
        return key, value, section



class TemplateInterpolation(InterpolationEngine):
    """Behaves like string.Template."""
    _delimiter = '$'
    _KEYCRE = re.compile(r"""
        \$(?:
          (?P<escaped>\$)              |   # Two $ signs
          (?P<named>[_a-z][_a-z0-9]*)  |   # $name format
          {(?P<braced>[^}]*)}              # ${name} format
        )
        """, re.IGNORECASE | re.VERBOSE)

    def _parse_match(self, match):
        # Valid name (in or out of braces): fetch value from section
        key = match.group('named') or match.group('braced')
        if key is not None:
            value, section = self._fetch(key)
            return key, value, section
        # Escaped delimiter (e.g., $$): return single delimiter
        if match.group('escaped') is not None:
            # Return None for key and section to indicate it's time to stop
            return None, self._delimiter, None
        # Anything else: ignore completely, just return it unchanged
        return None, match.group(), None


interpolation_engines = {
    'configparser': ConfigParserInterpolation,
    'template': TemplateInterpolation,
}


def __newobj__(cls, *args):
    # Hack for pickle
    return cls.__new__(cls, *args)

class Section(dict):
    """
    A dictionary-like object that represents a section in a config file.

    It does string interpolation if the 'interpolation' attribute
    of the 'main' object is set to True.

    Interpolation is tried first from this object, then from the 'DEFAULT'
    section of this object, next from the parent and its 'DEFAULT' section,
    and so on until the main object is reached.

    A Section will behave like an ordered dictionary - following the
    order of the ``scalars`` and ``sections`` attributes.
    You can use this to change the order of members.

    Iteration follows the order: scalars, then sections.
    """


    def __setstate__(self, state):
        dict.update(self, state[0])
        self.__dict__.update(state[1])

    def __reduce__(self):
        state = (dict(self), self.__dict__)
        return (__newobj__, (self.__class__,), state)


    def __init__(self, parent, depth, main, indict=None, name=None):
        """
        * parent is the section above
        * depth is the depth level of this section
        * main is the main ConfigObj
        * indict is a dictionary to initialise the section with
        """
        if indict is None:
            indict = {}
        dict.__init__(self)
        # used for nesting level *and* interpolation
        self.parent = parent
        # used for the interpolation attribute
        self.main = main
        # level of nesting depth of this Section
        self.depth = depth
        # purely for information
        self.name = name
        #
        self._initialise()
        # we do this explicitly so that __setitem__ is used properly
        # (rather than just passing to ``dict.__init__``)
        for entry, value in indict.iteritems():
            self[entry] = value


    def _initialise(self):
        # the sequence of scalar values in this Section
        self.scalars = []
        # the sequence of sections in this Section
        self.sections = []
        # for comments :-)
        self.comments = {}
        self.inline_comments = {}
        # the configspec
        self.configspec = None
        # for defaults
        self.defaults = []
        self.default_values = {}


    def _interpolate(self, key, value):
        try:
            # do we already have an interpolation engine?
            engine = self._interpolation_engine
        except AttributeError:
            # not yet: first time running _interpolate(), so pick the engine
            name = self.main.interpolation
            if name == True:  # note that "if name:" would be incorrect here
                # backwards-compatibility: interpolation=True means use default
                name = DEFAULT_INTERPOLATION
            name = name.lower()  # so that "Template", "template", etc. all work
            class_ = interpolation_engines.get(name, None)
            if class_ is None:
                # invalid value for self.main.interpolation
                self.main.interpolation = False
                return value
            else:
                # save reference to engine so we don't have to do this again
                engine = self._interpolation_engine = class_(self)
        # let the engine do the actual work
        return engine.interpolate(key, value)


    def __getitem__(self, key):
        """Fetch the item and do string interpolation."""
        val = dict.__getitem__(self, key)
        if self.main.interpolation and isinstance(val, basestring):
            return self._interpolate(key, val)
        return val


    def __setitem__(self, key, value, unrepr=False):
        """
        Correctly set a value.

        Making dictionary values Section instances.
        (We have to special case 'Section' instances - which are also dicts)

        Keys must be strings.
        Values need only be strings (or lists of strings) if
        ``main.stringify`` is set.

        ``unrepr`` must be set when setting a value to a dictionary, without
        creating a new sub-section.
        """
        if not isinstance(key, basestring):
            raise ValueError('The key "%s" is not a string.' % key)

        # add the comment
        if not self.comments.has_key(key):
            self.comments[key] = []
            self.inline_comments[key] = ''
        # remove the entry from defaults
        if key in self.defaults:
            self.defaults.remove(key)
        #
        if isinstance(value, Section):
            if not self.has_key(key):
                self.sections.append(key)
            dict.__setitem__(self, key, value)
        elif isinstance(value, dict) and not unrepr:
            # First create the new depth level,
            # then create the section
            if not self.has_key(key):
                self.sections.append(key)
            new_depth = self.depth + 1
            dict.__setitem__(
                self,
                key,
                Section(
                    self,
                    new_depth,
                    self.main,
                    indict=value,
                    name=key))
        else:
            if not self.has_key(key):
                self.scalars.append(key)
            if not self.main.stringify:
                if isinstance(value, basestring):
                    pass
                elif isinstance(value, (list, tuple)):
                    for entry in value:
                        if not isinstance(entry, basestring):
                            raise TypeError('Value is not a string "%s".' % entry)
                else:
                    raise TypeError('Value is not a string "%s".' % value)
            dict.__setitem__(self, key, value)


    def __delitem__(self, key):
        """Remove items from the sequence when deleting."""
        dict. __delitem__(self, key)
        if key in self.scalars:
            self.scalars.remove(key)
        else:
            self.sections.remove(key)
        del self.comments[key]
        del self.inline_comments[key]


    def get(self, key, default=None):
        """A version of ``get`` that doesn't bypass string interpolation."""
        try:
            return self[key]
        except KeyError:
            return default


    def update(self, indict):
        """
        A version of update that uses our ``__setitem__``.
        """
        for entry in indict:
            self[entry] = indict[entry]


    def pop(self, key, *args):
        """
        'D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised'
        """
        val = dict.pop(self, key, *args)
        if key in self.scalars:
            del self.comments[key]
            del self.inline_comments[key]
            self.scalars.remove(key)
        elif key in self.sections:
            del self.comments[key]
            del self.inline_comments[key]
            self.sections.remove(key)
        if self.main.interpolation and isinstance(val, basestring):
            return self._interpolate(key, val)
        return val


    def popitem(self):
        """Pops the first (key,val)"""
        sequence = (self.scalars + self.sections)
        if not sequence:
            raise KeyError(": 'popitem(): dictionary is empty'")
        key = sequence[0]
        val =  self[key]
        del self[key]
        return key, val


    def clear(self):
        """
        A version of clear that also affects scalars/sections
        Also clears comments and configspec.

        Leaves other attributes alone :
            depth/main/parent are not affected
        """
        dict.clear(self)
        self.scalars = []
        self.sections = []
        self.comments = {}
        self.inline_comments = {}
        self.configspec = None


    def setdefault(self, key, default=None):
        """A version of setdefault that sets sequence if appropriate."""
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return self[key]


    def items(self):
        """D.items() -> list of D's (key, value) pairs, as 2-tuples"""
        return zip((self.scalars + self.sections), self.values())


    def keys(self):
        """D.keys() -> list of D's keys"""
        return (self.scalars + self.sections)


    def values(self):
        """D.values() -> list of D's values"""
        return [self[key] for key in (self.scalars + self.sections)]


    def iteritems(self):
        """D.iteritems() -> an iterator over the (key, value) items of D"""
        return iter(self.items())


    def iterkeys(self):
        """D.iterkeys() -> an iterator over the keys of D"""
        return iter((self.scalars + self.sections))

    __iter__ = iterkeys


    def itervalues(self):
        """D.itervalues() -> an iterator over the values of D"""
        return iter(self.values())


    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return '{%s}' % ', '.join([('%s: %s' % (repr(key), repr(self[key])))
            for key in (self.scalars + self.sections)])

    __str__ = __repr__
    __str__.__doc__ = "x.__str__() <==> str(x)"


    # Extra methods - not in a normal dictionary

    def dict(self):
        """
        Return a deepcopy of self as a dictionary.

        All members that are ``Section`` instances are recursively turned to
        ordinary dictionaries - by calling their ``dict`` method.

        >>> n = a.dict()
        >>> n == a
        1
        >>> n is a
        0
        """
        newdict = {}
        for entry in self:
            this_entry = self[entry]
            if isinstance(this_entry, Section):
                this_entry = this_entry.dict()
            elif isinstance(this_entry, list):
                # create a copy rather than a reference
                this_entry = list(this_entry)
            elif isinstance(this_entry, tuple):
                # create a copy rather than a reference
                this_entry = tuple(this_entry)
            newdict[entry] = this_entry
        return newdict


    def merge(self, indict):
        """
        A recursive update - useful for merging config files.

        >>> a = '''[section1]
        ...     option1 = True
        ...     [[subsection]]
        ...     more_options = False
        ...     # end of file'''.splitlines()
        >>> b = '''# File is user.ini
        ...     [section1]
        ...     option1 = False
        ...     # end of file'''.splitlines()
        >>> c1 = ConfigObj(b)
        >>> c2 = ConfigObj(a)
        >>> c2.merge(c1)
        >>> c2
        ConfigObj({'section1': {'option1': 'False', 'subsection': {'more_options': 'False'}}})
        """
        for key, val in indict.items():
            if (key in self and isinstance(self[key], dict) and
                                isinstance(val, dict)):
                self[key].merge(val)
            else:
                self[key] = val


    def rename(self, oldkey, newkey):
        """
        Change a keyname to another, without changing position in sequence.

        Implemented so that transformations can be made on keys,
        as well as on values. (used by encode and decode)

        Also renames comments.
        """
        if oldkey in self.scalars:
            the_list = self.scalars
        elif oldkey in self.sections:
            the_list = self.sections
        else:
            raise KeyError('Key "%s" not found.' % oldkey)
        pos = the_list.index(oldkey)
        #
        val = self[oldkey]
        dict.__delitem__(self, oldkey)
        dict.__setitem__(self, newkey, val)
        the_list.remove(oldkey)
        the_list.insert(pos, newkey)
        comm = self.comments[oldkey]
        inline_comment = self.inline_comments[oldkey]
        del self.comments[oldkey]
        del self.inline_comments[oldkey]
        self.comments[newkey] = comm
        self.inline_comments[newkey] = inline_comment


    def walk(self, function, raise_errors=True,
            call_on_sections=False, **keywargs):
        """
        Walk every member and call a function on the keyword and value.

        Return a dictionary of the return values

        If the function raises an exception, raise the errror
        unless ``raise_errors=False``, in which case set the return value to
        ``False``.

        Any unrecognised keyword arguments you pass to walk, will be pased on
        to the function you pass in.

        Note: if ``call_on_sections`` is ``True`` then - on encountering a
        subsection, *first* the function is called for the *whole* subsection,
        and then recurses into it's members. This means your function must be
        able to handle strings, dictionaries and lists. This allows you
        to change the key of subsections as well as for ordinary members. The
        return value when called on the whole subsection has to be discarded.

        See  the encode and decode methods for examples, including functions.

        .. admonition:: caution

            You can use ``walk`` to transform the names of members of a section
            but you mustn't add or delete members.

        >>> config = '''[XXXXsection]
        ... XXXXkey = XXXXvalue'''.splitlines()
        >>> cfg = ConfigObj(config)
        >>> cfg
        ConfigObj({'XXXXsection': {'XXXXkey': 'XXXXvalue'}})
        >>> def transform(section, key):
        ...     val = section[key]
        ...     newkey = key.replace('XXXX', 'CLIENT1')
        ...     section.rename(key, newkey)
        ...     if isinstance(val, (tuple, list, dict)):
        ...         pass
        ...     else:
        ...         val = val.replace('XXXX', 'CLIENT1')
        ...         section[newkey] = val
        >>> cfg.walk(transform, call_on_sections=True)
        {'CLIENT1section': {'CLIENT1key': None}}
        >>> cfg
        ConfigObj({'CLIENT1section': {'CLIENT1key': 'CLIENT1value'}})
        """
        out = {}
        # scalars first
        for i in range(len(self.scalars)):
            entry = self.scalars[i]
            try:
                val = function(self, entry, **keywargs)
                # bound again in case name has changed
                entry = self.scalars[i]
                out[entry] = val
            except Exception:
                if raise_errors:
                    raise
                else:
                    entry = self.scalars[i]
                    out[entry] = False
        # then sections
        for i in range(len(self.sections)):
            entry = self.sections[i]
            if call_on_sections:
                try:
                    function(self, entry, **keywargs)
                except Exception:
                    if raise_errors:
                        raise
                    else:
                        entry = self.sections[i]
                        out[entry] = False
                # bound again in case name has changed
                entry = self.sections[i]
            # previous result is discarded
            out[entry] = self[entry].walk(
                function,
                raise_errors=raise_errors,
                call_on_sections=call_on_sections,
                **keywargs)
        return out


    def as_bool(self, key):
        """
        Accepts a key as input. The corresponding value must be a string or
        the objects (``True`` or 1) or (``False`` or 0). We allow 0 and 1 to
        retain compatibility with Python 2.2.

        If the string is one of  ``True``, ``On``, ``Yes``, or ``1`` it returns
        ``True``.

        If the string is one of  ``False``, ``Off``, ``No``, or ``0`` it returns
        ``False``.

        ``as_bool`` is not case sensitive.

        Any other input will raise a ``ValueError``.

        >>> a = ConfigObj()
        >>> a['a'] = 'fish'
        >>> a.as_bool('a')
        Traceback (most recent call last):
        ValueError: Value "fish" is neither True nor False
        >>> a['b'] = 'True'
        >>> a.as_bool('b')
        1
        >>> a['b'] = 'off'
        >>> a.as_bool('b')
        0
        """
        val = self[key]
        if val == True:
            return True
        elif val == False:
            return False
        else:
            try:
                if not isinstance(val, basestring):
                    raise KeyError()
                else:
                    return self.main._bools[val.lower()]
            except KeyError:
                raise ValueError('Value "%s" is neither True nor False' % val)


    def as_int(self, key):
        """
        A convenience method which coerces the specified value to an integer.

        If the value is an invalid literal for ``int``, a ``ValueError`` will
        be raised.

        >>> a = ConfigObj()
        >>> a['a'] = 'fish'
        >>> a.as_int('a')
        Traceback (most recent call last):
        ValueError: invalid literal for int() with base 10: 'fish'
        >>> a['b'] = '1'
        >>> a.as_int('b')
        1
        >>> a['b'] = '3.2'
        >>> a.as_int('b')
        Traceback (most recent call last):
        ValueError: invalid literal for int() with base 10: '3.2'
        """
        return int(self[key])


    def as_float(self, key):
        """
        A convenience method which coerces the specified value to a float.

        If the value is an invalid literal for ``float``, a ``ValueError`` will
        be raised.

        >>> a = ConfigObj()
        >>> a['a'] = 'fish'
        >>> a.as_float('a')
        Traceback (most recent call last):
        ValueError: invalid literal for float(): fish
        >>> a['b'] = '1'
        >>> a.as_float('b')
        1.0
        >>> a['b'] = '3.2'
        >>> a.as_float('b')
        3.2000000000000002
        """
        return float(self[key])


    def as_list(self, key):
        """
        A convenience method which fetches the specified value, guaranteeing
        that it is a list.

        >>> a = ConfigObj()
        >>> a['a'] = 1
        >>> a.as_list('a')
        [1]
        >>> a['a'] = (1,)
        >>> a.as_list('a')
        [1]
        >>> a['a'] = [1]
        >>> a.as_list('a')
        [1]
        """
        result = self[key]
        if isinstance(result, (tuple, list)):
            return list(result)
        return [result]


    def restore_default(self, key):
        """
        Restore (and return) default value for the specified key.

        This method will only work for a ConfigObj that was created
        with a configspec and has been validated.

        If there is no default value for this key, ``KeyError`` is raised.
        """
        default = self.default_values[key]
        dict.__setitem__(self, key, default)
        if key not in self.defaults:
            self.defaults.append(key)
        return default


    def restore_defaults(self):
        """
        Recursively restore default values to all members
        that have them.

        This method will only work for a ConfigObj that was created
        with a configspec and has been validated.

        It doesn't delete or modify entries without default values.
        """
        for key in self.default_values:
            self.restore_default(key)

        for section in self.sections:
            self[section].restore_defaults()


class ConfigObj(Section):
    """An object to read, create, and write config files."""

    _keyword = re.compile(r'''^ # line start
        (\s*)                   # indentation
        (                       # keyword
            (?:".*?")|          # double quotes
            (?:'.*?')|          # single quotes
            (?:[^'"=].*?)       # no quotes
        )
        \s*=\s*                 # divider
        (.*)                    # value (including list values and comments)
        $   # line end
        ''',
        re.VERBOSE)

    _sectionmarker = re.compile(r'''^
        (\s*)                     # 1: indentation
        ((?:\[\s*)+)              # 2: section marker open
        (                         # 3: section name open
            (?:"\s*\S.*?\s*")|    # at least one non-space with double quotes
            (?:'\s*\S.*?\s*')|    # at least one non-space with single quotes
            (?:[^'"\s].*?)        # at least one non-space unquoted
        )                         # section name close
        ((?:\s*\])+)              # 4: section marker close
        \s*(\#.*)?                # 5: optional comment
        $''',
        re.VERBOSE)

    # this regexp pulls list values out as a single string
    # or single values and comments
    _valueexp = re.compile(r'''^
        (?:
            (?:
                (
                    (?:
                        (?:
                            (?:".*?")|              # double quotes
                            (?:'.*?')|              # single quotes
                            (?:[^'",\#][^,\#]*?)    # unquoted
                        )
                        \s*,\s*                     # comma
                    )*      # match all list items ending in a comma (if any)
                )
                (
                    (?:".*?")|                      # double quotes
                    (?:'.*?')|                      # single quotes
                    (?:[^'",\#\s][^,]*?)|           # unquoted
                    (?:(?<!,))                      # Empty value
                )?          # last item in a list - or string value
            )|
            (,)             # alternatively a single comma - empty list
        )
        \s*(\#.*)?          # optional comment
        $''',
        re.VERBOSE)

    # use findall to get the members of a list value
    _listvalueexp = re.compile(r'''
        (
            (?:".*?")|          # double quotes
            (?:'.*?')|          # single quotes
            (?:[^'",\#].*?)       # unquoted
        )
        \s*,\s*                 # comma
        ''',
        re.VERBOSE)

    # this regexp is used for the value
    # when lists are switched off
    _nolistvalue = re.compile(r'''^
        (
            (?:".*?")|          # double quotes
            (?:'.*?')|          # single quotes
            (?:[^'"\#].*?)|     # unquoted
            (?:)                # Empty value
        )
        \s*(\#.*)?              # optional comment
        $''',
        re.VERBOSE)

    # regexes for finding triple quoted values on one line
    _single_line_single = re.compile(r"^'''(.*?)'''\s*(#.*)?$")
    _single_line_double = re.compile(r'^"""(.*?)"""\s*(#.*)?$')
    _multi_line_single = re.compile(r"^(.*?)'''\s*(#.*)?$")
    _multi_line_double = re.compile(r'^(.*?)"""\s*(#.*)?$')

    _triple_quote = {
        "'''": (_single_line_single, _multi_line_single),
        '"""': (_single_line_double, _multi_line_double),
    }

    # Used by the ``istrue`` Section method
    _bools = {
        'yes': True, 'no': False,
        'on': True, 'off': False,
        '1': True, '0': False,
        'true': True, 'false': False,
        }


    def __init__(self, infile=None, options=None, _inspec=False, **kwargs):
        """
        Parse a config file or create a config file object.

        ``ConfigObj(infile=None, options=None, **kwargs)``
        """
        self._inspec = _inspec
        # init the superclass
        Section.__init__(self, self, 0, self)

        infile = infile or []
        options = dict(options or {})

        # keyword arguments take precedence over an options dictionary
        options.update(kwargs)
        if _inspec:
            options['list_values'] = False

        defaults = OPTION_DEFAULTS.copy()
        for entry in options:
            if entry not in defaults:
                raise TypeError('Unrecognised option "%s".' % entry)

        # Add any explicit options to the defaults
        defaults.update(options)
        self._initialise(defaults)
        configspec = defaults['configspec']
        self._original_configspec = configspec
        self._load(infile, configspec)


    def _load(self, infile, configspec):
        if isinstance(infile, basestring):
            self.filename = infile
            if os.path.isfile(infile):
                h = open(infile, 'rb')
                infile = h.read() or []
                h.close()
            elif self.file_error:
                # raise an error if the file doesn't exist
                raise IOError('Config file not found: "%s".' % self.filename)
            else:
                # file doesn't already exist
                if self.create_empty:
                    # this is a good test that the filename specified
                    # isn't impossible - like on a non-existent device
                    h = open(infile, 'w')
                    h.write('')
                    h.close()
                infile = []

        elif isinstance(infile, (list, tuple)):
            infile = list(infile)

        elif isinstance(infile, dict):
            # initialise self
            # the Section class handles creating subsections
            if isinstance(infile, ConfigObj):
                # get a copy of our ConfigObj
                infile = infile.dict()

            for entry in infile:
                self[entry] = infile[entry]
            del self._errors

            if configspec is not None:
                self._handle_configspec(configspec)
            else:
                self.configspec = None
            return

        elif getattr(infile, 'read', MISSING) is not MISSING:
            # This supports file like objects
            infile = infile.read() or []
            # needs splitting into lines - but needs doing *after* decoding
            # in case it's not an 8 bit encoding
        else:
            raise TypeError('infile must be a filename, file like object, or list of lines.')

        if infile:
            # don't do it for the empty ConfigObj
            infile = self._handle_bom(infile)
            # infile is now *always* a list
            #
            # Set the newlines attribute (first line ending it finds)
            # and strip trailing '\n' or '\r' from lines
            for line in infile:
                if (not line) or (line[-1] not in ('\r', '\n', '\r\n')):
                    continue
                for end in ('\r\n', '\n', '\r'):
                    if line.endswith(end):
                        self.newlines = end
                        break
                break

            infile = [line.rstrip('\r\n') for line in infile]

        self._parse(infile)
        # if we had any errors, now is the time to raise them
        if self._errors:
            info = "at line %s." % self._errors[0].line_number
            if len(self._errors) > 1:
                msg = "Parsing failed with several errors.\nFirst error %s" % info
                error = ConfigObjError(msg)
            else:
                error = self._errors[0]
            # set the errors attribute; it's a list of tuples:
            # (error_type, message, line_number)
            error.errors = self._errors
            # set the config attribute
            error.config = self
            raise error
        # delete private attributes
        del self._errors

        if configspec is None:
            self.configspec = None
        else:
            self._handle_configspec(configspec)


    def _initialise(self, options=None):
        if options is None:
            options = OPTION_DEFAULTS

        # initialise a few variables
        self.filename = None
        self._errors = []
        self.raise_errors = options['raise_errors']
        self.interpolation = options['interpolation']
        self.list_values = options['list_values']
        self.create_empty = options['create_empty']
        self.file_error = options['file_error']
        self.stringify = options['stringify']
        self.indent_type = options['indent_type']
        self.encoding = options['encoding']
        self.default_encoding = options['default_encoding']
        self.BOM = False
        self.newlines = None
        self.write_empty_values = options['write_empty_values']
        self.unrepr = options['unrepr']

        self.initial_comment = []
        self.final_comment = []
        self.configspec = None

        if self._inspec:
            self.list_values = False

        # Clear section attributes as well
        Section._initialise(self)


    def __repr__(self):
        return ('ConfigObj({%s})' %
                ', '.join([('%s: %s' % (repr(key), repr(self[key])))
                for key in (self.scalars + self.sections)]))


    def _handle_bom(self, infile):
        """
        Handle any BOM, and decode if necessary.

        If an encoding is specified, that *must* be used - but the BOM should
        still be removed (and the BOM attribute set).

        (If the encoding is wrongly specified, then a BOM for an alternative
        encoding won't be discovered or removed.)

        If an encoding is not specified, UTF8 or UTF16 BOM will be detected and
        removed. The BOM attribute will be set. UTF16 will be decoded to
        unicode.

        NOTE: This method must not be called with an empty ``infile``.

        Specifying the *wrong* encoding is likely to cause a
        ``UnicodeDecodeError``.

        ``infile`` must always be returned as a list of lines, but may be
        passed in as a single string.
        """
        if ((self.encoding is not None) and
            (self.encoding.lower() not in BOM_LIST)):
            # No need to check for a BOM
            # the encoding specified doesn't have one
            # just decode
            return self._decode(infile, self.encoding)

        if isinstance(infile, (list, tuple)):
            line = infile[0]
        else:
            line = infile
        if self.encoding is not None:
            # encoding explicitly supplied
            # And it could have an associated BOM
            enc = BOM_LIST[self.encoding.lower()]
            if enc == 'utf_16':
                # For UTF16 we try big endian and little endian
                for BOM, (encoding, final_encoding) in BOMS.items():
                    if not final_encoding:
                        # skip UTF8
                        continue
                    if infile.startswith(BOM):
                        ### BOM discovered
                        ##self.BOM = True
                        # Don't need to remove BOM
                        return self._decode(infile, encoding)

                # If we get this far, will *probably* raise a DecodeError
                # As it doesn't appear to start with a BOM
                return self._decode(infile, self.encoding)

            # Must be UTF8
            BOM = BOM_SET[enc]
            if not line.startswith(BOM):
                return self._decode(infile, self.encoding)

            newline = line[len(BOM):]

            # BOM removed
            if isinstance(infile, (list, tuple)):
                infile[0] = newline
            else:
                infile = newline
            self.BOM = True
            return self._decode(infile, self.encoding)

        # No encoding specified - so we need to check for UTF8/UTF16
        for BOM, (encoding, final_encoding) in BOMS.items():
            if not line.startswith(BOM):
                continue
            else:
                # BOM discovered
                self.encoding = final_encoding
                if not final_encoding:
                    self.BOM = True
                    # UTF8
                    # remove BOM
                    newline = line[len(BOM):]
                    if isinstance(infile, (list, tuple)):
                        infile[0] = newline
                    else:
                        infile = newline
                    # UTF8 - don't decode
                    if isinstance(infile, basestring):
                        return infile.splitlines(True)
                    else:
                        return infile
                # UTF16 - have to decode
                return self._decode(infile, encoding)

        # No BOM discovered and no encoding specified, just return
        if isinstance(infile, basestring):
            # infile read from a file will be a single string
            return infile.splitlines(True)
        return infile


    def _a_to_u(self, aString):
        """Decode ASCII strings to unicode if a self.encoding is specified."""
        if self.encoding:
            return aString.decode('ascii')
        else:
            return aString


    def _decode(self, infile, encoding):
        """
        Decode infile to unicode. Using the specified encoding.

        if is a string, it also needs converting to a list.
        """
        if isinstance(infile, basestring):
            # can't be unicode
            # NOTE: Could raise a ``UnicodeDecodeError``
            return infile.decode(encoding).splitlines(True)
        for i, line in enumerate(infile):
            if not isinstance(line, unicode):
                # NOTE: The isinstance test here handles mixed lists of unicode/string
                # NOTE: But the decode will break on any non-string values
                # NOTE: Or could raise a ``UnicodeDecodeError``
                infile[i] = line.decode(encoding)
        return infile


    def _decode_element(self, line):
        """Decode element to unicode if necessary."""
        if not self.encoding:
            return line
        if isinstance(line, str) and self.default_encoding:
            return line.decode(self.default_encoding)
        return line


    def _str(self, value):
        """
        Used by ``stringify`` within validate, to turn non-string values
        into strings.
        """
        if not isinstance(value, basestring):
            return str(value)
        else:
            return value


    def _parse(self, infile):
        """Actually parse the config file."""
        temp_list_values = self.list_values
        if self.unrepr:
            self.list_values = False

        comment_list = []
        done_start = False
        this_section = self
        maxline = len(infile) - 1
        cur_index = -1
        reset_comment = False

        while cur_index < maxline:
            if reset_comment:
                comment_list = []
            cur_index += 1
            line = infile[cur_index]
            sline = line.strip()
            # do we have anything on the line ?
            if not sline or sline.startswith('#'):
                reset_comment = False
                comment_list.append(line)
                continue

            if not done_start:
                # preserve initial comment
                self.initial_comment = comment_list
                comment_list = []
                done_start = True

            reset_comment = True
            # first we check if it's a section marker
            mat = self._sectionmarker.match(line)
            if mat is not None:
                # is a section line
                (indent, sect_open, sect_name, sect_close, comment) = mat.groups()
                if indent and (self.indent_type is None):
                    self.indent_type = indent
                cur_depth = sect_open.count('[')
                if cur_depth != sect_close.count(']'):
                    self._handle_error("Cannot compute the section depth at line %s.",
                                       NestingError, infile, cur_index)
                    continue

                if cur_depth < this_section.depth:
                    # the new section is dropping back to a previous level
                    try:
                        parent = self._match_depth(this_section,
                                                   cur_depth).parent
                    except SyntaxError:
                        self._handle_error("Cannot compute nesting level at line %s.",
                                           NestingError, infile, cur_index)
                        continue
                elif cur_depth == this_section.depth:
                    # the new section is a sibling of the current section
                    parent = this_section.parent
                elif cur_depth == this_section.depth + 1:
                    # the new section is a child the current section
                    parent = this_section
                else:
                    self._handle_error("Section too nested at line %s.",
                                       NestingError, infile, cur_index)

                sect_name = self._unquote(sect_name)
                if parent.has_key(sect_name):
                    self._handle_error('Duplicate section name at line %s.',
                                       DuplicateError, infile, cur_index)
                    continue

                # create the new section
                this_section = Section(
                    parent,
                    cur_depth,
                    self,
                    name=sect_name)
                parent[sect_name] = this_section
                parent.inline_comments[sect_name] = comment
                parent.comments[sect_name] = comment_list
                continue
            #
            # it's not a section marker,
            # so it should be a valid ``key = value`` line
            mat = self._keyword.match(line)
            if mat is None:
                # it neither matched as a keyword
                # or a section marker
                self._handle_error(
                    'Invalid line at line "%s".',
                    ParseError, infile, cur_index)
            else:
                # is a keyword value
                # value will include any inline comment
                (indent, key, value) = mat.groups()
                if indent and (self.indent_type is None):
                    self.indent_type = indent
                # check for a multiline value
                if value[:3] in ['"""', "'''"]:
                    try:
                        (value, comment, cur_index) = self._multiline(
                            value, infile, cur_index, maxline)
                    except SyntaxError:
                        self._handle_error(
                            'Parse error in value at line %s.',
                            ParseError, infile, cur_index)
                        continue
                    else:
                        if self.unrepr:
                            comment = ''
                            try:
                                value = unrepr(value)
                            except Exception, e:
                                if type(e) == UnknownType:
                                    msg = 'Unknown name or type in value at line %s.'
                                else:
                                    msg = 'Parse error in value at line %s.'
                                self._handle_error(msg, UnreprError, infile,
                                    cur_index)
                                continue
                else:
                    if self.unrepr:
                        comment = ''
                        try:
                            value = unrepr(value)
                        except Exception, e:
                            if isinstance(e, UnknownType):
                                msg = 'Unknown name or type in value at line %s.'
                            else:
                                msg = 'Parse error in value at line %s.'
                            self._handle_error(msg, UnreprError, infile,
                                cur_index)
                            continue
                    else:
                        # extract comment and lists
                        try:
                            (value, comment) = self._handle_value(value)
                        except SyntaxError:
                            self._handle_error(
                                'Parse error in value at line %s.',
                                ParseError, infile, cur_index)
                            continue
                #
                key = self._unquote(key)
                if this_section.has_key(key):
                    self._handle_error(
                        'Duplicate keyword name at line %s.',
                        DuplicateError, infile, cur_index)
                    continue
                # add the key.
                # we set unrepr because if we have got this far we will never
                # be creating a new section
                this_section.__setitem__(key, value, unrepr=True)
                this_section.inline_comments[key] = comment
                this_section.comments[key] = comment_list
                continue
        #
        if self.indent_type is None:
            # no indentation used, set the type accordingly
            self.indent_type = ''

        # preserve the final comment
        if not self and not self.initial_comment:
            self.initial_comment = comment_list
        elif not reset_comment:
            self.final_comment = comment_list
        self.list_values = temp_list_values


    def _match_depth(self, sect, depth):
        """
        Given a section and a depth level, walk back through the sections
        parents to see if the depth level matches a previous section.

        Return a reference to the right section,
        or raise a SyntaxError.
        """
        while depth < sect.depth:
            if sect is sect.parent:
                # we've reached the top level already
                raise SyntaxError()
            sect = sect.parent
        if sect.depth == depth:
            return sect
        # shouldn't get here
        raise SyntaxError()


    def _handle_error(self, text, ErrorClass, infile, cur_index):
        """
        Handle an error according to the error settings.

        Either raise the error or store it.
        The error will have occured at ``cur_index``
        """
        line = infile[cur_index]
        cur_index += 1
        message = text % cur_index
        error = ErrorClass(message, cur_index, line)
        if self.raise_errors:
            # raise the error - parsing stops here
            raise error
        # store the error
        # reraise when parsing has finished
        self._errors.append(error)


    def _unquote(self, value):
        """Return an unquoted version of a value"""
        if (value[0] == value[-1]) and (value[0] in ('"', "'")):
            value = value[1:-1]
        return value


    def _quote(self, value, multiline=True):
        """
        Return a safely quoted version of a value.

        Raise a ConfigObjError if the value cannot be safely quoted.
        If multiline is ``True`` (default) then use triple quotes
        if necessary.

        * Don't quote values that don't need it.
        * Recursively quote members of a list and return a comma joined list.
        * Multiline is ``False`` for lists.
        * Obey list syntax for empty and single member lists.

        If ``list_values=False`` then the value is only quoted if it contains
        a ``\\n`` (is multiline) or '#'.

        If ``write_empty_values`` is set, and the value is an empty string, it
        won't be quoted.
        """
        if multiline and self.write_empty_values and value == '':
            # Only if multiline is set, so that it is used for values not
            # keys, and not values that are part of a list
            return ''

        if multiline and isinstance(value, (list, tuple)):
            if not value:
                return ','
            elif len(value) == 1:
                return self._quote(value[0], multiline=False) + ','
            return ', '.join([self._quote(val, multiline=False)
                for val in value])
        if not isinstance(value, basestring):
            if self.stringify:
                value = str(value)
            else:
                raise TypeError('Value "%s" is not a string.' % value)

        if not value:
            return '""'

        no_lists_no_quotes = not self.list_values and '\n' not in value and '#' not in value
        need_triple = multiline and ((("'" in value) and ('"' in value)) or ('\n' in value ))
        hash_triple_quote = multiline and not need_triple and ("'" in value) and ('"' in value) and ('#' in value)
        check_for_single = (no_lists_no_quotes or not need_triple) and not hash_triple_quote

        if check_for_single:
            if not self.list_values:
                # we don't quote if ``list_values=False``
                quot = noquot
            # for normal values either single or double quotes will do
            elif '\n' in value:
                # will only happen if multiline is off - e.g. '\n' in key
                raise ConfigObjError('Value "%s" cannot be safely quoted.' % value)
            elif ((value[0] not in wspace_plus) and
                    (value[-1] not in wspace_plus) and
                    (',' not in value)):
                quot = noquot
            else:
                quot = self._get_single_quote(value)
        else:
            # if value has '\n' or "'" *and* '"', it will need triple quotes
            quot = self._get_triple_quote(value)

        if quot == noquot and '#' in value and self.list_values:
            quot = self._get_single_quote(value)

        return quot % value


    def _get_single_quote(self, value):
        if ("'" in value) and ('"' in value):
            raise ConfigObjError('Value "%s" cannot be safely quoted.' % value)
        elif '"' in value:
            quot = squot
        else:
            quot = dquot
        return quot


    def _get_triple_quote(self, value):
        if (value.find('"""') != -1) and (value.find("'''") != -1):
            raise ConfigObjError('Value "%s" cannot be safely quoted.' % value)
        if value.find('"""') == -1:
            quot = tdquot
        else:
            quot = tsquot
        return quot


    def _handle_value(self, value):
        """
        Given a value string, unquote, remove comment,
        handle lists. (including empty and single member lists)
        """
        if self._inspec:
            # Parsing a configspec so don't handle comments
            return (value, '')
        # do we look for lists in values ?
        if not self.list_values:
            mat = self._nolistvalue.match(value)
            if mat is None:
                raise SyntaxError()
            # NOTE: we don't unquote here
            return mat.groups()
        #
        mat = self._valueexp.match(value)
        if mat is None:
            # the value is badly constructed, probably badly quoted,
            # or an invalid list
            raise SyntaxError()
        (list_values, single, empty_list, comment) = mat.groups()
        if (list_values == '') and (single is None):
            # change this if you want to accept empty values
            raise SyntaxError()
        # NOTE: note there is no error handling from here if the regex
        # is wrong: then incorrect values will slip through
        if empty_list is not None:
            # the single comma - meaning an empty list
            return ([], comment)
        if single is not None:
            # handle empty values
            if list_values and not single:
                single = None
            else:
                single = single or '""'
                single = self._unquote(single)
        if list_values == '':
            # not a list value
            return (single, comment)
        the_list = self._listvalueexp.findall(list_values)
        the_list = [self._unquote(val) for val in the_list]
        if single is not None:
            the_list += [single]
        return (the_list, comment)


    def _multiline(self, value, infile, cur_index, maxline):
        """Extract the value, where we are in a multiline situation."""
        quot = value[:3]
        newvalue = value[3:]
        single_line = self._triple_quote[quot][0]
        multi_line = self._triple_quote[quot][1]
        mat = single_line.match(value)
        if mat is not None:
            retval = list(mat.groups())
            retval.append(cur_index)
            return retval
        elif newvalue.find(quot) != -1:
            # somehow the triple quote is missing
            raise SyntaxError()
        #
        while cur_index < maxline:
            cur_index += 1
            newvalue += '\n'
            line = infile[cur_index]
            if line.find(quot) == -1:
                newvalue += line
            else:
                # end of multiline, process it
                break
        else:
            # we've got to the end of the config, oops...
            raise SyntaxError()
        mat = multi_line.match(line)
        if mat is None:
            # a badly formed line
            raise SyntaxError()
        (value, comment) = mat.groups()
        return (newvalue + value, comment, cur_index)


    def _handle_configspec(self, configspec):
        """Parse the configspec."""
        if not isinstance(configspec, ConfigObj):
            try:
                configspec = ConfigObj(configspec,
                                       raise_errors=True,
                                       file_error=True,
                                       _inspec=True)
            except ConfigObjError, e:
                raise ConfigspecError('Parsing configspec failed: %s' % e)
            except IOError, e:
                raise IOError('Reading configspec failed: %s' % e)

        self.configspec = configspec



    def _set_configspec(self, section, copy):
        """
        Called by validate. Handles setting the configspec on subsections
        including sections to be validated by __many__
        """
        configspec = section.configspec
        many = configspec.get('__many__')
        if isinstance(many, dict):
            for entry in section.sections:
                if entry not in configspec:
                    section[entry].configspec = many

        for entry in configspec.sections:
            if entry == '__many__':
                continue
            if entry not in section:
                section[entry] = {}
                if copy:
                    # copy comments
                    section.comments[entry] = configspec.comments.get(entry, [])
                    section.inline_comments[entry] = configspec.inline_comments.get(entry, '')

            # Could be a scalar when we expect a section
            if isinstance(section[entry], Section):
                section[entry].configspec = configspec[entry]


    def _write_line(self, indent_string, entry, this_entry, comment):
        """Write an individual line, for the write method"""
        # NOTE: the calls to self._quote here handles non-StringType values.
        if not self.unrepr:
            val = self._decode_element(self._quote(this_entry))
        else:
            val = repr(this_entry)
        return '%s%s%s%s%s' % (indent_string,
                               self._decode_element(self._quote(entry, multiline=False)),
                               self._a_to_u(' = '),
                               val,
                               self._decode_element(comment))


    def _write_marker(self, indent_string, depth, entry, comment):
        """Write a section marker line"""
        return '%s%s%s%s%s' % (indent_string,
                               self._a_to_u('[' * depth),
                               self._quote(self._decode_element(entry), multiline=False),
                               self._a_to_u(']' * depth),
                               self._decode_element(comment))


    def _handle_comment(self, comment):
        """Deal with a comment."""
        if not comment:
            return ''
        start = self.indent_type
        if not comment.startswith('#'):
            start += self._a_to_u(' # ')
        return (start + comment)


    # Public methods

    def write(self, outfile=None, section=None):
        """
        Write the current ConfigObj as a file

        >>> filename = a.filename
        >>> a.filename = 'test.ini'
        >>> a.write()
        >>> a.filename = filename
        >>> a == ConfigObj('test.ini', raise_errors=True)
        1
        """
        if self.indent_type is None:
            # this can be true if initialised from a dictionary
            self.indent_type = DEFAULT_INDENT_TYPE

        out = []
        cs = self._a_to_u('#')
        csp = self._a_to_u('# ')
        if section is None:
            int_val = self.interpolation
            self.interpolation = False
            section = self
            for line in self.initial_comment:
                line = self._decode_element(line)
                stripped_line = line.strip()
                if stripped_line and not stripped_line.startswith(cs):
                    line = csp + line
                out.append(line)

        indent_string = self.indent_type * section.depth
        for entry in (section.scalars + section.sections):
            if entry in section.defaults:
                # don't write out default values
                continue
            for comment_line in section.comments[entry]:
                comment_line = self._decode_element(comment_line.lstrip())
                if comment_line and not comment_line.startswith(cs):
                    comment_line = csp + comment_line
                out.append(indent_string + comment_line)
            this_entry = section[entry]
            comment = self._handle_comment(section.inline_comments[entry])

            if isinstance(this_entry, dict):
                # a section
                out.append(self._write_marker(
                    indent_string,
                    this_entry.depth,
                    entry,
                    comment))
                out.extend(self.write(section=this_entry))
            else:
                out.append(self._write_line(
                    indent_string,
                    entry,
                    this_entry,
                    comment))

        if section is self:
            for line in self.final_comment:
                line = self._decode_element(line)
                stripped_line = line.strip()
                if stripped_line and not stripped_line.startswith(cs):
                    line = csp + line
                out.append(line)
            self.interpolation = int_val

        if section is not self:
            return out

        if (self.filename is None) and (outfile is None):
            # output a list of lines
            # might need to encode
            # NOTE: This will *screw* UTF16, each line will start with the BOM
            if self.encoding:
                out = [l.encode(self.encoding) for l in out]
            if (self.BOM and ((self.encoding is None) or
                (BOM_LIST.get(self.encoding.lower()) == 'utf_8'))):
                # Add the UTF8 BOM
                if not out:
                    out.append('')
                out[0] = BOM_UTF8 + out[0]
            return out

        # Turn the list to a string, joined with correct newlines
        newline = self.newlines or os.linesep
        output = self._a_to_u(newline).join(out)
        if self.encoding:
            output = output.encode(self.encoding)
        if self.BOM and ((self.encoding is None) or match_utf8(self.encoding)):
            # Add the UTF8 BOM
            output = BOM_UTF8 + output

        if not output.endswith(newline):
            output += newline
        if outfile is not None:
            outfile.write(output)
        else:
            h = open(self.filename, 'wb')
            h.write(output)
            h.close()


    def validate(self, validator, preserve_errors=False, copy=False,
                 section=None):
        """
        Test the ConfigObj against a configspec.

        It uses the ``validator`` object from *validate.py*.

        To run ``validate`` on the current ConfigObj, call: ::

            test = config.validate(validator)

        (Normally having previously passed in the configspec when the ConfigObj
        was created - you can dynamically assign a dictionary of checks to the
        ``configspec`` attribute of a section though).

        It returns ``True`` if everything passes, or a dictionary of
        pass/fails (True/False). If every member of a subsection passes, it
        will just have the value ``True``. (It also returns ``False`` if all
        members fail).

        In addition, it converts the values from strings to their native
        types if their checks pass (and ``stringify`` is set).

        If ``preserve_errors`` is ``True`` (``False`` is default) then instead
        of a marking a fail with a ``False``, it will preserve the actual
        exception object. This can contain info about the reason for failure.
        For example the ``VdtValueTooSmallError`` indicates that the value
        supplied was too small. If a value (or section) is missing it will
        still be marked as ``False``.

        You must have the validate module to use ``preserve_errors=True``.

        You can then use the ``flatten_errors`` function to turn your nested
        results dictionary into a flattened list of failures - useful for
        displaying meaningful error messages.
        """
        if section is None:
            if self.configspec is None:
                raise ValueError('No configspec supplied.')
            if preserve_errors:
                # We do this once to remove a top level dependency on the validate module
                # Which makes importing configobj faster
                from validate import VdtMissingValue  #@UnresolvedImport
                self._vdtMissingValue = VdtMissingValue

            section = self

            if copy:
                section.initial_comment = section.configspec.initial_comment
                section.final_comment = section.configspec.final_comment
                section.encoding = section.configspec.encoding
                section.BOM = section.configspec.BOM
                section.newlines = section.configspec.newlines
                section.indent_type = section.configspec.indent_type

        #
        configspec = section.configspec
        self._set_configspec(section, copy)

        def validate_entry(entry, spec, val, missing, ret_true, ret_false):
            try:
                check = validator.check(spec,
                                        val,
                                        missing=missing
                                        )
            except validator.baseErrorClass, e:
                if not preserve_errors or isinstance(e, self._vdtMissingValue):
                    out[entry] = False
                else:
                    # preserve the error
                    out[entry] = e
                    ret_false = False
                ret_true = False
            else:
                try:
                    section.default_values.pop(entry, None)
                except AttributeError:
                    # For Python 2.2 compatibility
                    try:
                        del section.default_values[entry]
                    except KeyError:
                        pass

                try:
                    section.default_values[entry] = validator.get_default_value(configspec[entry])
                except (KeyError, AttributeError):
                    # No default or validator has no 'get_default_value' (e.g. SimpleVal)
                    pass

                ret_false = False
                out[entry] = True
                if self.stringify or missing:
                    # if we are doing type conversion
                    # or the value is a supplied default
                    if not self.stringify:
                        if isinstance(check, (list, tuple)):
                            # preserve lists
                            check = [self._str(item) for item in check]
                        elif missing and check is None:
                            # convert the None from a default to a ''
                            check = ''
                        else:
                            check = self._str(check)
                    if (check != val) or missing:
                        section[entry] = check
                if not copy and missing and entry not in section.defaults:
                    section.defaults.append(entry)
            return ret_true, ret_false

        #
        out = {}
        ret_true = True
        ret_false = True

        unvalidated = [k for k in section.scalars if k not in configspec]
        incorrect_sections = [k for k in configspec.sections if k in section.scalars]
        incorrect_scalars = [k for k in configspec.scalars if k in section.sections]

        for entry in configspec.scalars:
            if entry in ('__many__', '___many___'):
                # reserved names
                continue

            if (not entry in section.scalars) or (entry in section.defaults):
                # missing entries
                # or entries from defaults
                missing = True
                val = None
                if copy and not entry in section.scalars:
                    # copy comments
                    section.comments[entry] = (
                        configspec.comments.get(entry, []))
                    section.inline_comments[entry] = (
                        configspec.inline_comments.get(entry, ''))
                #
            else:
                missing = False
                val = section[entry]

            ret_true, ret_false = validate_entry(entry, configspec[entry], val,
                                                 missing, ret_true, ret_false)

        many = None
        if '__many__' in configspec.scalars:
            many = configspec['__many__']
        elif '___many___' in configspec.scalars:
            many = configspec['___many___']

        if many is not None:
            for entry in unvalidated:
                val = section[entry]
                ret_true, ret_false = validate_entry(entry, many, val, False,
                                                     ret_true, ret_false)

        for entry in incorrect_scalars:
            ret_true = False
            if not preserve_errors:
                out[entry] = False
            else:
                ret_false = False
                msg = 'Value %r was provided as a section' % entry
                out[entry] = validator.baseErrorClass(msg)
        for entry in incorrect_sections:
            ret_true = False
            if not preserve_errors:
                out[entry] = False
            else:
                ret_false = False
                msg = 'Section %r was provided as a single value' % entry
                out[entry] = validator.baseErrorClass(msg)

        # Missing sections will have been created as empty ones when the
        # configspec was read.
        for entry in section.sections:
            if section is self and entry == 'DEFAULT':
                continue
            if section[entry].configspec is None:
                continue
            if copy:
                section.comments[entry] = configspec.comments.get(entry, [])
                section.inline_comments[entry] = configspec.inline_comments.get(entry, '')
            check = self.validate(validator, preserve_errors=preserve_errors, copy=copy, section=section[entry])
            out[entry] = check
            if check == False:
                ret_true = False
            elif check == True:
                ret_false = False
            else:
                ret_true = False
                ret_false = False
        #
        if ret_true:
            return True
        elif ret_false:
            return False
        return out


    def reset(self):
        """Clear ConfigObj instance and restore to 'freshly created' state."""
        self.clear()
        self._initialise()
        self.configspec = None
        # Just to be sure ;-)
        self._original_configspec = None


    def reload(self):
        """
        Reload a ConfigObj from file.

        This method raises a ``ReloadError`` if the ConfigObj doesn't have
        a filename attribute pointing to a file.
        """
        if not isinstance(self.filename, basestring):
            raise ReloadError()

        filename = self.filename
        current_options = {}
        for entry in OPTION_DEFAULTS:
            if entry == 'configspec':
                continue
            current_options[entry] = getattr(self, entry)

        configspec = self._original_configspec
        current_options['configspec'] = configspec

        self.clear()
        self._initialise(current_options)
        self._load(filename, configspec)



class SimpleVal(object):
    """
    A simple validator.
    Can be used to check that all members expected are present.

    To use it, provide a configspec with all your members in (the value given
    will be ignored). Pass an instance of ``SimpleVal`` to the ``validate``
    method of your ``ConfigObj``. ``validate`` will return ``True`` if all
    members are present, or a dictionary with True/False meaning
    present/missing. (Whole missing sections will be replaced with ``False``)
    """

    def __init__(self):
        self.baseErrorClass = ConfigObjError

    def check(self, check, member, missing=False):
        """A dummy check method, always returns the value unchanged."""
        if missing:
            raise self.baseErrorClass()
        return member


# Check / processing functions for options
def flatten_errors(cfg, res, levels=None, results=None):
    """
    An example function that will turn a nested dictionary of results
    (as returned by ``ConfigObj.validate``) into a flat list.

    ``cfg`` is the ConfigObj instance being checked, ``res`` is the results
    dictionary returned by ``validate``.

    (This is a recursive function, so you shouldn't use the ``levels`` or
    ``results`` arguments - they are used by the function.)

    Returns a list of keys that failed. Each member of the list is a tuple :

    ::

        ([list of sections...], key, result)

    If ``validate`` was called with ``preserve_errors=False`` (the default)
    then ``result`` will always be ``False``.

    *list of sections* is a flattened list of sections that the key was found
    in.

    If the section was missing (or a section was expected and a scalar provided
    - or vice-versa) then key will be ``None``.

    If the value (or section) was missing then ``result`` will be ``False``.

    If ``validate`` was called with ``preserve_errors=True`` and a value
    was present, but failed the check, then ``result`` will be the exception
    object returned. You can use this as a string that describes the failure.

    For example *The value "3" is of the wrong type*.

    >>> import validate
    >>> vtor = validate.Validator()
    >>> my_ini = '''
    ...     option1 = True
    ...     [section1]
    ...     option1 = True
    ...     [section2]
    ...     another_option = Probably
    ...     [section3]
    ...     another_option = True
    ...     [[section3b]]
    ...     value = 3
    ...     value2 = a
    ...     value3 = 11
    ...     '''
    >>> my_cfg = '''
    ...     option1 = boolean()
    ...     option2 = boolean()
    ...     option3 = boolean(default=Bad_value)
    ...     [section1]
    ...     option1 = boolean()
    ...     option2 = boolean()
    ...     option3 = boolean(default=Bad_value)
    ...     [section2]
    ...     another_option = boolean()
    ...     [section3]
    ...     another_option = boolean()
    ...     [[section3b]]
    ...     value = integer
    ...     value2 = integer
    ...     value3 = integer(0, 10)
    ...         [[[section3b-sub]]]
    ...         value = string
    ...     [section4]
    ...     another_option = boolean()
    ...     '''
    >>> cs = my_cfg.split('\\n')
    >>> ini = my_ini.split('\\n')
    >>> cfg = ConfigObj(ini, configspec=cs)
    >>> res = cfg.validate(vtor, preserve_errors=True)
    >>> errors = []
    >>> for entry in flatten_errors(cfg, res):
    ...     section_list, key, error = entry
    ...     section_list.insert(0, '[root]')
    ...     if key is not None:
    ...        section_list.append(key)
    ...     else:
    ...         section_list.append('[missing]')
    ...     section_string = ', '.join(section_list)
    ...     errors.append((section_string, ' = ', error))
    >>> errors.sort()
    >>> for entry in errors:
    ...     print entry[0], entry[1], (entry[2] or 0)
    [root], option2  =  0
    [root], option3  =  the value "Bad_value" is of the wrong type.
    [root], section1, option2  =  0
    [root], section1, option3  =  the value "Bad_value" is of the wrong type.
    [root], section2, another_option  =  the value "Probably" is of the wrong type.
    [root], section3, section3b, section3b-sub, [missing]  =  0
    [root], section3, section3b, value2  =  the value "a" is of the wrong type.
    [root], section3, section3b, value3  =  the value "11" is too big.
    [root], section4, [missing]  =  0
    """
    if levels is None:
        # first time called
        levels = []
        results = []
    if res is True:
        return results
    if res is False or isinstance(res, Exception):
        results.append((levels[:], None, res))
        if levels:
            levels.pop()
        return results
    for (key, val) in res.items():
        if val == True:
            continue
        if isinstance(cfg.get(key), dict):
            # Go down one level
            levels.append(key)
            flatten_errors(cfg[key], val, levels, results)
            continue
        results.append((levels[:], key, val))
    #
    # Go up one level
    if levels:
        levels.pop()
    #
    return results


"""*A programming language is a medium of expression.* - Paul Graham"""

########NEW FILE########
__FILENAME__ = editor
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

"""A generic, extensible preferences dialog

Usage:

    dialog = PreferenceEditor(parent, title, preferences, style)
    dialog.ShowModal()

preferences is a any object with attribute preferecne_panels, which in turn
is a list or tuple of classes that inherit from PreferencesPanel.

style may have any of the values "auto", "notebook", "tree" or
"single". If style is "auto", the choice of using a single window, a
notebook, or a tree will depend on how many pages will be in the
dialog.

"""

import wx

# any more than TREE_THRESHOLD panels when style is "auto" forces
# the UI into showing a hierarchical tree
TREE_THRESHOLD = 5


class PreferenceEditor(wx.Dialog):
    """A dialog for showing the preference panels"""
    def __init__(self, parent, title, preferences, style="auto"):
        panels = preferences.preference_panels
        self._current_panel = None
        self._panels = []
        self._settings = preferences.settings
        wx.Dialog.__init__(self, parent, wx.ID_ANY, title, size=(800,400),
                           style=wx.RESIZE_BORDER|wx.DEFAULT_DIALOG_STYLE)

        if style not in ("tree","notebook","single","auto"):
            raise Exception("invalid style; must be one of 'tree','notebook','single' or 'auto'")

        if style == "tree" or (style == "auto" and len(panels) > TREE_THRESHOLD):
            self._sw = wx.SplitterWindow(self, wx.ID_ANY, style=wx.SP_LIVE_UPDATE|wx.SP_3D)
            self._tree = wx.TreeCtrl(self._sw, wx.ID_ANY, style=wx.TR_HIDE_ROOT|wx.TR_HAS_BUTTONS)
            # create a single container which will hold all of the
            # preference panels
            self._container = PanelContainer(self._sw, wx.ID_ANY)
            self._sw.SplitVertically(self._tree, self._container, 210)
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.Add(self._sw, 1, wx.EXPAND)
            self._tree.Bind(wx.EVT_TREE_SEL_CHANGED, self.OnTreeSelection)
            self._populate_tree(panels)
            self._tree.SelectItem(self._tree.GetFirstChild(self._tree.GetRootItem())[0])
            self.SetSizer(sizer)

        elif style == "notebook" or (style == "auto" and len(panels) > 1):
            # the tabs appear in alphabetical order based on their
            # location. This has the pleasant side effect of "General"
            # coming before "Plugins", but if some plugin adds a
            # location of ("aaa","me first!") it will come before
            # "General". I need some way to order them, though maybe
            # just special-casing "General" to come first might be
            # good enough?
            self._notebook = wx.Notebook(self)
            for panel_class in sorted(panels, key=lambda p: p.location):
                # for a notebook, each notebook page gets a container,
                # and that container will only show one panel
                container = PanelContainer(self._notebook)
                panel = container.AddPanel(panel_class)
                container.ShowPanel(panel)
                self._notebook.AddPage(container, panel.GetTitle())
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.Add(self._notebook, 1, wx.EXPAND)
            self.SetSizer(sizer)

        else:
            self._container = PanelContainer(self, wx.ID_ANY)
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.Add(self._container, 1, wx.EXPAND)
            self.SetSizer(sizer)

            panel = self._container.AddPanel(panels[0])
            self._container.ShowPanel(panel)
        self.Bind(wx.EVT_CLOSE, self._notify_close)

    def _notify_close(self, event):
        for p in self._panels:
            p.close()
        event.Skip()

    def OnTreeSelection(self, event):
        """Show panel that corresponds to selected tree item

        Used only when the hierarchical tree is shown.
        """
        pydata = self._tree.GetItemPyData(event.GetItem())

        if pydata is None:
            panel_class = GenericPreferencesPanel
        else:
            panel_class = pydata

        if isinstance(panel_class, wx.Panel):
            panel = pydata
        else:
            # not an instance, assume it's a class
            panel = self._container.AddPanel(panel_class, self._settings)
            self._panels.append(panel)
            self._tree.SetItemPyData(event.GetItem(), panel)
        self._container.ShowPanel(panel)

    def _populate_tree(self, panels):
        """Recreate the hierarchical tree of preferences panels

        Used only when the hierarchical tree is shown.
        """
        root = self._tree.AddRoot("Root")
        for panel_class in panels:
            location = panel_class.location
            if not isinstance(location, tuple):
                # location should be a tuple, but it's easy to accidentally
                # make it not a tuple (eg: ("Plugins")). This fixes that.
                location = (location,)
            item = self._get_item(location)
            self._tree.SetItemPyData(item, panel_class)
        self._tree.ExpandAll()

    def _get_item(self, location):
        item = self._tree.GetRootItem()
        for text in location:
            item = self._get_child_item(item, text)
        return item

    def _get_child_item(self, parent, text):
        """Returns the tree item with the given text under the given parent

        This will create the item if it doesn't exist
        """
        if self._tree.ItemHasChildren(parent):
            item, cookie = self._tree.GetFirstChild(parent)
            while item:
                if self._tree.GetItemText(item).strip().lower() == text.strip().lower():
                    return item
                item, cookie = self._tree.GetNextChild(parent, cookie)
        # if we get here we didn't find the item
        item = self._tree.AppendItem(parent, text)
        return item

    def _get_children(self, parent):
        if self._tree.ItemHasChildren(parent):
            item, cookie = self._tree.GetFirstChild(parent)
            while item:
                yield item
                item, cookie = self._tree.GetNextChild(parent, cookie)


class PanelContainer(wx.Panel):
    """This contains a preference panel.

    This container has the ability to hold several panels,
    and to be able to switch between them. For some modes, however,
    the container will only hold a single panel.

    Each page has a title area, and an area for a preferences panel
    """
    def __init__(self, *args, **kwargs):
        super(PanelContainer, self).__init__(*args, **kwargs)

        self._current_panel = None
        self.title = wx.StaticText(self, label="Your message here")
        self.panels_container = wx.Panel(self)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.title, 0, wx.TOP|wx.LEFT|wx.EXPAND, 4)
        sizer.Add(wx.StaticLine(self), 0, wx.EXPAND|wx.TOP|wx.BOTTOM, 4)
        sizer.Add(self.panels_container,1, wx.EXPAND)
        self.SetSizer(sizer)
        self.panels_container.SetSizer(wx.BoxSizer(wx.VERTICAL))

        font = self.title.GetFont()
        font.SetPointSize(font.GetPointSize()+2)
        self.title.SetFont(font)
        self.title.SetForegroundColour("#000000")

    def AddPanel(self, panel_class, settings):
        """Add a panel to the dialog"""
        panel = panel_class(parent=self.panels_container, settings=settings)
        self.panels_container.GetSizer().Add(panel, 1, wx.EXPAND)
        return panel

    def ShowPanel(self, panel):
        """Arrange for the given panel to be shown"""
        if self._current_panel is not None:
            self._current_panel.Hide()
        self._current_panel = panel
        panel.Show()
        sizer = self.panels_container.GetSizer()
        item = sizer.GetItem(panel)
        title = getattr(panel, "title", panel.location[-1])
        self.title.SetLabel(title)
        if item is None:
            sizer.Add(panel, 1, wx.EXPAND)
        sizer.Layout()

    def SetTitle(self, title):
        """Set the title of the panel"""
        self.title.SetLabel(title)



########NEW FILE########
__FILENAME__ = excludes
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from datetime import datetime
from fnmatch import fnmatch
import os
import wx
from robotide.widgets import Dialog, HtmlWindow
from .widgets import PreferencesPanel

class Excludes():

    def __init__(self, directory):
        self._settings_directory = directory
        self._exclude_file_path = os.path.join(self._settings_directory, 'excludes')

    def get_excludes(self, separator='\n'):
        return separator.join(self._get_excludes())

    def _get_excludes(self):
        with self._get_exclude_file('r') as exclude_file:
            if not exclude_file:
                return set()
            return set(exclude_file.read().split())

    def remove_path(self, path):
        path = self._normalize(path)
        excludes = self._get_excludes()
        self.write_excludes(set([e for e in excludes if e != path]))

    def write_excludes(self, excludes):
        excludes = [self._normalize(e) for e in excludes]
        with self._get_exclude_file(read_write='w') as exclude_file:
            for exclude in excludes:
                if not exclude:
                    continue
                exclude_file.write("%s\n" % exclude)

    def update_excludes(self, new_excludes):
        excludes = self._get_excludes()
        self.write_excludes(excludes.union(new_excludes))

    def _get_exclude_file(self, read_write):
        if not os.path.exists(self._exclude_file_path) and read_write.startswith('r'):
            if not os.path.isdir(self._settings_directory):
                os.makedirs(self._settings_directory)
            return open(self._exclude_file_path, 'w+')
        if os.path.isdir(self._exclude_file_path):
            raise NameError('"%s" is a directory, not file' % self._exclude_file_path)
        try:
            return open(self._exclude_file_path, read_write)
        except IOError as e:
            raise e #TODO FIXME

    def contains(self, path, excludes=None):
        if not path:
            return False
        excludes = excludes or self._get_excludes()
        if len(excludes) < 1:
            return False
        path = self._normalize(path)
        excludes = [self._normalize(e) for e in excludes]
        return any(self._match(path, e) for e in excludes)

    def _match(self, path, e):
        return fnmatch(path, e) or path.startswith(e)

    def _normalize(self, path):
        if not (path or path.strip()):
            return None
        path = os.path.normcase(os.path.normpath(path))
        ext = os.path.splitext(path)[1]
        if not ext and not path.endswith(('*', '?', ']')):
            path += os.sep
            if '*' in path or '?' in path or ']' in path:
                path += '*'
        return path


class ExcludePreferences(PreferencesPanel):
    location = ('Excludes')
    title = 'Excludes'

    def __init__(self, settings, *args, **kwargs):
        super(ExcludePreferences, self).__init__(*args, **kwargs)
        self._settings = settings
        self._create_sizer()

    def _create_sizer(self):
        sizer = wx.BoxSizer(orient=wx.VERTICAL)
        self._add_help_dialog(sizer)
        self._add_text_box(sizer)
        self._add_button_and_status(sizer)
        self.SetSizer(sizer)

    def _add_help_dialog(self, sizer):
        sizer.Add(wx.HyperlinkCtrl(self, wx.ID_ANY, '', 'Need help?'))
        self.Bind(wx.EVT_HYPERLINK, self.OnHelp)

    def _add_text_box(self, sizer):
        self._text_box = wx.TextCtrl(self,
            style=wx.TE_MULTILINE,
            size=wx.Size(570, 100),
            value=self._settings.excludes.get_excludes())
        sizer.Add(self._text_box, proportion=wx.EXPAND)

    def _add_button_and_status(self, sizer):
        status_and_button_sizer = wx.GridSizer(rows=1, cols=2, hgap=10)
        status_and_button_sizer.Add(wx.Button(self, id=wx.ID_SAVE))
        self.Bind(wx.EVT_BUTTON, self.OnSave)
        self._status_label = wx.StaticText(self)
        status_and_button_sizer.Add(self._status_label)
        sizer.Add(status_and_button_sizer)

    def OnSave(self, event):
        text = self._text_box.GetValue()
        self._settings.excludes.write_excludes(set(text.split('\n')))
        save_label = 'Saved at %s. Reload the project for changes to take an effect.' % datetime.now().strftime('%H:%M:%S')
        self._status_label.SetLabel(save_label)

    def OnHelp(self, event):
        dialog = ExcludeHelpDialog()
        dialog.Show()

class ExcludeHelpDialog(Dialog):
    help = """<font size="5">
<h1>Excludes</h1>
<p>
Paths to excludes are described in the text box, one exclude per row.
These excludes are saved in a file which is located at $HOME/.robotframework/ride/excludes on POSIX-systems and
%APPDATA%\\RobotFramework\\ride\\excludes on Windows.
</p>
<p>
You can edit excludes yourself using either the text box or editing the file with an editor. After hitting "Save", close
the Preferences window and reload the project to make the edited exludes to take effect. You can reload the project by
selecting "File" from the main menu bar and then selecting your project from the list in view.
</p>
<h2>Patterns in paths</h2>
<p>
RIDE supports defining excludes with absolute paths. You can achieve relative paths with path patterns which are
also supported.
</p>
<p>
The following shell-style wildcards are supported:
<table width="100%" border="1">
    <thead>
        <th><b>Pattern</b></th>
        <th><b>Meaning</b></th>
        <th><b>Examples</b></th>
    </thead>
    <tbody>
        <tr>
            <td valign="top" align="center">*</td>
            <td valign="top" align="center">matches everything</td>
            <td valign="top" align="left">
                Pattern /foo/*/quu matches:
                <ul>
                    <li>/foo/bar/quu</li>
                    <li>/foo/corge/quu</li>
                    <li><i>etc.</i></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td valign="top" align="center">?</td>
            <td valign="top" align="center">matches any single character</td>
            <td valign="top" align="left">
                Pattern C:\MyProject\?oo matches:
                <ul>
                    <li>C:\MyProject\\foo</li>
                    <li>C:\MyProject\\boo</li>
                    <li><i>etc.</i></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td valign="top" align="center">[seq]</td>
            <td valign="top" align="center">matches any character in <i>seq</i></td>
            <td valign="top" align="left">
               Pattern C:\MyProject\[bf]oo matches:
                <ul>
                    <li>C:\MyProject\\foo</li>
                    <li>C:\MyProject\\boo</li>
                    <li><i>and nothing else</i></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td valign="top" align="center">[!seq]</td>
            <td valign="top" align="center">matches any character not in <i>seq</i></td>
            <td valign="top" align="left">
                Pattern /foo/[!q]uu matches:
                <ul>
                    <li>/foo/zuu</li>
                    <li><i>etc.</i></li>
                </ul>
                But does not match:
                <ul>
                    <li>/foo/quu</li>
                </ul>
            </td>
        </tr>
    </tbody>
</table>
</p>
</font>"""

    def __init__(self):
        Dialog.__init__(self, title='Help: excludes')
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(HtmlWindow(self, (800, 600), self.help),
                  1,
                  flag=wx.EXPAND)
        self.SetSizerAndFit(sizer)

    def OnKey(self, *args):
        pass


########NEW FILE########
__FILENAME__ = imports
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

from robotide.widgets import (Label, TextField, VerticalSizer, HorizontalSizer,
        HelpLabel)

from .widgets import PreferencesPanel


class ImportPreferences(PreferencesPanel):
    location = ('Importing')
    title = 'Automatic imports and PYTHONPATH'
    def __init__(self, parent, settings):
        super(PreferencesPanel, self).__init__(parent)
        self.SetSizer(VerticalSizer())
        self._settings = [
            Setting(settings, 'auto imports',
                    'Comma separated list of libraries to be automatically imported.'),
            Setting(settings, 'pythonpath',
                    'Comma separated list of directories to be added to PYTHONPATH when libraries are searched.'),
            Setting(settings, 'library xml directories',
                    'Directories to search for library xml files')
        ]
        for s in self._settings:
            self._create_editor(s)

    def _create_editor(self, setting):
        sizer = HorizontalSizer()
        sizer.add_with_padding(self._label_for(setting))
        sizer.add(self._editor_for(setting), proportion=1)
        self.Sizer.Add(sizer, flag=wx.EXPAND)
        self.Sizer.add_with_padding(HelpLabel(self, setting.help))

    def _label_for(self, setting):
        label = ('%s: ' % setting.name).capitalize()
        return Label(self, label=label)

    def _editor_for(self, setting):
        initial_value = ', '.join(setting.current_value)
        editor = TextField(self, initial_value)
        editor.Bind(wx.EVT_TEXT, lambda evt: setting.set(editor.GetValue()))
        return editor

    def close(self):
        for s in self._settings:
            s.publish()


class Setting(object):

    def __init__(self, settings, name, help):
        self._settings = settings
        self.name = name
        self.help = help
        self._original_value = settings[name]
        self.current_value = self._original_value

    def set(self, new_value):
        self.current_value = [token.strip() for token in new_value.split(',') if token.strip()]

    def publish(self):
        self._settings.set(self.name, self.current_value)
        self._settings.notify(self.name, self._original_value, self.current_value)

########NEW FILE########
__FILENAME__ = saving
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import textwrap

from .widgets import (PreferencesPanel, PreferencesComboBox,
        IntegerPreferenceComboBox)
from robotide.widgets import HelpLabel


class _ChoiceEditor(object):
    _editor_class = None

    def __init__(self, settings, setting_name, label, choices, help=''):
        self._settings = settings
        self._setting_name = setting_name
        self._label = label
        self._choices = choices
        self._help = help

    def chooser(self, parent):
        return self._editor_class(parent, wx.ID_ANY, self._settings,
                                  key=self._setting_name, choices=self._choices)

    def label(self, parent):
        return wx.StaticText(parent, wx.ID_ANY, self._label)

    def help(self, parent):
        return HelpLabel(parent, '\n'.join(textwrap.wrap(self._help, 60)))


class StringChoiceEditor(_ChoiceEditor):
    _editor_class = PreferencesComboBox

class IntegerChoiceEditor(_ChoiceEditor):
    _editor_class = IntegerPreferenceComboBox


class SavingPreferences(PreferencesPanel):
    location = ('Saving',)
    title = 'Saving Preferences'

    def __init__(self, settings, *args, **kwargs):
        super(SavingPreferences, self).__init__(*args, **kwargs)
        self._settings = settings
        self.SetSizer(wx.FlexGridSizer(rows=7, cols=2))
        for editor in self._create_editors(settings):
            self._add_editor(editor)

    def _create_editors(self, settings):
        return [
            StringChoiceEditor(settings,
                'default file format',
                'Default file format:',
                ('txt', 'tsv', 'html', 'robot')
            ),
            StringChoiceEditor(settings,
                'txt format separator',
                'TXT format separator:',
                ('pipe', 'space')
            ),
            StringChoiceEditor(settings,
                'line separator',
                'Line separator:',
                ('native', 'CRLF', 'LF'),
                'Possible values are native (of current OS) CRLF (Windows) and LF (Unixy)'
            ),
            IntegerChoiceEditor(settings,
                'txt number of spaces',
                'Separating spaces',
                [str(i) for i in range(2, 11)],
                'Number of spaces between cells when saving in txt format'
            )
        ]

    def _add_editor(self, editor):
        self.Sizer.AddMany([editor.label(self), (editor.chooser(self),)])
        self.Sizer.AddMany([(editor.help(self), 0, wx.BOTTOM, 10),
                            wx.Window(self)])

########NEW FILE########
__FILENAME__ = settings
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from __future__ import with_statement
import os
import shutil

from robotide.context.platform import IS_WINDOWS
from robotide.preferences.configobj import ConfigObjError
from .configobj import ConfigObj, Section, UnreprError
from .excludes import Excludes

if IS_WINDOWS:
    SETTINGS_DIRECTORY = os.path.join(os.environ['APPDATA'], 'RobotFramework', 'ride')
else:
    SETTINGS_DIRECTORY = os.path.join(os.path.expanduser('~/.robotframework'), 'ride')

def initialize_settings(type, path, dest_file_name=None):
    if not os.path.exists(SETTINGS_DIRECTORY):
        os.makedirs(SETTINGS_DIRECTORY)
    if type == 'user settings':
        return _copy_or_migrate_user_settings(SETTINGS_DIRECTORY, path, dest_file_name)

def _copy_or_migrate_user_settings(settings_dir, source_path, dest_file_name):
    """ Creates settings directory and copies or merges the source to there.

    In case source already exists, merge is done.
    Destination file name is the source_path's file name unless dest_file_name
    is given.
    """
    if not dest_file_name:
        dest_file_name = os.path.basename(source_path)
    settings_path = os.path.join(settings_dir, dest_file_name)
    if not os.path.exists(settings_path):
        shutil.copyfile(source_path, settings_path)
    else:
        try:
            SettingsMigrator(source_path, settings_path).migrate()
        except ConfigObjError, parsing_error:
            print 'WARNING! corrupted configuration file replaced with defaults'
            print parsing_error
            shutil.copyfile(source_path, settings_path)
    return os.path.abspath(settings_path)

class SettingsMigrator(object):

    SETTINGS_VERSION = 'settings_version'
    CURRENT_SETTINGS_VERSION = 4 #used at least in tests

    def __init__(self, default_path, user_path):
        self._default_settings = ConfigObj(default_path, unrepr=True)
        self._user_path = user_path
        try:
            self._old_settings = ConfigObj(user_path, unrepr=True)
        except UnreprError, err:
            raise ConfigurationError("Invalid config file '%s': %s" %
                            (user_path, err))

    def migrate(self):
        # Add migrations here.
        # idea is that we are able to migrate from any of the previous settings
        # versions to the current one by applying as many migration scripts as
        # is needed --> so don't do migrate_from_0_to_3 or something other
        # that will leap over some versions to save space
        # NOTE!
        # Don't count on default settings when giving values in migration scripts
        # as default values could change in the future --> state after your
        # migration is something else then what you intended and this could
        # mess up the next migration script(s)
        if not self._old_settings.get(self.SETTINGS_VERSION):
            self.migrate_from_0_to_1(self._old_settings)
        if self._old_settings.get(self.SETTINGS_VERSION) == 1:
            self.migrate_from_1_to_2(self._old_settings)
        if self._old_settings.get(self.SETTINGS_VERSION) == 2:
            self.migrate_from_2_to_3(self._old_settings)
        if self._old_settings.get(self.SETTINGS_VERSION) == 3:
            self.migrate_from_3_to_4(self._old_settings)
        if self._old_settings.get(self.SETTINGS_VERSION) == 4:
            self.migrate_from_4_to_5(self._old_settings)
        #so next would be something like:
        #if self._old_settings[self.SETTINGS_VERSION] == 5:
        #   self.migrate_from_5_to_6(self._old_settings)
        self.merge()

    def merge(self):
        self._default_settings.merge(self._old_settings)
        self._write_merged_settings(self._default_settings, self._user_path)

    def migrate_from_0_to_1(self, settings):
        if settings.get('Colors',{}).get('text library keyword') == 'blue':
            settings['Colors']['text library keyword'] = '#0080C0'
        settings[self.SETTINGS_VERSION] = 1

    def migrate_from_1_to_2(self, settings):
        # See issue http://code.google.com/p/robotframework-ride/issues/detail?id=925
        # And other reported issues about test run failure after pythonpath was added
        # to run
        pythonpath = settings.get('pythonpath', [])
        if pythonpath:
            settings['pythonpath'] = [p.strip() for p in pythonpath if p.strip()]
        settings[self.SETTINGS_VERSION] = 2

    def migrate_from_2_to_3(self, settings):
        # See issue http://code.google.com/p/robotframework-ride/issues/detail?id=1107
        excludes = os.path.join(SETTINGS_DIRECTORY, 'excludes')
        if os.path.isfile(excludes):
            with open(excludes) as f:
                old = f.read()
            new = '\n'.join(d for d in old.split('\n') if os.path.isdir(d))+'\n'
            with open(excludes, 'w') as f:
                f.write(new)
        settings[self.SETTINGS_VERSION] = 3

    def migrate_from_3_to_4(self, settings):
        # See issue http://code.google.com/p/robotframework-ride/issues/detail?id=1124
        font_size = settings.get('font size', None)
        if font_size and font_size == 11:
            settings['font size'] = 8
        settings[self.SETTINGS_VERSION] = 4

    def migrate_from_4_to_5(self, settings):
        # Changed color section name; see http://code.google.com/p/robotframework-ride/issues/detail?id=1206
        colors = settings.get('Colors', None)
        if colors:
            settings['Grid Colors'] = colors
            # TODO FIXME: should old section 'Colors' be deleted?
            del settings['Colors']

    def _write_merged_settings(self, settings, path):
        try:
            with open(path, 'wb') as outfile:
                settings.write(outfile)
        except IOError:
            raise RuntimeError('Could not open settings file "%s" for writing' %
                                   path)


class SectionError(Exception):
    """Used when section is tried to replace with normal value or vice versa."""


class ConfigurationError(Exception):
    """Used when settings file is invalid"""


class _Section:

    def __init__(self, section, parent):
        self._config_obj = section
        self._parent = parent

    def save(self):
        self._parent.save()

    def __setitem__(self, name, value):
        self.set(name, value)

    def __getitem__(self, name):
        value = self._config_obj[name]
        if isinstance(value, Section):
            return _Section(value, self)
        return value

    def __iter__(self):
        return iter(self._config_obj)

    def __len__(self):
        return len(self._config_obj)

    def iteritems(self):
        '''Returns an iterator over the (key,value) items of the section'''
        return self._config_obj.iteritems()

    def has_setting(self, name):
        return self._config_obj.has_key(name)

    def get(self, name, default):
        """Returns specified setting or (automatically set) default."""
        try:
            return self[name]
        except KeyError:
            self.set(name, default)
            return default

    def get_without_default(self, name):
        """Returns specified setting or None if setting is not defined."""
        try:
            return self[name]
        except KeyError:
            return None

    def set(self, name, value, autosave=True, override=True):
        """Sets setting 'name' value to 'value'.

        'autosave' can be used to define whether to save or not after values are
        changed. 'override' can be used to specify whether to override existing
        value or not. Setting which does not exist is anyway always created.
        """
        if self._is_section(name) and not isinstance(value, _Section):
            raise SectionError("Cannot override section with value.")
        if isinstance(value, _Section):
            if override:
                self._config_obj[name] = {}
            for key, _value in value._config_obj.items():
                self[name].set(key, _value, autosave, override)
        elif name not in self._config_obj or override:
            self._config_obj[name] = value
            if autosave:
                self.save()

    def set_values(self, settings, autosave=True, override=True):
        """Set values from settings. 'settings' needs to be a dictionary.

        See method set for more info about 'autosave' and 'override'.
        """
        if settings:
            for key, value in settings.items():
                self.set(key, value, autosave=False, override=override)
            if autosave:
                self.save()
        return self

    def set_defaults(self, settings_dict=None, **settings):
        """Sets defaults based on dict and kwargs, kwargs having precedence."""
        settings_dict = settings_dict or {}
        settings_dict.update(settings)
        return self.set_values(settings_dict, override=False)

    def add_section(self, name, **defaults):
        """Creates section or updates existing section with defaults."""
        if name in self._config_obj and not isinstance(self._config_obj[name], Section):
            raise SectionError('Cannot override value with section.')
        if name not in self._config_obj:
            self._config_obj[name] = {}
        return self[name].set_defaults(**defaults)

    def _is_section(self, name):
        return self._config_obj.has_key(name) and \
               isinstance(self._config_obj[name], Section)


class Settings(_Section):

    def __init__(self, user_path):
        try:
            self._config_obj = ConfigObj(user_path, unrepr=True)
        except UnreprError, error:
            raise ConfigurationError(error)
        self._listeners = []
        self.excludes = Excludes(SETTINGS_DIRECTORY)

    def save(self):
        self._config_obj.write()

    def add_change_listener(self, l):
        self._listeners.append(l)

    def notify(self, name, old_value, new_value):
        for l in self._listeners:
            l.setting_changed(name, old_value, new_value)

class RideSettings(Settings):

    def __init__(self):
        default_path = os.path.join(os.path.dirname(__file__), 'settings.cfg')
        user_path = initialize_settings('user settings', default_path)
        Settings.__init__(self, user_path)
        self._settings_dir = os.path.dirname(user_path)
        self.set('install root', os.path.dirname(os.path.dirname(__file__)))

    def get_path(self, *parts):
        """Returns path which combines settings directory and given parts."""
        return os.path.join(self._settings_dir, *parts)



########NEW FILE########
__FILENAME__ = widgets
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx


class PreferencesPanel(wx.Panel):
    """Base class for all preference panels used by PreferencesDialog"""
    location = ("Preferences",)
    title = "Preferences"

    def __init__(self, parent=None, *args, **kwargs):
        self.tree_item = None
        wx.Panel.__init__(self, parent, *args, **kwargs)

    def GetTitle(self):
        return getattr(self, "title", self.location[-1])

    def Separator(self, parent, title):
        """Creates a simple horizontal separator with title"""
        container = wx.Panel(parent, wx.ID_ANY)
        label = wx.StaticText(container, wx.ID_ANY, label=title)
        sep = wx.StaticLine(container, wx.ID_ANY)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(label, 0, wx.EXPAND|wx.TOP, 8)
        sizer.Add(sep, 0, wx.EXPAND|wx.TOP|wx.BOTTOM, 2)
        container.SetSizerAndFit(sizer)
        return container

    def close(self):
        """Callback to do actions when editor is closed."""
        pass


class PreferencesComboBox(wx.ComboBox):
    """A combobox tied to a specific setting. Saves value to disk after edit."""
    def __init__(self, parent, id, settings, key, choices):
        self.settings = settings
        self.key = key
        super(PreferencesComboBox, self).__init__(parent, id, self._get_value(),
                                                  choices=choices)
        self.Bind(wx.EVT_COMBOBOX, self.OnSelect)

    def _get_value(self):
        return self.settings[self.key]

    def OnSelect(self, event):
        self._set_value(str(event.GetEventObject().GetValue()))
        self.settings.save()

    def _set_value(self, value):
        self.settings[self.key] = value


class IntegerPreferenceComboBox(PreferencesComboBox):
    """A combobox tied to a setting that has integer values."""

    def _get_value(self):
        return str(self.settings[self.key])

    def _set_value(self, value):
        self.settings[self.key] = int(value)


class PreferencesColorPicker(wx.ColourPickerCtrl):
    """A colored button that opens a color picker dialog"""
    def __init__(self, parent, id, settings, key):
        self.settings = settings
        self.key = key
        value = settings[key]
        super(PreferencesColorPicker, self).__init__(parent, id, col=value)
        self.Bind(wx.EVT_COLOURPICKER_CHANGED, self.OnPickColor)

    def OnPickColor(self, event):
        """Set the color for the given key to the color of the widget"""
        color = event.GetColour()
        rgb = "#%02X%02X%02X" % color.asTuple()
        self.settings[self.key] = rgb
        self.settings.save()

    def SetColour(self, colour):
        super(PreferencesColorPicker, self).SetColour(colour)
        self.settings[self.key] = colour
        self.settings.save()

########NEW FILE########
__FILENAME__ = messages
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org:licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from wx.lib.pubsub import Publisher as WxPublisher
import inspect
import messagetype
import sys
import traceback

from robotide import utils


class RideMessage(object):
    """Base class for all messages sent by RIDE.

    :CVariables:
      topic
        Topic of this message. If not overridden, value is got from the class
        name by lowercasing it, separating words with a dot and dropping possible
        ``Message`` from the end. For example classes ``MyExample`` and
        ``AnotherExampleMessage`` get titles ``my.example`` and
        ``another.example``, respectively.
      data
        Names of attributes this message provides. These must be given as
        keyword arguments to `__init__` when an instance is created.
    """
    __metaclass__ = messagetype.messagetype
    topic = None
    data = []

    def __init__(self, **kwargs):
        """Initializes message based on given keyword arguments.

        Names of the given keyword arguments must match to names in `data`
        class attribute, otherwise the initialization fails.

        Must be called explicitly by subclass if overridden.
        """
        if sorted(kwargs.keys()) != sorted(self.data):
            raise TypeError('Argument mismatch, expected: %s' % self.data)
        self.__dict__.update(kwargs)

    def publish(self):
        """Publishes the message.

        All listeners that have subscribed to the topic of this message will be
        called with the this instance as an argument.

        Notifications are sent sequentially. Due to the limitations of current
        implementation, if any of the listeners raises an exception, subsequent
        listeners will not get the notification.
        """
        try:
            self._publish(self)
        except Exception, err:
            self._publish(RideLogException(message='Error in publishing message: ' + str(err),
                                           exception=err, level='ERROR'))

    def _publish(self, msg):
        WxPublisher().sendMessage(msg.topic, msg)


class RideLog(RideMessage):
    """This class represents a general purpose log message.

    Subclasses of this be may used to inform error conditions or to provide
    some kind of debugging information.
    """
    data = ['message', 'level', 'timestamp']


class RideLogMessage(RideLog):
    """This class represents a general purpose log message.

    This message may used to inform error conditions or to provide
    some kind of debugging information.
    """
    data = ['message', 'level', 'timestamp']

    def __init__(self, message, level='INFO'):
        """Initializes a RIDE log message.

        The log ``level`` has default value ``INFO`` and the ``timestamp``
        is generated automatically.
        """
        RideMessage.__init__(self, message=message, level=level,
                             timestamp=utils.get_timestamp())


class RideLogException(RideLog):
    """This class represents a general purpose log message with a traceback
    appended to message text. Also the original exception is included with
    the message.

    This message may used to inform error conditions or to provide
    some kind of debugging information.
    """
    data = ['message', 'level', 'timestamp', 'exception']

    def __init__(self, message, exception, level='INFO'):
        """Initializes a RIDE log exception.

        The log ``level`` has default value ``INFO`` and the ``timestamp``
        is generated automatically. Message is automatically appended with
        a traceback.
        """
        exc_type, exc_value, exc_traceback = sys.exc_info()
        if exc_traceback:
            tb = traceback.extract_tb(exc_traceback)
            message += '\n\nTraceback (most recent call last):\n%s\n%s' % (unicode(exception) ,''.join(traceback.format_list(tb)))
        RideMessage.__init__(self, message=message, level=level,
                             timestamp=utils.get_timestamp(),
                             exception=exception)


class RideInputValidationError(RideMessage):
    """Sent whenever user input is invalid."""
    data = ['message']


class RideModificationPrevented(RideMessage):
    """Sent whenever modifying command is prevented for some reason"""
    data = ['controller']


class RideSettingsChanged(RideMessage):
    """Sent when settings are changed

    keys is a tuple of key names. For example, if the "Grid Colors" section
    was modified the keys would be ("Grid Colors"), or a specific plugin
    setting might be ("Plugin", "Preview", "format").
    """
    data = ['keys']

class RideExecuteSpecXmlImport(RideMessage):
    """Sent whenever spec xml import is requested"""

class RideTreeSelection(RideMessage):
    """Sent whenever user selects a node from the tree."""
    data = ['node', 'item', 'silent']

class RideOpenVariableDialog(RideMessage):
    """Sent when variable dialog is requested to be open"""
    data = ['controller']

class RideTestExecutionStarted(RideMessage):
    """Sent whenever new test execution is started."""
    data = ['results']

class RideTestSelectedForRunningChanged(RideMessage):
    """Sent whenever a test is selected or unselected from the tree."""
    data = ['tests']

class RideTestRunning(RideMessage):
    """Sent whenever RIDE is starting to run a test case."""
    data = ['item']

class RideTestPassed(RideMessage):
    """Sent whenever RIDE has executed a test case and it passed."""
    data = ['item']

class RideTestFailed(RideMessage):
    """Sent whenever RIDE has executed a test case and it failed."""
    data = ['item']

class RideNotebookTabChanging(RideMessage):
    """Sent when the notebook tab change has started.

    Subscribing to this event allows the listener to do something before the
    tab has actually changed in the UI.
    """
    data = ['oldtab', 'newtab']


class RideNotebookTabChanged(RideMessage):
    """Sent after the notebook tab change has completed."""


class RideSaving(RideMessage):
    """Sent when user selects Save from File menu or via shortcut.

    This is used for example to store current changes from editor to data
    model, to guarantee that all changes are really saved."""
    data = ['path', 'datafile']


class RideSaved(RideMessage):
    """Sent after the file has been actually saved to disk."""
    data = ['path']


class RideSaveAll(RideMessage):
    """Sent when user selects ``Save All`` from ``File`` menu or via shortcut."""


class RideDataDirtyCleared(RideMessage):
    """Sent when datafiles dirty marking is cleared

    datafile has been saved and datafile in memory equals the serialized one.
    """
    data = ['datafile']


class RideNewProject(RideMessage):
    """Sent when a new project has been created."""
    data = ['path', 'datafile']


class RideClosing(RideMessage):
    """Sent when user selects ``Quit`` from ``File`` menu or via shortcut."""
    pass


class RideOpenSuite(RideMessage):
    """Sent when a new suite has finished loading."""
    data = ['path', 'datafile']


class RideOpenResource(RideMessage):
    """Sent when a new resource has finished loading."""
    data = ['path', 'datafile']


class RideSelectResource(RideMessage):
    """Sent when a resource should be selected."""
    data = ['item']


class RideDataChanged(RideMessage):
    """Base class for all messages notifying that data in model has changed."""


class RideFileNameChanged(RideDataChanged):
    """Sent after test case or resource file is renamed"""
    data = ['datafile', 'old_filename']


class RideDataFileRemoved(RideDataChanged):
    data = ['path', 'datafile']


class RideSuiteAdded(RideDataChanged):
    data = ['parent', 'suite']


class RideInitFileRemoved(RideDataChanged):
    data = ['path', 'datafile']


class RideImportSetting(RideDataChanged):
    """Base class for all messages about changes to import settings."""
    data = ['datafile', 'type', 'import_controller']

    def is_resource(self):
        return self.type == 'resource'

    @property
    def name(self):
        return self.import_controller.name

class _RideExcludes(RideMessage):
    data = ['old_controller', 'new_controller']

class RideIncludesChanged(_RideExcludes):
    pass

class RideExcludesChanged(_RideExcludes):
    pass


class RideImportSettingAdded(RideImportSetting):
    """Sent whenever an import setting is added.

    ``datafile`` is the suite or resource file whose imports have changed,
    ``type`` is either ``resource``, ``library``, or ``variables``.
    """
    pass


class RideImportSettingChanged(RideImportSetting):
    """Sent whenever a value of import setting is changed.

    ``datafile`` is the suite or resource file whose imports have changed,
    ``type`` is either ``resource``, ``library``, or ``variables``.
    """
    pass


class RideImportSettingRemoved(RideImportSetting):
    """Sent whenever a value of import setting is removed.

    ``datafile`` is the suite or resource file whose imports have removed,
    ``type`` is either ``resource``, ``library``, or ``variables``.
    """
    pass


class RideDataChangedToDirty(RideDataChanged):
    """Sent when datafile changes from serialized version"""
    data = ['datafile']


class RideDataFileSet(RideDataChanged):
    """Set when a whole datafile is replaced with new one in a controller
    """
    data = ['item']


class RideUserKeyword(RideDataChanged):
    """Base class for all messages about changes to any user keyword."""


class RideUserKeywordAdded(RideUserKeyword):
    """Sent when a new user keyword is added to a suite or resource."""
    data = ['datafile', 'name', 'item']


class RideUserKeywordRemoved(RideUserKeyword):
    """Sent when a user keyword is removed from a suite or resource."""
    data = ['datafile', 'name', 'item']


class RideItem(RideDataChanged):
    """Base class for all messages about changes to any data item."""
    data = ['item']


class RideItemStepsChanged(RideItem):
    """"""


class RideItemNameChanged(RideItem):
    """"""


class RideItemSettingsChanged(RideItem):
    """"""


class RideTestCaseAdded(RideDataChanged):
    """Sent when a new test case is added to a suite."""
    data = ['datafile', 'name', 'item']


class RideTestCaseRemoved(RideDataChanged):
    """Sent when a test case is removed from a suite."""
    data = ['datafile', 'name', 'item']


class RideItemMovedUp(RideDataChanged):
    """Sent when an item (test, keyword, variable) is moved up."""
    data = ['item']


class RideItemMovedDown(RideDataChanged):
    """Sent when an item (test, keyword, variable) is moved down."""
    data = ['item']


class RideVariableAdded(RideDataChanged):
    """Sent when a new variable is added to a suite."""
    data = ['datafile', 'name', 'item', 'index']


class RideVariableRemoved(RideDataChanged):
    """Sent when a variable is removed from a suite."""
    data = ['datafile', 'name', 'item']


class RideVariableMovedUp(RideItemMovedUp):
    """Sent when a variable is moved up
    item   is the item that has been moved up
    other  is the item that was swapped down
    """
    data = ['item', 'other']


class RideVariableMovedDown(RideItemMovedDown):
    """Sent when a variable is moved down
    item   is the item that has been moved down
    other  is the item that was swapped up
    """
    data = ['item', 'other']


class RideVariableUpdated(RideDataChanged):
    """Sent when the state of a variable is changed"""
    data = ['item']


class RideOpenTagSearch(RideMessage):
    """ Sent we when want to open Search Tags)"""
    data = ['includes','excludes']

__all__ = [ name for name, cls in globals().items()
            if inspect.isclass(cls) and issubclass(cls, RideMessage) ]

########NEW FILE########
__FILENAME__ = messagetype
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org:licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide import utils


class messagetype(type):

    def __new__(cls, name, bases, dct):
        if not dct.get('topic'):
            dct['topic'] = cls._get_topic_from(name)
        dct['topic'] = dct['topic'].lower()
        return type.__new__(cls, name, bases, dct)

    @staticmethod
    def _get_topic_from(classname):
        if classname.endswith('Message'):
            classname = classname[:-len('Message')]
        return utils.printable_name(classname, code_style=True).replace(' ', '.')

########NEW FILE########
__FILENAME__ = publisher
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from wx.lib.pubsub import Publisher as WxPublisher

from messages import RideLogException


class Publisher(object):

    def __init__(self):
        self._listeners = {}

    def publish(self, topic, data):
        WxPublisher().sendMessage(topic, data)

    def subscribe(self, listener, topic, key=None):
        """Start to listen to messages with the specified ``topic``.

        The ``topic`` can be either a message class or a dot separated topic
        string, and the ``listener`` must be a callable accepting a message
        instance. See the generic documentation of the `robotide.publish`
        module for more details.

        The ``key`` is used for keeping a reference of the listener so that
        all listeners with the same key can be unsubscribed at once using
        ``unsubscribe_all``.
        """
        wrapper = _ListenerWrapper(listener, topic)
        self._listeners.setdefault(key, []).append(wrapper)

    def unsubscribe(self, listener, topic, key=None):
        """Stop listening for messages with the specified ``topic``.

        The ``topic``, the ``listener``, and the ``key`` must match the
        values passed to `subscribe` earlier.
        """
        for wrapper in self._listeners[key]:
            if wrapper.wraps(listener, topic):
                wrapper.unsubscribe()
                self._listeners[key].remove(wrapper)
                break

    def unsubscribe_all(self, key=None):
        """Unsubscribe all listeners registered with the given ``key``"""
        for wrapper in self._listeners[key]:
            wrapper.unsubscribe()
        del self._listeners[key]


class _ListenerWrapper:
    # Must be an old-style class because wxPython's pubsub doesn't handle
    # new-style classes in 2.8.7.1. Newer versions have that bug fixed.

    def __init__(self, listener, topic):
        self.listener = listener
        self.topic = self._get_topic(topic)
        WxPublisher().subscribe(self, self.topic)

    def _get_topic(self, topic):
        if not isinstance(topic, basestring):
            topic = topic.topic
        return topic.lower()

    def wraps(self, listener, topic):
        return self.listener == listener and self.topic == self._get_topic(topic)

    def unsubscribe(self):
        WxPublisher().unsubscribe(self, self.topic)

    def __call__(self, event):
        try:
            self.listener(event.data)
        except Exception, err:
            # Prevent infinite recursion if RideLogMessage listener is broken,
            if not isinstance(event.data, RideLogException):
                RideLogException(message='Error in listener: %s\n' \
                                         'While handling %s' % (unicode(err),
                                                                unicode(event.data)),
                                 exception=err, level='ERROR').publish()

########NEW FILE########
__FILENAME__ = recentfiles
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os.path
import wx

from robotide.publish import RideOpenSuite, RideFileNameChanged
from robotide.pluginapi import Plugin, ActionInfo, SeparatorInfo
from robotide.publish.messages import RideNewProject, RideSaved


def normalize_path(path):
    if os.path.basename(path).startswith('__init__.'):
        return os.path.dirname(path)
    return os.path.abspath(path)


class RecentFilesPlugin(Plugin):
    """Add recently opened files to the file menu."""

    def __init__(self, application=None):
        settings = {'recent_files':[], 'max_number_of_files':4}
        Plugin.__init__(self, application, default_settings=settings)

    def enable(self):
        self._save_currently_loaded_suite()
        self._add_recent_files_to_menu()
        self._new_project_path = None
        self.subscribe(self.OnSuiteOpened, RideOpenSuite)
        self.subscribe(self.OnFileNameChanged, RideFileNameChanged)
        self.subscribe(self.OnNewProjectOpened, RideNewProject)
        self.subscribe(self.OnSaved, RideSaved)
        # TODO: This plugin doesn't currently support resources
        # self._frame.subscribe(self.OnSuiteOpened, ('core', 'open','resource'))

    def disable(self):
        self.unregister_actions()
        self.unsubscribe(self.OnSuiteOpened, RideOpenSuite)
        self.unsubscribe(self.OnNewProjectOpened, RideNewProject)
        self.unsubscribe(self.OnSaved, RideSaved)

    def OnSuiteOpened(self, event):
        # Update menu with CallAfter to ensure ongoing menu selection
        # handling has finished before menu is changed
        wx.CallAfter(self._add_to_recent_files, event.path)
        self._new_project_path = None

    def OnFileNameChanged(self, event):
        self._new_project_path = None
        if not event.old_filename:
            return
        old_filename = normalize_path(event.old_filename)
        new_filename = normalize_path(event.datafile.filename)
        if old_filename not in self.recent_files:
            return
        index = self.recent_files.index(old_filename)
        self.recent_files[index] = new_filename
        self._save_settings_and_update_file_menu()

    def OnNewProjectOpened(self, event):
        self._new_project_path = event.path

    def OnSaved(self, event):
        if self._new_project_path is not None:
            wx.CallAfter(self._add_to_recent_files, self._new_project_path)
            self._new_project_path = None

    def _get_file_menu(self):
        menubar = self.get_menu_bar()
        pos = menubar.FindMenu('File')
        file_menu = menubar.GetMenu(pos)
        return file_menu

    def _save_currently_loaded_suite(self):
        model = self.model
        if model and model.suite:
            self._add_to_recent_files(model.suite.source)

    def _add_to_recent_files(self, path):
        if not path:
            return
        path = normalize_path(path)
        if path in self.recent_files:
            self.recent_files.remove(path)
        self.recent_files.insert(0, path)
        self.recent_files = self.recent_files[:self.max_number_of_files]
        self._save_settings_and_update_file_menu()

    def _save_settings_and_update_file_menu(self):
        self.save_setting('recent_files', self.recent_files)
        self.unregister_actions()
        self._add_recent_files_to_menu()

    def _add_recent_files_to_menu(self):
        if not self.recent_files:
            action = ActionInfo('File', 'No recent files')
            action.set_menu_position(before='Exit')
            self.register_action(action)
        else:
            for n, path in enumerate(self.recent_files):
                self._add_file_to_menu(path, n)
        sep = SeparatorInfo('File')
        sep.set_menu_position(before='Exit')
        self.register_action(sep)

    def _add_file_to_menu(self, path, n):
        entry = RecentFileEntry(n+1, path, self)
        self.register_action(entry.get_action_info())


class RecentFileEntry(object):

    def __init__(self, index, file, plugin):
        self.file = file
        self.index = index
        self.path = normalize_path(self.file)
        self.filename = os.path.basename(file)
        self.plugin = plugin
        self.label = '&%s: %s' % (index, self.filename)
        self.doc = 'Open %s' % self.path

    def OnOpenRecent(self, event):
        if not self.plugin.frame.check_unsaved_modifications():
            return
        self.plugin.open_suite(self.path)

    def get_action_info(self):
        action_info = ActionInfo('File', self.label, self.OnOpenRecent,
                                 doc=self.doc)
        action_info.set_menu_position(before='Exit')
        return action_info


########NEW FILE########
__FILENAME__ = robotapi
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import robot.parsing.populators
robot.parsing.populators.PROCESS_CURDIR = False

from robot.version import get_version
from robot.utils import normpath, NormalizedDict
from robot.common.handlers import UserErrorHandler
from robot.parsing import TestCaseFile, ResourceFile, TestDataDirectory
from robot.parsing.model import TestCase, UserKeyword
from robot.parsing.datarow import DataRow
from robot.parsing.model import Variable
from robot.running import TestLibrary
from robot.output import LOGGER as ROBOT_LOGGER
from robot.variables import Variables as RobotVariables
from robot.variables import is_scalar_var, is_list_var, is_var, VariableSplitter


ROBOT_VERSION = get_version()

########NEW FILE########
__FILENAME__ = configmanagerui
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx.lib.mixins.listctrl import TextEditMixin

from robotide.editor.listeditor import AutoWidthColumnList, ListEditorBase
from robotide.widgets import Dialog, HelpLabel


_CONFIG_HELP = '\n\n'.join([ txt for txt in
'''The specified command string will be split from whitespaces into a command
and its arguments. If either the command or any of the arguments require
internal spaces, they must be written as '<SPACE>'.'''.replace('\n', ' '),
'''The command will be executed in the system directly without opening a shell.
This means that shell commands and extensions are not available. For example,
in Windows batch files to execute must contain the '.bat' extension and 'dir'
command does not work.'''.replace('\n', ' '),
'''Examples:
    pybot.bat --include smoke C:\\my_tests
    svn update /home/robot
    C:\\Program<SPACE>Files\\App\\prg.exe argument<SPACE>with<SPACE>space''',
'''Run configurations are stored in the RIDE settings file.'''
])


class ConfigManagerDialog(Dialog):

    def __init__(self, configs, plugin):
        Dialog.__init__(self, title='Manage Run Configurations')
        self.plugin = plugin
        self._create_ui(configs)

    def _create_ui(self, configs):
        self.SetSizer(wx.BoxSizer(wx.VERTICAL))
        self._editor = self._create_editor(configs)
        self._create_help()
        self._create_line()
        self._create_buttons()
        self.SetSize((750, 400))

    def _create_editor(self, configs):
        editor = _ConfigListEditor(self, configs)
        self.Sizer.Add(editor, flag=wx.GROW, proportion=1)
        return editor

    def _create_help(self):
        help = HelpLabel(self, label=_CONFIG_HELP)
        help.Wrap(700)
        self.Sizer.Add(help, border=5, flag=wx.TOP)

    def _create_line(self):
        line = wx.StaticLine(self, size=(20, -1), style=wx.LI_HORIZONTAL)
        self.Sizer.Add(line, border=5,
                       flag=wx.GROW | wx.ALIGN_CENTER_VERTICAL | wx.RIGHT | wx.TOP)

    def _create_buttons(self):
        self.Sizer.Add(self.CreateStdDialogButtonSizer(wx.OK | wx.CANCEL),
                       flag=wx.ALIGN_CENTER | wx.ALL, border=5)

    def get_data(self):
        return self._editor.get_data()


class _ConfigListEditor(ListEditorBase):
    _buttons = ['New', 'Remove']
    _columns = ['Name', 'Command', 'Documentation']

    def __init__(self, parent, configs):
        self._editor_open = False
        ListEditorBase.__init__(self, parent, self._columns, configs)

    def _create_list(self, columns, data):
        return _TextEditListCtrl(self, columns, data)

    def get_column_values(self, config):
        return config.name, config.command, config.doc

    def get_data(self):
        return self._list.get_data()

    def OnEdit(self, event):
        self._list.open_editor(self._selection)

    def OnNew(self, event):
        self._list.new_item()

    def OnRemove(self, event):
        self.OnDelete(event)

    def new_config(self, data):
        self._controller.add(*data)

    def edit_config(self, index, data):
        self._controller.edit(index, *data)

    def OnDelete(self, event):
        if not self._editor_open:
            ListEditorBase.OnDelete(self, event)

    def editor_open(self):
        self._editor_open = True

    def editor_closed(self):
        self._editor_open = False


class _TextEditListCtrl(AutoWidthColumnList, TextEditMixin):
    last_index = property(lambda self: self.ItemCount - 1)

    def __init__(self, parent, columns, data):
        AutoWidthColumnList.__init__(self, parent, columns, data)
        TextEditMixin.__init__(self)
        self._set_command_column_width()
        self.col_locs = self._calculate_col_locs()
        self._new_item_creation = False

    def _set_command_column_width(self):
        self.SetColumnWidth(1, 250)

    def _calculate_col_locs(self):
        """Calculates and returns initial locations of colums.

        This is needed so that TextEditMixin can work from context menu,
        without selecting the row first.
        """
        locations = [0]
        loc = 0
        for n in range(self.GetColumnCount()):
            loc = loc + self.GetColumnWidth(n)
            locations.append(loc)
        return locations

    def open_editor(self, row):
        self.OpenEditor(0, row)

    def OpenEditor(self, col, row):
        self._parent.editor_open()
        TextEditMixin.OpenEditor(self, col, row)

    def new_item(self):
        self._new_item_creation = True
        self.InsertStringItem(self.ItemCount, '')
        self.Select(self.ItemCount-1, True)
        self.open_editor(self.last_index)

    def get_data(self):
        return [ self._get_row(row) for row in range(self.ItemCount) ]

    def _get_row(self, row):
        return [ self.GetItem(row, col).GetText() for col in range(3)]

    def CloseEditor(self, event=None):
        TextEditMixin.CloseEditor(self, event)
        # It seems that this is called twice per editing action and in the
        # first time the value may be empty.
        # End new item creation only when there really is a value
        lastrow = self._get_row(self.last_index)
        if self._new_item_creation:
            if any(lastrow):
                self._new_item_creation = False
                self.Parent.new_config(lastrow)
        else:
            self.Parent.edit_config(self.curRow, self._get_row(self.curRow))
            self.Select(self.curRow)
        self._parent.editor_closed()

########NEW FILE########
__FILENAME__ = process
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import time
import tempfile
import subprocess


class Process(object):

    def __init__(self, command):
        self._command = self._parse_command(command)
        self._process = None
        self._error = None

    def _parse_command(self, command):
        if isinstance(command, basestring):
            return [ val.replace('<SPACE>', ' ') for val in command.split() ]
        return command

    def start(self):
        self._out_fd, self._out_path = \
                        tempfile.mkstemp(prefix='rfproc_', suffix='.txt',
                                         text=True)
        self._out_file = open(self._out_path)
        if not self._command:
            self._error = 'The command is missing from this run configuration.'
            return
        try:
            self._process = subprocess.Popen(self._command, stdout=self._out_fd,
                                             stderr=subprocess.STDOUT)
        except OSError, err:
            self._error = str(err)

    def is_finished(self):
        return self._error is not None or self._process.poll() is not None

    def stop(self):
        try:
            self._process.kill()
        except AttributeError:
            raise AttributeError('Stopping process is possible only with '
                                 'Python 2.6 or newer')

    def wait(self):
        if self._process is not None:
            self._process.wait()

    def get_output(self, wait_until_finished=False):
        """Returns the output produced by the process.

        If ``wait_until_finished`` is True, blocks until the process is
        finished and returns all output. Otherwise the currently available
        output is returned immediately.

        Currently available output depends on buffering and might not include
        everything that has been written by the process.
        """
        if self._error:
            self._close_outputs()
            return self._error
        if wait_until_finished:
            self._process.wait()
        output = self._out_file.read()
        if self.is_finished():
            self._close_outputs()
        return output

    def _close_outputs(self):
        self._out_file.close()
        os.close(self._out_fd)
        self._remove_tempfile()

    def _remove_tempfile(self, attempts=10):
        try:
            os.remove(self._out_path)
        except OSError:
            if not attempts:
                raise
            time.sleep(1)
            self._remove_tempfile(attempts - 1)


########NEW FILE########
__FILENAME__ = runanything
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from robotide.controller.basecontroller import _BaseController

from robotide.pluginapi import Plugin, ActionInfo, SeparatorInfo
from robotide.run.configmanagerui import ConfigManagerDialog
from robotide.run.ui import Runner


class RunAnything(Plugin):
    """A plugin for executing commands on the system.

    This plugin enables creation of persistent run configurations and
    execution of those. Output of the executed command is displayed in a
    separate tab."""

    def __init__(self, app):
        Plugin.__init__(self, app, default_settings={'configs': []})
        self._configs = RunConfigs(self.configs)

    def enable(self):
        self._create_menu(self._configs)

    def OnManageConfigurations(self, event):
        dlg = ConfigManagerDialog(self._configs, self)
        if dlg.ShowModal() == wx.ID_OK:
            self._configs.update(dlg.get_data())
            self.save_setting('configs', self._configs.data_to_save())
            self._create_menu(self._configs)
        self._configs = RunConfigs(self.configs)
        dlg.Destroy()

    def _create_menu(self, configs):
        self.unregister_actions()
        self.register_action(ActionInfo('Macros', 'Manage Run Configurations',
                                        self.OnManageConfigurations))
        self.register_action(SeparatorInfo('Macros'))
        for index, cfg in enumerate(configs):
            self._add_config_to_menu(cfg, index+1)

    def _add_config_to_menu(self, config, index):
        def run(event):
            Runner(config, self.notebook).run()
        info = ActionInfo('Macros', name='%d: %s' % (index, config.name),
                          doc=config.help, action=run)
        self.register_action(info)


class RunConfigs(_BaseController):

    def __init__(self, saved_data):
        self._configs = []
        for item in saved_data:
            self.add(item[0], item[1], item[2])

    def __iter__(self):
        return iter(self._configs)

    def __len__(self):
        return len(self._configs)

    def __getitem__(self, index):
        return self._configs[index]

    def add(self, name, command, doc):
        config = RunConfig(name, command, doc)
        self._configs.append(config)
        return config

    def update(self, data):
        for index, datum in enumerate(data):
            self.edit(index, *datum)

    def move_up(self, index):
        self._swap(index-1, index)

    def move_down(self, index):
        self._swap(index, index+1)

    def _swap(self, index1, index2):
        self._configs[index1], self._configs[index2] = \
                self._configs[index2], self._configs[index1]

    def edit(self, index, name, command, doc):
        config = self._configs[index]
        config.name, config.command, config.doc = name, command, doc

    def delete(self, index):
        if index < len(self._configs):
            self._configs.pop(index)

    def data_to_save(self):
        return [ (c.name, c.command, c.doc) for c in self._configs ]


class RunConfig(object):
    help = property(lambda self: '%s (%s)' % (self.doc, self.command))

    def __init__(self, name, command, doc):
        self.name = name
        self.command = command
        self.doc = doc
        self._finished = False
        self._error = False


########NEW FILE########
__FILENAME__ = ui
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import sys

from robotide.run.process import Process
from robotide.widgets import Label, Font


class Runner(wx.EvtHandler):

    def __init__(self, config, notebook):
        wx.EvtHandler.__init__(self)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.name = config.name
        self._timer = wx.Timer(self)
        self._config = config
        self._window = self._get_output_window(notebook)

    def _get_output_window(self, notebook):
        return _OutputWindow(notebook, self)

    def run(self):
        self._process = Process(self._config.command)
        self._process.start()
        self._timer.Start(500)

    def OnTimer(self, event=None):
        finished = self._process.is_finished()
        self._window.update_output(self._process.get_output(), finished)
        if finished:
            self._timer.Stop()

    def stop(self):
        try:
            self._process.stop()
        except Exception, err:
            wx.MessageBox(str(err), style=wx.ICON_ERROR)


class _OutputWindow(wx.ScrolledWindow):

    def __init__(self, notebook, runner):
        wx.ScrolledWindow.__init__(self, notebook)
        self._create_ui()
        self._add_to_notebook(notebook, runner.name)
        self._runner = runner

    def _create_ui(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self._create_state_button())
        sizer.Add(self._create_output())
        self.SetSizer(sizer)
        self.SetScrollRate(20, 20)

    def _create_state_button(self):
        if sys.version_info[:2] >= (2,6):
            self._state_button = _StopAndRunAgainButton(self)
        else:
            self._state_button = _RunAgainButton(self)
        return self._state_button

    def _create_output(self):
        self._output = _OutputDisplay(self)
        return self._output

    def _add_to_notebook(self, notebook, name):
        notebook.add_tab(self, '%s (running)' % name, allow_closing=False)
        notebook.show_tab(self)

    def update_output(self, output, finished=False):
        if output:
            self._output.update(output)
            self.SetVirtualSize(self._output.Size)
        if finished:
            self._rename_tab('%s (finished)' % self._runner.name)
            self.Parent.allow_closing(self)
            self._state_button.enable_run_again()

    def OnStop(self):
        self._runner.stop()

    def OnRunAgain(self):
        self._output.clear()
        self._rename_tab('%s (running)' % self._runner.name)
        self.Parent.disallow_closing(self)
        self._state_button.reset()
        self._runner.run()

    def _rename_tab(self, name):
        self.Parent.rename_tab(self, name)


class _OutputDisplay(Label):

    def __init__(self, parent):
        Label.__init__(self, parent)
        self.SetFont(Font().fixed)

    def update(self, addition):
        self.SetLabel(self.LabelText + addition.decode('UTF-8', 'ignore'))

    def clear(self):
        self.SetLabel('')


class _StopAndRunAgainButton(wx.Button):

    def __init__(self, parent):
        wx.Button.__init__(self, parent, label='Stop')
        self.Bind(wx.EVT_BUTTON, self.OnClick, self)

    def OnClick(self, event):
        self.Enable(False)
        getattr(self.Parent, 'On' + self.LabelText.replace(' ', ''))()

    def enable_run_again(self):
        self.Enable()
        self.SetLabel('Run Again')

    def reset(self):
        self.Enable()
        self.SetLabel('Stop')


class _RunAgainButton(wx.Button):

    def __init__(self, parent):
        wx.Button.__init__(self, parent, label='Run Again')
        self.Bind(wx.EVT_BUTTON, self.OnClick, self)
        self.Enable(False)

    def OnClick(self, event):
        self.Parent.OnRunAgain()

    def enable_run_again(self):
        self.Enable()

    def reset(self):
        self.Enable(False)


########NEW FILE########
__FILENAME__ = dialogsearchtests
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.utils import overrides
from robotide.widgets import Dialog, VerticalSizer, VirtualList, Label, HelpLabel, ImageProvider, ButtonWithHandler
import wx
from robotide.widgets.list import ListModel

class TestsDialog(Dialog):

    def __init__(self, fuzzy_search_handler, tag_search_handler, add_to_selected_handler):
        self._fuzzy_search_handler = fuzzy_search_handler
        self._tag_search_handler = tag_search_handler
        self._add_to_selected_handler = add_to_selected_handler
        self._selection_listeners = []
        title = "Search Tests"
        Dialog.__init__(self, title=title, size=(750, 400))
        self.SetSizer(VerticalSizer())
        self.Sizer.Add(self._create_notebook(), 1, wx.ALL | wx.EXPAND | wx.ALIGN_LEFT, 3)

    def _create_notebook(self):
        self._notebook = wx.Notebook(self, wx.ID_ANY, style=wx.NB_TOP)
        self._notebook.AddPage(self._text_search_panel(), 'Search')
        self._notebook.AddPage(self._tag_pattern_search_panel(), 'Tag Search')
        return self._notebook

    def _select_page(self, page=0):
        self._notebook.ChangeSelection(page)

    def _text_search_panel(self):
        panel = wx.Panel(self._notebook)
        panel.SetSizer(VerticalSizer())
        self._add_search_control(panel)
        self.tests = _TestSearchListModel([])
        self.tests_list = VirtualList(panel, ['Test', 'Tags', 'Source'], self.tests)
        self.tests_list.add_selection_listener(self._select_text_search_result)
        panel.Sizer.add_expanding(self.tests_list)
        self._fuzzy_results_text = wx.StaticText(panel, -1, 'Results: ')
        panel.Sizer.Add(self._fuzzy_results_text, 0, wx.ALL, 3)
        return panel

    def _tag_pattern_search_panel(self):
        panel = wx.Panel(self._notebook)
        panel.SetSizer(VerticalSizer())
        tags_controls_sizer = VerticalSizer()
        tags_controls_sizer.Add(self._create_include_line(panel), 0, wx.ALL, 3)
        tags_controls_sizer.Add(self._create_exclude_line(panel), 0, wx.ALL, 3)
        controls_sizer = self._horizontal_sizer()
        controls_sizer.Add(tags_controls_sizer)
        controls_sizer.Add(self._create_switch_button(panel), 0, wx.CENTER, 3)
        controls_sizer.Add(self._create_tag_search_button(panel), 0, wx.ALL | wx.EXPAND, 3)
        controls_sizer.Add(self._create_add_to_selected_button(panel), 0, wx.ALL | wx.EXPAND, 3)
        panel.Sizer.Add(controls_sizer)
        panel.Sizer.Add(self._add_info_text(panel, "Find matches using tag patterns. See RF User Guide or 'pybot --help' for more information."), 0, wx.ALL, 3)
        self._tags_results = _TestSearchListModel([])
        self._tags_list = VirtualList(panel, ['Test', 'Tags', 'Source'], self._tags_results)
        self._tags_list.add_selection_listener(self._select_tag_search_result)
        panel.Sizer.add_expanding(self._tags_list)
        self._tags_results_text = wx.StaticText(panel, -1, 'Results: ')
        panel.Sizer.Add(self._tags_results_text, 0, wx.ALL, 3)
        return panel

    def _create_include_line(self, panel):
        include_line = self._horizontal_sizer()
        include_line.Add(Label(panel, label='Include', size=(80, -1)))
        self._tags_to_include_text = wx.TextCtrl(panel, value='', size=(400, -1), style=wx.TE_PROCESS_ENTER)
        self._tags_to_include_text.Bind(wx.EVT_TEXT_ENTER, self.OnSearchTags)
        include_line.Add(self._tags_to_include_text)
        return include_line

    def _create_switch_button(self, panel):
        sizer = self._vertical_sizer()
        img = ImageProvider().SWITCH_FIELDS_ICON
        button = wx.BitmapButton(panel, -1, img, pos=(10, 20))
        self.Bind(wx.EVT_BUTTON, self.OnSwitchFields, button)
        sizer.Add(button)
        return sizer

    def _create_exclude_line(self, panel):
        exclude_line = self._horizontal_sizer()
        exclude_line.Add(Label(panel, label='Exclude', size=(80, -1)))
        self._tags_to_exclude_text = wx.TextCtrl(panel, value='', size=(400, -1), style=wx.TE_PROCESS_ENTER)
        self._tags_to_exclude_text.Bind(wx.EVT_TEXT_ENTER, self.OnSearchTags)
        exclude_line.Add(self._tags_to_exclude_text)
        return exclude_line

    def _create_tag_search_button(self, panel):
        button = wx.Button(panel, label='Search')
        button.Bind(wx.EVT_BUTTON, self.OnSearchTags)
        return button

    def OnSearchTags(self, event):
        self._tag_search_handler(self._tags_to_include_text.GetValue(), self._tags_to_exclude_text.GetValue())

    def _create_add_to_selected_button(self, panel):
        button = wx.Button(panel, label='Add all to selected')
        button.Bind(wx.EVT_BUTTON, self.OnAddToSelected)
        return button

    def OnAddToSelected(self, event):
        self._add_to_selected_handler(self._get_current_tests())

    def OnSearchTests(self, event):
        self._fuzzy_search_handler(self._search_control.GetValue())

    def set_search_model(self, search_text, results):
        results = list(results)
        self._search_control.SetValue(search_text)
        self._fuzzy_results_text.SetLabel('Results: %d' % len(results))
        self.tests._tests = results
        self._refresh_list(self.tests_list)

    def set_tag_search_model(self, include_text, exclude_text, results):
        results = list(results)
        self._tags_to_include_text.SetValue(include_text)
        self._tags_to_exclude_text.SetValue(exclude_text)
        self._tags_results_text.SetLabel('Results: %d' % len(results))
        self._tags_results._tests = results
        self._refresh_list(self._tags_list)

    def _refresh_list(self, list):
        list.refresh()
        list.Refresh()
        if list.GetItemCount():
            list._inform_listeners(0)

    def _add_info_text(self, panel, text = ""):
        infopanel = self._horizontal_sizer()
        infopanel.Add(HelpLabel(panel, "Info. " + text))
        return infopanel

    def _add_search_control(self, panel):
        panel.SetSizer(VerticalSizer())
        line1 = self._horizontal_sizer()
        self._add_pattern_filter(line1, panel)
        fuzzy_search_button = wx.Button(panel, label='Search')
        fuzzy_search_button.Bind(wx.EVT_BUTTON, self.OnSearchTests)
        line1.Add(fuzzy_search_button)
        add_to_selection_button = wx.Button(panel, label='Add all to selected')
        add_to_selection_button.Bind(wx.EVT_BUTTON, self.OnAddToSelected)
        line1.Add(add_to_selection_button)
        panel.Sizer.Add(line1, 0, wx.ALL, 3)
        panel.Sizer.Add(self._add_info_text(panel, "Find matches by test name, documentation and/or tag."), 0, wx.ALL, 3)

    def _horizontal_sizer(self):
        return wx.BoxSizer(wx.HORIZONTAL)

    def _vertical_sizer(self):
        return wx.BoxSizer(wx.VERTICAL)

    def _add_pattern_filter(self, sizer, parent):
        self._search_control = wx.SearchCtrl(parent, value='', size=(200,-1), style=wx.TE_PROCESS_ENTER)
        self._search_control.SetDescriptiveText('Search term')
        wrapped = lambda event: self._fuzzy_search_handler(self._search_control.GetValue())
        self._search_control.Bind(wx.EVT_TEXT_ENTER, wrapped)
        sizer.Add(self._search_control, 0, wx.ALL, 3)

    def _select_text_search_result(self, idx):
        for listener in self._selection_listeners:
            listener(self.tests[idx])

    def _select_tag_search_result(self, idx):
        for listener in self._selection_listeners:
            listener(self._tags_results[idx])

    def add_selection_listener(self, listener):
        self._selection_listeners.append(listener)

    def _find_index_in_list(self, item, list):
        if item is None:
            return 0
        idx = 0
        for tc in list:
            if tc[0] == item:
                return idx
            idx += 1
        return 0

    def set_focus_to_default_location(self, selected=None):
        if self._notebook.GetSelection() == 0:
            self._set_focus_to_default_location_in_text_search(selected)
        else:
            self._set_focus_to_default_location_in_tag_search(selected)

    def _get_current_tests(self):
        if self._notebook.GetSelection() == 0:
            return [t for t, _ in self.tests._tests]
        else:
            return [test for test, _ in self._tags_results._tests]

    def _set_focus_to_default_location_in_text_search(self, selected):
        if self.tests.count:
            self.tests_list.Select(self._find_index_in_list(selected, self.tests))
            self.tests_list.SetFocus()
        else:
            self._search_control.SetFocus()

    def _set_focus_to_default_location_in_tag_search(self, selected):
        if self._tags_results.count:
            self._tags_list.Select(self._find_index_in_list(selected, self._tags_results))
            self._tags_list.SetFocus()
        else:
            self._tags_to_include_text.SetFocus()

    def OnSwitchFields(self, event):
        include_txt = self._tags_to_include_text.GetValue()
        exclude_txt = self._tags_to_exclude_text.GetValue()

        if len(include_txt.strip()) > 0 or len(exclude_txt.strip()) > 0:
            self._tags_to_include_text.SetValue(exclude_txt)
            self._tags_to_exclude_text.SetValue(include_txt)
            self.OnSearchTags(event)

class _TestSearchListModel(ListModel):

    def __init__(self, tests):
        self._tests = sorted(tests, cmp=lambda x, y: cmp(x[1], y[1]))

    @property
    @overrides(ListModel)
    def count(self):
        return len(self._tests)

    def __getitem__(self, item):
        return self._tests[item]

    def item_text(self, row, col):
        test, match = self._tests[row]
        if col == 0:
            return test.name
        if col == 1:
            return u', '.join(unicode(t) for t in test.tags)
        return test.datafile_controller.longname

########NEW FILE########
__FILENAME__ = searchtests
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import wx
from robot.model import TagPatterns
from robotide.action import ActionInfo
from robotide.pluginapi import Plugin
from robotide.publish import RideOpenTagSearch
from robotide.searchtests.dialogsearchtests import TestsDialog
from robotide.widgets import ImageProvider


class TestSearchPlugin(Plugin):
    """A plugin for searching tests based on name, tags and documentation"""
    HEADER = 'Search Tests'
    _selection = None

    def enable(self):
        self.register_action(ActionInfo('Tools', self.HEADER, self.show_empty_search, shortcut='F3', doc=self.__doc__,icon=ImageProvider().TEST_SEARCH_ICON,position=50))
        self.register_search_action(self.HEADER, self.show_search_for, ImageProvider().TEST_SEARCH_ICON, default=True)
        self.subscribe(self.show_tag_search, RideOpenTagSearch)
        self._dialog = None

    def show_search_for(self, text):
        if self._dialog is None:
            self._create_tests_dialog()
        self._dialog.set_search_model(text, self._search_results(TestSearchMatcher(text)))
        self._dialog.set_focus_to_default_location()

    def show_search_for_tag_patterns(self, includes, excludes):
        matcher =  TagSearchMatcher(includes, excludes)
        self._dialog.set_tag_search_model(includes, excludes, self._search_results(matcher))
        self._dialog.set_focus_to_default_location()

    def show_tag_search(self, data):
        if self._dialog is None:
            self._create_tests_dialog()
        self.show_search_for_tag_patterns(data.includes, data.excludes)
        self._dialog._select_page(1)

    def _create_tests_dialog(self):
        self._dialog = TestsDialog(fuzzy_search_handler=self.show_search_for, tag_search_handler=self.show_search_for_tag_patterns, add_to_selected_handler=self._add_to_selected)
        self._dialog.add_selection_listener(self._selected)
        self._dialog.Bind(wx.EVT_CLOSE, self._dialog_closed)
        self._selected_timer = wx.Timer(self._dialog)
        self._dialog.Bind(wx.EVT_TIMER, self._do_with_selection)
        self._dialog.Show()

    def _add_to_selected(self, tests):
        self.tree.SelectTests(tests)

    def _dialog_closed(self, event):
        self._dialog = None
        event.Skip()

    def show_empty_search(self, event):
        self.show_search_for('')

    def _do_with_selection(self, evt=None):
        test, match_location = self._selection
        self.tree.select_node_by_data(test)
        self._dialog.set_focus_to_default_location(test)

    def _selected(self, selection):
        self._selection = selection
        self._selected_timer.Start(400, True)

    def _search_results(self, matcher):
        current_suite = self.frame._controller.data
        if not current_suite:
            return []
        result = self._search(matcher, current_suite)
        return sorted(result, cmp=lambda x,y: cmp(x[1], y[1]))

    def _search(self, matcher, data):
        for test in data.tests:
            match = matcher.matches(test)
            if match:
                yield test, match
        for s in data.suites:
            for test, match in self._search(matcher, s):
                yield test, match

    def disable(self):
        self.unregister_actions()

class TagSearchMatcher(object):

    def __init__(self, includes, excludes):
        self._tag_pattern_includes = TagPatterns(includes.split()) if includes.split() else None
        self._tag_pattern_excludes = TagPatterns(excludes.split())

    def matches(self, test):
        tags = [unicode(tag) for tag in test.tags]
        if self._matches(tags):
            return test.longname
        return False

    def _matches(self, tags):
        return (self._tag_pattern_includes is None or self._tag_pattern_includes.match(tags)) and \
               not self._tag_pattern_excludes.match(tags)


class TestSearchMatcher(object):

    def __init__(self, text):
        self._texts = text.split()
        self._texts_lower = [t.lower() for t in self._texts]

    def matches(self, test):
        if self._matches(test):
            return SearchResult(self._texts, self._texts_lower, test)
        return False

    def _matches(self, test):
        name = test.name.lower()
        if self._match_in(name):
            return True
        if any(self._match_in(unicode(tag).lower()) for tag in test.tags):
            return True
        doc = test.documentation.value.lower()
        if self._match_in(doc):
            return True
        return False

    def _match_in(self, text):
        return any(word in text for word in self._texts_lower)


class SearchResult(object):

    def __init__(self, original_search_terms, search_terms_lower, test):
        self._original_search_terms = original_search_terms
        self._search_terms_lower = search_terms_lower
        self._test = test
        self.__total_matches = None
        self.__tags = None

    def __cmp__(self, other):
        totals, other_totals = self._total_matches(), other._total_matches()
        if totals != other_totals:
            return cmp(other_totals, totals)
        names = self._compare(self._is_name_match(), other._is_name_match(), self._test.name, other._test.name)
        if names:
            return names
        tags = self._compare(self._is_tag_match(), other._is_tag_match(), self._tags(), other._tags())
        if tags:
            return tags
        return cmp(self._test.name, other._test.name)

    def _compare(self, my_result, other_result, my_comparable, other_comparable):
        if my_result and not other_result:
            return -1
        if not my_result and other_result:
            return 1
        if my_result and other_result:
            return cmp(my_comparable, other_comparable)
        return 0

    def _total_matches(self):
        if not self.__total_matches:
            self.__total_matches = sum(1 for word in self._search_terms_lower
                                        if word in self._test.name.lower()
                                        or any(word in t for t in self._tags())
                                        or word in self._test.documentation.value.lower())
        return self.__total_matches

    def _match_in(self, text):
        return any(word in text for word in self._search_terms_lower)

    def _is_name_match(self):
        return self._match_in(self._test.name.lower())

    def _is_tag_match(self):
        return any(self._match_in(t) for t in self._tags())

    def _tags(self):
        if self.__tags is None:
            self.__tags = [unicode(tag).lower() for tag in self._test.tags]
        return self.__tags

    def __repr__(self):
        return self._test.name

########NEW FILE########
__FILENAME__ = iteminfo
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os

from robot.utils.normalizing import normalize
from robotide.utils import html_format, unescape


class ItemInfo(object):
    """Represents an object that can be displayed by content assistant."""

    def __init__(self, name, source, details):
        """Creates an item info.

        :Parameters:
          name
            Item name. Is shown in the first column of the content assist popup.
          source
            Item source. Is shown in the second column of the content assist popup.
          details
            Detailed information for item that is shown in the additional popup
            besides the list that contains content assist values. Will be
            displayed as HTML.
        """
        self.name = name
        self.source = source
        if details is not None:
            self.details = details
        self._priority = PRIORITIES.get(self.__class__, PRIORITIES[ItemInfo])

    @property
    def longname(self):
        return '%s.%s' % (self.source, self.name)

    def name_begins_with(self, prefix):
        return normalize(self.name).startswith(prefix)

    def longname_begins_with(self, prefix):
        return normalize(self.longname).startswith(prefix)

    def is_library_keyword(self):
        return False

    def is_user_keyword(self):
        return not self.is_library_keyword()

    def __cmp__(self, other):
        if self._priority == other._priority:
            name_cmp = cmp(self.name.upper(), other.name.upper())
            return name_cmp if name_cmp else cmp(self.source, other.source)
        return cmp(self._priority, other._priority)

    def __eq__(self, other):
        return not self.__cmp__(other) if isinstance(other, ItemInfo) else False

    def __hash__(self):
        return hash((self.name, self.source))


class VariableInfo(ItemInfo):

    def __init__(self, name, value, source):
        ItemInfo.__init__(self, name, self._source_name(source), None)
        self._original_source = source
        self._value = value

    def _source_name(self, source):
        return unicode(os.path.basename(source)) if source else ''

    @property
    def details(self):
        value = self._value
        if self.name.startswith('@'):
            if value is None:
                value = '[ ]'
        return ('<table>'
                '<tr><td><i>Name:</i></td><td>%s</td></tr>'
                '<tr><td><i>Source:</i></td><td>%s</td></tr>'
                '<tr><td valign=top><i>Value:</i></td><td>%s</td></tr>'
                '</table>') % (self.name, self._original_source, unicode(value))


class ArgumentInfo(VariableInfo):

    SOURCE = 'Argument'

    def __init__(self, name, value):
        VariableInfo.__init__(self, name, value, self.SOURCE)

class LocalVariableInfo(VariableInfo):

    SOURCE = 'Local variable'

    def __init__(self, name):
        VariableInfo.__init__(self, name, '', self.SOURCE)

class _KeywordInfo(ItemInfo):

    def __init__(self, item):
        self.doc = self._doc(item).strip()
        ItemInfo.__init__(self, self._name(item), self._source(item),
                          None)
        self.shortdoc = self.doc.splitlines()[0] if self.doc else ''
        self.item = item

    @property
    def arguments(self):
        return self._parse_args(self.item)

    @property
    def details(self):
        return ('<table>'
                '<tr><td><i>Name:</i></td><td>%s</td></tr>'
                '<tr><td><i>Source:</i></td><td>%s &lt;%s&gt;</td></tr>'
                '<tr><td><i>Arguments:</i></td><td>%s</td></tr>'
                '</table>'
                '<table>'
                '<tr><td>%s</td></tr>'
                '</table>') % \
                (self._name(self.item), self._source(self.item), self._type,
                 self._format_args(self.arguments),
                 html_format(self.doc))

    def _format_args(self, args):
        return '[ %s ]' % ' | '.join(args)

    def __str__(self):
        return 'KeywordInfo[name: %s, source: %s, doc: %s]' %(self.name,
                                                              self.source,
                                                              self.doc)
    def _name(self, item):
        return item.name


class _XMLKeywordContent(_KeywordInfo):

    def __init__(self, item, source, source_type):
        self._type = source_type
        self._source = lambda x: source
        _KeywordInfo.__init__(self, item)
        self.args = self._format_args(self._parse_args(item))

    def with_alias(self, alias):
        if alias:
            self.source = alias
        return self

    def _name(self, node):
        return node.get('name')

    def _doc(self, node):
        return node.find('doc').text or ''

    def _parse_args(self, node):
        args_node = node.find('arguments')
        return [arg_node.text for arg_node in args_node.findall('arg')]

    def is_library_keyword(self):
        return True


class LibraryKeywordInfo(_KeywordInfo):
    _type = 'test library'
    _library_alias = None
    item = None

    def __init__(self, name, doc, library_name, args):
        self._item_name = name
        self.doc = doc.strip()
        self._item_library_name = library_name
        self._args = args
        ItemInfo.__init__(self, self._item_name, library_name, None)
        self.shortdoc = self.doc.splitlines()[0] if self.doc else ''

    def with_alias(self, alias):
        self._library_alias = alias
        self.source = self._source(self.item)
        return self

    def _source(self, item):
        if self._library_alias:
            return self._library_alias
        return self._item_library_name

    @property
    def arguments(self):
        return self._args

    def is_library_keyword(self):
        return True

    def _name(self, item):
        return self._item_name


class _UserKeywordInfo(_KeywordInfo):

    def _source(self, item):
        return unicode(os.path.basename(item.source)) if item.source else ''

    def _doc(self, item):
        return unescape(item.doc.value)

    def _parse_args(self, uk):
        parsed = []
        for arg in uk.args.value:
            if self._is_scalar(arg):
                parsed.append(self._parse_name_and_default(arg))
            elif self._is_list(arg):
                parsed.append(self._parse_vararg(arg))
        return parsed

    def _is_scalar(self, arg):
        return arg.startswith('$')

    def _parse_name_and_default(self, arg):
        parts = arg.split('=', 1)
        name = self._strip_var_syntax_chars(parts[0])
        if len(parts) == 1:
            return name
        return name + '=' + parts[1]

    def _strip_var_syntax_chars(self, string):
        return string[2:-1]

    def _is_list(self, arg):
        return arg.startswith('@')

    def _parse_vararg(self, arg):
        return '*' + self._strip_var_syntax_chars(arg)


class TestCaseUserKeywordInfo(_UserKeywordInfo):
    _type = 'test case file'

    @property
    def longname(self):
        return self.name


class ResourceUserKeywordInfo(_UserKeywordInfo):
    _type = 'resource file'

    @property
    def longname(self):
        return self.item.parent.parent.name + '.' + self.name


PRIORITIES = {ItemInfo: 50,
              LibraryKeywordInfo: 40,
              ResourceUserKeywordInfo: 30,
              TestCaseUserKeywordInfo: 20,
              VariableInfo: 10,
              ArgumentInfo: 5,
              LocalVariableInfo: 5}

########NEW FILE########
__FILENAME__ = librarydatabase
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os
import sqlite3
import time
from robotide.preferences.settings import SETTINGS_DIRECTORY
from robotide.spec.iteminfo import LibraryKeywordInfo
from robot.utils import decode_from_system

CREATION_SCRIPT = """\
CREATE TABLE libraries (id INTEGER PRIMARY KEY,
                        name TEXT,
                        arguments TEXT,
                        last_updated REAL);
CREATE TABLE keywords (name TEXT,
                       doc TEXT,
                       arguments TEXT,
                       library_name TEXT,
                       library INTEGER,
                       FOREIGN KEY(library) REFERENCES libraries(id));
"""

DATABASE_FILE = os.path.join(decode_from_system(SETTINGS_DIRECTORY), 'librarykeywords.db')

def _create_database():
    print 'Creating librarykeywords database to "%s"' % DATABASE_FILE

    connection = sqlite3.connect(DATABASE_FILE)
    connection.executescript(CREATION_SCRIPT)
    connection.commit()
    connection.close()

def _validate_database():
    connection = sqlite3.connect(DATABASE_FILE)
    connection.execute('select id, name, arguments, last_updated from libraries')
    connection.execute('select name, doc, arguments, library_name, library from keywords')
    connection.close()

def initialize_database():
    if not os.path.exists(SETTINGS_DIRECTORY):
        os.makedirs(SETTINGS_DIRECTORY)
    if not os.path.exists(DATABASE_FILE):
        _create_database()
    else:
        try:
            _validate_database()
        except sqlite3.DatabaseError, err:
            print 'error during database validation "%s"' % err
            print 'removing database "%s"' % DATABASE_FILE
            os.remove(DATABASE_FILE)
            _create_database()

class LibraryDatabase(object):

    def __init__(self, database):
        self._connection = sqlite3.connect(database, timeout=30.0)

    def create_database(self):
        self._cursor().executescript(CREATION_SCRIPT)
        self._connection.commit()

    def _cursor(self):
        return self._connection.cursor()

    def close(self):
        self._connection.close()

    def insert_library_keywords(self, library_name, library_arguments, keywords):
        cur = self._cursor()
        old_versions = cur.execute('select id from libraries where name = ? and arguments = ?', (library_name, unicode(library_arguments))).fetchall()
        cur.executemany('delete from keywords where library = ?', old_versions)
        cur.executemany('delete from libraries where id = ?', old_versions)
        lib = self._insert_library(library_name, library_arguments, cur)
        keyword_values = [[kw.name, kw.doc, u' | '.join(kw.arguments), kw.source, lib[0]] for kw in keywords if kw is not None]
        self._insert_library_keywords(keyword_values, cur)
        self._connection.commit()

    def update_library_timestamp(self, name, arguments, milliseconds=None):
        self._cursor().execute('update libraries set last_updated = ? where name = ? and arguments = ?', (milliseconds or time.time(), name, unicode(arguments)))
        self._connection.commit()

    def fetch_library_keywords(self, library_name, library_arguments):
        lib = self._fetch_lib(library_name, library_arguments, self._cursor())
        if lib is None:
            return []
        return [LibraryKeywordInfo(name, doc, library_name, arguments.split(u' | ') if arguments else [])
                for name, doc, arguments, library_name in
                self._connection.execute('select name, doc, arguments, library_name from keywords where library = ?', [lib[0]])]

    def library_exists(self, library_name, library_arguments):
        return self._fetch_lib(library_name, library_arguments, self._cursor()) is not None

    def get_library_last_updated(self, library_name, library_arguments):
        lib = self._fetch_lib(library_name, library_arguments, self._cursor())
        if not lib:
            return 0.0
        return lib[3]

    def _insert_library(self, name, arguments, cursor):
        cursor.execute('insert into libraries values (null, ?, ?, ?)', (name, unicode(arguments), time.time()))
        return self._fetch_lib(name, arguments, cursor)

    def _fetch_lib(self, name, arguments, cursor):
        t = cursor.execute('select max(last_updated) from libraries where name = ? and arguments = ?', (name, unicode(arguments))).fetchone()[0]
        return cursor.execute('select * from libraries where name = ? and arguments = ? and last_updated = ?', (name, unicode(arguments), t)).fetchone()

    def _insert_library_keywords(self, data, cursor):
        cursor.executemany('insert into keywords values (?, ?, ?, ?, ?)', data)

########NEW FILE########
__FILENAME__ = libraryfetcher
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robot.running import TestLibrary
from robotide.spec.iteminfo import LibraryKeywordInfo


def get_import_result(path, args):
    try:
        lib = TestLibrary(path, args)
        return [
            LibraryKeywordInfo(
                kw.name,
                kw.doc,
                kw.library.name,
                _parse_args(kw.arguments)
            ) for kw in lib.handlers.values()]
    except SystemExit:
        raise ImportError('Library "%s" import failed' % path)

def _parse_args(handler_args):
    args = []
    if handler_args.names:
        args.extend(list(handler_args.names))
    if handler_args.defaults:
        for i, value in enumerate(handler_args.defaults):
            index = len(handler_args.names) - len(handler_args.defaults) + i
            args[index] = args[index] + '=' + unicode(value)
    if handler_args.varargs:
        args.append('*%s' % handler_args.varargs)
    return args

########NEW FILE########
__FILENAME__ = librarymanager
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from Queue import Queue
from _sqlite3 import OperationalError
import os
from threading import Thread
from robotide.publish import RideLogException
from robotide.spec.librarydatabase import LibraryDatabase
from robotide.spec.libraryfetcher import get_import_result
from robotide.spec.xmlreaders import get_path, SpecInitializer


class LibraryManager(Thread):

    def __init__(self, database_name, spec_initializer=None):
        self._database_name = database_name
        self._messages = Queue()
        self._spec_initializer = spec_initializer or SpecInitializer()
        Thread.__init__(self)
        self.setDaemon(True)

    def run(self):
        self._initiate_database_connection()
        while True:
            try:
                if not self._handle_message():
                    break
            except Exception, err:
                msg = 'Library import handling threw an unexpected exception'
                RideLogException(message=msg, exception=err, level='WARN').publish()
        self._database.close()

    def _initiate_database_connection(self):
        self._database = LibraryDatabase(self._database_name)

    def get_new_connection_to_library_database(self):
        library_database = LibraryDatabase(self._database_name)
        if self._database_name == ':memory:':
            # In memory database does not point to the right place..
            # this is here for unit tests..
            library_database.create_database()
        return library_database

    def _handle_message(self):
        message = self._messages.get()
        if not message:
            return False
        type = message[0]
        if type == 'fetch':
            self._handle_fetch_keywords_message(message)
        elif type == 'insert':
            self._handle_insert_keywords_message(message)
        elif type == 'create':
            self._database.create_database()
        return True

    def _handle_fetch_keywords_message(self, message):
        _, library_name, library_args, callback = message
        keywords = self._fetch_keywords(library_name, library_args)
        self._update_database_and_call_callback_if_needed((library_name, library_args), keywords, callback)

    def _fetch_keywords(self, library_name, library_args):
        try:
            path = get_path(library_name.replace('/', os.sep), os.path.abspath('.'))
            return get_import_result(path, library_args)
        except Exception, err:
            kws = self._spec_initializer.init_from_spec(library_name)
            if not kws:
                msg = 'Importing test library "%s" failed' % library_name
                RideLogException(message=msg, exception=err, level='WARN').publish()
            return kws

    def _handle_insert_keywords_message(self, message):
        _, library_name, library_args, result_queue = message
        keywords = self._fetch_keywords(library_name, library_args)
        self._insert(library_name, library_args, keywords, lambda result: result_queue.put(result))

    def _insert(self, library_name, library_args, keywords, callback):
        self._database.insert_library_keywords(library_name, library_args, keywords or [])
        self._call(callback, keywords)

    def _update_database_and_call_callback_if_needed(self, library_key, keywords, callback):
        db_keywords = self._database.fetch_library_keywords(*library_key)
        try:
            if not db_keywords or self._keywords_differ(keywords, db_keywords):
                self._insert(library_key[0], library_key[1], keywords, callback)
            else:
                self._database.update_library_timestamp(*library_key)
        except OperationalError:
            pass

    def _call(self, callback, *args):
        try:
            callback(*args)
        except Exception, err:
            msg = 'Library import callback threw an unexpected exception'
            RideLogException(message=msg, exception=err, level='WARN').publish()

    def fetch_keywords(self, library_name, library_args, callback):
        self._messages.put(('fetch', library_name, library_args, callback))

    def get_and_insert_keywords(self, library_name, library_args):
        result_queue = Queue(maxsize=1)
        self._messages.put(('insert', library_name, library_args, result_queue))
        return result_queue.get()

    def create_database(self):
        self._messages.put(('create',))

    def stop(self):
        self._messages.put(False)

    def _keywords_differ(self, keywords1, keywords2):
        if keywords1 != keywords2 and None in (keywords1, keywords2):
            return True
        if len(keywords1) != len(keywords2):
            return True
        for k1, k2 in zip(keywords1, keywords2):
            if k1.name != k2.name:
                return True
            if k1.doc != k2.doc:
                return True
            if k1.arguments != k2.arguments:
                return True
            if k1.source != k2.source:
                return True
        return False

########NEW FILE########
__FILENAME__ = specimporter
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os
import shutil
import wx
from robotide.action import ActionInfo
from robotide.pluginapi import Plugin
from robotide.publish import RideExecuteSpecXmlImport
from robotide.spec.xmlreaders import LIBRARY_XML_DIRECTORY, get_name_from_xml
from robotide.publish import PUBLISHER

class SpecImporterPlugin(Plugin):

    HEADER = 'Import Library Spec XML'

    def enable(self):
        self.register_action(ActionInfo('Tools', self.HEADER, self.execute_spec_import, position=83))
        PUBLISHER.subscribe(self.execute_spec_import, RideExecuteSpecXmlImport)

    def execute_spec_import(self, event=None):
        path = self._get_path_to_library_spec()
        if self._is_valid_path(path):
            self._store_spec(path)
            self._execute_namespace_update()

    def _is_valid_path(self, path):
        return path and os.path.isfile(path)

    def _execute_namespace_update(self):
        self.model.update_namespace()

    def _get_path_to_library_spec(self):
        wildcard = ('Library Spec XML | *.xml')
        dlg = wx.FileDialog(self.frame,
                            message='Import Library Spec XML',
                            wildcard=wildcard,
                            defaultDir=self.model.default_dir,
                            style=wx.OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
        else:
            path = None
        dlg.Destroy()
        return path

    def _store_spec(self, path):
        name = get_name_from_xml(path)
        if name:
            shutil.copy(path, os.path.join(LIBRARY_XML_DIRECTORY, name+'.xml'))
            wx.MessageBox('Library "%s" imported\nfrom "%s"\nThis may require RIDE restart.' % (name, path), 'Info', wx.OK | wx.ICON_INFORMATION)
        else:
            wx.MessageBox('Could not import library from file "%s"' % path, 'Import failed', wx.OK | wx.ICON_ERROR)


########NEW FILE########
__FILENAME__ = xmlreaders
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import sys
from robot.errors import DataError
from robotide import utils
from robotide.utils.versioncomparator import cmp_versions
from iteminfo import _XMLKeywordContent
from robotide.preferences.settings import SETTINGS_DIRECTORY

LIBRARY_XML_DIRECTORY = os.path.join(SETTINGS_DIRECTORY, 'library_xmls')
if not os.path.isdir(LIBRARY_XML_DIRECTORY):
    os.makedirs(LIBRARY_XML_DIRECTORY)

class SpecInitializer(object):

    def __init__(self, directories=None):
        self._directories = directories or []
        self._directories.append(LIBRARY_XML_DIRECTORY)

    def init_from_spec(self, name):
        specfile = self._find_from_pythonpath(name) or self._find_from_library_xml_directories(name)
        return self._init_from_specfile(specfile, name)

    def _find_from_library_xml_directories(self, name):
        for directory in self._directories:
            path = self._find_from_library_xml_directory(directory, name)
            if path:
                return path
        return None

    def _find_from_library_xml_directory(self, directory, name):
        current_xml_file = None
        for xml_file in self._list_xml_files_in(directory):
            name_from_xml = get_name_from_xml(xml_file)
            if name_from_xml == name:
                current_xml_file = self._get_newest_xml_file(xml_file, current_xml_file)
        return current_xml_file

    def _get_newest_xml_file(self, xml_file, current_xml_file):
        version1 = self._get_version(xml_file)
        version2 = self._get_version(current_xml_file)
        if cmp_versions(version1, version2) == 1:
            return xml_file
        return current_xml_file

    def _get_version(self, xml_file):
        try:
            return utils.ET.parse(xml_file).getroot().find('version').text
        except:
            return None

    def _list_xml_files_in(self, directory):
        for filename in os.listdir(directory):
            path = os.path.join(directory, filename)
            if path.endswith('.xml') and os.path.isfile(path):
                yield path

    def _find_from_pythonpath(self, name):
        return utils.find_from_pythonpath(name+'.xml')

    def _init_from_specfile(self, specfile, name):
        if not specfile:
            return []
        try:
            return _parse_xml(specfile, name)
        except Exception:
            # TODO: which exception to catch?
            return []


def _parse_xml(file, name):
    root = utils.ET.parse(file).getroot()
    if root.tag != 'keywordspec':
        # TODO: XML validation errors should be logged
        return [], ''
    kw_nodes = root.findall('keywords/kw') + root.findall('kw')
    source_type = root.get('type')
    if source_type == 'resource':
        source_type += ' file'
    return [_XMLKeywordContent(node, name, source_type) for node in kw_nodes]

def get_path(name, basedir):
    if not _is_library_by_path(name):
        return name.replace(' ', '')
    return _resolve_path(name.replace('/', os.sep), basedir)

def _is_library_by_path(path):
    return path.lower().endswith(('.py', '.java', '.class', '/', os.sep))

def _resolve_path(path, basedir):
    for base in [basedir] + sys.path:
        if not (base and os.path.isdir(base)):
            continue
        ret = os.path.join(base, path)
        if os.path.isfile(ret):
            return ret
        if os.path.isdir(ret) and os.path.isfile(os.path.join(ret, '__init__.py')):
            return ret
    raise DataError

def _get_library_name(name):
    if os.path.exists(name):
        return name
    return name.replace(' ', '')

def get_name_from_xml(path):
    try:
        root = utils.ET.parse(path).getroot()
        name = root.get('name')
        return name
    except:
        return None
########NEW FILE########
__FILENAME__ = actiontriggers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from robotide.action import ActionInfo

from robotide.context import IS_WINDOWS
from robotide.context.platform import IS_MAC


class MenuBar(object):

    def __init__(self, frame):
        self._mb = wx.MenuBar()
        self._name_builder = _NameBuilder()
        self._frame = frame
        self._accelerators = []
        self._menus = []
        self._create_default_menus()

    def take_menu_bar_into_use(self):
        """This should be called after fully populating menus.
        Otherwise help menu will not be functional in osx."""
        self._frame.SetMenuBar(self._mb)

    def _create_default_menus(self):
        for name in ['File', 'Edit', 'Tools', 'Help']:
            self._create_menu(name, before_help=False)

    def _create_menu(self, name, before_help=True):
        menu = _Menu(self._name_builder.get_name(name), self._frame)
        self._insert_menu(menu, before_help)
        return menu

    def _insert_menu(self, menu, before_help):
        if before_help:
            index = [m.name for m in self._menus].index('&Help')
        else:
            index = len(self._menus)
        self._menus.insert(index, menu)
        self._mb.Insert(index, menu.wx_menu, menu.name)

    def register(self, action):
        menu = self._find_menu(action.menu_name)
        if not menu:
            menu = self._create_menu(action.menu_name)
        menu.add_menu_item(action)

    def _find_menu(self, name):
        registered = self._name_builder.get_registered_name(name)
        if not registered:
            return None
        for menu in self._menus:
            if menu.name == registered:
                return menu


class _Menu(object):

    def __init__(self, name, frame):
        self.name = name
        self._frame = frame
        self.wx_menu = wx.Menu()
        self._menu_items = {}
        self._name_builder = _NameBuilder()
        self._open = False
        self._frame.Bind(wx.EVT_MENU_OPEN, self.OnMenuOpen)
        self._frame.Bind(wx.EVT_MENU_CLOSE, self.OnMenuClose)

    def OnMenuOpen(self, event):
        if self.wx_menu == event.GetMenu() and not self._open:
            self._open = True
            for menu_item in self._menu_items.values():
                menu_item.refresh_availability()
        event.Skip()

    def OnMenuClose(self, event):
        if self._open:
            self._open = False
            for menu_item in self._menu_items.values():
                menu_item.set_enabled()
        event.Skip()

    def add_menu_item(self, action):
        menu_item = self._construct_menu_item(action)
        self._menu_items[menu_item.id] = menu_item
        menu_item.register(action)

    def _construct_menu_item(self, action):
        if action.is_separator():
            return self._create_separator(action)
        menu_item = self._get_menu_item(action)
        if not menu_item:
            menu_item = self._create_menu_item(action)
        return menu_item

    def _create_separator(self, action):
        menu_item = SeparatorMenuItem(self._frame, self, action)
        pos = action.get_insertion_index(self.wx_menu)
        menu_item.set_wx_menu_item(self.wx_menu.InsertSeparator(pos))
        return menu_item

    def _get_menu_item(self, action):
        for menu_item in self._menu_items.values():
            if self._names_equal(menu_item, action):
                return menu_item
        return None

    def _names_equal(self, menu_item, action):
        return menu_item.name == self._get_name(action, build_new=False)

    def _get_name(self, action, build_new):
        get_name = build_new and self._name_builder.get_name or \
                                 self._name_builder.get_registered_name
        if not action.shortcut:
            return get_name(action.name)
        return '%s    (%s)' % (get_name(action.name), action.get_shortcut())

    def _create_menu_item(self, action):
        name_with_accerelator = self._get_name(action, build_new=True)
        menu_item = MenuItem(self._frame, self, name_with_accerelator)
        pos = action.get_insertion_index(self.wx_menu)
        wx_menu_item = self.wx_menu.Insert(pos, menu_item.id,
                                           menu_item.name, action.doc)
        menu_item.set_wx_menu_item(wx_menu_item)
        return menu_item

    def remove_menu_item(self, id):
        self.wx_menu.Delete(id)
        del(self._menu_items[id])


class _NameBuilder(object):

    def __init__(self):
        self._names = {}
        self._accelerators = []

    def get_name(self, name):
        registered = self.get_registered_name(name)
        if registered:
            return registered
        try:
            name = self._use_given_accelerator(name)
        except ValueError:
            name = self._generate_accelerator(name)
        self._register(name)
        return name

    def get_registered_name(self, name):
        try:
            return self._names[name.replace('&', '').upper()]
        except KeyError:
            return None

    def _register(self, name):
        self._names[name.replace('&', '').upper()] = name

    def _use_given_accelerator(self, name):
        index = name.find('&') + 1
        if 0 < index < len(name) and self._accelerator_is_free(name[index]):
            return name
        raise ValueError

    def _generate_accelerator(self, name):
        name = name.replace('&', '')
        for pos, char in enumerate(name):
            if self._accelerator_is_free(char):
                return '%s&%s' % (name[:pos], name[pos:])
        return name

    def _accelerator_is_free(self, char):
        char = char.upper()
        if char not in self._accelerators and char != ' ':
            self._accelerators.append(char)
            return True
        return False


class _MenuItem(object):

    def __init__(self, frame, menu, name):
        self._frame = frame
        self._menu = menu
        self.name = name
        self._action_delegator = ActionDelegator(self._frame)
        self.id = self._action_delegator.id

    def set_wx_menu_item(self, wx_menu_item):
        self._wx_menu_item = wx_menu_item

    def register(self, action):
        self._action_delegator.add(action)
        action.register(self)

    def unregister(self, action):
        if self._action_delegator.remove(action):
            self._menu.remove_menu_item(self.id)

    def refresh_availability(self):
        self._wx_menu_item.Enable(self._is_enabled())

    def set_enabled(self):
        self._wx_menu_item.Enable(True)


class MenuItem(_MenuItem):

    def _is_enabled(self):
        return self._action_delegator.is_active()


class SeparatorMenuItem(_MenuItem):

    def set_wx_menu_item(self, wx_menu_item):
        _MenuItem.set_wx_menu_item(self, wx_menu_item)
        self._wx_menu_item.SetId(self.id)

    def _is_enabled(self):
        return False

    def set_enabled(self):
        pass


class ToolBar(object):

    def __init__(self, frame):
        self._frame = frame
        self._wx_toolbar = wx.ToolBar(frame)
        self._wx_toolbar.SetToolBitmapSize((16, 16))
        self._frame.SetToolBar(self._wx_toolbar)
        self._buttons = []
        self._search_handlers = {}
        self._current_description = None

    def register(self, action):
        if action.has_icon():
            button = self._get_existing_button(action)
            if not button:
                button = self._create_button(action)
            button.register(action)


    def _get_existing_button(self, action):
        for button in self._buttons:
            if button.icon == action.icon:
                return button
        return None

    def enabled_status_changed(self, id, action):
        self._wx_toolbar.EnableTool(id, action.is_active())

    def _create_button(self, action):
        button = ToolBarButton(self._frame, self, action)
        name = self._format_button_tooltip(action)
        self._wx_toolbar.AddLabelTool(button.id, label=name, bitmap=action.icon,
                                      shortHelp=name, longHelp=action.doc)
        self._wx_toolbar.Realize()
        self._buttons.append(button)
        return button

    def _format_button_tooltip(self, action):
        tooltip = action.name.replace('&', '')
        if action.shortcut and action.shortcut.value:
            tooltip = '%s    (%s)' % (tooltip, action.shortcut.value)
        return tooltip

    def remove_toolbar_button(self, button):
        self._buttons.remove(button)
        self._wx_toolbar.RemoveTool(button.id)
        self._wx_toolbar.Realize()

    def register_search_handler(self, description, handler, icon, default=False):
        if default:
            self._current_description = description
        self._search_handlers[description] = _RideSearchMenuItem(handler, icon)


class _RideSearchMenuItem(object):

    def __init__(self, handler, icon):
        self._handler = handler
        self.icon = icon

    def __call__(self, *args, **kwargs):
        self._handler(*args, **kwargs)


class ToolBarButton(object):

    def __init__(self, frame, toolbar, action):
        self._toolbar = toolbar
        self.icon = action.icon
        self._action_delegator = ActionDelegator(frame)
        self.id = self._action_delegator.id

    def register(self, action):
        self._action_delegator.add(action)
        action.register(self)
        action.inform_changes_in_enabled_status(self)

    def unregister(self, action):
        if self._action_delegator.remove(action):
            self._toolbar.remove_toolbar_button(self)

    def enabled_status_changed(self, action):
        self._toolbar.enabled_status_changed(self.id, action)


class ShortcutRegistry(object):

    def __init__(self, frame):
        self._frame = frame
        self._actions = {}

    def register(self, action):
        if action.has_shortcut() and action.has_action():
            delegator = self._actions.setdefault(action.get_shortcut(),
                                                 ActionDelegator(self._frame, action.shortcut))
            delegator.add(action)
            action.register(self)
            self._update_accerelator_table()

    def unregister(self, action):
        key = action.get_shortcut()
        if self._actions[key].remove(action):
            del(self._actions[key])
        self._update_accerelator_table()

    def _update_accerelator_table(self):
        accerelators = []
        for delegator in self._actions.values():
            flags, key_code = delegator.shortcut.parse()
            accerelators.append(wx.AcceleratorEntry(flags, key_code, delegator.id))
        self._frame.SetAcceleratorTable(wx.AcceleratorTable(accerelators))


class ActionDelegator(object):

    def __init__(self, frame, shortcut=None):
        self._frame = frame
        self.shortcut = shortcut
        self.id = wx.NewId()
        self._actions = []

    def add(self, action):
        self._actions.append(action)
        if len(self._actions) == 1:
            self._frame.Bind(wx.EVT_MENU, self, id=self.id)

    def remove(self, action):
        """Removes action and returns True if delegator is empty."""
        self._actions.remove(action)
        if len(self._actions) == 0:
            self._frame.Unbind(wx.EVT_MENU, id=self.id)
            return True
        return False

    def is_active(self):
        for action in self._actions:
            if action.is_active():
                return True
        return False

    def __call__(self, event):
        for action in self._actions:
            action.act(event)
        if not (IS_WINDOWS or IS_MAC):
            event.Skip()

########NEW FILE########
__FILENAME__ = filedialogs
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import wx
from wx.lib.filebrowsebutton import DirBrowseButton

from robotide.controller.commands import (CreateNewResource,
    AddTestDataDirectory, AddTestCaseFile, CreateNewDirectoryProject,
    CreateNewFileProject, SetFileFormat, SetFileFormatRecuresively)
from robotide.utils import overrides
from robotide.widgets import Label
# This hack needed to set same label width as with other labels
DirBrowseButton.createLabel = lambda self: Label(self, size=(110, -1),
                                                      label=self.labelText)

from robotide.widgets import Dialog
from robotide.validators import NonEmptyValidator, NewSuitePathValidator, SuiteFileNameValidator


class _CreationDialog(Dialog):

    def __init__(self, default_dir, title):
        sizer = self._init_dialog(title)
        label_sizer = wx.BoxSizer(wx.VERTICAL)
        self._name_editor = self._create_name_editor(label_sizer)
        self._parent_chooser = self._create_parent_chooser(label_sizer, default_dir)
        self._path_display = self._create_path_display(label_sizer, default_dir)
        radio_group_sizer = wx.BoxSizer(wx.VERTICAL)
        self._type_chooser = self._create_type_chooser(radio_group_sizer)
        self._format_chooser = self._create_format_chooser(radio_group_sizer)
        edit_sizer = wx.BoxSizer(wx.HORIZONTAL)
        edit_sizer.Add(label_sizer, 1, wx.EXPAND)
        edit_sizer.Add(radio_group_sizer)
        sizer.Add(edit_sizer, 1, wx.EXPAND)
        self._finalize_dialog(sizer)
        self._name_editor.SetFocus()

    def _init_dialog(self, title):
        Dialog.__init__(self, title)
        return wx.BoxSizer(wx.VERTICAL)

    def _finalize_dialog(self, sizer):
        self._create_horizontal_line(sizer)
        self._create_buttons(sizer)
        sizer.Fit(self)
        self.SetSizer(sizer)

    def _create_name_editor(self, sizer):
        disp_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._add_label(disp_sizer, 'Name')
        name_editor = wx.TextCtrl(self)
        name_editor.SetValidator(NonEmptyValidator('Name'))
        self.Bind(wx.EVT_TEXT, self.OnPathChanged, name_editor)
        disp_sizer.Add(name_editor, 1, wx.ALIGN_CENTRE|wx.ALL|wx.EXPAND, 3)
        sizer.Add(disp_sizer, 1, wx.EXPAND)
        return name_editor

    def _add_label(self, sizer, text):
        label = Label(self, label=text, size=(110, -1))
        sizer.Add(label, flag=wx.CENTER|wx.ALL, border=3)

    def _create_type_chooser(self, sizer):
        return self._create_radiobuttons(sizer, 'Type', ['File', 'Directory'])

    def _create_format_chooser(self, sizer, callback=True):
        return self._create_radiobuttons(sizer, 'Format', ['ROBOT', 'TXT', 'TSV', 'HTML'],
                                         callback)

    def _create_radiobuttons(self, sizer, label, choices, callback=True):
        radios = wx.RadioBox(self, label=label, choices=choices)
        if callback:
            self.Bind(wx.EVT_RADIOBOX, self.OnPathChanged, radios)
        sizer.Add(radios, flag=wx.ALIGN_LEFT|wx.ALL, border=5)
        return radios

    def _create_parent_chooser(self, sizer, default_dir):
        browser = DirBrowseButton(self, labelText='Parent Directory',
                                  dialogTitle='Choose Parent Directory',
                                  startDirectory=default_dir,
                                  size=(600, -1), newDirectory=True,
                                  changeCallback=self.OnPathChanged)
        browser.SetValue(default_dir)
        sizer.Add(browser, 1, wx.EXPAND)
        return browser

    def _create_parent_display(self, sizer, path):
        return self._create_display(sizer, 'Parent Directory', path)

    def _create_path_display(self, sizer, path):
        return self._create_display(sizer, 'Created Path', path,
                                    NewSuitePathValidator())

    def _create_display(self, sizer, title, value, validator=None):
        disp_sizer = wx.BoxSizer(wx.HORIZONTAL)
        self._add_label(disp_sizer, title)
        disp = wx.TextCtrl(self, value=value)
        disp.SetSizeHints(self.GetTextExtent(value)[0]+100, -1)
        disp.SetEditable(False)
        disp.SetBackgroundColour('grey')
        if validator:
            disp.SetValidator(validator)
        disp_sizer.Add(disp, 1, wx.ALL|wx.EXPAND, 3)
        sizer.Add(disp_sizer, 1, wx.EXPAND)
        return disp

    def _get_path(self):
        name = self._name_editor.GetValue()
        path = os.path.join(self._parent_chooser.GetValue(), name.replace(' ', '_'))
        if self._is_dir_type():
            path = os.path.join(path, '__init__')
        return path + '.' + self._get_extension()

    def _is_dir_type(self):
        if not self._type_chooser:
            return False
        return self._type_chooser.GetStringSelection() == 'Directory'

    def _get_extension(self):
        if not self._format_chooser:
            return 'html'
        return self._format_chooser.GetStringSelection().lower()

    def OnPathChanged(self, event):
        if not hasattr(self, '_path_display'):
            return
        self._path_display.SetValue(self._get_path())
        event.Skip()


class _WithImmutableParent(object):

    def _create_parent_chooser(self, sizer, default_dir):
        return self._create_parent_display(sizer, self._path)


class NewProjectDialog(_CreationDialog):

    def __init__(self, chief_controller):
        self._controller = chief_controller
        _CreationDialog.__init__(self, chief_controller.default_dir, 'New Project')

    def _execute(self):
        cmd = CreateNewDirectoryProject if self._is_dir_type() else CreateNewFileProject
        cmd(self._get_path()).execute(self._controller )


class NewResourceDialog(_WithImmutableParent, _CreationDialog):

    def __init__(self, controller, settings):
        self._path = controller.directory
        _CreationDialog.__init__(self, controller.default_dir, 'New Resource File')
        self._format_chooser.SetStringSelection(settings['default file format'])
        self._controller = controller

    def _execute(self):
        self._controller.execute(CreateNewResource(self._get_path()))

    def _create_type_chooser(self, sizer):
        return None


class AddSuiteDialog(_WithImmutableParent, _CreationDialog):

    NAME = 'Add Suite'

    def __init__(self, controller, settings):
        self._controller = controller
        self._path = controller.directory
        _CreationDialog.__init__(self, self._path, self.NAME)
        self._format_chooser.SetStringSelection(settings['default file format'])

    @overrides(_CreationDialog)
    def _create_name_editor(self, sizer):
        name_editor = _CreationDialog._create_name_editor(self, sizer)
        name_editor.SetValidator(SuiteFileNameValidator('Name', self._is_dir_type))
        return name_editor

    def _execute(self):
        cmd = AddTestDataDirectory if self._is_dir_type() else AddTestCaseFile
        self._controller.execute(cmd(self._get_path()))


class AddDirectoryDialog(AddSuiteDialog):

    NAME = 'Add Directory'

    def _create_type_chooser(self, sizer):
        return None

    def _is_dir_type(self):
        return True


class _FileFormatDialog(_CreationDialog):

    def __init__(self, controller):
        sizer = self._init_dialog('Set Data Format')
        self._controller = controller
        self._create_help(sizer)
        self._chooser = self._create_format_chooser(sizer, callback=False)
        self._chooser.SetStringSelection(controller.get_format() or 'TXT')
        self._recursive = self._create_recursion_selector(sizer)
        self._finalize_dialog(sizer)

    def _create_help(self, sizer):
        pass

    def _create_recursion_selector(self, sizer):
        return None

    def _get_format(self):
        return self._chooser.GetStringSelection()


class ChangeFormatDialog(_FileFormatDialog):

    def _create_recursion_selector(self, sizer):
        if not self._controller.is_directory_suite():
            return None
        selector = wx.CheckBox(self, label='Change recursively')
        selector.SetValue(True)
        sizer.Add(selector, flag=wx.ALL, border=5)
        return selector

    def _execute(self):
        cmd = SetFileFormat if not self._get_recursive() \
                else SetFileFormatRecuresively
        self._controller.execute(cmd(self._get_format()))

    def _get_recursive(self):
        return self._recursive and self._recursive.IsChecked()


class InitFileFormatDialog(_FileFormatDialog):

    def _create_help(self, sizer):
        help = 'Provide format for initialization file in directory\n"%s".' % \
                    self._controller.directory
        sizer.Add(Label(self, label=help), flag=wx.ALL, border=5)

    def _execute(self):
        self._controller.execute(SetFileFormat(self._get_format()))


class AddResourceDialog(wx.FileDialog):

    def __init__(self, window, controller):
        wildcard = ('All files|*.*|Robot data (*.html)|*.*htm*|'
                'Robot data (*.tsv)|*.tsv|Robot data (*txt)|*.txt')
        self._controller = controller
        wx.FileDialog.__init__(self, window, message='Open', wildcard=wildcard,
            defaultDir=self._controller.default_dir, style=wx.OPEN)

    def execute(self):
        if self.ShowModal() == wx.ID_OK:
            path = self.GetPath()
            self._controller.update_default_dir(path)
        else:
            path = None
        self.Destroy()
        return path

########NEW FILE########
__FILENAME__ = images
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import wx
from robotide.controller.settingcontrollers import VariableController
from robotide.controller.macrocontrollers import TestCaseController, UserKeywordController
from robotide.controller.filecontrollers import TestDataDirectoryController, TestCaseFileController, ResourceFileController, ExcludedDirectoryController


_SIZE = (16, 16)
_BASE = os.path.join(os.path.dirname(__file__), '..', 'widgets')

ROBOT_IMAGE_INDEX = 3
RUNNING_IMAGE_INDEX = 7
PASSED_IMAGE_INDEX = 8
FAILED_IMAGE_INDEX = 9

class TreeImageList(wx.ImageList):

    def __init__(self):
        wx.ImageList.__init__(self, *_SIZE)
        self._execution_results = None
        self._images = {
            TestDataDirectoryController: _TreeImage(self, 'folder.png'),
            'resource directory': _TreeImage(self, 'folder_wrench.png'),
            TestCaseFileController: _TreeImage(self, 'page_white.png'),
            TestCaseController: _TreeImage(self, 'robot.png'),
            UserKeywordController: _TreeImage(self, 'cog.png'),
            ResourceFileController: _TreeImage(self, 'page_white_gear.png'),
            VariableController: _TreeImage(self, 'dollar.png'),
            'running': _TreeImage(self, 'robot_running.png'),
            'passed': _TreeImage(self, 'robot_passed.png'),
            'failed': _TreeImage(self, 'robot_failed.png'),
            ExcludedDirectoryController: _TreeImage(self, 'folder_excluded.png')
        }

    @property
    def directory(self):
        return self._images['resource directory']

    def set_execution_results(self, results):
        self._execution_results = results

    def __getitem__(self, controller):
        if controller.__class__ == TestCaseController:
            if self._execution_results:
                if self._execution_results.is_running(controller):
                    return self._images['running']
                if self._execution_results.has_passed(controller):
                    return self._images['passed']
                if self._execution_results.has_failed(controller):
                    return self._images['failed']
        elif controller.__class__ == TestDataDirectoryController:
            if not controller.contains_tests():
                return self._images['resource directory']
        return self._images[controller.__class__]


class _TreeImage(object):

    def __init__(self, image_list, normal, expanded=None):
        self.normal = self._get_image(image_list, normal)
        self.expanded = self._get_image(image_list, expanded) if expanded else self.normal

    def _get_image(self, image_list, source):
        if source.startswith('wx'):
            img = wx.ArtProvider_GetBitmap(source, wx.ART_OTHER, _SIZE)
        else:
            path = os.path.join(_BASE, source)
            img = wx.Image(path, wx.BITMAP_TYPE_PNG).ConvertToBitmap()
        return image_list.Add(img)

########NEW FILE########
__FILENAME__ = keywordsearch
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx.lib.mixins.listctrl import ListCtrlAutoWidthMixin
import os.path

from robotide.controller.filecontrollers import (ResourceFileController,
                                                 TestCaseFileController)
from robotide.pluginapi import (Plugin, ActionInfo, RideOpenSuite,
        RideOpenResource, RideImportSetting, RideUserKeyword, RideNewProject)
from robotide.usages.UsageRunner import Usages
from robotide import utils
from robotide.widgets import (PopupMenuItem, ButtonWithHandler, Label, Font,
        HtmlWindow, ImageProvider)

ALL_KEYWORDS = '<all keywords>'
ALL_USER_KEYWORDS = '<all user keywords>'
ALL_LIBRARY_KEYWORDS = '<all library keywords>'


class KeywordSearch(Plugin):
    """A plugin for searching keywords based on name or documentation."""

    def __init__(self, app):
        Plugin.__init__(self, app)
        self.all_keywords = []
        self._criteria = _SearchCriteria()
        self.dirty = False

    def enable(self):
        action = ActionInfo('Tools', 'Search Keywords', self.OnSearch,
                            shortcut='F5',
                            doc='Search keywords from libraries and resources',
                            icon=ImageProvider().KW_SEARCH_ICON,
                            position=51)
        self.register_action(action)
        self.register_search_action('Search Keywords', self.show_search_for, ImageProvider().KW_SEARCH_ICON)
        self.subscribe(self.mark_dirty, RideOpenSuite, RideOpenResource,
                       RideImportSetting, RideUserKeyword, RideNewProject)
        self._dialog = KeywordSearchDialog(self.frame, self)
        self.tree.register_context_menu_hook(self._search_resource)

    def OnSearch(self, event):
        self._dialog.show_search_with_criteria()

    def mark_dirty(self, message):
        self.dirty = True

    def have_keywords_changed(self):
        if not self.dirty:
            return False
        self._update()
        return True

    def _update(self):
        self.dirty = False
        self.all_keywords = self.model.get_all_keywords()

    def search(self, pattern, search_docs, source_filter):
        self._criteria = _SearchCriteria(pattern, search_docs, source_filter)
        return self._search()

    def _search(self):
        return [ kw for kw in self.all_keywords if self._criteria.matches(kw) ]

    def _search_resource(self, item):
        if isinstance(item, (TestCaseFileController, ResourceFileController)):
            callable = lambda x: self._show_resource(os.path.basename(item.source))
            return [PopupMenuItem('Search Keywords', callable=callable)]
        return []

    def _show_resource(self, resource):
        self._dialog.show_search_with_criteria(source=resource)

    def show_search_for(self, pattern):
        self._dialog.show_search_with_criteria(pattern=pattern)

    def disable(self):
        self.unregister_actions()

class _SearchCriteria(object):

    def __init__(self, pattern='', search_docs=True, source_filter=ALL_KEYWORDS):
        self._pattern = pattern
        self._search_docs = search_docs
        self._source_filter = source_filter

    def matches(self, kw):
        if not self._matches_source_filter(kw):
            return False
        if self._contains(kw.name, self._pattern):
            return True
        return self._search_docs and self._contains(kw.doc, self._pattern)

    def _matches_source_filter(self, kw):
        if self._source_filter == ALL_KEYWORDS:
            return True
        if self._source_filter == ALL_USER_KEYWORDS and kw.is_user_keyword():
            return True
        if self._source_filter == ALL_LIBRARY_KEYWORDS and kw.is_library_keyword():
            return True
        return self._source_filter == kw.source

    def _contains(self, string, pattern):
        return utils.normalize(pattern) in utils.normalize(string)


class KeywordSearchDialog(wx.Frame):

    def __init__(self, parent, searcher):
        wx.Frame.__init__(self, parent, title="Search Keywords", style=wx.DEFAULT_FRAME_STYLE|wx.FRAME_FLOAT_ON_PARENT)
        self._plugin = searcher
        self._create_components()
        self._make_bindings()
        self._sort_order = _SortOrder()
        self._last_selected_kw = None
        self.SetBackgroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE))
        self.CenterOnParent()

    def _create_components(self):
        self.SetSizer(wx.BoxSizer(wx.VERTICAL))
        self._add_search_control()
        self._add_keyword_list()
        self._add_keyword_details()
        self.SetSize((700,500))

    def _add_search_control(self):
        line1 = self._horizontal_sizer()
        self._add_pattern_filter(line1)
        self._add_doc_filter(line1)
        self.Sizer.Add(line1, 0, wx.ALL, 3)
        line2 = self._horizontal_sizer()
        self._add_source_filter(line2)
        self.Sizer.Add(line2, 0, wx.ALL, 3)

    def _horizontal_sizer(self):
        return wx.BoxSizer(wx.HORIZONTAL)

    def _add_pattern_filter(self, sizer):
        sizer.Add(Label(self, label='Search term: '))
        self._search_control = wx.SearchCtrl(self, size=(200,-1),
                                             style=wx.TE_PROCESS_ENTER)
        sizer.Add(self._search_control)

    def _add_doc_filter(self, sizer):
        self._use_doc = wx.CheckBox(self, label='Search documentation')
        self._use_doc.SetValue(True)
        sizer.Add(self._use_doc)

    def _add_source_filter(self, sizer):
        sizer.Add(Label(self, label='Source: '))
        self._source_filter = wx.ComboBox(self, value=ALL_KEYWORDS, size=(300, -1),
                                          choices=self._get_sources(), style=wx.CB_READONLY)
        sizer.Add(self._source_filter)

    def _get_sources(self):
        sources = []
        for kw in self._plugin.all_keywords:
            if kw.source not in sources:
                sources.append(kw.source)
        return [ALL_KEYWORDS, ALL_USER_KEYWORDS, ALL_LIBRARY_KEYWORDS] + sorted(sources)

    def _add_keyword_list(self):
        self._list = _KeywordList(self, self._plugin)
        self._list.SetSize(self.Size)
        self._add_to_sizer(self._list)

    def _add_keyword_details(self):
        self._details = HtmlWindow(self)
        self._add_to_sizer(self._details)
        self._find_usages_button = ButtonWithHandler(self, 'Find Usages')
        self.Sizer.Add(self._find_usages_button, 0, wx.ALL, 3)

    def _add_to_sizer(self, component):
        self.Sizer.Add(component, 1, wx.EXPAND | wx.ALL, 3)

    def OnFindUsages(self, event):
        Usages(self._plugin.model, self._plugin.tree.highlight, self._last_selected_kw.name,  self._last_selected_kw).show()

    def _make_bindings(self):
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnItemSelected, self._list)
        self.Bind(wx.EVT_SEARCHCTRL_SEARCH_BTN, self.OnSearch,
                  self._search_control)
        self.Bind(wx.EVT_TEXT_ENTER, self.OnSearch, self._search_control)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_CHECKBOX, self.OnUseDocChange, self._use_doc)
        self.Bind(wx.EVT_COMBOBOX, self.OnSourceFilterChange, self._source_filter)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.OnColClick)

    def OnColClick(self,event):
        col = event.GetColumn()
        if self._sort_order.is_sortable_column(col):
            self._sort_order.sort(col)
            self._populate_search()
        event.Skip()

    def OnActivate(self, event):
        if self._plugin.have_keywords_changed():
            self._update_sources()
            self._populate_search()

    def OnUseDocChange(self, event):
        self._populate_search()

    def OnSearch(self, event):
        self._sort_order.searched(self._get_search_text())
        self._populate_search()

    def OnSourceFilterChange(self, event):
        self._populate_search()

    def OnKey(self, event):
        # Needed for HtmlWindow callback
        pass

    def OnItemSelected(self, event):
        self._last_selected_kw = self._keywords[event.Index]
        self._update_details()

    def _update_sources(self):
        selection = self._source_filter.GetValue()
        self._source_filter.Clear()
        for source in self._get_sources():
            self._source_filter.Append(source)
        self._source_filter.SetValue(selection)
        if self._source_filter.GetValue() != selection:
            self._source_filter.SetValue(ALL_KEYWORDS)

    def OnClose(self, event):
        self.Hide()

    def _populate_search(self):
        self._keywords = _KeywordData(self._plugin.search(*self._get_search_criteria()),
                                      self._sort_order, self._get_search_text())
        self._update_keyword_selection()
        self._list.show_keywords(self._keywords, self._last_selected_kw)
        self.Refresh()

    def _get_search_criteria(self):
        return self._get_search_text(), self._use_doc.GetValue(), self._source_filter.GetValue()

    def _get_search_text(self):
        return self._search_control.GetValue().lower()

    def _update_keyword_selection(self):
        if not self._last_selected_kw in self._keywords and self._keywords:
            self._last_selected_kw = self._keywords[0]
        self._update_details()

    def _update_details(self):
        if self._last_selected_kw in self._keywords:
            self._details.SetPage(self._last_selected_kw.details)
            self._find_usages_button.Enable()
        else:
            self._details.clear()
            self._find_usages_button.Disable()

    def show_search_with_criteria(self, pattern='', search_docs=True, source=ALL_KEYWORDS):
        self._update_widgets(pattern, search_docs, source)
        self._populate_search()
        self._show()
        self._search_control.SetFocus()

    def _update_widgets(self, pattern, search_docs, source):
        self._search_control.SetValue(pattern)
        self._use_doc.SetValue(search_docs)
        self._source_filter.SetValue(source)

    def _show(self):
        if not self.IsShown():
            self.Show()
        self.Raise()


class _SortOrder(object):

    def __init__(self):
        self.sort_up = True
        self.column = 0
        self.default_order = False

    def searched(self, term):
        self.__init__()
        if term:
            self.default_order = True

    def swap_direction(self):
        self.sort_up = not self.sort_up

    def is_sortable_column(self, col):
        return col < 2

    def sort(self, col):
        if self._has_been_sorted_by(col):
            self.swap_direction()
        else:
            self.sort_up = True
            self.column = col
        self.default_order = False

    def _has_been_sorted_by(self, col):
        return self.column == col and not self.default_order


class _KeywordData(list):
    headers = ['Name', 'Source', 'Description']

    def __init__(self, keywords, sort_order, search_criteria=None):
        self.extend(self._sort(keywords, sort_order, search_criteria))

    def _sort(self, keywords, sort_order, search_criteria=None):
        if sort_order.default_order:
            return self._sort_by_search(keywords, sort_order, search_criteria)
        return self._sort_by_attr(keywords, sort_order)

    def _sort_by_search(self, keywords, sort_order, search_criteria):
        search_criteria = search_criteria.lower()
        starts_with = [kw for kw in keywords if kw.name.lower().startswith(search_criteria)]
        name_contains = [kw for kw in keywords if (search_criteria in kw.name.lower()
                                                   and kw not in starts_with)]
        doc_contains = [kw for kw in keywords if (search_criteria in kw.details.lower()
                                                  and kw not in starts_with
                                                  and kw not in name_contains)]
        result = []
        for to_sort in (starts_with, name_contains, doc_contains):
            result.extend(self._sort_by_attr(to_sort, sort_order))
        return result

    def _sort_by_attr(self, keywords, sort_order):
        return sorted(keywords, cmp=self._get_comparator_for(self.headers[sort_order.column].lower()),
                      reverse=not sort_order.sort_up)

    def _get_comparator_for(self, atrr_name):
        return lambda kw, kw2: cmp(self._value_lowerer(kw, atrr_name),
                                   self._value_lowerer(kw2, atrr_name))

    def _value_lowerer(self, kw, attr_name):
        return getattr(kw, attr_name).lower()


class _KeywordList(wx.ListCtrl, ListCtrlAutoWidthMixin):

    def __init__(self, parent, plugin):
        style = wx.LC_REPORT|wx.NO_BORDER|wx.LC_SINGLE_SEL|wx.LC_HRULES|wx.LC_VIRTUAL
        wx.ListCtrl.__init__(self, parent, style=style)
        ListCtrlAutoWidthMixin.__init__(self)
        self._plugin = plugin
        self._create_headers()
        self._link_attribute = self._create_link_attribute()
        self._image_list = self._create_image_list()
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)

    def _create_headers(self):
        for col, title in enumerate(_KeywordData.headers):
            self.InsertColumn(col, title)
        self.SetColumnWidth(0, 250)

    def _create_link_attribute(self):
        attr = wx.ListItemAttr()
        attr.SetTextColour(wx.BLUE)
        attr.SetFont(Font().underlined)
        return attr

    def _create_image_list(self):
        imglist = wx.ImageList(16, 16)
        imglist.Add(wx.ArtProvider_GetBitmap(wx.ART_GO_UP, wx.ART_OTHER, (16, 16)))
        self.SetImageList(imglist, wx.IMAGE_LIST_SMALL)
        return imglist

    def show_keywords(self, keywords, kw_selection):
        self._keywords = keywords
        self.SetItemCount(len(self._keywords))
        if keywords:
            index = self._keywords.index(kw_selection)
            self.Select(index)
            self.Focus(index)

    def OnLeftUp(self, event):
        item, flags = self.HitTest(event.Position)
        if item == wx.NOT_FOUND:
            return
        kw = self._keywords[item]
        if kw.is_user_keyword() and (flags & wx.LIST_HITTEST_ONITEMICON):
            self._plugin.select_user_keyword_node(kw.item)

    def OnGetItemText(self, row, col):
        kw = self._keywords[row]
        return [kw.name, kw.source, kw.shortdoc][col]

    def OnGetItemImage(self, item):
        if self._keywords[item].is_user_keyword():
            return 0 # index in self._image_list
        return -1 # No image

########NEW FILE########
__FILENAME__ = mainframe
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.context.platform import IS_MAC

import wx

from robotide.action import ActionInfoCollection, ActionFactory, SeparatorInfo
from robotide.context import ABOUT_RIDE, SHORTCUT_KEYS
from robotide.controller.commands import SaveFile, SaveAll
from robotide.publish import (RideSaveAll, RideClosing, RideSaved, PUBLISHER,
        RideInputValidationError, RideTreeSelection, RideModificationPrevented)
from robotide.ui.tagdialogs import ViewAllTagsDialog
from robotide.utils import RideEventHandler
from robotide.widgets import Dialog, ImageProvider, HtmlWindow
from robotide.preferences import PreferenceEditor

from .actiontriggers import MenuBar, ToolBar, ShortcutRegistry
from .filedialogs import (NewProjectDialog, InitFileFormatDialog)
from .review import ReviewDialog
from .pluginmanager import PluginManager
from robotide.action.shortcut import localize_shortcuts
from .tree import Tree
from .notebook import NoteBook
from .progress import LoadProgressObserver


_menudata = """
[File]
!&New Project | Create a new top level suite | Ctrlcmd-N
---
!&Open Test Suite | Open file containing tests | Ctrlcmd-O | ART_FILE_OPEN
!Open &Directory | Open directory containing datafiles | Shift-Ctrlcmd-O | ART_FOLDER_OPEN
---
&Save | Save selected datafile | Ctrlcmd-S | ART_FILE_SAVE
!Save &All | Save all changes | Ctrlcmd-Shift-S | ART_FILE_SAVE_AS
---
!E&xit | Exit RIDE | Ctrlcmd-Q

[Tools]
!Search Unused Keywords | | | | POSITION-54
!Manage Plugins | | | | POSITION-81
!View All Tags | | F7 | | POSITION-82
!Preferences | | | | POSITION-99

[Help]
!Shortcut keys | RIDE shortcut keys
!User Guide | RIDE User Guide
!Report a Problem | Open browser to the RIDE issue tracker
!Release notes | Shows release notes
!About | Information about RIDE
"""


class RideFrame(wx.Frame, RideEventHandler):

    def __init__(self, application, controller):
        wx.Frame.__init__(self, parent=None, title='RIDE',
                          pos=application.settings['mainframe position'],
                          size=application.settings['mainframe size'])
        self._application = application
        self._controller = controller
        self._init_ui()
        self._plugin_manager = PluginManager(self.notebook)
        self._review_dialog = None
        self._view_all_tags_dialog = None
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self._subscribe_messages()
        self.ensure_on_screen()
        self.Show()
        wx.CallLater(100, self.actions.register_tools)

    def _subscribe_messages(self):
        for listener, topic in [(lambda msg: self.SetStatusText('Saved %s' % msg.path), RideSaved),
                                (lambda msg: self.SetStatusText('Saved all files'), RideSaveAll),
                                (self._set_label, RideTreeSelection),
                                (self._show_validation_error, RideInputValidationError),
                                (self._show_modification_prevented_error, RideModificationPrevented)]:
            PUBLISHER.subscribe(listener, topic)

    def _set_label(self, message):
        self.SetTitle(self._create_title(message))

    def _create_title(self, message):
        title = 'RIDE'
        if message:
            item = message.item
            title += ' - ' + item.datafile.name
            if not item.is_modifiable():
                title += ' (READ ONLY)'
        return title

    def _show_validation_error(self, message):
        wx.MessageBox(message.message, 'Validation Error', style=wx.ICON_ERROR)

    def _show_modification_prevented_error(self, message):
        wx.MessageBox('"%s" is read only' % message.controller.datafile_controller.filename,
                      'Modification prevented',
                      style=wx.ICON_ERROR)

    def _init_ui(self):
        splitter = wx.SplitterWindow(self, style=wx.SP_LIVE_UPDATE)
        self.notebook = NoteBook(splitter, self._application)
        mb = MenuBar(self)
        self.toolbar = ToolBar(self)
        self.actions = ActionRegisterer(mb, self.toolbar,
                                        ShortcutRegistry(self))
        self.tree = Tree(splitter, self.actions, self._application.settings)
        self.actions.register_actions(ActionInfoCollection(_menudata, self, self.tree))
        mb.take_menu_bar_into_use()
        splitter.SetMinimumPaneSize(100)
        splitter.SplitVertically(self.tree, self.notebook, 300)
        self.CreateStatusBar()
        self.SetIcons(ImageProvider().PROGICONS)

    def get_selected_datafile(self):
        return self.tree.get_selected_datafile()

    def get_selected_datafile_controller(self):
        return self.tree.get_selected_datafile_controller()

    def OnClose(self, event):
        self._application.settings['mainframe size'] = self.GetSizeTuple()
        self._application.settings['mainframe position'] = self.GetPositionTuple()
        if self._allowed_to_exit():
            PUBLISHER.unsubscribe(self._set_label, RideTreeSelection)
            RideClosing().publish()
            self.Destroy()
        else:
            wx.CloseEvent.Veto(event)

    def OnReleasenotes(self, event):
        pass

    def _allowed_to_exit(self):
        if self.has_unsaved_changes():
            ret = wx.MessageBox('There are unsaved modifications.\n'
                                'Do you want to save your changes before exiting?',
                                'Warning', wx.ICON_WARNING|wx.CANCEL|wx.YES_NO)
            if ret == wx.CANCEL:
                return False
            if ret == wx.YES:
                self.save()
        return True

    def has_unsaved_changes(self):
        return self._controller.is_dirty()

    def OnNewProject(self, event):
        if not self.check_unsaved_modifications():
            return
        NewProjectDialog(self._controller).execute()
        self._populate_tree()

    def _populate_tree(self):
        self.tree.populate(self._controller)

    def OnOpenTestSuite(self, event):
        if not self.check_unsaved_modifications():
            return
        path = self._get_path()
        if path:
            self.open_suite(path)

    def check_unsaved_modifications(self):
        if self.has_unsaved_changes():
            ret = wx.MessageBox('There are unsaved modifications.\n'
                                'Do you want to proceed without saving?',
                                'Warning', wx.ICON_WARNING|wx.YES_NO)
            return ret == wx.YES
        return True


    def _get_path(self):
        wildcard = ('All files|*.*|Robot data (*.html)|*.*htm*|'
                    'Robot data (*.tsv)|*.tsv|Robot data (*txt)|*.txt')
        dlg = wx.FileDialog(self, message='Open', wildcard=wildcard,
                            defaultDir=self._controller.default_dir, style=wx.OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self._controller.update_default_dir(path)
        else:
            path = None
        dlg.Destroy()
        return path

    def open_suite(self, path):
        self._controller.update_default_dir(path)
        self._controller.load_datafile(path, LoadProgressObserver(self))
        self._populate_tree()

    def refresh_datafile(self, item, event):
        self.tree.refresh_datafile(item, event)

    def OnOpenDirectory(self, event):
        if self.check_unsaved_modifications():
            path = wx.DirSelector(message='Choose a directory containing Robot files',
                                  defaultPath=self._controller.default_dir)
            if path:
                self.open_suite(path)

    def OnSave(self, event):
        self.save()

    def OnSaveAll(self, event):
        self.save_all()

    def save_all(self):
        self._show_dialog_for_files_without_format()
        self._controller.execute(SaveAll())

    def save(self, controller=None):
        if controller is None :
            controller = self.get_selected_datafile_controller()
        if controller is not None:
            if not controller.has_format():
                self._show_dialog_for_files_without_format(controller)
            else:
                controller.execute(SaveFile())

    def _show_dialog_for_files_without_format(self, controller=None):
        files_without_format = self._controller.get_files_without_format(controller)
        for f in files_without_format:
            self._show_format_dialog_for(f)

    def _show_format_dialog_for(self, file_controller_without_format):
        InitFileFormatDialog(file_controller_without_format).execute()

    def OnExit(self, event):
        self.Close()

    def OnManagePlugins(self, event):
        self._plugin_manager.show(self._application.get_plugins())

    def OnViewAllTags(self, event):
        if self._view_all_tags_dialog is None:
            self._view_all_tags_dialog = ViewAllTagsDialog(self._controller, self)
        self._view_all_tags_dialog.show_dialog()

    def OnSearchUnusedKeywords(self, event):
        if self._review_dialog is None:
            self._review_dialog = ReviewDialog(self._controller, self)
        self._review_dialog.show_dialog()

    def OnPreferences(self, event):
        dlg = PreferenceEditor(self, "RIDE - Preferences",
                                self._application.preferences, style='tree')
        # I would prefer that this not be modal, but making it non-
        # modal opens up a can of worms. We don't want to have to deal
        # with settings getting changed out from under us while the
        # dialog is open.
        dlg.ShowModal()
        dlg.Destroy()

    def OnAbout(self, event):
        dlg = AboutDialog()
        dlg.ShowModal()
        dlg.Destroy()

    def OnShortcutkeys(self, event):
        dialog = ShortcutKeysDialog()
        dialog.Show()

    def OnReportaProblem(self, event):
        wx.LaunchDefaultBrowser('http://code.google.com/p/robotframework-ride/issues/list')

    def OnUserGuide(self, event):
        wx.LaunchDefaultBrowser('http://code.google.com/p/robotframework/wiki/UserGuide')

    def _has_data(self):
        return self._controller.data is not None

    def _refresh(self):
        self._controller.update_namespace()

# This code is copied from http://wiki.wxpython.org/EnsureFrameIsOnScreen,
# and adapted to fit our code style.
    def ensure_on_screen(self):
        try:
            display_id = wx.Display.GetFromWindow(self)
        except NotImplementedError:
            display_id = 0
        if display_id == -1:
            display_id = 0
        geometry = wx.Display(display_id).GetGeometry()
        position = self.GetPosition()
        if position.x < geometry.x:
            position.x = geometry.x
        if position.y < geometry.y:
            position.y = geometry.y
        size = self.GetSize()
        if size.width > geometry.width:
            size.width = geometry.width
            position.x = geometry.x
        elif position.x + size.width > geometry.x + geometry.width:
            position.x = geometry.x + geometry.width - size.width
        if size.height > geometry.height:
            size.height = geometry.height
            position.y = geometry.y
        elif position.y + size.height > geometry.y + geometry.height:
            position.y = geometry.y + geometry.height - size.height
        self.SetPosition(position)
        self.SetSize(size)


class ActionRegisterer(object):

    def __init__(self, menubar, toolbar, shortcut_registry):
        self._menubar = menubar
        self._toolbar = toolbar
        self._shortcut_registry = shortcut_registry
        self._tools_items = {}

    def register_action(self, action_info):
        menubar_can_be_registered = True
        action = ActionFactory(action_info)
        self._shortcut_registry.register(action)
        if hasattr(action_info,"menu_name"):
            if action_info.menu_name == "Tools":
                self._tools_items[action_info.position] = action
                menubar_can_be_registered = False
        if menubar_can_be_registered:
            self._menubar.register(action)
        self._toolbar.register(action)
        return action

    def register_tools(self):
        separator_action = ActionFactory(SeparatorInfo("Tools"))
        add_separator_after = ["stop test run","search unused keywords","preview","view ride log"]
        for key in sorted(self._tools_items.iterkeys()):
            self._menubar.register(self._tools_items[key])
            if self._tools_items[key].name.lower() in add_separator_after:
                self._menubar.register(separator_action)

    def register_actions(self, actions):
        for action in actions:
            self.register_action(action)

    def register_shortcut(self, action_info):
        action = ActionFactory(action_info)
        self._shortcut_registry.register(action)
        return action


class AboutDialog(Dialog):

    def __init__(self):
        Dialog.__init__(self, title='RIDE')
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(HtmlWindow(self, (450, 200), ABOUT_RIDE), 1, flag=wx.EXPAND)
        self.SetSizerAndFit(sizer)

    def OnKey(self, *args):
        pass


class ShortcutKeysDialog(Dialog):

    def __init__(self):
        Dialog.__init__(self, title='Shortcut keys for RIDE')
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(HtmlWindow(self, (350, 400), self._get_platform_specific_shortcut_keys()), 1, flag=wx.EXPAND)
        self.SetSizerAndFit(sizer)

    def OnKey(self, *args):
        pass

    def _get_platform_specific_shortcut_keys(self):
        return localize_shortcuts(SHORTCUT_KEYS)

########NEW FILE########
__FILENAME__ = notebook
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

try:
    from wx.lib.agw import flatnotebook as fnb
except ImportError:
    from wx.lib import flatnotebook as fnb

from robotide.publish import RideNotebookTabChanging, RideNotebookTabChanged


class NoteBook(fnb.FlatNotebook):

    def __init__(self, parent, app):
        self._app = app
        style = fnb.FNB_NODRAG|fnb.FNB_HIDE_ON_SINGLE_TAB|fnb.FNB_VC8
        fnb.FlatNotebook.__init__(self, parent, style=style)
        self.Bind(fnb.EVT_FLATNOTEBOOK_PAGE_CLOSING, self.OnTabClosing)
        self.Bind(fnb.EVT_FLATNOTEBOOK_PAGE_CHANGING, self.OnTabChanging)
        self.Bind(fnb.EVT_FLATNOTEBOOK_PAGE_CHANGED, self.OnTabChanged)
        self._tab_closing = False
        self._uncloseable = []

    def add_tab(self, tab, title, allow_closing=True):
        if not allow_closing:
            self._uncloseable.append(tab)
        self.AddPage(tab, title.strip())

    def show_tab(self, tab):
        """Shows the notebook page that contains the given tab."""
        if not self.tab_is_visible(tab):
            page = self.GetPageIndex(tab)
            if page >= 0:
                self.SetSelection(page)

    def delete_tab(self, tab):
        if tab in self._uncloseable:
            self._uncloseable.remove(tab)
        page = self.GetPageIndex(tab)
        self.DeletePage(page)

    def rename_tab(self, tab, new_name):
        self.SetPageText(self.GetPageIndex(tab), new_name)

    def allow_closing(self, tab):
        if tab in self._uncloseable:
            self._uncloseable.remove(tab)

    def disallow_closing(self, tab):
        if tab not in self._uncloseable:
            self._uncloseable.append(tab)

    def tab_is_visible(self, tab):
        return tab == self.GetCurrentPage()

    @property
    def current_page_title(self):
        return self.GetPageText(self.GetSelection())

    def OnTabClosing(self, event):
        if self.GetPage(event.GetSelection()) in self._uncloseable:
            event.Veto()
            return
        self._tab_closing = True

    def OnTabChanging(self, event):
        if not self._tab_changed():
            return
        oldtitle = self.GetPageText(event.GetOldSelection())
        newindex = event.GetSelection()
        if newindex <= self.GetPageCount() - 1:
            newtitle = self.GetPageText(event.GetSelection())
            self.GetPage(event.GetSelection()).SetFocus()
        else:
            newtitle = None
        RideNotebookTabChanging(oldtab=oldtitle, newtab=newtitle).publish()

    def OnTabChanged(self, event):
        if not self._tab_changed():
            self._tab_closing = False
            return
        RideNotebookTabChanged().publish()

    def _tab_changed(self):
        """Change event is send even when no tab available or tab is closed"""
        if not self.GetPageCount() or self._tab_closing:
            return False
        return True

########NEW FILE########
__FILENAME__ = pluginmanager
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx.lib.scrolledpanel import ScrolledPanel

from robotide.context import LOG
from robotide.publish import RideLogException
from robotide.widgets import Label


class PluginManager(object):

    def __init__(self, notebook):
        self._notebook = notebook
        self._tab = None

    def show(self, plugins):
        if not self._tab:
            self._tab = _PluginPanel(self._notebook, plugins, self._show_tab)
            self._notebook.add_tab(self._tab, 'Manage Plugins')
        self._show_tab()

    def _show_tab(self):
        self._notebook.show_tab(self._tab)


class _PluginPanel(wx.Panel):

    def __init__(self, notebook, plugins, activation_callback):
        wx.Panel.__init__(self, notebook)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self._create_header(), 0, flag=wx.LEFT|wx.RIGHT|wx.TOP, border=16)
        sizer.Add(self._create_info_text(), 0, flag=wx.EXPAND|wx.LEFT|wx.RIGHT, border=16)
        sizer.Add(self._create_line(), 0, flag=wx.EXPAND|wx.LEFT|wx.RIGHT)
        sizer.Add(self._create_body(plugins, activation_callback), 1, flag=wx.EXPAND|wx.ALL, border=16)
        self.SetSizer(sizer)

    def _create_header(self):
        header_panel = wx.Panel(self, wx.ID_ANY)
        header = Label(header_panel, wx.ID_ANY, "Installed Plugins")
        header.SetFont(wx.Font(14, wx.SWISS, wx.NORMAL, wx.BOLD))
        return header

    def _create_line(self):
        return wx.StaticLine(self)

    def _create_body(self, plugins, activation_callback):
        panel = ScrolledPanel(self, wx.ID_ANY, style=wx.TAB_TRAVERSAL)
        panel.SetupScrolling()
        sizer = wx.FlexGridSizer(1, 2, hgap=8, vgap=8)
        sizer.AddGrowableCol(1, 1)
        sizer.Add(self._create_label(panel, 'Enabled'), 0, wx.BOTTOM, border=8)
        sizer.Add(self._create_label(panel, 'Plugin'), 0,
                  wx.BOTTOM|wx.EXPAND, border=8)
        for plugin in sorted(plugins, key=lambda p: p.name):
            sizer.Add(_PluginEnablationCheckBox(panel, plugin, activation_callback),
                      flag=wx.ALIGN_CENTER_HORIZONTAL)
            sizer.Add(_PluginRow(panel, plugin), 0, wx.EXPAND)
        panel.SetSizer(sizer)
        return panel

    def _create_info_text(self):
        info = wx.StaticText(self, wx.ID_ANY, "Info. Enabling and disabling plugins might require RIDE restart for menus to work.")
        info.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.FONTWEIGHT_NORMAL))
        return info

    def _create_label(self, parent, text):
        boldFont = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        boldFont.SetWeight(wx.FONTWEIGHT_BOLD)
        label = Label(parent, wx.ID_ANY, text)
        label.SetFont(boldFont)
        return label


class _PluginEnablationCheckBox(wx.CheckBox):

    def __init__(self, parent, plugin, activation_callback):
        wx.CheckBox.__init__(self, parent)
        self.SetValue(plugin.enabled)
        self.Bind(wx.EVT_CHECKBOX, self.OnCheckBox)
        if plugin.error:
            self.Enable(False)
        self._plugin = plugin
        self._callback = activation_callback

    def OnCheckBox(self, event):
        if event.IsChecked():
            self._execute(self._plugin.enable)
        else:
            self._execute(self._plugin.disable)
        self._callback()

    def _execute(self, method):
        try:
            method()
        except Exception, err:
            self.SetValue(False)
            self.Enable(False)
            msg = 'Failed to %s plugin %s:\n%s'\
                   % (method.__name__, self._plugin.name, err)
            self._plugin.error = err
            self._plugin.doc = msg
            LOG.error(msg)
            RideLogException(message=msg, exception=err, level='ERROR').publish()


class _PluginRow(wx.Panel):

    def __init__(self, parent, plugin):
        wx.Panel.__init__(self, parent)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self._get_name(plugin))
        for name, value in plugin.metadata.items():
            sizer.Add(self._get_metadata(name, value))
        sizer.Add(self._get_description(plugin), 0, wx.EXPAND)
        config = plugin.config_panel(self)
        if config:
            sizer.Add(config, 1, wx.EXPAND|wx.LEFT, border=16)
        self.SetSizer(sizer)

    def _get_name(self, plugin):
        return Label(self, label=plugin.name)

    def _get_metadata(self, name, value):
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(Label(self, label='%s: ' % name))
        if value.split('://')[0] in ['http', 'https']:
            sizer.Add(wx.HyperlinkCtrl(self, -1, label=value, url=value))
        else:
            sizer.Add(Label(self, label=value))
        return sizer

    def _get_description(self, plugin):
        desc = Label(self, label=plugin.doc)
        if plugin.error:
            desc.SetForegroundColour("firebrick")
        return desc

########NEW FILE########
__FILENAME__ = preview
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx.html
from StringIO import StringIO

from robotide.pluginapi import Plugin, ActionInfo, TreeAwarePluginMixin
from robotide.publish import (RideTreeSelection, RideNotebookTabChanged,
                              RideTestCaseAdded, RideUserKeywordAdded)
from robotide.robotapi import TestCase, UserKeyword
from robotide.widgets import ButtonWithHandler, Font
from robotide.utils import Printing


class PreviewPlugin(Plugin, TreeAwarePluginMixin):
    """Provides preview of the test data in HTML, TSV and TXT formats."""
    datafile = property(lambda self: self.get_selected_datafile())

    def __init__(self, application):
        Plugin.__init__(self, application, default_settings={'format': 'HTML'})
        self._panel = None

    def enable(self):
        self.register_action(ActionInfo('Tools','Preview', self.OnShowPreview,
                                        shortcut='F6',
                                        doc='Show preview of the current file',
                                        position=71))
        self.subscribe(self.OnTreeSelection, RideTreeSelection)
        self.subscribe(self.OnTabChanged, RideNotebookTabChanged)
        self.subscribe(self._update_preview, RideTestCaseAdded)
        self.subscribe(self._update_preview, RideUserKeywordAdded)
        self.add_self_as_tree_aware_plugin()

    def disable(self):
        self.remove_self_from_tree_aware_plugins()
        self.unsubscribe_all()
        self.unregister_actions()
        self.delete_tab(self._panel)
        self._panel = None

    def is_focused(self):
        return self.tab_is_visible(self._panel)

    def OnShowPreview(self, event):
        if not self._panel:
            self._panel = PreviewPanel(self, self.notebook)
        self.show_tab(self._panel)
        self._update_preview()

    def OnTreeSelection(self, event):
        if self.is_focused():
            self._panel.tree_node_selected(event.item)

    def OnTabChanged(self, event):
        self._update_preview()

    def _update_preview(self, event=None):
        if self.is_focused() and self.datafile:
            self._panel.update_preview()


class PreviewPanel(wx.Panel):
    _formats = ['HTML', 'Text (Spaces)', 'Text (Pipes)']

    def __init__(self, parent, notebook):
        wx.Panel.__init__(self, notebook)
        self._parent = parent
        main_sizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(main_sizer)
        self._format = parent.format
        self.__view = None
        self._printing = Printing(self)
        box = wx.BoxSizer(wx.HORIZONTAL)
        box.Add(self._chooser())
        box.Add(self._print_button(), 1, wx.ALIGN_CENTER_VERTICAL | wx.EXPAND)
        self.Sizer.Add(box)
        notebook.AddPage(self, "Preview")

    def OnPrint(self, evt):
        self._printing.preview_text(self._get_content())

    @property
    def _file_format(self):
        if self._format == 'HTML':
            return self._format.lower()
        return 'txt'

    @property
    def _pipe_separated(self):
        return 'Pipes' in self._format

    def _chooser(self):
        chooser = wx.RadioBox(self, label='Format', choices=self._formats)
        chooser.SetStringSelection(self._format)
        self.Bind(wx.EVT_RADIOBOX, self.OnTypeChanged, chooser)
        return chooser

    def _print_button(self):
        return ButtonWithHandler(self, 'Print')

    @property
    def _view(self):
        view_class = HtmlView if self._file_format == 'html' else TxtView
        if isinstance(self.__view, view_class):
            return self.__view
        self._remove_current_view()
        self.__view = self._create_view(view_class)
        return self.__view

    def _remove_current_view(self):
        if self.__view:
            self.Sizer.Remove(self.__view)
            self.__view.Destroy()

    def _create_view(self, view_class):
        view = view_class(self)
        self.Sizer.Add(view, 1, wx.EXPAND|wx.ALL, border=8)
        self.Sizer.Layout()
        return view

    def tree_node_selected(self, item):
        self.update_preview()
        self._view.scroll_to_subitem(item)

    def update_preview(self):
        self._view.set_content(self._get_content())

    def _get_content(self):
        datafile = self._parent.datafile
        if not datafile:
            return ''
        output = StringIO()
        try:
            datafile.save(
                output=output,
                format=self._file_format,
                pipe_separated=self._pipe_separated,
                txt_separating_spaces=self._parent.global_settings['txt number of spaces']
            )
        except Exception, e:
            return "Creating preview of '%s' failed: %s" % (datafile.name, e)
        else:
            return output.getvalue()

    def OnTypeChanged(self, event):
        self._format = event.String
        self.update_preview()
        self._parent.save_setting('format', self._format)


class HtmlView(wx.html.HtmlWindow):

    def __init__(self, parent):
        wx.html.HtmlWindow.__init__(self, parent)
        self.SetStandardFonts()

    def set_content(self, content):
        self.SetPage(content)

    def scroll_to_subitem(self, item):
        anchor = self._get_anchor(item.data)
        if self.HasAnchor(anchor):
            self.ScrollToAnchor(anchor)
            self.ScrollLines(-1)
        else:
            self.Scroll(0,0)

    def _get_anchor(self, data):
        if isinstance(data, UserKeyword):
            return 'keyword_%s' % data.name
        if isinstance(data, TestCase):
            return 'test_%s' % data.name
        return ''


class TxtView(wx.TextCtrl):

    def __init__(self, parent):
        wx.TextCtrl.__init__(self, parent, style=wx.TE_MULTILINE)
        self.SetEditable(False)
        self.SetFont(Font().fixed)

    def set_content(self, content):
        self.SetValue(content)

    def scroll_to_subitem(self, item):
        pass

########NEW FILE########
__FILENAME__ = progress
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import time

from robotide import context


class ProgressObserver(object):

    def __init__(self, frame, title, message):
        self._progressbar = wx.ProgressDialog(title, message,
                                              maximum=100, parent=frame,
                                              style=wx.PD_ELAPSED_TIME)

    def notify(self):
        self._progressbar.Pulse()

    def finish(self):
        self._progressbar.Destroy()
        context.LOG.report_parsing_errors()

    def error(self, msg):
        self.finish()
        context.LOG.error(msg)


class LoadProgressObserver(ProgressObserver):

    def __init__(self, frame):
        ProgressObserver.__init__(self, frame, 'RIDE', 'Loading the test data')


class RenameProgressObserver(ProgressObserver):

    def __init__(self, frame):
        ProgressObserver.__init__(self, frame, 'RIDE', 'Renaming')
        self._notification_occured = 0

    def notify(self):
        if time.time() - self._notification_occured > 0.1:
            self._progressbar.Pulse()
            self._notification_occured = time.time()

########NEW FILE########
__FILENAME__ = resourcedialogs
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.controller.filecontrollers import ResourceFileController

import wx

from robotide.controller.commands import DeleteResourceAndImports, DeleteFile, DeleteFolder, DeleteFolderAndImports
from robotide.usages.commands import FindResourceUsages, FindTestFolderUsages
from robotide.usages.usagesdialog import ResourceImportListModel, RecursiveResourceImportListModel
from robotide.widgets import Dialog, VirtualList, VerticalSizer, Label


class _UsageDialog(Dialog):
    _width = 650
    _height = 250

    def __init__(self, usages, title, checkbox_label, model=ResourceImportListModel):
        Dialog.__init__(self, title, size=(self._width, self._height))
        self._sizer = VerticalSizer()
        self._create_controls(usages, checkbox_label, model)
        self._create_horizontal_line(self._sizer)
        self._create_buttons(self._sizer)
        self.SetSizer(self._sizer)

    def _create_controls(self, usages, checkbox_label, model):
        self._sizer.add_with_padding(Label(self, label="Usages:"))
        model = model(usages)
        self._sizer.add_expanding(VirtualList(self, model.headers, model))
        self._add_usages_modifying_help(usages)
        self._checkbox = wx.CheckBox(self, label=checkbox_label)
        self._checkbox.SetValue(True)
        self._sizer.add_with_padding(self._checkbox)

    def _add_usages_modifying_help(self, usages):
        if any(u for u in usages if not u.can_be_renamed):
            help = Label(self,
                label='Highlighted imports are not modified because they '
                      'contain variables in resource file name.')
            help.Wrap(self._width)
            help.SetForegroundColour('red')
            self._sizer.add_with_padding(help)

    def show(self):
        confirmed = self.ShowModal() == wx.ID_OK
        return confirmed, self._checkbox.IsChecked()


class _FolderUsageDialog(_UsageDialog):

    def __init__(self, usages, title, checkbox_label):
        _UsageDialog.__init__(self, usages, title, checkbox_label)


class ResourceRenameDialog(object):
    def __init__(self, controller):
        self._rename_confirmed = True
        self._rename_usage = False
        title = 'Rename resource'
        checkbox_label = 'Also update resource imports'

        usages = list(controller.execute(FindResourceUsages()))
        if usages:
            self._rename_confirmed, self._rename_usage = _UsageDialog(usages, title, checkbox_label).show()

    def execute(self):
        return self._rename_confirmed and self._rename_usage


class ResourceDeleteDialog(object):
    def __init__(self, controller):
        self._delete_confirmed = False
        self._delete_usage = False
        self._controller = controller
        title = 'Delete resource'
        checkbox_label = 'Also delete resource imports'

        usages = list(controller.execute(FindResourceUsages()))
        self._delete_confirmed, self._delete_usage = _UsageDialog(usages, title, checkbox_label).show()

    def execute(self):
        if self._delete_confirmed:
            if self._delete_usage:
                self._controller.execute(DeleteResourceAndImports())
            else:
                self._controller.execute(DeleteFile())


class FolderDeleteDialog(object):
    def __init__(self, controller):
        self._delete_confirmed = False
        self._delete_usage = False
        self._controller = controller
        title = 'Delete test data folder'
        checkbox_label = 'Also delete resource imports'

        usages = list(controller.execute(FindTestFolderUsages()))
        self._delete_confirmed, self._delete_usage = _UsageDialog(usages, title, checkbox_label, RecursiveResourceImportListModel).show()

    def execute(self):
        if self._delete_confirmed:
            if self._delete_usage:
                self._controller.execute(DeleteFolderAndImports())
            else:
                self._controller.execute(DeleteFolder())
########NEW FILE########
__FILENAME__ = review
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import wx
import wx.lib.mixins.listctrl as listmix
import time
import re
from robotide.context.platform import IS_MAC
from robotide.ui.searchdots import DottedSearch
from robotide.widgets import ButtonWithHandler, Label
from robotide.spec.iteminfo import LibraryKeywordInfo
from robotide.usages.commands import FindUsages
from robotide.controller.filecontrollers import TestCaseFileController, ResourceFileController, TestDataDirectoryController
from threading import Thread

class ReviewDialog(wx.Frame):

    def __init__(self, controller, frame):
        wx.Frame.__init__(self, frame, title="Search unused keywords", style=wx.SYSTEM_MENU|wx.CAPTION|wx.CLOSE_BOX|wx.CLIP_CHILDREN|wx.FRAME_FLOAT_ON_PARENT)
        self.index = 0
        self.frame = frame
        self._search_model = ResultModel()
        self._runner = ReviewRunner(controller, self._search_model)
        self._build_ui()
        self._make_bindings()
        self._set_default_values()
        self.CenterOnParent()

    def _build_ui(self):
        self.SetSize((800,600))
        self.SetBackgroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE))
        self.SetSizer(wx.BoxSizer(wx.VERTICAL))
        self._build_header()
        self._build_filter()
        self._build_notebook()
        self._build_unused_keywords()
        self._build_controls()

    def _build_header(self):
        label_introduction = wx.StaticText(self,
                                           label='This dialog helps you finding unused keywords within your opened project.\nIf you want, you can restrict the search to a set of files with the filter.')
        label_filter_is = wx.StaticText(self, label='Filter is')
        self.label_filter_status = wx.StaticText(self, label='inactive')
        header_sizer = wx.BoxSizer(wx.HORIZONTAL)
        header_sizer.Add(label_introduction, 0, wx.ALL | wx.EXPAND, 3)
        header_sizer.AddStretchSpacer(1)
        header_sizer.Add(label_filter_is, 0,
                         wx.LEFT | wx.TOP | wx.BOTTOM | wx.ALIGN_BOTTOM, 3)
        header_sizer.Add(self.label_filter_status, 0,
                         wx.ALL | wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT, 3)
        self.Sizer.Add(header_sizer, 0, wx.ALL | wx.EXPAND, 3)

    def _build_filter(self):
        self._filter_pane = MyCollapsiblePane(self, label="Filter",
                                              style=wx.CP_DEFAULT_STYLE | wx.CP_NO_TLW_RESIZE)
        self._filter_input = wx.TextCtrl(self._filter_pane.GetPane(),
                                         size=(-1, 20))
        self._filter_regex_switch = wx.CheckBox(self._filter_pane.GetPane(),
                                                wx.ID_ANY, label="Use RegEx")
        self._filter_info = wx.StaticText(self._filter_pane.GetPane(),
                                          label='Here you can define one or more strings separated by comma (e.g. common,abc,123).\nThe filter matches if at least one string is part of the filename.\nIf you don\'t enter any strings, all opened files are included')
        filter_source_box = wx.StaticBox(self._filter_pane.GetPane(), label="Search")
        self._filter_source_testcases = wx.CheckBox(self._filter_pane.GetPane(),
                                                    wx.ID_ANY,
                                                    label="Test case files")
        self._filter_source_resources = wx.CheckBox(self._filter_pane.GetPane(),
                                                    wx.ID_ANY,
                                                    label="Resource files")
        self._filter_mode = wx.RadioBox(self._filter_pane.GetPane(),
                                        label="Mode",
                                        choices=["exclude", "include"])
        self._filter_test_button = wx.Button(self._filter_pane.GetPane(),
                                             wx.ID_ANY, 'Test the filter')
        filter_box_sizer = wx.BoxSizer(wx.HORIZONTAL)
        filter_box_sizer.SetSizeHints(self._filter_pane.GetPane())
        filter_source_sizer = wx.StaticBoxSizer(filter_source_box, wx.VERTICAL)
        checkbox_border = 0 if IS_MAC else 3
        filter_source_sizer.Add(self._filter_source_testcases, 0, wx.ALL, checkbox_border)
        filter_source_sizer.Add(self._filter_source_resources, 0, wx.ALL, checkbox_border)
        filter_options = wx.BoxSizer(wx.VERTICAL)
        filter_options.Add(filter_source_sizer, 0,
                           wx.BOTTOM | wx.RIGHT | wx.LEFT | wx.EXPAND, 3)
        filter_options.Add(self._filter_mode, 0, wx.ALL | wx.EXPAND, 3)
        filter_input_sizer = wx.BoxSizer(wx.VERTICAL)
        filter_input_sizer.SetMinSize((600, -1))
        filter_input_sizer.AddSpacer(10)
        filter_input_sizer.Add(self._filter_input, 0, wx.ALL | wx.EXPAND, 3)
        filter_input_sizer.Add(self._filter_regex_switch, 0,
                               wx.ALL | wx.ALIGN_RIGHT, 3)
        filter_input_sizer.Add(self._filter_info, 0, wx.ALL | wx.EXPAND, 3)
        filter_input_sizer.AddStretchSpacer(1)
        filter_controls = wx.BoxSizer(wx.HORIZONTAL)
        filter_controls.AddStretchSpacer(1)
        filter_controls.Add(self._filter_test_button, 0,
                            wx.ALL | wx.ALIGN_BOTTOM | wx.ALIGN_RIGHT, 3)
        filter_input_sizer.Add(filter_controls, 0, wx.ALL | wx.EXPAND, 3)
        filter_box_sizer.Add(filter_options, 0, wx.ALL | wx.EXPAND, 3)
        filter_box_sizer.Add(filter_input_sizer, 0, wx.ALL | wx.EXPAND, 3)
        self._filter_pane.GetPane().SetSizer(filter_box_sizer)
        self.Sizer.Add(self._filter_pane, 0, wx.ALL | wx.EXPAND, 3)

    def _build_unused_keywords(self):
        panel_unused_kw = wx.Panel(self._notebook)
        sizer_unused_kw = wx.BoxSizer(wx.VERTICAL)
        panel_unused_kw.SetSizer(sizer_unused_kw)
        self._unused_kw_list = ResultListCtrl(panel_unused_kw,
                                              style=wx.LC_REPORT)
        self._unused_kw_list.InsertColumn(0, "Keyword", width=400)
        self._unused_kw_list.InsertColumn(1, "File", width=250)
        self._unused_kw_list.SetMinSize((650, 250))
        self._unused_kw_list.set_dialog(self)
        self._delete_button = wx.Button(panel_unused_kw, wx.ID_ANY,
                                        'Delete marked keywords')
        sizer_unused_kw.Add(self._unused_kw_list, 1, wx.ALL | wx.EXPAND, 3)
        unused_kw_controls = wx.BoxSizer(wx.HORIZONTAL)
        unused_kw_controls.AddStretchSpacer(1)
        unused_kw_controls.Add(self._delete_button, 0, wx.ALL | wx.ALIGN_RIGHT,
                               3)
        sizer_unused_kw.Add(unused_kw_controls, 0, wx.ALL | wx.EXPAND, 3)
        self._notebook.AddPage(panel_unused_kw, "Unused Keywords")

    def _build_controls(self):
        self._search_button = ButtonWithHandler(self, 'Search')
        self._abort_button = ButtonWithHandler(self, 'Abort')
        self._status_label = Label(self, label='')
        controls = wx.BoxSizer(wx.HORIZONTAL)
        controls.Add(self._search_button, 0, wx.ALL, 3)
        controls.Add(self._abort_button, 0, wx.ALL, 3)
        controls.Add(self._status_label, 1, wx.ALL | wx.EXPAND, 3)
        self.Sizer.Add(controls, 0, wx.ALL | wx.EXPAND, 3)

    def _build_notebook(self):
        self._notebook = wx.Notebook(self, wx.ID_ANY, style=wx.NB_TOP)
        self.Sizer.Add(self._notebook, 1, wx.ALL | wx.EXPAND, 3)

    def _make_bindings(self):
        self.Bind(wx.EVT_CLOSE, self._close_dialog)
        self.Bind(wx.EVT_TEXT, self._update_filter, self._filter_input)
        self.Bind(wx.EVT_RADIOBOX, self._update_filter_mode, self._filter_mode)
        self.Bind(wx.EVT_CHECKBOX, self._update_filter_source_testcases, self._filter_source_testcases)
        self.Bind(wx.EVT_CHECKBOX, self._update_filter_source_resources, self._filter_source_resources)
        self.Bind(wx.EVT_BUTTON, self.OnDeletemarkedkeywords, self._delete_button)
        self.Bind(wx.EVT_BUTTON, self.OnShowfilestobesearched, self._filter_test_button)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnResultSelected, self._unused_kw_list)
        self.Bind(wx.EVT_CHECKBOX, self._upate_filter_regex, self._filter_regex_switch)
        self.Bind(wx.EVT_COLLAPSIBLEPANE_CHANGED, self._toggle_filter_active, self._filter_pane)

    def _set_default_values(self):
        check_testcases = True
        self._filter_source_testcases.SetValue(check_testcases)
        self._runner.set_filter_source_testcases(check_testcases)
        check_resources = True
        self._filter_source_resources.SetValue(check_resources)
        self._runner.set_filter_source_resources(check_resources)
        filter_mode = 0
        self._filter_mode.SetSelection(filter_mode)
        self._runner.set_filter_mode(filter_mode == 0)
        use_regex = False
        self._filter_regex_switch.SetValue(use_regex)
        self._runner.set_filter_use_regex(use_regex)
        filter_string = ''
        self._filter_input.ChangeValue(filter_string)
        self._runner.parse_filter_string(filter_string)
        self._disable_filter()
        self._abort_button.Disable()
        self._delete_button.Disable()

    def _update_filter(self, event):
        self._runner.parse_filter_string(event.GetString())

    def _update_filter_mode(self, event):
        self._runner.set_filter_mode(event.GetInt() == 0)

    def _update_filter_source_testcases(self, event):
        self._runner.set_filter_source_testcases(event.Checked())

    def _update_filter_source_resources(self, event):
        self._runner.set_filter_source_resources(event.Checked())

    def _upate_filter_regex(self, event):
        self._runner.set_filter_use_regex(event.Checked())

    def _toggle_filter_active(self, event):
        if event.GetCollapsed():
            self._disable_filter()
        else:
            self._enable_filter()
        self._filter_pane.on_change(event)
    
    def _disable_filter(self):
        self._runner.set_filter_active(False)
        self.label_filter_status.SetLabel('inactive')
        self.label_filter_status.SetForegroundColour(wx.RED)
        
    def _enable_filter(self):
        self._runner.set_filter_active(True)
        self.label_filter_status.SetLabel('active')
        self.label_filter_status.SetForegroundColour((0,200,0))

    def OnSearch(self, event):
        self.begin_searching()
        self._runner._run_review()

    def OnAbort(self, event):
        self.end_searching()

    def OnDeletemarkedkeywords(self, event):
        item = self._unused_kw_list.get_next_checked_item()
        while item:
            index = item[0]
            kw = item[1]
            listitem = item[2]
            item_id = listitem.GetData()
            self._unused_kw_list.DeleteItem(index)
            self._unused_kw_list.RemoveClientData(item_id)
            kw.delete()
            self._update_notebook_text("Unused Keywords (%d)" % self._unused_kw_list.GetItemCount())
            self.update_status("")
            item = self._unused_kw_list.get_next_checked_item()
        self.item_in_kw_list_checked()

    def OnShowfilestobesearched(self, event):
        df_list = self._runner._get_datafile_list()
        if not df_list:
            string_list = "(None)"
        else:
            string_list = "\n".join(df.name for df in df_list)
        message = "Keywords of the following files will be included in the search:\n\n" + string_list
        wx.MessageDialog(self, message=message, caption="Included files", style=wx.OK|wx.ICON_INFORMATION).ShowModal()

    def OnResultSelected(self, event):
        self.frame.tree.select_node_by_data(self._unused_kw_list.GetClientData(event.GetData()))

    def item_in_kw_list_checked(self):
        if self._unused_kw_list.get_number_of_checked_items() > 0:
            self._delete_button.Enable()
        else:
            self._delete_button.Disable()

    def show_dialog(self):
        if not self.IsShown():
            self._clear_search_results()
            self.Show()
        self.Raise()

    def _close_dialog(self, event):
        if self._search_model.searching:
            self.end_searching()
        if event.CanVeto():
            self.Hide()
        else:
            self.Destroy()

    def begin_searching(self):
        self._abort_button.Enable()
        self._search_button.Disable()
        self._filter_pane.Disable()
        self._unused_kw_list.Disable()
        self._clear_search_results()
        self._dots = DottedSearch(self, self._update_unused_keywords)
        self._dots.start()

    def _clear_search_results(self):
        self._unused_kw_list.ClearAll()
        self._update_notebook_text('Unused Keywords')
        self._delete_button.Disable()
        self._status_label.SetLabel('')
        self._search_model.clear_search()

    def add_result_unused_keyword(self, index, keyword):
        keyword_info = keyword.info
        self._unused_kw_list.InsertStringItem(index, keyword_info.name)
        filename = os.path.basename(keyword_info.item.source)
        self._unused_kw_list.SetStringItem(index, 1, filename)
        self._unused_kw_list.SetItemData(index, index)
        self._unused_kw_list.SetClientData(index, keyword)

    def _update_unused_keywords(self, dots):
        count_before = self._unused_kw_list.GetItemCount()
        for index, kw in list(enumerate(self._search_model.keywords))[count_before:]:
            self.add_result_unused_keyword(index, kw)
        self.update_status("Searching.%s \t- %s" % (dots, self._search_model.status))
        if not self._search_model.searching:
            self.end_searching()

    def _update_notebook_text(self, new_text):
        self._notebook.SetPageText(0, new_text)

    def update_status(self, message, increase=1):
        self._status_label.SetLabel(message)

    def end_searching(self):
        self._dots.stop()
        self._search_model.end_search()
        self._update_notebook_text('Unused Keywords (%d)' % (self._unused_kw_list.GetItemCount()))
        self.update_status("Search finished - Found %d Unused Keywords" % (self._unused_kw_list.GetItemCount()))
        self._unused_kw_list.Enable()
        self._abort_button.Disable()
        self._filter_pane.Enable()
        self._search_button.Enable()

    def send_radiobox_event(self, mycontrol):
        cmd = wx.CommandEvent(wx.EVT_RADIOBOX.evtType[0])
        cmd.SetEventObject(mycontrol)
        cmd.SetId(mycontrol.GetId())
        mycontrol.GetEventHandler().ProcessEvent(cmd)


class ReviewRunner(object):

    def __init__(self, controller, model):
        self._controller = controller
        self._model = model
        self._filter = ResultFilter()

    def set_filter_active(self, value):
        self._filter.active = value

    def set_filter_mode(self, exclude):
        self._filter.excludes = exclude

    def set_filter_source_testcases(self, value):
        self._filter.check_testcases = value

    def set_filter_source_resources(self, value):
        self._filter.check_resources = value

    def set_filter_use_regex(self, value):
        self._filter.use_regex = value

    def parse_filter_string(self, filter_string):
        self._filter.set_strings(filter_string.split(','))

    def _get_datafile_list(self):
        return [df for df in self._controller.datafiles if self._filter.include_file(df)]

    def _run_review(self):
        self._model.begin_search()
        Thread(target=self._run).start()

    def _run(self):
        self._stop_requested = False
        self._model.status = 'listing datafiles'
        for df in self._get_datafile_list():
            libname = os.path.basename(df.source).rsplit('.', 1)[0]
            self._model.status = 'searching from '+libname
            for keyword in df.keywords:
                time.sleep(0) # GIVE SPACE TO OTHER THREADS -- Thread.yield in Java
                self._model.status = "%s.%s" % (libname, keyword.name)
                if not self._model.searching:
                    break
                # Check if it is unused
                if not isinstance(keyword, LibraryKeywordInfo) and keyword.name:
                    if self._is_unused(keyword):
                        self._model.add_unused_keyword(keyword)
            if not self._model.searching:
                break
        self._model.end_search()

    def _is_unused(self, keyword):
        try:
            self._controller.execute(FindUsages(keyword.name, keyword_info=keyword.info)).next()
            return False
        except StopIteration:
            return True


class ResultFilter(object):

    def __init__(self):
        self._strings = []
        self.excludes = True
        self.check_testcases = True
        self.check_resources = True
        self.use_regex = False
        self.active = False

    def set_strings(self, strings):
        self._strings = [s.strip() for s in strings if s.strip()]

    def include_file(self, datafile):
        if isinstance(datafile, TestDataDirectoryController):
            return False
        if not self.active:
            return True
        if not self.check_testcases and isinstance(datafile, TestCaseFileController):
            return False
        if not self.check_resources and isinstance(datafile, ResourceFileController):
            return False
        if not self._strings:
            return True
        return self.excludes ^ any(self._results(datafile.name))

    def _results(self, name):
        for string in self._strings:
            if self.use_regex:
                yield bool(re.match(string, name))
            else:
                yield string in name


class ResultModel(object):

    def __init__(self):
        self.clear_search()

    def clear_search(self):
        self.status = ''
        self.keywords = []
        self.searching = False

    def add_unused_keyword(self, keyword):
        self.keywords += [keyword]

    def begin_search(self):
        self.searching = True

    def end_search(self):
        self.searching = False


class ResultListCtrl(wx.ListCtrl, listmix.CheckListCtrlMixin, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, style):
        self.parent = parent
        wx.ListCtrl.__init__(self, parent=parent, style=style)
        listmix.CheckListCtrlMixin.__init__(self)
        listmix.ListCtrlAutoWidthMixin.__init__(self)
        self.setResizeColumn(2)
        self._clientData = {}

    def set_dialog(self, dialog):
        self._dlg = dialog

    def OnCheckItem(self, index, flag):
        if self._dlg:
            self._dlg.item_in_kw_list_checked()
        else:
            print "No dialog set"

    def get_next_checked_item(self):
        for i in range(self.GetItemCount()):
            if self.IsChecked(i):
                item = self.GetItem(i)
                return ([i, self.GetClientData(item.GetData()), item])
        return None

    def get_number_of_checked_items(self):
        sum = 0
        for i in range(self.GetItemCount()):
            if self.IsChecked(i):
                sum += 1
        return sum

    def SetClientData(self, index, data):
        self._clientData[index] = data

    def GetClientData(self, index):
        return self._clientData.get(index, None)

    def RemoveClientData(self, index):
        del self._clientData[index]

    def ClearAll(self):
        self.DeleteAllItems()
        self._clientData.clear()

    def print_data(self):
        print self._clientData

class MyCollapsiblePane(wx.CollapsiblePane):
    
    def __init__(self, parent, *args, **kwargs):
        wx.CollapsiblePane.__init__(self, parent, *args, **kwargs)
        self.Bind(wx.EVT_SIZE, self._recalc_size)

    def _recalc_size(self, event=None):
        if self.IsExpanded():
            expand_button_height = 32  # good guess...
            height = 150 if IS_MAC else 135
            self.SetSizeHints(650, height + expand_button_height)
        if self.IsCollapsed():
            self.SetSizeHints(650, 40)
        if event:
            event.Skip()

    def on_change(self, event):
        self.GetParent().Layout()

########NEW FILE########
__FILENAME__ = searchdots
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import wx


class DottedSearch(object):
    """Class that can be used to make Search dots...

    parent - the UI component that the timer should be bound to

    callback - function that will receive timer events in UI thread
               argument to callback is string containing dots '.', '..'. '...' etc.

    """

    def __init__(self, parent, callback):
        self._timer = wx.Timer(parent)
        self._dots = 0
        self._callback = callback
        parent.Bind(wx.EVT_TIMER, self._timer_event)

    def _timer_event(self, event):
        self._dots = (self._dots + 1) % 5
        self._callback('.'*self._dots)

    def start(self):
        self._timer.Start(500)

    def stop(self):
        self._timer.Stop()

########NEW FILE########
__FILENAME__ = tagdialogs
#  Copyright 2008-2013 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import wx.lib.mixins.listctrl as listmix

from robot.utils import NormalizedDict
from robotide.controller.commands import ChangeTag, DeleteTag
from types import *
from robotide.publish import RideOpenTagSearch
from robotide.ui.treenodehandlers import ResourceRootHandler, ResourceFileHandler
from robotide.widgets import ButtonWithHandler, PopupMenuItems

class ViewAllTagsDialog(wx.Frame):

    def __init__(self, controller, frame):
        wx.Frame.__init__(self, frame, title="View all tags", style=wx.SYSTEM_MENU|wx.CAPTION|wx.CLOSE_BOX|wx.CLIP_CHILDREN|wx.FRAME_FLOAT_ON_PARENT)
        self.frame = frame
        self.tree = self.frame.tree
        self._controller = controller
        self._results = NormalizedDict()
        self.selected_tests = list()
        self.tagged_test_cases = list()
        self.unique_tags = 0
        self.total_test_cases = 0
        self._index = -1
        self._build_ui()
        self._make_bindings()

    def _build_ui(self):
        self.SetSize((500,400))
        parent_x, parent_y = self.frame.GetPosition()
        parent_size_x, parent_size_y = self.frame.tree.GetSize()
        self.SetPosition((parent_x+parent_size_x+50,parent_y+50))
        self.SetBackgroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE))
        self.SetSizer(wx.BoxSizer(wx.VERTICAL))
        self._build_notebook()
        self._build_tag_lister()
        self._build_controls()
        self._build_footer()

    def _build_tag_lister(self):
        panel_tag_vw = wx.Panel(self._notebook)
        sizer_tag_vw = wx.BoxSizer(wx.VERTICAL)
        panel_tag_vw.SetSizer(sizer_tag_vw)
        self._tags_list = TagsListCtrl(panel_tag_vw,style=wx.LC_REPORT)
        self._tags_list.InsertColumn(0, "Tag", width=200)
        self._tags_list.InsertColumn(1, "Occurrences", width=25, format=wx.LIST_FORMAT_CENTER)
        self._tags_list.SetMinSize((450, 250))
        self._tags_list.set_dialog(self)
        sizer_tag_vw.Add(self._tags_list, 1, wx.ALL | wx.EXPAND, 3)
        self._notebook.AddPage(panel_tag_vw, "The List")

    def _build_controls(self):
        self._clear_button = ButtonWithHandler(self, 'Refresh', self.OnClear)
        self._show_tagged_tests_button = ButtonWithHandler(self, 'Included Tag Search')
        self._show_excluded_tests_button = ButtonWithHandler(self, 'Excluded Tag Search')
        controls = wx.BoxSizer(wx.HORIZONTAL)
        controls.Add(self._show_tagged_tests_button, 0, wx.ALL, 3)
        controls.Add(self._show_excluded_tests_button, 0, wx.ALL, 3)
        controls.Add(self._clear_button, 0, wx.ALL, 3)
        self.Sizer.Add(controls, 0, wx.ALL | wx.EXPAND, 3)

    def _build_footer(self):
        footer = wx.BoxSizer(wx.HORIZONTAL)
        self._footer_text = wx.StaticText(self, -1, '')
        footer.Add(self._footer_text)
        self.Sizer.Add(footer, 0, wx.ALL, 3)

    def _build_notebook(self):
        self._notebook = wx.Notebook(self, wx.ID_ANY, style=wx.NB_TOP)
        self.Sizer.Add(self._notebook, 1, wx.ALL | wx.EXPAND, 3)

    def _make_bindings(self):
        self.Bind(wx.EVT_CLOSE, self._close_dialog)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnTagSelected)
        self._tags_list.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.OnRightClick)

    def _execute(self):
        self._clear_search_results()
        self._search_for_tags()

        self.tagged_test_cases = list()
        self.unique_tags = 0

        for tag_name, tests in self._results:
            self._tags_list.SetClientData(self.unique_tags, (tests,tag_name))
            self._tags_list.InsertStringItem(self.unique_tags, unicode(tag_name))
            self.tagged_test_cases += tests
            self._tags_list.SetStringItem(self.unique_tags, 1, str(len(tests)))
            self.unique_tags += 1
        self._tags_list.SetColumnWidth(1,wx.LIST_AUTOSIZE_USEHEADER)
        self._tags_list.setResizeColumn(1)
        self.tagged_test_cases = list(set(self.tagged_test_cases))
        self.update_footer()

    def update_footer(self):
        footer_string = "Total tests %d, Tests with tags %d, Unique tags %d, Currently selected tests %d" % \
                    (self.total_test_cases, len(self.tagged_test_cases), self.unique_tags, len(self.selected_tests))
        self._footer_text.SetLabel(footer_string)

    def show_dialog(self):
        self._execute()
        if not self.IsShown():
            self.Show()
        self.Raise()

    def _clear_search_results(self):
        self.selected_tests = list()
        self._tags_list.ClearAll()

    def _add_view_components(self):
        pass

    def _search_for_tags(self):
        self._unique_tags = NormalizedDict()
        self._tagit = dict()
        self._test_cases = list()
        for test in self.frame._controller.all_testcases():
            self._test_cases.append(test)
            for tag in test.tags:
                if tag.is_empty() or len(unicode(tag).strip()) == 0:
                    continue
                else:
                    tag_name = unicode(tag)
                if self._unique_tags.has_key(tag_name):
                    self._unique_tags[tag_name].append(test)
                    self._tagit[tag_name].append(tag)
                else:
                    self._unique_tags.set(tag_name, [test])
                    self._tagit[tag_name] = [tag]

        self.total_test_cases = len(self._test_cases)
        self._results = sorted(self._unique_tags.items(), key=lambda x: len(x[1]), reverse=True)

    def GetListCtrl(self):
        return self._tags_list

    def OnColClick(self, event):
        event.Skip()

    def _add_checked_tags_into_list(self):
        tags = []
        for tests,tag_name in self._tags_list.get_checked_items():
            tags.append(tag_name)
        return tags

    def OnIncludedTagSearch(self, event):
        included_tags = self._add_checked_tags_into_list()
        RideOpenTagSearch(includes=' '.join(included_tags), excludes="").publish()

    def OnExcludedTagSearch(self, event):
        excluded_tags = self._add_checked_tags_into_list()
        RideOpenTagSearch(includes="", excludes=' '.join(excluded_tags)).publish()

    def OnClear(self, event):
        self._execute()
        for tag_name, tests in self._results:
            self.tree.DeselectTests(tests)
        for item in self.tree.GetItemChildren():
            if not isinstance(item.GetData(), ResourceRootHandler or ResourceFileHandler):
                self.tree.CollapseAllSubNodes(item)
        self.update_footer()

    def OnSelectAll(self, event):
        all_tests = []
        for tag_name, tests in self._results:
            all_tests += tests
        self.tree.SelectTests(all_tests)
        self._tags_list.CheckAll()

    def OnRightClick(self, event):
        self._index = event.GetIndex()
        self.tree._popup_creator.show(self, PopupMenuItems(self, ["Select all",
                                                                  "Clear",
                                                                  "---",
                                                                  "Rename",
                                                                  "Delete",
                                                                  "---",
                                                                  "Show tests with this tag",
                                                                  "Show tests without this tag"]),
                                      self._controller)

    def OnShowTestsWithThisTag(self, event):
        if self._index == -1:
            return
        tests,tag_name = self._tags_list.GetClientData(self._index)
        RideOpenTagSearch(includes=tag_name, excludes="").publish()

    def OnShowTestsWithoutThisTag(self, event):
        if self._index == -1:
            return
        tests,tag_name = self._tags_list.GetClientData(self._index)
        RideOpenTagSearch(includes="", excludes=tag_name).publish()

    def OnRename(self, event):
        if self._index == -1:
            return
        tests,tag_name = self._tags_list.GetClientData(self._index)
        tags_to_rename = self._tagit[tag_name]
        name = wx.GetTextFromUser(message="Renaming tag '%s'." % tag_name, default_value=tag_name, caption='Rename')
        if name:
            for tag in tags_to_rename:
                tag.controller.execute(ChangeTag(tag, name))
            self._execute()
            for tag_name, tests in self._results:
                self.tree.DeselectTests(tests)

    def OnDelete(self, event):
        if self._index == -1:
            return
        tests,tag_name = self._tags_list.GetClientData(self._index)
        tags_to_delete = self._tagit[tag_name]
        if wx.MessageBox("Delete a tag '%s' ?" % tag_name, caption='Confirm',
            style=wx.YES_NO | wx.ICON_QUESTION) == wx.YES:
            for tag in tags_to_delete:
                tag.execute(DeleteTag())
            self._execute()
            for tag_name, tests in self._results:
                self.tree.DeselectTests(tests)

    def _close_dialog(self, event):
        if event.CanVeto():
            self.Hide()
        else:
            self.Destroy()

    def OnTagSelected(self, event):
        item = self._tags_list.GetItem(event.GetIndex())

    def item_in_kw_list_checked(self, index, flag):
        self.selected_tests = list()
        if flag == False:
            tests, tag_name = self._tags_list.GetClientData(index)
            self.tree.DeselectTests(tests)
        if self._tags_list.get_number_of_checked_items() > 0:
            for tests,tag_name in self._tags_list.get_checked_items():
                self.selected_tests += tests
                self.tree.SelectTests(tests)
        self.selected_tests = list(set(self.selected_tests))
        self.update_footer()


class TagsListCtrl(wx.ListCtrl, listmix.CheckListCtrlMixin, listmix.ListCtrlAutoWidthMixin):
    def __init__(self, parent, style):
        self.parent = parent
        wx.ListCtrl.__init__(self, parent=parent, style=style)
        listmix.CheckListCtrlMixin.__init__(self)
        listmix.ListCtrlAutoWidthMixin.__init__(self)
        self.setResizeColumn(2)
        self._clientData = {}

    def OnCheckItem(self, index, flag):
        if self._dlg:
            self._dlg.item_in_kw_list_checked(index,flag)
        else:
            pass

    def get_next_checked_item(self):
        for i in range(self.GetItemCount()):
            if self.IsChecked(i):
                item = self.GetItem(i)
                return ([i, self.GetClientData(item.GetData()), item])
        return None

    def get_checked_items(self):
        items = []
        for i in range(self.GetItemCount()):
            if self.IsChecked(i):
                items.append(self.GetClientData(i))
        return items

    def get_number_of_checked_items(self):
        sum = 0
        for i in range(self.GetItemCount()):
            if self.IsChecked(i):
                sum += 1
        return sum

    def set_dialog(self, dialog):
        self._dlg = dialog

    def SetClientData(self, index, data):
        self._clientData[index] = data

    def GetClientData(self, index):
        return self._clientData.get(index, None)

    def RemoveClientData(self, index):
        del self._clientData[index]

    def ClearAll(self):
        self.DeleteAllItems()
        self._clientData.clear()

    def CheckAll(self):
        for i in range(self.GetItemCount()):
            self.CheckItem(i)

########NEW FILE########
__FILENAME__ = tree
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
from wx.lib.agw import customtreectrl
from wx.lib.agw.customtreectrl import GenericTreeItem
from wx.lib.mixins import treemixin

from robotide.controller.ui.treecontroller import TreeController, TestSelectionController
from robotide.context import IS_WINDOWS
from robotide.action.actioninfo import ActionInfo
from robotide.controller.filecontrollers import ResourceFileController
from robotide.publish.messages import RideTestRunning, RideTestPassed, RideTestFailed, RideTestExecutionStarted, \
    RideImportSetting, RideExcludesChanged, RideIncludesChanged, RideOpenSuite, RideNewProject
from robotide.ui.images import RUNNING_IMAGE_INDEX, PASSED_IMAGE_INDEX, FAILED_IMAGE_INDEX, ROBOT_IMAGE_INDEX
from robotide.ui.treenodehandlers import TestCaseHandler
from robotide.publish import (PUBLISHER, RideTreeSelection, RideFileNameChanged,
    RideItem, RideUserKeywordAdded, RideTestCaseAdded,
    RideUserKeywordRemoved, RideTestCaseRemoved, RideDataFileRemoved, RideDataChangedToDirty,
    RideDataDirtyCleared, RideVariableRemoved, RideVariableAdded,
    RideVariableMovedUp, RideVariableMovedDown, RideVariableUpdated,
    RideOpenResource, RideSuiteAdded, RideSelectResource, RideDataFileSet)
from robotide.controller.commands import MoveTo
from robotide.widgets import PopupCreator
from robotide import utils

from .treenodehandlers import ResourceRootHandler, action_handler_class, ResourceFileHandler
from .images import TreeImageList

_TREE_ARGS = {'style':wx.TR_DEFAULT_STYLE}

if wx.VERSION_STRING >= '2.8.11.0':
    _TREE_ARGS['agwStyle']=customtreectrl.TR_DEFAULT_STYLE | customtreectrl.TR_HIDE_ROOT | customtreectrl.TR_EDIT_LABELS
if IS_WINDOWS:
    _TREE_ARGS['style'] |= wx.TR_EDIT_LABELS


class Tree(treemixin.DragAndDrop, customtreectrl.CustomTreeCtrl, utils.RideEventHandler):

    _RESOURCES_NODE_LABEL = 'External Resources'

    def __init__(self, parent, action_registerer, settings=None):
        self._checkboxes_for_tests = False
        self._test_selection_controller = self._create_test_selection_controller()
        self._controller = TreeController(self, action_registerer, settings=settings, test_selection=self._test_selection_controller)
        treemixin.DragAndDrop.__init__(self, parent, **_TREE_ARGS)
        self._controller.register_tree_actions()
        self._bind_tree_events()
        self._images = TreeImageList()
        self._silent_mode = False
        self.SetImageList(self._images)
        self.label_editor = TreeLabelEditListener(self, action_registerer)
        self._controller.bind_keys()
        self._subscribe_to_messages()
        self._popup_creator = PopupCreator()
        self._dragging = False
        self._clear_tree_data()
        self._editor = None
        self._execution_results = None
        if not hasattr(self, 'OnCancelEdit'):
            self.OnCancelEdit = self._on_cancel_edit

    def _create_test_selection_controller(self):
        tsc = TestSelectionController()
        PUBLISHER.subscribe(tsc.clear_all, RideOpenSuite)
        PUBLISHER.subscribe(tsc.clear_all, RideNewProject)
        return tsc

    def _on_cancel_edit(self, item):
        le = customtreectrl.TreeEvent(customtreectrl.wxEVT_TREE_END_LABEL_EDIT, self.GetId())
        le._item = item
        le.SetEventObject(self)
        le._label = ""
        le._editCancelled = True
        self.GetEventHandler().ProcessEvent(le)

    def _bind_tree_events(self):
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.OnSelChanged)
        self.Bind(wx.EVT_TREE_ITEM_EXPANDING, self.OnTreeItemExpanding)
        self.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.OnRightClick)
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.OnItemActivated)
        self.Bind(customtreectrl.EVT_TREE_ITEM_CHECKED, self.OnTreeItemChecked)

    def OnDoubleClick(self, event):
        item, pos = self.HitTest(self.ScreenToClient(wx.GetMousePosition()))
        if item:
            handler = self._controller.get_handler(item)
            handler.double_clicked()
        event.Skip()

    def set_editor(self, editor):
        self._editor = editor

    def StartDragging(self):
        self._dragging = True
        treemixin.DragAndDrop.StartDragging(self)

    def OnEndDrag(self, event):
        self._dragging = False
        treemixin.DragAndDrop.OnEndDrag(self, event)

    def register_context_menu_hook(self, callable):
        self._popup_creator.add_hook(callable)

    def unregister_context_menu_hook(self, callable):
        self._popup_creator.remove_hook(callable)

    def _subscribe_to_messages(self):
        subscriptions = [
            (self._item_changed, RideItem),
            (self._resource_added, RideOpenResource),
            (self._select_resource, RideSelectResource),
            (self._suite_added, RideSuiteAdded),
            (self._keyword_added, RideUserKeywordAdded),
            (self._test_added, RideTestCaseAdded),
            (self._variable_added, RideVariableAdded),
            (self._leaf_item_removed, RideUserKeywordRemoved),
            (self._leaf_item_removed, RideTestCaseRemoved),
            (self._leaf_item_removed, RideVariableRemoved),
            (self._datafile_removed, RideDataFileRemoved),
            (self._datafile_set, RideDataFileSet),
            (self._data_dirty, RideDataChangedToDirty),
            (self._data_undirty, RideDataDirtyCleared),
            (self._variable_moved_up, RideVariableMovedUp),
            (self._variable_moved_down, RideVariableMovedDown),
            (self._variable_updated, RideVariableUpdated),
            (self._filename_changed, RideFileNameChanged),
            (self._testing_started, RideTestExecutionStarted),
            (self._test_result, RideTestRunning),
            (self._test_result, RideTestPassed),
            (self._test_result, RideTestFailed),
            (self._handle_import_setting_message, RideImportSetting),
            (self._mark_excludes, RideExcludesChanged),
            (self._mark_excludes, RideIncludesChanged),
        ]
        for listener, topic in subscriptions:
            PUBLISHER.subscribe(listener, topic)

    def _mark_excludes(self, message):
        tree = self._controller.find_node_by_controller(message.old_controller)
        self._render_datafile(self.GetItemParent(tree), message.new_controller)
        self._remove_datafile_node(tree)

    def _set_item_excluded(self, node):
        self.SetItemTextColour(node, 'gray')
        self.SetItemItalic(node, True)
        self.SetItemText(node, "%s (excluded)" % self.GetItemText(node))

    def _handle_import_setting_message(self, message):
        if message.is_resource():
            self._set_resource_color(message.import_controller.get_imported_controller())
            self._set_resource_color(message.import_controller.get_previous_imported_controller())

    def _set_resource_color(self, resource_controller):
        if not resource_controller:
            return
        node = self._controller.find_node_by_controller(resource_controller)
        if node:
            self.SetItemTextColour(node, self._get_resource_text_color(resource_controller))

    def _get_resource_text_color(self, resource_controller):
        return self.GetDefaultAttributes().colFg if resource_controller.is_used() else wx.LIGHT_GREY

    def _testing_started(self, message):
        self._for_all_drawn_tests(self._root, lambda t: self.SetItemImage(t, ROBOT_IMAGE_INDEX))
        self._execution_results = message.results
        self._images.set_execution_results(message.results)

    def _test_result(self, message):
        wx.CallAfter(self._set_icon_from_execution_results, message.item)

    def _set_icon_from_execution_results(self, controller):
        node = self._controller.find_node_by_controller(controller)
        if not node:
            return
        self.SetItemImage(node, self._get_icon_index_for(controller))

    def _get_icon_index_for(self, controller):
        if not self._execution_results:
            return ROBOT_IMAGE_INDEX
        if self._execution_results.is_running(controller):
            return RUNNING_IMAGE_INDEX
        if self._execution_results.has_passed(controller):
            return PASSED_IMAGE_INDEX
        if self._execution_results.has_failed(controller):
            return FAILED_IMAGE_INDEX
        return ROBOT_IMAGE_INDEX

    def populate(self, model):
        self._clear_tree_data()
        self._populate_model(model)
        self._refresh_view()
        self.SetFocus() # Needed for keyboard shortcuts

    def _clear_tree_data(self):
        self.DeleteAllItems()
        self._root = self.AddRoot('')
        self._resource_root = self._create_resource_root()
        self._datafile_nodes = []

    def _create_resource_root(self):
        return self._create_node(self._root, self._RESOURCES_NODE_LABEL,
                                 self._images.directory)

    def _populate_model(self, model):
        handler = ResourceRootHandler(model, self, self._resource_root,
                                      self._controller.settings)
        self.SetPyData(self._resource_root, handler)
        if model.data:
            self._render_datafile(self._root, model.data, 0)
        for res in model.external_resources:
            if not res.parent:
                self._render_datafile(self._resource_root, res)

    def _resource_added(self, message):
        ctrl = message.datafile
        if self._controller.find_node_by_controller(ctrl):
            return
        parent = self._get_dir_node(ctrl.parent) if ctrl.parent else self._resource_root
        self._render_datafile(parent, ctrl)

    def _get_dir_node(self, ctrl):
        if ctrl is None:
            return self._root
        dir_node = self._get_datafile_node(ctrl.data)
        if dir_node is None:
            parent = self._get_dir_node(ctrl.parent)
            self._render_datafile(parent, ctrl)
            dir_node = self._get_datafile_node(ctrl.data)
        return dir_node

    def _select_resource(self, message):
        self.select_controller_node(message.item)

    def select_controller_node(self, controller):
        self.SelectItem(self._controller.find_node_by_controller(controller))

    def _suite_added(self, message):
        self.add_datafile(message.parent, message.suite)

    def _refresh_view(self):
        self.Refresh()
        if self._resource_root:
            self.Expand(self._resource_root)
        if self._datafile_nodes:
            self.SelectItem(self._datafile_nodes[0])
            self._expand_and_render_children(self._datafile_nodes[0])

    def _render_datafile(self, parent_node, controller, index=None):
        node = self._create_node_with_handler(parent_node, controller, index)
        if controller.dirty:
            self._controller.mark_node_dirty(node)
        self._datafile_nodes.append(node)
        self.SetItemHasChildren(node, True)

        for child in controller.children:
            self._render_datafile(node, child)
        return node

    def _create_node_with_handler(self, parent_node, controller, index=None):
        handler_class = action_handler_class(controller)
        node = self._create_node(parent_node, controller.display_name, self._images[controller],
                                 index, with_checkbox=(handler_class == TestCaseHandler and self._checkboxes_for_tests))
        if isinstance(controller, ResourceFileController):
            if not controller.is_used():
                self.SetItemTextColour(node, wx.ColorRGB(0xA9A9A9))
        self.SetPyData(node, handler_class(controller, self, node, self._controller.settings))
        if controller.is_excluded():
            self._set_item_excluded(node)
        return node

    def set_checkboxes_for_tests(self):
        self._checkboxes_for_tests = True

    def _expand_and_render_children(self, node):
        assert node is not None
        self._render_children(node)
        self.Expand(node)

    def _render_children(self, node):
        handler = self._controller.get_handler(node)
        if not handler or not handler.can_be_rendered:
            return
        self._create_child_nodes(node, handler, lambda item: item.is_test_suite)
        handler.set_rendered()

    def _create_child_nodes(self, node, handler, predicate):
        for childitem in self._children_of(handler):
            index = self._get_insertion_index(node, predicate)
            self._create_node_with_handler(node, childitem, index)

    def _children_of(self, handler):
        return [v for v in handler.variables if v.has_data()] + list(handler.tests) + \
                list(handler.keywords)

    def _create_node(self, parent_node, label, img, index=None, with_checkbox=False):
        node = self._wx_node(parent_node, index, label, with_checkbox)
        self.SetItemImage(node, img.normal, wx.TreeItemIcon_Normal)
        self.SetItemImage(node, img.expanded, wx.TreeItemIcon_Expanded)
        return node

    def _wx_node(self, parent_node, index, label, with_checkbox):
        ct_type = 1 if with_checkbox else 0
        if index is not None:
            # blame wxPython for this ugliness
            if isinstance(index, int):
                return self.InsertItemByIndex(parent_node, index, label, ct_type=ct_type)
            else:
                return self.InsertItem(parent_node, index, label, ct_type=ct_type)
        return self.AppendItem(parent_node, label, ct_type=ct_type)

    def add_datafile(self, parent, suite):
        snode = self._render_datafile(self._get_datafile_node(parent.data), suite)
        self.SelectItem(snode)

    def add_test(self, parent_node, test):
        self._add_dataitem(parent_node, test, lambda item: item.is_user_keyword)

    def add_keyword(self, parent_node, kw):
        self._add_dataitem(parent_node, kw, lambda item: item.is_test_suite)

    def _add_dataitem(self, parent_node, dataitem, predicate):
        node = self._get_or_create_node(parent_node, dataitem, predicate)
        self._select(node)
        self._controller.mark_node_dirty(parent_node)

    def _get_or_create_node(self, parent_node, dataitem, predicate):
        if not self.IsExpanded(parent_node):
            self._expand_and_render_children(parent_node)
            return self._controller.find_node_with_label(parent_node, dataitem.display_name)
        index = self._get_insertion_index(parent_node, predicate)
        return self._create_node_with_handler(parent_node, dataitem, index)

    def _select(self, node):
        if node:
            wx.CallAfter(self.SelectItem, node)

    def _get_insertion_index(self, parent_node, predicate):
        if not predicate:
            return None
        item, cookie = self.GetFirstChild(parent_node)
        while item:
            if predicate(self._controller.get_handler(item)):
                index = self.GetPrevSibling(item)
                if not index:
                    index = 0
                return index
            item, cookie = self.GetNextChild(parent_node, cookie)
        return None

    def _keyword_added(self, message):
        self.add_keyword(self._get_datafile_node(self.get_selected_datafile()),
                         message.item)

    def _variable_added(self, message):
        self._get_or_create_node(self._get_datafile_node(self.get_selected_datafile()),
                           message.item, lambda item: not item.is_variable or item.index > message.index)

    def _leaf_item_removed(self, message):
        node = self._controller.find_node_by_controller(message.item)
        self.delete_node(node)

    def _test_added(self, message):
        self.add_test(self._get_datafile_node(self.get_selected_datafile()),
                      message.item)

    def _datafile_removed(self, message):
        dfnode = self._get_datafile_node(message.datafile.data)
        self._datafile_nodes.remove(dfnode)
        self.DeleteChildren(dfnode)
        self.Delete(dfnode)

    def _datafile_set(self, message):
        wx.CallAfter(self._refresh_datafile_when_file_set, message.item)

    def _filename_changed(self, message):
        df = message.datafile
        node = self._controller.find_node_by_controller(df)
        if not node:
            raise AssertionError('No node found with controller "%s"' % df)
        wx.CallAfter(self.SetItemText, node, df.display_name)

    def add_keyword_controller(self, controller):
        parent = self._get_datafile_node(self.get_selected_datafile())
        self.add_keyword(parent, controller)

    def delete_node(self, node):
        if node is None:
            return
        parent = self.GetItemParent(node)
        self._controller.mark_node_dirty(parent)
        if self.IsSelected(node):
            wx.CallAfter(self.SelectItem, parent)
        wx.CallAfter(self.Delete, node)

    def _data_dirty(self, message):
        self._controller.mark_controller_dirty(message.datafile)

    def _data_undirty(self, message):
        self.unset_dirty()

    def unset_dirty(self):
        for node in self._datafile_nodes:
            text = self.GetItemText(node)
            handler = self._controller.get_handler(node)
            if text.startswith('*') and not handler.controller.dirty:
                self.SetItemText(node, text[1:])

    def select_node_by_data(self, controller):
        '''Find and select the tree item associated with the given controller.

        Controller can be any of the controllers that are represented in the tree.'''
        parent_node = self._get_datafile_node(controller.datafile)
        if not parent_node:
            return None
        if not self.IsExpanded(parent_node):
            self._expand_and_render_children(parent_node)
        node = self._controller.find_node_by_controller(controller)
        if node != self.GetSelection():
            self.SelectItem(node)
        return node

    def select_user_keyword_node(self, uk):
        parent_node = self._get_datafile_node(uk.parent.parent)
        if not parent_node:
            return
        if not self.IsExpanded(parent_node):
            self._expand_and_render_children(parent_node)
        node = self._controller.find_node_with_label(parent_node, utils.normalize(uk.name))
        if node != self.GetSelection():
            self.SelectItem(node)

    def _get_datafile_node(self, datafile):
        for node in self._datafile_nodes:
            if self._controller.get_handler(node).item == datafile:
                return node
        return None

    def get_selected_datafile(self):
        """Returns currently selected data file.

        If a test or user keyword node is selected, returns parent of that item.
        """
        datafile = self._get_selected_datafile_node()
        if not datafile:
            return None
        return self._controller.get_handler(datafile).item

    def get_selected_datafile_controller(self):
        """Returns controller associated with currently active data file.

        If a test or user keyword node is selected, returns parent of that item.
        """
        dfnode = self._get_selected_datafile_node()
        return self._controller.get_handler(dfnode).controller if dfnode else None

    def _get_selected_datafile_node(self):
        node = self.GetSelection()
        if not node or node in (self._resource_root, self._root):
            return None
        while node not in self._datafile_nodes:
            node = self.GetItemParent(node)
        return node

    def get_selected_item(self):
        """Returns model object associated with currently selected tree node."""
        selection = self.GetSelection()
        if not selection:
            return None
        handler = self._controller.get_handler(selection)
        return handler and handler.controller or None

    def move_up(self, node):
        prev = self.GetPrevSibling(node)
        if prev.IsOk():
            self._switch_items(prev, node, node)

    def move_down(self, node):
        next = self.GetNextSibling(node)
        if next.IsOk():
            self._switch_items(node, next, node)

    def _switch_items(self, first, second, currently_selected):
        """Changes the order of given items, first is expected to be directly above the second"""
        selection = self.GetItemPyData(currently_selected).controller
        controller = self._controller.get_handler(first).controller
        self.Delete(first)
        self._create_node_with_handler(self.GetItemParent(second),
                                              controller, second)
        self.select_node_by_data(selection)

    def _refresh_datafile_when_file_set(self, controller):
        self._start_silent_mode() #Prevent tab selections based on tree item selected events
        current = self.get_selected_datafile_controller()
        if not current: # If tree is not yet in use - do not expand anything.
            self._end_silent_mode()
            return
        self._uncheck_tests(current)
        item = self.GetSelection()
        current_txt = self.GetItemText(item) if item.IsOk() else ''
        # after refresh current and current_txt might have been changed
        node = self._refresh_datafile(controller)
        if node is None:
            #TODO: Find out why this sometimes happens
            return
        self._expand_and_render_children(node)
        if current == controller:
            wx.CallAfter(self.SelectItem, self._controller.find_node_with_label(node, current_txt) or node)
            wx.CallAfter(self._end_silent_mode)
        else:
            self._end_silent_mode()

    def _uncheck_tests(self, controller):
        self._test_selection_controller.unselect_all(controller.tests)

    def _start_silent_mode(self):
        self._silent_mode = True

    def _end_silent_mode(self):
        self._silent_mode = False

    def refresh_datafile(self, controller, event):
        to_be_selected = self._get_pending_selection(event)
        new_node = self._refresh_datafile(controller)
        self._handle_pending_selection(to_be_selected, new_node)

    def _refresh_datafile(self, controller):
        self._uncheck_tests(controller)
        orig_node = self._get_data_controller_node(controller)
        if orig_node is not None:
            insertion_index = self._get_datafile_index(orig_node)
            parent = self._get_parent(orig_node)
            self._remove_datafile_node(orig_node)
            return self._render_datafile(parent, controller, insertion_index)

    def _get_pending_selection(self, event):
        if hasattr(event, 'Item'):
            item = event.GetItem()
            event.Veto()
        elif hasattr(event, 'Position'):
            item, flags = self.HitTest(event.Position)
            if not (item.IsOk() and self._click_on_item(flags)):
                return
        else:
            return
        return self.GetItemText(item)

    def _get_data_controller_node(self, controller):
        for node in self._datafile_nodes:
            if self.GetItemPyData(node).controller == controller:
                return node
        return None

    def _click_on_item(self, flags):
        return flags & wx.TREE_HITTEST_ONITEM

    def _get_datafile_index(self, node):
        insertion_index = self.GetPrevSibling(node)
        if not insertion_index:
            insertion_index = 0
        return insertion_index

    def _get_parent(self, node):
        return self.GetItemParent(node)

    def _remove_datafile_node(self, node):
        for child in self.GetItemChildren(node):
            if child in self._datafile_nodes:
                self._remove_datafile_node(child)
        self._datafile_nodes.remove(node)
        self.Delete(node)

    def _handle_pending_selection(self, to_be_selected, parent_node):
        if to_be_selected:
            self._expand_and_render_children(parent_node)
            wx.CallAfter(self.SelectItem,
                         self._controller.find_node_with_label(parent_node, to_be_selected))


    def OnSelChanged(self, event):
        node = event.GetItem()
        if not node.IsOk() or self._dragging:
            event.Skip()
            return
        self._controller.add_to_history(node)
        handler = self._controller.get_handler(node)
        if handler and handler.item:
            RideTreeSelection(node=node, item=handler.controller, silent=self._silent_mode).publish()
        self.SetFocus()

    def OnTreeItemExpanding(self, event):
        node = event.GetItem()
        if node.IsOk():
            self._render_children(node)

    def SelectAllTests(self, item):
        self._for_all_tests(item, lambda t: self.CheckItem(t))

    def SelectTests(self, tests):
        def foo(t):
            if self.GetPyData(t).controller in tests:
                self.CheckItem(t)
        self._for_all_tests(self._root, foo)

    def ExpandAllSubNodes(self, item):
        self._expand_or_collapse_nodes(item, self.Expand)

    def CollapseAllSubNodes(self, item):
        self._expand_or_collapse_nodes(item, self.Collapse)

    def _expand_or_collapse_nodes(self, item, callback):
        if not self.HasAGWFlag(customtreectrl.TR_HIDE_ROOT) or item != self.GetRootItem():
            callback(item)
            for child in item.GetChildren():
                self._expand_or_collapse_nodes(child, callback)

    def _for_all_tests(self, item, func):
        if not self.HasAGWFlag(customtreectrl.TR_HIDE_ROOT) or item != self.GetRootItem():
            if isinstance(item.GetData(), ResourceRootHandler or ResourceFileHandler):
                return
            self.Expand(item)
            if self._is_test_node(item):
                func(item)
            if not self.IsExpanded(item):
                return
        for child in item.GetChildren():
            self._for_all_tests(child, func)

    def _for_all_drawn_tests(self, item, func):
        if self._is_test_node(item):
            func(item)
        for child in item.GetChildren():
            self._for_all_drawn_tests(child, func)

    def _is_test_node(self, node):
        return node.GetType() == 1

    def DeselectAllTests(self, item):
        self._for_all_tests(item, lambda t: self.CheckItem(t, checked=False))

    def DeselectTests(self, tests):
        def foo(t):
            if self.GetPyData(t).controller in tests:
                self.CheckItem(t, checked=False)
        self._for_all_tests(self._root, foo)

    def SelectFailedTests(self, item):
        def func(t):
            # FIXME: This information should be in domain model!
            self.CheckItem(t, checked=(self.GetItemImage(t) == FAILED_IMAGE_INDEX))
        self._for_all_tests(item, func)

    def SelectPassedTests(self, item):
        def func(t):
            self.CheckItem(t, checked=(self.GetItemImage(t) == PASSED_IMAGE_INDEX))
        self._for_all_tests(item, func)

    def OnTreeItemChecked(self, event):
        node = event.GetItem()
        handler = self._controller.get_handler(node=node)
        self._test_selection_controller.select(handler.controller, node.IsChecked())

    def OnItemActivated(self, event):
        node = event.GetItem()
        if self.IsExpanded(node):
            self.Collapse(node)
        elif self.ItemHasChildren(node):
            self._expand_and_render_children(node)

    def OnLeftArrow(self, event):
        node = self.GetSelection()
        if self.IsExpanded(node):
            self.Collapse(node)
        else:
            event.Skip()

    def OnRightClick(self, event):
        handler = self._controller.get_handler(event.GetItem() if hasattr(event, 'GetItem') else None)
        if handler:
            if not self.IsExpanded(handler.node):
                self.Expand(handler.node)
            handler.show_popup()

    def OnNewTestCase(self, event):
        handler = self._controller.get_handler()
        if handler:
            handler.OnNewTestCase(event)

    def OnDrop(self, target, dragged):
        dragged = self._controller.get_handler(dragged)
        target = self._controller.get_handler(target)
        if target and target.accepts_drag(dragged):
            dragged.controller.execute(MoveTo(target.controller))
        else:
            self.Refresh()

    def IsValidDragItem(self, item):
        return self._controller.get_handler(item).is_draggable

    def OnMoveUp(self, event):
        handler = self._controller.get_handler()
        if handler.is_draggable:
            handler.OnMoveUp(event)

    def OnMoveDown(self, event):
        handler = self._controller.get_handler()
        if handler.is_draggable:
            handler.OnMoveDown(event)

    def _item_changed(self, data):
        controller = data.item
        node = self._controller.find_node_by_controller(controller)
        if node:
            self.SetItemText(node, data.item.name)
            self._test_selection_controller.send_selection_changed_message()
        if controller.dirty:
            self._controller.mark_node_dirty(self._get_datafile_node(controller.datafile))

    def _variable_moved_up(self, data):
        if self._should_update_variable_positions(data):
            self._do_action_if_datafile_node_is_expanded(self.move_up, data)

    def _variable_moved_down(self, data):
        if self._should_update_variable_positions(data):
            self._do_action_if_datafile_node_is_expanded(self.move_down, data)

    def _should_update_variable_positions(self, message):
        return message.item != message.other and message.item.has_data() and message.other.has_data()

    def _do_action_if_datafile_node_is_expanded(self, action, data):
        if self.IsExpanded(self._get_datafile_node(data.item.datafile)):
            node = self._controller.find_node_by_controller(data.item)
            action(node)

    def _variable_updated(self, data):
        self._item_changed(data)

    def highlight(self, data, text):
        self.select_node_by_data(data)
        self._editor.highlight(text)

    def node_is_resource_file(self, node):
        return self._controller.get_handler(node).__class__ == ResourceFileHandler


class TreeLabelEditListener(object):

    def __init__(self, tree, action_registerer):
        self._tree = tree
        tree.Bind(wx.EVT_TREE_BEGIN_LABEL_EDIT, self.OnBeginLabelEdit)
        tree.Bind(wx.EVT_TREE_END_LABEL_EDIT, self.OnLabelEdited)
        tree.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        if IS_WINDOWS:
            #Delete key does not work in windows without registration
            action_registerer.register_shortcut(ActionInfo(None, None, action=self.OnDelete, shortcut='Del'))
        self._editing_label = False
        self._on_label_edit_called = False

    def OnBeginLabelEdit(self, event):
        #See http://code.google.com/p/robotframework-ride/issues/detail?id=756
        self._editing_label = True
        if not self._on_label_edit_called:
            self.OnLabelEdit()
            event.Veto() # On windows CustomTreeCtrl will create Editor component
            # And we want this to be done by the handler -- as it knows if there should be one or not
            # And because this will make it work the same way as when pressing F2
            # .. so in other words there is a bug if we don't Veto this event

    def OnLabelEdit(self, event=None):
        if not self._on_label_edit_called:
            self._on_label_edit_called = True
            handler = self._tree._controller.get_handler()
            if handler and not handler.begin_label_edit():
                    self._on_label_edit_called = False
                    self._editing_label = False

    def OnLabelEdited(self, event):
        self._editing_label = False
        self._on_label_edit_called = False
        self._tree._controller.get_handler(event.GetItem()).end_label_edit(event)
        # Reset edit control as it doesn't seem to reset it in case the focus goes directly
        # away from the tree control
        # Use CallAfter to prevent messing up the current end label edit
        # .. and the another CallAfter because of
        # customtreectrl.TreeTextCtrl#OnChar will call CallAfter(self.Finish) when Enter is pressed
        # --> Results in PyDeadObject if called after ResetEditControl..
        wx.CallAfter(wx.CallAfter, self._stop_editing)

    def _stop_editing(self):
        control = self._tree.GetEditControl()
        if control:
            control.StopEditing()

    def OnDelete(self, event):
        editor = self._tree.GetEditControl()
        if editor and wx.Window.FindFocus() == editor:
            start, end = editor.GetSelection()
            editor.Remove(start, max(end, start+1))

    def OnLeftDown(self, event):
        #See http://code.google.com/p/robotframework-ride/issues/detail?id=756
        if IS_WINDOWS and self._editing_label:
            # This method works only on Windows, luckily the issue 756 exists
            # only on Windows
            self._tree.OnCancelEdit(self._tree.GetSelection())
        event.Skip()

    def _get_handler(self, item=None):
        return self._tree._get_handler(item)


########NEW FILE########
__FILENAME__ = treenodehandlers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

from robotide.controller.commands import (RenameKeywordOccurrences, RemoveMacro,
    AddKeyword, AddTestCase, RenameTest, CopyMacroAs, AddVariable,
    UpdateVariableName, RenameFile, RenameResourceFile, DeleteFile, SortKeywords, Include, Exclude)
from robotide.controller.settingcontrollers import VariableController
from robotide.controller.macrocontrollers import (TestCaseController,
                                                  UserKeywordController)
from robotide.controller.filecontrollers import (TestDataDirectoryController,
    ResourceFileController, TestCaseFileController, ExcludedDirectoryController, DirtyRobotDataException)
from robotide.editor.editordialogs import (TestCaseNameDialog,
    UserKeywordNameDialog, ScalarVariableDialog, ListVariableDialog,
    CopyUserKeywordDialog)
from robotide.publish import RideOpenVariableDialog
from robotide.ui.progress import LoadProgressObserver
from robotide.usages.UsageRunner import Usages, ResourceFileUsages
from .filedialogs import (AddSuiteDialog, AddDirectoryDialog, ChangeFormatDialog, NewResourceDialog, AddResourceDialog)
from robotide.utils import overrides
from robotide.widgets import PopupMenuItems
from .progress import RenameProgressObserver
from .resourcedialogs import ResourceRenameDialog, ResourceDeleteDialog
from robotide.ui.resourcedialogs import FolderDeleteDialog

def action_handler_class(controller):
    return {TestDataDirectoryController:TestDataDirectoryHandler,
         ResourceFileController:ResourceFileHandler,
         TestCaseFileController:TestCaseFileHandler,
         TestCaseController:TestCaseHandler,
         UserKeywordController:UserKeywordHandler,
         VariableController:VariableHandler,
         ExcludedDirectoryController:ExcludedDirectoryHandler
     }[controller.__class__]

class _ActionHandler(wx.Window):
    is_user_keyword = False
    is_test_suite = False
    is_variable = False

    _label_add_suite = 'New Suite\tCtrl-Shift-F'
    _label_add_directory = 'New Directory'
    _label_new_test_case = 'New Test Case\tCtrl-Shift-T'
    _label_new_user_keyword = 'New User Keyword\tCtrl-Shift-K'
    _label_sort_keywords = 'Sort Keywords'
    _label_new_scalar = 'New Scalar\tCtrl-Shift-V'
    _label_new_list_variable = 'New List Variable\tCtrl-Shift-L'
    _label_change_format = 'Change Format'
    _label_copy_macro = 'Copy\tCtrl-Shift-C'
    _label_rename = 'Rename\tF2'
    _label_add_resource = 'Add Resource'
    _label_new_resource = 'New Resource'
    _label_find_usages = 'Find Usages'
    _label_select_all = 'Select All Tests'
    _label_deselect_all = 'Deselect All Tests'
    _label_select_failed_tests = 'Select Only Failed Tests'
    _label_select_passed_tests = 'Select Only Passed Tests'
    _label_delete = 'Delete\tCtrl-Shift-D'
    _label_delete_no_kbsc = 'Delete'
    _label_exclude = 'Exclude'
    _label_include = 'Include'
    _label_expand_all = 'Expand all'
    _label_collapse_all = 'Collapse all'

    def __init__(self, controller, tree, node, settings):
        wx.Window.__init__(self, tree)
        self.controller = controller
        self._tree = tree
        self._node = node
        self._settings = settings
        self._rendered = False
        self.Show(False)
        self._popup_creator = tree._popup_creator

    @property
    def item(self):
        return self.controller.data

    @property
    def node(self):
        return self._node

    def show_popup(self):
        self._popup_creator.show(self, PopupMenuItems(self, self._actions),
                                 self.controller)
    def begin_label_edit(self):
        return False

    def double_clicked(self):
        pass

    def end_label_edit(self, event):
        pass

    def OnDelete(self, event):
        pass

    def OnNewSuite(self, event):
        pass

    def OnNewDirectory(self, event):
        pass

    def OnNewResource(self, event):
        pass

    def OnNewUserKeyword(self, event):
        pass

    def OnNewTestCase(self, event):
        pass

    def OnNewScalar(self, event):
        pass

    def OnNewListVariable(self, event):
        pass

    def OnCopy(self, event):
        pass

    def OnFindUsages(self, event):
        pass

    def OnSelectAllTests(self, event):
        self._tree.SelectAllTests(self._node)

    def OnDeselectAllTests(self, event):
        self._tree.DeselectAllTests(self._node)

    def OnSelectOnlyFailedTests(self, event):
        self._tree.SelectFailedTests(self._node)

    def OnSelectOnlyPassedTests(self, event):
        self._tree.SelectPassedTests(self._node)

    def OnSafeDelete(self, event):
        pass

    def OnExclude(self, event):
        pass

    def OnInclude(self, event):
        pass


class _CanBeRenamed(object):

    def OnRename(self, event):
        self._tree.label_editor.OnLabelEdit()

    def begin_label_edit(self):
        def label_edit():
            #FIXME: yep.yep.yep.yep.yep
            node = self._tree._controller.find_node_by_controller(self.controller)
            if node:
                self._tree.EditLabel(node)
        # Must handle pending events before label edit
        # This is a fix for situations where there is a pending action
        # that will change this label (Text Editor all changing actions)
        wx.CallAfter(label_edit)
        return True

    def end_label_edit(self, event):
        if not event.IsEditCancelled():
            if self._is_valid_rename(event.GetLabel()):
                self.rename(event.GetLabel())
            else:
                event.Veto()

    def _is_valid_rename(self, label):
        validation = self.controller.validate_name(label)
        if validation.error_message:
            self._show_validation_error(validation.error_message)
            return False
        return True

    def _show_validation_error(self, err_msg):
        wx.MessageBox(err_msg, 'Validation Error', style=wx.ICON_ERROR)


class DirectoryHandler(_ActionHandler):
    is_draggable = False
    is_test_suite = False
    can_be_rendered = False
    _actions = [_ActionHandler._label_new_resource]

    def OnNewResource(self, event):
        NewResourceDialog(self.controller, self._settings).execute()


class TestDataHandler(_ActionHandler):
    accepts_drag = lambda self, dragged: (isinstance(dragged, UserKeywordHandler) or
                                          isinstance(dragged, VariableHandler))

    is_draggable = False
    is_test_suite = True

    @property
    def tests(self):
        return self.controller.tests

    @property
    def keywords(self):
        return self.controller.keywords

    @property
    def variables(self):
        return self.controller.variables

    def has_been_modified_on_disk(self):
        return self.item.has_been_modified_on_disk()

    def do_drop(self, item):
        self.controller.add_test_or_keyword(item)

    def rename(self, new_name):
        return False

    def OnSortKeywords(self, event):
        """Sorts the keywords inside the treenode"""
        self.controller.execute(SortKeywords())

    @property
    def can_be_rendered(self):
        if not self._has_children():
            return False
        return not self._rendered

    def _has_children(self):
        return (self.item.keyword_table or self.item.testcase_table or
                self.item.variable_table)

    def set_rendered(self):
        self._rendered = True

    def OnChangeFormat(self, event):
        ChangeFormatDialog(self.controller).execute()

    def OnNewUserKeyword(self, event):
        dlg = UserKeywordNameDialog(self.controller)
        if dlg.ShowModal() == wx.ID_OK:
            self.controller.execute(AddKeyword(dlg.get_name(), dlg.get_args()))
        dlg.Destroy()

    def OnNewScalar(self, event):
        self._new_var(ScalarVariableDialog)

    def OnNewListVariable(self, event):
        class FakePlugin(object):
            global_settings = self._settings
        self._new_var(ListVariableDialog, plugin=FakePlugin())

    def _new_var(self, dialog_class, plugin=None):
        dlg = dialog_class(self._var_controller, plugin=plugin)
        if dlg.ShowModal() == wx.ID_OK:
            name, value = dlg.get_value()
            comment = dlg.get_comment()
            self.controller.execute(AddVariable(name, value, comment))

    @property
    def _var_controller(self):
        return self.controller.datafile_controller.variables


class TestDataDirectoryHandler(TestDataHandler):

    def __init__(self, *args):
        TestDataHandler.__init__(self, *args)
        self._actions = [
            _ActionHandler._label_add_suite,
            _ActionHandler._label_add_directory,
            _ActionHandler._label_new_resource,
            '---',
            _ActionHandler._label_new_user_keyword,
            _ActionHandler._label_new_scalar,
            _ActionHandler._label_new_list_variable,
            '---',
            _ActionHandler._label_change_format
        ]
        if self.controller.parent:
            self._actions.extend([_ActionHandler._label_delete_no_kbsc])

        self._actions.extend([
            '---',
            _ActionHandler._label_select_all,
            _ActionHandler._label_deselect_all,
            _ActionHandler._label_select_failed_tests,
            _ActionHandler._label_select_passed_tests
        ])
        if self.controller.parent:
            self._actions.extend(['---',
                                  _ActionHandler._label_exclude])
        self._actions.extend(['---',
                              _ActionHandler._label_expand_all,
                              _ActionHandler._label_collapse_all])

    def OnExpandAll(self, event):
        self._tree.ExpandAllSubNodes(self._node)

    def OnCollapseAll(self, event):
        self._tree.CollapseAllSubNodes(self._node)

    def OnNewSuite(self, event):
        AddSuiteDialog(self.controller, self._settings).execute()

    def OnNewDirectory(self, event):
        AddDirectoryDialog(self.controller, self._settings).execute()

    def OnNewResource(self, event):
        NewResourceDialog(self.controller, self._settings).execute()

    def OnDelete(self, event):
        FolderDeleteDialog(self.controller).execute()

    def OnExclude(self, event):
        try:
            self.controller.execute(Exclude())
        except DirtyRobotDataException:
            wx.MessageBox('Directory contains unsaved data!\n'
                          'You must save data before excluding.')


class _FileHandlerThanCanBeRenamed(_CanBeRenamed):

    @overrides(_CanBeRenamed)
    def begin_label_edit(self):
        self._old_label = self._node.GetText()
        self._set_node_label(self.controller.basename)
        return _CanBeRenamed.begin_label_edit(self)

    @overrides(_CanBeRenamed)
    def end_label_edit(self, event):
        if not event.IsEditCancelled():
            result = self.controller.execute(self._rename_command(event.GetLabel()))
            if result:
                self._rename_ok_handler()
                self._old_label = self.controller.basename
            else:
                event.Veto()
        else:
            self._set_node_label(self._old_label)

    def _rename_ok_handler(self):
        pass

    def _rename_command(self, label):
        raise NotImplementedError(self.__class__)

    def _set_node_label(self, label):
        self._tree.SetItemText(self._node, label)


class ResourceFileHandler(_FileHandlerThanCanBeRenamed, TestDataHandler):
    is_test_suite = False
    _actions = [_ActionHandler._label_new_user_keyword,
                _ActionHandler._label_new_scalar,
                _ActionHandler._label_new_list_variable, '---',
                _ActionHandler._label_rename,
                _ActionHandler._label_change_format,
                _ActionHandler._label_sort_keywords,
                _ActionHandler._label_find_usages,
                _ActionHandler._label_delete]

    def OnFindUsages(self, event):
        ResourceFileUsages(self.controller, self._tree.highlight).show()

    def OnDelete(self, event):
        ResourceDeleteDialog(self.controller).execute()

    def OnSafeDelete(self, event):
        return self.OnDelete(event)

    @overrides(_FileHandlerThanCanBeRenamed)
    def _rename_command(self, label):
        return RenameResourceFile(label, self._check_should_rename_static_imports)

    def _check_should_rename_static_imports(self):
        return ResourceRenameDialog(self.controller).execute()


class TestCaseFileHandler(_FileHandlerThanCanBeRenamed, TestDataHandler):
    accepts_drag = lambda *args: True
    _actions = [_ActionHandler._label_new_test_case,
                _ActionHandler._label_new_user_keyword,
                _ActionHandler._label_new_scalar,
                _ActionHandler._label_new_list_variable, '---',
                _ActionHandler._label_rename,
                _ActionHandler._label_change_format,
                _ActionHandler._label_sort_keywords,
                _ActionHandler._label_delete,
                '---',
                _ActionHandler._label_select_all,
                _ActionHandler._label_deselect_all,
                _ActionHandler._label_select_failed_tests,
                _ActionHandler._label_select_passed_tests
                ]

    def OnNewTestCase(self, event):
        dlg = TestCaseNameDialog(self.controller)
        if dlg.ShowModal() == wx.ID_OK:
            self.controller.execute(AddTestCase(dlg.get_name()))
        dlg.Destroy()

    def OnDelete(self, event):
        if wx.MessageBox('Delete test case file', caption='Confirm',
                         style=wx.YES_NO | wx.ICON_QUESTION) == wx.YES:
            self.controller.execute(DeleteFile())

    def OnSafeDelete(self, event):
        return self.OnDelete(event)

    @overrides(_FileHandlerThanCanBeRenamed)
    def _rename_command(self, label):
        return RenameFile(label)

    @overrides(_FileHandlerThanCanBeRenamed)
    def _rename_ok_handler(self):
        self._tree.DeselectAllTests(self._node)


class _TestOrUserKeywordHandler(_CanBeRenamed, _ActionHandler):
    accepts_drag = lambda *args: False
    is_draggable = True
    _actions = [_ActionHandler._label_copy_macro, 'Move Up\tCtrl-Up', 'Move Down\tCtrl-Down',
                _ActionHandler._label_rename, '---', 'Delete']

    def remove(self):
        self.controller.delete()

    def rename(self, new_name):
        self.controller.execute(self._create_rename_command(new_name))

    def OnCopy(self, event):
        dlg = self._copy_name_dialog_class(self.controller, self.item)
        if dlg.ShowModal() == wx.ID_OK:
            self.controller.execute(CopyMacroAs(dlg.get_name()))
        dlg.Destroy()

    def OnMoveUp(self, event):
        if self.controller.move_up():
            self._tree.move_up(self._node)

    def OnMoveDown(self, event):
        if self.controller.move_down():
            self._tree.move_down(self._node)

    def OnDelete(self, event):
        self.controller.execute(RemoveMacro(self.controller))


class TestCaseHandler(_TestOrUserKeywordHandler):
    _datalist = property(lambda self: self.item.datalist)
    _copy_name_dialog_class = TestCaseNameDialog

    def _add_copy_to_tree(self, parent_node, copied):
        self._tree.add_test(parent_node, copied)

    def _create_rename_command(self, new_name):
        return RenameTest(new_name)


class UserKeywordHandler(_TestOrUserKeywordHandler):
    is_user_keyword = True
    _datalist = property(lambda self: self.item.datalist)
    _copy_name_dialog_class = CopyUserKeywordDialog
    _actions = _TestOrUserKeywordHandler._actions + [_ActionHandler._label_find_usages]

    def _add_copy_to_tree(self, parent_node, copied):
        self._tree.add_keyword(parent_node, copied)

    def _create_rename_command(self, new_name):
        return RenameKeywordOccurrences(self.controller.name, new_name,
                                        RenameProgressObserver(self.GetParent().GetParent()),
                                        self.controller.info)

    def OnFindUsages(self, event):
        Usages(self.controller, self._tree.highlight).show()


class VariableHandler(_CanBeRenamed, _ActionHandler):
    accepts_drag = lambda *args: False
    is_draggable = True
    is_variable = True
    OnMoveUp = OnMoveDown = lambda *args: None
    _actions = [_ActionHandler._label_rename, 'Delete']

    @overrides(_ActionHandler)
    def double_clicked(self):
        RideOpenVariableDialog(controller=self.controller).publish()

    def OnDelete(self, event):
        self.remove()

    def remove(self):
        self.controller.delete()

    def rename(self, new_name):
        self.controller.execute(UpdateVariableName(new_name))

    @property
    def index(self):
        return self.controller.index


class ResourceRootHandler(_ActionHandler):
    can_be_rendered = is_draggable = is_user_keyword = is_test_suite = False
    rename = lambda self, new_name: False
    accepts_drag = lambda self, dragged: False
    _actions = [_ActionHandler._label_add_resource]

    @property
    def item(self):
        return None

    def OnAddResource(self, event):
        path = AddResourceDialog(self, self.controller).execute()
        if path:
            self.controller.load_resource(path, LoadProgressObserver(self))


class ExcludedDirectoryHandler(TestDataDirectoryHandler):
    is_draggable = False
    is_test_suite = True

    def __init__(self, *args):
        TestDataHandler.__init__(self, *args)
        self._actions = [_ActionHandler._label_include]

    def OnInclude(self, event):
        self.controller.execute(Include())

########NEW FILE########
__FILENAME__ = commands
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import os

from robotide.controller.commands import FindOccurrences, _Command, FindVariableOccurrences
from robotide.controller.macrocontrollers import KeywordNameController


class FindUsages(FindOccurrences):

    def execute(self, context):
        prev = None
        for occ in FindOccurrences.execute(self, context):
            if isinstance(occ.item, KeywordNameController):
                continue
            if prev == occ:
                prev.count += 1
            else:
                if prev:
                    yield prev
                prev = occ
        if prev:
            yield prev


class FindVariableUsages(FindVariableOccurrences):
    
    def execute(self, context):
        prev = None
        for occ in FindVariableOccurrences.execute(self, context):
            if prev == occ:
                prev.count += 1
            else:
                if prev:
                    yield prev
                prev = occ
        if prev:
            yield prev


class FindResourceUsages(_Command):

    def execute(self, context):
        for imp in context.get_where_used():
            yield ResourceUsage(context, imp)


class FindTestFolderUsages(_Command):

    def execute(self, context):
        for imp in context.get_where_used():
            yield ResourceUsage(*imp)


class ResourceUsage(object):

    def __init__(self, resource, imp):
        self.res_name = resource.name
        self.res_src = resource.source
        user = imp.datafile_controller
        self.location = user.filename
        self.name = user.display_name
        self.item = user.imports
        self.parent = user
        self.can_be_renamed = imp.contains_filename(os.path.basename(resource.filename))

########NEW FILE########
__FILENAME__ = UsageRunner
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.usages.commands import FindUsages, FindResourceUsages, FindVariableUsages
from robotide.usages.usagesdialog import UsagesDialog, UsagesDialogWithUserKwNavigation, ResourceImportUsageDialog
from threading import Thread
import wx
import time

class Usages(object):

    def __init__(self, controller, highlight, name=None, kw_info=None):
        self._name = name or controller.name
        self._kw_info = kw_info
        self._controller = controller
        self._highlight = highlight
        self._dlg = self._usages_dialog()
        self._worker = Thread(target=self._run)
        self._dialog_closed = False

    def _usages_dialog(self):
        if self._controller.name == self._name:
            return UsagesDialogWithUserKwNavigation(self._name, self._highlight, self._controller)
        return UsagesDialog(self._name)

    def show(self):
        self._dlg.add_selection_listener(self._highlight)
        self._dlg.Bind(wx.EVT_CLOSE, self._stop)
        self._dlg.Show()
        self._worker.start()

    def _run(self):
        wx.CallAfter(self._begin_search)
        for usage in self._find_usages():
            time.sleep(0) # GIVE SPACE TO OTHER THREADS -- Thread.yield in Java
            if self._dialog_closed: return
            wx.CallAfter(self._add_usage, usage)
        wx.CallAfter(self._end_search)

    def _find_usages(self):
        return self._controller.execute(FindUsages(self._name, self._kw_info))

    def _begin_search(self):
        if not self._dialog_closed:
            self._dlg.begin_searching()

    def _add_usage(self, usage):
        if not self._dialog_closed:
            self._dlg.add_usage(usage)

    def _end_search(self):
        if not self._dialog_closed:
            self._dlg.end_searching()

    def _stop(self, event):
        self._dialog_closed = True
        event.Skip()


class ResourceFileUsages(Usages):

    def __init__(self, controller, highlight):
        Usages.__init__(self, controller, highlight)

    def _usages_dialog(self):
        return ResourceImportUsageDialog(self._controller.display_name,
                                         self._highlight,
                                         self._controller)

    def _find_usages(self):
        return self._controller.execute(FindResourceUsages())


class VariableUsages(Usages):

    def _find_usages(self):
        return self._controller.execute(FindVariableUsages(self._name))

########NEW FILE########
__FILENAME__ = usagesdialog
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from robotide.ui.searchdots import DottedSearch

from robotide.widgets import (Dialog, VirtualList, VerticalSizer, ImageList,
                              ImageProvider, ButtonWithHandler)
import wx
from robotide.widgets.list import ListModel

class UsagesDialog(Dialog):

    def __init__(self, name, usages=None):
        self._name = name
        self._selection_listeners = []
        title = "'%s'" % (name)
        Dialog.__init__(self, title=title, size=(650, 400))
        self.SetSizer(VerticalSizer())
        self._add_view_components()
        self.usages = usages or UsagesListModel([])
        self.usage_list = VirtualList(self, self.usages.headers,
                                      self.usages)
        self.usage_list.add_selection_listener(self._usage_selected)
        self.Sizer.add_expanding(self.usage_list)

    def add_usage(self, usage):
        self.usages.add_usage(usage)

    def begin_searching(self):
        self._dots = DottedSearch(self, self._update_searching)
        self._dots.start()

    def _update_searching(self, dots):
        self.SetTitle("'%s' - %d matches found - Searching%s" % (self._name, self.usages.total_usages, dots))
        self.usage_list.refresh()

    def end_searching(self):
        self._dots.stop()
        self.SetTitle("'%s' - %d matches" % (self._name, self.usages.total_usages))
        self.usage_list.refresh()

    def _usage_selected(self, idx):
        for listener in self._selection_listeners:
            listener(self.usages.usage(idx).item.parent, self._name)

    def add_selection_listener(self, listener):
        self._selection_listeners.append(listener)

    def _add_view_components(self):
        pass


class UsagesDialogWithUserKwNavigation(UsagesDialog):

    def __init__(self, name, highlight, controller, usages=None):
        self.OnGotodefinition = lambda evt: highlight(controller, name)
        UsagesDialog.__init__(self, name, usages=usages)

    def _add_view_components(self):
        self.Sizer.Add(ButtonWithHandler(self, 'Go to definition'), 0, wx.ALL, 3)


def ResourceImportUsageDialog(name, highlight, controller):
    return UsagesDialogWithUserKwNavigation(name, highlight, controller, usages=ResourceImportListModel([]))


class _UsagesListModel(ListModel):

    def __init__(self, usages):
        self._usages = usages
        self._create_image_list()

    def _create_image_list(self):
        images = ImageList(16, 16)
        provider = ImageProvider()
        images.add(provider.TESTCASEIMG)
        images.add(provider.KEYWORDIMG)
        images.add(provider.DATAFILEIMG)
        images.add(provider.DATADIRIMG)
        self._images = images

    @property
    def images(self):
        return self._images

    def image(self, item):
        # TODO: better mechanism for item type recognition
        parent_type = self._usages[item].parent.__class__.__name__
        return {'TestCaseController': 0,
                'UserKeywordController': 1,
                'TestCaseFileController': 2,
                'ResourceFileController': 2,
                'TestDataDirectoryController': 3}.get(parent_type, -1)

    def add_usage(self, usage):
        self._usages.append(usage)

    def usage(self, idx):
        return self._usages[idx]

    @property
    def total_usages(self):
        return sum(u.count for u in self._usages)

    @property
    def count(self):
        return len(self._usages)


class UsagesListModel(_UsagesListModel):

    def __init__(self, usages):
        _UsagesListModel.__init__(self, usages)
        self.headers = ['Location', 'Usage', 'Source']

    def item_text(self, row, col):
        u = self.usage(row)
        return [u.location,  u.usage, u.source][col]


class ResourceImportListModel(_UsagesListModel):

    def __init__(self, usages):
        _UsagesListModel.__init__(self, usages)
        self.headers = ['Name', 'Location']
        self._cannot_rename_item_attr = wx.ListItemAttr()
        self._cannot_rename_item_attr.SetBackgroundColour(wx.Colour(255, 64, 64))

    def item_text(self, row, col):
        u = self.usage(row)
        return [u.name, u.location][col]

    def item_attributes(self, idx):
        if self._usages[idx].can_be_renamed:
            return None
        return self._cannot_rename_item_attr

    @property
    def total_usages(self):
        return len(self._usages)


class RecursiveResourceImportListModel(_UsagesListModel):

    def __init__(self, usages):
        _UsagesListModel.__init__(self, usages)
        self.headers = ['Imported name', 'Imported Location', 'Importing Name', 'Importing Location']

    def item_text(self, row, col):
        u = self.usage(row)
        return [u.res_name, u.res_src, u.name, u.location][col]

########NEW FILE########
__FILENAME__ = eventhandler
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

class eventhandlertype(type):
    def __new__(cls, name, bases, dict):
        def mod_time_wrapper(method):
            def wrapped(self, event=None):
                if self._can_be_edited(event):
                    method(self, event)
            return wrapped
        for attr in dict:
            if (attr.startswith('On') and
                    not (name == 'RideFrame' and attr == 'OnClose') and
                    not (name == 'Tree' and attr == 'OnDrop') and
                    not (name == 'KeywordEditor' and attr == 'OnIdle') and
                    not (attr == 'OnEnterWindow' or attr == 'OnLeaveWindow' or attr == 'OnDisplayMotion')):
                dict[attr] = mod_time_wrapper(dict[attr])
        return type.__new__(cls, name, bases, dict)


class RideEventHandler(object):
    __metaclass__ = eventhandlertype
    _SHOWING_MODIFIED_ON_DISK_CONTROLLERS_ = set()
    _SHOWING_REMOVED_ON_DISK_CONTROLLERS_ = set()

    def _can_be_edited(self, event):
        ctrl = self.get_selected_datafile_controller()
        if ctrl and ctrl.has_been_removed_from_disk():
            return self._show_removed_from_disk_warning(ctrl, event)
        if ctrl and ctrl.has_been_modified_on_disk():
            return self._show_modified_on_disk_warning(ctrl, event)
        return True

    def _show_removed_from_disk_warning(self, ctrl, event):
        msg = ['The file has been removed from the file system.',
               'Do you want to remove it from the project?',
               'Answering <No> will rewrite the file on disk.']
        self._execute_if_not_in_the_set(RideEventHandler._SHOWING_REMOVED_ON_DISK_CONTROLLERS_, ctrl, msg, ctrl.remove)

    #TODO: Not a very good mechanism to control the number of shown dialogs
    def _show_modified_on_disk_warning(self, ctrl, event):
        def reload_datafile():
            ctrl.reload()
            self.refresh_datafile(ctrl, event)
        msg = ['The file has been changed on the file system.',
               'Do you want to reload the file?',
               'Answering <No> will overwrite the changes on disk.']
        self._execute_if_not_in_the_set(RideEventHandler._SHOWING_MODIFIED_ON_DISK_CONTROLLERS_, ctrl, msg, reload_datafile)

    def _execute_if_not_in_the_set(self, the_set, ctrl, msg, yes_handler):
        if ctrl in the_set:
            return
        the_set.add(ctrl)
        wx.CallLater(100, self._try_show_warning, the_set, ctrl, msg, yes_handler)

    def _try_show_warning(self, the_set, ctrl, msg, yes_handler):
        try:
            self._show_warning(msg, ctrl, yes_handler)
        finally:
            the_set.remove(ctrl)

    def _show_warning(self, msg_lines, ctrl, yes_handler):
        if ctrl.dirty:
            msg_lines.insert(2, 'Answering <Yes> will discard unsaved changes.')
        msg_lines.extend(['', 'Changed file is:', ctrl.datafile.source])
        ret = wx.MessageBox('\n'.join(msg_lines), 'File Changed On Disk',
                            style=wx.YES_NO|wx.ICON_WARNING)
        if ret == wx.NO:
            from robotide.controller.commands import SaveFile
            ctrl.execute(SaveFile())
            return True
        if ret == wx.YES:
            yes_handler()
        return False

    def get_selected_datafile_controller(self):
        raise NotImplementedError(self.__class__.__name__)

########NEW FILE########
__FILENAME__ = highlightmatcher
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


from robotide.utils import normalize, get_variable_basename, find_variable_basenames


def highlight_matcher(value, content):
    if not value or not content:
        return False
    selection = normalize(value, ignore=['_'])
    if not selection:
        return False
    target = normalize(content, ignore=['_'])
    if not target:
        return False
    if selection == target:
        return True
    return _variable_matches(selection, target)

def _variable_matches(selection, target):
    variable = get_variable_basename(selection)
    if not variable:
        return False
    variables = find_variable_basenames(target)
    if variable in variables:
        return True
    return _list_variable_used_as_scalar(variable, variables)

def _list_variable_used_as_scalar(variable, variables):
    return '$%s' % variable[1:] in variables

########NEW FILE########
__FILENAME__ = printing
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from wx.html import HtmlEasyPrinting


class Printing(HtmlEasyPrinting):

    def __init__(self, parent):
        HtmlEasyPrinting.__init__(self, parentWindow=parent)

    def GetHtmlText(self,text):
        text = text.replace('\t', '&nbsp;&nbsp;&nbsp;&nbsp;')
        text = text.replace(' ', '&nbsp;')
        text = text.replace('\n\n','<p>')
        text = text.replace('\n', '<br>')
        return text

    def preview_text(self, text):
        if not '<html>' in text:
            text = self.GetHtmlText(text)
        HtmlEasyPrinting.PreviewText(self, text)

########NEW FILE########
__FILENAME__ = variablematcher
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import re
from robot.utils import matches

_VAR_BODY = r'([^\}]|\\\})*'
_SCALAR_VARIABLE_MATCHER = re.compile(r'\$\{'+_VAR_BODY+'\}')
_SCALAR_VARIABLE_LINE_MATCHER = re.compile(r'^(\$\{'+_VAR_BODY+'\}) *=?$')
_LIST_VARIABLE_MATCHER = re.compile(r'^(@\{'+_VAR_BODY+'\})( ?=?|\[\d*\])$')
_LIST_VARIABLE_SUBITEM_END_MATCHER = re.compile(r'\[\d+\]\s*(=\s*)?$')

def is_variable(value):
    return is_scalar_variable(value) or is_list_variable(value)

def is_scalar_variable(value):
    return _match_scalar_variable(value)

def _match_scalar_variable(value):
    return _SCALAR_VARIABLE_LINE_MATCHER.match(value.strip())

def is_list_variable(value):
    return _match_list_variable(value)

def is_list_variable_subitem(value):
    return is_list_variable(value) and _LIST_VARIABLE_SUBITEM_END_MATCHER.search(value)

def _match_list_variable(value):
    return _LIST_VARIABLE_MATCHER.match(value.strip())

def get_variable(value):
    """Returns variables name without equal sign '=' and indexing '[2]' or None"""
    match = is_variable(value)
    return match.groups()[0] if match else None

def get_variable_basename(value):
    "Return variable without extended variable syntax part"
    if is_list_variable(value):
        return get_variable(value)
    match = re.match('\${(.+?)[^\s\w-]+.*?}?', value)
    if not match:
        return None
    return '${%s}' % (match.groups()[0].strip())

def find_variable_basenames(value):
    return [get_variable_basename(var) for var in re.findall('[\@\$]{.*?}', value)]

def contains_scalar_variable(value):
    return bool(_SCALAR_VARIABLE_MATCHER.findall(value))

def value_contains_variable(value, varname):
    return matches(value, "*%s*" % varname)

########NEW FILE########
__FILENAME__ = versioncomparator
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import re


def cmp_versions(version1, version2):
    if version1 == version2:
        return 0
    if version1 is None:
        return -1
    if version2 is None:
        return 1
    l1 = _version_string_to_list(version1)
    l2 = _version_string_to_list(version2)
    d = len(l1) - len(l2)
    if d > 0:
        l2 += ['' for _ in range(d)]
    if d < 0:
        l1 += ['' for _ in range(-d)]
    return cmp(l1, l2)

_PREVIEW_VERSION = re.compile(r'(\d+)(\.\d+)*(a|b|rc)(\d*)$')
_PREVIEW_PREFERENCE = {'a':-3, 'b':-2, 'rc':-1}

def _version_string_to_list(version_string):
    if version_string == 'trunk':
        return [-100]
    version_list = version_string.split('.')
    if _PREVIEW_VERSION.match(version_string):
        m = _PREVIEW_VERSION.match(version_list[-1])
        version_list[-1] = m.group(1)
        version_list += [_PREVIEW_PREFERENCE[m.group(3)]]
        version_list += [m.group(4)]
    return _strip_leading_zeros(version_list)

def _strip_leading_zeros(version_list):
    while version_list and version_list[-1] == '0':
        version_list.pop()
    return version_list

########NEW FILE########
__FILENAME__ = version
# Automatically generated by `pavement.py`.
VERSION = '1.2.3'

########NEW FILE########
__FILENAME__ = button
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx


class ButtonWithHandler(wx.Button):

    def __init__(self, parent, label, handler=None, width=-1,
                 height=25):
        wx.Button.__init__(self, parent, label=label,
                           size=(width, height))
        if not handler:
            handler = getattr(parent, 'On'+label.replace(' ', ''))
        parent.Bind(wx.EVT_BUTTON, handler, self)

########NEW FILE########
__FILENAME__ = dialog
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

class Dialog(wx.Dialog):

    def __init__(self, title='', parent=None, size=None, style=None):
        parent = parent or wx.GetTopLevelWindows()[0]
        size = size or (-1, -1)
        # wx.THICK_FRAME allows resizing
        style = style or wx.DEFAULT_DIALOG_STYLE | wx.THICK_FRAME
        wx.Dialog.__init__(self, parent, title=title, size=size, style=style)
        self.CenterOnParent()

    def _create_buttons(self, sizer):
        buttons = self.CreateStdDialogButtonSizer(wx.OK|wx.CANCEL)
        sizer.Add(buttons, flag=wx.ALIGN_CENTER|wx.ALL, border=5)

    def _create_horizontal_line(self, sizer):
        line = wx.StaticLine(self, size=(20,-1), style=wx.LI_HORIZONTAL)
        sizer.Add(line, flag=wx.GROW|wx.ALIGN_CENTER_VERTICAL|wx.RIGHT|wx.TOP,
                  border=5)

    def execute(self):
        retval = None
        if self.ShowModal() == wx.ID_OK:
            retval = self._execute()
        self.Destroy()
        return retval

    def _execute(self):
        raise NotImplementedError(self.__class__.__name__)

########NEW FILE########
__FILENAME__ = font
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx


class Font(object):
    help = property(lambda self: self._get_font(scale=-2))
    fixed = property(lambda self: self._get_font(family=wx.FONTFAMILY_MODERN))
    fixed_log = property(lambda self:
            self._get_font(scale=-2, family=wx.FONTFAMILY_MODERN))
    underlined = property(lambda self: self._get_font(underlined=True))

    def _get_font(self, scale=0, family=wx.FONTFAMILY_DEFAULT, underlined=False):
        size = wx.SystemSettings.GetFont(wx.SYS_SYSTEM_FONT).GetPointSize()
        return wx.Font(size + scale, family, wx.FONTWEIGHT_NORMAL,
                       wx.FONTSTYLE_NORMAL, underline=underlined)

########NEW FILE########
__FILENAME__ = htmlwindow
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import webbrowser
import wx
from wx import html


class HtmlWindow(html.HtmlWindow):

    def __init__(self, parent, size=wx.DefaultSize, text=None):
        html.HtmlWindow.__init__(self, parent, size=size)
        self.SetBorders(2)
        self.SetStandardFonts(size=9)
        if text:
            self.SetPage(text)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)

    def OnKeyDown(self, event):
        if self._is_copy(event):
            self._add_selection_to_clipboard()
        self.Parent.OnKey(event)
        event.Skip()

    def _is_copy(self, event):
        return event.GetKeyCode() == ord('C') and event.CmdDown()

    def _add_selection_to_clipboard(self):
        wx.TheClipboard.Open()
        wx.TheClipboard.SetData(wx.TextDataObject(self.SelectionToText()))
        wx.TheClipboard.Close()

    def OnLinkClicked(self, link):
        webbrowser.open(link.Href)

    def close(self):
        self.Show(False)

    def clear(self):
        self.SetPage('')


########NEW FILE########
__FILENAME__ = images
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx
import os


class ImageList(wx.ImageList):

    def __init__(self, img_width, img_height):
        wx.ImageList.__init__(self, img_width, img_height)

    def add(self, image):
        self.Add(image)


class ImageProvider(object):
    _BASE = os.path.dirname(__file__)

    def __init__(self, size=(16, 16)):
        self._size = size
        self.TESTCASEIMG = self._load_image('robot.png')
        self.KEYWORDIMG = self._load_image('process.png')
        self.DATADIRIMG = self._img_from_art_provider(wx.ART_FOLDER)
        self.DATAFILEIMG = self._img_from_art_provider(wx.ART_NORMAL_FILE)
        self.PROGICONS = self._load_prog_icons()
        self.REPORTIMG = self._load_image('report.png')
        self.REFRESH_ALL = self._load_image('database_refresh.png')
        self.KW_SEARCH_ICON = self._load_image('kw_search_button.png')
        self.TEST_SEARCH_ICON = self._load_image('test_search_button.png')
        self.TOOLBAR_PLAY = self._load_image('control_play.png')
        self.TOOLBAR_STOP = self._load_image('control_stop.png')
        self.TOOLBAR_PAUSE = self._load_image('control_pause.png')
        self.TOOLBAR_CONTINUE = self._load_image('control_play.png')
        self.TOOLBAR_NEXT = self._load_image('control_fastforward.png')
        self.SWITCH_FIELDS_ICON = self._load_image('switch.png')
        self._build_icons()

    def _build_icons(self):
        self._icons = {}
        for name in dir(self):
            value = getattr(self, name)
            if isinstance(value, wx.Bitmap):
                self._icons[name] = getattr(self, name)

    def get_image_by_name(self, name):
        return self._icons.get(name, None)

    def _load_image(self, name):
        path = self._get_img_path(name)
        return wx.Image(path, wx.BITMAP_TYPE_PNG).ConvertToBitmap()

    def _get_img_path(self, name):
        return os.path.join(self._BASE, name)

    def _img_from_art_provider(self, source):
        return wx.ArtProvider_GetBitmap(source, wx.ART_OTHER, self._size)

    def _load_prog_icons(self):
        icons = wx.IconBundle()
        icons.AddIconFromFile(self._get_img_path('robot.ico'),
                             wx.BITMAP_TYPE_ANY)
        return icons

########NEW FILE########
__FILENAME__ = label
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx

from .font import Font


class Label(wx.StaticText):

    def __init__(self, parent, id=-1, label='', **args):
        wx.StaticText.__init__(self, parent=parent, id=id, label=label.replace('&', '&&'), **args)

    def SetLabel(self, label):
        wx.StaticText.SetLabel(self, label.replace('&', '&&'))


class HeaderLabel(Label):

    def __init__(self, parent, label):
        Label.__init__(self, parent, label=label)
        self.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD))


class HelpLabel(Label):

    def __init__(self, parent, label):
        Label.__init__(self, parent, label=label)
        self.SetFont(Font().help)

########NEW FILE########
__FILENAME__ = list
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import wx
from wx.lib.mixins.listctrl import ListCtrlAutoWidthMixin

IS_WINDOWS = os.sep == '\\'


class VirtualList(wx.ListCtrl, ListCtrlAutoWidthMixin):
    _style = wx.LC_REPORT|wx.LC_SINGLE_SEL|wx.LC_HRULES|wx.LC_VIRTUAL

    def __init__(self, parent, headers, model):
        wx.ListCtrl.__init__(self, parent, style=self._style)
        ListCtrlAutoWidthMixin.__init__(self)
        self._model = model
        self._selection_listeners = []
        self._create_headers(headers)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnListItemSelected)
        if IS_WINDOWS:
            self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.SetItemCount(model.count)
        self.SetImageList(model.images, wx.IMAGE_LIST_SMALL)

    def OnLeftDown(self, event):
        item, flags =  self.HitTest(event.Position)
        if flags | wx.LIST_HITTEST_ONITEM:
            wx.CallAfter(self._inform_listeners, item)
        event.Skip()

    def _create_headers(self, headers):
        for idx, name in enumerate(headers):
            self.InsertColumn(idx, name)
        self.SetColumnWidth(0, 200)
        self.SetColumnWidth(1, 160)

    def refresh(self):
        self.SetItemCount(self._model.count)
        self.SetImageList(self._model.images, wx.IMAGE_LIST_SMALL)

    def add_selection_listener(self, listener):
        self._selection_listeners.append(listener)

    def OnListItemSelected(self, event):
        self._inform_listeners(event.Index)

    def _inform_listeners(self, selected_index):
        for listener in self._selection_listeners:
            listener(selected_index)

    def OnGetItemText(self, row, col):
        return self._model.item_text(row, col)

    def OnGetItemImage(self, item):
        return self._model.image(item)

    def OnGetItemAttr(self, item):
        return self._model.item_attributes(item)


class ListModel(object):

    @property
    def count(self):
        return 0

    @property
    def images(self):
        return None

    def item_text(self, row, col):
        return ''

    def image(self, row):
        return None

    def item_attributes(self, row):
        return None


########NEW FILE########
__FILENAME__ = popupmenu
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx


class PopupCreator(object):

    def __init__(self):
        self._external_hooks = []

    def add_hook(self, hook):
        self._external_hooks.append(hook)

    def remove_hook(self, hook):
        self._external_hooks.remove(hook)

    def _get_all_actions(self, fixed_menu_items, data):
        menu_items = fixed_menu_items
        external_items = self._get_external_menu_items(data)
        if external_items:
            menu_items.add_separator()
            for item in external_items:
                menu_items.add_menu_item(item)
        return menu_items

    def _get_external_menu_items(self, data):
        menu_items = []
        for hook in self._external_hooks:
            menu_items.extend(hook(data))
        return menu_items

    def show(self, parent, fixed_menu_items, data):
        PopupMenu(parent, self._get_all_actions(fixed_menu_items, data))


class PopupMenu(wx.Menu):

    def __init__(self, parent, menu_items):
        wx.Menu.__init__(self)
        for item in menu_items:
            if item.is_separator():
                self.AppendSeparator()
            else:
                self._add_item(parent, item)
        parent.PopupMenu(self)
        self.Destroy()

    def _add_item(self, parent, item):
        id_ = wx.NewId()
        self.Append(id_, item.name)
        parent.Bind(wx.EVT_MENU, item.callable, id=id_)


class PopupMenuItems(object):

    def __init__(self, parent=None, menu_names=[]):
        self._items = []
        for item in menu_names:
            self.add_menu_item(PopupMenuItem(item, parent=parent))

    def __iter__(self):
        return iter(self._items)

    def add_menu_item(self, item):
        self._items.append(item)

    def add_separator(self):
        self.add_menu_item(PopupMenuItem('---'))


class PopupMenuItem(object):

    def __init__(self, name, callable=None, parent=None):
        self.name = name
        self.callable = self._get_callable(name, callable, parent)

    def _get_callable(self, name, callable, parent):
        if callable:
            return callable
        if name == '---':
            return None
        handler_name = ''.join(x for x in name.split('\t')[0].title() if not x.isspace())
        return getattr(parent, 'On'+handler_name)

    def is_separator(self):
        return self.name == '---'



########NEW FILE########
__FILENAME__ = sizers
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx


class _BoxSizer(wx.BoxSizer):

    def __init__(self):
        wx.BoxSizer.__init__(self, self.direction)

    def add(self, component, proportion=0, flag=0):
        self.Add(component, proportion=proportion, flag=flag)

    def add_with_padding(self, component, padding=5):
        self.Add(component, flag=wx.ALL, border=padding)

    def add_expanding(self, component, propotion=1):
        self.Add(component, proportion=propotion, flag=wx.EXPAND)


class VerticalSizer(_BoxSizer):
    direction = wx.VERTICAL


class HorizontalSizer(_BoxSizer):
    direction = wx.HORIZONTAL

    def add_to_end(self, component):
        self.Add(component, flag=wx.ALIGN_RIGHT)


########NEW FILE########
__FILENAME__ = text
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import wx


class TextField(wx.TextCtrl):

    def __init__(self, parent, initial_value, process_enters=False):
        flags = wx.TE_PROCESS_ENTER if process_enters else 0
        wx.TextCtrl.__init__(self, parent, style=flags)
        self.SetValue(initial_value)

########NEW FILE########
__FILENAME__ = test_action_dsl
import unittest

from robotide.action.actioninfo import ActionInfoCollection
from robot.utils.asserts import assert_equals
from robotide.context.platform import IS_MAC


def _check_mac(value, expected, expected_mac):
    if IS_MAC:
        assert_equals(value, expected_mac)
    else:
        assert_equals(value, expected)


class HandlerMock(object):

    def __init__(self, **handlers):
        self.handlers = handlers

    def __getattr__(self, name):
        return self.handlers[name]


class TestActionInfoCollection(unittest.TestCase):

    def test_create_entry(self):
        data = """ [File]
        Save | Save current suite or resource | Ctrl-S
        Huba | HubaBuba
        """
        handlers = HandlerMock(OnSave='save action', OnHuba='huba action')
        infos = ActionInfoCollection(data, handlers)
        assert_equals(infos[0].menu_name, 'File')
        assert_equals(infos[0].name, 'Save')
        assert_equals(infos[0].action, 'save action')
        assert_equals(infos[0].shortcut.value, 'Ctrl-S')
        _check_mac(infos[0].shortcut.printable, u'Ctrl-S', u'\u2303S')

        assert_equals(infos[1].menu_name, 'File')
        assert_equals(infos[1].name, 'Huba')
        assert_equals(infos[1].action, 'huba action')
        assert_equals(infos[1].shortcut.value, None)

    def test_create_entry_with_multi_shortcut(self):
        data = """ [Hopla]
        Huba (Alt-D or CtrlCmd-H) | HubaBuba
        """
        handlers = HandlerMock(OnHuba='huba action')
        infos = ActionInfoCollection(data, handlers)
        assert_equals(infos[0].menu_name, 'Hopla')
        _check_mac(infos[0].name, u'Huba  (Alt-D or Ctrl-H)', u'Huba  (\u2325D or \u2318H)')
        assert_equals(infos[0].action, 'huba action')
        assert_equals(infos[0].shortcut.value, None)


if __name__ == "__main__":
    unittest.main()
########NEW FILE########
__FILENAME__ = test_shortcut
#  Copyright 2008 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest 

from robotide.action.shortcut import Shortcut
from robotide.context import ctrl_or_cmd
# wx needs to imported last so that robotide can select correct wx version.
import wx


class TestShortcutParsing(unittest.TestCase):

    def test_single_character(self):
        self._test([('A', (wx.ACCEL_NORMAL, 65)),
                    ('a', (wx.ACCEL_NORMAL, 65)),
                    ('R', (wx.ACCEL_NORMAL, 82))])

    def test_single_key(self):
        self._test([('Insert', (wx.ACCEL_NORMAL, wx.WXK_INSERT)),
                    ('DEL', (wx.ACCEL_NORMAL, wx.WXK_DELETE)),
                    ('DeLeTE', (wx.ACCEL_NORMAL, wx.WXK_DELETE))])

    def test_control_key(self):
        self._test([('Ctrl-A', (wx.ACCEL_CTRL, 65)),
                    ('Shift-DEL', (wx.ACCEL_SHIFT, wx.WXK_DELETE)),
                    ('Alt-DELETE', (wx.ACCEL_ALT, wx.WXK_DELETE))])

    def test_two_control_keys(self):
        self._test([('Ctrl-Alt-A', (wx.ACCEL_CTRL+wx.ACCEL_ALT, 65)),
                    ('Shift-Ctrl-DEL', (wx.ACCEL_SHIFT+wx.ACCEL_CTRL, wx.WXK_DELETE)),
                    ('Alt-Cmd-DELETE', (wx.ACCEL_ALT+wx.ACCEL_CMD, wx.WXK_DELETE))])

    def test_ctrlcmd(self):
        self._test([('Ctrlcmd-Alt-A', (ctrl_or_cmd()+wx.ACCEL_ALT, 65))])

    def test_invalid_shortcut(self):
        self.assertRaises(ValueError, Shortcut('InvaLid').parse)

    def _test(self, data):
        for shortcut, expected in data:
            self.assertEquals(Shortcut(shortcut).parse(), expected)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = .#invalidmodule
Some invalid content


########NEW FILE########
__FILENAME__ = also_plugins
from robotide.pluginapi import Plugin


class ExamplePlugin3(Plugin):

    def __init__(self, application):
        Plugin.__init__(self, application)

########NEW FILE########
__FILENAME__ = not_plugin
# This sits in the plugin directory but is not a plugin.
# This exists to test that such a thing won't cause the 
# plugin manager to throw an exception.

########NEW FILE########
__FILENAME__ = plugin_module
from robotide.pluginapi import Plugin


class ExamplePlugin1(Plugin):

    def __init__(self, application):
        Plugin.__init__(self, application)


class ExamplePlugin2(Plugin):

    def __init__(self, application):
        Plugin.__init__(self, application)

    def turn_off(self, name):
        self._get_plugin_by_name(name).disable()

    def _get_plugin_by_name(self, name):
        for p in self.get_plugins():
            if p.name == name:
                return p
        return None

########NEW FILE########
__FILENAME__ = test_editor_provider
import unittest

from robot.utils.asserts import assert_equals, assert_raises

from robotide.application.editorprovider import EditorProvider


class TestObject(object): pass
class TestEditor(object): pass
class TestEditor2(object): pass


class TestEditorProvide(unittest.TestCase):

    def setUp(self):
        self.p = EditorProvider()
        self.p.register_editor(TestObject, TestEditor)

    def test_registering(self):
        assert_equals(self.p.get_editor(TestObject), TestEditor)
        self.p.register_editor(TestObject, TestEditor2)
        assert_equals(self.p.get_editor(TestObject), TestEditor2)

    def test_setting_deafult_editor(self):
        self.p.register_editor(TestObject, TestEditor2, default=False)
        assert_equals(self.p.get_editor(TestObject), TestEditor)

    def test_getting_when_none_registered(self):
        self.p.unregister_editor(TestObject, TestEditor)
        assert_raises(IndexError, self.p.get_editor, TestObject)

    def test_unregistering(self):
        self.p.register_editor(TestObject, TestEditor2)
        self.p.unregister_editor(TestObject, TestEditor2)
        assert_equals(self.p.get_editor(TestObject), TestEditor)

    def test_get_editors(self):
        self.p.register_editor(TestObject, TestEditor2)
        assert_equals(self.p.get_editors(TestObject), [TestEditor, TestEditor2])

    def test_registering_twice_does_nothing(self):
        self.p.register_editor(TestObject, TestEditor)
        assert_equals(self.p.get_editors(TestObject), [TestEditor])

    def test_activating(self):
        self.p.register_editor(TestObject, TestEditor2, default=False)
        self.p.set_active_editor(TestObject, TestEditor2)
        assert_equals(self.p.get_editor(TestObject), TestEditor2)


########NEW FILE########
__FILENAME__ = test_plugin_loading
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import unittest
from robot.utils.asserts import assert_true, assert_false

import robotide.context
from robotide import utils
class _Log(object):
    def __init__(self):
        self.log = ''
    def error(self, msg):
        self.log += msg

LOGGER = _Log()
robotide.context.LOG = LOGGER


from robotide.application.pluginloader import PluginLoader
from robotide.log import LogPlugin

from resources import FakeApplication, FakeSettings

robotide.application.pluginconnector.SETTINGS = FakeSettings()


class TestPluginLoader(unittest.TestCase):
    used_plugin_class = LogPlugin
    expected_plugins = ['Example Plugin 1', 'Example Plugin 2',
                        'Example Plugin 3', utils.name_from_class(used_plugin_class, drop='Plugin')]

    def setUp(self):
        plugins_dir = [os.path.join(os.path.dirname(__file__), 'plugins_for_loader')]
        app = FakeApplication()
        self.loader = PluginLoader(app, plugins_dir, [self.used_plugin_class])
        app.get_plugins = lambda: self.loader.plugins

    def tearDown(self):
        for p in self.loader.plugins:
            p.disable()

    def test_plugin_loading(self):
        for name in self.expected_plugins:
            self._assert_plugin_loaded(name)
        assert_false(LOGGER.log)

    def _assert_plugin_loaded(self, name):
        for p in self.loader.plugins:
            if p.name == name:
                return
        raise AssertionError("Plugin '%s' not loaded" % name)

    def test_plugins_are_not_enabled_when_loaded(self):
        for p in self.loader.plugins:
            assert_false(p.enabled)

    def test_plugins_can_be_enabled(self):
        self.loader.enable_plugins()
        for p in self.loader.plugins:
            assert_true(p.enabled, 'Plugin %s was not enabled' % p.name)

    def test_plugins_can_disable_other_plugins(self):
        self.loader.enable_plugins()
        self._get_plugin_by_name('Example Plugin 2')._plugin.turn_off('Example Plugin 1')
        assert_false(self._get_plugin_by_name('Example Plugin 1').enabled)

    def _get_plugin_by_name(self, name):
        for p in self.loader.plugins:
            if p.name == name:
                return p
        return None


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_robot_patches
from robot.parsing.settings import Timeout, Tags, Fixture, Template
from robot.utils.asserts import assert_equals
import robotide
import unittest


class Test(unittest.TestCase):

    def test_timeout_patch(self):
        timeout = Timeout('Timeout')
        assert_equals(timeout.as_list(),['Timeout'])
        timeout.message='boo'
        assert_equals(timeout.as_list(),['Timeout', '', 'boo'])
        timeout.message=''
        timeout.value='1 second'
        assert_equals(timeout.as_list(),['Timeout', '1 second'])
        timeout.message='boo'
        assert_equals(timeout.as_list(),['Timeout', '1 second', 'boo'])

    def test_settings_patch(self):
        tags = Tags('Tags')
        assert_equals(tags.as_list(),['Tags'])
        tags.value = ['tag1','tag2']
        assert_equals(tags.as_list(),['Tags', 'tag1', 'tag2'])

    def test_fixture_patch(self):
        fixture = Fixture('Teardown')
        assert_equals(fixture.as_list(), ['Teardown'])
        fixture.name = 'Keyword'
        assert_equals(fixture.as_list(), ['Teardown', 'Keyword'])
        fixture.args = ['arg1', 'arg2']
        assert_equals(fixture.as_list(), ['Teardown', 'Keyword', 'arg1', 'arg2'])
        fixture.name = ''
        assert_equals(fixture.as_list(), ['Teardown', '', 'arg1', 'arg2'])

    def test_template_patch(self):
        template = Template('Template')
        assert_equals(template.as_list(),['Template'])
        template.value = 'value'
        assert_equals(template.as_list(),['Template', 'value'])


if __name__ == "__main__":
    unittest.main()
########NEW FILE########
__FILENAME__ = test_updatenotifier
import unittest
import time
import urllib2
from robotide.application.updatenotifier import UpdateNotifierController


class UpdateNotifierTestCase(unittest.TestCase):

    def setUp(self):
        self._callback_called = False
        self._version = None
        self._url = None

    def _callback(self, version, url, settings):
        self.assertFalse(self._callback_called)
        self._callback_called = True
        self.assertNotEqual(None, version)
        self._version = version
        self.assertNotEqual(None, url)
        self._url = url
        self.assertEqual(dict, type(settings))

    def _update_notifier_controller(self, settings, current, new, url='some url'):
        ctrl = UpdateNotifierController(settings)
        ctrl.VERSION = current
        ctrl._get_newest_version = lambda: new
        ctrl._get_download_url   = lambda v: url if v == new else None
        return ctrl

    def _settings(self, check_for_updates=True, last_update_check=time.time()-60*60*24*7):
        return {'check for updates': check_for_updates,
                'last update check': last_update_check}

    def test_normal_update(self):
        settings = self._settings()
        ctrl = self._update_notifier_controller(settings, '0', '1', 'http://xyz.abc.efg.di')
        ctrl.notify_update_if_needed(self._callback)
        self.assertEqual('1', self._version)
        self.assertEqual('http://xyz.abc.efg.di', self._url)
        self.assertTrue(self._callback_called)
        self.assertTrue(settings['check for updates'])
        self.assertTrue(settings['last update check'] > time.time() - 1)

    def test_update_when_trunk_version(self):
        settings = self._settings()
        ctrl = self._update_notifier_controller(settings, 'trunk', '0.56')
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(self._callback_called)
        self.assertEqual('0.56', self._version)
        self.assertTrue(settings['check for updates'])
        self.assertTrue(settings['last update check'] > time.time() - 1)

    def test_last_update_done_less_than_a_week_ago(self):
        original_time = time.time()-60*60*24*3
        settings = self._settings(last_update_check=original_time)
        ctrl = UpdateNotifierController(settings)
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['check for updates'])
        self.assertEqual(original_time, settings['last update check'])
        self.assertFalse(self._callback_called)

    def test_check_for_updates_is_false(self):
        settings = self._settings(check_for_updates=False)
        original_time = settings['last update check']
        ctrl = UpdateNotifierController(settings)
        ctrl.notify_update_if_needed(self._callback)
        self.assertFalse(settings['check for updates'])
        self.assertEqual(original_time, settings['last update check'])
        self.assertFalse(self._callback_called)

    def test_no_update_found(self):
        settings = self._settings()
        ctrl = self._update_notifier_controller(settings, '0.55', '0.55')
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertFalse(self._callback_called)

    def test_first_run_sets_settings_correctly_and_checks_for_updates(self):
        settings = self._settings(check_for_updates=None, last_update_check=None)
        ctrl = self._update_notifier_controller(settings, '1.0.2', '1.0.2')
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertTrue(settings['check for updates'])
        self.assertFalse(self._callback_called)

    def test_first_run_sets_settings_correctly_and_finds_an_update(self):
        settings = self._settings(check_for_updates=None, last_update_check=None)
        ctrl = self._update_notifier_controller(settings, '1.2', '2.0')
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertTrue(settings['check for updates'])
        self.assertTrue(self._callback_called)

    def test_checking_timeouts(self):
        settings = self._settings()
        ctrl = UpdateNotifierController(settings)
        def throwTimeoutError():
            raise urllib2.URLError('timeout')
        ctrl._get_newest_version = throwTimeoutError
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertFalse(self._callback_called)

    def test_download_url_checking_timeouts(self):
        settings = self._settings()
        ctrl = UpdateNotifierController(settings)
        ctrl.VERSION = '0'
        ctrl._get_newest_version = lambda: '1'
        def throwTimeoutError(*args):
            raise urllib2.URLError('timeout')
        ctrl._get_download_url = throwTimeoutError
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertFalse(self._callback_called)

    def test_server_returns_no_versions(self):
        settings = self._settings()
        ctrl = self._update_notifier_controller(settings, '1.2.2', None)
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertTrue(settings['check for updates'])
        self.assertFalse(self._callback_called)

    def test_server_returns_older_version(self):
        settings = self._settings()
        ctrl = self._update_notifier_controller(settings, '0.44', '0.43.1')
        ctrl.notify_update_if_needed(self._callback)
        self.assertTrue(settings['last update check'] > time.time() - 1)
        self.assertTrue(settings['check for updates'])
        self.assertFalse(self._callback_called)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_command_creation
import os
import unittest
from robot.output import LEVELS
from robotide.contrib.testrunner.testrunner import TestRunner
from robotide.contrib.testrunner.testrunnerplugin import TestRunnerPlugin

class CommandCreator(TestRunner):

    def _get_listener_to_cmd(self):
        return 'listener'

    def _write_argfile(self, argfile, args):
        self.arguments = args

class CommandCreationTestCase(unittest.TestCase):

    def test_command(self):
        fakechief = lambda:0
        fakechief.suite = lambda:0
        fakechief.suite.source = 'source'
        creator = CommandCreator(fakechief)
        creator._output_dir = 'temppi'
        command = creator.get_command(self._create_profile(), ['PYTHON', 'PATH'], 7, [('suite', 'suite.test')])
        self.assertEqual(command,
            ['prefix', '--argumentfile', os.path.join('temppi','argfile.txt'),
             '--listener', 'listener', os.path.abspath('source')])
        self.assertEqual(creator.arguments,
            ['custom', 'args',
             '--outputdir', 'temppi',
             '--pythonpath', 'PYTHON:PATH',
             '--monitorcolors', 'off',
             '--monitorwidth', 7,
             '--suite', 'suite',
             '--test', 'suite.test'])

    def _create_profile(self):
        p = lambda:0
        p.get_command_prefix = lambda: ['prefix']
        p.get_custom_args = lambda: ['custom', 'args']
        return p

    def test_min_log_level_settings(self):
        self._min_log_level_setting_test(['-L', 'warn'], 'WARN')
        self._min_log_level_setting_test(['--loglevel', 'debug'], 'DEBUG')
        self._min_log_level_setting_test(['prefix'], 'INFO')
        self._min_log_level_setting_test(['-L', 'obscure'], 'INFO')
        self._min_log_level_setting_test(['--loglevel', 'WARN:TRACE'], 'WARN')


    def _min_log_level_setting_test(self, command_as_list, expected_level):
        creator = CommandCreator(None)
        self.assertEquals(creator.get_message_log_level(command_as_list), LEVELS[expected_level])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_debugger
from contextlib import contextmanager
import threading
import unittest
import time
from robotide.contrib.testrunner.TestRunnerAgent import RobotDebugger

class TestDebugger(unittest.TestCase):

    def setUp(self):
        self._debugger = RobotDebugger()

    def test_pausing_and_resuming(self):
        self.assertFalse(self._debugger.is_paused())
        self._debugger.pause()
        self.assertTrue(self._debugger.is_paused())
        self._debugger.resume()
        self.assertFalse(self._debugger.is_paused())

    def test_is_breakpoint(self):
        self.assertTrue(self._debugger.is_breakpoint('BuiltIn.Comment', {'args':['PAUSE']}))
        self.assertFalse(self._debugger.is_breakpoint('BuiltIn.Log', {'args':['PAUSE']}))
        self.assertFalse(self._debugger.is_breakpoint('BuiltIn.Comment', {'args':['Something']}))
        self.assertFalse(self._debugger.is_breakpoint('Foo', {'args':[]}))

    def test_step_next(self):
        self._debugger.pause()
        started = threading.Event()
        first_keyword_done = threading.Event()
        second_keyword_done = threading.Event()
        third_keyword_done = threading.Event()
        wait_for_step_next_before_entering_debugger = threading.Event()

        def test_execution():
            started.set()
            with self.kw():
                first_keyword_done.set()
                wait_for_step_next_before_entering_debugger.wait()
                with self.kw():
                    second_keyword_done.set()
            with self.kw():
                third_keyword_done.set()

        with self.execution(test_execution):
            self._verify_done(started)
            self.assertFalse(first_keyword_done.isSet())
            self._debugger.step_next()
            self._verify_done(first_keyword_done)
            self.assertFalse(second_keyword_done.isSet())
            self._debugger.step_next()
            wait_for_step_next_before_entering_debugger.set()
            self._verify_done(second_keyword_done)
            self.assertFalse(third_keyword_done.isSet())
            self._debugger.step_next()
            self._verify_done(third_keyword_done)


    def _verify_done(self, event):
        self.assertTrue(event.wait(timeout=10.0) or event.isSet())

    @contextmanager
    def kw(self, passes=True):
        self._debugger.start_keyword()
        yield
        self._debugger.end_keyword(passes)

    @contextmanager
    def execution(self, executed):
        t = threading.Thread(target=executed)
        t.setDaemon(True)
        t.start()
        yield
        t.join()

    def test_step_over(self):
        self._debugger.pause()
        started = threading.Event()
        first_keyword_done = threading.Event()
        second_keyword_done = threading.Event()
        third_keyword_done = threading.Event()
        last_keyword_done = threading.Event()

        def test_execution():
            started.set()
            with self.kw():
                first_keyword_done.set()
                with self.kw():
                    with self.kw():
                        pass
                    with self.kw():
                        pass
                    second_keyword_done.set()
                with self.kw():
                    third_keyword_done.set()
            with self.kw():
                last_keyword_done.set()

        with self.execution(test_execution):
            self._verify_done(started)
            self.assertFalse(first_keyword_done.isSet())
            self._debugger.step_next()
            self._verify_done(first_keyword_done)
            self.assertFalse(second_keyword_done.isSet())
            self._debugger.step_over()
            self._verify_done(second_keyword_done)
            self.assertFalse(third_keyword_done.isSet())
            self._debugger.step_over()
            self._verify_done(third_keyword_done)
            self.assertFalse(last_keyword_done.isSet())
            self._debugger.step_over()
            self._verify_done(last_keyword_done)

    def test_pause_on_failure(self):
        self._debugger.pause_on_failure(True)
        before_failure = threading.Event()
        after_failure = threading.Event()

        def test_execution():
            with self.kw():
                pass
            with self.kw():
                pass
            before_failure.set()
            with self.kw(False):
                pass
            with self.kw():
                pass
            after_failure.set()

        with self.execution(test_execution):
            self._verify_done(before_failure)
            self.assertFalse(after_failure.isSet())
            self._debugger.resume()
            time.sleep(0)
            self._verify_done(after_failure)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_process
import unittest
import time
import datafilereader
from robotide.contrib.testrunner.testrunner import Process
from robotide.widgets.list import IS_WINDOWS

class ProcessUnicodeTestCase(unittest.TestCase):

    def test_unicode_command(self):
        try:
            Process(u'\xf6').run_command(u'echo \xf6')
        except UnicodeEncodeError:
            self.fail('Should not throw unicode error')
        except OSError, expected:
            pass

    def test_running_pybot_test(self):
        output, errors = self._run_small_test()
        self.assertTrue(output.replace('\r','').startswith(
        '==============================================================================\n'
        'Small Test                                                                    \n'
        '==============================================================================\n'
        'Small Test.Test                                                               \n'
        '==============================================================================\n'
        'Passing                                                               | PASS |\n'
        '------------------------------------------------------------------------------\n'
        'Failing                                                               | FAIL |\n'
        'this fails\n'
        '------------------------------------------------------------------------------\n'
        'Small Test.Test                                                       | FAIL |\n'
        '2 critical tests, 1 passed, 1 failed\n2 tests total, 1 passed, 1 failed\n'
        '==============================================================================\n'
        'Small Test                                                            | FAIL |\n'
        '2 critical tests, 1 passed, 1 failed\n2 tests total, 1 passed, 1 failed\n'
        '==============================================================================\n'),
        msg=repr(output))
        self.assertEquals(errors.replace('\r', ''), u'[ WARN ] this passes\n')

    def _run_small_test(self):
        p = Process(datafilereader.SMALL_TEST_PATH)
        p.run_command('pybot' + ('.bat' if IS_WINDOWS else '') + ' --output NONE --log NONE --report NONE .')
        max_time = 5.0
        while p.is_alive() and max_time > 0:
            time.sleep(0.1)
            max_time -= 0.1
        if max_time <= 0:
            p.kill()
            raise AssertionError('process did not stop in 5 second time')
        return p.get_output(), p.get_errors()

    def test_stopping_pybot_with_listener_should_generate_outputs(self):
        pass

    def test_stopping_pybot_with_two_kill_signals_should_not_generate_outputs(self):
        pass

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pybot_arguments_validation
import unittest
from robotide.contrib.testrunner.runprofiles import PybotProfile


class TestPybotArgumentsValidation(unittest.TestCase):

    def setUp(self):
        self._profile = PybotProfile(lambda:0)

    def test_invalid_argument(self):
        self.assertNotEqual(None, self._profile._get_invalid_message('--invalidargument'))

    def test_valid_argument_short(self):
        self._working_arguments('-T')

    def _working_arguments(self, args):
        self.assertEqual(None, self._profile._get_invalid_message(args))

    def test_valid_argument_long(self):
        self._working_arguments('--timestampoutputs')

    def test_valid_argument_with_value(self):
        self._working_arguments('--log somelog.html')

    def test_runfailed_argument_works(self):
        self._working_arguments('--runfailed output.xml')

    def test_old_runmode_argument_works(self):
        self._working_arguments('--runmode DryRun')


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = base_command_test
import unittest
import os
from robot.parsing.model import TestCaseFile
from robot.parsing.populators import FromFilePopulator
from robot.utils.asserts import assert_equals

from robotide.publish import PUBLISHER
from robotide.controller.filecontrollers import TestCaseFileController
from robotide.publish.messages import RideItemStepsChanged
from controller.controller_creator import _FakeChief, testcase_controller,\
   BASE_DATA


class TestCaseCommandTest(unittest.TestCase, _FakeChief):

    resource_file_controller_factory = None

    def setUp(self):
        self._steps = None
        self._data = self._create_data()
        self._ctrl = testcase_controller(self, data=self._data)
        PUBLISHER.subscribe(self._test_changed, RideItemStepsChanged)
        self._orig_number_of_steps = len(self._ctrl.steps)
        self._number_of_test_changes = 0

    def tearDown(self):
        if os.path.exists('path'):
            os.removedirs('path')

    def _create_data(self):
        return BASE_DATA[:]

    def save(self, controller):
        self._file_saved = (controller == self._ctrl.datafile_controller)

    def tearDown(self):
        PUBLISHER.unsubscribe(self._test_changed, RideItemStepsChanged)

    def _get_macros(self):
        return [m for m in self._ctrl._parent]

    def _get_macro_by_name(self, name):
        return [m for m in self._get_macros() if m.name == name][0]

    def _data_row(self, line):
        return self._data.index(line)-1

    def _data_step_as_list(self, step_data):
        return step_data.split('  ')[1:]

    def _exec(self, command):
        return self._ctrl.execute(command)

    def _test_changed(self, data):
        self._number_of_test_changes += 1
        self._steps = data.item.steps

    def _verify_step_unchanged(self, step_data):
        row = self._data_row(step_data)
        assert_equals(self._steps[row].as_list(), self._data_step_as_list(step_data))

    def _verify_steps_unchanged(self, *steps):
        for step in steps:
            self._verify_step_unchanged(step)

    def _verify_number_of_test_changes(self, expected):
        assert_equals(self._number_of_test_changes, expected)

    def _verify_row_does_not_exist(self, line):
        for step in self._steps:
            if step.as_list() == self._data_step_as_list(line):
                raise AssertionError('Row "%s" exists' % line)

    def _verify_step_is_empty(self, index):
        assert_equals(self._steps[index].as_list(), [])

    def _verify_step(self, index, exp_name, exp_args=[], exp_comment=None):
        exp = [exp_name] + exp_args
        if exp_comment:
            exp += [exp_comment]
        assert_equals(self._steps[index].as_list(), exp)

    def _verify_step_number_change(self, change):
        assert_equals(len(self._steps), self._orig_number_of_steps + change)

########NEW FILE########
__FILENAME__ = controller_creator
from robot.parsing.model import TestCaseFile, TestDataDirectory
from robot.parsing.populators import FromFilePopulator
from robotide.controller.basecontroller import WithNamespace
from robotide.controller.filecontrollers import TestCaseFileController,\
    TestDataDirectoryController

TEST_NAME = 'Test With two Steps'
STEP1_KEYWORD = 'Step 1'
STEP1 = '  '+STEP1_KEYWORD+'  arg'
STEP2 = '  Step 2  a1  a2  a3'
STEP_WITH_COMMENT = '  Foo  # this is a comment'
FOR_LOOP_HEADER = '  : FOR  ${i}  IN  1  2  3'
FOR_LOOP_STEP1 = '    Log  ${i}'
FOR_LOOP_STEP2 = '    No Operation'
STEP_AFTER_FOR_LOOP = '  Step bar'

BASE_DATA = [TEST_NAME,
        STEP1,
        STEP2,
        STEP_WITH_COMMENT,
        FOR_LOOP_HEADER,
        FOR_LOOP_STEP1,
        FOR_LOOP_STEP2,
        STEP_AFTER_FOR_LOOP,
        '  ${variable}=  some value'
]

class _FakeChief(WithNamespace):

    def update_namespace(self):
        pass

    def register_for_namespace_updates(self, listener):
        pass

    def unregister_namespace_updates(self, listener):
        pass

    resource_file_controller_factory = None

def create(data):
    tcf = TestCaseFile()
    tcf.directory = '/path/to'
    pop = FromFilePopulator(tcf)
    pop.start_table(['Test cases'])
    for row in [ [cell for cell in line.split('  ')] for line in data]:
        pop.add(row)
    pop.eof()
    return tcf


def testcase_controller(chief=None, data=None):
    if data is None:
        data = BASE_DATA[:]
    base_directory_controller = TestDataDirectoryController(TestDataDirectory(), chief)
    directory_controller = TestDataDirectoryController(TestDataDirectory(), chief, base_directory_controller)
    tcf_controller = TestCaseFileController(create(data), chief, directory_controller)
    tctablectrl = tcf_controller.tests
    return tctablectrl[0]

########NEW FILE########
__FILENAME__ = test_all_files_can_be_seen
import unittest
import datafilereader

class TestAllFiles(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.chief = datafilereader.construct_chief_controller(datafilereader.ALL_FILES_PATH)

    @classmethod
    def tearDownClass(cls):
        cls.chief.close()

    def test_all_files_can_be_seen(self):
        all_files = self.chief.data
        self.assertEqual(all_files.name, 'All Files')
        self.assertEqual(len(all_files.suites), 3)
        self._verify_names(all_files, 'Used Resource', 'Unused Resource', 'Resource Dir', 'Suite Dir', 'Suite2 Dir')
        resource_dir = self._get_child(all_files, 'Resource Dir')
        self._verify_names(resource_dir, 'Unused')
        suite_dir = self._get_child(all_files, 'Suite Dir')
        self._verify_names(suite_dir, 'Suite')

    def _get_child(self, controller, name):
        return [c for c in controller.children if c.name == name][0]

    def _verify_names(self, controller, *names):
        self.assertEqual(set(c.name for c in controller.children), set(names))

    def test_unused_resource_knows_it_is_unused(self):
        unused = datafilereader.get_ctrl_by_name('Unused Resource', self.chief.datafiles)
        self.assertFalse(unused.is_used())

    def test_used_resource_knows_it_is_used(self):
        used = datafilereader.get_ctrl_by_name('Used Resource', self.chief.datafiles)
        self.assertTrue(used.is_used())


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_arguments
import unittest
from robotide.controller.arguments import parse_argument,\
    parse_arguments_to_var_dict
from robot.utils.asserts import assert_equals, assert_none


class TestParseArguments(unittest.TestCase):

    def test_parse(self):
        args = ['${my arg}', '${default}=huhuu', '@{list}', 'invalid${}{}{{']
        parsed = parse_arguments_to_var_dict(args, 'Keyword name')
        assert_equals(parsed['${my arg}'], None)
        assert_equals(parsed['${default}'], 'huhuu')
        assert_equals(parsed['@{list}'], None)
        assert_equals(len(parsed.keys()), 3)

    def test_parse_with_no_args(self):
        parsed = parse_arguments_to_var_dict([], 'Keyword name')
        assert_equals(len(parsed.keys()), 0)
 
    def test_embedded_arguments(self):
        parsed = parse_arguments_to_var_dict([], "Here is ${arg} and ${another arg}")
        assert_equals(parsed['${arg}'], None)
        assert_equals(parsed['${another arg}'], None)
        assert_equals(len(parsed.keys()), 2)

    def test_embedded_arguments_with_list_var_syntax(self):
        parsed = parse_arguments_to_var_dict([], "Here is ${arg} and @{list arg}")
        assert_equals(parsed['${arg}'], None)
        assert_equals(len(parsed.keys()), 1)

    def test_embedded_arguments_with_args(self):
        parsed = parse_arguments_to_var_dict(['${my arg}'], "Here is ${arg} and ${another arg}")
        assert_equals(parsed['${my arg}'], None)
        assert_equals(len(parsed.keys()), 1)


class TestArgument(unittest.TestCase):

    def test_simple_argument(self):
        arg = parse_argument('${my arg}')
        assert_equals(arg, ('${my arg}', None))

    def test_list_argument(self):
        arg = parse_argument('@{my arg}')
        assert_equals(arg, ('@{my arg}', None))

    def test_default_value(self):
        arg = parse_argument('${my arg}    = huhuu')
        assert_equals(arg, ('${my arg}', 'huhuu'))

    def test_default_value_with_no_space(self):
        arg = parse_argument('${my arg}=huhuu')
        assert_equals(arg, ('${my arg}', 'huhuu'))

    def test_default_value_with_escaped_sequence(self):
        arg = parse_argument('${my arg}=huh\\}uu')
        assert_equals(arg, ('${my arg}', 'huh\\}uu'))

    def test_invalid_argument(self):
        arg = parse_argument('${my invalid')
        assert_none(arg)


if __name__ == "__main__":
    unittest.main()
########NEW FILE########
__FILENAME__ = test_backup
from __future__ import with_statement

import unittest
from robotide.controller.chiefcontroller import Backup


class BackupTestCase(unittest.TestCase):

    def setUp(self):
        file_controller = lambda:0
        file_controller.filename = 'some_filename.txt'
        file_controller.refresh_stat = lambda:0
        self._backupper = _MyBackup(file_controller)

    def test_backup_is_restored_when_save_raises_exception(self):
        try:
            with self._backupper:
                raise _SaveFailed('expected')
            self.fail('should not get here')
        except _SaveFailed:
            self.assertTrue(self._backupper.restored)

    def test_backup_is_not_restored_when_save_passes(self):
        with self._backupper:
            self.assertNotEqual(None, self._backupper._backup)
            pass
        self.assertFalse(self._backupper.restored)
        self.assertEqual(None, self._backupper._backup)

    def test_save_can_be_done_if_backup_move_fails(self):
        def move_fails(*args):
            raise IOError('failed')
        self._backupper._move = move_fails
        save_done = False
        with self._backupper:
            save_done = True
        self.assertTrue(save_done)


class _SaveFailed(Exception):
    pass


class _MyBackup(Backup):

    def __init__(self, file_controller):
        Backup.__init__(self, file_controller)
        self._backup = object()
        self.restored = False

    def _move(self, from_path, to_path):
        self.restored = (self._backup == from_path)

    def _remove_backup(self):
        self._backup = None

    def _remove_backup_dir(self):
        pass


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_basecontroller
import unittest
from robotide.controller.basecontroller import WithNamespace
from robotide.namespace.namespace import Namespace
from robotide.preferences.settings import Settings

class TestWithNamespace(unittest.TestCase):

    def test_get_all_cached_library_names(self):
        with_namespace = WithNamespace()
        with_namespace._set_namespace(namespace=self._create_namespace())
        print with_namespace.get_all_cached_library_names()

    def _create_namespace(self):
        settings = lambda:0
        settings.get = lambda k, d: d
        settings.add_change_listener = lambda *args:0
        settings.excludes = self._dummy_settings()
        namespace = Namespace(settings=settings)
        return namespace

    def _dummy_settings(self):
        class foo(object):
            def __init__(self):
                self.contains = lambda *args: False
        return foo()


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_cellinfo
import unittest
import datafilereader
from robotide.controller.commands import ChangeCellValue, DeleteRows, AddKeyword,\
    Undo, PasteArea
from robot.utils.asserts import assert_equals, assert_true, assert_false,\
    assert_none
from robotide.controller.cellinfo import CellType, ContentType, CellInfo,\
    CellContent, CellPosition

class TestCellInfoErrors(unittest.TestCase):

    def test_empty_mandatory_is_error(self):
        cell = CellInfo(CellContent(ContentType.EMPTY, '', ''), CellPosition(CellType.MANDATORY, None))
        assert_true(cell.has_error())
        assert_true(cell.argument_missing())

    def test_none_empty_mandatory_is_not_error(self):
        cell = CellInfo(CellContent(ContentType.LIBRARY_KEYWORD, '', ''), CellPosition(CellType.MANDATORY, None))
        assert_false(cell.has_error())
        assert_false(cell.argument_missing())

    def test_commented_mandatory_is_error(self):
        cell = CellInfo(CellContent(ContentType.COMMENTED, '', ''), CellPosition(CellType.MANDATORY, None))
        assert_true(cell.has_error())
        assert_true(cell.argument_missing())

    def test_none_empty_mandatory_empty_is_error(self):
        cell = CellInfo(CellContent(ContentType.STRING, '', ''), CellPosition(CellType.MUST_BE_EMPTY, None))
        assert_true(cell.has_error())
        assert_true(cell.too_many_arguments())

    def test_empty_mandatory_empty_is_not_error(self):
        cell = CellInfo(CellContent(ContentType.EMPTY, '', ''), CellPosition(CellType.MUST_BE_EMPTY, None))
        assert_false(cell.has_error())
        assert_false(cell.too_many_arguments())

    def test_optional_has_no_error(self):
        assert_false(CellInfo(CellContent(ContentType.EMPTY, '', ''), CellPosition(CellType.OPTIONAL, None)).has_error())
        assert_false(CellInfo(CellContent(ContentType.STRING, '', ''), CellPosition(CellType.OPTIONAL, None)).has_error())


class TestCellInfo(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.chief_ctrl = datafilereader.construct_chief_controller(datafilereader.ARGUMENTS_PATH)
        cls.testsuite = datafilereader.get_ctrl_by_name('Suite', cls.chief_ctrl.datafiles)
        cls.test = cls.testsuite.tests[0]
        keyword = lambda name: [kw for kw in cls.testsuite.keywords if kw.name == name][0]
        cls.keyword1 = keyword('KW1')
        cls.keyword2 = keyword('KW2')
        cls.keyword3 = keyword('KW3')
        cls.keyword4 = keyword('KW4')
        cls.keyword5 = keyword('KW5')

    @classmethod
    def tearDownClass(cls):
        cls.chief_ctrl.close()

    def tearDown(self):
        self.test.execute(DeleteRows([i for i in range(len(self.test.steps))]))

    def test_no_cell_info_if_no_data(self):
        assert_none(self.test.get_cell_info(0, 0))
        assert_none(self.test.get_cell_info(0, 1))
        assert_none(self.test.get_cell_info(0, 2))
        assert_none(self.test.get_cell_info(0, 3))

    def test_keyword_with_mandatory_and_optional_arguments(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword1.name))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_string_change(0, 1, CellType.MANDATORY)
        self._verify_string_change(0, 2, CellType.OPTIONAL)
        self._verify_string_change(0, 3, CellType.MUST_BE_EMPTY)

    def test_list_variables_item_in_keyword_args(self):
        self.test.execute(PasteArea((0,0), [[self.keyword5.name, '@{LIST_VARIABLE}[0]']]))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.VARIABLE, CellType.MANDATORY)
        self._verify_cell_info(0, 2, ContentType.EMPTY, CellType.MANDATORY)

    def test_keyword_with_optional_and_list_arguments(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword4.name))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_string_change(0, 1, CellType.OPTIONAL)
        self._verify_string_change(0, 2, CellType.OPTIONAL)
        self._verify_string_change(0, 3, CellType.OPTIONAL)
        self._verify_string_change(0, 4, CellType.OPTIONAL)

    def test_celltype_is_unknown_if_list_var_given(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword1.name))
        self.test.execute(ChangeCellValue(0, 1, '@{vars}'))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.UNKNOWN_VARIABLE, CellType.UNKNOWN)
        self._verify_cell_info(0, 2, ContentType.EMPTY, CellType.UNKNOWN)
        self._verify_cell_info(0, 3, ContentType.EMPTY, CellType.UNKNOWN)

    def test_variable_is_known_when_defining_it(self):
        self.test.execute(ChangeCellValue(0, 0, '${var}='))
        self.test.execute(ChangeCellValue(0, 1, 'Set Variable'))
        self.test.execute(ChangeCellValue(0, 2, '${var}'))
        self._verify_cell_info(0, 0, ContentType.VARIABLE, CellType.ASSIGN)
        self._verify_cell_info(0, 2, ContentType.UNKNOWN_VARIABLE, CellType.OPTIONAL)

    def test_known_extended_variable_syntax(self):
        self.test.execute(ChangeCellValue(0, 0, '${var}='))
        self.test.execute(ChangeCellValue(0, 1, 'Set Variable'))
        self.test.execute(ChangeCellValue(0, 2, 'something'))
        self.test.execute(ChangeCellValue(1, 0, 'log'))
        self.test.execute(ChangeCellValue(1, 2, '${var.lower()}'))
        self.test.execute(ChangeCellValue(2, 0, 'log'))
        self.test.execute(ChangeCellValue(2, 2, '${var+"moi"}'))
        self.test.execute(ChangeCellValue(3, 0, 'log'))
        self.test.execute(ChangeCellValue(3, 2, '${var[1:]}'))
        self._verify_cell_info(1, 2, ContentType.VARIABLE, CellType.OPTIONAL)
        self._verify_cell_info(2, 2, ContentType.VARIABLE, CellType.OPTIONAL)
        self._verify_cell_info(3, 2, ContentType.VARIABLE, CellType.OPTIONAL)

    def test_empty_column_before_string_is_string(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword1.name))
        self.test.execute(ChangeCellValue(0, 2, 'something'))
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.MANDATORY)

    def test_comment(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword1.name))
        self.test.execute(ChangeCellValue(0, 1, '# I have something to say'))
        self.test.execute(ChangeCellValue(0, 2, 'to you my friend'))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.COMMENTED, CellType.MANDATORY)
        self._verify_cell_info(0, 2, ContentType.COMMENTED, CellType.OPTIONAL)

    def test_comment_keyword(self):
        self.test.execute(ChangeCellValue(0, 0, 'I have nothing to say'))
        self.test.execute(ChangeCellValue(0, 1, 'to the void of darkness'))
        self.test.step(0).comment()
        self._verify_cell_info(0, 0, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.COMMENTED, CellType.OPTIONAL)
        self._verify_cell_info(0, 2, ContentType.COMMENTED, CellType.OPTIONAL)
        self._verify_cell_info(0, 3, ContentType.COMMENTED, CellType.OPTIONAL)

    def test_keyword_with_varargs(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword2.name))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_string_change(0, 1, CellType.OPTIONAL)
        self._verify_string_change(0, 2, CellType.OPTIONAL)
        self._verify_string_change(0, 3, CellType.OPTIONAL)

    def test_variable_setting(self):
        self.test.execute(ChangeCellValue(0, 0, '${my cool var}='))
        self._verify_cell_info(0, 0, ContentType.VARIABLE, CellType.ASSIGN)
        self.test.execute(ChangeCellValue(0, 1, 'Set Variable'))
        self._verify_cell_info(0, 1, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)
        self._verify_string_change(0, 2, CellType.OPTIONAL)

    def test_keyword_without_args(self):
        self.test.execute(ChangeCellValue(0, 0, self.keyword3.name))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.EMPTY, CellType.MUST_BE_EMPTY)

    def test_for_loop_in_header(self):
        forlooped_case = self.keyword3
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(0, 1, ContentType.VARIABLE, CellType.ASSIGN, forlooped_case)
        self._verify_cell_info(0, 2, ContentType.STRING, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(0, 3, ContentType.STRING, CellType.OPTIONAL, forlooped_case)
        self._verify_cell_info(0, 4, ContentType.STRING, CellType.OPTIONAL, forlooped_case)
        self._verify_cell_info(0, 5, ContentType.EMPTY, CellType.OPTIONAL, forlooped_case)

    def test_steps_in_for_loop(self):
        forlooped_case = self.keyword3
        self._verify_cell_info(1, 0, ContentType.EMPTY, CellType.MUST_BE_EMPTY, forlooped_case)
        self._verify_cell_info(1, 1, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD, forlooped_case)
        self._verify_cell_info(1, 2, ContentType.STRING, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(2, 0, ContentType.EMPTY, CellType.MUST_BE_EMPTY, forlooped_case)
        self._verify_cell_info(2, 1, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD, forlooped_case)
        self._verify_cell_info(2, 2, ContentType.VARIABLE, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(3, 0, ContentType.EMPTY, CellType.MUST_BE_EMPTY, forlooped_case)
        self._verify_cell_info(3, 1, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD, forlooped_case)
        self._verify_cell_info(3, 2, ContentType.UNKNOWN_VARIABLE, CellType.MANDATORY, forlooped_case)

    def test_for_loop_in_range_header(self):
        forlooped_case = self.keyword3
        in_range_header_index = 4
        self._verify_cell_info(in_range_header_index, 0, ContentType.STRING, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(in_range_header_index, 1, ContentType.VARIABLE, CellType.ASSIGN, forlooped_case)
        self._verify_cell_info(in_range_header_index, 2, ContentType.STRING, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(in_range_header_index, 3, ContentType.STRING, CellType.MANDATORY, forlooped_case)
        self._verify_cell_info(in_range_header_index, 4, ContentType.EMPTY, CellType.OPTIONAL, forlooped_case)
        self._verify_cell_info(in_range_header_index, 5, ContentType.EMPTY, CellType.OPTIONAL, forlooped_case)
        self._verify_cell_info(in_range_header_index, 6, ContentType.EMPTY, CellType.MUST_BE_EMPTY, forlooped_case)

    def test_library_import_add_and_remove(self):
        self.test.execute(PasteArea((0, 0), [['Get File', 'reaktor.txt']]))
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.UNKNOWN)
        self.testsuite.imports.add_library('OperatingSystem', [], '')
        self._verify_cell_info(0, 0, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.MANDATORY)
        self.testsuite.imports.delete(-1)
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.UNKNOWN)

    def test_library_import_with_name_and_arguments(self):
        self.test.execute(ChangeCellValue(0,0, 'alias.Onething'))
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self.testsuite.imports.add_library('libi.py', 'a | b', 'alias')
        self._verify_cell_info(0, 0, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)

    def test_library_import_with_name_and_one_argument(self):
        self.test.execute(ChangeCellValue(0,0, 'alias2.Onething'))
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self.testsuite.imports.add_library('libi.py', '1', 'alias2')
        self._verify_cell_info(0, 0, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)

    def test_library_import_with_name(self):
        self.test.execute(ChangeCellValue(0,0, 'alias3.Onething'))
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self.testsuite.imports.add_library('libi.py', [], 'alias3')
        self._verify_cell_info(0, 0, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)

    def test_library_import_modify(self):
        self.test.execute(PasteArea((0, 0), [['Get File', 'reaktor.txt']]))
        lib = self.testsuite.imports.add_library('WrongOperatingSystem', [], '')
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.UNKNOWN)
        lib.set_value('OperatingSystem', [], '')
        self._verify_cell_info(0, 0, ContentType.LIBRARY_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.MANDATORY)
        self.testsuite.imports.delete(-1)
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.STRING, CellType.UNKNOWN)

    def test_create_and_remove_keyword(self):
        kw_name = 'Super Keyword'
        self.test.execute(ChangeCellValue(0, 0, kw_name))
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self.test.execute(AddKeyword(kw_name, '${argh}'))
        self._verify_cell_info(0, 0, ContentType.USER_KEYWORD, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.EMPTY, CellType.MANDATORY)
        self.test.execute(Undo())
        self._verify_cell_info(0, 0, ContentType.STRING, CellType.KEYWORD)
        self._verify_cell_info(0, 1, ContentType.EMPTY, CellType.UNKNOWN)

    def _verify_string_change(self, row, col, celltype):
        self._verify_cell_info(row, col, ContentType.EMPTY, celltype)
        self.test.execute(ChangeCellValue(row, col, 'diipadaapa'))
        self._verify_cell_info(row, col, ContentType.STRING, celltype)

    def _verify_cell_info(self, row, col, contenttype, celltype, macro=None):
        if macro == None:
            macro = self.test
        cell_info = macro.get_cell_info(row, col)
        assert_equals(cell_info.cell_type, celltype)
        assert_equals(cell_info.content_type, contenttype)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_chiefcontroller
import os
import unittest

from os.path import join as j

from robot.parsing.model import TestDataDirectory, TestCaseFile, ResourceFile
from robot.utils.asserts import assert_true, assert_equals, assert_none

from robotide.controller import ChiefController
from robotide.namespace import Namespace
from robotide.controller.filecontrollers import TestCaseFileController, \
    TestDataDirectoryController, ResourceFileController
from robotide.publish.messages import RideOpenSuite, RideOpenResource

from resources import (COMPLEX_SUITE_PATH, MINIMAL_SUITE_PATH, RESOURCE_PATH,
                       MessageRecordingLoadObserver, SUITEPATH,
                       DATAPATH, RELATIVE_PATH_TO_RESOURCE_FILE,
                       RESOURCE_PATH2, RESOURCE_PATH3, RESOURCE_PATH_TXT,
                       EXTERNAL_RES_UNSORTED_PATH, FakeSettings)
from resources.mocks import PublisherListener
import datafilereader
from robotide.spec.librarymanager import LibraryManager


ALL_RESOURCE_PATH_RELATED_RESOURCE_IMPORTS = [RESOURCE_PATH, RESOURCE_PATH2, RESOURCE_PATH3, RESOURCE_PATH_TXT]


def _library_manager():
    library_manager = LibraryManager(':memory:')
    library_manager.create_database()
    return library_manager

class ChiefControllerTest(unittest.TestCase):

    def setUp(self):
        self._library_manager = _library_manager()
        self.ctrl = ChiefController(Namespace(FakeSettings()), FakeSettings(), self._library_manager)
        self.load_observer = MessageRecordingLoadObserver()
        self.suite_listener = PublisherListener(RideOpenSuite)
        self.resource_listener = PublisherListener(RideOpenResource)

    def tearDown(self):
        self.suite_listener.unsubscribe()
        self.resource_listener.unsubscribe()
        self.ctrl.close()
        self._library_manager.stop()

    def test_loading_suite_at_startup(self):
        self._load(MINIMAL_SUITE_PATH)
        assert_true(self.ctrl._controller is not None)
        self._test_listeners([MINIMAL_SUITE_PATH], [])

    def _test_listeners(self, suite_paths, resource_paths):
        self.assertEqual(self._get_paths(self.suite_listener.data), suite_paths)
        self.assertEqual(self._get_paths(self.resource_listener.data), resource_paths)

    def _get_paths(self, data):
            return [item.path for item in data]

    def test_loading_resource_at_startup(self):
        self._load(RESOURCE_PATH)
        assert_true(self.ctrl.resources != [])
        self._test_listeners([], ALL_RESOURCE_PATH_RELATED_RESOURCE_IMPORTS)

    def test_loading_invalid_data_at_startup(self):
        msg = "Given file 'invalid' is not a valid Robot Framework test case or resource file."
        self.ctrl.load_data('invalid', self.load_observer)
        assert_true(self.load_observer.finished)
        assert_equals(self.load_observer.message, msg)
        self._test_listeners([], [])

    def _load(self, path):
        self.ctrl.load_data(path, self.load_observer)
        assert_true(self.load_observer.notified)
        assert_true(self.load_observer.finished)

    def test_loading_datafile(self):
        data = self.ctrl.load_datafile(MINIMAL_SUITE_PATH, self.load_observer)
        assert_true(self.load_observer.finished)
        assert_true(data is not None)
        self._test_listeners([MINIMAL_SUITE_PATH], [])

    def test_reloading(self):
        self.ctrl.new_file_project(MINIMAL_SUITE_PATH)
        files1 = self.ctrl.datafiles
        self.ctrl.new_file_project(MINIMAL_SUITE_PATH)
        files2 = self.ctrl.datafiles
        assert_true(files1 != files2)

    def test_loading_resource_file(self):
        resource = self.ctrl.load_resource(RESOURCE_PATH, self.load_observer)
        assert_true(self.load_observer.finished)
        assert_true(resource is not None)
        self._test_listeners([], ALL_RESOURCE_PATH_RELATED_RESOURCE_IMPORTS)

    def test_loading_invalid_datafile(self):
        self.ctrl.load_datafile('invalid', self.load_observer)
        assert_equals(self.load_observer.message, "Invalid data file 'invalid'.")
        self._test_listeners([], [])

    def test_loading_invalid_resource(self):
        assert_none(self.ctrl.load_resource('invalid', self.load_observer))
        assert_equals(self.load_observer.message, "Invalid resource file 'invalid'.")
        self._test_listeners([], [])

    def test_dirtyness(self):
        self.ctrl.load_data(COMPLEX_SUITE_PATH, MessageRecordingLoadObserver())
        assert_true(not self.ctrl.is_dirty())
        self.ctrl.data.create_test('newnessness')
        assert_true(self.ctrl.is_dirty())

    def test_load_dirty_controllers(self):
        self.ctrl.load_data(SUITEPATH, MessageRecordingLoadObserver())
        assert_equals(len(self.ctrl._get_all_dirty_controllers()), 0)
        tcf = self._find_suite_by_type(self.ctrl.data.children, TestCaseFileController)
        tcf.create_test('newnessness')
        assert_equals(len(self.ctrl._get_all_dirty_controllers()), 1)
        self.ctrl.data.mark_dirty()
        assert_equals(len(self.ctrl._get_all_dirty_controllers()), 2)
        sub_dir = self._find_suite_by_type(self.ctrl.data.children, TestDataDirectoryController)
        sub_dir_tcf = self._find_suite_by_type(sub_dir.children, TestCaseFileController)
        sub_dir_tcf.create_test('newnessness')
        assert_equals(len(self.ctrl._get_all_dirty_controllers()), 3)

    def _find_suite_by_type(self, suites, type):
        for child in suites:
            if isinstance(child, type):
                return child
        return None

    def test_creating_new_resource(self):
        controller = self.ctrl.new_resource('somepath')
        assert_equals(controller.name, 'Somepath')

    def test_resource_with_same_path_is_not_added_twice(self):
        self.ctrl.new_resource('somepath')
        self.ctrl.new_resource('somepath')
        assert_equals(len(self.ctrl.resources), 1)

    def test_load_data_with_external_resources_all_externals_are_used(self):
        are_used = []
        def handle(message):
            are_used.append(message.datafile.is_used())
        self.resource_listener.outer_listener = handle
        self._load(EXTERNAL_RES_UNSORTED_PATH)
        assert_true(self.ctrl.resources != [])
        res_path = os.path.join(os.path.split(EXTERNAL_RES_UNSORTED_PATH)[0], 'external_resources')
        abc_path = os.path.join(res_path, 'subdirectory2', 'subsubdirectory', 'Abc.txt')
        bar_path = os.path.join(res_path, 'subdirectory2', 'bar.txt')
        foo_path = os.path.join(res_path, 'subdirectory', 'Foo.txt')
        hello_path = os.path.join(res_path, 'subdirectory2', 'subsubdirectory', 'hello.txt')
        resource_path = os.path.join(res_path, 'subdirectory2', 'Resource.txt')
        self.assertEqual(are_used, [True for _ in range(5)])
        self._test_listeners([EXTERNAL_RES_UNSORTED_PATH], [abc_path, bar_path, foo_path, hello_path, resource_path])

    def test_sort_external_resources(self):
        self.ctrl.load_data(EXTERNAL_RES_UNSORTED_PATH, MessageRecordingLoadObserver())
        assert_equals([res.name for res in self.ctrl.external_resources], ["Abc", "Bar", "Foo", "Hello", "Resource"])

    def test_datafiles_property_with_resource_file_only(self):
        resource = self.ctrl.load_resource(RESOURCE_PATH, self.load_observer)
        assert_equals(self.ctrl.datafiles[0], resource)

    def test_get_all_keywords_with_resource_file_only(self):
        chief = datafilereader.construct_chief_controller(RESOURCE_PATH)
        all_kws = chief.get_all_keywords()
        chief.close()
        res_kws = [kw for kw in all_kws if kw.name == 'Resource UK']
        assert_equals(len(res_kws), 1)

    def test_resource_import_modified(self):
        self.ctrl.resource_import_modified(RELATIVE_PATH_TO_RESOURCE_FILE, DATAPATH)
        self._test_listeners([], ALL_RESOURCE_PATH_RELATED_RESOURCE_IMPORTS)


def _data_directory(path):
    data = TestDataDirectory()
    data.source = data.directory = os.path.normpath(path)
    return data

def _testcasefile(path):
    data = TestCaseFile()
    data.source = os.path.normpath(path)
    return data


class TestResolvingResourceDirectories(unittest.TestCase):

    def setUp(self):
        self.chief = ChiefController(Namespace(FakeSettings()), FakeSettings(), _library_manager())

    def tearDown(self):
        self.chief.close()

    def test_resource_file_outside_of_topsuite_is_an_external_resource(self):
        self._set_data_directory_controller('suite')
        self._set_resources(j('foo','resource.txt'))
        assert_equals(self.chief.external_resources, self.chief.resources)

    def _set_data_directory_controller(self, dir):
        self.chief._controller = TestDataDirectoryController(_data_directory(dir))

    def test_resource_file_in_own_directory_is_added_to_top_suite(self):
        self._set_data_directory_controller('foo')
        self._set_resources(j('foo','bar','quux.txt'))
        self._assert_resource_dir_was_created_as_child_of(self.chief.data)
        self._assert_resource_dir_contains_resources()
        assert_true(len(self.chief.external_resources)==  0)

    def test_two_resource_in_same_directory_get_same_parent(self):
        self._set_data_directory_controller('foo')
        self._set_resources(j('foo','bar','quux.txt'), j('foo','bar','zap.txt'))
        self._assert_resource_dir_was_created_as_child_of(self.chief.data)
        self._assert_resource_dir_contains_resources()

    def test_two_nested_resources_in_same_directory_get_same_parent(self):
        self._set_data_directory_controller('suite')
        self._set_resources(j('suite','foo','bar','quux.txt'), j('suite','foo','bar','zap.txt'))
        assert_equals(self.chief.data.children[0].children[0].children,
                      self.chief.resources)

    def test_resource_directory_gets_nearest_possible_parent(self):
        self._set_data_directory_controller('tmp')
        self.chief.data.add_child(TestDataDirectoryController(_data_directory(j('tmp','some'))))
        self._set_resources(j('tmp','some','resoruces','res.txt'))
        assert_equals(len(self.chief.data.children), 1)
        assert_equals(len(self.chief.data.children[0].children), 1)
        assert_equals(self.chief.data.children[0].children[0].children, [self.chief.resources[0]])

    def test_nested_resource_directories(self):
        self._set_data_directory_controller('tmp')
        self._set_resources(j('tmp','resoruces','res.txt'), j('tmp','resoruces','more','res.txt'))
        assert_equals(len(self.chief.data.children), 1)
        assert_equals(len(self.chief.data.children[0].children), 2)
        assert_equals(self.chief.data.children[0].children[1].children, [self.chief.resources[1]])

    def test_resource_in_nested_directory(self):
        self._set_data_directory_controller('tmp')
        self._set_resources(j('tmp','res','ources','res.txt'))
        assert_equals(len(self.chief.data.children), 1)
        assert_equals(len(self.chief.data.children[0].children), 1)
        assert_equals(self.chief.data.children[0].children[0].children, [self.chief.resources[0]])
        assert_true(len(self.chief.external_resources)==  0)

    def _set_resources(self, *paths):
        for p in paths:
            resource = ResourceFileController(ResourceFile(os.path.normpath(p)))
            self.chief.resources.append(resource)
            self.chief.insert_into_suite_structure(resource)

    def _assert_resource_dir_was_created_as_child_of(self, ctrl):
        assert_equals(len(ctrl.children), 1)

    def _assert_resource_dir_contains_resources(self):
        assert_equals(self.chief.data.children[0].children, self.chief.resources)


class TestFindingControllers(unittest.TestCase):

    def setUp(self):
        self.chief = ChiefController(Namespace(FakeSettings()), FakeSettings(), _library_manager())

    def tearDown(self):
        self.chief.close()

    def test_finding_root_directory_controller(self):
        self.chief._controller = TestDataDirectoryController(_data_directory('Root'))
        result = self.chief.find_controller_by_longname('Root')
        assert_equals(result, self.chief._controller)

    def test_finding_subdirectory_controller(self):
        directory_controller = TestDataDirectoryController(_data_directory('Root'))
        subdirectory_controller = TestDataDirectoryController(_data_directory('Sub.suite'))
        directory_controller.add_child(subdirectory_controller)
        self.chief._controller = directory_controller
        result = self.chief.find_controller_by_longname('Root.Sub.suite')
        assert_equals(result, subdirectory_controller)

    def test_finding_testcase_controller(self):
        suite_controller = TestCaseFileController(_testcasefile('Suite.txt'))
        test = suite_controller.create_test('Test 1')
        self.chief._controller = suite_controller
        result = self.chief.find_controller_by_longname('Suite.Test 1', 'Test 1')
        assert_equals(result, test)

    def test_finding_correct_testcase_when_two_with_same_name(self):
        test1, test2 = self._create_suite_structure_with_two_tests_with_same_name()
        result1 = self.chief.find_controller_by_longname('Ro.ot.'+test1.longname, test1.display_name)
        assert_equals(result1, test1)
        result2 = self.chief.find_controller_by_longname('Ro.ot.'+test2.longname, test2.display_name)
        assert_equals(result2, test2)

    def test_finding_correct_testcase_when_two_files_with_same_name_start(self):
        directory_controller = TestDataDirectoryController(_data_directory('t'))
        suite1_controller = TestCaseFileController(_testcasefile('test.txt'))
        test1 = suite1_controller.create_test('A')
        suite2_controller = TestCaseFileController(_testcasefile('test2.txt'))
        test2 = suite2_controller.create_test('A')
        directory_controller.add_child(suite1_controller)
        directory_controller.add_child(suite2_controller)
        self.chief._controller = directory_controller
        result1 = self.chief.find_controller_by_longname('T.'+test1.longname, test1.display_name)
        assert_equals(result1, test1)
        result2 = self.chief.find_controller_by_longname('T.'+test2.longname, test2.display_name)
        assert_equals(result2, test2)

    def _create_suite_structure_with_two_tests_with_same_name(self):
        directory_controller = TestDataDirectoryController(_data_directory('Ro.ot'))
        suite1_controller = TestCaseFileController(_testcasefile('Suite.1.txt'))
        test1 = suite1_controller.create_test('Te.st')
        suite2_controller = TestCaseFileController(_testcasefile('Suite.2.txt'))
        test2 = suite2_controller.create_test('Te.st')
        directory_controller.add_child(suite1_controller)
        directory_controller.add_child(suite2_controller)
        self.chief._controller = directory_controller
        return test1, test2

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_commands
import unittest
from robot.utils.asserts import assert_true, assert_false, assert_equals
from robotide.controller.tags import DefaultTag
from robotide.controller.commands import *

from base_command_test import TestCaseCommandTest
from controller_creator import *


class UnmodifyingCommandsTest(unittest.TestCase):

    def test_unmodifying(self):
        self.assertFalse(FindOccurrences.modifying)


class FileHandlingCommandsTest(TestCaseCommandTest):

    def test_file_saving(self):
        self._file_saved = False
        self._exec(SaveFile())
        assert_true(self._file_saved)
        assert_false(self._ctrl.datafile_controller.dirty)

    def test_file_saving_purifies(self):
        self._add_empty_step_to_macro()
        other_name = self._ctrl.name + 'foo'
        self._copy_macro_as(other_name)
        self._exec(SaveFile())
        assert_equals(len(self._ctrl.steps), self._orig_number_of_steps+1)
        other = self._get_macro_by_name(other_name)
        assert_equals(len(other.steps), self._orig_number_of_steps+1)

    def test_undo_after_file_save_does_not_break(self):
        self._exec(SaveFile())
        self._exec(Undo())

    def _add_empty_step_to_macro(self):
        self._exec(ChangeCellValue(self._orig_number_of_steps+1, 10, 'A'))
        self._verify_step_number_change(2)

    def _copy_macro_as(self, name):
        self._exec(CopyMacroAs(name))


class MacroCopyingTest(TestCaseCommandTest):

    def test_copy_macro(self):
        new_name = self._ctrl.name + '1'
        original_macro_number = len(self._get_macros())
        self._exec(CopyMacroAs(new_name))
        macro_names = [m.name for m in self._get_macros()]
        assert_true(self._ctrl.name in macro_names)
        assert_true(new_name in macro_names)
        assert_equals(len(macro_names), original_macro_number+1)
        assert_equals(len(self._get_macro_by_name(new_name).steps), 
                      len(self._ctrl.steps))

    def test_copy_does_not_change_original(self):
        new_name = self._ctrl.name + '2'
        self._exec(CopyMacroAs(new_name))
        copy = self._get_copy(new_name)
        copy.execute(ChangeCellValue(0, 0, 'Changed Step'))
        assert_equals(self._ctrl.steps[0].keyword, STEP1_KEYWORD)
        assert_equals(copy.steps[0].keyword, 'Changed Step')

    def _get_copy(self,name):
        copies = [m for m in self._get_macros() if m.name == name]
        assert_equals(len(copies), 1)
        return copies[0]

    def test_copy_macro_inherits_default_tag(self):
        suite = self._ctrl.datafile_controller
        tag_name = 'konsukiepre'
        suite.default_tags.add(DefaultTag(tag_name))
        assert_true(any(True for tag in self._ctrl.tags if tag.name == tag_name))
        new_name = self._ctrl.name + '3'
        self._exec(CopyMacroAs(new_name))
        assert_true(any(True for tag in self._get_copy(new_name).tags if tag.name == tag_name))

class TestCaseEditingTest(TestCaseCommandTest):

    def test_changing_one_cell(self):
        self._exec(ChangeCellValue(0, 0, 'Changed Step'))
        assert_equals(self._steps[0].keyword, 'Changed Step')

    def test_changing_first_cell_in_for_loop_step(self):
        step_index = self._data_row(FOR_LOOP_STEP1)
        value = 'Foo'
        self._exec(ChangeCellValue(step_index, 0, value))
        assert_equals(self._steps[step_index].as_list()[0], value)

    def test_empty_second_cell_in_for_loop_step(self):
        step_index = self._data_row(FOR_LOOP_STEP1)
        value = ''
        self._exec(ChangeCellValue(step_index, 1, value))
        assert_equals(self._steps[step_index].as_list()[1], value)

    def test_undo_redo(self):
        original_cell_value = self._data_step_as_list(STEP1)[0]
        changed_cell_value = 'Changed Step'
        self._exec(ChangeCellValue(0, 0, changed_cell_value))
        assert_equals(self._steps[0].keyword, changed_cell_value)
        self._exec(Undo())
        assert_equals(self._steps[0].keyword, original_cell_value)
        self._exec(Redo())
        assert_equals(self._steps[0].keyword, changed_cell_value)

    def test_undo_when_nothing_to_undo(self):
        self._exec(Undo())
        assert_equals(self._number_of_test_changes, 0)

    def test_redo_when_nothing_to_redo(self):
        self._exec(Redo())
        assert_equals(self._number_of_test_changes, 0)

    def test_undo_undo_redo_redo(self):
        original_cell_value = self._data_step_as_list(STEP1)[0]
        changed_cell_value_1 = 'Changed Step'
        changed_cell_value_2 = 'Again changed Step'
        self._exec(ChangeCellValue(0, 0, changed_cell_value_1))
        assert_equals(self._steps[0].keyword, changed_cell_value_1)
        self._exec(ChangeCellValue(0, 0, changed_cell_value_2))
        assert_equals(self._steps[0].keyword, changed_cell_value_2)
        self._exec(Undo())
        assert_equals(self._steps[0].keyword, changed_cell_value_1)
        self._exec(Undo())
        assert_equals(self._steps[0].keyword, original_cell_value)
        self._exec(Redo())
        assert_equals(self._steps[0].keyword, changed_cell_value_1)
        self._exec(Redo())
        assert_equals(self._steps[0].keyword, changed_cell_value_2)

    def test_redo_does_nothing_after_state_changing_command_that_is_not_undo(self):
        changed_cell_value_1 = 'Changed Step'
        changed_cell_value_2 = 'Changed Step again'
        self._exec(ChangeCellValue(0, 0, changed_cell_value_1))
        self._exec(Undo())
        self._exec(ChangeCellValue(0, 0, changed_cell_value_2))
        self._exec(Redo())
        assert_equals(self._steps[0].keyword, changed_cell_value_2)

    def test_changing_cell_value_after_last_column_adds_empty_columns(self):
        self._exec(ChangeCellValue(0, 2, 'Hello'))
        assert_equals(self._steps[0].args, ['arg', 'Hello'])

    def test_changing_cell_value_after_last_row_adds_empty_rows(self):
        self._exec(ChangeCellValue(len(self._data)+5, 0, 'Hello'))
        assert_equals(self._steps[len(self._data)+5].keyword, 'Hello')

    def test_changing_for_loop_header_value(self):
        self._exec(ChangeCellValue(self._data_row(FOR_LOOP_HEADER), 0, 'Keyword'))
        assert_equals(self._steps[self._data_row(FOR_LOOP_HEADER)].as_list(),
                      ['Keyword'] + self._data_step_as_list(FOR_LOOP_HEADER)[1:])
        self._verify_step_unchanged(FOR_LOOP_STEP1)
        assert_equals(len(self._steps), self._orig_number_of_steps)

    def test_changing_for_loop_header_argument(self):
        self._exec(ChangeCellValue(self._data_row(FOR_LOOP_HEADER), 1, 'Keyword'))
        assert_equals(self._steps[self._data_row(FOR_LOOP_HEADER)].as_list(),
                      [': FOR', 'Keyword'] + self._data_step_as_list(FOR_LOOP_HEADER)[2:])
        self._verify_step_unchanged(FOR_LOOP_STEP1)
        assert_equals(len(self._steps), self._orig_number_of_steps)

    def test_changing_for_loop_header_in_clause(self):
        self._exec(ChangeCellValue(self._data_row(FOR_LOOP_HEADER), 2, 'Keyword'))
        assert_equals(self._steps[self._data_row(FOR_LOOP_HEADER)].as_list(),
                      [': FOR', '${i}', 'Keyword'] + self._data_step_as_list(FOR_LOOP_HEADER)[3:])
        assert_equals(self._steps[self._data_row(FOR_LOOP_STEP1)].as_list(),
                      self._data_step_as_list(FOR_LOOP_STEP1))
        assert_equals(len(self._steps), self._orig_number_of_steps)

    def test_deleting_row(self):
        self._exec(DeleteRow(0))
        self._verify_step_number_change(-1)
        self._verify_row_does_not_exist(STEP1)

    def test_undoing_row_delete(self):
        self._exec(DeleteRow(0))
        self._exec(Undo())
        assert_equals(len(self._steps), self._orig_number_of_steps)
        self._verify_step(0, 'Step 1', ['arg'])

    def test_delete_row_inside_of_for_loop(self):
        self._exec(DeleteRow(self._data_row(FOR_LOOP_STEP1)))
        assert_equals(len(self._steps), self._orig_number_of_steps-1)
        self._verify_row_does_not_exist(FOR_LOOP_STEP1)

    def test_delete_for_loop_header_row(self):
        self._exec(DeleteRow(self._data_row(FOR_LOOP_HEADER)))
        assert_equals(len(self._steps), self._orig_number_of_steps-1)
        self._verify_row_does_not_exist(FOR_LOOP_HEADER)

    def test_adding_row_last(self):
        self._exec(AddRow(-1))
        assert_equals(len(self._steps), self._orig_number_of_steps+1)
        assert_equals(self._steps[self._orig_number_of_steps].as_list(), [])

    def test_adding_row_first(self):
        self._exec(AddRow(0))
        assert_equals(len(self._steps), self._orig_number_of_steps+1)
        assert_equals(self._steps[0].as_list(), [])

    def test_adding_row_middle(self):
        self._exec(AddRow(1))
        assert_equals(len(self._steps), self._orig_number_of_steps+1)
        assert_equals(self._steps[1].as_list(), [])

    def test_adding_row_in_for_loop_body(self):
        row_in_for_loop = self._data_row(FOR_LOOP_STEP2)
        self._exec(AddRow(row_in_for_loop))
        assert_equals(len(self._steps), self._orig_number_of_steps+1)
        assert_equals(self._steps[row_in_for_loop].as_list(), [''])

    def test_inserting_cell_when_for_loop_is_last(self):
        row_after_for_loop = self._data_row(STEP_AFTER_FOR_LOOP)
        self._exec(DeleteRow(row_after_for_loop))
        self._exec(DeleteRow(row_after_for_loop))
        assert_equals(self._steps[-1].as_list(), ['', 'No Operation'])
        self._exec(InsertCell(0,0))
        self._verify_step(0, '', ['Step 1', 'arg'])

    def test_add_multiple_rows(self):
        self._exec(AddRows([1,2]))
        self._verify_step_number_change(2)
        self._verify_step(0, 'Step 1', ['arg'])
        self._verify_step_is_empty(1)
        self._verify_step_is_empty(2)
        self._verify_step(3, 'Step 2', ['a1', 'a2', 'a3'])

    def test_undo_multiple_rows_add(self):
        self._exec(AddRows([3,2,1,4,5,6,9,8,7,10]))
        self._exec(Undo())
        self._verify_step(0, 'Step 1', ['arg'])
        self._verify_step(1, 'Step 2', ['a1', 'a2', 'a3'])

    def test_purify_removes_empty_rows(self):
        self._exec(AddRow(-1))
        self._exec(AddRow(1))
        self._exec(AddRow(2))
        assert_equals(len(self._steps), self._orig_number_of_steps+3)
        self._exec(Purify())
        assert_equals(len(self._steps), self._orig_number_of_steps)

    def test_purify_can_be_undone(self):
        self._exec(AddRow(1))
        self._exec(AddRow(2))
        assert_equals(len(self._steps), self._orig_number_of_steps+2)
        self._exec(Purify())
        assert_equals(len(self._steps), self._orig_number_of_steps)
        self._exec(Undo())
        assert_equals(len(self._steps), self._orig_number_of_steps+2)

    def test_purify_removes_rows_with_no_data(self):
        self._exec(ChangeCellValue(0,0, ''))
        self._exec(ChangeCellValue(0,1, ''))
        self._exec(Purify())
        assert_equals(len(self._steps), self._orig_number_of_steps-1)

    def test_can_add_values_to_empty_row(self):
        self._exec(AddRow(-1))
        self._exec(ChangeCellValue(0, 3, 'HELLO'))
        assert_equals(self._steps[0].args, ['arg', '', 'HELLO'])

    def test_only_comment_is_left(self):
        index = self._data_row(STEP_WITH_COMMENT)
        self._exec(ChangeCellValue(index, 0, ''))
        self._exec(Purify())
        assert_equals(self._steps[index].as_list(), ['# this is a comment'])

    def test_comment_is_changed(self):
        index = self._data_row(STEP_WITH_COMMENT)
        self._exec(ChangeCellValue(index, 1, '# new comment'))
        self._verify_step(index, 'Foo', [], '# new comment')

    def test_cell_value_after_comment_is_changed(self):
        index = self._data_row(STEP_WITH_COMMENT)
        self._exec(ChangeCellValue(index, 2, 'something'))
        assert_equals(self._steps[index].as_list(), ['Foo', '# this is a comment', 'something'])

    def test_change_keyword_value_in_indented_step(self):
        index = self._data_row(FOR_LOOP_STEP1)
        self._exec(ChangeCellValue(index, 1, 'Blog'))
        assert_equals(self._steps[index].keyword, 'Blog')
        assert_equals(len(self._steps), self._orig_number_of_steps)

    def test_delete_multiple_rows(self):
        self._exec(DeleteRows([2,0]))
        assert_equals(len(self._steps), self._orig_number_of_steps-2)
        self._verify_row_does_not_exist(STEP1)
        self._verify_row_does_not_exist(STEP_WITH_COMMENT)
        self._verify_number_of_test_changes(1)

    def test_deleting_rows_below_existing_steps_should_do_nothing(self):
        self._exec(DeleteRows([1000, 960]))
        self._verify_number_of_test_changes(0)

    def test_inserting_rows_below_existing_steps_should_do_nothing(self):
        self._exec(AddRows([1001, 1002]))
        self._verify_number_of_test_changes(0)

    def test_clear_area(self):
        self._exec(ClearArea((0,1), (1,2)))
        self._verify_step(0, 'Step 1')
        self._verify_step(1, 'Step 2', ['', '', 'a3'])

    def test_paste_area(self):
        self._exec(PasteArea((0, 0), [['Changed Step 1', '', ''],
                                      ['Changed Step 2', '', 'ca2']]))
        self._verify_step(0, 'Changed Step 1')
        self._verify_step(1, 'Changed Step 2', ['', 'ca2', 'a3'])

    def test_paste_area_different_length_rows(self):
        self._exec(PasteArea((0, 0), [['Changed Step 1', '', '', '', '\t'],
            ['Changed Step 2', '', 'ca2']]))
        self._verify_step(0, 'Changed Step 1')
        self._verify_step(1, 'Changed Step 2', ['', 'ca2', 'a3'])

    def test_insert_area_inserts_cells_before_selected_cell(self):
        self._exec(InsertArea((0, 0), [['Changed Step 1', '', ''],
                                      ['Changed Step 2', '', 'ca2']]))
        self._verify_step(0, 'Changed Step 1')
        self._verify_step(1, 'Changed Step 2', ['', 'ca2'])
        self._verify_step(2, 'Step 1', ['arg'])

    def test_insert_area_inserts_cells_before_selected_cell_different_length_rows(self):
        self._exec(InsertArea((0, 0), [['Changed Step 1', '', '', '\t'],
            ['Changed Step 2', '', 'ca2']]))
        self._verify_step(0, 'Changed Step 1')
        self._verify_step(1, 'Changed Step 2', ['', 'ca2'])
        self._verify_step(2, 'Step 1', ['arg'])

    def test_insert_cell(self):
        self._exec(InsertCells((0,1), (0,1)))
        self._verify_step(0, 'Step 1', ['', 'arg'])

    def test_inserting_cells_outside_step(self):
        self._exec(InsertCells((0,10), (0,10)))
        self._verify_step(0, 'Step 1', ['arg'])

    def test_insert_cell_before_comment(self):
        self._exec(InsertCells((2,1), (2,1)))
        self._verify_step(2, 'Foo', [''], exp_comment='# this is a comment')

    def test_inserting_many_cells(self):
        self._exec(InsertCells((0,1), (1,2)))
        self._verify_step(0, 'Step 1', ['', '', 'arg'])
        self._verify_step(1, 'Step 2', ['', '', 'a1', 'a2', 'a3'])

    def test_delete_many_cells(self):
        self._exec(DeleteCells((0,1), (1,2)))
        self._verify_step(0, 'Step 1', [])
        self._verify_step(1, 'Step 2', ['a3'])

    def test_delete_cells_in_for_loop_and_undo(self):
        start_row = self._data_row(FOR_LOOP_STEP1)
        end_row = self._data_row(FOR_LOOP_STEP2)
        self._exec(DeleteCells((start_row, 1), (end_row, 10)))
        assert_equals(self._steps[start_row].as_list(), [''])
        assert_equals(self._steps[end_row].as_list(), [''])
        self._exec(Undo())
        self._verify_steps_unchanged(FOR_LOOP_STEP1, FOR_LOOP_STEP2)

    def test_commenting(self):
        self._exec(CommentRows([0]))
        self._verify_step(0, 'Comment', ['Step 1', 'arg'])

    def test_commenting_many_rows(self):
        self._exec(CommentRows([1,2,3,4]))
        for row_data in [STEP2, STEP_WITH_COMMENT, FOR_LOOP_HEADER, FOR_LOOP_STEP1]:
            assert_equals(self._steps[self._data_row(row_data)].as_list(),
                          ['Comment'] + self._data_step_as_list(row_data))

    def test_commenting_step_in_for_loop(self):
        row = self._data_row(FOR_LOOP_STEP1)
        self._exec(CommentRows([row]))
        assert_equals(self._steps[row].as_list(),
                      ['', 'Comment'] + self._data_step_as_list(FOR_LOOP_STEP1)[1:])

    def test_uncommenting_single_row(self):
        self._exec(CommentRows([0]))
        self._exec(UncommentRows([0]))
        assert_equals(self._steps[0].as_list(), self._data_step_as_list(STEP1))

    def test_uncommenting_rows(self):
        self._exec(CommentRows([1,2,3,4]))
        self._exec(UncommentRows([1,2,3,4]))
        self._verify_steps_unchanged(STEP2, STEP_WITH_COMMENT, FOR_LOOP_HEADER, FOR_LOOP_STEP1)

    def test_uncommenting_commented_step_in_for_loop(self):
        row = self._data_row(FOR_LOOP_STEP1)
        self._exec(CommentRows([row]))
        self._exec(UncommentRows([row]))
        self._verify_step_unchanged(FOR_LOOP_STEP1)

    def test_uncommenting_does_nothing_if_not_commented(self):
        self._exec(UncommentRows([1,2,3,4]))
        self._verify_steps_unchanged(STEP2, STEP_WITH_COMMENT, FOR_LOOP_HEADER, FOR_LOOP_STEP1)

    def test_commenting_and_uncommenting_row_with_no_step(self):
        self._exec(CommentRows([1000]))
        self._verify_number_of_test_changes(0)
        self._exec(UncommentRows([10001]))
        self._verify_number_of_test_changes(0)


_TEST_WITH_TWO_FOR_LOOPS = ['Test With Two For Loops',
                            '  : FOR  ${i}  IN  1  2',
                            '    Log  ${i}',
                            '  : FOR  ${j}  IN  1  2',
                            '    Log  ${j}']

class ForLoopCases(TestCaseCommandTest):

    def _create_data(self):
        return _TEST_WITH_TWO_FOR_LOOPS[:]

    def test_remove_second_for_header(self):
        self._exec(DeleteCells((2,0), (2,0)))
        self._verify_step(2, '${j}', ['IN', '1', '2'])

    def test_remove_first_step_in_for_loop(self):
        self._exec(DeleteCells((1,1), (1,10)))
        self._verify_step_unchanged('  : FOR  ${i}  IN  1  2')
        self._verify_step(1, '')
        self._verify_step_unchanged('  : FOR  ${j}  IN  1  2')

class RowMovingTest(TestCaseCommandTest):

    def test_row_up(self):
        result = self._exec(MoveRowsUp([1]))
        assert_true(result)
        self._assert_step_order(STEP2, STEP1)

    def test_first_row_up_does_nothing(self):
        result = self._exec(MoveRowsUp([0]))
        assert_true(not result)
        assert_equals(self._number_of_test_changes, 0)
        self._exec(Undo())
        self._exec(Redo())

    def test_moving_block_containing_first_row_up_does_nothing(self):
        self._exec(MoveRowsUp([0,1,2]))
        assert_equals(self._number_of_test_changes, 0)

    def test_move_for_loop_header_up(self):
        self._exec(MoveRowsUp([self._data_row(FOR_LOOP_HEADER)]))
        self._assert_step_order(STEP1,
                                STEP2,
                                FOR_LOOP_HEADER,
                                '  '+STEP_WITH_COMMENT,
                                FOR_LOOP_STEP1,
                                FOR_LOOP_STEP2,
                                STEP_AFTER_FOR_LOOP)

    def test_move_step1_in_for_loop_header_up(self):
        self._exec(MoveRowsUp([self._data_row(FOR_LOOP_STEP1)]))
        self._assert_step_order(STEP1,
                                STEP2,
                                STEP_WITH_COMMENT,
                                FOR_LOOP_STEP1[2:],
                                FOR_LOOP_HEADER,
                                FOR_LOOP_STEP2,
                                STEP_AFTER_FOR_LOOP)

    def test_move_down_step_before_for_loop_header(self):
        self._exec(MoveRowsDown([self._data_row(STEP_WITH_COMMENT)]))
        self._assert_step_order(STEP1,
                                STEP2,
                                FOR_LOOP_HEADER,
                                '  '+STEP_WITH_COMMENT,
                                FOR_LOOP_STEP1,
                                FOR_LOOP_STEP2,
                                STEP_AFTER_FOR_LOOP)

    def test_move_up_step_after_for_loop(self):
        self._exec(MoveRowsUp([self._data_row(STEP_AFTER_FOR_LOOP)]))
        self._assert_step_order(STEP1,
                                STEP2,
                                STEP_WITH_COMMENT,
                                FOR_LOOP_HEADER,
                                FOR_LOOP_STEP1,
                                '  '+STEP_AFTER_FOR_LOOP,
                                FOR_LOOP_STEP2)

    def test_move_down_last_step_in_for_loop(self):
        self._exec(MoveRowsDown([self._data_row(FOR_LOOP_STEP2)]))
        self._assert_step_order(STEP1,
                                STEP2,
                                STEP_WITH_COMMENT,
                                FOR_LOOP_HEADER,
                                FOR_LOOP_STEP1,
                                STEP_AFTER_FOR_LOOP,
                                FOR_LOOP_STEP2[2:])

    def test_move_down_for_loop_header(self):
        self._exec(MoveRowsDown([self._data_row(FOR_LOOP_HEADER)]))
        self._assert_step_order(STEP1,
                                STEP2,
                                STEP_WITH_COMMENT,
                                FOR_LOOP_STEP1[2:],
                                FOR_LOOP_HEADER,
                                FOR_LOOP_STEP2,
                                STEP_AFTER_FOR_LOOP,)

    def test_undo_row_up(self):
        self._exec(MoveRowsUp([1]))
        self._exec(Undo())
        self._assert_step_order(STEP1, STEP2)

    def test_moving_rows(self):
        self._exec(MoveRowsUp([1, 2]))
        self._assert_step_order(STEP2, STEP_WITH_COMMENT, STEP1)

    def test_undoing_moving_rows(self):
        self._exec(MoveRowsUp([1, 2]))
        self._exec(Undo())
        self._assert_step_order(STEP1, STEP2, STEP_WITH_COMMENT)

    def test_move_row_down(self):
        self._exec(MoveRowsDown([0]))
        self._assert_step_order(STEP2, STEP1)

    def test_undo_move_row_down(self):
        self._exec(MoveRowsDown([0]))
        self._exec(Undo())
        self._assert_step_order(STEP1, STEP2)

    def test_move_rows_down(self):
        self._exec(MoveRowsDown([0,1]))
        self._assert_step_order(STEP_WITH_COMMENT, STEP1, STEP2)

    def _assert_step_order(self, *steps):
        for idx, step in enumerate(steps):
            assert_equals(self._steps[idx].as_list(),
                          self._data_step_as_list(step))
        assert_true(self._ctrl.dirty)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_controllers
import re
import unittest
from mock import Mock
from robot.parsing.settings import Fixture, Documentation, Timeout, Tags, Return
from robot.utils.asserts import assert_equals, assert_true, assert_false
from robot.parsing.model import TestCaseFile

from robotide.controller.filecontrollers import TestCaseFileController
from robotide.controller.settingcontrollers import (DocumentationController,
        FixtureController, TagsController, ImportController,
        ReturnValueController, TimeoutController, ForceTagsController,
        DefaultTagsController)
from robotide.controller.tablecontrollers import (VariableTableController,
        MetadataListController, ImportSettingsController, _WithListOperations)
from robotide.publish.messages import (RideImportSetting, RideImportSettingRemoved,
        RideImportSettingAdded, RideImportSettingChanged)
from resources.mocks import PublisherListener
from controller.base_command_test import _FakeChief
from robotide.controller.tags import Tag


class _FakeParent(_FakeChief):
    def __init__(self):
        self.parent = None
        self.dirty = False
        self.datafile = None
        self.force_tags = ForceTagsController(self, Tags('Force Tags'))
        self.default_tags = DefaultTagsController(self, Tags('Default Tags'))
        self._setting_table = self
    def mark_dirty(self):
        self.dirty = True


class DocumentationControllerTest(unittest.TestCase):

    def setUp(self):
        self.doc = Documentation('Documentation')
        self.doc.value = 'Initial doc'
        self.parent = _FakeParent()
        self.ctrl = DocumentationController(self.parent, self.doc)

    def test_creation(self):
        assert_equals(self.ctrl.display_value, 'Initial doc')
        assert_true(self.ctrl.datafile is None)
        ctrl = DocumentationController(self.parent, Documentation('[Documentation]'))
        assert_equals(ctrl.label, 'Documentation')

    def test_setting_value(self):
        self.ctrl.set_value('Doc changed')
        assert_equals(self.doc.value, 'Doc changed')
        self.ctrl.set_value('Doc changed | again')
        assert_equals(self.doc.value, 'Doc changed | again')

    def test_get_editable_value(self):
        self.doc.value = 'My doc \\n with enters \\\\\\r\\n and \\t tabs and escapes \\\\n \\\\\\\\r'
        assert_equals(self.ctrl.editable_value, 'My doc \n with enters \\\\\n'
                                                ' and \\t tabs and escapes \\\\n \\\\\\\\r')

    def test_set_editable_value(self):
        test_text = '''My doc
 with enters
 and \t tabs'''
        self.ctrl.editable_value = test_text
        assert_equals(self.doc.value, 'My doc\\n with enters\\n and \t tabs')
        assert_equals(self.ctrl.editable_value, test_text)

    def test_set_editable_value_should_escape_leading_hash(self):
        self.ctrl.editable_value = '# Not # Comment'
        assert_equals(self.doc.value, '\\# Not # Comment')
        assert_equals(self.ctrl.editable_value, '\\# Not # Comment')

    def test_get_visible_value(self):
        self.doc.value = 'My doc \\n with enters \\n and \t tabs'
        assert_equals(self.ctrl.visible_value, '<p>My doc with enters and \t tabs</p>')

    def test_setting_value_informs_parent_controller_about_dirty_model(self):
        self.ctrl.set_value('Blaa')
        assert_true(self.ctrl.dirty)

    def test_set_empty_value(self):
        self.ctrl.set_value('')
        assert_equals(self.doc.value, '')
        assert_true(self.ctrl.dirty)

    def test_same_value(self):
        self.ctrl.set_value('Initial doc')
        assert_false(self.ctrl.dirty)

    def test_clear(self):
        self.ctrl.clear()
        assert_equals(self.doc.value, '')
        assert_true(self.ctrl.dirty)


class FixtureControllerTest(unittest.TestCase):

    def setUp(self):
        self.fix = Fixture('Suite Setup')
        self.fix.name = 'My Setup'
        self.fix.args = ['argh', 'urgh']
        self.parent = _FakeParent()
        self.ctrl = FixtureController(self.parent, self.fix)

    def test_creation(self):
        assert_equals(self.ctrl.display_value, 'My Setup | argh | urgh')
        assert_equals(self.ctrl.label, 'Suite Setup')
        assert_true(self.ctrl.is_set)

    def test_value_with_empty_fixture(self):
        assert_equals(FixtureController(self.parent, Fixture('Teardown')).display_value, '')

    def test_setting_value_changes_fixture_state(self):
        self.ctrl.set_value('Blaa')
        assert_equals(self.fix.name, 'Blaa')
        assert_equals(self.fix.args, [])
        self.ctrl.set_value('Blaa | a')
        assert_equals(self.fix.name, 'Blaa')
        assert_equals(self.fix.args, ['a'])

    def test_whitespace_is_ignored_in_value(self):
        self.ctrl.set_value('Name |   a    |    b      |     c')
        assert_equals(self.fix.name, 'Name')
        assert_equals(self.fix.args, ['a', 'b', 'c'])
        assert_equals(self.ctrl.display_value, 'Name | a | b | c')

    def test_setting_value_informs_parent_controller_about_dirty_model(self):
        self.ctrl.set_value('Blaa')
        assert_true(self.ctrl.dirty)

    def test_set_empty_value(self):
        self.ctrl.set_value('')
        assert_equals(self.fix.name, '')
        assert_equals(self.fix.args, [])
        assert_true(self.ctrl.dirty)

    def test_same_value(self):
        self.ctrl.set_value('My Setup | argh | urgh')
        assert_false(self.ctrl.dirty)

    def test_setting_comment(self):
        self.ctrl.set_comment(['My comment'])
        assert_equals(self.ctrl.comment.as_list(), ['# My comment'])
        assert_true(self.ctrl.dirty)

    def test_contains_keyword_with_regexp_with_empty_fixture(self):
        empty_fixture_controller = FixtureController(self.parent, Fixture('Setup'))
        keyword_regexp = re.compile(r'foo.*bar')
        assert_false(empty_fixture_controller.contains_keyword(keyword_regexp))


class TagsControllerTest(unittest.TestCase):

    def setUp(self):
        self.tags = Tags('Force Tags')
        self.tags.value = ['f1', 'f2']
        self.parent = _FakeParent()
        self.ctrl = TagsController(self.parent, self.tags)

    def test_creation(self):
        assert_equals(self.ctrl.display_value, 'f1 | f2')
        assert_true(self.ctrl.is_set)

    def test_value_with_empty_fixture(self):
        assert_equals(TagsController(self.parent, Tags('Tags')).display_value, '')

    def test_setting_value_changes_fixture_state(self):
        self.ctrl.set_value('Blaa')
        assert_equals(self.tags.value, ['Blaa'])
        self.ctrl.set_value('a1 | a2 | a3')
        assert_equals(self.tags.value, ['a1', 'a2', 'a3'])

    def test_setting_value_informs_parent_controller_about_dirty_model(self):
        self.ctrl.set_value('Blaa')
        assert_true(self.ctrl.dirty)

    def test_set_empty_value(self):
        self.ctrl.set_value('')
        assert_equals(self.tags.value, [])
        assert_true(self.ctrl.dirty)

    def test_same_value(self):
        self.ctrl.set_value('f1 | f2')
        assert_false(self.ctrl.dirty)

    def test_escaping_pipes_in_value(self):
        self.ctrl.set_value('first \| second')
        assert_equals(self.tags.value, ['first | second'])
        assert_equals(self.ctrl.display_value, 'first \| second')

    def test_adding_tag(self):
        self.ctrl.add(Tag('new tag'))
        assert_equals(self.tags.value, ['f1', 'f2', 'new tag'])


class TimeoutControllerTest(unittest.TestCase):

    def setUp(self):
        self.to = Timeout('Timeout')
        self.to.value = '1 s'
        self.to.message = 'message'
        self.parent = _FakeParent()
        self.ctrl = TimeoutController(self.parent, self.to)

    def test_creation(self):
        assert_equals(self.ctrl.display_value, '1 s | message')
        assert_true(self.ctrl.is_set)

    def test_value_with_empty_timeout(self):
        assert_equals(TimeoutController(self.parent,
                                        Timeout('Timeout')).display_value, '')

    def test_setting_value_changes_fixture_state(self):
        self.ctrl.set_value('3 s')
        assert_equals(self.to.value, '3 s')
        assert_equals(self.to.message, '')
        self.ctrl.set_value('3 s | new message')
        assert_equals(self.to.value, '3 s')
        assert_equals(self.to.message, 'new message')

    def test_setting_value_informs_parent_controller_about_dirty_model(self):
        self.ctrl.set_value('1 min')
        assert_true(self.ctrl.dirty)

    def test_set_empty_value(self):
        self.ctrl.set_value('')
        assert_equals(self.to.value, '')
        assert_equals(self.to.message, '')
        assert_true(self.ctrl.dirty)

    def test_same_value(self):
        self.ctrl.set_value('1 s | message')
        assert_false(self.ctrl.dirty)


class ReturnValueControllerTest(unittest.TestCase):

    def test_creation(self):
        ctrl = ReturnValueController(_FakeParent(), Return('[Return]'))
        assert_equals(ctrl.label, 'Return Value')


class ImportControllerTest(unittest.TestCase):
    class FakeParent(_FakeChief):

        _namespace = None

        @property
        def directory(self):
            return 'tmp'

        def resource_import_modified(self, path, directory):
            pass

    def setUp(self):
        self.tcf = TestCaseFile()
        self.tcf.setting_table.add_library('somelib', ['foo', 'bar'])
        self.tcf.setting_table.add_resource('resu')
        self.tcf.setting_table.add_library('BuiltIn', ['WITH NAME', 'InBuilt'])
        self.tcf_ctrl = TestCaseFileController(self.tcf, ImportControllerTest.FakeParent())
        self.tcf_ctrl.data.directory = 'tmp'
        self.parent = ImportSettingsController(self.tcf_ctrl, self.tcf.setting_table,
            resource_file_controller_factory=self._resource_file_controller_factory_mock())
        self.add_import_listener = PublisherListener(RideImportSettingAdded)
        self.changed_import_listener = PublisherListener(RideImportSettingChanged)
        self.removed_import_listener = PublisherListener(RideImportSettingRemoved)
        self.import_listener = PublisherListener(RideImportSetting)

    def _resource_file_controller_factory_mock(self):
        rfcfm = lambda:0
        rfcfm.find_with_import = lambda *_:None
        return rfcfm

    def tearDown(self):
        self.add_import_listener.unsubscribe()
        self.changed_import_listener.unsubscribe()
        self.import_listener.unsubscribe()

    def test_creation(self):
        self._assert_import(0, 'somelib', ['foo', 'bar'])
        self._assert_import(1, 'resu')
        self._assert_import(2, 'BuiltIn', exp_alias='InBuilt')

    def test_display_value(self):
        assert_equals(self.parent[0].display_value, 'foo | bar')
        assert_equals(self.parent[1].display_value, '')
        assert_equals(self.parent[2].display_value, 'WITH NAME | InBuilt')

    def test_editing(self):
        ctrl = ImportController(self.parent, self.parent[1]._import)
        ctrl.set_value('foo')
        self._assert_import(1, 'foo')
        assert_true(self.parent.dirty)

    def test_editing_with_args(self):
        ctrl = ImportController(self.parent, self.parent[0]._import)
        ctrl.set_value('bar', 'quux')
        self._assert_import(0, 'bar', ['quux'])
        assert_true(self.parent.dirty)
        ctrl.set_value('name', 'a1 | a2')
        self._assert_import(0, 'name', ['a1', 'a2'])

    def test_editing_with_alias(self):
        ctrl = ImportController(self.parent, self.parent[0]._import)
        ctrl.set_value('newname', '', 'namenew')
        self._assert_import(0, 'newname', exp_alias='namenew')
        ctrl.set_value('again')
        self._assert_import(0, 'again')

    def test_publishing_change(self):
        ctrl = ImportController(self.parent, self.parent[1]._import)
        ctrl.set_value('new name')
        self._test_listener('new name', 'resource', self.changed_import_listener)

    def test_publishing_remove(self):
        self.parent.delete(1)
        self._test_listener('resu', 'resource', self.removed_import_listener)
        self.parent.delete(0)
        self._test_listener('somelib', 'library', self.removed_import_listener, 1)

    def test_publish_adding_library(self):
        self.parent.add_library('name', 'argstr', None)
        self._test_listener('name', 'library', self.add_import_listener)

    def test_publish_adding_resource(self):
        self.parent.add_resource('path')
        self._test_listener('path', 'resource', self.add_import_listener)

    def test_publish_adding_variables(self):
        self.parent.add_variables('path', 'argstr')
        self._test_listener('path', 'variables', self.add_import_listener)

    def _test_listener(self, name, type, listener, index=0):
        data = listener.data[index]
        assert_equals(data.name, name)
        assert_equals(data.type, type)
        assert_equals(data.datafile, self.tcf_ctrl)
        assert_equals(self.import_listener.data[index].name, name)

    def _assert_import(self, index, exp_name, exp_args=[], exp_alias=''):
        item = self.parent[index]
        assert_equals(item.name, exp_name)
        assert_equals(item.args, exp_args)
        assert_equals(item.alias, exp_alias)


class ImportSettingsControllerTest(unittest.TestCase):

    def setUp(self):
        self.tcf = TestCaseFile()
        filectrl = TestCaseFileController(self.tcf)
        filectrl.resource_import_modified = Mock()
        resource_file_controller_mock = lambda:0
        resource_file_controller_mock.add_known_import = lambda *_:0
        resu_factory_mock = lambda:0
        resu_factory_mock.find_with_import = lambda *_: resource_file_controller_mock
        self.ctrl = ImportSettingsController(filectrl, self.tcf.setting_table, resu_factory_mock)

    def test_adding_library(self):
        self.ctrl.add_library('MyLib', 'Some | argu | ments', 'alias')
        self._assert_import('MyLib', ['Some', 'argu', 'ments'], 'alias')

    def test_adding_resource(self):
        self.ctrl.add_resource('/a/path/to/file.txt')
        self._assert_import('/a/path/to/file.txt')

    def test_adding_variables(self):
        self.ctrl.add_variables('varfile.py', 'an arg')
        self._assert_import('varfile.py', ['an arg'])

    def _assert_import(self, exp_name, exp_args=[], exp_alias=None):
        imp = self.tcf.setting_table.imports[-1]
        assert_equals(imp.name, exp_name)
        assert_equals(imp.args, exp_args)
        assert_true(self.ctrl.dirty)

    def test_creation(self):
        assert_true(self.ctrl._items is not None)


class VariablesControllerTest(unittest.TestCase):

    def setUp(self):
        self.tcf = TestCaseFile()
        self._add_var('${foo}', 'foo')
        self._add_var('@{bar}', ['b', 'a', 'r'])
        self.ctrl = VariableTableController(TestCaseFileController(self.tcf),
                                            self.tcf.variable_table)

    def _add_var(self, name, value):
        self.tcf.variable_table.add(name, value)

    def test_creation(self):
        assert_equals(self.ctrl[0].name, '${foo}')
        assert_equals(self.ctrl[1].name, '@{bar}')

    def test_adding_scalar(self):
        self.ctrl.add_variable('${blaa}', 'value')
        assert_true(self.ctrl.dirty)
        self._assert_var_in_model(2, '${blaa}', ['value'])

    def test_editing(self):
        self.ctrl[0].set_value('${blaa}', 'quux')
        self._assert_var_in_ctrl(0, '${blaa}', ['quux'])
        self.ctrl[1].set_value('@{listvar}', ['a', 'b', 'c'])
        self._assert_var_in_ctrl(1, '@{listvar}', ['a', 'b', 'c'])
        assert_true(self.ctrl.dirty)

    def _assert_var_in_ctrl(self, index, name, value):
        assert_equals(self.ctrl[index].name, name)
        assert_equals(self.ctrl[index].value, value)

    def _assert_var_in_model(self, index, name, value):
        assert_equals(self.tcf.variable_table.variables[index].name, name)
        assert_equals(self.tcf.variable_table.variables[index].value, value)


class MetadataListControllerTest(unittest.TestCase):

    def setUp(self):
        self.tcf = TestCaseFile()
        self.tcf.setting_table.add_metadata('Meta name', 'Some value')
        self.ctrl = MetadataListController(TestCaseFileController(self.tcf),
                                           self.tcf.setting_table)

    def test_creation(self):
        self._assert_meta_in_ctrl(0, 'Meta name', 'Some value')

    def test_editing(self):
        self.ctrl[0].set_value('New name', 'another value')
        self._assert_meta_in_model(0, 'New name', 'another value')
        assert_true(self.ctrl[0].dirty)

    def test_serialization(self):
        assert_equals(self._get_metadata(0).as_list(),
                      ['Metadata', 'Meta name', 'Some value'])

    def _assert_meta_in_ctrl(self, index, name, value):
        assert_equals(self.ctrl[index].name, name)
        assert_equals(self.ctrl[index].value, value)

    def _assert_meta_in_model(self, index, name, value):
        assert_equals(self._get_metadata(index).name, name)
        assert_equals(self._get_metadata(index).value, value)

    def _get_metadata(self, index):
        return self.tcf.setting_table.metadata[index]


class FakeListController(_WithListOperations):

    def __init__(self):
        self._itemslist = ['foo', 'bar', 'quux']
        self.dirty = False

    @property
    def _items(self):
        return self._itemslist

    def mark_dirty(self):
        self.dirty = True


class WithListOperationsTest(unittest.TestCase):

    def setUp(self):
        self._list_operations = FakeListController()

    def test_move_up(self):
        self._list_operations.move_up(1)
        assert_true(self._list_operations.dirty)
        self._assert_item_in(0, 'bar')
        self._assert_item_in(1, 'foo')

    def test_move_down(self):
        self._list_operations.move_down(0)
        assert_true(self._list_operations.dirty)
        self._assert_item_in(0, 'bar')
        self._assert_item_in(1, 'foo')

    def test_moving_first_item_up_does_nothing(self):
        self._list_operations.move_up(0)
        assert_false(self._list_operations.dirty)
        self._assert_item_in(0, 'foo')

    def test_moving_last_item_down_does_nothing(self):
        self._list_operations.move_down(2)
        assert_false(self._list_operations.dirty)
        self._assert_item_in(2, 'quux')

    def test_delete(self):
        self._list_operations.delete(0)
        self._assert_item_in(0, 'bar')

    def _assert_item_in(self, index, name):
        assert_equals(self._list_operations._items[index], name)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_excludes_logic
import tempfile
import unittest
import os
import datafilereader
from robotide.controller.filecontrollers import TestDataDirectoryController, ExcludedDirectoryController, \
    DirtyRobotDataException


class TestExcludesLogic(unittest.TestCase):

    def setUp(self):
        self.chief = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH, tempfile.gettempdir())

    def tearDown(self):
        p = self.chief._settings.excludes._exclude_file_path
        if os.path.exists(p):
            os.remove(p)

    def _get_resource_dir(self):
        return datafilereader.get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_INNER_RESOURCE_DIR, self.chief.datafiles)

    def test_excluding_and_including(self):
        resource_dir = self._get_resource_dir()
        self.assertEqual(resource_dir.__class__, TestDataDirectoryController)
        resource_dir.exclude()
        resource_dir = self._get_resource_dir()
        self.assertEqual(resource_dir.__class__, ExcludedDirectoryController)
        resource_dir.remove_from_excludes()
        resource_dir = self._get_resource_dir()
        self.assertEqual(resource_dir.__class__, TestDataDirectoryController)

    def test_excluding_throws_exception_if_dirty_data(self):
        resource_dir = self._get_resource_dir()
        resu = resource_dir.children[0]
        resu.mark_dirty()
        self.assertRaises(DirtyRobotDataException, resource_dir.exclude)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_extract_keyword
from controller.base_command_test import *

from robotide.controller.commands import ExtractKeyword, Undo
from robotide.publish.messages import RideUserKeywordAdded
from robot.utils.asserts import assert_true
from controller.controller_creator import FOR_LOOP_HEADER, FOR_LOOP_STEP2,\
    FOR_LOOP_STEP1


class TestExtractKeyword(TestCaseCommandTest):

    _namespace = None

    def setUp(self):
        TestCaseCommandTest.setUp(self)
        PUBLISHER.subscribe(self._on_keyword_added, RideUserKeywordAdded)

    def _on_keyword_added(self, message):
        self._new_keyword = message.item

    def test_extract(self):
        new_kw_name = 'New Keyword'
        self._exec(ExtractKeyword(new_kw_name, '', (0,1)))
        self._verify_step(0, new_kw_name)
        self._verify_step_number_change(-1)
        assert_true(self._ctrl.dirty)
        assert_equals(self._new_keyword.name, new_kw_name)

    def test_extract_with_for_loop(self):
        new_kw_name = 'New Keyword with For Loop'
        self._exec(ExtractKeyword(new_kw_name, '',
            (self._data_row(FOR_LOOP_HEADER),self._data_row(FOR_LOOP_STEP2))))
        self._verify_step(self._data_row(FOR_LOOP_HEADER), new_kw_name)
        self._verify_step_number_change(-2)
        assert_true(self._ctrl.dirty)
        assert_equals(self._new_keyword.name, new_kw_name)

    def not_implemented_test_undoing_extract(self):
        new_kw_name = 'New Keyword'
        self._exec(ExtractKeyword(new_kw_name, '', (0,1)))
        self._exec(Undo())
        self._verify_step_number_change(0)

    def not_implmented_test_extract_from_for_loop(self):
        new_kw_name = 'Flooo'
        self._exec(ExtractKeyword(new_kw_name, '',
            (self._data_row(FOR_LOOP_STEP1),self._data_row(FOR_LOOP_STEP2))))
        self._verify_step_number_change(-1)
        assert_true(self._ctrl.dirty)
        assert_equals(self._new_keyword.name, new_kw_name)
        assert_equals(self._steps[self._data_row(FOR_LOOP_STEP1)].as_list(), ['', new_kw_name])


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_extract_var_commands
import unittest
import datafilereader
from robotide.controller.commands import ExtractScalar, ExtractList
from robot.utils.asserts import assert_equals


class TestExtractVariableCommands(unittest.TestCase):

    def setUp(self):
        self.chief_ctrl = datafilereader.construct_chief_controller(datafilereader.LOG_MANY_SUITE)
        self.datafile = datafilereader.get_ctrl_by_name('Log Many', self.chief_ctrl.datafiles)
        self.testcase = self.datafile.tests[0]

    def tearDown(self):
        self.chief_ctrl.close()

    def test_scalar_extract(self):
        row, col = 0, 1
        var_name = '${foo}'
        var_value = self.testcase.step(row).as_list()[col]
        var_comment = ['Something about the variable']
        self.testcase.execute(ExtractScalar(var_name, var_value, var_comment, (row, col)))
        assert_equals(self.testcase.step(row).as_list()[col], var_name)
        var = [var for var in self.testcase.datafile_controller.variables if var.name == var_name][0]
        assert_equals(var.value[0], var_value)
        assert_equals(var.comment.as_list(), var_comment)

    def test_list_extract(self):
        row = 0
        cols = [2, 3]
        var_name = '@{joo}'
        var_value = self.testcase.step(row).as_list()[cols[0]:cols[-1]+1]
        value_after_list = self.testcase.step(row).as_list()[cols[-1]+1]
        var_comment = ['Comment for my test list']
        self.testcase.execute(ExtractList(var_name, var_value, var_comment, [(row, col) for col in cols]))
        assert_equals(self.testcase.step(row).as_list()[cols[0]], var_name)
        var = [var for var in self.testcase.datafile_controller.variables if var.name == var_name][0]
        assert_equals(var.value, var_value)
        assert_equals(var.comment.as_list(), var_comment)
        assert_equals(self.testcase.step(row).as_list()[cols[0]+1], value_after_list)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_filecontrollers
import unittest
import os
import shutil

from robotide.robotapi import TestCase, TestCaseFile, TestDataDirectory
from robot.utils.asserts import (assert_equals, assert_true, assert_false)

from robotide.controller.filecontrollers import TestCaseFileController, \
    TestDataDirectoryController, _FileSystemElement
from robotide.controller.tablecontrollers import TestCaseController
from robotide.controller.commands import AddTestCaseFile, AddTestDataDirectory,\
    SortKeywords, Undo, Redo
from robotide.publish import PUBLISHER
from robotide.publish.messages import RideDataChangedToDirty,\
RideDataDirtyCleared

from resources import SUITEPATH
import datafilereader


class TestMarkUnMarkDirty(unittest.TestCase):

    def setUp(self):
        class Data(object):
            source = directory = None
        self.ctrl = TestCaseFileController(Data())
        self._has_unsaved_changes = False
        self._saved = False
        self.messages = [(self._changes, RideDataChangedToDirty),
                         (self._cleared, RideDataDirtyCleared)]
        for listener, topic in self.messages:
            PUBLISHER.subscribe(listener, topic)

    def tearDown(self):
        for listener, topic in self.messages:
            PUBLISHER.unsubscribe(listener, topic)
        if os.path.exists('path'):
            shutil.rmtree('path')

    def _changes(self, payload):
        self._has_unsaved_changes = payload.datafile

    def _cleared(self, payload):
        self._saved = payload.datafile

    def test_marking_data_dirty_publishes_data_has_changes_message(self):
        self.ctrl.mark_dirty()
        assert_equals(self._has_unsaved_changes, self.ctrl)

    def test_clearing_dirty_mark_publishes_data_saved_message(self):
        self.ctrl.mark_dirty()
        self.ctrl.unmark_dirty()
        assert_equals(self._saved, self.ctrl)

    def test_remarking_data_dirty_does_not_publish_data_has_changes_message(self):
        self.ctrl.mark_dirty()
        self._has_unsaved_changes = None
        self.ctrl.mark_dirty()
        assert_equals(self._has_unsaved_changes, None)

    def test_reclearing_dirty_mark_does_not_publish_data_saved_message(self):
        self.ctrl.unmark_dirty()
        self._saved = None
        self.ctrl.unmark_dirty()
        assert_equals(self._saved, None)


class TestCaseFileControllerTest(unittest.TestCase):
    SOURCE_HTML = os.path.abspath(os.path.join('tmp', '.path.with.dots', 'test.cases.html'))
    SOURCE_TXT = SOURCE_HTML.replace('.html', '.txt')

    def setUp(self):
        self.ctrl = TestCaseFileController(TestCaseFile(source=self.SOURCE_HTML))

    def test_creation(self):
        for st in self.ctrl.settings:
            assert_true(st is not None)
        assert_equals(len(self.ctrl.settings), 9)
        assert_false(self.ctrl.dirty)

    def test_has_format(self):
        assert_true(self.ctrl.has_format())

    def test_get_format(self):
        assert_equals(self.ctrl.get_format(), 'html')

    def test_source(self):
        assert_equals(self.ctrl.filename, self.SOURCE_HTML)

    def test_longname(self):
        assert_equals(self.ctrl.longname, 'Test.Cases')
        self.ctrl.parent = lambda:0
        self.ctrl.parent.longname = 'Parent'
        assert_equals(self.ctrl.longname, 'Parent.Test.Cases')

    def test_set_format(self):
        self.ctrl.set_format('txt')
        assert_equals(self.ctrl.filename, self.SOURCE_TXT)

    def test_add_test_or_kw(self):
        assert_equals(len(self.ctrl.tests), 0)
        new_test = TestCaseController(self.ctrl, TestCase(TestCaseFile(), 'New test'))
        self.ctrl.add_test_or_keyword(new_test)
        assert_equals(len(self.ctrl.tests), 1)
        assert_true(self.ctrl.tests[0]._test.parent.parent is self.ctrl.datafile)
        assert_true(self.ctrl.dirty)

    def test_new_test(self):
        test_ctrl = self.ctrl.create_test('Foo')
        assert_equals(test_ctrl.name, 'Foo')

    def test_create_keyword(self):
        kw_ctrl = self.ctrl.create_keyword('An UK')
        assert_equals(kw_ctrl.name, 'An UK')

    def test_create_keyword_with_args(self):
        kw_ctrl = self.ctrl.create_keyword('UK', '${a1} | ${a2}')
        assert_equals(kw_ctrl.name, 'UK')
        assert_equals(kw_ctrl.data.args.value, ['${a1}', '${a2}'])


class TestResourceFileControllerTest(unittest.TestCase):


    def setUp(self):
        self.chief = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH)

    def tearDown(self):
        self.chief.close()

    def _get_ctrl_by_name(self, name):
        return datafilereader.get_ctrl_by_name(name , self.chief.datafiles)

    def test_resource_file_display_name_is_file_name_with_extension(self):
        resource_ctrl = self._get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_RESOURCE_NAME)
        assert_equals(resource_ctrl.display_name, datafilereader.SIMPLE_TEST_SUITE_RESOURCE_FILE)

    def test_sort_and_restore_keywords(self):
        resource_ctrl = self._get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_RESOURCE_NAME)

        # Capture keyword list before sorting
        original_keywords = resource_ctrl.get_keyword_names()
        list_for_undo_comparison = original_keywords[:]

        # Sort the list
        resource_ctrl.execute(SortKeywords())
        sorted_keywords = resource_ctrl.get_keyword_names()
        original_keywords.sort()
        assert_equals(original_keywords, sorted_keywords)

        # Undo sorting
        resource_ctrl.execute(Undo())
        restored_list = resource_ctrl.get_keyword_names()
        assert_equals(restored_list, list_for_undo_comparison)

        # Redo sorting
        resource_ctrl.execute(Redo())
        keywords_after_redo = resource_ctrl.get_keyword_names()
        assert_equals(keywords_after_redo, sorted_keywords)


class TestDataDirectoryControllerTest(unittest.TestCase):
    TEST_CASE_FILE_PATH = os.path.abspath('path/to/suite.txt')
    INIT_FILE_PATH = os.path.abspath('path/to/__init__.txt')
    DATA_DIRECTORY_NAME = os.path.split(os.path.dirname(INIT_FILE_PATH))[-1].title()

    def setUp(self):
        self.data = TestDataDirectory(source='source')

    def test_creation(self):
        ctrl = TestDataDirectoryController(self.data)
        for st in ctrl.settings:
            assert_true(st is not None)
        assert_equals(len(ctrl.settings), 6)

    def test_has_format(self):
        ctrl = TestDataDirectoryController(self.data)
        assert_false(ctrl.has_format())
        ctrl.mark_dirty()
        assert_false(ctrl.has_format())
        ctrl.data.initfile = os.path.join('source', '__init__.html')
        assert_true(ctrl.has_format())

    def test_default_dir_is_source(self):
        self.data.initfile = os.path.join('source', '__init__.html')
        ctrl = TestDataDirectoryController(self.data)
        assert_true(ctrl.default_dir, os.path.dirname(ctrl.filename))

    def test_set_format(self):
        ctrl = TestDataDirectoryController(self.data)
        assert_false(ctrl.has_format())
        ctrl.set_format('txt')
        assert_true(ctrl.has_format())
        assert_equals(ctrl.source, os.path.abspath(os.path.join('source', '__init__.txt')))

    def test_longname(self):
        ctrl = TestDataDirectoryController(self.data)
        assert_equals(ctrl.longname, 'Source')
        ctrl.parent = lambda:0
        ctrl.parent.longname = 'Parent'
        assert_equals(ctrl.longname, 'Parent.Source')


    def test_adding_test_case_file(self):
        new_data = TestDataDirectoryController(self.data).\
                    new_test_case_file(self.TEST_CASE_FILE_PATH)
        assert_true(new_data.dirty)
        assert_true(isinstance(new_data, TestCaseFileController))
        assert_equals(new_data.filename, self.TEST_CASE_FILE_PATH)

    def test_adding_test_suite_directory(self):
        new_data = TestDataDirectoryController(self.data).\
                        new_test_data_directory(self.INIT_FILE_PATH)
        assert_true(isinstance(new_data, TestDataDirectoryController))
        assert_equals(new_data.name, self.DATA_DIRECTORY_NAME)
        assert_equals(new_data.filename, self.INIT_FILE_PATH)

    def test_adding_test_case_file_using_command(self):
        ctrl = TestDataDirectoryController(self.data)
        suite = ctrl.execute(AddTestCaseFile(self.TEST_CASE_FILE_PATH))
        assert_equals(suite.data.parent, ctrl.data)

    def test_adding_test_data_directory_using_command(self):
        ctrl = TestDataDirectoryController(self.data)
        suite = ctrl.execute(AddTestDataDirectory(self.INIT_FILE_PATH))
        assert_equals(suite.data.parent, ctrl.data)

    def test_exclude(self):
        parent = lambda:0
        chief = self._mock_chief()
        ctrl = TestDataDirectoryController(self.data, chief, parent)
        parent.children = [ctrl]
        ctrl.exclude()
        self.assertEqual(len(parent.children), 1)
        self.assertTrue(parent.children[0].is_excluded())
        self.assertTrue(self.called)

    def _mock_chief(self):
        chief = lambda:0
        chief._namespace = lambda:0
        chief.resource_file_controller_factory = lambda:0
        chief.is_datafile_dirty = lambda *_:False
        chief._settings = lambda:0
        chief._settings.excludes = lambda:0
        self.called = False
        def update_excludes(new_excludes):
            self.assertEqual(len(new_excludes), 1)
            self.assertTrue(new_excludes[0].endswith('source'))
            self.called = True
        chief._settings.excludes.update_excludes = update_excludes
        return chief

class DatafileIteratorTest(unittest.TestCase):

    def setUp(self):
        test_data_suite = TestDataDirectory(source=SUITEPATH).populate()
        self.directory_controller = TestDataDirectoryController(test_data_suite)

    def test_iterate_all(self):
        class Checker(object):
            def __init__(self):
                self.iteration_count = 0
                self.in_sub_dir = False
            def __call__(self, controller):
                self.iteration_count += 1
                print controller.filename
                if controller.filename and controller.filename.endswith('test.txt'):
                    self.in_sub_dir = True
        check_count_and_sub_dir = Checker()
        [check_count_and_sub_dir(df) for df
                in self.directory_controller.iter_datafiles()]
        assert_true(check_count_and_sub_dir.iteration_count == 5)
        assert_true(check_count_and_sub_dir.in_sub_dir)


class TestRelativePathTo(unittest.TestCase):

    def test_relative_path_to(self):
        fse1 = _FileSystemElement('foo.txt', 'bar')
        fse2 = _FileSystemElement('zoo.html', 'goo')
        self.assertEqual('../goo/zoo.html', fse1.relative_path_to(fse2))
        self.assertEqual('../bar/foo.txt', fse2.relative_path_to(fse1))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_file_rename
import os
import unittest
from robot.parsing.model import TestCaseFile

from robot.utils.asserts import assert_equals, assert_true
from robotide.controller.commands import RenameFile
from robotide.controller.filecontrollers import TestCaseFileController
from robotide.controller.validators import ERROR_ILLEGAL_CHARACTERS, ERROR_EMPTY_FILENAME, ERROR_NEWLINES_IN_THE_FILENAME, ERROR_FILE_ALREADY_EXISTS
from robotide.publish import PUBLISHER, RideFileNameChanged, RideInputValidationError


class TestRenameTestCaseFile(unittest.TestCase):
    _filenames_to_remove = []

    def setUp(self):
        PUBLISHER.subscribe(self._file_name_changed, RideFileNameChanged, "TestRenameTestCaseFile")
        PUBLISHER.subscribe(self._file_name_error, RideInputValidationError, "TestRenameTestCaseFile")
        self._clean_test_files(["quux.txt","some.txt"])

    def tearDown(self):
        self._clean_test_files()
        PUBLISHER.unsubscribe_all("TestRenameTestCaseFile")

    def _clean_test_files(self, paths = None):
        for filename in paths if paths else self._filenames_to_remove:
            try:
                os.remove(filename)
            except OSError:
                pass

    def _file_name_error(self, message):
        self._error_message = message.message

    def _file_name_changed(self, message):
        self._message = message.datafile

    def test_rename_changes_basename_but_keeps_extension(self):
        RenameFile('quux').execute(self._create_controller())
        assert_equals(self._error_message, None)
        assert_equals(self.ctrl.filename, 'quux.txt')
        assert_equals(self.ctrl.data.source, self.ctrl.filename)

    def test_rename_preserves_directory_path(self):
        RenameFile('quux').execute(self._create_controller('foo/bar.html'))
        assert_equals(self._error_message, None)
        assert_true(self.ctrl.filename.endswith(os.path.join('foo', 'quux.html')))

    def test_rename_deletes_old_path(self):
        RenameFile('quux').execute(self._create_controller())
        assert_equals(self._error_message, None)
        assert_true(self.deleted is True)

    def test_rename_saves_file(self):
        RenameFile('quux').execute(self._create_controller())
        assert_equals(self._error_message, None)
        assert_true(self.saved is True)

    def test_rename_publishes_message(self):
        RenameFile('some').execute(self._create_controller())
        assert_equals(self._error_message, None)
        assert_equals(self._message, self.ctrl)

    def test_rename_illegal_character_error(self):
        RenameFile("dsk\//\sdfj$''lkfdsjflk$'\'fdslkjlsuite....").execute(self._create_controller())
        assert_equals(self._error_message, ERROR_ILLEGAL_CHARACTERS)

    def test_rename_empty_name_error(self):
        RenameFile("").execute(self._create_controller())
        assert_equals(self._error_message, ERROR_EMPTY_FILENAME)

    def test_rename_newlines_in_name_error(self):
        RenameFile("ashdjashdhjasd\nasdads").execute(self._create_controller())
        assert_equals(self._error_message, ERROR_NEWLINES_IN_THE_FILENAME)

    def test_rename_already_existing_error(self):
        rename_command = RenameFile("jup")
        rename_command._validator._file_exists = lambda *_: True
        rename_command.execute(self._create_controller())
        assert_equals(self._error_message, ERROR_FILE_ALREADY_EXISTS % "jup.txt")

    def _create_controller(self, path='some.txt'):
        self._filenames_to_remove.append(path)
        self.ctrl = TestCaseFileController(TestCaseFile(source=path))
        self.saved = False
        self.deleted = False
        self._message = None
        self._error_message = None
        def save(*args): self.saved = True
        def remove_from_filesystem(*Args): self.deleted = True
        self.ctrl.save = save
        self.ctrl.remove_from_filesystem = remove_from_filesystem
        return self.ctrl

########NEW FILE########
__FILENAME__ = test_format_change
import os
import unittest
from mock import Mock
from robot.parsing.model import TestCaseFile, ResourceFile

from robotide.controller.chiefcontroller import ChiefController
from robotide.controller.commands import RenameResourceFile
from robotide.controller.filecontrollers import TestCaseFileController
from robotide.namespace.namespace import Namespace
from robot.utils.asserts import assert_not_none, assert_true, assert_false, assert_equals, assert_none

from resources import MINIMAL_SUITE_PATH, SUITEPATH, MessageRecordingLoadObserver, FakeSettings
from robotide.spec.librarymanager import LibraryManager


class TestFormatChange(unittest.TestCase):

    def setUp(self):
        ns = Namespace(FakeSettings())
        self.chief = ChiefControllerChecker(ns, settings=ns._settings)

    def test_format_change_to_tsv(self):
        self._test_format_change('tsv')

    def test_format_change_to_robot(self):
        self._test_format_change('robot')

    def _test_format_change(self, to_format):
        controller = self._get_file_controller(MINIMAL_SUITE_PATH)
        assert_not_none(controller)
        controller.save_with_new_format(to_format)
        self._assert_removed(MINIMAL_SUITE_PATH)
        path_with_tsv = os.path.splitext(MINIMAL_SUITE_PATH)[0] + '.'+to_format
        self._assert_serialized(path_with_tsv)

    def test_recursive_format_change(self):
        controller = self._get_file_controller(SUITEPATH)
        controller.save_with_new_format_recursive('txt')
        init_file = os.path.join(SUITEPATH,'__init__.txt')
        self._assert_serialized(init_file)
        path_to_sub_init_file = os.path.join(SUITEPATH,'subsuite','__init__.txt')
        self._assert_serialized(path_to_sub_init_file)
        path_to_old_sub_init_file = os.path.join(SUITEPATH,'subsuite','__init__.tsv')
        self._assert_removed(path_to_old_sub_init_file)
        path_to_txt_file = os.path.join(SUITEPATH,'subsuite','test.txt')
        self._assert_not_serialized(path_to_txt_file)
        self._assert_not_removed(path_to_txt_file)

    def _get_file_controller(self, path):
        self.chief.load_datafile(path, MessageRecordingLoadObserver())
        return self.chief._controller

    def _assert_serialized(self, path):
        assert_true(path in self.chief.serialized_files)

    def _assert_not_serialized(self, path):
        assert_false(path in self.chief.serialized_files)

    def _assert_removed(self, path):
        assert_true(path in self.chief.removed_files)

    def _assert_not_removed(self, path):
        assert_false(path in self.chief.removed_files)


class ChiefControllerChecker(ChiefController):

    def __init__(self, namespace, settings=None, library_manager=None):
        self.removed_files = []
        self.serialized_files = []
        library_manager = library_manager or LibraryManager(':memory:')
        if not library_manager:
            library_manager.create_database()
        ChiefController.__init__(self, namespace, settings, library_manager)

    def save(self, controller):
        self.serialized_files.append(controller.source)

    def _remove_file(self, path):
        self.removed_files.append(path)


class _UnitTestsWithWorkingResourceImports(unittest.TestCase):

    def _create_data(self, resource_name, resource_import):
        res_path = os.path.abspath(resource_name)
        tcf = TestCaseFile(source=os.path.abspath('test.txt'))
        tcf.setting_table.add_resource(resource_import)
        tcf.variable_table.add('${dirname}', os.path.abspath('.').replace('\\', '\\\\'))
        tcf.variable_table.add('${path}', os.path.abspath(resource_name).replace('\\', '\\\\'))
        library_manager = LibraryManager(':memory:')
        library_manager.create_database()
        self.chef = ChiefController(Namespace(FakeSettings()), FakeSettings(), library_manager)
        self.chef._controller = TestCaseFileController(tcf, self.chef)
        res = ResourceFile(source=res_path)
        self.res_controller = \
            self.chef._resource_file_controller_factory.create(res)
        self.chef._namespace._resource_factory.cache[os.path.normcase(res_path)] = res

    @property
    def import_setting(self):
        return self.chef._controller.imports[0]

    def _verify_import_reference(self, imp_is_resolved):
        if imp_is_resolved:
            self._verify_import_reference_exists()
        else:
            self._verify_import_reference_is_not_resolved()

    def _verify_import_reference_exists(self):
        assert_equals(self.import_setting.get_imported_controller(),
                          self.res_controller)

    def _verify_import_reference_is_not_resolved(self):
        imported_controller = self.import_setting.get_imported_controller()
        if imported_controller:
            msg = 'Resolved to source %s' % imported_controller.source
        else:
            msg = None
        assert_none(imported_controller, msg)


class TestResourceFileRename(_UnitTestsWithWorkingResourceImports):

    def test_import_is_invalidated_when_resource_file_name_changes(self):
        self._create_data('resource.txt', '${path}')
        self._verify_import_reference_exists()
        self._rename_resource('resu', False)
        self._verify_import_reference_is_not_resolved()
        assert_equals(self.import_setting.name, '${path}')

    def test_import_is_modified_when_resource_file_name_changes_and_habaa(self):
        self._create_data('fooo.txt', 'fooo.txt')
        self._verify_import_reference_exists()
        self._rename_resource('gooo', True)
        self._verify_import_reference_exists()
        assert_equals(self.import_setting.name, 'gooo.txt')

    def test_cancel_execute_when_modify_imports_is_canceled(self):
        self._create_data('fooo.txt', 'fooo.txt')
        self._verify_import_reference_exists()
        self._execute_rename_resource('gooo', None)
        assert_false(self.res_controller.remove_from_filesystem.called)
        assert_false(self.res_controller.save.called)


    def test_import_is_invalidated_when_resource_file_name_changes_and_hubaa(self):
        self._create_data('resource.txt', '${path}')
        self._verify_import_reference_exists()
        self._rename_resource('resu', True)
        self._verify_import_reference_is_not_resolved()
        assert_equals(self.import_setting.name, '${path}')

    def _execute_rename_resource(self, new_basename, boolean_variable):
        self.res_controller.remove_from_filesystem = Mock()
        self.res_controller.save = Mock()
        self.res_controller.execute(RenameResourceFile(new_basename, lambda : boolean_variable))

    def _rename_resource(self, new_basename, boolean_variable):
        self._execute_rename_resource(new_basename, boolean_variable)
        assert_true(self.res_controller.remove_from_filesystem.called)
        assert_true(self.res_controller.save.called)


class TestResourceFormatChange(_UnitTestsWithWorkingResourceImports):

    def test_imports_are_updated(self):
        self._create_data('name.txt', 'name.txt')
        self._change_format('BAR')
        self._assert_format_change('name.bar', 'name.bar')

    def test_imports_with_variables_and_path_are_updated(self):
        self._create_data('name.txt', '${dirname}${/}name.txt')
        self._change_format('cock')
        self._assert_format_change('${dirname}${/}name.cock', 'name.cock')

    def test_imports_with_only_variables(self):
        self._create_data('res.txt', '${path}')
        self._change_format('zap')
        self._assert_format_change('${path}', 'res.zap', imp_is_resolved=False)

    def _change_format(self, format):
        self.res_controller.set_format(format)

    def _assert_format_change(self, import_name, resource_path,
                              imp_is_resolved=True):
        imp = self.import_setting
        assert_equals(imp.name, import_name)
        assert_equals(self.res_controller.filename, os.path.abspath(resource_path))
        self._verify_import_reference(imp_is_resolved)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_for_loop
import unittest
import datafilereader
from robotide.controller.cellinfo import CellType
from robotide.controller.commands import MoveRowsDown, Undo, ChangeCellValue, InsertCell, DeleteCell, Purify, MoveRowsUp
from robotide.controller.stepcontrollers import ForLoopStepController, IntendedStepController, StepController


class TestForLoop(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.chief = datafilereader.construct_chief_controller(datafilereader.FOR_LOOP_PATH)

    @classmethod
    def tearDownClass(cls):
        cls.chief.close()

    def test_for_loop_move_with_undo_preserves_correct_celltype(self):
        test = self.chief.datafiles[1].tests[0]
        test.execute(MoveRowsDown([0]))
        test.execute(MoveRowsDown([1]))
        self.assertEqual(test.get_cell_info(1,1).cell_type, CellType.ASSIGN)
        test.execute(Undo())
        test.execute(Undo())
        self.assertEqual(test.get_cell_info(1,1).cell_type, CellType.KEYWORD)

    def test_adding_new_for_loop(self):
        test2 = self.chief.datafiles[1].tests[1]
        test2.execute(ChangeCellValue(0, 0, ':FOR'))
        self.assertTrue(isinstance(test2.step(0), ForLoopStepController),
            'wrong type of step type (%s)' % type(test2.step(0)))

    def test_adding_step_to_for_loop(self):
        test = self.chief.datafiles[1].tests[0]
        test.execute(ChangeCellValue(4, 1, 'No Operation'))
        self.assertTrue(isinstance(test.step(4), IntendedStepController),
            'wrong type of step type (%s)' % type(test.step(4)))

    def test_removing_step_in_middle_from_for_loop(self):
        test = self.chief.datafiles[1].tests[5]
        test.execute(ChangeCellValue(2, 0, 'Something'))
        self._steps_are_in_for_loop(test, 1)
        self._steps_are_not_in_for_loop(test, 2, 3)
        self._steps_first_cells_are_empty(test, 1, 3)

    def _steps_first_cells_are_empty(self, macro, *steps):
        for i in steps:
            self.assertEqual(macro.step(i).get_value(0), '')

    def test_removing_first_step_from_for_loop(self):
        test = self.chief.datafiles[1].tests[6]
        test.execute(ChangeCellValue(1, 0, 'Invalidate all'))
        self._steps_are_not_in_for_loop(test, 1, 2, 3)
        self._steps_first_cells_are_empty(test, 2, 3)

    def test_removing_last_step_from_for_loop(self):
        test = self.chief.datafiles[1].tests[7]
        test.execute(ChangeCellValue(3, 0, 'Something'))
        self._steps_are_in_for_loop(test, 1, 2)
        self._steps_are_not_in_for_loop(test, 3)
        self._steps_first_cells_are_empty(test, 1, 2)

    def test_modify_step_so_that_it_becomes_part_of_for_loop_at_first_position(self):
        test = self.chief.datafiles[1].tests[3]
        test.execute(InsertCell(1, 0))
        self._steps_are_in_for_loop(test, 1, 2, 3)

    def test_modify_step_so_that_it_becomes_part_of_for_loop_at_middle_position(self):
        test = self.chief.datafiles[1].tests[2]
        test.execute(InsertCell(2, 0))
        self._steps_are_in_for_loop(test, 1, 2, 3)

    def test_modify_step_so_that_it_becomes_part_of_for_loop_at_last_position(self):
        test = self.chief.datafiles[1].tests[4]
        test.execute(InsertCell(3, 0))
        self._steps_are_in_for_loop(test, 1, 2, 3)

    def test_modify_last_step_so_that_it_should_be_empty_and_not_part_of_for_loop(self):
        test = self.chief.datafiles[1].tests[8]
        test.execute(ChangeCellValue(2, 0, ''))
        self._steps_are_not_in_for_loop(test, 2)

    def test_empty_normal_step_first_cell(self):
        test = self.chief.datafiles[1].tests[9]
        test.execute(ChangeCellValue(0, 0, ''))
        self._steps_are_not_in_for_loop(test, 0)

    def _steps_are_in_for_loop(self, macro, *steps):
        for i in steps:
            self.assertEqual(type(macro.step(i)), IntendedStepController, 'Wrong type in index %d' % i)

    def _steps_are_not_in_for_loop(self, macro, *steps):
        for i in steps:
            self.assertEqual(type(macro.step(i)), StepController, 'Wrong type in index %d' % i)

    def test_modifying_step_in_for_loop(self):
        test = self.chief.datafiles[1].tests[0]
        test.execute(ChangeCellValue(3, 1, 'Something again'))
        self.assertEqual(type(test.step(3)), IntendedStepController)

    def test_new_for_loop(self):
        test = self.chief.datafiles[1].tests[10]
        test.execute(ChangeCellValue(0, 0, ': FOR'))
        test.execute(ChangeCellValue(0, 1, '${i}'))
        test.execute(ChangeCellValue(0, 2, 'IN RANGE'))
        test.execute(ChangeCellValue(0, 3, '100'))
        self.assertEqual(test.steps[0].as_list(), [':FOR', '${i}', 'IN RANGE', '100'])
        self.assertEqual(type(test.steps[0]), ForLoopStepController)

    def test_for_loop_creation_and_steps(self):
        test = self.chief.datafiles[1].tests[11]
        test.execute(ChangeCellValue(0, 0, ': FOR'))
        self._steps_are_in_for_loop(test, 1, 2, 3)

    def test_for_loop_shift_left(self):
        test = self.chief.datafiles[1].tests[12]
        test.execute(ChangeCellValue(0, 0, ': FOR'))
        test.execute(DeleteCell(0,0))
        self.assertEqual(type(test.steps[0]), StepController)

    def test_for_loop_change_and_purify(self):
        test = self.chief.datafiles[1].tests[13]
        test.execute(ChangeCellValue(1, 2, ''))
        test.execute(Purify())
        self._steps_are_in_for_loop(test, 2)

    def test_adding_comment(self):
        test = self.chief.datafiles[1].tests[14]
        test.execute(ChangeCellValue(1, 2, '# comment'))
        self.assertEqual(test.steps[1].as_list(), ['', 'No Operation', '# comment'])
        test.execute(ChangeCellValue(1, 2, '##comment'))
        self.assertEqual(test.steps[1].as_list(), ['', 'No Operation', '##comment'])

    def test_comment_is_preserved_when_shifting_row_to_left_and_back(self):
        test = self.chief.datafiles[1].tests[15]
        test.execute(DeleteCell(2,0))
        self.assertEqual(test.steps[2].as_list(), ['Keyword', '# comment'])
        test.execute(InsertCell(2,0))
        self.assertEqual(test.steps[2].as_list(), ['', 'Keyword', '# comment'])
        test.execute(DeleteCell(1,0))
        self.assertEqual(test.steps[1].as_list(), ['Kw1', '# comment'])
        test.execute(InsertCell(1,0))
        self.assertEqual(test.steps[1].as_list(), ['', 'Kw1', '# comment'])

    def test_new_for_loop_with_existing_comment(self):
        test = self.chief.datafiles[1].tests[16]
        test.execute(ChangeCellValue(0, 2, '# comment'))
        test.execute(ChangeCellValue(0, 0, ':FOR'))
        self.assertEqual(test.steps[0].as_list(), [':FOR', '', '# comment'])
        test.execute(DeleteCell(0, 0))
        self.assertEqual(test.steps[0].as_list(), ['', '# comment'])

    def test_move_for_loop_over_another_for_loop(self):
        loop_1 = ': FOR  ${i}  IN  1  2  3  4'.split('  ')
        loop_2 = [': FOR', '${j}', 'IN RANGE', '100']
        inside_1 = ['', 'No Operation']
        inside_2 = ['', 'Fail']
        test = self.chief.datafiles[1].tests[17]
        self._verify_steps(test.steps, loop_1, inside_1, loop_2, inside_2)
        test.execute(MoveRowsUp([2]))
        self._verify_steps(test.steps, loop_1, loop_2, inside_1, inside_2)
        test.execute(MoveRowsUp([1]))
        self._verify_steps(test.steps, loop_2, loop_1, inside_1, inside_2)
        test.execute(MoveRowsDown([0]))
        self._verify_steps(test.steps, loop_1, loop_2, inside_1, inside_2)

    def test_move_for_loop_header_between_for_loops(self):
        test = self.chief.datafiles[1].tests[18]
        test.execute(MoveRowsDown([3]))
        self.assertEqual(test.steps[4].as_list()[1], '${j}')

    def _verify_steps(self, steps, *expected):
        for step, exp in zip(steps, expected):
            self.assertEqual(step.as_list(), exp)
        self.assertEqual(len(steps), len(expected), steps)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_imports
import unittest
import datafilereader


class TestImports(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.chief = datafilereader.construct_chief_controller(datafilereader.IMPORTS)
        suite = cls.chief.data.suites[1]
        cls.imports =  [i for i in suite.imports]

    @classmethod
    def tearDownClass(cls):
        cls.chief.close()

    def _find_by_name(self, name, data_file=None):
        data_file = data_file or self
        for i in data_file.imports:
            if i.name == name:
                return i
        raise AssertionError('No import found with name "%s"' % name)

    def _has_error(self, name):
        self.assertTrue(self._find_by_name(name).has_error(), 'Import "%s" should have error' % name)

    def _has_no_error(self, name, data_file=None):
        self.assertFalse(self._find_by_name(name, data_file).has_error(), 'Import "%s" should have no error' % name)

    def test_importing_existing_resource_has_no_error(self):
        self._has_no_error('res//existing.txt')

    def test_importing_existing_library_from_pythonpath_has_no_error(self):
        self._has_no_error('String')

    def test_importing_existing_library_with_path_has_no_error(self):
        self._has_no_error('libs//existing.py')

    def test_importing_none_existing_resource_has_error(self):
        self._has_error('res//none_existing.txt')

    def test_importing_none_existing_library_has_error(self):
        self._has_error('libs//none_existing.py')

    def test_importing_corrupted_library_has_error(self):
        self._has_error('libs//corrupted.py')

    def test_importing_system_exiting_library_has_error(self):
        self._has_error('libs//exiting.py')

    def test_resource_import_with_variable_has_no_error(self):
        self._has_no_error('${RESU}')

    def test_library_import_with_variable_has_no_error(self):
        self._has_no_error('${LIB}')

    def test_variable_import_has_no_error(self):
        self._has_no_error('vars//vars.py')

    def test_importing_none_existing_variable_file_has_error(self):
        self._has_error('vars//none_existing.py')

    def test_importing_exiting_variable_file_has_error(self):
        self._has_error('vars//exiting.py')

    def test_library_import_in_subsuite_init_file_with_relative_path_has_no_error(self):
        self._has_no_error('..//outer_lib.py', self.chief.data.suites[0])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_macro_commands
import unittest
from robot.utils.asserts import assert_equals
from robot.parsing.model import TestCaseFile

from controller.base_command_test import testcase_controller
from robotide.controller.filecontrollers import TestCaseFileController
from robotide.publish.messages import RideUserKeywordAdded, RideUserKeywordRemoved,\
    RideTestCaseAdded, RideTestCaseRemoved, RideItemNameChanged
from robotide.controller.commands import AddKeyword, RemoveMacro, Undo,\
    AddTestCase, AddKeywordFromCells, RenameTest
from robotide.publish import PUBLISHER


class _TestMacroCommands(object):

    def setUp(self):
        for listener, topic in [(self._on_keyword_added, RideUserKeywordAdded),
                                (self._on_keyword_deleted, RideUserKeywordRemoved),
                                (self._on_test_added, RideTestCaseAdded),
                                (self._on_test_deleted, RideTestCaseRemoved)]:
            PUBLISHER.subscribe(listener, topic)

    def tearDown(self):
        self._new_keyword = None
        self._deleted_keyword = None
        self._new_test = None
        self._deleted_test = None

    def _exec(self, command):
        return self._ctrl.execute(command)

    def _on_keyword_added(self, message):
        self._new_keyword = message.item

    def _on_keyword_deleted(self, message):
        self._deleted_keyword = message.item

    def _on_test_added(self, message):
        self._new_test = message.item

    def _on_test_deleted(self, message):
        self._deleted_test = message.item

    def test_add_keyword_command_with_name(self):
        new_kw_name = 'Floajask'
        self._exec(AddKeyword(new_kw_name))
        assert_equals(self._new_keyword.name, new_kw_name)
        assert_equals(self._new_keyword.arguments.value, '')

    def test_add_keyword_command_with_step(self):
        new_kw_name = 'Akjskajs'
        self._exec(AddKeywordFromCells([new_kw_name, 'foo', 'bar']))
        assert_equals(self._new_keyword.name, new_kw_name)
        assert_equals(self._new_keyword.arguments.value, '${arg1} | ${arg2}')

    def test_delete_keyword_command(self):
        new_kw_name = 'Jiihaa'
        self._exec(AddKeyword(new_kw_name))
        assert_equals(self._new_keyword.name, new_kw_name)
        self._exec(RemoveMacro(self._new_keyword))
        assert_equals(self._deleted_keyword.name, new_kw_name)

    def test_add_keyword_undo(self):
        new_kw_name = 'Jiihaa'
        self._exec(AddKeyword(new_kw_name))
        assert_equals(self._new_keyword.name, new_kw_name)
        self._exec(Undo())
        assert_equals(self._deleted_keyword.name, new_kw_name)

    def test_delete_keyword_undo(self):
        new_kw_name = 'Jiihaa'
        self._exec(AddKeyword(new_kw_name))
        self._exec(RemoveMacro(self._new_keyword))
        self._new_keyword = None
        self._exec(Undo())
        assert_equals(self._new_keyword.name, new_kw_name)

    def test_add_test(self):
        new_test_name = 'Kalle'
        self._exec(AddTestCase(new_test_name))
        assert_equals(self._new_test.name, new_test_name)

    def test_remove_test(self):
        test_name = 'Kukka'
        tc = self._exec(AddTestCase(test_name))
        self._exec(RemoveMacro(tc))
        assert_equals(self._deleted_test.name, test_name)

    def test_add_keyword(self):
        new_kw_name = 'Floajask'
        self._exec(AddKeyword(new_kw_name))
        assert_equals(self._new_keyword.name, new_kw_name)
        assert_equals(self._new_keyword.arguments.value, '')

    def test_add_keyword_with_bdd_given(self):
        self._bdd_test('Given', 'george is a dog')
        self._bdd_test('given', 'steve is a cat')

    def _bdd_test(self, prefix, new_kw_name):
        self._exec(AddKeyword(prefix + ' ' + new_kw_name))
        assert_equals(self._new_keyword.name, self._bdd_name(prefix, new_kw_name))
        assert_equals(self._new_keyword.arguments.value, '')

    def test_add_keyword_with_bdd_when(self):
        self._bdd_test('When', 'george runs')
        self._bdd_test('when', 'steve says hello')

    def test_add_keyword_with_bdd_then(self):
        self._bdd_test('Then', 'george sleeps')
        self._bdd_test('then', 'steve goes home')

    def test_add_keyword_with_bdd_and(self):
        self._bdd_test('And', 'the end')
        self._bdd_test('and', 'really no more')

class TestMacroCommandsInTestCaseContext(_TestMacroCommands, unittest.TestCase):

    def setUp(self):
        _TestMacroCommands.setUp(self)
        self._ctrl = testcase_controller()

    def _bdd_name(self, prefix, name):
        return name


class TestMacroCommandsInDataFileContext(_TestMacroCommands, unittest.TestCase):

    def setUp(self):
        _TestMacroCommands.setUp(self)
        self._ctrl = TestCaseFileController(TestCaseFile())

    def _bdd_name(self, prefix, name):
        return prefix + ' ' + name


class TestCaseRenameCommandTest(unittest.TestCase):

    def setUp(self):
        self.ctrl = testcase_controller()
        PUBLISHER.subscribe(self._test_renamed, RideItemNameChanged)

    def tearDown(self):
        PUBLISHER.unsubscribe(self._test_renamed, RideItemNameChanged)

    def _test_renamed(self, message):
        self._test = message.item

    def test_(self):
        new_name = 'New name'
        self.ctrl.execute(RenameTest(new_name))
        assert_equals(self._test.name, new_name)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_macro_controllers
import unittest
from robot.parsing.model import TestCaseFile
from robot.utils.asserts import assert_equals, assert_true, assert_false

from robotide.controller.filecontrollers import TestCaseFileController
from robotide.controller.macrocontrollers import (TestCaseController,
                                                  UserKeywordController,
                                                  StepController)
from robotide.controller.tablecontrollers import (TestCaseTableController,
                                                  KeywordTableController)


class _BaseWithSteps(unittest.TestCase):

    def _test_copy_empty(self):
        for setting in self.ctrl.settings:
            assert_false(setting.is_set, 'not empty %s' % setting.__class__)
        new = self.ctrl.copy('new name')
        for setting in new.settings:
            assert_false(setting.is_set, 'not empty %s' % setting.__class__)

    def _test_copy_content(self):
        for setting in self.ctrl.settings:
            assert_false(setting.is_set, 'not empty %s' % setting.__class__)
            setting.set_value('boo')
            setting.set_comment(['hobo'])
        new = self.ctrl.copy('new name')
        for setting in new.settings:
            assert_true(setting.is_set, 'empty %s' % setting.__class__)
            assert_equals(setting.value, 'boo', 'not boo %s' % setting.__class__)
            assert_equals(setting.comment.as_list(), ['# hobo'], 'comment not copied %s' % setting.__class__)


class TestCaseControllerTest(_BaseWithSteps):

    def setUp(self):
        self.tcf = TestCaseFile()
        self.testcase = self.tcf.testcase_table.add('Test')
        self.testcase.add_step(['Log', 'Hello'])
        self.testcase.add_step(['No Operation'])
        self.testcase.add_step(['Foo'])
        self.tcf.testcase_table.add('Another Test')
        tctablectrl = TestCaseTableController(TestCaseFileController(self.tcf),
                                              self.tcf.testcase_table)
        self.ctrl = TestCaseController(tctablectrl, self.testcase)

    def test_creation(self):
        for st in self.ctrl.settings:
            assert_true(st is not None)
        assert_true(self.ctrl.datafile is self.tcf, self.ctrl.datafile)

    def test_rename(self):
        self.ctrl.rename('Foo Barness')
        assert_equals(self.ctrl.name, 'Foo Barness')
        assert_true(self.ctrl.dirty)

    def test_rename_strips_whitespace(self):
        self.ctrl.rename('\t  \n Foo Barness        ')
        assert_equals(self.ctrl.name, 'Foo Barness')
        assert_true(self.ctrl.dirty)

    def test_copy_empty(self):
        self._test_copy_empty()

    def test_copy_content(self):
        self._test_copy_content()

    def test_add_tag(self):
        orig_num_tags = len(self.ctrl.tags.as_list())
        self.ctrl.add_tag('Some tag')
        assert_true(len(self.ctrl.tags.as_list()) == orig_num_tags + 1)


class UserKeywordControllerTest(_BaseWithSteps):

    def setUp(self):
        self.tcf = TestCaseFile()
        uk = self.tcf.keyword_table.add('UK')
        uk.add_step(['No Operation'])
        uk2 = self.tcf.keyword_table.add('UK 2')
        tablectrl = KeywordTableController(TestCaseFileController(self.tcf),
                                           self.tcf.keyword_table)
        self.ctrl = UserKeywordController(tablectrl, uk)
        self.ctrl2 = UserKeywordController(tablectrl, uk2)

    def test_keyword_settings(self):
        labels = [setting.label for setting in self.ctrl.settings]
        assert_true('Documentation' in labels)
        assert_true('Arguments' in labels)
        assert_true('Teardown' in labels)
        assert_true('Return Value' in labels)
        assert_true('Timeout' in labels)

    def test_creation(self):
        for st in self.ctrl.settings:
            assert_true(st is not None)
        assert_equals(self.ctrl.steps[0].keyword, 'No Operation')
        assert_true(self.ctrl.datafile is self.tcf)

    def test_dirty(self):
        self.ctrl.mark_dirty()
        assert_true(self.ctrl.dirty)

    def test_move_up(self):
        assert_false(self.ctrl.move_up())
        self._assert_uk_in(0, 'UK')
        assert_true(self.ctrl2.move_up())
        self._assert_uk_in(0, 'UK 2')

    def test_move_down(self):
        assert_false(self.ctrl2.move_down())
        self._assert_uk_in(1, 'UK 2')
        assert_true(self.ctrl.move_down())
        self._assert_uk_in(1, 'UK')

    def test_delete(self):
        self.ctrl.delete()
        assert_false('UK' in self.tcf.keyword_table.keywords)
        self._assert_uk_in(0, 'UK 2')

    def _assert_uk_in(self, index, name):
        assert_equals(self.tcf.keyword_table.keywords[index].name, name)

    def _assert_step(self, step, exp_assign=[], exp_keyword=None, exp_args=[]):
        assert_equals(step.assign, exp_assign)
        assert_equals(step.keyword, exp_keyword)
        assert_equals(step.args, exp_args)

    def test_copy_empty(self):
        self._test_copy_empty()

    def test_copy_content(self):
        self._test_copy_content()


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_modifications_on_disk
import random
import unittest
import os
import tempfile
from robot.utils.asserts import assert_true, assert_false, assert_equals
from robot.parsing.model import TestCaseFile, TestDataDirectory, ResourceFile
from resources.mocks import FakeSettings
from robotide.controller.commands import DeleteResourceAndImports, DeleteFile, SaveFile

from robotide.controller.filecontrollers import (TestCaseFileController,
                                                 TestDataDirectoryController,
                                                 ResourceFileController)
from robotide.controller import ChiefController
from robotide.publish.messages import RideDataFileRemoved
from robotide.publish import PUBLISHER
import shutil
from robotide.namespace.namespace import Namespace
from robotide.spec.librarymanager import LibraryManager

def create_test_data(path, filepath, resourcepath, initpath):
    if not os.path.exists(path):
        os.mkdir(path)
    open(filepath, 'w').write('''\
*Settings*
Resource  resource.txt
*Test Cases*
Ride Unit Test  No Operation
''')
    open(resourcepath, 'w').write('*Keywords*\nUnit Test Keyword  No Operation\n')
    open(initpath, 'w').write('''\
*Settings*
Documentation  Ride unit testing file
''')

def remove_test_data(path):
    shutil.rmtree(path)

def create_chief():
    library_manager = LibraryManager(':memory:')
    library_manager.create_database()
    return ChiefController(Namespace(FakeSettings()), FakeSettings(), library_manager)


class _DataDependentTest(unittest.TestCase):

    def setUp(self):
        self._dirpath = os.path.join(tempfile.gettempdir(), 'ride_controller_utest_dir'+str(random.randint(0,100000000)))
        self._filepath = os.path.join(self._dirpath, 'tests.txt')
        self._resource_path = os.path.join(self._dirpath, 'resource.txt')
        self._init_path = os.path.join(self._dirpath, '__init__.txt')
        create_test_data(self._dirpath, self._filepath, self._resource_path, self._init_path)

    def tearDown(self):
        remove_test_data(self._dirpath)


class TestModifiedOnDiskWithFileSuite(_DataDependentTest):

    def test_mtime(self):
        ctrl = TestCaseFileController(TestCaseFile(source=self._filepath).populate())
        assert_false(ctrl.has_been_modified_on_disk())
        os.utime(self._filepath, (1,1))
        assert_true(ctrl.has_been_modified_on_disk())

    def test_size_change(self):
        os.utime(self._filepath, None)
        ctrl = TestCaseFileController(TestCaseFile(source=self._filepath).populate())
        open(self._filepath, 'a').write('#Ninja edit\n')
        assert_true(ctrl.has_been_modified_on_disk())

    def test_reload(self):
        controller_parent = object()
        model_parent = object()
        ctrl = TestCaseFileController(
            TestCaseFile(parent=model_parent, source=self._filepath).populate(),
            parent=controller_parent)
        assert_equals(len(ctrl.tests), 1)
        open(self._filepath, 'a').write('Second Test  Log  Hello World!\n')
        ctrl.reload()
        assert_equals(len(ctrl.tests), 2)
        assert_equals(ctrl.tests[-1].name, 'Second Test')
        assert_equals(ctrl.parent, controller_parent)
        assert_equals(ctrl.data.parent, model_parent)

    def test_overwrite(self):
        ctrl = TestCaseFileController(TestCaseFile(source=self._filepath).populate(),
                                      create_chief())
        os.utime(self._filepath, (1,1))
        assert_true(ctrl.has_been_modified_on_disk())
        ctrl.execute(SaveFile())
        assert_false(ctrl.has_been_modified_on_disk())


class TestModifiedOnDiskWithDirectorySuite(_DataDependentTest):

    def test_reload_with_directory_suite(self):
        model_parent = object()
        controller_parent = object()
        ctrl = TestDataDirectoryController(TestDataDirectory(source=self._dirpath, parent=model_parent).populate(),
            parent=controller_parent)
        open(self._init_path, 'a').write('...  ninjaed more documentation')
        ctrl.reload()
        assert_equals(ctrl.settings[0].value,
                      'Ride unit testing file\\nninjaed more documentation')
        assert_equals(ctrl.parent, controller_parent)
        assert_equals(ctrl.data.parent, model_parent)

    def test_mtime_with_directory_suite(self):
        ctrl = TestDataDirectoryController(TestDataDirectory(source=self._dirpath).populate())
        assert_false(ctrl.has_been_modified_on_disk())
        os.utime(self._init_path, (1,1))
        assert_true(ctrl.has_been_modified_on_disk())


class TestModifiedOnDiskWithresource(_DataDependentTest):

    def test_reload_with_resource(self):
        controller_parent = lambda:0
        controller_parent.children = []
        controller_parent.add_child = controller_parent.children.append
        ctrl = ResourceFileController(ResourceFile(source=self._resource_path).populate(), parent=controller_parent)
        assert_equals(len(ctrl.keywords), 1)
        open(self._resource_path, 'a').write('Ninjaed Keyword  Log  I am taking over!\n')
        ctrl.reload()
        assert_equals(len(ctrl.keywords), 2)
        assert_equals(ctrl.keywords[-1].name, 'Ninjaed Keyword')
        assert_equals(ctrl.parent, controller_parent)


class TestDataFileRemoval(_DataDependentTest):

    def setUp(self):
        _DataDependentTest.setUp(self)
        PUBLISHER.subscribe(self._datafile_removed, RideDataFileRemoved)

    def tearDown(self):
        _DataDependentTest.tearDown(self)
        PUBLISHER.unsubscribe(self._datafile_removed, RideDataFileRemoved)

    def _datafile_removed(self, message):
        self._removed_datafile = message.datafile

    def test_deleting_source_should_remove_it_from_model(self):
        chief = create_chief()
        chief._controller = TestCaseFileController(TestCaseFile(source=self._filepath), chief)
        os.remove(self._filepath)
        ctrl = chief.data
        ctrl.remove()
        assert_true(chief.data is None)
        assert_true(self._removed_datafile is ctrl)

    def test_deleting_file_suite_under_dir_suite(self):
        chief = create_chief()
        chief._controller = TestDataDirectoryController(TestDataDirectory(source=self._dirpath).populate(), chief)
        original_children_length = len(chief.data.children)
        file_suite = chief.data.children[0]
        file_suite.remove()
        assert_true(len(chief.data.children) == original_children_length-1, 'Child suite was not removed')

    def test_deleting_resource_file(self):
        chief = create_chief()
        res = chief.new_resource(self._resource_path)
        res.remove()
        assert_true(len(chief.resources) == 0, 'Resource was not removed')

    def test_deleting_init_file(self):
        chief = create_chief()
        chief._controller = TestDataDirectoryController(TestDataDirectory(source=self._dirpath).populate(), chief)
        os.remove(self._init_path)
        chief.data.remove()
        open(self._init_path, 'w').write('*Settings*\nDocumentation  Ride unit testing file\n')
        assert_true(chief.data.has_format() is False, chief.data.data.initfile)


class DeleteCommandTest(_DataDependentTest):

    def setUp(self):
        _DataDependentTest.setUp(self)
        self.chief = create_chief()
        self.chief.load_data(self._dirpath)
        self.suite = self.chief.suite.children[0]
        self.resource = self.chief.resources[0]

    def test_delete_resource_and_imports(self):
        self.assert_resource_count(1)
        self.assert_import_count(1)
        self.resource.execute(DeleteResourceAndImports())
        self.assert_resource_count(0)
        self.assert_import_count(0)

    def test_delete_file(self):
        self.assert_resource_count(1)
        self.assert_import_count(1)
        self.resource.execute(DeleteFile())
        self.assert_resource_count(0)
        self.assert_import_count(1)

    def assert_resource_count(self, resource_count):
        assert_equals(len(self.chief.resources), resource_count)

    def assert_import_count(self, import_count):
        assert_equals(len(self.suite.setting_table.imports), import_count)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_modification_prevention
import unittest
from robotide.controller.basecontroller import _BaseController
from robotide.controller.commands import _Command
from robotide.controller.filecontrollers import TestCaseFileController, ResourceFileController
from robotide.controller.macrocontrollers import UserKeywordController, TestCaseController
from robotide.controller.settingcontrollers import _SettingController, LibraryImportController, ResourceImportController
from robotide.controller.stepcontrollers import StepController
from robotide.controller.tablecontrollers import VariableTableController
from robotide.publish import PUBLISHER
from robotide.publish.messages import RideModificationPrevented


class _Controller(_BaseController):

    modifiable = False

    def is_modifiable(self):
        return self.modifiable


class _ModifyingCommand(_Command):

    executed = False

    def execute(self, context):
        self.executed = True


class _SomeSetting(_SettingController):

    def _init(self, *args):
        pass


class ModificationPreventionTestCase(unittest.TestCase):

    def setUp(self):
        self._controller = _Controller()
        self._reset_command()
        PUBLISHER.subscribe(self._modification_prevented, RideModificationPrevented)

    def tearDown(self):
        PUBLISHER.unsubscribe(self._modification_prevented, RideModificationPrevented)

    def _reset_command(self):
        self._command = _ModifyingCommand()
        self._modification_prevented_controller = None

    def _modification_prevented(self, message):
        self._modification_prevented_controller = message.controller

    def test_modification_prevented(self):
        self._execution_prevented()

    def test_modification_allowed(self):
        self._controller.modifiable = True
        self._execution_allowed()

    def test_nonmodifying_command_is_not_prevented(self):
        self._command.modifying = False
        self._execution_allowed()

    def test_nonmodifying_command_implies_no_is_modifiable_call(self):
        self._command.modifying = False
        def no_call():
            raise AssertionError('Should not be called')
        self._controller.is_modifiable = no_call
        self._execution_allowed()

    def test_nonmodifying_command_and_modifications_allowed(self):
        self._command.modifying = False
        self._controller.modifiable = True
        self._execution_allowed()

    def test_test_case_file_modifications_are_prevented_when_file_is_read_only(self):
        self._use_testcasefilecontroller()
        self._controller.is_readonly = lambda: True
        self._execution_prevented()

    def test_test_case_file_modifications_are_allowed_when_file_is_not_read_only(self):
        self._use_testcasefilecontroller()
        self._controller.is_readonly = lambda: False
        self._execution_allowed()

    def test_test_case_file_modifications_are_allowed_when_file_does_not_exist(self):
        self._use_testcasefilecontroller()
        self._controller.exists = lambda: False
        self._execution_allowed()

    def test_resource_file_modifications_are_prevented_when_file_is_read_only(self):
        self._use_resourcefilecontroller()
        self._controller.is_readonly = lambda: True
        self._execution_prevented()

    def test_resource_file_modifications_are_allowed_when_file_is_not_read_only(self):
        self._use_resourcefilecontroller()
        self._controller.is_readonly = lambda: False
        self._execution_allowed()

    def test_resource_file_modifications_are_allowed_when_file_does_not_exist(self):
        self._use_resourcefilecontroller()
        self._controller.exists = lambda: False
        self._execution_allowed()

    def test_settings_are_modifiable_equals_file_is_modifiable(self):
        data = lambda:0
        data.setting_name = 'some setting'
        self._verify_controller_obeys_datafile_modifiability(_SomeSetting, data)

    def test_steps_are_modifiable_equals_file_is_modifiable(self):
        self._verify_controller_obeys_datafile_modifiability(UserKeywordController)
        self._verify_controller_obeys_datafile_modifiability(TestCaseController)

    def test_step_is_modifiable_equals_file_is_modifiable(self):
        data = lambda:0
        data.args = []
        data.comment = None
        self._verify_controller_obeys_datafile_modifiability(StepController, data)

    def test_imports_are_modifiable_equals_file_is_modifiable(self):
        data = lambda:0
        data.type = None
        self._verify_controller_obeys_datafile_modifiability(LibraryImportController, data)
        self._verify_controller_obeys_datafile_modifiability(ResourceImportController, data)

    def test_variables_are_modifiable_equals_file_is_modifiable(self):
        self._verify_controller_obeys_datafile_modifiability(VariableTableController)

    def _verify_controller_obeys_datafile_modifiability(self, controller_class, data=None):
        controller = controller_class(self._parent_with_datafile(), data or (lambda:0))
        controller.datafile_controller.is_modifiable = lambda: False
        self._controller = controller
        self.assertFalse(controller.is_modifiable())
        self._reset_command()
        self._execution_prevented()
        controller.datafile_controller.is_modifiable = lambda: True
        self.assertTrue(controller.is_modifiable())
        self._reset_command()
        self._execution_allowed()

    def _parent_with_datafile(self):
        parent = lambda:0
        parent.datafile_controller = lambda:0
        parent.datafile_controller.register_for_namespace_updates = lambda *args:0
        return parent

    def _use_resourcefilecontroller(self):
        self._create_ctrl(ResourceFileController)

    def _use_testcasefilecontroller(self):
        self._create_ctrl(TestCaseFileController)

    def _create_ctrl(self, clazz):
        data = lambda:0
        data.source = ''
        data.directory = ''
        self._controller = clazz(data)
        self._controller.exists = lambda: True

    def _execution_prevented(self):
        self._controller.execute(self._command)
        self.assertFalse(self._command.executed)
        self.assertEqual(self._controller, self._modification_prevented_controller)

    def _execution_allowed(self):
        self._controller.execute(self._command)
        self.assertTrue(self._command.executed)
        self.assertEqual(None, self._modification_prevented_controller)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_move_command
import unittest
import datafilereader
from robot.utils.asserts import assert_true, assert_false, assert_equals
from robotide.controller.commands import MoveTo


class TestMoveCommand(unittest.TestCase):

    # NOTE! The data is shared among tests and they change the data
    # This is for performance reasons but be warned when you add tests!
    @classmethod
    def setUpClass(cls):
        cls.chief_ctrl = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH)
        cls.ts1 = datafilereader.get_ctrl_by_name('TestSuite1', cls.chief_ctrl.datafiles)
        cls.ts2 = datafilereader.get_ctrl_by_name('TestSuite2', cls.chief_ctrl.datafiles)
        cls.resu = datafilereader.get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_RESOURCE_NAME, cls.chief_ctrl.datafiles)

    @classmethod
    def tearDownClass(cls):
        cls.chief_ctrl.close()
        cls.chief_ctrl = None

    def test_move_variable_from_suite_to_another_suite(self):
        self._move_variable(self.ts1.variables[0], self.ts1, self.ts2)

    def test_move_variable_from_suite_to_resource_file(self):
        self._move_variable(self.ts1.variables[0], self.ts1, self.resu)

    def test_move_variable_from_resource_to_suite(self):
        self._move_variable(self.resu.variables[0], self.resu, self.ts2)

    def _move_variable(self, what, from_where, to_where):
        what.execute(MoveTo(to_where))
        name, value = what.name, what.value
        assert_true((name, value) in [(v.name,v.value) for v in to_where.variables])
        assert_false((name, value) in [(v.name,v.value) for v in from_where.variables])

    def test_move_testcase_from_suite_to_another_suite(self):
        test_from_suite2 = self.ts2.tests[1]
        len_before = len(self.ts2.tests)
        test_from_suite2.execute(MoveTo(self.ts1))
        assert_equals(test_from_suite2, self.ts1.tests[1])
        assert_equals(len(self.ts2.tests), len_before-1)

    def test_move_keyword_from_suite_to_another_suite(self):
        kw_from_suite1 = self.ts1.keywords[1]
        kw_from_suite1.execute(MoveTo(self.ts2))
        self._verify_namespace_works()
        assert_equals(kw_from_suite1, self.ts2.keywords[-1])
        assert_equals(len(self.ts1.keywords), 1)

    def test_move_keyword_from_suite_to_resource(self):
        kw_from_suite2 = self.ts2.keywords[1]
        kw_from_suite2.execute(MoveTo(self.resu))
        self._verify_namespace_works()
        assert_equals(kw_from_suite2, self.resu.keywords[-1])

    def test_move_keyword_from_resource_to_suite(self):
        kw_from_resu = self.resu.keywords[-1]
        resu_len, ts2_len = len(self.resu.keywords), len(self.ts2.keywords)
        kw_from_resu.execute(MoveTo(self.ts2))
        self._verify_namespace_works()
        resu_len2, ts2_len2 = len(self.resu.keywords), len(self.ts2.keywords)
        assert_equals(resu_len, resu_len2+1)
        assert_equals(ts2_len+1, ts2_len2)

    def _verify_namespace_works(self):
        self.ts1.tests[0].get_cell_info(0,0)
        self.ts2.tests[0].get_cell_info(0,0)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_new_datafile_controller
import os
import tempfile
import unittest

from robot.utils.asserts import assert_true, assert_equals
from robotide.controller.robotdata import NewTestCaseFile, NewTestDataDirectory


class NewDataFileTest(unittest.TestCase):

    def test_creating_new_datafile(self):
        ctrl = NewTestCaseFile('./foo.txt')
        assert_equals(ctrl.name, 'Foo')

    def test_creating_directory_data(self):
        dirname = os.path.dirname(os.path.abspath(__file__))
        initpath = os.path.join(dirname, '__init__.html')
        ctrl = NewTestDataDirectory(initpath)
        assert_equals(ctrl.name, 'Controller')

    def test_creating_new_data_created_missing_subdirs(self):
        dirname = os.path.join(tempfile.gettempdir(), 'rideutest-newdirectory')
        if os.path.isdir(dirname):
            os.rmdir(dirname)
        ctrl = NewTestCaseFile(os.path.join(dirname, 'mynew_tcf.html'))
        assert_equals(ctrl.name, 'Mynew Tcf')
        assert_true(os.path.isdir(dirname))
        os.rmdir(dirname)

########NEW FILE########
__FILENAME__ = test_occurrences
import unittest
from robot.parsing.model import TestCaseFile

from robot.utils.asserts import assert_equals, assert_true, assert_false
from resources import FakeSettings
from robotide.controller import ChiefController
from robotide.controller.macrocontrollers import KEYWORD_NAME_FIELD
from robotide.controller.commands import Undo, FindOccurrences, FindVariableOccurrences, NullObserver, RenameKeywordOccurrences, ChangeCellValue
from robotide.controller.filecontrollers import (TestCaseFileController,
                                                 TestCaseTableController,
                                                 TestCaseController)
from robotide.publish import PUBLISHER
from robotide.publish.messages import RideItemStepsChanged, RideItemSettingsChanged,\
    RideItemNameChanged
from robotide.namespace.namespace import Namespace
import datafilereader
from robotide.spec.librarymanager import LibraryManager
from robotide.usages.commands import FindUsages


STEP1_KEYWORD = 'Log'
STEP2_ARGUMENT = 'No Operation'
TEST1_NAME = 'Test'
UNUSED_KEYWORD_NAME = 'Foo'
USERKEYWORD1_NAME = 'User Keyword'
USERKEYWORD2_NAME = 'Juuser kei woord'
SETUP_KEYWORD = 'Setup Kw'
TEMPLATE_KEYWORD = 'Template Kw'
SUITE_SETUP_KEYWORD = 'Suite Setup Kw'
SUITE_TEST_SETUP_KEYWORD = 'Test Setup Kw'
SUITE_TEST_TEMPLATE_KEYWORD = 'Test Template Kw'
SUITE_NAME = 'Some Suite'
KEYWORD_IN_USERKEYWORD1 = 'Some Keyword'
EMBEDDED_ARGUMENTS_KEYWORD = "Pick '${fruit}' and '${action}' it"

def TestCaseControllerWithSteps(chief=None, source='some_suite.txt'):
    tcf = TestCaseFile()
    tcf.source = source
    tcf.setting_table.suite_setup.name = 'Suite Setup Kw'
    tcf.setting_table.test_setup.name = SUITE_TEST_SETUP_KEYWORD
    tcf.setting_table.test_teardown.name = 'Test Teardown Kw'
    tcf.setting_table.suite_teardown.name = 'Suite Teardown Kw'
    tcf.setting_table.test_template.value = SUITE_TEST_TEMPLATE_KEYWORD
    testcase = _create_testcase(tcf)
    uk = tcf.keyword_table.add(USERKEYWORD1_NAME)
    uk.add_step([KEYWORD_IN_USERKEYWORD1])
    uk = tcf.keyword_table.add(USERKEYWORD2_NAME)
    uk.add_step(['No Operation'])
    uk = tcf.keyword_table.add(EMBEDDED_ARGUMENTS_KEYWORD)
    uk.add_step(['No Operation'])
    if chief is None:
        library_manager = LibraryManager(':memory:')
        library_manager.create_database()
        chief = ChiefController(Namespace(FakeSettings()), library_manager=library_manager)
    tcf_ctrl = TestCaseFileController(tcf, chief)
    chief._controller = tcf_ctrl
    tctablectrl = TestCaseTableController(tcf_ctrl,
                                          tcf.testcase_table)
    return TestCaseController(tctablectrl, testcase), chief._namespace

def _create_testcase(tcf):
    testcase = tcf.testcase_table.add(TEST1_NAME)
    for step in [[STEP1_KEYWORD, 'Hello'],
                 ['Run Keyword', STEP2_ARGUMENT],
                 [USERKEYWORD2_NAME],
                 ["Pick 'apple' and 'peel' it"]]:
        testcase.add_step(step)
    for_loop = testcase.add_for_loop([': FOR', '${i}', 'IN RANGE', '10'])
    for_loop.add_step(['Log', '${i}'])
    testcase.setup.name = SETUP_KEYWORD
    testcase.teardown.name = 'Teardown Kw'
    testcase.template.value = TEMPLATE_KEYWORD
    return testcase


def assert_occurrence(test_ctrl, kw_name, expected_source, expected_usage):
    occ = _first_occurrence(test_ctrl, kw_name)
    assert_equals(occ.location, expected_source, 'Occurrence not in the right place')
    assert_equals(occ.usage, expected_usage, 'Usage not in the right place')

def assert_variable_occurrence(occurrences, source, usage, count):
    times_found = 0
    for occ in occurrences:
        if occ.location == source and occ.usage == usage:
            times_found += 1
    assert_equals(times_found, count)

def check_for_variable_occurrences(test_ctrl, name, expected_occurrences):
    occurrences = list(test_ctrl.execute(FindVariableOccurrences(name)))
    processed_occurrences = 0
    for source, usage, count in expected_occurrences:
        assert_variable_occurrence(occurrences, source, usage, count)
        processed_occurrences += count
    assert_equals(processed_occurrences, len(occurrences))

def _first_occurrence(test_ctrl, kw_name):
    occurrences = test_ctrl.execute(FindOccurrences(kw_name))
    if not occurrences:
        raise AssertionError('No occurrences found for "%s"' % kw_name)
    return occurrences.next()

def _get_ctrl_by_name(self, name, datafiles):
    for file in datafiles:
        if file.name == name:
            return file
        for test in file.tests:
            if test.name == name:
                return test
        for kw in file.keywords:
            if kw.name == name:
                return kw
    return None


class TestFindOccurrencesWithFiles(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.chief_ctrl = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH)
        cls.ts1 = datafilereader.get_ctrl_by_name('TestSuite1', cls.chief_ctrl.datafiles)
        cls.ts2 = datafilereader.get_ctrl_by_name('TestSuite2', cls.chief_ctrl.datafiles)
        cls.ts3 = datafilereader.get_ctrl_by_name('TestSuite3', cls.chief_ctrl.datafiles)
        cls.resu = datafilereader.get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_RESOURCE_NAME, cls.chief_ctrl.datafiles)

    @classmethod
    def tearDownClass(cls):
        cls.chief_ctrl.close()

    def test_finds_only_occurrences_with_same_source(self):
        self.assert_occurrences(self.ts1, 'My Keyword', 2)
        self.assert_occurrences(self.ts2, 'My Keyword', 3)
        self.assert_occurrences(self.resu, 'My Keyword', 3)

    def test_first_occurrences_are_from_the_same_file(self):
        occ = self.resu.execute(FindOccurrences('My Keyword'))
        assert_true(self.resu.filename.endswith(occ.next().item.parent.source))
        assert_equals(occ.next().source, self.ts2.source)
        assert_equals(occ.next().source, self.ts2.source)

    def test_finds_occurrences_that_are_unrecognized(self):
        self.assert_occurrences(self.ts1, 'None Keyword', 2)
        self.assert_occurrences(self.ts2, 'None Keyword', 4)

    def test_finds_occurrences_that_override_builtin(self):
        self.assert_occurrences(self.ts1, 'Log', 1)
        self.assert_occurrences(self.ts2, 'Log', 2)

    def test_ignores_definition_in_base_resource(self):
        self.assert_occurrences(self.resu, 'Keyword In Both Resources', 1)
        occ = _first_occurrence(self.resu, 'Keyword In Both Resources')
        assert_equals(occ.item.parent.source, 'inner_resource.txt')

    def test_rename_resu_occurrence_in_case_of_double_definition(self):
        old_name = 'Keyword In Both Resources'
        new_name = 'FiiFaa'
        for kw in [k for k in self.resu.keywords if k.name == old_name]:
            self.resu.execute(RenameKeywordOccurrences(kw.name, new_name, NullObserver(), kw.info))
            assert_equals(kw.name, new_name)

    def test_rename_embedded_arguments_keyword_but_dont_rename_occurrences(self):
        old_name = 'embedded ${args} keyword'
        new_name = 'unembedded keyword'
        self.assert_occurrences(self.ts3, old_name, 2)
        self.assert_occurrences(self.ts3, new_name, 0)
        self.ts3.execute(RenameKeywordOccurrences(old_name, new_name, NullObserver()))
        self.assert_occurrences(self.ts3, old_name, 1)
        self.assert_occurrences(self.ts3, new_name, 1)

    def test_rename_embedded_arguments_keyword_with_another_embedded_arguments_keyword(self):
        old_name = '2nd embedded ${args} keyword'
        new_name = '2nd embedded args keyword with ${trailing args}'
        self.assert_occurrences(self.ts3, old_name, 2)
        self.assert_occurrences(self.ts3, new_name, 0)
        self.ts3.execute(RenameKeywordOccurrences(old_name, new_name, NullObserver()))
        self.assert_occurrences(self.ts3, old_name, 1)
        self.assert_occurrences(self.ts3, new_name, 1)

    def test_finding_from_test_setup_with_run_keyword(self):
        self._assert_usage('Test Setup Keyword', 'Setup')

    def test_finding_from_suite_setup_with_run_keyword(self):
        self._assert_usage('Suite Setup Keyword', 'Suite Setup')

    def test_finding_from_test_teardown_with_run_keyword(self):
        self._assert_usage('Test Teardown Keyword', 'Teardown')

    def test_finding_from_keyword_teardown(self):
        self._assert_usage('Keyword Teardown Keyword', 'Teardown')

    def test_finding_from_test_teardown_in_settings(self):
        self._assert_usage('Test Teardown in Setting', 'Test Teardown')

    def test_occurrences_in_suite_documentation_should_not_be_found(self):
        self._assert_no_usages('suitedocmatch')

    def test_occurrences_in_test_documentation_should_not_be_found(self):
        self._assert_no_usages('testdocmatch')

    def test_occurrences_in_keyword_documentation_should_not_be_found(self):
        self._assert_no_usages('keyworddocmatch')

    def _assert_usage(self, keyword, usage):
        occ = list(self.ts2.execute(FindUsages(keyword)))
        self.assertEqual(len(occ), 1)
        self.assertEqual(occ[0].usage, usage)

    def _assert_no_usages(self, keyword):
        self.assertEqual(list(self.ts2.execute(FindUsages(keyword))), [])

    def assert_occurrences(self, ctrl, kw_name, count):
        assert_equals(sum(1 for _ in ctrl.execute(FindOccurrences(kw_name))), count)


class FindOccurrencesTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.test_ctrl, cls.namespace = TestCaseControllerWithSteps()

    def test_no_occurrences(self):
        find_occurrences = FindOccurrences('Keyword Name')
        occurrences = self.test_ctrl.execute(find_occurrences)
        assert_equals([i for i in occurrences], [])

    def test_occurrences_in_steps(self):
        assert_occurrence(self.test_ctrl, STEP1_KEYWORD, TEST1_NAME, 'Steps')

    def test_occurrences_in_step_arguments(self):
        assert_occurrence(self.test_ctrl, STEP2_ARGUMENT, TEST1_NAME, 'Steps')

    def test_occurrences_are_case_and_space_insensitive(self):
        assert_occurrence(self.test_ctrl, 'R un KE Y W O rd', TEST1_NAME, 'Steps')
        assert_occurrence(self.test_ctrl, 'se tu p KW  ', TEST1_NAME, 'Setup')

    def test_embedded_arguments_occurrence(self):
        assert_occurrence(self.test_ctrl, EMBEDDED_ARGUMENTS_KEYWORD, TEST1_NAME, 'Steps')

    def test_unknown_variable_occurrences(self):
        self.assertEqual(list(self.test_ctrl.execute(FindOccurrences('${some unknown variable}'))), [])

    def test_occurrences_in_test_metadata(self):
        assert_occurrence(self.test_ctrl, SETUP_KEYWORD, TEST1_NAME, 'Setup')
        assert_occurrence(self.test_ctrl, 'Teardown Kw', TEST1_NAME, 'Teardown')
        assert_occurrence(self.test_ctrl, TEMPLATE_KEYWORD, TEST1_NAME, 'Template')

    def test_occurrences_in_suite_metadata(self):
        assert_occurrence(self.test_ctrl, SUITE_SETUP_KEYWORD, SUITE_NAME, 'Suite Setup')
        assert_occurrence(self.test_ctrl, 'Test Setup Kw', SUITE_NAME, 'Test Setup')
        assert_occurrence(self.test_ctrl, 'Test Teardown Kw', SUITE_NAME, 'Test Teardown')
        assert_occurrence(self.test_ctrl, 'Suite Teardown Kw', SUITE_NAME, 'Suite Teardown')
        assert_occurrence(self.test_ctrl, 'Test Template Kw', SUITE_NAME, 'Test Template')

    def test_occurrences_in_user_keywords(self):
        assert_occurrence(self.test_ctrl, KEYWORD_IN_USERKEYWORD1, USERKEYWORD1_NAME, 'Steps')

    def test_occurrence_in_user_keyword_name(self):
        assert_occurrence(self.test_ctrl, USERKEYWORD1_NAME, USERKEYWORD1_NAME, KEYWORD_NAME_FIELD)


class FindVariableOccurrencesTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        chief = datafilereader.construct_chief_controller(datafilereader.FINDWHEREUSED_VARIABLES_PATH)
        cls._suite1 = _get_ctrl_by_name(cls, "Suite 1", chief.datafiles)
        cls._suite2 = _get_ctrl_by_name(cls, "Suite 2", chief.datafiles)
        cls._resource1 = _get_ctrl_by_name(cls, "Res1", chief.datafiles)
        cls._case1 = _get_ctrl_by_name(cls, "Case 1", chief.datafiles)
        cls._case2 = _get_ctrl_by_name(cls, "Case 2", chief.datafiles)
        cls._case3 = _get_ctrl_by_name(cls, "Case 3", chief.datafiles)
        cls._case4 = _get_ctrl_by_name(cls, "Case 4", chief.datafiles)
        cls._case5 = _get_ctrl_by_name(cls, "Case 5", chief.datafiles)
        cls._case6 = _get_ctrl_by_name(cls, "Case 6", chief.datafiles)
        cls._kw1 = _get_ctrl_by_name(cls, "User KW 1", chief.datafiles)
        cls._kw2 = _get_ctrl_by_name(cls, "User KW 2", chief.datafiles)

    def test_occurrences_local_variable(self):
        check_for_variable_occurrences(self._case2, "${log}", ((self._case2.name, 'Steps', 2),
                                                           (self._case2.name, 'Documentation', 1)))
        
        check_for_variable_occurrences(self._kw2, "${arg1}", ((self._kw2.name, 'Arguments', 1),
                                                            (self._kw2.name, 'Documentation', 1),
                                                            (self._kw2.name, 'Steps', 1)))
        
        check_for_variable_occurrences(self._kw2, "@{arg2}", ((self._kw2.name, 'Arguments', 1),
                                                            (self._kw2.name, 'Teardown', 1),
                                                            (self._kw2.name, 'Steps', 1)))

    def test_occurrences_file_variable(self):
        check_for_variable_occurrences(self._case1, "${fileVar}", ((self._case2.name, 'Teardown', 1),
                                                            (self._case1.name, 'Setup', 1),
                                                            (self._case3.name, 'Steps', 1),
                                                            (self._suite1.name, 'Variable Table', 1)))
        
        check_for_variable_occurrences(self._kw2, "${resVar}", ((self._resource1.name, 'Variable Table', 1),
                                                            (self._kw2.name, 'Steps', 1),
                                                            (self._kw1.name, 'Teardown', 1),
                                                            (self._case5.name, 'Steps', 1),
                                                            (self._case5.name, 'Documentation', 1)))

    def test_occurrences_imported_variable(self):
        check_for_variable_occurrences(self._case5, "${resVar}", ((self._resource1.name, 'Variable Table', 1),
                                                            (self._kw2.name, 'Steps', 1),
                                                            (self._kw1.name, 'Teardown', 1),
                                                            (self._case5.name, 'Steps', 1),
                                                            (self._case5.name, 'Documentation', 1)))
    
    def test_occurrences_external_file_variable(self):
        check_for_variable_occurrences(self._case2, "${ServerHost}", ((self._case1.name, 'Steps', 1),
                                                            (self._case2.name, 'Steps', 1),
                                                            (self._case5.name, 'Steps', 1)))

        check_for_variable_occurrences(self._case5, "${ServerHost}", ((self._case1.name, 'Steps', 1),
                                                             (self._case2.name, 'Steps', 1),
                                                             (self._case5.name, 'Steps', 1)))
        
        check_for_variable_occurrences(self._case1, "${ServerPort}", ((self._case1.name, 'Steps', 1),
                                                                       (self._kw1.name, 'Steps', 1)))

    def test_occurrences_builtin_variable(self):
        check_for_variable_occurrences(self._kw1, "${True}", ((self._case4.name, 'Steps', 1),
                                                             (self._case6.name, 'Setup', 1),
                                                             (self._case6.name, 'Steps', 1),
                                                             (self._kw1.name, 'Steps', 1)))
        
        check_for_variable_occurrences(self._case6, "${False}", ((self._case6.name, 'Documentation', 1),
                                                             (self._case1.name, 'Steps', 1),
                                                             (self._kw1.name, 'Steps', 1)))
        
        check_for_variable_occurrences(self._case3, "${EMPTY}", ((self._resource1.name, 'Variable Table', 1),
                                                             (self._case3.name, 'Steps', 1)))


class RenameOccurrenceTest(unittest.TestCase):

    def setUp(self):
        self.test_ctrl, self.namespace = TestCaseControllerWithSteps()
        self._steps_have_changed = False
        self._testcase_settings_have_changed = False
        self._name_has_changed = False
        self._listeners_and_topics = [(self._steps_changed, RideItemStepsChanged),
                                      (self._testcase_settings_changed, RideItemSettingsChanged),
                                      (self._name_changed, RideItemNameChanged)]
        for listener, topic in self._listeners_and_topics:
            PUBLISHER.subscribe(listener, topic)

    def tearDown(self):
        for listener, topic in self._listeners_and_topics:
            PUBLISHER.unsubscribe(listener, topic)

    def _steps_changed(self, test):
        self._steps_have_changed = True

    def _testcase_settings_changed(self, message):
        if self.test_ctrl == message.item:
            self._testcase_settings_have_changed = True

    def _name_changed(self, data):
        self._name_has_changed = True

    def _expected_messages(self, steps_have_changed=False, testcase_settings_have_changed=False,
                           name_has_changed=False):
        assert_equals(self._steps_have_changed, steps_have_changed)
        assert_equals(self._testcase_settings_have_changed, testcase_settings_have_changed)
        assert_equals(self._name_has_changed, name_has_changed)

    def _rename(self, original_name, new_name, source, usage):
        self.test_ctrl.execute(RenameKeywordOccurrences(original_name, new_name, NullObserver()))
        assert_occurrence(self.test_ctrl, new_name, source, usage)

    def test_rename_updates_namespace(self):
        assert_true(self.namespace.is_user_keyword(self.test_ctrl.datafile, USERKEYWORD2_NAME))
        assert_false(self.namespace.is_user_keyword(self.test_ctrl.datafile, UNUSED_KEYWORD_NAME))
        self._rename(USERKEYWORD2_NAME, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        assert_true(self.namespace.is_user_keyword(self.test_ctrl.datafile, UNUSED_KEYWORD_NAME))
        assert_false(self.namespace.is_user_keyword(self.test_ctrl.datafile, USERKEYWORD2_NAME))

    def test_notifies_only_after_transaction_complete(self):
        datas_ok = {'steps':False, 'name':False}
        def name_changed_check_that_steps_have_also(data):
            datas_ok['steps'] = self.test_ctrl.step(2).keyword == UNUSED_KEYWORD_NAME
        def steps_changed_check_that_name_has_also(data):
            datas_ok['name'] = any(True for i in self.test_ctrl.datafile_controller.keywords
                                   if i.name == UNUSED_KEYWORD_NAME)
        PUBLISHER.subscribe(name_changed_check_that_steps_have_also, RideItemNameChanged)
        PUBLISHER.subscribe(steps_changed_check_that_name_has_also, RideItemStepsChanged)
        try:
            self._rename(USERKEYWORD2_NAME, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        finally:
            PUBLISHER.unsubscribe(name_changed_check_that_steps_have_also, RideItemNameChanged)
            PUBLISHER.unsubscribe(steps_changed_check_that_name_has_also, RideItemStepsChanged)
        assert_true(datas_ok['steps'])
        assert_true(datas_ok['name'])

    def test_rename_in_steps(self):
        self._rename(STEP1_KEYWORD, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)

    def test_rename_with_dollar_sign(self):
        self._rename(STEP1_KEYWORD, UNUSED_KEYWORD_NAME+'$', TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)

    def test_undo_rename_in_step(self):
        self._rename(STEP1_KEYWORD, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self.test_ctrl.execute(Undo())
        assert_equals(self.test_ctrl.steps[0].keyword, STEP1_KEYWORD)

    def test_undo_after_renaming_to_something_that_is_already_there(self):
        self._rename(STEP1_KEYWORD, STEP2_ARGUMENT, TEST1_NAME, 'Steps')
        self.test_ctrl.execute(Undo())
        assert_equals(self.test_ctrl.steps[1].args[0], STEP2_ARGUMENT)

    def test_rename_steps_argument(self):
        self._rename(STEP2_ARGUMENT, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)
        assert_equals(self.test_ctrl.steps[1].as_list(), ['Run Keyword', UNUSED_KEYWORD_NAME])

    def test_user_keyword_rename(self):
        self._rename(USERKEYWORD1_NAME, UNUSED_KEYWORD_NAME, UNUSED_KEYWORD_NAME, KEYWORD_NAME_FIELD)
        self._expected_messages(name_has_changed=True)

    def test_rename_in_test_setup(self):
        self._rename(SETUP_KEYWORD, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Setup')
        self._expected_messages(testcase_settings_have_changed=True)
        self.assertTrue(self.test_ctrl.dirty)

    def test_rename_in_test_template(self):
        self._rename(TEMPLATE_KEYWORD, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Template')
        self._expected_messages(testcase_settings_have_changed=True)
        self.assertTrue(self.test_ctrl.dirty)

    def test_rename_in_suite_metadata(self):
        self._rename(SUITE_SETUP_KEYWORD, UNUSED_KEYWORD_NAME, SUITE_NAME, 'Suite Setup')
        self._expected_messages()
        self.assertTrue(self.test_ctrl.dirty)

    def test_rename_in_suite_test_setup(self):
        self._rename(SUITE_TEST_SETUP_KEYWORD, UNUSED_KEYWORD_NAME, SUITE_NAME, 'Test Setup')
        self._expected_messages()
        self.assertTrue(self.test_ctrl.dirty)

    def test_rename_in_suite_test_template(self):
        self._rename(SUITE_TEST_TEMPLATE_KEYWORD, UNUSED_KEYWORD_NAME, SUITE_NAME, 'Test Template')
        self._expected_messages()
        self.assertTrue(self.test_ctrl.dirty)

    def test_rename_in_user_keywords(self):
        self._rename(KEYWORD_IN_USERKEYWORD1, UNUSED_KEYWORD_NAME, USERKEYWORD1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)

    def test_rename_given_prefixed_keywords(self):
        kw = 'BLOdkajasdj'
        self._add_step('Given '+kw)
        self._rename(kw, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)
        self.assertEquals(self.test_ctrl.step(100).as_list()[100], 'Given '+UNUSED_KEYWORD_NAME)

    def test_rename_when_prefixed_keywords(self):
        kw = 'fjsdklhf37849'
        self._add_step('wHEn   '+kw)
        self._rename(kw, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)
        self.assertEquals(self.test_ctrl.step(100).as_list()[100], 'wHEn   '+UNUSED_KEYWORD_NAME)

    def test_rename_then_prefixed_keywords(self):
        kw = 'djkfsekrhnbdxcvzo dsjah'
        self._add_step('THen '+kw)
        self._rename(kw, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)
        self.assertEquals(self.test_ctrl.step(100).as_list()[100], 'THen '+UNUSED_KEYWORD_NAME)

    def test_rename_and_prefixed_keywords(self):
        kw = 'mmxznbfje uiriweyi yr iu fjkdhzxck'
        self._add_step('AND '+kw)
        self._rename(kw, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)
        self.assertEquals(self.test_ctrl.step(100).as_list()[100], 'AND '+UNUSED_KEYWORD_NAME)

    def test_rename_when_keyword_begins_with_prefix(self):
        kw = 'When I say so'
        self._add_step(kw)
        self._rename(kw, UNUSED_KEYWORD_NAME, TEST1_NAME, 'Steps')
        self._expected_messages(steps_have_changed=True)
        self.assertEquals(self.test_ctrl.step(100).as_list()[100], UNUSED_KEYWORD_NAME)

    def _add_step(self, keyword):
        self.test_ctrl.execute(ChangeCellValue(100, 100, keyword))
        self._steps_have_changed = False


########NEW FILE########
__FILENAME__ = test_parents
#  Copyright 2008-2011 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import unittest
import datafilereader


class TestParents(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.chief = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH)
        cls.directory = cls.chief.data
        cls.test = datafilereader.get_ctrl_by_name('TestSuite1', cls.chief.datafiles)
        cls.resource = datafilereader.get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_RESOURCE_NAME, cls.chief.datafiles)
        cls.external_resource = datafilereader.get_ctrl_by_name('Resu', cls.chief.datafiles)

    @classmethod
    def tearDownClass(cls):
        cls.chief.close()

    def test_test_suite_parent_is_directory(self):
        self.assertEquals(self.test.parent, self.directory)
        self.assertTrue(self.test in self.directory.children)

    def test_local_resource_parent_is_directory(self):
        self.assertEquals(self.resource.parent, self.directory)
        self.assertTrue(self.resource in self.directory.children)

    def test_external_resource_parent_is_undefined(self):
        self.assertEquals(self.external_resource.parent, None)
        self.assertTrue(self.external_resource not in self.directory.children)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_resourcefilecontrollerfactory
import unittest
from robotide.controller.filecontrollers import ResourceFileControllerFactory


class ResourceFileControllerFactoryTestCase(unittest.TestCase):

    def setUp(self):
        namespace = lambda:0
        chef = lambda:0
        self._resource_file_controller_factory = ResourceFileControllerFactory(namespace, chef)

    def test_is_all_resource_imports_resolved(self):
        self.assertFalse(self._resource_file_controller_factory.is_all_resource_file_imports_resolved())
        self._resource_file_controller_factory.set_all_resource_imports_resolved()
        self.assertTrue(self._resource_file_controller_factory.is_all_resource_file_imports_resolved())
        self._resource_file_controller_factory.set_all_resource_imports_unresolved()
        self.assertFalse(self._resource_file_controller_factory.is_all_resource_file_imports_resolved())

    def test_all_resource_imports_is_unresolved_when_new_resource_is_added(self):
        self._resource_file_controller_factory.set_all_resource_imports_resolved()
        data = lambda:0
        data.source = 'source'
        data.directory = 'directory'
        self._resource_file_controller_factory.create(data)
        self.assertFalse(self._resource_file_controller_factory.is_all_resource_file_imports_resolved())

    def test_all_resource_imports_is_unresolved_when_new_resource_is_added(self):
        self._resource_file_controller_factory.set_all_resource_imports_resolved()
        resu = lambda:0
        self._resource_file_controller_factory._resources.append(resu)
        self._resource_file_controller_factory.remove(resu)
        self.assertFalse(self._resource_file_controller_factory.is_all_resource_file_imports_resolved())


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_resource_import
import os
import unittest
import datafilereader

from robotide.controller.commands import AddKeyword, ChangeCellValue,\
    CreateNewResource, SaveFile
from robot.utils.asserts import assert_equals
from robotide.controller.cellinfo import ContentType, CellType


class TestResourceImport(unittest.TestCase):

    def setUp(self):
        self.res_path = datafilereader.SIMPLE_TEST_SUITE_PATH
        self.res_name = 'new_resource_for_test_creating_and_importing_resource.txt'
        self.res_full_name = os.path.join(self.res_path, self.res_name)
        self.new_keyword_name = 'My Keywordian'
        self.ctrl = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH)
        self.suite = datafilereader.get_ctrl_by_name('TestSuite1', self.ctrl.datafiles)
        self.test = self.suite.tests[0]
        self.test.execute(ChangeCellValue(0,0,self.new_keyword_name))
        self.test.execute(ChangeCellValue(0,1,'value'))

    def tearDown(self):
        os.remove(self.res_full_name)
        self.ctrl.close()

    def _create_resource(self):
        self.new_resource = self.ctrl.execute(CreateNewResource(self.res_full_name))
        self.new_resource.execute(AddKeyword(self.new_keyword_name, '${moi}'))
        self.new_resource.execute(SaveFile())

    def test_number_of_resources_is_correct(self):
        original_number_of_resources = len(self.ctrl.resources)
        self._create_resource()
        assert_equals(original_number_of_resources+1, len(self.ctrl.resources))
        self._add_resource_import_to_suite()
        assert_equals(original_number_of_resources+1, len(self.ctrl.resources))

    def test_creating_and_importing_resource_file(self):
        self._create_resource()
        self._verify_unidentified_keyword()
        self.assertFalse(self.new_resource.is_used())
        import_ = self._add_resource_import_to_suite()
        self._verify_identified_keyword()
        self.assertTrue(self.new_resource.is_used())
        self._remove_resource_import_from_suite(import_)
        self._verify_unidentified_keyword()
        self.assertFalse(self.new_resource.is_used())

    def test_importing_and_creating_resource_file(self):
        self._add_resource_import_to_suite()
        self._verify_unidentified_keyword()
        self._create_resource()
        self._verify_identified_keyword()

    def test_changes_in_resource_file(self):
        self._create_resource()
        self._add_resource_import_to_suite()
        self._keyword_controller.arguments.set_value('')
        self._check_cells(ContentType.USER_KEYWORD, CellType.MUST_BE_EMPTY)

    def test_resource_import_knows_resource_after_import_has_been_removed(self):
        item_without_settings = datafilereader.get_ctrl_by_name('Inner Resource', self.ctrl.datafiles)
        self.assertEqual(list(item_without_settings.imports), [])
        self._create_resource()
        import_ = item_without_settings.imports.add_resource('/'.join(['..', self.res_name]))
        self.assertTrue(import_ is not None)
        item_without_settings.imports.delete(0)
        self.assertEqual(self.new_resource, import_.get_previous_imported_controller())

    def test_previously_imported_resource_controller_is_none_by_default(self):
        self._create_resource()
        import_controller = self._add_resource_import_to_suite()
        self.assertEqual(import_controller.get_previous_imported_controller(), None)

    @property
    def _keyword_controller(self):
        return self.ctrl.resources[-1].keywords[-1]

    def _add_resource_import_to_suite(self):
        return self.suite.imports.add_resource(self.res_name)

    def _remove_resource_import_from_suite(self, import_):
        import_.remove()

    def _verify_unidentified_keyword(self):
        self._check_cells(ContentType.STRING, CellType.UNKNOWN)

    def _verify_identified_keyword(self):
        self._check_cells(ContentType.USER_KEYWORD, CellType.MANDATORY)

    def _check_cells(self, keyword_content_type, value_cell_type):
        assert_equals(self.test.get_cell_info(0,0).content_type, keyword_content_type)
        assert_equals(self.test.get_cell_info(0,1).cell_type, value_cell_type)

########NEW FILE########
__FILENAME__ = test_stepcontrollers
import unittest

from robotide.controller.stepcontrollers import StepController


class FakeStep(StepController):

    def __init__(self):
        pass

class UpdatingArgumentsTest(unittest.TestCase):

    def test_converting_last_empty_cell_without_args(self):
        self.assertEqual(FakeStep()._change_last_empty_to_empty_var([], None), [])

    def test_converting_last_empty_cell_with_single_value(self):
        self.assertEqual(FakeStep()._change_last_empty_to_empty_var([''], None),
                         ['${EMPTY}'])

    def test_converting_last_empty_cell_with_multiple_values(self):
        self.assertEqual(FakeStep()._change_last_empty_to_empty_var(['Foo', '', ''], None),
                         ['Foo', '', '${EMPTY}'])

    def test_converting_last_empty_cell_with_comment(self):
        self.assertEqual(FakeStep()._change_last_empty_to_empty_var([''], 'comment'),
                         [''])


class StepContainsKeywordTest(unittest.TestCase, FakeStep):

    @property
    def keyword(self):
        return self._keyword

    @property
    def args(self):
        return self._args

    def setUp(self):
        self._keyword = 'Foo'
        self._args = ['Bar']

    def _verify_contains(self, keyword):
        self.assertTrue(self.contains_keyword(keyword))

    def _verify_does_not_contain(self, keyword):
        self.assertFalse(self.contains_keyword(keyword))

    def test_contains_keyword_in_keyword_position(self):
        self._verify_contains('Foo')

    def test_contains_keyword_in_argument_position(self):
        self._verify_contains('Bar')

    def test_does_not_contain_keyword(self):
        self._verify_does_not_contain('FooBar')

    def test_contains_keyword_with_given_prefix(self):
        self._args += ['Given Keyword']
        self._verify_contains('Keyword')

    def test_contains_keyword_with_when_prefix(self):
        self._keyword = 'When Something'
        self._verify_contains('SomeThing')

    def test_contains_keyword_with_then_prefix(self):
        self._args = ['Then anything']
        self._verify_contains('anythinG')

    def test_contains_keyword_with_and_prefix(self):
        self._keyword = 'and Nothing Else'
        self._verify_contains('nothingelse')

    def test_does_not_remove_too_many_prefixes(self):
        self._keyword = 'Then And Nothing'
        self._verify_contains('And Nothing')
        self._verify_does_not_contain('Nothing')

    def test_matches_to_keyword_with_prefix_word(self):
        self._keyword = 'Then came John'
        self._verify_contains('Then came John')

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tablecontrollers
import unittest
from robot.parsing.model import TestCaseFile, TestCaseFileSettingTable
from robot.parsing.settings import _Import
from robot.parsing.tablepopulators import SettingTablePopulator
from robot.utils.asserts import assert_equals

from robotide.controller.filecontrollers import TestCaseFileController
from robotide.controller.tablecontrollers import ImportSettingsController


VALID_NAME = 'Valid name'


class TestCaseNameValidationTest(unittest.TestCase):

    def setUp(self):
        self.ctrl = TestCaseFileController(TestCaseFile()).tests

    def test_valid_name(self):
        self._validate_name(VALID_NAME, True)

    def test_empty_name(self):
        self._validate_name('', False)

    def test_name_with_only_whitespace(self):
        self._validate_name('      ', False)

    def test_duplicate_name(self):
        self.ctrl.new(VALID_NAME)
        self._validate_name(VALID_NAME, False)
        self._validate_name(VALID_NAME.upper(), False)
        self._validate_name(VALID_NAME.replace(' ', '_'), False)

    def test_duplicate_name_when_previous_name_known(self):
        ctrl = self.ctrl.new(VALID_NAME)
        self._validate_name(VALID_NAME, True, ctrl)
        self._validate_name(VALID_NAME.upper(), True, ctrl)
        self._validate_name(VALID_NAME.replace(' ', '_'), True, ctrl)

    def _validate_name(self, name, expected_valid, named_ctrl=None):
        valid = not bool(self.ctrl.validate_name(name, named_ctrl).error_message)
        assert_equals(valid, expected_valid)


class TestCaseCreationTest(unittest.TestCase):

    def setUp(self):
        self.ctrl = TestCaseFileController(TestCaseFile()).tests

    def test_whitespace_is_stripped(self):
        test = self.ctrl.new('   ' + VALID_NAME + '\t   \n')
        assert_equals(test.name, VALID_NAME)


class LibraryImportListOperationsTest(unittest.TestCase):

    def setUp(self):
        self._parent = lambda:0
        self._parent.mark_dirty = lambda:0
        self._parent.datafile_controller = self._parent
        self._parent.update_namespace = lambda:0
        self._table = TestCaseFileSettingTable(lambda:0)
        self.ctrl = ImportSettingsController(self._parent, self._table)
        self._lib1 = self.ctrl.add_library('libbi1', '', '')
        self._lib2 = self.ctrl.add_library('libbi2', '', '')
        self.assertEqual([self._lib1.name, self._lib2.name], [l.name for l in self.ctrl])

    def test_move_up(self):
        self.ctrl.move_up(1)
        self.assertEqual([self._lib2.name, self._lib1.name], [l.name for l in self.ctrl])

    def test_move_down(self):
        self.ctrl.move_down(0)
        self.assertEqual([self._lib2.name, self._lib1.name], [l.name for l in self.ctrl])

########NEW FILE########
__FILENAME__ = test_tags
import unittest
from robot.utils.asserts import fail, assert_true, assert_false
from controller_creator import testcase_controller
from robotide.controller.tags import Tag, DefaultTag, ForcedTag
from robotide.controller.commands import ChangeTag


class Test(unittest.TestCase):

    def setUp(self):
        self._test = testcase_controller()

    @property
    def tags(self):
        return self._test.tags

    def test_tests_tag_is_shown(self):
        tag = Tag('tag')
        self.tags.add(tag)
        assert_true(tag in self.tags)

    def test_default_from_suite(self):
        tag = DefaultTag('suite tag')
        suite = self._test.datafile_controller
        suite.default_tags.add(tag)
        assert_true(tag in self.tags)

    def test_adding_empty_tag_will_remove_default(self):
        self.test_default_from_suite()
        self._verify_number_of_tags(1)
        t = self.tags.empty_tag()
        self.tags.execute(ChangeTag(t, ''))
        self._verify_number_of_tags(1)
        self._tag_with_name_exists('')

    def test_overwriting_default(self):
        tag_to_overwrite = DefaultTag('suite tag')
        tag = Tag('overwriter')
        suite = self._test.datafile_controller
        suite.default_tags.add(tag_to_overwrite)
        self.tags.add(tag)
        assert_true(tag_to_overwrite not in self.tags)
        assert_true(tag in self.tags)

    def test_force_tag_from_suite(self):
        force_tag = ForcedTag('force tag')
        suite = self._test.datafile_controller
        suite.force_tags.add(force_tag)
        assert_true(force_tag in self.tags)

    def test_force_tag_from_suites_parent_directory(self):
        force_tag = ForcedTag('forced from directory')
        directory = self._test.datafile_controller.parent
        directory.force_tags.add(force_tag)
        assert_true(force_tag in self.tags)

    def test_force_tag_from_suites_parents_parent_directory(self):
        force_tag = ForcedTag('forced from directory')
        directory = self._test.datafile_controller.parent.parent
        directory.force_tags.add(force_tag)
        assert_true(force_tag in self.tags)

    def test_changing_tag(self):
        tag = Tag('tag')
        self.tags.add(tag)
        self.tags.execute(ChangeTag(tag, 'foo'))
        self._tag_with_name_exists('foo')
        assert_false(any(t for t in self.tags if t.name == 'tag'))

    def test_changing_empty_tag_adds_tag(self):
        name = 'sometag'
        self.tags.add(Tag('tag'))
        self.tags.execute(ChangeTag(self.tags.empty_tag(), name))
        self._tag_with_name_exists(name)

    def test_changing_tag_to_empty_removes_tag(self):
        tag = Tag('tag')
        self.tags.add(tag)
        self.tags.execute(ChangeTag(tag, ''))
        self._verify_number_of_tags(1)
        self._tag_with_name_does_not_exists('tag')
        self._tag_with_name_exists('')

    def test_removing_one_tag_when_multiple_with_same_name(self):
        name = 'tag'
        tag = Tag(name)
        tag2 = Tag(name)
        self.tags.add(tag)
        self.tags.add(tag2)
        self.tags.execute(ChangeTag(tag, ''))
        self._verify_number_of_tags(1)
        self._tag_with_name_exists(tag2.name)

    def test_changing_partial_tag(self):
        self.tags.add(Tag('tag'))
        partial = Tag('ag')
        self.tags.add(partial)
        self.tags.execute(ChangeTag(partial, 'foo'))
        self._tag_with_name_exists('foo')
        self._tag_with_name_exists('tag')
        self._tag_with_name_does_not_exists('ag')

    def test_changing_tags_does_not_change_total_number_of_tags(self):
        tag_to_change = Tag('tagistano')
        self.tags.add(tag_to_change)
        self._test.datafile_controller.force_tags.add(ForcedTag('suite'))
        self._test.datafile_controller.parent.force_tags.add(ForcedTag('directory'))
        self._verify_number_of_tags(3)
        self._test.tags.execute(ChangeTag(tag_to_change, 'foobar'))
        self._verify_number_of_tags(3)

    def _verify_number_of_tags(self, number):
        assert_true(number == sum(1 for _ in self.tags))

    def _tag_with_name_exists(self, name):
        assert_true(any(t for t in self.tags if t.name == name))

    def _tag_with_name_does_not_exists(self, name):
        assert_false(any(t for t in self.tags if t.name == name))

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
########NEW FILE########
__FILENAME__ = test_tcuk_copy
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import time
import unittest

from robotide.robotapi import TestCaseFile
from robotide.controller.filecontrollers import TestCaseFileController

from resources import COMPLEX_SUITE_PATH
from robot.utils.asserts import assert_equals, assert_true


class TestCaseAndUserKeywordCopyingTest(unittest.TestCase):
    controller = TestCaseFileController(TestCaseFile(source=COMPLEX_SUITE_PATH).populate())

    def test_test_case_copy(self):
        test = self.controller.tests[0]
        copy = test.copy('New Name')
        assert_equals(copy.name, 'New Name')
        for orig, copied in zip(test.settings, copy.settings):
            assert_equals(orig.value, copied.value)
            assert_true(copied is not orig)
        assert_equals(test.steps, copy.steps)
        assert_true(test.steps is not copy.steps)

    def test_keyword_copy(self):
        test = self.controller.keywords[0]
        copy = test.copy('New Name')
        assert_equals(copy.name, 'New Name')
        for orig, copied in zip(test.settings, copy.settings):
            assert_equals(orig.value, copied.value)
            assert_true(copied is not orig)
        assert_equals(test.steps, copy.steps)
        assert_true(test.steps is not copy.steps)

    def test_test_copy_performance(self):
        self._run_copy_test(self.controller.tests[0])

    def test_keyword_copy_performance(self):
        self._run_copy_test(self.controller.keywords[0])

    def _run_copy_test(self, item):
        self._test_copy(item, 10)
        self._test_copy(item, 200)

    def _test_copy(self, item, count):
        start_time = time.time()
        for i in range(0, count):
            item.copy(str(i))
        self.assertTrue(time.time() < (start_time + 2),
                        "Copy operation takes too long time")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_testexecutionresult
import unittest
from robotide.controller.testexecutionresults import TestExecutionResults

class TestExecutionResultTestCase(unittest.TestCase):

    def setUp(self):
        self._results = TestExecutionResults()
        self._test = object()
        self._test2 = object()

    def test_running_test(self):
        self._results.set_running(self._test)
        self._expect_running(self._test)
        self._results.set_passed(self._test)
        self._expect_passed(self._test)

    def _expect_passed(self, test):
        self.assertFalse(self._results.is_running(test))
        self.assertTrue(self._results.has_passed(test))
        self.assertFalse(self._results.has_failed(test))

    def _expect_running(self, test):
        self.assertTrue(self._results.is_running(test))
        self.assertFalse(self._results.has_passed(test))
        self.assertFalse(self._results.has_failed(test))

    def test_running_test_that_fails(self):
        self._results.set_running(self._test)
        self._expect_running(self._test)
        self._results.set_failed(self._test)
        self._expect_failed(self._test)

    def _expect_failed(self, test):
        self.assertFalse(self._results.is_running(test))
        self.assertFalse(self._results.has_passed(test))
        self.assertTrue(self._results.has_failed(test))

    def test_running_two_tests(self):
        self._results.set_running(self._test)
        self._expect_running(self._test)
        self._expect_no_result(self._test2)
        self._results.set_failed(self._test)
        self._expect_failed(self._test)
        self._results.set_running(self._test2)
        self._expect_running(self._test2)
        self._expect_failed(self._test)
        self._results.set_passed(self._test2)
        self._expect_passed(self._test2)
        self._expect_failed(self._test)

    def test_clearing_results(self):
        self._results.set_running(self._test)
        self._results.set_passed(self._test)
        self._results.set_running(self._test2)
        self._results.set_passed(self._test2)
        self._results.clear()
        self._expect_no_result(self._test)
        self._expect_no_result(self._test2)

    def _expect_no_result(self, test):
        self.assertFalse(self._results.is_running(test))
        self.assertFalse(self._results.has_passed(test))
        self.assertFalse(self._results.has_failed(test))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tooltip_message
import unittest
from robot.utils.asserts import assert_false, assert_equals, assert_true

from robotide.utils import html_escape
from robotide.controller.cellinfo import CellInfo, CellContent, ContentType,\
    CellPosition, CellType, TipMessage, _TooltipMessage, _ForLoopTooltipMessage


class TestCellTooltip(unittest.TestCase):

    def test_empty_tooltip(self):
        cell = CellInfo(CellContent(ContentType.EMPTY, None),
                        CellPosition(CellType.UNKNOWN, None))
        assert_false(TipMessage(cell))

    def test_unknown_keyword(self):
        cell = CellInfo(CellContent(ContentType.STRING, 'What?'),
                        CellPosition(CellType.KEYWORD, None))
        msg = TipMessage(cell)
        assert_true(msg)
        assert_equals(str(msg), html_escape(_TooltipMessage.KEYWORD_NOT_FOUND))

    def test_known_keyword(self):
        cell = CellInfo(CellContent(ContentType.USER_KEYWORD, 'Known', 'my_source'),
                        CellPosition(CellType.KEYWORD, None))
        msg = TipMessage(cell)
        assert_true(msg)
        assert_equals(str(msg),
                      html_escape(_TooltipMessage.KEYWORD % 'my_source'))

    def test_for_loop_start(self):
        cell = CellInfo(CellContent(ContentType.STRING, ':FOR'),
                        CellPosition(CellType.MANDATORY, None), for_loop=True)
        assert_false(TipMessage(cell))

    def test_for_loop_var(self):
        cell = CellInfo(CellContent(ContentType.VARIABLE, '${i}'),
                        CellPosition(CellType.MANDATORY, None), for_loop=True)
        assert_false(TipMessage(cell))

    def test_unknown_variable(self):
        cell = CellInfo(CellContent(ContentType.UNKNOWN_VARIABLE, '${unknown}'),
                        CellPosition(CellType.UNKNOWN, None))
        assert_true(TipMessage(cell))

    def test_for_loop_too_many_args(self):
        cell = CellInfo(CellContent(ContentType.STRING, 'something'),
                        CellPosition(CellType.MUST_BE_EMPTY, None), for_loop=True)
        msg = TipMessage(cell)
        assert_true(msg)
        assert_equals(str(msg), _ForLoopTooltipMessage.TOO_MANY_ARGUMENTS)


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_variable
import unittest
from robot.parsing.model import Variable
from robotide.controller.settingcontrollers import VariableController


class TestVariableEquality(unittest.TestCase):

    def setUp(self):
        self._var = Variable('${steve}', 'val')
        self._var_ctrl = VariableController(object(), self._var)

    def test_is_not_equal_to_none(self):
        self.assertFalse(self._var_ctrl == None)

    def test_is_equal_to_self(self):
        self.assertTrue(self._var_ctrl == self._var_ctrl)

    def test_is_not_equal_to_some_other(self):
        self.assertFalse(self._var_ctrl == VariableController(object(), Variable('${other}', 'foo')))

    def test_is_equal_if_same_underlining_var(self):
        other = VariableController(object(), self._var)
        self.assertTrue(self._var_ctrl == other)

    def test_comment_variable(self):
        self.assertTrue(self._var_ctrl.has_data())
        self.assertFalse(VariableController(object(), Variable('','')).has_data())

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_treecontroller
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest
from robot.parsing.model import TestCase, TestCaseFile
from robot.utils.asserts import assert_equals
from robotide.controller.commands import ChangeTag
from robotide.controller.filecontrollers import TestCaseFileController
from robotide.controller.macrocontrollers import TestCaseController
from robotide.controller.tablecontrollers import TestCaseTableController
from robotide.controller.tags import Tag
from robotide.controller.ui.treecontroller import TreeController, _History, TestSelectionController


class ActionRegistererMock(object):

    def register_actions(self, action_collections):
        self.action_collections = action_collections

    def register_action(self, action):
        pass


class TestTreeController(unittest.TestCase):

    def test_register_tree_actions(self):
        mocked_ar = ActionRegistererMock()
        TreeController(None, mocked_ar, None, None).register_tree_actions()
        self.assertEquals(["Go &Back", "Go &Forward"], [a.name for a in mocked_ar.action_collections])


class _BaseTreeControllerTest(object):

    def setUp(self):
        self.history = _History()
        self.controller = TreeController(self._tree_mock(), None, None, None, history=self.history)
        self.controller.add_to_history("Top Suite")

    def _tree_mock(self):
        tree_mock = lambda:0
        self._tree_mock_items = []
        tree_mock.SelectItem = lambda i: self._tree_mock_items.append(i)
        return tree_mock

    def _select_node(self, value):
        self.controller.add_to_history(value)

    def _go_back_and_return_selection(self):
        self.controller.OnGoBack(None)
        return self._tree_mock_items[-1]

    def _go_forward_and_return_selection(self):
        self.controller.OnGoForward(None)
        return self._tree_mock_items[-1]


class TestNavigationHistory(_BaseTreeControllerTest, unittest.TestCase):

    def test_go_back_one_level(self):
        self._select_node('Top Suite Fake UK 2')
        self.assertEquals('Top Suite', self._go_back_and_return_selection())

    def test_go_back_two_levels(self):
        nodes = ['Top Suite Fake UK 1', 'Sub Suite 1', 'Sub Suite 1 Fake UK 0']
        for name in nodes:
            self._select_node(name)
        nodes.reverse()
        for name in nodes[1:]:
            self.assertEquals(name, self._go_back_and_return_selection())

    def test_it_is_not_possible_to_go_back_farther_than_history(self):
        nodes = ['Top Suite Fake UK 1', 'Sub Suite 1', 'Sub Suite 1 Fake UK 0']
        for name in nodes:
            self._select_node(name)
        nodes.reverse()
        for name in nodes[1:] + ['Top Suite']:
            self._go_back_and_assert_selection(name)
        self._go_back_and_assert_selection('Top Suite')

    def test_go_back_with_selecting_in_between(self):
        nodes = ['Top Suite Fake UK 1', 'Sub Suite 1', 'Sub Suite 1 Fake UK 0']
        for name in nodes:
            self._select_node(name)
        self._go_back_and_assert_selection('Sub Suite 1')
        self._select_node('Sub Suite 2 Fake UK 0')
        self._go_back_and_assert_selection('Sub Suite 1')

    def test_go_forward(self):
        nodes = ['Top Suite Fake UK 1', 'Sub Suite 1', 'Sub Suite 1 Fake UK 0']
        for name in nodes:
            self._select_node(name)
        for _ in range(3):
            self.controller.OnGoBack(None)
        for name in nodes:
            self._go_forward_and_assert_selection(name)

    def test_go_back_and_forward_between_suite_and_resource(self):
        nodes = ['Top Suite Fake UK 0', 'Resource Keyword', 'Sub Suite 0 Fake UK 2']
        for name in nodes:
            self._select_node(name)
        self._go_back_and_assert_selection('Resource Keyword')
        self._go_back_and_assert_selection('Top Suite Fake UK 0')
        self._go_forward_and_assert_selection('Resource Keyword')
        self._go_forward_and_assert_selection('Sub Suite 0 Fake UK 2')

    def _go_back_and_assert_selection(self, expected_selection):
        assert_equals(self._go_back_and_return_selection(), expected_selection)

    def _go_forward_and_assert_selection(self, expected_selection):
        assert_equals(self._go_forward_and_return_selection(), expected_selection)


class TestTestSelectionController(unittest.TestCase):

    def setUp(self):
        self._tsc = TestSelectionController()

    def test_test_selection_is_empty_by_default(self):
        self.assertTrue(self._tsc.is_empty())

    def test_test_selection_is_not_empty_when_it_contains_a_test(self):
        self._tsc.select(self._create_test())
        self.assertFalse(self._tsc.is_empty())

    def test_test_selection_is_empty_after_removing_same_test_from_there_even_when_it_is_not_the_same_object(self):
        self._tsc.select(self._create_test())
        self._tsc.select(self._create_test(), False)
        self.assertTrue(self._tsc.is_empty())

    def test_adding_tag_to_selected_tests(self):
        tests = [self._create_test('test%d' % i) for i in range(10)]
        for t in tests:
            self._tsc.select(t)
        self._tsc.add_tag('foo')
        for t in tests:
            self.assertEqual([tag.name for tag in t.tags], ['foo'])

    def test_adding_a_tag_to_test_with_a_default_tag(self):
        test = self._create_test()
        test.datafile_controller.default_tags.execute(ChangeTag(Tag(None), 'default'))
        assert_equals([t.name for t in test.tags], ['default'])
        self._tsc.select(test)
        self._tsc.add_tag('custom')
        self.assertEqual([t.name for t in test.tags], ['default', 'custom'])

    def _create_test(self, name='test'):
        suite = TestCaseFile(source='suite')
        suite_controller = TestCaseFileController(suite)
        parent = TestCaseTableController(suite_controller, suite.testcase_table)
        test = TestCase(parent=lambda:0, name=name)
        return TestCaseController(parent, test)


if __name__ == '__main__':
    unittest.main()




########NEW FILE########
__FILENAME__ = datafilereader
import os
from resources import FakeSettings
from robotide.controller.chiefcontroller import ChiefController
from robotide.controller.commands import NullObserver
from robotide.namespace import Namespace
from robotide.spec.librarymanager import LibraryManager

RESOURCES_DIR = 'resources'
RESOURCES_HTML = 'resource.html'
DATAPATH = os.path.join(os.path.abspath(os.path.split(__file__)[0]),
                        RESOURCES_DIR, 'robotdata')

def _makepath(*elements):
    elements = [DATAPATH]+list(elements)
    return os.path.normpath(os.path.join(*elements)).replace('\\', '/')

ALL_FILES_PATH = _makepath('all_files')
RESOURCE_PATH = _makepath(RESOURCES_DIR, RESOURCES_HTML)
RESOURCE_LIB_PATH = _makepath(RESOURCES_DIR, 'resource_lib_imports.txt')
RESOURCE_WITH_VARS = _makepath(RESOURCES_DIR, 'resource_with_variables.txt')
TESTCASEFILE_WITH_EVERYTHING = _makepath('testsuite', 'everything.html')
RELATIVE_IMPORTS = _makepath('relative_imports', 'relative.txt')
LOG_MANY_SUITE = _makepath('logmanysuite', 'log_many.txt')
KW1000_TESTCASEFILE = _makepath('performance', 'suite_kw1000.txt')
KW2000_TESTCASEFILE = _makepath('performance', 'suite_kw2000.txt')
KW3000_TESTCASEFILE = _makepath('performance', 'suite_kw3000.txt')
KW4000_TESTCASEFILE = _makepath('performance', 'suite_kw4000.txt')
RESOURCE_WITH_VARIABLE_IN_PATH = _makepath(RESOURCES_DIR, 'resu.${extension}')
LIBRARY_WITH_SPACES_IN_PATH = _makepath('lib with spaces', 'spacelib.py')
TESTCASEFILE_WITH_RESOURCES_WITH_VARIABLES_FROM_VARIABLE_FILE = _makepath('var_file_variables',
                                            'import_resource_with_variable_from_var_file.txt')

SIMPLE_TEST_SUITE_RESOURCE_NAME = 'Testdata Resource'
SIMPLE_TEST_SUITE_RESOURCE_FILE = 'testdata_resource.txt'
SIMPLE_TEST_SUITE_INNER_RESOURCE_DIR = 'Resources Folder'
SIMPLE_TEST_SUITE_PATH = _makepath('simple_testsuite_with_different_namespaces')

FOR_LOOP_PATH = _makepath('forloop')

ARGUMENTS_PATH = _makepath('arguments_suite')

SIMPLE_PROJECT = _makepath('simple', 'test.txt')

UNUSED_KEYWORDS_PATH = _makepath('unused_keywords')

FINDWHEREUSED_VARIABLES_PATH = _makepath('findwhereused_variables')

SMALL_TEST_PATH = _makepath('small_test')

IMPORTS = _makepath('imports')

def construct_chief_controller(datapath, temp_dir_for_excludes=None):
    settings = FakeSettings(temp_dir_for_excludes)
    library_manager = LibraryManager(':memory:')
    library_manager.create_database()
    chief = ChiefController(Namespace(settings), settings, library_manager)
    chief.load_data(datapath, NullObserver())
    return chief

def get_ctrl_by_name(name, datafiles):
    for file in datafiles:
        if file.name == name:
            return file
    return None

########NEW FILE########
__FILENAME__ = fakeplugin
#  Copyright 2008-2011 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

class FakePlugin(object):
    def __init__(self, editors, item):
        self._editors = editors
        self._item = item
    def get_selected_item(self):
        return self._item
    def get_editor(self, itemclass):
        return self._editors[itemclass]
    def subscribe(self, *args):
        pass
    def unsubscribe(self, *args):
        pass

########NEW FILE########
__FILENAME__ = test_clipboard
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import unittest

from robot.utils.asserts import assert_equals

from resources import PYAPP_REFERENCE as _ #Needed to be able to create wx components
from robotide.context.platform import IS_WINDOWS
from robotide.editor.clipboard import _GridClipboard

if not IS_WINDOWS:
    class TestGridClipBoard(unittest.TestCase):

        def test_with_string_content(self):
            self._test_clipboard('Hello, world!', 'Hello, world!')

        def test_with_list_content(self):
            self._test_clipboard([['Hello', 'world!']], 'Hello\tworld!')

        def test_with_multiple_rows(self):
            self._test_clipboard([['Hello', 'world!'], ['Another', 'row']],
                                 'Hello\tworld!\nAnother\trow')

        def _test_clipboard(self, content, expected=''):
            clipb = _GridClipboard()
            clipb.set_contents(content)
            assert_equals(clipb._get_contents(),
                          expected.replace('\n', os.linesep))


    if __name__ == '__main__':
        unittest.main()

########NEW FILE########
__FILENAME__ = test_contentassist
import unittest
from robotide.editor.contentassist import Suggestions
from robotide.namespace.suggesters import SuggestionSource, HistorySuggester

class TestSuggestionSources(unittest.TestCase):

    def test_suggestion_source_when_controller_and_row(self):
        suggestion_source = SuggestionSource(plugin=None, controller=self._controller_mock('foo'))
        suggestions = suggestion_source.get_suggestions('foo', 1)
        self.assertEqual(1, len(suggestions))
        self.assertEqual('foobar', suggestions[0].name)

    def test_suggestion_source_when_no_controller(self):
        suggestion_source = SuggestionSource(plugin=self._plugin_mock('bar'), controller=None)
        suggestions = suggestion_source.get_suggestions('foo', 1)
        self.assertEqual(1, len(suggestions))
        self.assertEqual('barfoo', suggestions[0].name)

    def test_history_suggester(self):
        suggestion_source = HistorySuggester()
        self.assertEqual([], suggestion_source.get_suggestions('f'))
        suggestion_source.store('foo')
        self.assertEqual('foo', suggestion_source.get_suggestions('f')[0].name)
        self.assertEqual([], suggestion_source.get_suggestions('b'))
        suggestion_source.store('bar')
        self.assertEqual('bar', suggestion_source.get_suggestions('b')[0].name)
        self.assertEqual('foo', suggestion_source.get_suggestions('f')[0].name)

    def _controller_mock(self, name):
        controller_mock = lambda:0
        controller_mock.get_local_namespace_for_row = lambda row:controller_mock
        suggestion = lambda:0
        suggestion.name = '%sbar' % name
        suggestion.description = None
        controller_mock.get_suggestions = lambda value: [suggestion]
        return controller_mock

    def _plugin_mock(self, name):
        mock = lambda:0
        suggestion = lambda:0
        suggestion.name = '%sfoo' % name
        suggestion.description = None
        mock.content_assist_values = lambda value:[suggestion]
        return mock


class TestSuggestions(unittest.TestCase):

    def test_suggestions_are_cached(self):
        mock_source = self._create_mock_source()
        suggestions = Suggestions(mock_source)
        self.assertEquals(mock_source.request_count, 0)
        suggestions.get_for('a')
        self.assertEquals(mock_source.request_count, 1)
        suggestions.get_for('aa')
        self.assertEquals(mock_source.request_count, 1)

    def test_cache_is_not_used_when_current_search_is_not_subset_of_previous(self):
        mock_source = self._create_mock_source()
        suggestions = Suggestions(mock_source)
        self.assertEquals(mock_source.request_count, 0)
        suggestions.get_for('aa')
        self.assertEquals(mock_source.request_count, 1)
        suggestions.get_for('a')
        self.assertEquals(mock_source.request_count, 2)

    def test_suggestions_for_duplicates(self):
        mock_source = self._create_mock_source()
        suggestions = Suggestions(mock_source)
        choices = suggestions.get_for('a')
        self.assertEquals(choices, ['aarnio', 'fo.aaatio', 'bA.AAATIO'])

    def _create_mock_source(self):
        mock_source = lambda:0
        mock_source.request_count = 0
        def get(name, *args):
            mock_source.request_count += 1
            return self._suggestions(('aarnio', 'fo.aarnio'), ('aaatio', 'fo.aaatio'), ('AAATIO', 'bA.AAATIO'))
        mock_source.get_suggestions = get
        return mock_source

    def _suggestions(self, *args):
        return [self._sug(name, longname) for (name, longname) in args]

    def _sug(self, name, longname):
        sug = lambda:0
        sug.name = name
        sug.longname = longname
        return sug

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_editor_creator
from editor.fakeplugin import FakePlugin
from resources import PYAPP_REFERENCE
import unittest
import wx
import os
from mock import Mock
from robot.parsing.model import Variable
from robot.utils.asserts import assert_equals, assert_true

from robotide.controller import DataController
from robotide.controller.robotdata import NewTestCaseFile
from robotide.controller.settingcontrollers import VariableController
from robotide.controller.tablecontrollers import VariableTableController
from robotide.editor import EditorCreator
from robotide.editor.editors import TestCaseFileEditor, WelcomePage


DATADIR = 'fake'
DATAPATH = '%s/path' % DATADIR
TestCaseFileEditor._populate = lambda self: None

class EditorCreatorTest(unittest.TestCase):

    def setUp(self):
        self._registered_editors = {}
        self.creator = EditorCreator(self._register)
        self.creator.register_editors()

    def tearDown(self):
        if os.path.exists(DATADIR):
            os.rmdir(DATADIR)

    def _register(self, iclass, eclass):
        self._registered_editors[iclass] = eclass

    def test_registering_editors_for_model_objects(self):
        assert_equals(len(self._registered_editors), len(self.creator._EDITORS))

    def test_creating_editor_for_datafile_controller(self):
        plugin = self._datafile_plugin()
        editor = self._editor_for(plugin)
        assert_true(isinstance(editor, TestCaseFileEditor))

    def _editor_for(self, plugin):
        return self.creator.editor_for(plugin, wx.Frame(None), None)

    def test_creating_editor_with_variable(self):
        plugin = self._variable_plugin()
        editor = self._editor_for(plugin)
        assert_true(isinstance(editor, TestCaseFileEditor))

    def test_creating_welcome_page_when_no_item(self):
        plugin = self._no_item_selected_plugin()
        editor = self._editor_for(plugin)
        assert_true(isinstance(editor, WelcomePage))

    def test_same_welcome_page_editor_instance_is_returned_if_called_multiple_times(self):
        plugin = self._no_item_selected_plugin()
        editor = self._editor_for(plugin)
        editor2 = self._editor_for(plugin)
        assert_equals(editor, editor2)

    def test_same_testcasefile_editor_instance_is_returned_if_called_multiple_times(self):
        plugin = self._variable_plugin()
        editor = self._editor_for(plugin)
        editor2 = self._editor_for(plugin)
        assert_equals(editor, editor2)

    def test_editor_is_recreated_when_controller_changes(self):
        p1 = self._datafile_plugin()
        p2 = self._datafile_plugin()
        e1 = self._editor_for(p1)
        e2 = self._editor_for(p2)
        assert_true(e1 is not e2)

    def test_editor_is_destroyed_when_new_is_created(self):
        ed = self._datafile_editor()
        ed.destroy = Mock()
        self._datafile_editor()
        assert_true(ed.destroy.called)

    def _datafile_editor(self):
        return self.creator.editor_for(self._datafile_plugin(),
                                       wx.Frame(None), None)

    def _datafile_plugin(self):
        return FakePlugin(self._registered_editors,
                          self._datafile_controller())

    def _variable_plugin(self):
        return FakePlugin(self._registered_editors,
                          VariableController(VariableTableController(
                              self._datafile_controller(), None), Variable('','')))

    def _no_item_selected_plugin(self):
        return FakePlugin(self._registered_editors, None)

    def _datafile_controller(self):
        return DataController(NewTestCaseFile(DATAPATH), None)

########NEW FILE########
__FILENAME__ = test_grid
import unittest
from robot.utils.asserts import assert_equals

from robotide.editor.grid import GridEditor

from resources import PYAPP_REFERENCE as _ #Needed to be able to create wx components

# wx needs to imported last so that robotide can select correct wx version.
import wx
from robotide.context.platform import IS_WINDOWS

DATA = [['kw1', '', ''],
        ['kw2', 'arg1', ''],
        ['kw3', 'arg1', 'arg2']]


class _FakeMainFrame(wx.Frame):
    def __init__(self):
        wx.Frame.__init__(self, None)
        self.plugin = None


def EditorWithData():
    grid = GridEditor(_FakeMainFrame(), 5, 5)
    for ridx, rdata in enumerate(DATA):
        for cidx, cdata in enumerate(rdata):
            grid.write_cell(ridx, cidx, cdata, update_history=False)
    return grid


class TestCoordinates(unittest.TestCase):

    def setUp(self):
        self._editor = EditorWithData()

    def test_cell_selection(self):
        self._editor.SelectBlock(2, 2, 2, 2)
        self._verify_selection(2, 2, 2, 2)

    def test_selecting_multiple_cells(self):
        self._editor.SelectBlock(0, 1, 3, 4)
        self._verify_selection(0, 1, 3, 4)

    def _verify_selection(self, toprow, topcol, botrow, botcol):
        assert_equals(self._editor.selection.topleft.row, toprow)
        assert_equals(self._editor.selection.topleft.col, topcol)
        assert_equals(self._editor.selection.bottomright.row, botrow)
        assert_equals(self._editor.selection.bottomright.col, botcol)


if not IS_WINDOWS:
    class TestClipBoard(unittest.TestCase):

        def setUp(self):
            self._editor = EditorWithData()

        def test_copy_one_cell(self):
            self._copy_block_and_verify((0, 0, 0, 0), [['kw1']])

        def test_copy_row(self):
            self._copy_block_and_verify((1, 0, 1, 1), [[val for val in DATA[1] if val]])

        def test_copy_block(self):
            self._copy_block_and_verify((0, 0, 2, 2), DATA)

        def _copy_block_and_verify(self, block, exp_content):
            self._editor.SelectBlock(*block)
            self._editor.copy()
            assert_equals(self._editor._clipboard_handler._clipboard.get_contents(),
                          exp_content)
            self._verify_grid_content(DATA)

        def test_cut_one_cell(self):
            self._cut_block_and_verify((0, 0, 0, 0), [['kw1']],
                                       [['', '', '']] + DATA[1:])

        def test_cut_row(self):
            self._cut_block_and_verify((2, 0, 2, 2), [DATA[2]], DATA[:2])

        def test_cut_block(self):
            self._cut_block_and_verify((0, 0, 2, 2), DATA, [])

        def _cut_block_and_verify(self, block, exp_clipboard, exp_grid):
            self._cut_block(block)
            assert_equals(self._editor._clipboard_handler._clipboard.get_contents(),
                          exp_clipboard)
            self._verify_grid_content(exp_grid)

        def test_undo_with_cut(self):
            self._cut_undo_and_verify((0,0,0,0), DATA)
            self._cut_undo_and_verify((0, 0, 2, 2), DATA)

        def _cut_undo_and_verify(self, block, exp_data_after_undo):
            self._cut_block(block)
            self._editor.undo()
            self._verify_grid_content(exp_data_after_undo)

        def test_multiple_levels_of_undo(self):
            self._cut_block((0, 0, 0, 0))
            self._cut_block((2, 0, 2, 2))
            self._editor.undo()
            self._verify_grid_content([['', '', '']] + DATA[1:])
            self._editor.undo()
            self._verify_grid_content(DATA)

        def _cut_block(self, block):
            self._editor.SelectBlock(*block)
            self._editor.cut()

        def test_paste_one_cell(self):
            self._copy_and_paste_block((1, 0, 1, 0), (3, 0, 3, 0), DATA + [['kw2']])
            # These tests are not independent
            self._copy_and_paste_block((1, 0, 1, 0), (0, 3, 0, 3),
                                       [DATA[0] + ['kw2']] + DATA[1:] + [['kw2']])

        def test_paste_row(self):
            self._copy_and_paste_block((2, 0, 2, 2), (3, 1, 3, 1), DATA + [[''] + DATA[2]])

        def test_paste_block(self):
            self._copy_and_paste_block((0, 0, 2, 2), (4, 0, 4, 0), DATA + [['']] + DATA)

        def test_paste_over(self):
            self._copy_and_paste_block((1, 0, 1, 1), (0, 0, 0, 0), [DATA[1]] + DATA[1:])

        def _copy_and_paste_block(self, sourceblock, targetblock, exp_content):
            self._editor.SelectBlock(*sourceblock)
            self._editor.copy()
            self._editor.SelectBlock(*targetblock)
            self._editor.paste()
            self._verify_grid_content(exp_content)

        def _verify_grid_content(self, data):
            for row in range(self._editor.NumberRows):
                for col in range(self._editor.NumberCols):
                    value = self._editor.GetCellValue(row, col)
                    try:
                        assert_equals(value, data[row][col],
                                      'The contents of cell (%d,%d) was not as '
                                      'expected' % (row, col))
                    except IndexError:
                        assert_equals(value, '')

        def test_simple_undo(self):
            self._editor.SelectBlock(*(0, 0, 0, 0))
            self._editor.cut()
            self._editor.undo()
            self._verify_grid_content(DATA)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_gridcolorizer
import unittest
import random

from robot.libraries.String import String


from robotide.controller.cellinfo import CellInfo, ContentType, CellType,\
    CellContent, CellPosition
from robotide.editor.gridcolorizer import Colorizer, ColorizationSettings

from resources import PYAPP_REFERENCE as _ #Needed to be able to create wx components

# wx needs to imported last so that robotide can select correct wx version.
import wx


class MockGrid(object):
    SetCellTextColour = SetCellBackgroundColour = SetCellFont = lambda s, x, y, z: True

    def GetCellFont(self, x, y):
        return Font()


class Font(object):
    SetWeight = lambda s, x: True


class ControllerWithCellInfo(object):
    content_types = [getattr(ContentType, i) for i in dir(ContentType) if not i.startswith('__') ]
    cell_types = [getattr(CellType, i) for i in dir(CellType) if not i.startswith('__') ]

    def __init__(self):
        self._string = String()

    def get_cell_info(self, row, column):
        return CellInfo(CellContent(self._get(self.content_types), self._get_data(), None),
                        CellPosition(self._get(self.cell_types), None))

    def _get(self, items):
        return items[random.randint(0, len(items)-1)]

    def _get_data(self):
        if random.randint(0, 5) == 0:
            return "data with some ${variable} in there"
        return self._string.generate_random_string(50)


class TestPerformance(unittest.TestCase):
    _data = ['Keyword', 'Some longer data in cell', '${variable}', 
             '#asdjaskdkjasdkjaskdjkasjd', 'asdasd,asdasd,as asd jasdj asjd asjdj asd']

    def test_colorizing_performance(self):
        colorizer = Colorizer(MockGrid(), ControllerWithCellInfo(), ColorizationSettings())
        for _ in range(0, 500):
            colorizer._colorize_cell(1,1, self._data[random.randint(0, 4)])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_macroeditors
#  Copyright 2008-2011 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import unittest
import wx
from editor.fakeplugin import FakePlugin
from robot.utils.asserts import assert_true, assert_false
from robotide.controller.macrocontrollers import TestCaseController
from robotide.editor.macroeditors import TestCaseEditor

TestCaseEditor._populate = lambda self: None

class mock(object):

    def __getattr__(self, item):
        return self

    def __call__(self, *args, **kwargs):
        return self

class MockKwEditor(object):

    _expect = None
    _called = None

    def __getattr__(self, item):
        self._active_item = item
        return self

    def __call__(self, *args, **kwargs):
        self._called = self._active_item

    def is_to_be_called(self):
        self._expect = self._active_item

    def has_been_called(self):
        return self._active_item == self._expect == self._called

class MacroEditorTest(unittest.TestCase):

    def setUp(self):
        controller = TestCaseController(mock(), mock())
        plugin = FakePlugin({}, controller)
        self.tc_editor = TestCaseEditor(plugin, wx.Frame(None), controller, None)

    def test_delegation_to_kw_editor(self):
        for method, kw_method in [('save', 'save'),
                                  ('undo', 'OnUndo'),
                                  ('redo', 'OnRedo'),
                                  ('cut', 'OnCut'),
                                  ('copy', 'OnCopy'),
                                  ('paste', 'OnPaste'),
                                  ('insert', 'OnInsert'),
                                  ('insert_rows', 'OnInsertRows'),
                                  ('delete_rows', 'OnDeleteRows'),
                                  ('delete', 'OnDelete'),
                                  ('comment', 'OnCommentRows'),
                                  ('uncomment', 'OnUncommentRows'),
                                  ('show_content_assist', 'show_content_assist')]:
            kw_mock = MockKwEditor()
            self.tc_editor.kweditor = kw_mock
            getattr(kw_mock, kw_method).is_to_be_called()
            getattr(self.tc_editor, method)()
            assert_true(getattr(kw_mock, kw_method).has_been_called(),
                        'Should have called "%s" when calling "%s"' % (kw_method, method))




########NEW FILE########
__FILENAME__ = test_tags
import unittest
from robotide.editor.tags import TagsDisplay
from controller.controller_creator import testcase_controller as tc
from robot.utils.asserts import assert_equals
from robotide.controller.tags import Tag

class _PartialTagsDisplay(TagsDisplay):

    def __init__(self, controller):
        self._tag_boxes = []
        self._controller = controller

    def add_tag(self, tag):
        self._tag_boxes += [_TagInfo(tag, True)]

    def build(self):
        pass

class _TagInfo(object):

    add_new = False

    def __init__(self, tag, editable):
        self.set_tag(tag)
        self.SetEditable(editable)

    @property
    def enabled(self):
        return self._editable

    @property
    def value(self):
        return self._tag.name

    def GetValue(self):
        if self._tag.is_empty(): return ''
        return self.value

    def is_empty(self):
        return self._tag.is_empty()

    def set_tag(self, tag):
        self._tag = tag

    def SetEditable(self, editable):
        self._editable = editable

    def Destroy(self):
        pass

class TestTagsModifications(unittest.TestCase):

    def setUp(self):
        self._cntrl = tc()
        self._tags_display = _PartialTagsDisplay(self._cntrl.tags)

    @property
    def tagboxes(self):
        return self._tags_display._tag_boxes

    def test_set_empty_value(self):
        self._tags_display.set_value(self._cntrl.tags)
        assert_equals(len(self.tagboxes), 0)

    def test_set_non_empty_value(self):
        tag = Tag('moro')
        self._cntrl.tags.add(tag)
        self._tags_display.set_value(self._cntrl.tags)
        assert_equals(len(self.tagboxes), 1)
        assert_equals(self.tagboxes[0]._tag, tag)

    def test_remove_only_tag(self):
        self.test_set_non_empty_value()
        self._cntrl.tags.clear()
        self._tags_display.clear()
        assert_equals(len(self.tagboxes), 0)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_embedded_args
import unittest
from robotide.namespace.embeddedargs import EmbeddedArgsHandler
from robot.utils.asserts import assert_true, assert_raises, assert_false


class KWMock(object):

    def __init__(self, name, args=None):
        self.name = name
        self.arguments = args


class TestEmbeddedArgs(unittest.TestCase):

    def test_extra_arguments_are_illegal(self):
        assert_raises(TypeError, EmbeddedArgsHandler,
                            KWMock('add user ${user} to db', ['${arg}']))

    def test_no_embedded_arguments(self):
        assert_raises(TypeError, EmbeddedArgsHandler,
                            KWMock('no embedded args'))

    def test_embedded_args(self):
        args = EmbeddedArgsHandler(KWMock('add user ${user} to db'))
        assert_true(args.name_regexp.match('add user test to db'))
        assert_false(args.name_regexp.match('add user test to somewhere else'))

    def test_several_args(self):
        args = EmbeddedArgsHandler(KWMock('${user} should ${foo} and ${bar}'))
        assert_true(args.name_regexp.match('john should eat and drink'))
        assert_false(args.name_regexp.match('this should not match'))

    def test_custom_variable_regexp(self):
        args = EmbeddedArgsHandler(KWMock('Say hello to ${user:[A-C]+}'))
        assert_true(args.name_regexp.match('Say hello to ABC'))
        assert_false(args.name_regexp.match('Say hello to ABCD'))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_expiring_cache
import unittest
import time
from robot.utils.asserts import assert_none, assert_equals

from robotide.namespace.cache import ExpiringCache


class TestExpiringCache(unittest.TestCase):

    def test_cache_hit(self):
        cache = ExpiringCache(0.1)
        cache.put('a', 'b')
        assert_equals('b', cache.get('a'))

    def test_cache_expiration(self):
        cache = ExpiringCache(0.01)
        cache.put('a', 'b')
        time.sleep(0.1)
        assert_none(cache.get('a'))
        cache.put('a', 'c')
        assert_equals('c', cache.get('a'))


if __name__ == "__main__":
    unittest.main()
########NEW FILE########
__FILENAME__ = test_keywords
import unittest
from robotide.namespace.namespace import _Keywords
from robot.utils.asserts import assert_true, assert_false, assert_equals


class ItemMock(object):

    def __init__(self, name, args, long):
        self.name = name
        self.arguments = args
        self.longname = long


class TestKeywords(unittest.TestCase):

    def setUp(self):
        self.kws = _Keywords([ItemMock('My kw', ['${arg}'], 'source.My kw'),
                       ItemMock('Given foo', [], 'source.Given foo'),
                       ItemMock('${user} should ${foo} and ${bar}', [], 'longem'),
                       ItemMock('this ${has} real args', ['${arg}'], 'long.normal')])

    def test_parse_keywords(self):
        assert_true(self.kws.get('My kw'))

    def test_normalize(self):
        assert_true(self.kws.get('mykw'))
        assert_true(self.kws.get('M Y     KW'))
        assert_false(self.kws.get('my kw?'))

    def test_underscore_normalization(self):
        assert_true(self.kws.get('m_ykw'))
        assert_true(self.kws.get('_mY_kw_'))

    def test_longname(self):
        assert_true(self.kws.get('source.my kw'))

    def test_given_when_then(self):
        assert_true(self.kws.get('Given foo'))
        assert_true(self.kws.get('Given my kw'))
        assert_true(self.kws.get('When my kw'))
        assert_true(self.kws.get('then mykw'))
        assert_true(self.kws.get('  and  given foo'))

    def test_embedded_args(self):
        assert_true(self.kws.get('john should embed arguments and something'))
        assert_true(self.kws.get('WHEN john should embed arguments and something'))
        assert_false(self.kws.get('this keyword has real args'))

    def test_embedded_args_are_space_sensitive(self):
        assert_false(self.kws.get('john shouldembed arguments and something'))
        assert_false(self.kws.get('given johnshould embed arguments and something'))

    def test_first_come_prioritized_when_same_short_name(self):
        kws = _Keywords([ItemMock('My kw', ['${arg}'], 'source.My kw'),
                       ItemMock('My kw', [], 'Collision!')])
        assert_equals(kws.get('My kw').arguments, ['${arg}'])
        assert_equals(kws.get('Collision!').arguments, [])


if __name__ == "__main__":
    unittest.main()
########NEW FILE########
__FILENAME__ = test_library_cache
import unittest
import sys
import os
from robot.running.timeouts.stoppablethread import Thread

from robotide.namespace.cache import LibraryCache

from resources import DATAPATH
from robotide.spec.librarymanager import LibraryManager

sys.path.append(os.path.join(DATAPATH, 'libs'))


class TestLibraryCache(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls._library_manager = LibraryManager(':memory:')
        cls._library_manager.start()
        cls._library_manager.create_database()

    @classmethod
    def tearDownClass(cls):
        cls._library_manager.stop()
        cls._library_manager = None

    def test_auto_importing_libraries(self):
        cache = self._create_cache_with_auto_imports('TestLib')
        self._assert_keyword_in_keywords(cache.get_default_keywords(), 'Testlib Keyword')

    def test_auto_importing_libraries_with_arguments(self):
        cache = self._create_cache_with_auto_imports('ArgLib|foo')
        self._assert_keyword_in_keywords(cache.get_default_keywords(), 'Get Mandatory')

    def test_importing_library_with_dictionary_arg(self):
        LibraryCache({}, lambda:0, self._library_manager)._get_library('ArgLib', [{'moi':'hoi'}, []])

    def test_importing_from_two_threads(self):
        cache = self._create_cache_with_auto_imports('TestLib')
        self._thread_results = []
        def check_test_lib_keyword():
            cache.get_default_keywords()
            self._thread_results.append('ok')
        t1 = Thread(runner=check_test_lib_keyword)
        t2 = Thread(runner=check_test_lib_keyword)
        t1.start()
        t2.start()
        t1.join()
        t2.join()
        self.assertEqual(['ok', 'ok'], self._thread_results)

    def _create_cache_with_auto_imports(self, auto_import):
        settings = {'auto imports': [auto_import]}
        return LibraryCache(settings, lambda:0, self._library_manager)

    def _assert_keyword_in_keywords(self, keywords, name):
        for kw in keywords:
            if kw.name == name:
                return
        raise AssertionError('Keyword %s not found in default keywords' % name)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_local_namespace
import unittest
from robot.utils.asserts import assert_equals, assert_false, assert_true
import datafilereader


class TestLocalNamespace(unittest.TestCase):

    def setUp(self):
        self._chief = datafilereader.construct_chief_controller(datafilereader.SIMPLE_PROJECT)
        self._test = datafilereader.get_ctrl_by_name('Test Case', self._chief.datafiles[0].tests)
        self._keyword = datafilereader.get_ctrl_by_name('Keyword', self._chief.datafiles[0].keywords)

    def tearDown(self):
        self._chief.close()

    def test_macro_controller_has_local_namespace(self):
        assert_true(self._test.get_local_namespace() is not None)
        assert_true(self._keyword.get_local_namespace() is not None)

    def test_keyword_argument_is_visible_in_keywords_local_namespace(self):
        assert_true(self._keyword.get_local_namespace().has_name('${argument}'))

    def test_keyword_argument_is_not_visible_in_test_cases_local_namespace(self):
        assert_false(self._test.get_local_namespace().has_name('${argument}'))

    def test_keyword_steps_local_namespace_does_not_contain_local_variables_before_definition(self):
        for i in range(8):
            local_namespace = self._keyword.get_local_namespace_for_row(i)
            if i < 3:
                assert_false(local_namespace.has_name('${foo}'))
            if i < 5:
                assert_false(local_namespace.has_name('${bar}'))
            if i < 7:
                assert_false(local_namespace.has_name('${i}'))

    def test_keyword_steps_local_namespace_does_contain_local_variables_after_definition(self):
        for i in range(8):
            local_namespace = self._keyword.get_local_namespace_for_row(i)
            assert_true(local_namespace.has_name('${argument}'))
            if i >= 3:
                assert_true(local_namespace.has_name('${foo}'))
            if i >= 5:
                assert_true(local_namespace.has_name('${bar}'))
            if i >= 7:
                assert_true(local_namespace.has_name('${i}'))

    def test_keyword_steps_suggestions_with_local_variables(self):
        self._verify_suggestions_on_row(0, contains=['${argument}'], does_not_contain=['${foo}', '${bar}', '${i}'])
        self._verify_suggestions_on_row(3, contains=['${argument}', '${foo}'], does_not_contain=['${bar}', '${i}'])
        self._verify_suggestions_on_row(5, contains=['${argument}', '${foo}', '${bar}'], does_not_contain=['${i}'])
        self._verify_suggestions_on_row(7, contains=['${argument}', '${foo}', '${bar}', '${i}'])

    def test_suggestions_when_empty_text(self):
        self._verify_suggestions_on_row(4, start='', contains=['${argument}', '${foo}'], does_not_contain=['${bar}'])

    def test_suggestions_when_no_match(self):
        self._verify_suggestions_on_row(5, start='${no match}', does_not_contain=['${argument}', '${foo}', '${bar}'])

    def test_suggestions_when_only_part_matches(self):
        self._verify_suggestions_on_row(4, start='${f', contains=['${foo}'], does_not_contain=['${argument}', '${bar}'])
        self._verify_suggestions_on_row(4, start='fo', contains=['${foo}'], does_not_contain=['${argument}', '${bar}'])

    def _verify_suggestions_on_row(self, row, start='${', contains=None, does_not_contain=None):
        suggestion_names = [suggestion.name for suggestion in self._keyword.get_local_namespace_for_row(row).get_suggestions(start)]
        self.assertEquals(len(suggestion_names), len(set(suggestion_names)))
        if contains:
            for name in contains:
                if name not in suggestion_names:
                    raise AssertionError('Suggestions on row (%s) did not contain expected value "%s"' % (str(row), name))
        if does_not_contain:
            for name in does_not_contain:
                if name in suggestion_names:
                    raise AssertionError('Suggestions on row (%s) did contain illegal value "%s"' % (str(row), name))




if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_namespace
import sys
import unittest

from robot.parsing.settings import Resource
from robot.parsing.model import VariableTable, TestDataDirectory
from robot.utils import robotpath
from robot.utils.asserts import assert_true, assert_false, assert_not_none, \
    assert_equals, fail, assert_none
from resources.mocks import FakeSettings
from robotide.namespace.namespace import _VariableStash
from robotide.robotapi import TestCaseFile
from robotide.controller.filecontrollers import DataController
from datafilereader import *
from robotide.spec.iteminfo import ArgumentInfo, VariableInfo
from robotide.context import IS_WINDOWS
from robotide.spec.librarymanager import LibraryManager

RESOURCES_DIR = 'resources'

sys.path.append(os.path.join(os.path.dirname(__file__), '..', RESOURCES_DIR,
                             'robotdata', 'libs'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..', RESOURCES_DIR,
                             'robotdata', 'put_into_python_path'))

OS_LIB = 'OperatingSystem'
COLLECTIONS_LIB = 'Collections'
STRING_LIB = 'String'
TELNET_LIB = 'Telnet'
TELNET_LIB_ALIAS = 'telikka'
RES_NAME_VARIABLE = '${resname}'
LIB_NAME_VARIABLE = '${libname}'
UNRESOLVABLE_VARIABLE = '${unresolvable}'
UNKNOWN_VARIABLE = '${this var does not exist}'
EXTENSION_VAR = '${extension}'
EXTENSION = 'txt'
INVALID_FILE_PATH = '/this/is/invalid.py'
EXISTING_USER_KEYWORD = 'Should be in keywords Uk'
COLLIDING_ARGUMENT = '${colliding argument}'
COLLIDING_CONSTANT = COLLIDING_ARGUMENT.upper()

def _build_test_case_file():
    tcf = TestCaseFile()
    tcf.source = 'tmp.txt'
    tcf.directory = '/tmp/'
    _add_settings_table(tcf)
    _add_variable_table(tcf)
    _add_keyword_table(tcf)
    return tcf

def _add_settings_table(tcf):
    tcf.setting_table.add_library(OS_LIB)
    tcf.setting_table.add_resource(RESOURCE_PATH)
    tcf.setting_table.add_resource(RESOURCE_LIB_PATH)
    tcf.setting_table.add_resource(RES_NAME_VARIABLE)
    tcf.setting_table.add_library(LIB_NAME_VARIABLE)
    tcf.setting_table.add_library(LIB_NAME_VARIABLE)
    tcf.setting_table.add_library(UNRESOLVABLE_VARIABLE)
    tcf.setting_table.add_library(LIBRARY_WITH_SPACES_IN_PATH)
    tcf.setting_table.add_library(TELNET_LIB, ['WITH NAME', TELNET_LIB_ALIAS])
    tcf.setting_table.add_resource(RESOURCE_WITH_VARIABLE_IN_PATH)
    tcf.setting_table.add_variables(INVALID_FILE_PATH)

def _add_variable_table(tcf):
    tcf.variable_table.add(LIB_NAME_VARIABLE, COLLECTIONS_LIB)
    tcf.variable_table.add(RES_NAME_VARIABLE, RESOURCE_WITH_VARS)
    tcf.variable_table.add(EXTENSION_VAR, EXTENSION)
    tcf.variable_table.add(UNRESOLVABLE_VARIABLE, UNKNOWN_VARIABLE)
    tcf.variable_table.add(COLLIDING_CONSTANT, 'collision')

def _add_keyword_table(tcf):
    uk_table = tcf.keyword_table
    uk_table.add(EXISTING_USER_KEYWORD)
    uk_table.keywords[0].args.value = ['${keyword argument}', '${colliding argument}', '${keyword argument with default} = default']


class ParentMock(object):
    source = '/tmp/example/parentmock'
    directory = '/tmp/exmaple'


class _DataFileTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.tcf = _build_test_case_file()
        cls.tcf_ctrl = DataController(cls.tcf, None)
        cls.kw = cls.tcf_ctrl.keywords[0]
        cls.ns = Namespace(FakeSettings())
        cls.library_manager = LibraryManager(':memory:')
        cls.library_manager.start()
        cls.library_manager.create_database()
        cls.ns.set_library_manager(cls.library_manager)

    @classmethod
    def tearDownClass(cls):
        cls.library_manager.stop()
        cls.library_manager = None


class TestKeywordSuggestions(_DataFileTest):

    def test_getting_suggestions_for_empty_datafile(self):
        start = 'shOulD'
        sugs = self.ns.get_suggestions_for(self.kw, start)
        assert_true(len(sugs) > 0)
        for s in sugs:
            assert_true(s.name.lower().startswith(start.lower()))

    def test_getting_suggestions_in_order(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'sHoUlD')
        assert_true(len(sugs) > 2)
        assert_equals(sugs, sorted(sugs))

    def test_user_keywords(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'sHoUlD')
        assert_true(EXISTING_USER_KEYWORD in [s.name for s in sugs])

    def test_imported_lib_keywords(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'create file')
        self._assert_import_kws(sugs, OS_LIB)

    def test_lib_from_resource_file(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'generate random')
        self._assert_import_kws(sugs, STRING_LIB)

    def test_lib_import_from_var(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'Copy List')
        self._assert_import_kws(sugs, COLLECTIONS_LIB)

    def test_lib_import_with_spaces(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'space')
        sugs = [s for s in sugs if not isinstance(s, VariableInfo)] #remove variable suggestions
        self._assert_import_kws(sugs, 'spacelib')

    def test_resource_file_keywords(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'Resource Uk')
        self._assert_import_kws(sugs, RESOURCES_HTML)

    def test_resource_file_keyword_with_longname(self):
        sugs = self.ns.get_suggestions_for(self.kw, RESOURCES_HTML.replace('.html', '') + '.Resource Uk')
        self._assert_import_kws(sugs, RESOURCES_HTML)

    def test_keywords_normalization(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'Reso   Urceuk')
        self._assert_import_kws(sugs, RESOURCES_HTML)

    def test_uk_from_resource_files_resource_file(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'UK From Text Resource')
        self._assert_import_kws(sugs, 'resource.txt')

    def test_resource_file_from_variable(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'UK From Variable Resource')
        self._assert_import_kws(sugs, 'resource_with_variables.txt')

    def test_resource_file_from_resource_file_with_variable(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'UK From Resource from Resource with Variable')
        self._assert_import_kws(sugs, 'resource_from_resource_with_variable.txt')

    def test_library_from_resourcefile_variable(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'Execute Manual')
        self._assert_import_kws(sugs, 'Dialogs')

    def test_xml_library(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_EVERYTHING).keywords[0], 'Attributeless Keyword')
        self._assert_import_kws(sugs, 'LibSpecLibrary')

    def test_xml_library_is_library_keyword(self):
        everything_tcf = TestCaseFile(source=TESTCASEFILE_WITH_EVERYTHING).populate()
        assert_true(self.ns.is_library_keyword(everything_tcf, 'Attributeless Keyword'))

    def test_variable_path_separator(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_EVERYTHING).keywords[0], 'foo')
        self._assert_import_kws(sugs, 'even_more_resources.txt')

    def test_keywords_only_once_per_source(self):
        sugs = self.ns.get_suggestions_for(self.kw, '')
        kw_set = []
        for kw in sugs:
            if self._not_variable(kw):
                key = 'kw: %s %s' % (kw.name, kw.source)
                assert_false(key in kw_set, key)
                kw_set.append(key)

    def _not_variable(self, item):
        return not (item.name.startswith('$') or item.name.startswith('@'))

    def test_global_variable_list_suggestions(self):
        global_vars = [name for name in _VariableStash.global_variables]
        self._test_global_variable(global_vars[0])
        self._test_global_variable(global_vars[5])
        self._test_global_variable(global_vars[-1])

    def _test_global_variable(self, variable, expected=None):
        assert_equals(expected or variable, self.ns.get_suggestions_for(self.kw, variable)[0].name)

    def test_resource_with_variable_in_path(self):
        sugs = self.ns.get_suggestions_for(self.kw, 'Resu UK')
        self._assert_import_kws(sugs, 'resu.txt')

    def test_variable_suggestion(self):
        scalar_vars = self.ns.get_suggestions_for(self.kw, '$')
        assert_true(len(scalar_vars) > 0)
        assert_true(len(self.ns.get_suggestions_for(self.kw, '${')) == len(scalar_vars))
        list_vars = self.ns.get_suggestions_for(self.kw, '@')
        assert_true(len(list_vars) > 0)
        assert_true(len(self.ns.get_suggestions_for(self.kw, '@{')) == len(list_vars))
        sug = self.ns.get_suggestions_for(self.kw, '${lib')
        assert_true(sug[0].name == LIB_NAME_VARIABLE)

    def test_variable_suggestions_without_varwrapping(self):
        self._test_global_variable('space', '${SPACE}')
        self._test_global_variable('EMP', '${EMPTY}')

    def test_vars_from_file(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_EVERYTHING).keywords[0],
                                           '${var_from_file')
        assert_true(len(sugs) > 0)

    def _get_controller(self, source):
        return DataController(TestCaseFile(source=source).populate(), None)

    def test_library_arguments_are_resolved(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_EVERYTHING).keywords[0],
                                           'Get ')
        assert_true(len(sugs) > 0)
        for item in sugs:
            if item.name == 'Get Mandatory':
                return
        fail('Get mandatory not found')

    def test_vars_from_path_resource_file(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_EVERYTHING).keywords[0],
                                           '${Path RESOURCE var')
        assert_true(len(sugs) > 0)

    def test_variable_file_arguments_are_resolved(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_EVERYTHING).keywords[0],
                                           '${dyn ')
        assert_true(len(sugs) > 0)

    def test_variable_file_variables_are_available_in_resource_imports(self):
        sugs = self.ns.get_suggestions_for(self._get_controller(TESTCASEFILE_WITH_RESOURCES_WITH_VARIABLES_FROM_VARIABLE_FILE).tests[0],
                                           'from resource with variable in pa')
        self._assert_import_kws(sugs, 'res.txt')

    def test_vars_from_keyword_arguments(self):
        sugs = self.ns.get_suggestions_for(self.kw, '${keyword argu')
        assert_equals(len(sugs), 2)
        sugs = self.ns.get_suggestions_for(self.kw, '${keyword argument with defau')
        assert_equals(len(sugs), 1)
        self._check_source(self.kw, '${keyword argument with defau', ArgumentInfo.SOURCE)

    def test_argument_is_superior_to_variable_from_variable_table(self):
        sugs = self.ns.get_suggestions_for(self.kw, COLLIDING_ARGUMENT[0:4])
        assert_true(any(True for s in sugs if s.source == ArgumentInfo.SOURCE))

    def test_keyword_arguments_are_suggested_first(self):
        sugs = self.ns.get_suggestions_for(self.kw, '')
        self._assert_import_kws(sugs[:2], ArgumentInfo.SOURCE)

    def test_suggestions_for_datafile(self):
        sugs = self.ns.get_suggestions_for(self.tcf_ctrl, 'Execute Manual')
        self._assert_import_kws(sugs, 'Dialogs')
        sugs = self.ns.get_suggestions_for(self.tcf_ctrl, '${libna')
        assert_true(len(sugs) == 1)

    def test_variable_sources(self):
        everything_tcf = self._get_controller(TESTCASEFILE_WITH_EVERYTHING)
        self._check_source(everything_tcf, '${arg}', 'everything.html')
        self._check_source(everything_tcf, '@{list}', 'everything.html')
        self._check_source(everything_tcf, '${dynamic var}', 'dynamic_varz.py')
        self._check_source(everything_tcf, '${OPERATING SYSTEM}', 'another_resource.html')

    def test_relative_imports(self):
        relative_tcf = self._get_controller(RELATIVE_IMPORTS)
        self._check_source(relative_tcf, 'local', 'local')

    def _check_source(self, controller, name, source):
        sugs = self.ns.get_suggestions_for(controller, name)
        assert_equals(len(sugs), 1)
        assert_equals(sugs[0].source, source)

    def _assert_import_kws(self, sugs, source):
        assert_true(len(sugs) > 0)
        for s in sugs:
            assert_true(s.source.endswith(source),
                        '%s does not end with %s' % (s.source, source))

    def test_reset(self):
        sugs  = self.ns.get_suggestions_for(self.kw, 'generate random')
        sugs2 = self.ns.get_suggestions_for(self.kw, 'generate random')
        assert_true(sugs[0] is sugs2[0])
        self.ns.reset_resource_and_library_cache()
        sugs3 = self.ns.get_suggestions_for(self.kw, 'generate random')
        assert_false(sugs[0] is sugs3[0])


class TestKeywordSearch(_DataFileTest):

    def test_is_library_keyword(self):
        assert_true(self.ns.is_library_keyword(self.tcf, 'Should Be Equal'))
        assert_false(self.ns.is_library_keyword(self.tcf, 'kameli'))
        assert_false(self.ns.is_library_keyword(self.tcf, 'UK From Resource from Resource with Variable'))

    def test_is_library_keyword_longname(self):
        assert_true(self.ns.is_library_keyword(self.tcf, 'Builtin.Should Be Equal'))

    def test_is_library_keyword_longname_with_alias(self):
        assert_true(self.ns.is_library_keyword(self.tcf, TELNET_LIB_ALIAS+'.LOGIN'))

    def test_find_default_keywords(self):
        all_kws = self.ns.get_all_keywords([])
        assert_not_none(all_kws)
        self.assert_in_keywords(all_kws, 'Should Be Equal')

    def test_find_suite_keywords(self):
        everything_tcf = TestCaseFile(source=TESTCASEFILE_WITH_EVERYTHING).populate()
        all_kws = self.ns.get_all_keywords([self.tcf, everything_tcf])
        self.assert_in_keywords(all_kws, 'Should be in keywords Uk',
                                         'Copy List',
                                         'Uk From Variable Resource')
        self.assert_in_keywords(all_kws, 'My Test Setup',
                                         'My Suite Teardown')

    def test_resource_kws_only_once(self):
        directory = TestDataDirectory(source=SIMPLE_TEST_SUITE_PATH).populate()
        all_kws = self.ns.get_all_keywords(directory.children)
        self._check_resource_keyword_only_once(all_kws)

    def test_resource_kws_only_once_through_chief_controller(self):
        chief = construct_chief_controller(SIMPLE_TEST_SUITE_PATH)
        all_kws = chief.get_all_keywords()
        chief.close()
        self._check_resource_keyword_only_once(all_kws)

    def _check_resource_keyword_only_once(self, all_kws):
        results = [(kw.name, kw.source) for kw in all_kws if kw.name == "Only From Resource"]
        assert_equals(len(results), 1)
        assert_equals(results[0], (u'Only From Resource', u'testdata_resource.txt'))

    def test_find_user_keyword_name_normalized(self):
        assert_not_none(self.ns.find_user_keyword(self.tcf, 'UK Fromresource from rESOURCE with variaBLE'))
        assert_none(self.ns.find_user_keyword(self.tcf, 'Copy List'))

    def test_is_user_keyword(self):
        assert_true(self.ns.is_user_keyword(self.tcf, 'UKFromResource from ResourcewithVariable'))
        assert_false(self.ns.is_user_keyword(self.tcf, 'hevoinen'))
        assert_false(self.ns.is_user_keyword(self.tcf, 'Should Be Equal'))

    def test_is_user_keyword_in_resource_file(self):
        everything_tcf = TestCaseFile(source=TESTCASEFILE_WITH_EVERYTHING).populate()
        assert_not_none(self.ns.find_user_keyword(everything_tcf, 'Duplicate UK'))
        assert_true(self.ns.is_user_keyword(everything_tcf, 'Duplicate UK'))
        assert_not_none(self.ns.find_user_keyword(everything_tcf, 'Another Resource UK'))
        assert_true(self.ns.is_user_keyword(everything_tcf, 'Another Resource UK'))

    def test_given_when_then_and_aliases(self):
        assert_not_none(self.ns.find_user_keyword(self.tcf, '  Given   UK Fromresource from rESOURCE with variaBLE'))
        assert_not_none(self.ns.find_user_keyword(self.tcf, 'when  UK Fromresource from rESOURCE with variaBLE'))
        assert_not_none(self.ns.find_user_keyword(self.tcf, '  then UK Fromresource from rESOURCE with variaBLE'))
        assert_not_none(self.ns.find_user_keyword(self.tcf, 'AND UK Fromresource from rESOURCE with variaBLE'))
        assert_none(self.ns.find_user_keyword(self.tcf, 'given and UK Fromresource from rESOURCE with variaBLE'))

    def assert_in_keywords(self, keywords, *kw_names):
        for kw_name in kw_names:
            if not self._in_keywords(keywords, kw_name):
                fail(kw_name)

    def _in_keywords(self, keywords, kw_name):
        return any([kw_name.lower() == kw.name.lower() for kw in keywords])


class TestVariableStash(unittest.TestCase):

    def test_variable_resolving(self):
        vars = _VariableStash()
        var_table = VariableTable(ParentMock())
        var_table.add('${var1}', 'foo')
        var_table.add('${var2}', 'bar')
        vars.set_from_variable_table(var_table)
        result = vars.replace_variables('hoo${var1}hii${var2}huu')
        assert_equals('hoofoohiibarhuu',result)

    def test_variable_resolving_with_unresolvable_value(self):
        vars = _VariableStash()
        var_table = VariableTable(ParentMock())
        var_table.add('${var1}', '${unresolvable variable}')
        var_table.add('${var2}', 'bar')
        vars.set_from_variable_table(var_table)
        assert_true('${var1}' in [v.name for v in vars])
        assert_true('${var2}' in [v.name for v in vars])

    def test_has_default_values(self):
        vars = _VariableStash()
        assert_true('${SPACE}' in [v.name for v in vars])
        assert_true('${PREV_TEST_MESSAGE}' in [v.name for v in vars])

    def test_global_variable_trues_value_is_replaced_with_true(self):
        assert_equals(_VariableStash().replace_variables('${True}'), True)

    def test_global_variable_falses_value_is_replaced_with_false(self):
        assert_equals(_VariableStash().replace_variables('${False}'), False)

    def test_global_variable_nones_value_is_replaced_with_none(self):
        assert_equals(_VariableStash().replace_variables('${None}'), None)

    def test_global_variable_nulls_value_is_replaced_with_none(self):
        assert_equals(_VariableStash().replace_variables('${null}'), None)


class TestResourceGetter(_DataFileTest):

    def test_resource_getter(self):
        resources = self.ns.get_resources(self.tcf)
        assert_equals(len(resources),8)
        paths = []
        for res in resources:
            normalized = robotpath.normpath(res.source)
            assert_false(normalized in paths)
            paths.append(normalized)


class TestResourceCache(_DataFileTest):

    def setUp(self):
        self._res_cache = self.ns._resource_factory

    def test_file_read_only_once(self):
        imp = Resource(None, RESOURCE_PATH)
        first = self._res_cache.get_resource(imp.directory, imp.name)
        second = self._res_cache.get_resource(imp.directory, imp.name)
        assert_true(first is second)

    def test_file_with_absolute_path(self):
        imp = Resource(ParentMock(), RESOURCE_PATH)
        assert_true(self._res_cache.get_resource(imp.directory, imp.name))

    def test_file_with_invalid_path(self):
        imp = Resource(ParentMock(), '${kumikameli}')
        assert_none(self._res_cache.get_resource(imp.directory, imp.name))

    if IS_WINDOWS:
        def test_case_sensetive_filenames(self):
            imp = Resource(None, RESOURCE_PATH)
            first = self._res_cache.get_resource(imp.directory, imp.name.lower())
            second = self._res_cache.get_resource(imp.directory, imp.name.upper())
            assert_true(first is second)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_ns_performance
import time
import unittest

from robot.utils.asserts import assert_true
from robotide.namespace import Namespace
from robotide.controller.chiefcontroller import ChiefController

from resources import MessageRecordingLoadObserver, FakeSettings
from datafilereader import TESTCASEFILE_WITH_EVERYTHING, KW1000_TESTCASEFILE,\
    KW2000_TESTCASEFILE, KW3000_TESTCASEFILE, KW4000_TESTCASEFILE
from robotide.spec.librarymanager import LibraryManager


class TestNamespacePerformance(unittest.TestCase):
    SAFETY_MARGIN = 0.96
    RELEVANT_B_RELATIVE_TO_C = 0.2

    def test_user_keyword_find_performance(self):
        self._test_keyword_find_performance('is_user_keyword')

    def test_library_keyword_find_performance(self):
        self._test_keyword_find_performance('is_library_keyword')

    def _test_keyword_find_performance(self, find_function_name):
        times = 5000
        end_time = self._execute_keyword_find_function_n_times(find_function_name, times)
        assert_true(end_time < 0.5, 'Checking %d kws took too long: %fs.' % (times, end_time))

    def _FLICKERS_measure_user_keyword_find_performance(self):
        times = 1000
        kw1000_result = self._execute_keyword_find_function_n_times('is_user_keyword', times, KW1000_TESTCASEFILE)
        kw2000_result = self._execute_keyword_find_function_n_times('is_user_keyword', times, KW2000_TESTCASEFILE)
        kw3000_result = self._execute_keyword_find_function_n_times('is_user_keyword', times, KW3000_TESTCASEFILE)
        a, b, c = self._calculate_power2_estimate_constants(kw1000_result, kw2000_result, kw3000_result)
        assert_true(b > c or (c <= 0),
                    'Possibly o(n*2) or greater growth in user keyword performance measures!\nkw1000 time = %s kw2000 time = %s kw3000 time = %s'\
                     % (kw1000_result, kw2000_result, kw3000_result))
        if c > 0 and (b <= 0 or c / b > self.RELEVANT_B_RELATIVE_TO_C):
            kw4000_result = self._execute_keyword_find_function_n_times('is_user_keyword', times, KW4000_TESTCASEFILE)
            self._verify_that_power2_estimate_overestimates(a, b, c, kw1000_result, kw2000_result, kw3000_result, kw4000_result)

    def _verify_that_power2_estimate_overestimates(self, a, b, c, kw1000_result, kw2000_result, kw3000_result, kw4000_result):
        def power2estimate(kw_amount):
            x = kw_amount / 1000
            return a + b * x + c * x**2
        assert_true(power2estimate(4000) * self.SAFETY_MARGIN > kw4000_result,
                   'Possibly o(n*2) or greater growth in namespace performance measures!\nkw1000 time = %s kw2000 time = %s kw3000 time = %s kw4000 time = %s'\
                    % (kw1000_result, kw2000_result, kw3000_result, kw4000_result))


    def _calculate_power2_estimate_constants(self, kw1000_result, kw2000_result, kw3000_result):
        # Assume
        # a + b * 1000kw_amount + c * 1000kw_amount**2
        # THE MATH
        # 1 1 1 [a] = kw1000_result
        # 1 2 4 [b] = kw2000_result
        # 1 3 9 [c] = kw3000_result
        # -- reduce [a]
        # 0 1 3 [b] = kw2000_result-kw1000_result
        # 0 2 8 [c] = kw3000_result-kw1000_result
        # -- reduce [b]
        # 0 0 1 [c] = (kw3000_result-kw1000_result-2*(kw2000_result-kw1000_result))/2
        # -- reduce [c]
        # 1 1 0 [a] = kw1000_result - c
        # 0 1 0 [b] = kw2000_result-kw1000_result - 3*c
        # -- reduce [b]
        # a = kw1000_result - c - b
        c = (kw3000_result-kw1000_result-2*(kw2000_result-kw1000_result))/2
        b = kw2000_result-kw1000_result - 3*c
        a = kw1000_result - c - b
        return a, b, c

    def _load(self, testcasefile):
        ns = Namespace(FakeSettings())
        library_manager = LibraryManager(':memory:')
        library_manager.create_database()
        chief = ChiefController(ns, settings=ns._settings, library_manager=library_manager)
        chief.load_datafile(testcasefile,
                            MessageRecordingLoadObserver())
        return ns, chief._controller.data, library_manager

    def _execute_keyword_find_function_n_times(self, function, n, filename=TESTCASEFILE_WITH_EVERYTHING):
        ns, testcasefile, library_manager = self._load(filename)
        try:
            func = getattr(ns, function)
            func(testcasefile, 'hevonen -1') # execute one time to initialize caches correctly
            start_time = time.time()
            for i in range(n):
                func(testcasefile, 'hevonen %s' % i)
            return time.time() - start_time
        finally:
            library_manager.stop()


########NEW FILE########
__FILENAME__ = test_resourcefactory
import os
import unittest
from robot.parsing.settings import _Import
from resources import FakeSettings
from robotide.context.platform import IS_WINDOWS
from robotide.namespace.resourcefactory import ResourceFactory


class _ResourceFactory(ResourceFactory):
    from_path = None

    def _load_resource(self, path, report_status):
        return object()

    def _get_python_path(self, name):
        if not self.from_path:
            return None
        return os.path.join(self.from_path, name)

    def _remove(self):
        p = self._excludes._exclude_file_path
        if p:
            os.remove(p)


class ResourceFactoryDirectoryIgnoreTestCase(unittest.TestCase):

    def setUp(self):
        self._import = _Import(None, __file__)
        self._context = self._mock_context()

    def tearDown(self):
        if self.r:
            self.r._remove()

    def test_resourcefactory_finds_imported_resource(self):
        self.r = _ResourceFactory(FakeSettings())
        self._is_resolved(self.r)

    def test_resourcefactory_ignores_imported_resource_from_ignore_directory(self):
        self.r = self._create_factory(os.path.dirname(__file__))
        self.assertEqual(None, self.r.get_resource_from_import(self._import, self._context))

    def test_resourcefactory_ignores_imported_resource_from_ignore_subdirectory(self):
        self.r = self._create_factory(os.path.split(os.path.dirname(__file__))[0])
        self.assertEqual(None, self.r.get_resource_from_import(self._import, self._context))

    def test_resourcefactory_finds_imported_resource_when_subdirectory_ignored(self):
        self.r = self._create_factory(os.path.join(os.path.dirname(__file__), 'something'))
        self._is_resolved(self.r)

    def test_resourcefactory_finds_imported_resource_when_similar_ignore_name(self):
        self.r = self._create_factory(os.path.dirname(__file__))
        imp = _Import(None, os.path.join(os.path.dirname(__file__)+'2', 'foo'))
        self._is_resolved(self.r, imp)

    def test_resourcefactory_ignores_imported_resource_when_relative_import(self):
        self.r = self._create_factory(os.path.abspath('.'))
        imp = _Import(None, os.path.join('.', 'foo'))
        self.assertEqual(None, self.r.get_resource_from_import(imp, self._context))

    def test_resourcefactory_finds_imported_resource_from_python_path(self):
        self.r = _ResourceFactory(FakeSettings())
        self.r.from_path = os.path.dirname(__file__)
        self._is_resolved(self.r)

    def test_resourcefactory_ignores_imported_resource_from_python_path(self):
        self.r = self._create_factory(os.path.dirname(__file__))
        self.r.from_path = os.path.dirname(__file__)
        self.assertEqual(None, self.r.get_resource_from_import(self._import, self._context))

    if IS_WINDOWS:

        def test_case_insensitive_ignore_upper(self):
            self._ignore_import(os.path.dirname(__file__).upper())

        def test_case_insensitive_ignore_lower(self):
            self._ignore_import(os.path.dirname(__file__).lower())

        def test_case_insensitive_ignore_relative_with_pattern(self):
            self._ignore_import(os.path.join('*', os.path.dirname(__file__)))

    def _ignore_import(self, exclude_directory):
        self.r = self._create_factory(exclude_directory)
        self.assertEqual(None, self.r.get_resource_from_import(self._import, self._context))

    def _create_factory(self, excluded_dir):
        settings = FakeSettings()
        settings.set('default directory', os.path.dirname(__file__))
        settings.excludes.update_excludes([excluded_dir])
        return _ResourceFactory(settings)

    def _mock_context(self):
        context = lambda:0
        context.vars = context
        context.replace_variables = lambda s: s
        return context

    def _is_resolved(self, factory, imp=None):
        imp = imp or self._import
        self.assertNotEqual(None, factory.get_resource_from_import(imp, self._context))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_retrievercontextfactory
import unittest
from robotide.namespace.namespace import _RetrieverContextFactory
from robot.parsing.model import ResourceFile
from robot.utils.asserts import assert_equals


def datafileWithVariables(vars):
    data = ResourceFile()
    for var in vars:
        data.variable_table.add(var, vars[var])
    return data

class RetrieverContextFactoryTest(unittest.TestCase):

    def test_created_context_has_variable_table_variables(self):
        factory = _RetrieverContextFactory()
        ctx = factory.ctx_for_datafile(datafileWithVariables({'${foo}':'moi',
                                                            '${bar}': 'hoi',
                                                            '@{zoo}': 'koi'}))
        result = ctx.vars.replace_variables('!${foo}!${bar}!@{zoo}!')
        assert_equals(result, "!moi!hoi!['koi']!")

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_suggesters
import unittest
from robotide.controller.filecontrollers import ResourceFileController
from robotide.namespace.suggesters import ResourceSuggester, CachedLibrarySuggester, BuiltInLibrariesSuggester, LibrariesSuggester, HistorySuggester
from robotide.utils import overrides


class _ImportSuggesterHelpers(object):

    def _assert_suggestion_names(self, expected, value):
        self.assertEqual(expected, self._suggestion_names(value))

    def _suggestion_names(self, value):
        return [s.name for s in self._suggester.get_suggestions(value)]


class _ImportSuggesterTests(_ImportSuggesterHelpers):

    def setUp(self):
        self._suggester = self._create_suggester(['foofoo'], ['foofoo', 'foobar', 'barbar', 'doodoo'])

    def test_all_suggestions_with_empty_string(self):
        self._assert_suggestion_names(['barbar', 'doodoo', 'foobar'], '')

    def test_only_matching_suggestion(self):
        self._assert_suggestion_names(['foobar'], 'foo')

    def test_multiple_matching_suggestions(self):
        self._assert_suggestion_names(['barbar', 'foobar'], 'bar')

    def test_no_matching_suggestions(self):
        self._assert_suggestion_names([], 'zoo')

    def _controller(self, imports=(), resources=(), libraries=()):
        controller = lambda:0
        controller.datafile_controller = controller
        controller.relative_path_to = lambda other: other.display_name
        controller.imports = [self._import(i) for i in imports]
        controller._chief_controller = controller
        controller.resources = [self._resource(r) for r in resources]
        controller.get_all_cached_library_names = lambda: libraries[:]
        return controller

    def _resource(self, name):
        data = lambda:0
        data.source = name
        data.directory = '.'
        resource = ResourceFileController(data)
        return resource

    def _import(self, name):
        imp = lambda:0
        imp.name = name
        return imp


class TestResourceSuggester(_ImportSuggesterTests, unittest.TestCase):

    def _create_suggester(self, already_imported=(), available=()):
        return ResourceSuggester(self._controller(imports=already_imported, resources=available))


class TestCachedLibrarySuggester(_ImportSuggesterTests, unittest.TestCase):

    def _create_suggester(self, already_imported=(), available=()):
        return CachedLibrarySuggester(self._controller(imports=already_imported, libraries=available))

class TestBuiltInLibrariesSuggester(_ImportSuggesterHelpers, unittest.TestCase):

    def setUp(self):
        self._suggester = BuiltInLibrariesSuggester()

    def test_returns_all_builtin_libraries_with_empty_string(self):
        self._assert_suggestion_names(['Collections',
                                       'Dialogs',
                                       'OperatingSystem',
                                       'Process',
                                       'Remote',
                                       'Screenshot',
                                       'String',
                                       'Telnet',
                                       'XML'], '')

    def test_returns_matching_builtin_libraries(self):
        self._assert_suggestion_names(['OperatingSystem', 'Remote', 'Telnet'], 'te')

class TestLibrariesSuggester(_ImportSuggesterTests, unittest.TestCase):

    def _create_suggester(self, already_imported=(), available=()):
        self._history_suggester = HistorySuggester()
        return LibrariesSuggester(self._controller(imports=already_imported, libraries=available),
                                  self._history_suggester)

    @overrides(_ImportSuggesterTests)
    def test_all_suggestions_with_empty_string(self):
        self._assert_suggestion_names(['barbar',
                                       'Collections',
                                       'Dialogs',
                                       'doodoo',
                                       'foobar',
                                       'OperatingSystem',
                                       'Process',
                                       'Remote',
                                       'Screenshot',
                                       'String',
                                       'Telnet',
                                       'XML'], '')

    def test_history(self):
        self._assert_suggestion_names([], 'ooz')
        self._history_suggester.store(u'zooZoo')
        self._assert_suggestion_names([u'zooZoo'], 'ooz')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_messages
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest

from robot.utils.asserts import assert_equals, assert_none, assert_false, \
    assert_raises_with_msg, assert_true

from robotide.publish import RideMessage, RideLog, PUBLISHER
from robotide.pluginapi import Plugin


class RideTestMessage(RideMessage):
    pass

class RideMessageWithData(RideMessage):
    data = ['data_item', 'more_data']


class TestSubscribingToEvents(unittest.TestCase):

    def setUp(self):
        self.plugin = SubscribingPlugin()

    def tearDown(self):
        self.plugin.disable()

    def test_subscribing_with_class(self):
        RideTestMessage().publish()
        assert_equals(self.plugin.class_handler_topic, 'ride.test')

    def test_subscribing_with_string(self):
        RideTestMessage().publish()
        assert_equals(self.plugin.string_handler_topic, 'ride.test')

    def test_subscribing_with_string_is_case_insensitive(self):
        RideTestMessage().publish()
        assert_equals(self.plugin.case_insensitive_string_handler_topic,
                      'ride.test')

    def test_event_with_data(self):
        RideMessageWithData(data_item='Data', more_data=[1,2,3]).publish()
        assert_equals(self.plugin.record['data_item'], 'Data')
        assert_equals(self.plugin.record['more_data'], [1,2,3])

    def test_subscribing_multiple_times(self):
        RideTestMessage().publish()
        assert_equals(self.plugin.count, 5)

    def test_subscribing_to_multiple_topics(self):
        RideMessageWithData(data_item='', more_data={}).publish()
        RideTestMessage().publish()
        assert_equals(self.plugin.multi_events,
                      ['ride.message.with.data', 'ride.test'])

    def test_subscribing_to_hierarchy(self):
        RideTestMessage().publish()
        RideMessageWithData(data_item=None, more_data=[]).publish()
        assert_equals(self.plugin.hierarchy_events,
                      ['ride.test', 'ride.message.with.data'])


class TestUnsubscribingFromEvents(unittest.TestCase):

    def setUp(self):
        self.plugin = SubscribingPlugin()
        self._unsubscribe_all = True

    def tearDown(self):
        if self._unsubscribe_all:
            self.plugin.unsubscribe_all()

    def test_unsubscribe_with_class(self):
        listener_count = len(PUBLISHER._listeners[self.plugin])
        self.plugin.unsubscribe(self.plugin.OnTestEventClass, RideTestMessage)
        RideTestMessage().publish()
        assert_none(self.plugin.class_handler_topic)
        assert_equals(len(PUBLISHER._listeners[self.plugin]), listener_count-1)

    def test_unsubscribe_with_string(self):
        self.plugin.unsubscribe(self.plugin.OnTestEventString, 'ride.test')
        RideTestMessage().publish()
        assert_none(self.plugin.string_handler_topic)

    def test_unsubscribe_with_string_is_case_insensitive(self):
        self.plugin.unsubscribe(self.plugin.OnTestEventStringWrongCase, 'RiDe.TEst')
        RideTestMessage().publish()
        assert_none(self.plugin.case_insensitive_string_handler_topic)

    def test_unsubscribing_multiple_times_subscribed_once(self):
        self.plugin.unsubscribe(self.plugin.counting_handler, RideTestMessage)
        RideTestMessage().publish()
        assert_equals(self.plugin.count, 4)

    def test_unsubscribing_multiple_times_subscribed_all(self):
        for _ in range(5):
            self.plugin.unsubscribe(self.plugin.counting_handler, RideTestMessage)
        RideTestMessage().publish()
        assert_equals(self.plugin.count, 0)

    def test_unsubscribing_from_hierarchy(self):
        self.plugin.unsubscribe(self.plugin.hierarchical_listener, RideMessage)
        RideTestMessage().publish()
        RideMessageWithData(data_item='Data', more_data=[1,2,3]).publish()
        assert_equals(self.plugin.hierarchy_events, [])

    def test_unsubscribing_from_one_of_the_multiple_topics(self):
        self.plugin.unsubscribe(self.plugin.multiple_events_listening_handler,
                                RideMessageWithData)
        RideMessageWithData(data_item='data', more_data='').publish()
        RideTestMessage().publish()
        assert_equals(self.plugin.multi_events, ['ride.test'])

    def test_unsubscribing_from_multiple_topics(self):
        self.plugin.unsubscribe(self.plugin.multiple_events_listening_handler,
                                'Ride.test', RideMessageWithData)
        RideTestMessage().publish()
        RideMessageWithData(data_item='data', more_data='').publish()
        assert_equals(self.plugin.multi_events, [])

    def test_unsubscribing_from_not_subscribed_event_does_not_fail(self):
        self.plugin.unsubscribe(self.plugin.OnTestEventClass, 'Non.existing')

    def test_unsubscribe_all(self):
        self.plugin.unsubscribe_all()
        self._unsubscribe_all = False
        RideTestMessage().publish()
        RideMessageWithData(data_item='Data', more_data=[1,2,3]).publish()
        assert_none(self.plugin.class_handler_topic)
        assert_none(self.plugin.string_handler_topic)
        assert_none(self.plugin.case_insensitive_string_handler_topic)
        assert_equals(self.plugin.record, {})
        assert_equals(self.plugin.count, 0)
        assert_equals(self.plugin.hierarchy_events, [])
        assert_false(self.plugin in PUBLISHER._listeners)


class TestBrokenMessageListener(unittest.TestCase):

    def setUp(self):
        self.plugin = BrokenListenerPlugin()

    def tearDown(self):
        self.plugin.disable()

    def test_broken_listener(self):
        self.plugin.subscribe(self.plugin.error_listener, RideLog)
        RideTestMessage().publish()
        assert_true(self.plugin.error.message.startswith('Error in listener: ride.test'),
                    'Wrong error message text: ' + self.plugin.error.message)
        assert_equals(self.plugin.error.topic, 'ride.log.exception')
        assert_equals(self.plugin.error.level, 'ERROR')

    def test_broken_error_listener_does_not_cause_infinite_recusrion(self):
        self.plugin.subscribe(self.plugin.broken_listener, RideLog)


class BrokenListenerPlugin(Plugin):

    def __init__(self):
        self.subscribe(self.broken_listener, RideTestMessage)

    def disable(self):
        self.unsubscribe_all()

    def broken_listener(self, message):
        raise RuntimeError(message.topic)

    def error_listener(self, message):
        self.error = message


class SubscribingPlugin(Plugin):

    def __init__(self):
        self._reset_recorders()
        self._subscribe_to_events()

    def disable(self):
        self.unsubscribe_all()

    def _reset_recorders(self):
        self.record = {}
        self.count = 0
        self.hierarchy_events = []
        self.multi_events = []
        self.class_handler_topic = self.string_handler_topic =\
            self.case_insensitive_string_handler_topic = None

    def _subscribe_to_events(self):
        self.subscribe(self.OnTestEventClass, RideTestMessage)
        self.subscribe(self.OnTestEventString, 'ride.test')
        self.subscribe(self.OnTestEventStringWrongCase, 'RIDE.tesT')
        self.subscribe(self.OnTestEventWithData, RideMessageWithData)
        for _ in range(5):
            self.subscribe(self.counting_handler, RideTestMessage)
        self.subscribe(self.hierarchical_listener, RideMessage)
        self.subscribe(self.multiple_events_listening_handler, RideTestMessage,
                       RideMessageWithData)

    def OnTestEventClass(self, event):
        self.class_handler_topic = event.topic

    def OnTestEventString(self, event):
        self.string_handler_topic = event.topic

    def OnTestEventStringWrongCase(self, event):
        self.case_insensitive_string_handler_topic = event.topic

    def OnTestEventWithData(self, event):
        self.record['data_item'] = event.data_item
        self.record['more_data'] = event.more_data

    def counting_handler(self, event):
        self.count += 1

    def hierarchical_listener(self, event):
        self.hierarchy_events.append(event.topic)

    def multiple_events_listening_handler(self, event):
        self.multi_events.append(event.topic)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_plugin_api
import unittest
from robot.utils.asserts import assert_equals

from robotide.pluginapi import Plugin
from robotide.namespace import Namespace
from robotide.spec.iteminfo import ItemInfo
from robotide.robotapi import TestCaseFile
from robotide.controller.filecontrollers import DataController

from resources import FakeApplication
from robotide.spec.librarymanager import LibraryManager


class ContentAssistPlugin(Plugin):

    def _get_content_assist_values(self, item, value):
        assert_equals(item.name, None)
        assert_equals(value, 'given')
        return [ItemInfo('foo', 'test', 'quux')]


class TestContentAssistHook(unittest.TestCase):

    def test_hook_suggestions_are_included(self):
        self.app = FakeApplication()
        self.app.namespace = Namespace(self.app.settings)
        library_manager = LibraryManager(':memory:')
        library_manager.create_database()
        library_manager.start()
        self.app.namespace.set_library_manager(library_manager)
        pl = ContentAssistPlugin(self.app, name='test')
        pl.register_content_assist_hook(pl._get_content_assist_values)
        self._assert_contains('foo')
        library_manager.stop()

    def _assert_contains(self, name):
        controller = DataController(TestCaseFile(), None)
        for val in self.app.namespace.get_suggestions_for(controller, 'given'):
            if val.name == name:
                return
        raise AssertionError()

########NEW FILE########
__FILENAME__ = test_plugin_settings
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import tempfile
import unittest
import os

from robotide.preferences.settings import Settings
from robotide.pluginapi import Plugin

from resources import TestSettingsHelper, FakeApplication


class TestPluginSettings(TestSettingsHelper):
    _settings_path = os.path.join(tempfile.gettempdir(), 'set.cfg')

    def tearDown(self):
        if os.path.exists(self._settings_path):
            os.remove(self._settings_path)

    def test_setting_default_settings_when_no_settings_exist(self):
        self.assertEquals(self._create_plugin().foo, 'bar')

    def test_set_default_settings_when_settings_exist(self):
        app = self._create_app()
        app.settings['Plugins'].add_section('MyPlug', foo='zip')
        self.assertEquals(Plugin(app, name='MyPlug').foo, 'zip')

    def test_save_setting_with_override(self):
        p = self._create_plugin()
        p.save_setting('foo', 'new')
        self.assertEquals(p.foo, 'new')

    def test_save_setting_without_override(self):
        p = self._create_plugin()
        p.save_setting('foo', 'new', override=False)
        self.assertEquals(p.foo, 'bar')

    def test_direct_attribute_access_with_existing_setting(self):
        self.assertEquals(self._create_plugin().foo, 'bar')

    def test_direct_attribute_access_with_non_existing_setting(self):
        try:
            self._create_plugin().non_existing
        except AttributeError:
            return
        raise AssertionError("Accessing non existent attribute should raise AttributeError")

    def _create_plugin(self, settings={'foo': 'bar'}):
        return Plugin(self._create_app(), name='MyPlug', default_settings=settings)

    def _create_app(self):
        app = FakeApplication()
        settings = Settings(self._settings_path)
        settings.add_section('Plugins')
        app.settings = settings
        return app


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pythonpath_imports
import unittest
from robotide.preferences.imports import Setting

class TestImportSetting(unittest.TestCase):

    def setUp(self):
        settings = {'name':['foo']}
        self.import_setting = Setting(settings, 'name', 'help')
        self.assertEqual(['foo'], self.import_setting.current_value)

    def test_that_empty_data_is_cleaned(self):
        self._test_data_set('', [])

    def _test_data_set(self, value, expected):
        self.import_setting.set(value)
        self.assertEqual(expected, self.import_setting.current_value)

    def test_that_only_non_empty_data_is_set(self):
        self._test_data_set(',,bar, ,', ['bar'])

    def test_values_are_stripped(self):
        self._test_data_set('z  ,   b ,  a b', ['z', 'b', 'a b'])

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_settings
import unittest
from robotide.preferences.settings import SettingsMigrator
from robotide.utils import overrides


class SettingsMigrationTestCase(SettingsMigrator, unittest.TestCase):

    def __init__(self, methodName='runTest'):
        unittest.TestCase.__init__(self, methodName=methodName)

    def setUp(self):
        self._old_settings = {}
        self._default_settings = lambda:0
        self._from_0_to_1_called = False
        self._from_1_to_2_called = False
        self._merge_called = False

    def test_migration_from_0_to_2(self):
        self._old_settings[SettingsMigrator.SETTINGS_VERSION] = 0
        self.migrate()
        self.assertTrue(self._from_0_to_1_called)
        self.assertTrue(self._from_1_to_2_called)
        self.assertTrue(self._merge_called)

    def test_migration_from_1_to_2(self):
        self._old_settings[SettingsMigrator.SETTINGS_VERSION] = 1
        self.migrate()
        self.assertFalse(self._from_0_to_1_called)
        self.assertTrue(self._from_1_to_2_called)
        self.assertTrue(self._merge_called)

    @overrides(SettingsMigrator)
    def migrate_from_0_to_1(self, settings):
        self.assertEqual(self._old_settings, settings)
        self._from_0_to_1_called = True
        settings[SettingsMigrator.SETTINGS_VERSION] = 1

    @overrides(SettingsMigrator)
    def migrate_from_1_to_2(self, settings):
        self.assertEqual(self._old_settings, settings)
        self._from_1_to_2_called = True
        settings[SettingsMigrator.SETTINGS_VERSION] = 2

    def merge(self):
        self._merge_called = True

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_message_publishing
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest

from robot.utils.asserts import assert_equals, assert_raises_with_msg,\
    assert_true

from robotide.publish import RideMessage, RideLogMessage, RideLogException, Publisher


_ARGS_ERROR = "Argument mismatch, expected: ['foo', 'bar']"


class RideTestMessage(RideMessage):
    topic = 'My.Topic'

class RideTestMessageWithAttrs(RideTestMessage):
    data = ['foo', 'bar']

class RideTestMessageWithLongName(RideTestMessage):
    pass


class TestMessage(unittest.TestCase):

    def test_topic(self):
        assert_equals(RideMessage().topic, 'ride')
        assert_equals(RideTestMessage().topic, 'my.topic')
        assert_equals(RideTestMessageWithLongName().topic,
                      'ride.test.message.with.long.name')

    def test_all_attributes_given(self):
        msg = RideTestMessageWithAttrs(foo='bar', bar='quux')
        assert_equals(msg.foo, 'bar')
        assert_equals(msg.bar, 'quux')

    def test_missing_mandatory_attribute(self):
        assert_raises_with_msg(TypeError, _ARGS_ERROR,
                               RideTestMessageWithAttrs, foo='bar')

    def test_missing_many_mandatory_attributes(self):
        assert_raises_with_msg(TypeError, _ARGS_ERROR, RideTestMessageWithAttrs)

    def test_no_such_attribute_should_fail(self):
        assert_raises_with_msg(TypeError, _ARGS_ERROR, RideTestMessageWithAttrs,
                               foo='', bar='', quux='camel')


class TestRideLogMessage(unittest.TestCase):

    def test_log_message(self):
        msg = RideLogMessage(message='Some error text', level='ERROR')
        assert_equals(msg.message, 'Some error text')
        assert_equals(msg.level, 'ERROR')
        assert_true(msg.timestamp.startswith('20'))

    def test_log_exception(self):
        try:
            1/0
        except Exception, err:
            msg = RideLogException(message='Some error text', exception=err, level='ERROR')
            assert_true(msg.message.startswith('Some error text\n\nTraceback (most recent call last):'))
            assert_equals(msg.level, 'ERROR')
            assert_true(msg.timestamp.startswith('20'))


class TestPublisher(unittest.TestCase):

    def setUp(self):
        self._msg = ''

    def test_publishing_string_message(self):
        pub = Publisher()
        pub.subscribe(self._listener, 'test.message')
        pub.publish('test.message', 'content')
        assert_equals(self._msg, 'content')

    def test_broken_string_message_listener(self):
        pub = Publisher()
        pub.subscribe(self._broken_listener, 'test.message')
        pub.publish('test.message', 'content')
        assert_equals(self._msg, 'content')

    def _listener(self, data):
        self._msg = data

    def _broken_listener(self, data):
        self._msg = data
        raise RuntimeError(data)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = mocks
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from robotide.preferences.settings import Settings, Excludes
from robotide.publish import PUBLISHER


class MessageRecordingLoadObserver(object):
    def __init__(self):
        self._log = ''
        self.finished = False
        self.notified = False

    def notify(self):
        if self.finished:
            raise RuntimeError('Notified after finished')
        self.notified = True

    def finish(self):
        self.finished = True

    def error(self, msg):
        if self.finished:
            raise RuntimeError('Errored after finished')
        self.finish()
        self._log = msg

    @property
    def message(self):
        return self._log


class _FakeModel(object):
    suite = None

class _FakeActions(object):
    def register_action(self, *args):
        return self

    def unregister(self, *args):
        pass

class _FakeUIObject(object):
    Enable = InsertSeparator = Append = Connect = lambda *args: None
    Insert = FindMenu = GetMenuBar = GetMenu = lambda *args: _FakeUIObject()
    GetMenuItemCount = lambda s: 1
    notebook = property(lambda *args: _FakeUIObject())
    actions = property(lambda *args: _FakeActions())


class FakeSettings(Settings):
    def __init__(self, temp_dir_for_excludes=None):
        Settings.__init__(self, None)
        self.add_section('Plugins')
        self.set('pythonpath', [])
        self.set('auto imports', [])
        if temp_dir_for_excludes:
            self.excludes = Excludes(temp_dir_for_excludes)


class FakeApplication(object):
    frame = _FakeUIObject()
    model = _FakeModel()
    namespace = None
    get_model = lambda s: _FakeModel()
    subscribe = lambda s, x, y: None
    get_menu_bar = lambda s: _FakeUIObject()
    get_notebook = lambda s: _FakeUIObject()
    get_frame = lambda s: _FakeUIObject()
    create_menu_item = lambda *args: None
    settings = FakeSettings()


class _FakeSetting(object):
    add_section = lambda self, name: _FakeSetting()
    get = lambda self, name, default: True
    set = lambda self, name, value: None

class PublisherListener(object):

    def __init__(self, topic):
        PUBLISHER.subscribe(self._listener, topic, self)
        self._topic = topic
        self.data = []
        self.outer_listener = lambda message:0

    def _listener(self, data):
        self.data.append(data)
        self.outer_listener(data)

    @property
    def count(self):
        return len(self.data)

    def unsubscribe(self):
        PUBLISHER.unsubscribe(self._listener, self._topic, self)



########NEW FILE########
__FILENAME__ = libi
class libi(object):

    def __init__(self, *args):
        pass

    def onething(self):
        pass


########NEW FILE########
__FILENAME__ = datagenerator
#!/usr/bin/env python

from getopt import getopt, GetoptError
from random import randint
import os

SUITE=\
"""*** Settings ***
Resource    resource.txt

*** Test Cases ***
%TESTCASES%

*** Keywords ***
Test Keyword
    Log jee
"""

RESOURCE=\
"""*** Variables ***
@{Resource Var}  MOI

*** Keywords ***
%KEYWORDS%
"""

KEYWORD_TEMPLATE=\
"""My Keyword %KW_ID%
    No Operation"""

TEST_CASE_TEMPLATE=\
"""My Test %TEST_ID%
    My Keyword %KW_ID%
    Log  moi
    Test Keyword
    Log  moi
    Test Keyword
    Log  moi
    Test Keyword
    Log  moi
    Test Keyword
    Log  moi
    Test Keyword
    My Keyword %KW_ID%
    Test Keyword
    Log  moi
    Test Keyword
    Log  moi
    Test Keyword
    Log  moi"""


def generate_tests(number_of_tests, number_of_keywords):
    return '\n'.join(TEST_CASE_TEMPLATE.replace('%TEST_ID%', str(test_id))\
                      .replace('%KW_ID%', str(randint(0,number_of_keywords-1)))\
                      for test_id in xrange(number_of_tests))

def generate_keywords(number_of_keywords):
    return '\n'.join(KEYWORD_TEMPLATE.replace('%KW_ID%', str(i)) for i in xrange(number_of_keywords))

def generate_suite(number_of_tests, number_of_keywords):
    return SUITE.replace('%TESTCASES%', generate_tests(number_of_tests, number_of_keywords))\
                .replace('%KEYWORDS%', generate_keywords(number_of_keywords))

def generate_resource(number_of_keywords):
    return RESOURCE.replace('%KEYWORDS%', generate_keywords(number_of_keywords))

def generate(directory, suites, tests, keywords):
    os.mkdir(directory)
    for suite_index in xrange(suites):
        f = open(os.path.join('.', directory, 'suite%s.txt' % suite_index), 'w')
        f.write(generate_suite(tests, keywords))
        f.close()
    r = open(os.path.join('.', directory, 'resource.txt'), 'w')
    r.write(generate_resource(keywords))
    r.close()

def usage():
    print 'datagenerator.py -d [directory] -s [NUMBER OF SUITES] -t [NUMBER OF TESTS IN SUITE] -k [NUMBER OF KEYWORDS]'

def main(args):
    try:
        opts, args = getopt(args, 'd:s:t:k:', [])
    except GetoptError, e:
        print e
        usage()
        sys.exit(2)
    if len(opts) != 4:
        if opts:
            print opts
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-d':
            directory = arg
        if opt == '-s':
            suites = int(arg)
        if opt == '-t':
            tests = int(arg)
        if opt == '-k':
            keywords = int(arg)
    generate(directory, suites, tests, keywords)

if __name__ == '__main__':
    import sys
    main(sys.argv[1:])


########NEW FILE########
__FILENAME__ = vars
ServerHost = "localhost"
ServerPort = "1337"
########NEW FILE########
__FILENAME__ = corrupted
sdklsdjakjsa
d#skladjslk,..dsalkdjs weoiqwejdskla
CORRUpteD

########NEW FILE########
__FILENAME__ = existing
def keyword():
    print 'this is a keyword'

########NEW FILE########
__FILENAME__ = exiting
import sys
sys.exit()

########NEW FILE########
__FILENAME__ = outer_lib
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

def this_is_the_outer_lib():
    print 'For imports test'

########NEW FILE########
__FILENAME__ = exiting
import sys
sys.exit()

########NEW FILE########
__FILENAME__ = vars
VARIABLE = 'VALUE'


########NEW FILE########
__FILENAME__ = spacelib
def space_lib_function():
    pass

########NEW FILE########
__FILENAME__ = AnotherArgLib
class AnotherArgLib(object):

    def __init__(self, *args):
        self._check_args(args)
        self._args = args

    def _check_args(self, args):
        for arg in args:
            if arg and '${' in arg:
                raise ValueError('Test library needs variables resolved')

    def longest(self):
        return max(self._args, key=len)

########NEW FILE########
__FILENAME__ = ArgLib
class ArgLib(object):

    def __init__(self, mandatory_arg, default_arg=None):
        self._check_args((mandatory_arg, default_arg))
        self._mandatory = mandatory_arg
        self._default =default_arg

    def _check_args(self, args):
        for arg in args:
            if arg and '${' in arg:
                raise ValueError('Test library needs variables resolved')

    def get_mandatory(self):
        return self._mandatory

    def get_default(self):
        if not self._default:
            raise AssertionError("Default not properly set!")
        return self._default

########NEW FILE########
__FILENAME__ = libsi
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

def libsi_keyword():
    print 'libsi keyword'

########NEW FILE########
__FILENAME__ = TestLib
#  Copyright 2008 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


def testlib_keyword():
    """
    """
    return True


def testlib_keyword_with_args(arg1, arg2='default value', *args):
    """This keyword requires one argument, has one optional argument and varargs.

    This is some more documentation 
    """
    pass

########NEW FILE########
__FILENAME__ = local
def local():
    print 'Hello'
########NEW FILE########
__FILENAME__ = dynamic_varz
def get_variables(arg=None):
    return arg and {'dynamic var': arg, arg:'value', 'Technology Lib': 'Telnet'} or {}

########NEW FILE########
__FILENAME__ = even_more_varz
var_in_resource2 = "Foo"

########NEW FILE########
__FILENAME__ = more_varz
varfrommorevarz = {'key': 'value'}

########NEW FILE########
__FILENAME__ = res_var_file
var_from_resource_var_file = 'Some Value'

########NEW FILE########
__FILENAME__ = varz
var_from_file = 'Some value'

########NEW FILE########
__FILENAME__ = myvars
from_my_var = 'res'
########NEW FILE########
__FILENAME__ = setting_utils
import os
import stat
import unittest

from robotide.preferences.settings import Settings


class TestSettingsHelper(unittest.TestCase):

    def setUp(self, settings=None):
        self._init_settings_paths()
        if not settings:
            settings = Settings
        self.settings = settings(self.user_settings_path)

    def _init_settings_paths(self):
        self.settings_path = os.path.join(os.path.dirname(__file__),
                                          'settings.cfg')
        self.user_settings_path = os.path.join(os.path.dirname(__file__),
                                          'user.cfg')
        self.read_only_path = os.path.join(os.path.dirname(__file__), 'read-only.cfg')
        os.chmod(self.read_only_path, stat.S_IRUSR)


    def tearDown(self):
        for path in [self.settings_path, self.user_settings_path]:
            self._remove_path(path)

    def _remove_path(self, path):
        if os.path.exists(path):
                os.remove(path)

    def _check_content(self, expected_dict, check_self_settings=True):
        settings = Settings(self.user_settings_path)
        self.assertEquals(settings._config_obj, expected_dict)
        if check_self_settings:
            self.assertEquals(self.settings._config_obj, expected_dict)

    def _write_settings(self, content, path=None):
        f = open(self._get_path(path), 'w')
        f.write(content)
        f.close()

    def _read_settings_file_content(self, path=None):
        f = open(self._get_path(path), 'r')
        value = f.read()
        f.close()
        return value

    def _get_path(self, path):
        if path:
            return path
        return self.user_settings_path

    def _create_invalid_settings_file(self, path=None):
        self._write_settings('invalid = invalid', path)

    def _read_settings(self, path=None):
        try:
            return Settings(self._get_path(path))
        except:
            print self._read_settings_file_content()
            raise

########NEW FILE########
__FILENAME__ = process_test_scripts
import sys
import time


def output(sleep=0.1):
    print 'start'
    for i in range(2):
        print 'running iteration %d' % i * 500
        time.sleep(float(sleep))
    print 'done'


def count_args(*args):
    print len(args)

def stderr():
    sys.stderr.write('This is stderr\n')

globals()[sys.argv[1]](*sys.argv[2:])


########NEW FILE########
__FILENAME__ = test_process
import unittest
import os
import sys

from robotide.run.process import Process
from robot.utils.asserts import assert_equals, assert_raises_with_msg


SCRIPT = os.path.join(os.path.dirname(__file__), 
                      'process_test_scripts.py').replace(' ', '<SPACE>')


class TestProcess(unittest.TestCase):

    def test_command_as_string(self):
        initial_command = 'python hupu count_args a1 a2<SPACE>2<SPACE>1 a3<SPACE>'
        processed_command = Process(initial_command)._command
        assert_equals(len(processed_command), len(initial_command.split()))
        assert_equals(processed_command[4], 'a2 2 1')

    if sys.version_info[:2] < (2,6):
        def test_stopping(self):
                msg = 'Stopping process is possible only with Python 2.6 or newer'
                assert_raises_with_msg(AttributeError, msg,
                                       self._create_process(['']).stop)

    def test_writing_to_stderr(self):
        self.proc = self._create_process('python %s stderr' % SCRIPT)
        assert_equals(self.proc.get_output(wait_until_finished=True),
                      'This is stderr\n')

    def _create_process(self, command):
        proc = Process(command)
        proc.start()
        return proc
########NEW FILE########
__FILENAME__ = test_run_anything
import unittest
import time
import os
import sys
from robot.utils.asserts import assert_equals, assert_true

from robotide.run.runanything import RunConfig
from robotide.run.ui import Runner
from resources import PYAPP_REFERENCE as _


SCRIPT = os.path.join(os.path.dirname(__file__),
                      'process_test_scripts.py').replace(' ', '<SPACE>')


class _TestableRunner(Runner):
    output = property(lambda self: self._window.output)
    outstr = property(lambda self: self._window.outstr)
    finished = property(lambda self: self._window.finished)
    def _get_output_window(self, notebook):
        return _FakeOutputWindow()

class _FakeOutputWindow(object):
    outstr = property(lambda self: ''.join(self.output))
    def __init__(self):
        self.output = []
    def update_output(self, output, finished):
        self.output.append(output)
        self.finished = finished


class TestRunAnything(unittest.TestCase):

    def test_run(self):
        self.runner = self._create_runner('python %s count_args a b c' % SCRIPT)
        self._wait_until_finished()
        assert_true(self.runner.finished)
        assert_equals(self.runner.outstr, '3\n')

    if sys.version_info[:2] >= (2,6):
        def test_stopping(self):
            self.runner = self._create_runner('python %s output 0.8' % SCRIPT)
            time.sleep(0.3)
            self.runner.stop()
            self._sleep_and_log_output(0.1)
            assert_true(self.runner.finished)
            assert_true(self.runner.outstr.startswith('start\nrunning '))

    def test_error(self):
        self.runner = self._create_runner('invalid command')
        self._wait_until_finished()
        assert_true(self.runner.finished)
        assert_true(self.runner.outstr)

    def test_stderr(self):
        self.runner = self._create_runner('python %s stderr' % SCRIPT)
        self._wait_until_finished()
        assert_true(self.runner.finished)
        assert_equals(self.runner.outstr, 'This is stderr\n')

    def _create_runner(self, cmd):
        runner = _TestableRunner(RunConfig('test', cmd, ''), None)
        runner.run()
        return runner

    def _wait_until_finished(self):
        self.runner._process.wait()
        self.runner.OnTimer()

    def _sleep_and_log_output(self, amount):
        time.sleep(amount)
        self.runner.OnTimer()

########NEW FILE########
__FILENAME__ = test_run_configs
import unittest
from robot.utils.asserts import assert_equals

from robotide.run.runanything import RunConfigs


ITEM = ('name', 'command', 'doc')


class RunConfigurationsTest(unittest.TestCase):

    def test_creation_with_no_data(self):
        configs = RunConfigs([])
        assert_equals(len(configs), 0)

    def test_creation_with_data(self):
        self._assert_config(self._create_configs_with_item()[0], *ITEM)

    def test_adding(self):
        item = ('newname', 'some command', '')
        self._assert_config(RunConfigs([]).add(*item), *item)

    def test_edit(self):
        configs = self._create_configs_with_item()
        configs.edit(0, 'edited_name', 'cmd', 'doc')
        self._assert_config(configs[0], 'edited_name', 'cmd', 'doc')

    def test_update(self):
        items = [ITEM, ('another', 'ls -l', '')]
        edited = [('Changed Name', 'command', 'doc'),
                  ('', '', '')]
        configs = RunConfigs(items)
        configs.update(edited)
        self._assert_config(configs[0], 'Changed Name', 'command', 'doc')
        self._assert_config(configs[1], '', '' ,'')

    def test_data_to_save(self):
        configs = self._create_configs_with_item()
        assert_equals(configs.data_to_save(), [ITEM])

    def _create_configs_with_item(self):
        return RunConfigs([ITEM])

    def _assert_config(self, config, exp_name, exp_cmd, exp_doc):
        assert_equals(config.name, exp_name)
        assert_equals(config.command, exp_cmd)
        assert_equals(config.doc, exp_doc)


########NEW FILE########
__FILENAME__ = test_matcher
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import unittest
from robot.parsing.model import TestCase, Tags
from robotide.controller.macrocontrollers import TestCaseController
from robotide.searchtests.searchtests import TestSearchMatcher

class _TestSearchTest(object):

    def _test(self, name='name', tags=None, doc='documentation'):
        parent = lambda:0
        parent.datafile_controller = parent
        parent.register_for_namespace_updates = lambda *_:0
        parent.force_tags = []
        parent.default_tags = []
        robot_test = TestCase(parent=parent, name=name)
        robot_test.get_setter('documentation')(doc)
        robot_test.get_setter('tags')(tags or [])
        test = TestCaseController(parent, robot_test)
        return test

    def _match(self, text, name='name', tags=None, doc='documentation'):
        return TestSearchMatcher(text).matches(self._test(name, tags, doc))


class TestTestSearchMatcher(_TestSearchTest, unittest.TestCase):

    def test_matching_name(self):
        self.assertTrue(self._match('name', name='name'))

    def test_not_matching(self):
        self.assertFalse(self._match('tERm', name='no match', tags=['no match'], doc='no match'))

    def test_matching_name_partially(self):
        self.assertTrue(self._match('match', doc='prefix[match]postfix'))

    def test_matching_name_is_case_insensitive_in_tags(self):
        self.assertTrue(self._match('mAtCh', tags=['MATcH']))

    def test_matching_name_is_case_insensitive_in_name(self):
        self.assertTrue(self._match('mAtCh', name=' MATcH'))

    def test_matching_name_is_case_insensitive_in_doc(self):
        self.assertTrue(self._match('mAtCh', doc='Doc MATcHoc'))

    def test_matching_to_documentation(self):
        self.assertTrue(self._match('docstring', doc='docstring matching!'))

    def test_matching_to_tag(self):
        self.assertTrue(self._match('tag', tags=['tag']))

    def test_multiple_match_terms(self):
        self.assertTrue(self._match('name tag doc', name='name!', tags=['foo', 'tag', 'bar'], doc='well doc to you!'))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_testsorter
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import unittest
from searchtests.test_matcher import _TestSearchTest


class TestTestSorter(_TestSearchTest, unittest.TestCase):

    def test_exact_match_is_better_than_partial(self):
        self._matches_in_order('exact', ['aexact', 'exact', 'exact jotain', 'exact_foo', 'jotain exact', 'zexact'])

    def _matches_in_order(self, match_text, matches):
        match_objects = [self._match(match_text, name=name) for name in matches]
        for i in range(1, len(match_objects)):
            self._assert_is_greater(match_objects[i], match_objects[i-1])

    def test_all_matches_is_better_than_some(self):
        self._matches_in_order('zoo foo bar', ['zoo foo bar', 'zoo foo', 'bar'])

    def test_more_matches_is_better_than_some_in_name(self):
        all_matches_in_docs = self._match('foo bar', doc='foo bar')
        some_match_in_name = self._match('foo bar', name='foo')
        self._assert_is_greater(some_match_in_name, all_matches_in_docs)

    def test_more_matches_is_better_than_some_in_tags(self):
        some_match_in_tag = self._match('foo bar', tags=['bar'])
        all_matches_in_tags = self._match('foo bar', tags=['foo', 'bar'])
        self._assert_is_greater(some_match_in_tag, all_matches_in_tags)

    def test_same_pattern_matches_do_not_raise_priority(self):
        all_matches_in_name = self._match('foo bar', name='foo bar')
        some_match_in_doc = self._match('foo bar', doc='bar bar bar bar bar bar')
        self._assert_is_greater(some_match_in_doc, all_matches_in_name)

    def test_name_is_better_than_doc(self):
        name_match = self._match('name', name='name')
        doc_match = self._match('doc', doc='doc')
        self._assert_is_greater(doc_match, name_match)

    def test_name_is_better_than_tag(self):
        name_match = self._match('name', name='name')
        tag_match = self._match('tag', tags=['tag'])
        self._assert_is_greater(tag_match, name_match)

    def test_tag_is_better_than_doc(self):
        tag_match = self._match('tag', tags=['tag'])
        doc_match = self._match('doc', doc='doc')
        self._assert_is_greater(doc_match, tag_match)

    def test_tags_order(self):
        tag1_match = self._match('tag', tags=['atag'])
        tag2_match = self._match('tag', tags=['btag'])
        self._assert_is_greater(tag2_match, tag1_match)

    def _assert_is_greater(self, greater, smaller):
        self.assertTrue(greater > smaller, msg='%r !>! %r' % (greater, smaller))
        self.assertFalse(smaller > greater)
        self.assertFalse(greater == smaller)


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_excludes
import os
from os.path import sep
import tempfile
import unittest
from robotide.preferences.excludes import Excludes

class TestExcludes(unittest.TestCase):

    def setUp(self):
        self.exclude = Excludes(directory=tempfile.gettempdir())
        self.file_path = self.exclude._exclude_file_path

    def tearDown(self):
        if hasattr(self, 'file_path') and os.path.exists(self.file_path):
            os.remove(self.file_path)

    def test_update_excludes(self):
        self.exclude.update_excludes(['foo'])
        self.assertTrue(self.exclude.contains(_join('foo', 'bar')))

    def test_update_excludes_with_separator(self):
        self.exclude.update_excludes(['foo' + sep])
        self.assertTrue(self.exclude.contains(_join('foo')))
        self.assertTrue(self.exclude.contains('foo'))

    def test_updating_excludes_does_not_repeat_path(self):
        self.exclude.update_excludes(['foo'])
        self.exclude.update_excludes(['foo' + sep])
        self.assertTrue(self.exclude.contains(_join('foo', 'bar')))
        self.assertEqual(len(self.exclude._get_excludes()), 1)

    def test_updating_excludes_does_not_repeat_almost_similar_paths(self):
        data = os.path.join('foo', 'bar')
        self.exclude.update_excludes([data])
        self.exclude.update_excludes([data + os.path.sep])
        self.assertTrue(self.exclude.contains(_join('foo', 'bar')))

    def test_contains_when_there_is_no_path(self):
        self.assertFalse(self.exclude.contains(None))

    def test_remove_path(self):
        excludes = [_join('foo'), _join('bar', 'baz'), _join('qux'), _join('quux', 'corge')]
        removed = [_join('bar', 'baz'), _join('quux', 'corge')]
        self.exclude.update_excludes(excludes)
        self.assertTrue(all([self.exclude.contains(e) for e in excludes]))
        self.exclude.remove_path(removed[0])
        self.assertFalse(self.exclude.contains(removed[0]))
        self.exclude.remove_path(removed[1])
        self.assertFalse(self.exclude.contains(removed[1]))

    def test_when_exclude_file_points_to_directory(self):
        dir = tempfile.mkdtemp()
        os.mkdir(os.path.join(dir, 'excludes'))
        self.exclude = Excludes(dir)
        del self.file_path # not created nor used in this test
        self.assertRaises(NameError, self.exclude._get_exclude_file, 'w')

    def test_star_path_pattern(self):
        self.exclude.update_excludes([_join('foo', '*', 'bar'), _join('*', 'splat')])
        self.assertTrue(self.exclude.contains('foo/baz/bar'))
        self.assertTrue(self.exclude.contains('foo/quu/qux/bar'))
        self.assertTrue(self.exclude.contains('/corge/splat/doom.txt'))

    def test_question_mark_path_pattern(self):
        self.exclude.update_excludes([_join('foo', '?ar')])
        self.assertTrue(self.exclude.contains('foo/bar'))
        self.assertTrue(self.exclude.contains('foo/dar'))
        self.assertFalse(self.exclude.contains('foo/ggar'))

    def test_char_sequence_path_pattern(self):
        self.exclude.update_excludes([_join('foo', '[bz]ar')])
        self.assertTrue(self.exclude.contains('foo/bar'))
        self.assertTrue(self.exclude.contains('foo/zar'))
        self.assertFalse(self.exclude.contains('foo/gar'))

    def test_char_sequence_not_in_path_pattern(self):
        self.exclude.update_excludes([_join('foo', '[!bz]ar')])
        self.assertFalse(self.exclude.contains('foo/bar'))
        self.assertFalse(self.exclude.contains('foo/zar'))
        self.assertTrue(self.exclude.contains('foo/gar'))

def _join(*args):
    return os.path.join(*args) + sep

########NEW FILE########
__FILENAME__ = test_merge_settings
#  Copyright 2010 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os.path
import unittest

from resources.setting_utils import TestSettingsHelper
from robotide.preferences.settings import SettingsMigrator


class TestMergeSettings(TestSettingsHelper):

    def setUp(self):
        base = os.path.join(os.path.dirname(__file__), '..', 'resources')
        self.settings_cfg = os.path.join(base, 'settings2.cfg')
        self.user_cfg = os.path.join(base, 'user2.cfg')

    def tearDown(self):
        pass

    def test_merge_settings(self):
        SettingsMigrator(self.settings_cfg, self.user_cfg).merge()
        SettingsMigrator(self.settings_cfg, self.user_cfg).merge()
        content = self._read_settings_file_content(self.user_cfg)
        line_count = len(content.splitlines())
        self.assertEquals(line_count, 33, "line count should be 33 was %s" %
                          line_count)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_ride_settings
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest
import os

from robotide.preferences import RideSettings


class TestRideSettings(unittest.TestCase):

    def test_loading_settings(self):
        settings = RideSettings()
        self.assertTrue(settings._config_obj["mainframe size"])


class TestGettingPath(unittest.TestCase):

    def test_get_path_without_parts(self):
        settings = RideSettings()
        self.assertTrue(settings.get_path().endswith('ride'))

    def test_get_path_with_one_part(self):
        settings = RideSettings()
        self.assertTrue(settings.get_path('foo').endswith('ride%sfoo' % os.sep))

    def test_get_path_with_three_parts(self):
        path = RideSettings().get_path('foo', 'bar', 'hello')
        expected_end = 'ride/foo/bar/hello'.replace('/', os.sep)
        self.assertTrue(path.endswith(expected_end))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_settings
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
from __future__ import with_statement

import unittest
import os
from robotide.preferences import settings

from robotide.preferences.settings import Settings, SectionError,\
    ConfigurationError, initialize_settings, SettingsMigrator, Excludes

from resources.setting_utils import TestSettingsHelper
from os.path import sep

class TestInvalidSettings(TestSettingsHelper):

    def test_no_settings_exists(self):
        self.assertEquals(self.settings._config_obj, {})

    def test_setting_name_with_space(self):
        self.settings['name with space'] = 0
        settings = Settings(self.user_settings_path)
        self.assertEquals(settings['name with space'], 0)

    def test_invalid_settings(self):
        self._write_settings('invalid syntax = foo')
        self.assertRaises(ConfigurationError, Settings, self.user_settings_path)


class TestSettingTypes(TestSettingsHelper):

    def test_writing_string_setting(self):
        self._test_settings_types({'string':'value'})

    def test_writing_unicode_setting(self):
        self._test_settings_types({'unicode_string':u'non-ascii character \xe4'})

    def test_writing_list_setting(self):
        self._test_settings_types({'unicode_string': [1, 'string',
                                                u'non-ascii character \xe4']})

    def test_writing_tuple_setting(self):
        self._test_settings_types({'unicode_string': (1, 'string',
                                                u'non-ascii character \xe4')})

    def test_writing_dictionary_setting(self):
        self._test_settings_types({'dictionary': {'a': 1, 'b': 2, 'c': 3}})

    def test_writing_none_setting(self):
        self._test_settings_types({'none': None})

    def test_writing_boolean_setting(self):
        self._test_settings_types({'boolean': True})

    def test_writing_multiline_string_setting(self):
        multiline = u"""Multi line string
with non-ascii chars \xe4
and quotes "foo" 'bar'
and even triple quotes \"\"\" '''
"""
        self._test_settings_types({'multiline': multiline})

    def test_multiple_settings(self):
        multiline = u"""Multi line string
with non-ascii chars \xe4
and quotes "foo" 'bar'
and even triple quotes \"\"\" '''
"""
        self._test_settings_types({'multiline': multiline, 'string': u'some',
                                'bool': False, 'int':1, 'float':2.4})

    def _test_settings_types(self, expected):
        for key, value in expected.items():
            self.settings[key] = value
        self.assertEqual(expected, self._read_settings()._config_obj)


class TestSettings(TestSettingsHelper):

    def test_changing_settings_with_setitem(self):
        self._create_settings_with_defaults()
        self.settings['foo'] = 'new value'
        self._check_content({'foo':'new value', 'hello':'world'})

    def test_getting_settings_with_getitem(self):
        self._create_settings_with_defaults()
        self.assertEquals('bar', self.settings['foo'])

    def _create_settings_with_defaults(self):
        self._write_settings("foo = 'bar'\nhello = 'world'", self.user_settings_path)
        self.default = {'foo':'bar', 'hello':'world'}
        self.settings = Settings(self.user_settings_path)

    def test_set(self):
        self._create_settings_with_defaults()
        self.settings.set('foo', 'new value')
        self._check_content({'foo':'new value', 'hello':'world'})

    def test_set_with_non_existing_value(self):
        self._create_settings_with_defaults()
        self.settings.set('zip', 2)
        self._check_content({'foo':'bar', 'hello':'world', 'zip':2})

    def test_set_without_autosave(self):
        self._create_settings_with_defaults()
        self.settings.set('foo', 'new value', autosave=False)
        self._check_content(self.default, check_self_settings=False)
        expected = {'foo':'new value', 'hello':'world'}
        self.assertEquals(self.settings._config_obj, expected)
        self.settings.save()
        self._check_content(expected)

    def test_set_without_override_when_settings_does_not_exist(self):
        self.settings.set('foo', 'new value', override=False)
        self._check_content({'foo':'new value'})

    def test_set_without_override_when_settings_exists(self):
        self._create_settings_with_defaults()
        self.settings.set('foo', 'new value', override=False)
        self._check_content(self.default)

    def test_set_values(self):
        self._create_settings_with_defaults()
        self.settings.set_values({'foo':'new value', 'int':1})
        self._check_content({'foo':'new value', 'hello':'world', 'int':1})

    def test_set_values_without_autosave(self):
        self._create_settings_with_defaults()
        self.settings.set_values({'foo':'new value', 'int':1}, autosave=False)
        expected = {'foo':'new value', 'hello':'world', 'int':1}
        self.assertEquals(self.settings._config_obj, expected)
        self._check_content(self.default, check_self_settings=False)
        self.settings.save()
        self._check_content(expected)

    def test_set_values_without_override(self):
        self._create_settings_with_defaults()
        self.settings.set_values({'foo':'not set', 'new item': 'is set'},
                                 override=False)
        self.default['new item'] = 'is set'
        self._check_content(self.default)

    def test_set_values_with_none(self):
        self._create_settings_with_defaults()
        self.settings.set_values(None)
        self._check_content(self.default)

    def test_set_defaults(self):
        self.settings.set_defaults(foo='bar', zip=3)
        self._check_content({'foo':'bar', 'zip':3})

    def test_set_defaults_when_some_values_already_exists(self):
        self._create_settings_with_defaults()
        self.settings.set_defaults(foo='value', zip=3)
        self._check_content({'foo':'bar', 'hello':'world', 'zip':3})


SETTINGS_CONTENT = """
# Main comment
string = 'REPLACE_STRING'
int = 13
float = 1.5
# Main comment 2
boolean = True

[Section 1]
# Section 1 comment

list = [1, 2]
robot = 'REPLACE_ROBOT'
tuple = (1, 2)

# Section 1 comment 2

[Section 2]

list = [2, 1]
# Comment again
tuple = (2, 1)

# Which also may be several lines
"""


class TestSettingsFileContent(TestSettingsHelper):

    def test_settings_file_content_stay(self):
        self._write_settings(SETTINGS_CONTENT)
        settings = Settings(self.user_settings_path)
        settings['string'] = 'new value'
        settings['Section 1']['robot'] = 'New Robot'
        expected = SETTINGS_CONTENT.replace('REPLACE_STRING', 'new value')
        expected = expected.replace('REPLACE_ROBOT', 'New Robot')
        self.assertEquals(self._read_settings_file_content(), expected)


class TestSections(TestSettingsHelper):

    def test_add_section(self):
        self.settings.add_section('Plugin 1')
        self.assertEquals(self.settings['Plugin 1']._config_obj, {})

    def test_add_section_returns_section(self):
        self.assertEquals(self.settings.add_section('Plugin 1')._config_obj, {})

    def test_add_section_with_default_values(self):
        section = self.settings.add_section('Plugin 1', a='b', one='2')
        self.assertEquals(section._config_obj, {'a':'b', 'one':'2'})
        self.assertEquals(self._read_settings()['Plugin 1']._config_obj,
                          {'a':'b', 'one':'2'})

    def test_add_section_should_not_fail_if_section_already_exists(self):
        self.settings.add_section('Plugin 1')
        self.settings.add_section('Plugin 1')
        self.settings['Plugin 1']['foo'] = 'bar'
        self.assertEquals(self.settings.add_section('Plugin 1')._config_obj,
                          {'foo':'bar'})

    def test_add_section_should_fail_if_item_with_same_name_already_exists(self):
        self.settings['Plugin 1'] = 123
        self.assertRaises(SectionError, self.settings.add_section, 'Plugin 1')

    def test_set_should_fail_if_section_with_same_name_already_exists(self):
        self.settings.add_section('Plugin 1')
        self.assertRaises(SectionError, self.settings.set, 'Plugin 1', 123)

    def test_set_overriding_section_with_other_section(self):
        self.settings.add_section('Plugin 1', foo='bar', hello='world')
        section = self.settings.add_section('Plugin 2', zip=2)
        self.settings.set('Plugin 1', section)
        self.assertEquals(self.settings['Plugin 1']._config_obj, {'zip':2})
        self.assertEquals(self._read_settings()['Plugin 1']._config_obj, {'zip':2})

    def test_set_updating_section_with_other_section(self):
        self.settings.add_section('Plugin 1', foo='bar', hello='world')
        section = self.settings.add_section('Plugin 2', foo='new value', zip=2)
        self.settings.set('Plugin 1', section, override=False)
        expected = {'foo':'bar', 'hello':'world', 'zip':2}
        self.assertEquals(self.settings['Plugin 1']._config_obj, expected)
        self.assertEquals(self._read_settings()['Plugin 1']._config_obj, expected)

    def test_add_sub_section(self):
        self.settings.add_section('Plugin 1')
        self.settings['Plugin 1'].add_section('Plugin 1.1')
        self.assertEquals(self.settings['Plugin 1']['Plugin 1.1']._config_obj, {})

    def test_add_settings_to_sub_section(self):
        self.settings.add_section('Plugin 1')
        self.settings['Plugin 1'].add_section('Plugin 1.1')
        self.settings['Plugin 1']['Plugin 1.1']['foo'] = 'bar'
        self.assertEquals(self.settings['Plugin 1']['Plugin 1.1']._config_obj,
                          {'foo':'bar'})

    def test_using_section_separately_and_saving(self):
        self.settings.add_section('Plugin 1')
        plugin_settings = self.settings['Plugin 1']
        plugin_settings['foo'] = 'bar'
        plugin_settings.save()
        self.assertEquals(self._read_settings()['Plugin 1']._config_obj,
                          {'foo':'bar'})

    def test_set_values_to_section(self):
        defaults = {'foo':'bar', 'hello':'world'}
        self.settings.add_section('Plugin 1')
        self.settings['Plugin 1'].set_values(defaults)
        self.assertEquals(self._read_settings()['Plugin 1']._config_obj, defaults)


class TestInitializeSettings(TestSettingsHelper):

    def setUp(self):
        self._orig_dir = settings.SETTINGS_DIRECTORY
        self.settings_dir = os.path.join(os.path.dirname(__file__), 'ride')
        settings.SETTINGS_DIRECTORY = self.settings_dir
        self._init_settings_paths()
        self._write_settings("foo = 'bar'\nhello = 'world'",
                             self.settings_path)
        self.user_settings_path = os.path.join(self.settings_dir, 'user.cfg')

    def tearDown(self):
        settings.SETTINGS_DIRECTORY = self._orig_dir
        self._remove_path(self.user_settings_path)
        os.removedirs(self.settings_dir)

    def test_initialize_settings_creates_directory(self):
        initialize_settings('user settings', self.settings_path, 'user.cfg')
        self.assertTrue(os.path.exists(self.settings_dir))

    def test_initialize_settings_copies_settings(self):
        initialize_settings('user settings', self.settings_path, 'user.cfg')
        self.assertTrue(os.path.exists(self.settings_dir))

    def test_initialize_settings_does_merge_when_settings_exists(self):
        os.mkdir(self.settings_dir)
        self._write_settings("foo = 'bar'\nhello = 'world'",self.settings_path)
        self._write_settings("foo = 'new value'\nhello = 'world'",
                             self.user_settings_path)
        initialize_settings('user settings', self.settings_path, 'user.cfg')
        self._check_content({'foo':'new value', 'hello' : 'world',
                             SettingsMigrator.SETTINGS_VERSION:SettingsMigrator.CURRENT_SETTINGS_VERSION,}, False)

    def test_initialize_settings_raises_exception_when_invalid_user_settings(self):
        os.mkdir(self.settings_dir)
        self._write_settings("foo = 'bar'\nhello = 'world'",
                             self.settings_path)
        self._write_settings("invalid = invalid", self.user_settings_path)
        self.assertRaises(ConfigurationError, initialize_settings, 'user settings',
                          self.settings_path, 'user.cfg')

    def test_initialize_settings_replaces_corrupted_settings_with_defaults(self):
        os.mkdir(self.settings_dir)
        self._write_settings("dlskajldsjjw2018032")
        defaults = self._read_file(self.settings_path)
        settings = self._read_file(initialize_settings('user settings', self.settings_path, 'user.cfg'))
        self.assertEqual(defaults, settings)

    def _read_file(self, path):
        with open(path, 'r') as o:
            return o.read()

class TestMergeSettings(TestSettingsHelper):

    def setUp(self):
        self._init_settings_paths()
        self._write_settings("foo = 'bar'\nhello = 'world'",
                             self.settings_path)

    def test_merge_when_no_user_settings(self):
        SettingsMigrator(self.settings_path, self.user_settings_path).merge()
        self._check_content({'foo':'bar', 'hello' : 'world'}, False)

    def test_merge_when_user_settings_are_changed(self):
        self._write_settings("foo = 'new value'\nhello = 'world'",
                             self.user_settings_path)
        SettingsMigrator(self.settings_path, self.user_settings_path).merge()
        self._check_content({'foo':'new value', 'hello' : 'world'}, False)

    def test_merge_when_new_settings_in_defaults(self):
        self._write_settings("foo = 'bar'\nhello = 'world'\nnew = 'value'",
                             self.settings_path)
        self._write_settings("foo = 'new value'\nhello = 'world'",
                             self.user_settings_path)
        SettingsMigrator(self.settings_path, self.user_settings_path).merge()
        self._check_content({'foo':'new value', 'hello' : 'world', 'new':'value'},
                            False)

    def test_merge_fails_reasonably_when_settings_file_is_read_only(self):
        try:
            SettingsMigrator(self.settings_path, self.read_only_path).merge()
        except RuntimeError, e:
            self.assertTrue(str(e).startswith('Could not open'))
        else:
            raise AssertionError('merging read-only file succeeded')


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = Exceptional
#  Copyright 2008-2012 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

class Exceptional(object):

    def get_keyword_names(self):
        raise Exception('Exceptions')

########NEW FILE########
__FILENAME__ = test_iteminfo
import sys
import os
import unittest
from robot.running import TestLibrary
from robot.parsing.model import UserKeyword, KeywordTable
from robot.utils.asserts import assert_true, assert_equals
from robotide.namespace import variablefetcher
from robotide.spec import libraryfetcher

from robotide.spec.iteminfo import LibraryKeywordInfo, TestCaseUserKeywordInfo, VariableInfo, ResourceUserKeywordInfo


testlibpath = os.path.join(os.path.dirname(__file__), '..', 'resources', 'robotdata', 'libs')
sys.path.append(testlibpath)


class _FakeTestCaseFile(object):
    source = '/path/to/testcase.txt'

class _FakeResourceFile(object):
    source = '/path/to/my/resource.html'
    name = 'resource'

def assert_in_details(kw_info, *expecteds):
    details = kw_info.details
    for e in expecteds:
        assert_true(e in details, details)


class TestKeywordInfo(unittest.TestCase):

    def test_libkw_arguments_parsing(self):
        libname = 'TestLib'
        lib = TestLibrary(libname)
        kw = lib.handlers['testlib_keyword_with_args']
        kw_info = LibraryKeywordInfo(kw.name, kw.doc, kw.library.name, libraryfetcher._parse_args(kw.arguments))
        assert_in_details(kw_info, 'Testlib',
                          '[ arg1 | arg2=default value | *args ]')

    def test_uk_arguments_parsing(self):
        uk = UserKeyword(_FakeTestCaseFile(), 'My User keyword')
        uk.args.value = ['${arg1}', '${arg2}=def', '@{varargs}']
        kw_info = TestCaseUserKeywordInfo(uk)
        exp_source = 'testcase.txt'
        exp_args = '[ arg1 | arg2=def | *varargs ]'
        assert_in_details(kw_info, exp_source, exp_args)

    def test_resource_uk_longname(self):
        uk = UserKeyword(KeywordTable(_FakeResourceFile()), 'UK')
        kw_info = ResourceUserKeywordInfo(uk)
        self.assertEquals(kw_info.longname, 'resource.UK')


class TestVariableInfo(unittest.TestCase):

    def test_variable_item_info(self):
        name = '${foo}'
        source = 'source'
        value = True
        info = VariableInfo(name, value, source)
        assert_equals(info.name, name)
        assert_in_details(info, source, 'True')

    def test_variable_item_info_when_value_none(self):
        name = '${foo}'
        source = 'source'
        value = None
        info = VariableInfo(name, value, source)
        assert_equals(info.name, name)
        assert_in_details(info, source, '')

    def test_list_variable_item_info(self):
        name = '@{foo}'
        source = 'source'
        value = variablefetcher._format_value([1,2,3])
        info = VariableInfo(name, value, source)
        assert_equals(info.name, name)
        assert_in_details(info, source, '[ 1 | 2 | 3 ]')

    def test_list_variable_item_info_when_value_none(self):
        name = '@{foo}'
        source = 'source'
        value = None
        info = VariableInfo(name, value, source)
        assert_equals(info.name, name)
        assert_in_details(info, source, '')

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_keywordspec
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest
import sys
import os

from robot.utils.asserts import assert_equals, assert_true

from resources import DATAPATH
from robotide.spec.xmlreaders import SpecInitializer, LIBRARY_XML_DIRECTORY
from robotide.utils import overrides

sys.path.append(os.path.join(DATAPATH, 'libs'))


class TestLibrarySpec(unittest.TestCase):

    def _spec(self, name):
        return SpecInitializer().init_from_spec(name)

    def test_reading_library_from_xml(self):
        kws = self._spec('LibSpecLibrary')
        assert_equals(len(kws), 3)
        exp_doc = 'This is kw documentation.\n\nThis is more docs.'
        self._assert_keyword(kws[0], 'Normal Keyword', exp_doc,
                             exp_doc.splitlines()[0], '[ foo ]')
        self._assert_keyword(kws[1], 'Attributeless Keyword')
        self._assert_keyword(kws[2], 'Multiarg Keyword',
                             args='[ arg1 | arg2=default value | *args ]')

    def test_reading_library_from_old_style_xml(self):
        kws = self._spec('OldStyleLibSpecLibrary')
        assert_equals(len(kws), 3)
        exp_doc = 'This is kw documentation.\n\nThis is more docs.'
        self._assert_keyword(kws[0], 'Normal Keyword', exp_doc,
                             exp_doc.splitlines()[0], '[ foo ]')
        self._assert_keyword(kws[1], 'Attributeless Keyword')
        self._assert_keyword(kws[2], 'Multiarg Keyword',
                             args='[ arg1 | arg2=default value | *args ]')

    def _assert_keyword(self, kw, name, doc='', shortdoc='', args='[  ]'):
        assert_equals(kw.name, name)
        assert_equals(kw.doc, doc, repr(kw.doc))
        assert_equals(kw.shortdoc, shortdoc)
        if args:
            assert_equals(kw.args, args)


class MockedSpecInitializer(SpecInitializer):

    def __init__(self, directories=None, pythonpath_return_value='pythonpath', directory_mapping=None):
        self._pythonpath_return_value = pythonpath_return_value
        if directory_mapping is None:
            directory_mapping = {LIBRARY_XML_DIRECTORY:'directory'}
        self._directory_mapping = directory_mapping
        self.initialized_from_pythonpath = False
        self.initialized_from_xml_directory = False
        SpecInitializer.__init__(self, directories)

    @overrides(SpecInitializer)
    def _find_from_library_xml_directory(self, directory, name):
        assert(name == 'name')
        self.directory = directory
        return self._directory_mapping.get(directory, None)

    @overrides(SpecInitializer)
    def _find_from_pythonpath(self, name):
        assert(name == 'name')
        return self._pythonpath_return_value

    @overrides(SpecInitializer)
    def _init_from_specfile(self, specfile, name):
        if not specfile:
            return None
        self.initialized_from_pythonpath = (specfile == 'pythonpath')
        self.initialized_from_xml_directory = (specfile == 'directory')
        return 'OK'


class TestSpecInitializer(unittest.TestCase):

    def test_pythonpath_is_preferred_before_xml_directory(self):
        specinitializer = MockedSpecInitializer()
        self.assertEquals('OK', specinitializer.init_from_spec('name'))
        self.assertTrue(specinitializer.initialized_from_pythonpath)
        self.assertFalse(specinitializer.initialized_from_xml_directory)

    def test_default_directory_is_always_used(self):
        specinitializer = MockedSpecInitializer(pythonpath_return_value=None)
        self.assertEquals('OK', specinitializer.init_from_spec('name'))
        self.assertFalse(specinitializer.initialized_from_pythonpath)
        self.assertTrue(specinitializer.initialized_from_xml_directory)
        self.assertEquals(specinitializer.directory, LIBRARY_XML_DIRECTORY)

    def test_not_finding_correct_file(self):
        specinitializer = MockedSpecInitializer(pythonpath_return_value=None, directory_mapping={})
        self.assertEquals(None, specinitializer.init_from_spec('name'))
        self.assertFalse(specinitializer.initialized_from_pythonpath)
        self.assertFalse(specinitializer.initialized_from_xml_directory)

    def test_finding_from_given_directory(self):
        specinitializer = MockedSpecInitializer(directories=['my_dir'],
                                                pythonpath_return_value=None,
                                                directory_mapping={'my_dir':'directory'})
        self.assertEquals('OK', specinitializer.init_from_spec('name'))
        self.assertFalse(specinitializer.initialized_from_pythonpath)
        self.assertTrue(specinitializer.initialized_from_xml_directory)
        self.assertEquals(specinitializer.directory, 'my_dir')


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_librarymanager
import os
import unittest
import sys
from robotide.spec.libraryfetcher import get_import_result
from robotide.spec.librarymanager import LibraryManager
from resources import DATAPATH

sys.path.append(os.path.join(DATAPATH, 'libs'))

class TestLibraryManager(unittest.TestCase):

    def setUp(self):
        self._keywords = None
        self._library_manager = LibraryManager(':memory:')
        self._library_manager._initiate_database_connection()
        self._library_manager._database.create_database()

    def tearDown(self):
        self._library_manager._database.close()

    def test_database_update(self):
        self._library_manager.fetch_keywords('BuiltIn', '', self._callback)
        keywords = get_import_result('BuiltIn', '')
        self._library_manager._handle_message()
        self.assertFalse(self._library_manager._keywords_differ(keywords, self._keywords))

    def test_manager_handles_callback_exception(self):
        self._library_manager.fetch_keywords('Collections', '', (lambda *_: 1/0))
        self._library_manager._handle_message()
        self._library_manager.fetch_keywords('BuiltIn', '', self._callback)
        self._library_manager._handle_message()
        self.assertTrue(self._keywords is not None)

    def test_fetching_unknown_library(self):
        self._library_manager.fetch_keywords('FooBarZoo', '', self._callback)
        self._library_manager._handle_message()
        self.assertEqual(self._keywords, [])

    def test_fetching_from_library_xml(self):
        self._library_manager.fetch_keywords('LibSpecLibrary', '', self._callback)
        self._library_manager._handle_message()
        self.assertEqual(len(self._keywords), 3)

    def test_manager_handler_library_that_throws_timeout_exception(self):
        import Exceptional as e
        self._library_manager.fetch_keywords(e.__file__, '', self._callback)
        self._library_manager._handle_message()
        self.assertEqual(self._keywords, [])

    def _callback(self, keywords):
        self._keywords = keywords


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_library_database
import unittest
from robotide.spec.iteminfo import LibraryKeywordInfo
from robotide.spec.librarydatabase import LibraryDatabase
from robotide.spec.libraryfetcher import get_import_result

class TestLibraryDatabase(unittest.TestCase):

    def setUp(self):
        self._database = LibraryDatabase(':memory:')
        self._database.create_database()

    def tearDown(self):
        self._database.close()

    def test_inserting_and_fetching(self):
        collections_kws = self._get_and_insert_keywords('Collections', '')
        string_kws = self._get_and_insert_keywords('String', '')
        builtin_kws = self._get_and_insert_keywords('BuiltIn', '')
        collections_kws_from_db = self._database.fetch_library_keywords('Collections', '')
        string_kws_from_db = self._database.fetch_library_keywords('String', '')
        builtin_kws_from_db = self._database.fetch_library_keywords('BuiltIn', '')
        for originals, from_database in [[collections_kws, collections_kws_from_db],
                                         [string_kws, string_kws_from_db],
                                         [builtin_kws, builtin_kws_from_db]]:
            self._check_keywords(originals, from_database)

    def test_finds_newest_version(self):
        self._database.insert_library_keywords('lib.py', 'foo', [LibraryKeywordInfo('this is old', 'doc', 'lib.py', '')])
        self._database.insert_library_keywords('lib.py', 'foo', [LibraryKeywordInfo('this is new', 'doc', 'lib.py', '')])
        kws = self._database.fetch_library_keywords('lib.py', 'foo')
        self.assertEqual(len(kws), 1, unicode(kws))
        self.assertEqual(kws[0].name, 'this is new')

    def test_removing_old_data(self):
        self._get_and_insert_keywords('String', '')
        self._get_and_insert_keywords('String', '')
        newest = self._get_and_insert_keywords('String', '')
        newest_again = self._database.fetch_library_keywords('String', '')
        self._check_keywords(newest, newest_again)
        self.assertEqual(self._database._connection.execute('select count(*) from libraries').fetchone()[0], 1)
        self.assertEqual(self._database._connection.execute('select count(*) from keywords').fetchone()[0], len(newest))

    def test_unknown_library_keywords_fetch(self):
        results = self._database.fetch_library_keywords('Something that is not there', 'at all')
        self.assertEqual(len(results), 0)

    def test_unknown_library_fetch(self):
        self.assertFalse(self._database.library_exists('library', ''))
        self._database.insert_library_keywords('library', '', [])
        self.assertTrue(self._database.library_exists('library', ''))

    def _get_and_insert_keywords(self, library_name, library_arguments):
        kws = get_import_result(library_name, library_arguments)
        self._database.insert_library_keywords(library_name, library_arguments, kws)
        return kws

    def _check_keywords(self, originals, from_database):
        for k1, k2 in zip(originals, from_database):
            self.assertEqual(k1.name, k2.name)
            self.assertEqual(k1.doc, k2.doc)
            self.assertEqual(k1.arguments, k2.arguments, 'Arguments differ ("%s" != "%s") on keyword %s' %
                                                         (k1.arguments, k2.arguments, k1.name))
            self.assertEqual(k1.source, k2.source)
        self.assertEqual(len(originals), len(from_database))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_specimporter
import unittest
from robotide.spec.specimporter import SpecImporterPlugin
from robotide.utils import overrides


class PartiallyMockedSpecImporter(SpecImporterPlugin):

    def __init__(self, is_valid_path):
        self.__is_valid_path = is_valid_path
        self.spec_stored = False
        self.namespace_update_executed = False

    @overrides(SpecImporterPlugin)
    def _get_path_to_library_spec(self):
        return 'somepath.xml'

    @overrides(SpecImporterPlugin)
    def _is_valid_path(self, path):
        return self.__is_valid_path

    @overrides(SpecImporterPlugin)
    def _store_spec(self, path):
        self.spec_stored = True

    @overrides(SpecImporterPlugin)
    def _execute_namespace_update(self):
        self.namespace_update_executed = True


class TestSpecImporter(unittest.TestCase):

    def test_execute_spec_importer(self):
        spec_importer = PartiallyMockedSpecImporter(True)
        spec_importer.execute_spec_import()
        self.assertTrue(spec_importer.spec_stored)
        self.assertTrue(spec_importer.namespace_update_executed)

    def test_execute_spec_importer_with_invalid_path(self):
        spec_importer = PartiallyMockedSpecImporter(False)
        spec_importer.execute_spec_import()
        self.assertFalse(spec_importer.spec_stored)
        self.assertFalse(spec_importer.namespace_update_executed)


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_argumentparsing
import unittest
import robotide


class ArgumentParsingTestCase(unittest.TestCase):

    def test_no_args(self):
        self._assert_args([])

    def _assert_args(self, tested, expected_no_update_check=False, expected_debug_console=False, expected_path=None):
        self.assertEqual((expected_no_update_check, expected_debug_console, expected_path), robotide._parse_args(tested))

    def test_path_to_data(self):
        self._assert_args(['data'], expected_path='data')

    def test_noupdatecheck(self):
        self._assert_args(['--noupdatecheck'], expected_no_update_check=True)

    def test_noupdatecheck_and_path(self):
        self._assert_args(['--noupdatecheck', 'path'], expected_no_update_check=True, expected_path='path')

    def test_debugconsole(self):
        self._assert_args(['--debugconsole'], expected_debug_console=True)

    def test_debugconsole_and_path(self):
        self._assert_args(['--debugconsole', 'dir'], expected_debug_console=True, expected_path='dir')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = time_tests
#!/usr/bin/env python
import os
import sys
import time
from nose import run


def test_modules():
    topdir = os.path.dirname(__file__)
    for dirpath, _, filenames in os.walk(topdir):
        for fname in filenames:
            if _is_test_module(fname):
                yield os.path.join(dirpath, fname)

def _is_test_module(fname):
    return fname.startswith('test') and fname.endswith('.py')


def collect_execution_times(test_modules):
    sys.argv.append('--match=^test')
    sys.argv.append('-q')
    for tmodule in test_modules:
        yield(tmodule, _test_module_execution_time(tmodule))

def _test_module_execution_time(tmodule):
    starttime = time.time()
    run(defaultTest=tmodule)
    return time.time() - starttime


def write_results(exectimes, write):
    total = 0.0
    writes = []
    for record in reversed(sorted(exectimes, key=lambda record: record[1])):
        total += record[1]
        write('%s%.02f s (%.02f s)\n' % (record[0].ljust(70), record[1], total))
    write('\nTotal test execution time: %.02f seconds\n' % total)

def main():
    exectimes = collect_execution_times(test_modules())
    with open('testtimes.txt', 'w') as output:
        def write(txt):
            output.write(txt)
            sys.stdout.write(txt)
        write_results(exectimes, write)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_keyword_search
#  Copyright 2008 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest
from robot.utils.asserts import assert_equals, assert_true

from robotide.ui.keywordsearch import _KeywordData, _SearchCriteria,\
    ALL_KEYWORDS, ALL_USER_KEYWORDS, ALL_LIBRARY_KEYWORDS, _SortOrder
from robotide.spec.iteminfo import ItemInfo

test_kws = [ItemInfo(name, source, desc) for name, source, desc in
            [ ('Should Be Equal', 'BuiltIn', 'Foo'),
              ('get bar', 'resource.txt', 'getting bar'),
              ('get bar2', 'resource2.txt', 'getting bar'),
              ('Get File', 'OperatingSystem', 'Bar'),
              ('Bar', 'OBarsystem', 'Doc'),
              ('BarBar', 'OBarBarSystem', 'Doc'),
              ('User Keyword', 'resource.html', 'Quuz'), ]
           ]


class Keyword(object):
    
    def __init__(self, name, source, doc):
        self.name = name
        self.source = source
        self.doc = doc

    def is_user_keyword(self):
        return self.source.endswith('.txt')

    def is_library_keyword(self):
        return not self.source.endswith('.txt')


class TestSearchCriteria(unittest.TestCase):
    keyword = Keyword('start Da ta end', 'source.txt', 'some dO c here')
    library_keyword = Keyword('start Da ta end', 'library', 'some dO c here')

    def test_defaults(self):
        criteria = _SearchCriteria()
        for kw in test_kws:
            assert_true(criteria.matches(kw))

    def test_pattern(self):
        self._test_criteria(True, 'data', False, self.keyword)
        self._test_criteria(False, 'no match', False, self.keyword)

    def test_doc_search(self):
        self._test_criteria(True, 'doc', True, self.keyword)
        self._test_criteria(False, 'doc', False, self.keyword)

    def test_exact_source_filter_matches(self):
        self._test_criteria(True, '', True, self.keyword, 'source.txt')
        self._test_criteria(True, 'data', True, self.keyword, 'source.txt')
        self._test_criteria(False, 'no match', True, self.keyword, 'source.txt')

    def test_exact_source_filter_does_not_match(self):
        self._test_criteria(False, 'doc', True, self.keyword,  'Some')
        self._test_criteria(False, 'data', False, self.keyword, 'Some')

    def test_source_filter_all_keywords(self):
        self._test_criteria(True, '', True, self.keyword, ALL_KEYWORDS)
        self._test_criteria(True, '', True, self.library_keyword, ALL_KEYWORDS)

    def test_source_filter_resource_keywords(self):
        self._test_criteria(True, '', True, self.keyword, ALL_USER_KEYWORDS)
        self._test_criteria(False, '', True, self.library_keyword, ALL_USER_KEYWORDS)

    def test_source_filter_library_keywords(self):
        self._test_criteria(True, '', True, self.library_keyword, ALL_LIBRARY_KEYWORDS)
        self._test_criteria(False, '', True, self.keyword, ALL_LIBRARY_KEYWORDS)

    def _test_criteria(self, expected, pattern, search_doc, keyword,
                       source_filter=ALL_KEYWORDS):
        criteria = _SearchCriteria(pattern, search_doc, source_filter)
        assert_equals(criteria.matches(keyword), expected)


class TestKeyWordData(unittest.TestCase):

    def test_sort_by_search(self):
        order = _SortOrder()
        order.searched('Bar')
        kw_data = _KeywordData(test_kws, order, search_criteria='Bar')
        for index, name in enumerate(['Bar',
                                      'BarBar',
                                      'get bar',
                                      'get bar2',
                                      'Get File']):
            assert_equals(kw_data[index].name, name)

    def test_sort_by_name(self):
        order = _SortOrder()
        kw_data = _KeywordData(test_kws, order)
        for index, name in enumerate(['Bar',
                                      'BarBar',
                                      'get bar',
                                      'get bar2',
                                      'Get File',
                                      'Should Be Equal',
                                      'User Keyword']):
            assert_equals(kw_data[index].name, name)

    def test_sort_by_name_reversed(self):
        order = _SortOrder()
        order.sort(0)
        kw_data = _KeywordData(test_kws, order)
        for index, name in enumerate(['User Keyword',
                                      'Should Be Equal',
                                      'Get File',
                                      'get bar2', 
                                      'get bar',
                                      'BarBar',
                                      'Bar']):
            assert_equals(kw_data[index].name, name)

    def test_sort_by_source(self):
        order = _SortOrder()
        order.sort(1)
        kw_data = _KeywordData(test_kws, order)
        for index, name in enumerate(['Should Be Equal',
                                      'BarBar',
                                      'Bar',
                                      'Get File',
                                      'User Keyword',
                                      'get bar',
                                      'get bar2']):
            assert_equals(kw_data[index].name, name)

    def test_sort_by_source_reversed(self):
        order = _SortOrder()
        order.sort(1)
        order.sort(1)
        kw_data = _KeywordData(test_kws, order)
        for index, name in enumerate(['get bar2',
                                      'get bar',
                                      'User Keyword',
                                      'Get File',
                                      'Bar',
                                      'BarBar',
                                      'Should Be Equal']):
            assert_equals(kw_data[index].name, name)


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_menu
#  Copyright 2008 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest
from robot.utils.asserts import assert_equals, assert_none
from robotide.ui.actiontriggers import _NameBuilder


class TestGetNameWithAccelerator(unittest.TestCase):

    def setUp(self):
        self._nb = _NameBuilder()

    def _test(self, input, expected):
        assert_equals(self._nb.get_name(input), expected)

    def test_use_first_free_char(self):
        self._test('File', '&File')
        self._test('Foo', 'F&oo')
        self._test('Foobar', 'Foo&bar')

    def test_case_insensitive(self):
        self._test('File', '&File')
        self._test('foo', 'f&oo')
        self._test('bar', '&bar')
        self._test('Barbi', 'B&arbi')

    def test_all_letters_taken(self):
        self._test('File', '&File')
        self._test('Open', '&Open')
        self._test('Foo', 'Foo')

    def test_space_is_not_used(self):
        self._test('File', '&File')
        self._test('Open', '&Open')
        self._test('Foo Bar', 'Foo &Bar')

    def test_free_given(self):
        self._test('&File', '&File')
        self._test('O&pen', 'O&pen')

    def test_non_free_given(self):
        self._test('&File', '&File')
        self._test('&Foo', 'F&oo')
        self._test('&Open', 'O&pen')
        self._test('F&oo Bar', 'Foo &Bar')
        self._test('&Fofo', 'Fofo')

    def test_get_same_acc_for_same_name(self):
        for name in 'F&ile', 'File', '&File', 'FI&LE', 'fil&e', 'file':
            self._test(name, 'F&ile')

    def test_ambersand_at_end_is_ignored(self):
        self._test('File&', '&File')

    def test_get_registered_name(self):
        self._test('&File', '&File')
        for name in 'F&ile', 'File', '&File', 'FI&LE', 'fil&e', 'file':
            assert_equals(self._nb.get_registered_name(name), '&File')
        assert_none(self._nb.get_registered_name('Non Existing'))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_namedialogs
import unittest
from robot.parsing.model import TestCaseFile
from robot.utils.asserts import assert_equals

from robotide.controller.filecontrollers import TestCaseFileController
from robotide.editor.editordialogs import TestCaseNameDialog, UserKeywordNameDialog

from resources import PYAPP_REFERENCE, wx


def file_controller():
    return TestCaseFileController(TestCaseFile())


class TestNameDialogTest(unittest.TestCase):
    _frame = wx.Frame(None)

    def test_creation(self):
        test_ctrl = file_controller().create_test('A test')
        dlg = TestCaseNameDialog(test_ctrl)
        assert_equals(dlg.get_name(), '')


class UserKeywordNameDialogTest(unittest.TestCase):

    def test_creation(self):
        kw_ctrl = file_controller().create_keyword('Keyword it is')
        dlg = UserKeywordNameDialog(kw_ctrl)
        assert_equals(dlg.get_name(), '')

    def test_arguments_are_returned(self):
        kw_ctrl = file_controller().create_keyword('Keyword it is')
        dlg = UserKeywordNameDialog(kw_ctrl)
        assert_equals(dlg.get_args(), '')

########NEW FILE########
__FILENAME__ = test_review
#  Copyright 2008 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


import unittest
import datafilereader
from robot.utils.asserts import assert_true
from robotide.ui.review import ReviewRunner

class TestReview(unittest.TestCase):
    
    def setUp(self):
        self.chief = datafilereader.construct_chief_controller(datafilereader.UNUSED_KEYWORDS_PATH)
        self.runner = ReviewRunner(self.chief, self)

    def tearDown(self):
        self.chief.close()
    
    def test_filter(self):
        assert_true(self.helper(True, False, False, False, False,
                                "", ["Test suite 1", "Test suite 2", "Res1", "Abc", "Foobar"]))
        assert_true(self.helper(True, False, False, False, True,
                                "", ["Test suite 1", "Test suite 2"]))
        assert_true(self.helper(False, True, False, False, True,
                                "", ["Res1", "Abc", "Foobar"]))
        assert_true(self.helper(True, True, False, False, True,
                                "1", ["Test suite 1", "Res1"]))
        assert_true(self.helper(True, True, True, False, True,
                                "1,2", ["Abc", "Foobar"]))
        assert_true(self.helper(True, True, True, True, True,
                                "^.es.*1$", ["Test suite 2", "Abc", "Foobar"]))
        assert_true(self.helper(True, True, False, True, True,
                                ",,", ["Test suite 1", "Test suite 2", "Res1", "Abc", "Foobar"]))
        assert_true(self.helper(True, True, False, False, True,
                                ",s,", ["Test suite 1", "Test suite 2", "Res1"]))
        assert_true(self.helper(True, True, True, True, True,
                                ".*es,.*o{2}", ["Abc"]))

    def helper(self, tcfiles, resfiles, exclude, regex, active, string, expected_results):
        self.runner.set_filter_active(active)
        self.runner.set_filter_mode(exclude)
        self.runner.set_filter_source_testcases(tcfiles)
        self.runner.set_filter_source_resources(resfiles)
        self.runner.set_filter_use_regex(regex)
        self.runner.parse_filter_string(string)
        
        counter = 0
        for df in self.runner._get_datafile_list():
            if df.name not in expected_results:
                print "\"%s\" should have been filtered out " % df.name
                return False
            counter += 1
        
        all_items_checked = counter == len(expected_results)
        if not all_items_checked:
            print "Result contained %d files, expected %d" % (counter, len(expected_results))
        return all_items_checked


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tree
#  Copyright 2008 Nokia Siemens Networks Oyj
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# This is needed to be able to create WX objects.

import unittest

from robotide.robotapi import (TestDataDirectory, TestCaseFile, ResourceFile,
                               TestCase, UserKeyword)
from robot.utils.asserts import assert_equals
from robotide.spec.librarymanager import LibraryManager
from robotide.ui.images import TreeImageList

from robotide.application import ChiefController
from robotide.controller.filecontrollers import (TestDataDirectoryController,
                                                 ResourceFileController)

from robotide.ui.actiontriggers import MenuBar, ToolBar, ShortcutRegistry
from robotide.ui.mainframe import ActionRegisterer
from resources import PYAPP_REFERENCE, FakeSettings

from robotide.ui import tree as st
from robotide.ui import treenodehandlers as th
from robotide.publish import PUBLISHER
from robotide.namespace.namespace import Namespace
th.FakeDirectorySuiteHandler = th.FakeUserKeywordHandler = \
    th.FakeSuiteHandler = th.FakeTestCaseHandler = \
    th.FakeResourceHandler = th.TestDataDirectoryHandler
st.Editor = lambda *args: _FakeEditor()
from robotide.ui.tree import Tree
Tree._show_correct_editor = lambda self, x:None
Tree.get_active_datafile = lambda self: None
Tree._select = lambda self, node: self.SelectItem(node) # CallAfter does not work in unit tests
# wx needs to imported last so that robotide can select correct wx version.
import wx


class _FakeMainFrame(wx.Frame):
    _editor_panel = None
    def publish(self, *args):
        pass


class _FakeImageList(wx.ImageList):
    def __init__(self):
        wx.ImageList.__init__(self, 16, 16)
        self._image = _FakeImage(self)
    def __getitem__(self, name):
        return self._image

class _FakeImage(object):
    def __init__(self, imglist):
        self.normal = self.expanded = \
            imglist.Add(wx.ArtProvider_GetBitmap(wx.ART_FOLDER, wx.ART_OTHER,
                                                 (16,16)))

class _FakeEditor(object):
    view = close = lambda *args: None


class _BaseSuiteTreeTest(unittest.TestCase):

    def setUp(self):
        frame = _FakeMainFrame(None)
        self._model = self._create_model()
        self._tree = Tree(frame, ActionRegisterer(MenuBar(frame), ToolBar(frame),
                                                  ShortcutRegistry(frame)))
        images =  TreeImageList()
        self._tree._images = images
        self._tree.SetImageList(images)
        self._tree.populate(self._model)
        self._expand_all()

    def tearDown(self):
        PUBLISHER.unsubscribe_all()

    def _create_model(self):
        suite = self._create_directory_suite('/top_suite')
        suite.children = [self._create_file_suite('sub_suite_%d.txt' % i)
                          for i in range(3)]
        res = ResourceFile()
        res.source = 'resource.txt'
        res.keyword_table.keywords.append(UserKeyword(res, 'Resource Keyword'))
        library_manager = LibraryManager(':memory:')
        library_manager.create_database()
        model = ChiefController(Namespace(FakeSettings()), library_manager=library_manager)
        model._controller = TestDataDirectoryController(suite)
        rfc = ResourceFileController(res, chief_controller=model)
        model.resources.append(rfc)
        model.insert_into_suite_structure(rfc)
        return model

    def _create_directory_suite(self, source):
        return self._create_suite(TestDataDirectory, source, is_dir=True)

    def _create_file_suite(self, source):
        suite = self._create_suite(TestCaseFile, source)
        suite.testcase_table.tests  = [TestCase(suite, '%s Fake Test %d' % (suite.name, i))
                                       for i in range(5)]
        return suite

    def _create_suite(self, suite_class, source, is_dir=False):
        suite = suite_class()
        suite.source = source
        if is_dir:
            suite.directory = source
        suite.keyword_table.keywords = [ UserKeyword(suite.keyword_table,
                                                     '%s Fake UK %d' % (suite.name, i))
                                         for i in range(5) ]
        return suite

    def _expand_all(self):
        for node in self._tree._datafile_nodes[1:]:
            self._tree._expand_and_render_children(node)

    def _get_selected_label(self):
        return self._tree.GetItemText(self._tree.GetSelection())

    def _get_node(self, label):
        node = self._tree._controller.find_node_with_label(self._tree._root, label)
        return node or self._tree._controller.find_node_with_label(self._tree._root, '*' + label)

    def _select_node(self, label):
        self._tree.SelectItem(self._get_node(label))


class TestPopulating(_BaseSuiteTreeTest):

    def test_suite_count_and_names(self):
        assert_equals(len(self._tree._datafile_nodes), 5)
        for index, name in enumerate(['Top Suite'] +
                                     ['Sub Suite %d' % i for i in range(3)]):
            assert_equals(self._tree.GetItemText(self._tree._datafile_nodes[index]),
                          name)

    def test_file_suite_has_correct_subnodes(self):
        file_suite = self._tree._datafile_nodes[1]
        self._assert_children(file_suite, ['Sub Suite 0 Fake Test 0'])

    def _assert_children(self, parent, children):
        item, cookie = self._tree.GetFirstChild(parent)
        assert_equals(self._tree.GetItemText(item), children[0])
        for name in children[1:]:
            item, cookie = self._tree.GetNextChild(parent, cookie)
            assert_equals(self._tree.GetItemText(item), name)


class TestAddingItems(_BaseSuiteTreeTest):

    def test_adding_user_keyword(self):
        suite = self._model.data
        suite.create_keyword('New Fake UK')
        assert_equals(self._get_selected_label(), 'New Fake UK')

    def test_adding_test(self):
        suite = self._model.data.children[0]
        create_test = suite.create_test('New Fake Test')
        self._tree.add_test(self._get_node(suite.name), create_test)
        assert_equals(self._get_selected_label(), 'New Fake Test')


class TestNodeSearchAndSelection(_BaseSuiteTreeTest):

    def test_topsuite_node_should_be_selected_by_default(self):
        assert_equals(self._get_selected_label(), 'Top Suite')

    def test_searching_matching_uk_node(self):
        self._select_and_assert_selection(self._model.data.keywords[0].data)
        self._select_and_assert_selection(self._model.data.children[1].keywords[2].data)

    def _select_and_assert_selection(self, uk):
        self._tree.select_user_keyword_node(uk)
        assert_equals(self._get_selected_label(), uk.name)

    def test_get_active_suite_or_resource(self):
        exp = [('Top Suite Fake UK 2', 'Top Suite'),
               ('Sub Suite 1 Fake Test 1', 'Sub Suite 1'),
               ('Resource Keyword', 'Resource')]
        for node, parent_name in exp:
            self._select_node_and_assert_parent(node, parent_name)

    def _select_node_and_assert_parent(self, label, expected_parent_name):
        self._select_node(label)
        suite_or_resource = self._tree.get_selected_datafile()
        assert_equals(suite_or_resource.name, expected_parent_name)


class TestNodeRemoval(_BaseSuiteTreeTest):

    def test_removing_user_keyword(self):
        name = self._model.data.children[1].keywords[1].name
        root = self._tree._root
        count = self._tree.GetChildrenCount(self._tree._root)
        self._tree.Delete(self._tree._controller.find_node_with_label(root, name))
        assert_equals(count -1, self._tree.GetChildrenCount(self._tree._root))


class TestRefreshingDataNode(_BaseSuiteTreeTest):

    def test_refreshing_suite(self):
        orig_node_lenght = len(self._tree._datafile_nodes)
        new_name = 'Modified name'
        suite = self._model.data.children[0]
        suite.tests[0].rename(new_name)
        self._tree.refresh_datafile(suite, None)
        self._expand_all()
        snode = self._get_node(suite.display_name)
        tnode = self._tree.GetFirstChild(snode)[0]
        assert_equals(self._tree.GetItemText(tnode), new_name)
        assert_equals(orig_node_lenght, len(self._tree._datafile_nodes))

    def test_refreshing_resource(self):
        orig_node_lenght = len(self._tree._datafile_nodes)
        new_name = 'Ninjaed Uk Name'
        resource = self._model.resources[0]
        resource.keywords[0].rename(new_name)
        self._tree.refresh_datafile(resource, None)
        self._expand_all()
        rnode = self._get_node(resource.display_name)
        knode = self._tree.GetFirstChild(rnode)[0]
        assert_equals(self._tree.GetItemText(knode), new_name)
        assert_equals(orig_node_lenght, len(self._tree._datafile_nodes))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_tree_history
import unittest

from robot.utils.asserts import assert_equals
from robotide.controller.ui.treecontroller import _History


class TestChange(unittest.TestCase):

    def setUp(self):
        self.history = _History()
        for i in range(4):
            self.history.change(i)

    def test_history_states(self):
        assert_equals(self.history._back, range(4))

    def test_change_ignores_state_if_same_as_previous(self):
        self.history.change(3)
        assert_equals(self.history._back, range(4))

    def test_forward_list_is_kept_when_state_is_ignored(self):
        self.history.back()
        self.history.change(2)
        assert_equals(self.history._forward, [3])

    def test_change_sanity(self):
        self.history.back()
        for _ in range(7):
            self.history.change(2)
        self.history.forward()
        for _ in range(7):
            self.history.change(3)
        self.history.change(4)
        assert_equals(self.history._back, range(5))


class TestBack(unittest.TestCase):

    def setUp(self):
        self.history = _History()
        for i in range(4):
            self.history.change(i)

    def test_back_once(self):
        self._test_back(2)

    def test_back_many(self):
        self._test_back(2, 1)

    def test_back_more_than_states(self):
        self._test_back(2,1,0,0,0)

    def test_back_before_state_change(self):
        assert_equals(_History().back(), None)

    def _test_back(self, *states):
        for state in states:
            assert_equals(self.history.back(), state)


class TestForward(unittest.TestCase):

    def setUp(self):
        self.history = _History()
        for i in range(5):
            self.history.change(i)

    def test_forward_once(self):
        self.history.back()
        self._test_forward(4)

    def test_forward_many(self):
        for _ in range(3):
            self.history.back()
        self._test_forward(2,3,4)

    def test_forward_before_back(self):
        assert_equals(self.history.forward(), None)

    def test_forward_before_state_change(self):
        assert_equals(_History().forward(), None)

    def test_change_between_back_and_forward(self):
        self.history.back()
        self.history.change(42)
        assert_equals(self.history.forward(), None)

    def test_back_forward_back_forward(self):
        assert_equals(self.history.back(), 3)
        assert_equals(self.history.forward(), 4)
        assert_equals(self.history.back(), 3)
        assert_equals(self.history.back(), 2)
        assert_equals(self.history.back(), 1)
        assert_equals(self.history.forward(), 2)
        assert_equals(self.history.forward(), 3)
        assert_equals(self.history.back(), 2)
        assert_equals(self.history.forward(), 3)
        assert_equals(self.history.forward(), 4)

    def _test_forward(self, *states):
        for state in states:
            assert_equals(self.history.forward(), state)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_resource_usages
import unittest
import datafilereader
from robot.utils.asserts import assert_equals
from robotide.usages.commands import FindResourceUsages


class ResourceUsageTests(unittest.TestCase):

    # NOTE! The data is shared among tests
    # This is for performance reasons but be warned when you add tests!
    @classmethod
    def setUpClass(cls):
        cls.ctrl = datafilereader.construct_chief_controller(datafilereader.SIMPLE_TEST_SUITE_PATH)
        cls.ts1 = datafilereader.get_ctrl_by_name('TestSuite1', cls.ctrl.datafiles)
        cls.ts2 = datafilereader.get_ctrl_by_name('TestSuite2', cls.ctrl.datafiles)
        cls.resu = datafilereader.get_ctrl_by_name(datafilereader.SIMPLE_TEST_SUITE_RESOURCE_NAME, cls.ctrl.datafiles)

    @classmethod
    def tearDownClass(cls):
        cls.ctrl.close()

    def test_resource_import_knows_imported_resource_controller(self):
        assert_equals(self.resu, self.ts1.imports[0].get_imported_controller())
        assert_equals(self.resu, self.ts2.imports[0].get_imported_controller())

    def test_resource_usages_finding(self):
        usages = list(self.resu.execute(FindResourceUsages()))
        self._verify_length(2, usages)
        self._verify_that_contains(self.ts1, usages)
        self._verify_that_contains(self.ts2, usages)

    def _verify_length(self, expected, usages):
        assert_equals(len(usages), expected)

    def _verify_that_contains(self, item, usages):
        for u in usages:
            if u.item == item.imports:
                if item.display_name != u.name:
                    raise AssertionError('Name "%s" was not expected "%s"!' % (u.name, item.display_name))
                return
        raise AssertionError('Item %r not in usages %r!' % (item, usages))

    def test_import_in_resource_file(self):
        inner_resu = self.resu.imports[0].get_imported_controller()
        usages = list(inner_resu.execute(FindResourceUsages()))
        self._verify_length(1, usages)
        self._verify_that_contains(self.resu, usages)

    def test_none_existing_import(self):
        imp = self.ts1.imports.add_resource('this_does_not_exists.txt')
        assert_equals(imp.get_imported_controller(), None)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_highlightmatcher
import unittest

from robot.utils.asserts import assert_true, assert_false

from robotide.utils import highlight_matcher

class TestHighlightMatcher(unittest.TestCase):

    def test_empty_cell_should_not_match(self):
        assert_false(self.matcher('', ''))

    def test_exact_match(self):
        assert_true(self.matcher('My Keyword', 'My Keyword'))
        assert_false(self.matcher('My Keyword', 'Keyword'))

    def test_normalized_match(self):
        assert_true(self.matcher('MyKeyword', 'My Keyword'))
        assert_true(self.matcher('mykeyword', 'My Keyword'))
        assert_true(self.matcher('my_key_word', 'My Keyword'))

    def test_variable_with_equals_sign(self):
        assert_true(self.matcher('${foo} =', '${foo}'))
        assert_true(self.matcher('${foo}=', '${foo}'))
        assert_true(self.matcher('${foo}=', '${  F O O }'))
        assert_false(self.matcher('${foo}=', '${foo2}'))

    def test_variable_inside_cell_content(self):
        assert_true(self.matcher('${foo} =', 'some  ${foo} data'))
        assert_false(self.matcher('some  ${foo} data', '${foo} ='))
        assert_false(self.matcher('${foo}=', 'some not matching ${var}'))
        assert_true(self.matcher('${foo} =', 'Jep we have ${var} and ${foo}!'))

    def test_list_variable(self):
        assert_true(self.matcher('@{foo} =', '@{foo}'))

    def test_list_variable_when_index_is_used(self):
        assert_true(self.matcher('@{foo}[2]', '@{foo}'))
        assert_true(self.matcher('@{foo}[2]', '@{foo}[1]'))
        assert_true(self.matcher('@{foo}[2]', 'some @{foo} data'))
        assert_false(self.matcher('@{foo}[2]', 'some @{foo2} data'))
        assert_false(self.matcher('@{foo}123', '@{foo}'))

    def test_extended_variable(self):
        assert_true(self.matcher('${foo.extended}', '${foo}'))
        assert_true(self.matcher('${foo + 5}', '${foo}'))
        assert_true(self.matcher('${foo}', 'some ${foo.extended} data'))
        assert_true(self.matcher('${foo} =', 'some ${foo.extended} data'))
        assert_false(self.matcher('${foo + 5}', '${foo2}'))

    def test_list_variable_used_as_scalar(self):
        assert_true(self.matcher('@{foo}', '${foo}'))

    def matcher(self, value, content):
        return highlight_matcher(value, content)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_htmlformat
import unittest
from robotide import utils

class HTMLFormatTestCase(unittest.TestCase):

    def test_formatting(self):
        formated = utils.html_format('| foo | bar |\n| zoo | zaa |\n\nhello')
        self.assertEqual('<table border="1">\n<tr>\n<td>foo</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>zoo</td>\n<td>zaa</td>\n</tr>\n</table>\n<p>hello</p>', formated)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_is_same_drive
import os
import unittest
from robotide.context import IS_WINDOWS
from robotide.utils import is_same_drive

if IS_WINDOWS:

    class IsSameDriveTestCase(unittest.TestCase):

        def test_same_drive_is_case_insensitive(self):
            self.assertTrue(is_same_drive('D:', 'd:'))
            self.assertFalse(is_same_drive('x:', 'E:'))

        def test_same_drive_with_different_path(self):
            path1 = os.path.join('x:', 'foo', 'bar.txt')
            path2 = os.path.join('x:', 'zoo')
            not_same_drive = os.path.join('y:', 'bb')
            self.assertTrue(is_same_drive(path1, path2))
            self.assertFalse(is_same_drive(path1, not_same_drive))
            self.assertFalse(is_same_drive(not_same_drive, path1))

        def test_same_drive_with_same_path(self):
            path = os.path.join('a:', 'quu', 'huu.out')
            self.assertTrue(is_same_drive(path, path))

    if __name__ == '__main__':
        unittest.main()



########NEW FILE########
__FILENAME__ = test_variable_matcher
import unittest
from robotide.utils.variablematcher import *
from robot.utils.asserts import assert_equals, assert_true, assert_false


class _BaseTestIsVariable(object):
    var_name = None
    var_with_curly_bracket = None

    def test_variable_only(self):
        assert_true(self._test_method(self.var_name))
        assert_true(self._test_method(self.var_with_curly_bracket))

    def test_variable_with_equal_sign(self):
        assert_true(self._test_method('%s = ' % self.var_name))
        assert_true(self._test_method('%s= ' % self.var_name))
        assert_true(self._test_method('%s=' % self.var_name))

    def test_variable_part_of_string_should_not_match(self):
        assert_false(self._test_method('some %s variable' % self.var_name))
        assert_false(self._test_method('some %s' % self.var_name))
        assert_false(self._test_method('%s variable' % self.var_name))
        assert_false(self._test_method('%s123' % self.var_name))
        assert_false(self._test_method('%s some text %s' % (self.var_name, self.var_name)))


class TestIsScalarVariable(_BaseTestIsVariable, unittest.TestCase):
    var_name = '${var name}'
    var_with_curly_bracket = '${var \}}'

    def _test_method(self, value):
        return is_scalar_variable(value)


class TestIsListVariable(_BaseTestIsVariable, unittest.TestCase):
    var_name = '@{var name}'
    var_with_curly_bracket = '@{var \}}'

    def _test_method(self, value):
        return is_list_variable(value)

    def test_variable_with_index(self):
        assert_true(is_list_variable('@{list}[21]'))

    def test_list_variable_subitem(self):
        assert_true(is_list_variable_subitem('@{SOME_LIST}[3]'))
        assert_false(is_list_variable_subitem('@{justlist}'))

class TestGetVariable(unittest.TestCase):

    def test_get_scalar_variable(self):
        assert_equals(get_variable('${var}'), '${var}')
        assert_equals(get_variable('${var} = '), '${var}')

    def test_get_list_variable(self):
        assert_equals(get_variable('@{var}'), '@{var}')
        assert_equals(get_variable('@{var} = '), '@{var}')
        assert_equals(get_variable('@{var}[2]'), '@{var}')

    def test_variable_not_found(self):
        assert_equals(get_variable('{not var}'), None)

class TestGetVariableBaseName(unittest.TestCase):

    def test_list_variable(self):
        assert_equals(get_variable_basename('@{list var}'), '@{list var}')
        assert_equals(get_variable_basename('@{list var} ='), '@{list var}')

    def test_attribute_accessed_with_extended_var_syntax(self):
        assert_equals(get_variable_basename('${var name.some_attr}'), '${var name}')

    def test_method_accessed_with_extended_var_syntax(self):
        assert_equals(get_variable_basename('${var name.method()}'), '${var name}')

    def test_slice_accessed_with_extended_var_syntax(self):
        assert_equals(get_variable_basename('${var name[6]}'), '${var name}')

    def test_calculation_accessed_with_extended_var_syntax(self):
        assert_equals(get_variable_basename('${var name + 1 -${23}}'), '${var name}')

class TestFindVariables(unittest.TestCase):

    def test_find_variables_without_var(self):
        assert_equals(find_variable_basenames('some data'), [])

    def test_find_variables(self):
        assert_equals(find_variable_basenames('some ${var} and ${another var}'), 
                      ['${var}', '${another var}'])

    def test_find_scalar_and_list_variable(self):
        assert_equals(find_variable_basenames('some ${var} and @{another var}'), 
                      ['${var}', '@{another var}'])

    def test_find_scalar_with_extended_var_syntax(self):
        assert_equals(find_variable_basenames('some ${var.attr} and ${another var.method()}'), 
                      ['${var}', '${another var}'])

    def test_finding_multiple_variables(self):
        assert_equals(find_variable_basenames('hu ${huhu + 5} pupu ${foo} uhhu ${gugy.gug sdknjs +enedb} {{]{}{}{[[}'),
                                                ['${huhu}', '${foo}', '${gugy}'])

    def test_finding_variables_when_variable_inside_variable(self):
        assert_equals(find_variable_basenames('some ${var + ${another}} inside'), 
                      ['${var}']) # We do not support variables inside vars at the moment



if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_versioncomparator
import unittest
from robotide.utils.versioncomparator import cmp_versions


class VersionComparatorTestCase(unittest.TestCase):

    def test_versions(self):
        self.assertEqual(1, cmp_versions('1.0', '0.0'))
        self.assertEqual(-1, cmp_versions('0.0', '1.0'))
        self.assertEqual(0, cmp_versions('0.0', '0.0'))

    def test_none(self):
        self.assertEqual(1, cmp_versions('21', None))
        self.assertEqual(-1, cmp_versions(None, '3.21'))
        self.assertEqual(0, cmp_versions(None, None))

    def test_trunk_is_smaller_than_released_version(self):
        self.assertEqual(1, cmp_versions('0.02', 'trunk'))
        self.assertEqual(1, cmp_versions('1.2.3', 'trunk'))
        self.assertEqual(1, cmp_versions('13.001', 'trunk'))

    def test_zero_and_empty_are_equal(self):
        self.assertEqual(0, cmp_versions('0', '0.0.0.0'))
        self.assertEqual(0, cmp_versions('2.0.1', '2.0.1.0'))

    def test_release_candidate_is_smaller_than_released(self):
        self.assertEqual(1, cmp_versions('0.45', '0.45rc1'))
        self.assertEqual(-1, cmp_versions('1.4rc2', '1.4'))

    def test_alpha_less_than_beta_less_than_rc(self):
        self.assertEqual(1, cmp_versions('0b', '0a'))
        self.assertEqual(-1, cmp_versions('1.0b', '1.0rc1'))

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_arguments_validation
#  Copyright 2008 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest

from robot.utils.asserts import assert_equals, assert_none

from robotide.validators import ArgumentsValidator


class Test(unittest.TestCase):
    validate = ArgumentsValidator()._validate

    def test_valid_arguments_validation(self):
        for arg in ["${arg}", "${arg}|${arg2}", "${arg}=", "${arg}=default val", 
                    "${a} | ${b}=d | ${c}=\\| | ${d}=", "@{list}",
                    "${a} | ${b} | ${c}=1 | ${d}=2 | ${e}=3 | @{f}"]:
            assert_none(self.validate(arg))

    def test_invalid_arguments_validation(self):
        for arg in ["arg", "@{list}=", "@{list}=fooness"]:
            assert_equals(self.validate(arg),
                          "Invalid argument syntax '%s'" % arg)
        for arg, err in [("|${a}", ""), ("${a} | ${a2} | invalid", "invalid")]:
            assert_equals(self.validate(arg),
                          "Invalid argument syntax '%s'" % err)

    def test_list_arg_not_last(self):
        for arg in ["@{list} | ${arg}", "@{list} | ${arg} | @{list2}", 
                    "@{list} | ${arg}=foo", "@{list} | @{list2}"]:
            assert_equals(self.validate(arg),
                          "List variable allowed only as the last argument")

    def test_req_arg_after_defaults(self):
        for arg in ["${a}=default | ${a2}", "${a} | ${b}=default | ${c}"]:
            assert_equals(self.validate(arg),
                          "Required arguments not allowed after arguments "
                          "with default values.")


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_name_validation
import unittest
from robot.parsing.model import VariableTable, KeywordTable, TestCaseTable
from robotide.controller.macrocontrollers import UserKeywordController, TestCaseController
from robotide.controller.tablecontrollers import VariableTableController, KeywordTableController, TestCaseTableController
from robotide.validators import ScalarVariableNameValidator, ListVariableNameValidator, UserKeywordNameValidator, TestCaseNameValidator


class _NameValidationTest(object):

    def mock_ctrl(self):
        self.datafile = self
        self.datafile_controller = self
        self.mark_dirty = lambda: 0
        self.update_namespace = lambda: 0
        self.register_for_namespace_updates = lambda *args: 0

    def test_new_name_validation_pass(self):
        self.assertTrue(self.validate('NewName'))

    def test_new_name_validation_fails_when_same_already_exists(self):
        self.add_named('Exists')
        self.assertFalse(self.validate('Exists'))

    def test_new_name_validation_fails_when_normalized_same_already_exists(self):
        self.add_named('NoRmAliZeD')
        self.assertFalse(self.validate('Normalized'))

    def test_rename_validation_pass(self):
        self.assertTrue(self.rename_validate('Old', 'New'))

    def test_rename_validation_fails_when_same_already_exists(self):
        self.add_named('ThisIsAlreadyInThere')
        self.assertFalse(self.rename_validate('Old', 'ThisIsAlreadyInThere'))

    def test_rename_validation_pass_when_different_than_previous_but_normalized_eq(self):
        self.assertTrue(self.rename_validate('NorMALIzed', 'N_O_R_M_A_L_I_zed'))


class _VariableNameValidationTest(_NameValidationTest):

    def setUp(self):
        self._variable_table_ctrl = VariableTableController(self, VariableTable(self))
        self.mock_ctrl()

    def add_named(self, name):
        self._variable_table_ctrl.add_variable('%s{%s}' % (self.symbol, name), 'value')

    def validate(self, name, old=None):
        self._validator = self.validator_class(self._variable_table_ctrl, old)
        return self._validator._validate('%s{%s}' % (self.symbol, name)) == ''

    def rename_validate(self, old, new):
        self.add_named(old)
        return self.validate(new, '%s{%s}' % (self.symbol, old))


class ScalarNameValidationTest(_VariableNameValidationTest, unittest.TestCase):
    symbol = '$'
    validator_class = ScalarVariableNameValidator


class ListVariableNameValidationTest(_VariableNameValidationTest, unittest.TestCase):
    symbol = '@'
    validator_class = ListVariableNameValidator


class _MacroNameValidationTest(_NameValidationTest):

    def setUp(self):
        self.mock_ctrl()
        self._table_ctrl = self.table_ctrl_class(self, self.table_class(self))
        self._ctrl = self.ctrl_class(self._table_ctrl, self)

    def add_named(self, name):
        return self._ctrl._parent.new(name)

    def validate(self, name, old=None):
        validator = self.validator_class(self._ctrl, old)
        return validator._validate(name) == ''

    def rename_validate(self, old, new):
        self._ctrl = self.add_named(old)
        return self.validate(new, old)


class KeywordNameValidationTest(_MacroNameValidationTest, unittest.TestCase):
    table_class = KeywordTable
    table_ctrl_class = KeywordTableController
    ctrl_class = UserKeywordController
    validator_class = UserKeywordNameValidator


class TestCaseNameValidationTest(_MacroNameValidationTest, unittest.TestCase):
    table_class = TestCaseTable
    table_ctrl_class = TestCaseTableController
    ctrl_class = TestCaseController
    validator_class = TestCaseNameValidator


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_timeout_validation
import unittest
from robotide.validators import TimeoutValidator

class TimeoutValidationTest(unittest.TestCase):

    def setUp(self):
        self.validator = TimeoutValidator()
        self.validator._set_window_value = self._catch_value
        self._value = ""

    def _catch_value(self, value):
        self._value = value

    def test_timeout_validation_passes(self):
        result = self.validator._validate("2h 30min 45sec")
        self.assertEqual( result, None, "Empty string should have been returned from validate: %s" % result)

    def test_timeout_validation_negative_cases(self):
        self._run_validation("-1000","-1","0")

    def test_timeout_validation_illegal_format(self):
        self._run_validation("1 minuuttia", "2 tuntia ja muuta","dshfkjhsdkjfhjk")

    def _run_validation(self, *test_values):
        errors = []
        for val in test_values:
            result = self.validator._validate(val)
            if result == None:
                errors.append("\n%s should have failed, but didn't, got '%s'" % (val, result))
        self.assertEqual(len(errors), 0, ''.join(errors))

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_popupmenu
#  Copyright 2010 Nokia Siemens Networks Oyj
#  
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  
#      http://www.apache.org/licenses/LICENSE-2.0
#  
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import unittest

from robot.utils.asserts import assert_equals, assert_none

from robotide.widgets.popupmenu import PopupMenuItems, PopupMenuItem


class Parent(object):

    def OnDoSomething(self):
        pass

    def OnDo(self):
        pass


class TestPopupMenuItems(unittest.TestCase):

    def test_initing_without_data(self):
        items = PopupMenuItems()
        assert_equals(len(items._items), 0)

    def test_initing_with_data(self):
        parent = Parent()
        items = PopupMenuItems(parent, ['Do Something', 'Do'])
        assert_equals(len(items._items), 2)

    def test_adding_data(self):
        parent = Parent()
        items = PopupMenuItems(parent, ['Do Something'])
        assert_equals(len(items._items), 1)
        items.add_menu_item(PopupMenuItem('Do', parent=parent))
        assert_equals(len(items._items), 2)
        def _test():
            pass
        items.add_menu_item(PopupMenuItem('Do', callable=_test))
        assert_equals(len(items._items), 3)
        assert_equals(items._items[-1].callable, _test)

    def test_adding_separator(self):
        items = PopupMenuItems()
        items.add_separator()
        assert_equals(len(items._items), 1)


class TestPopupMenuItem(unittest.TestCase):

    def test_creation_with_name_and_parent(self):
        parent = Parent()
        item = PopupMenuItem('Do Something', parent=parent)
        assert_equals(item.callable, parent.OnDoSomething)

    def test_creation_with_name_and_callable(self):
        def _test():
            pass
        item = PopupMenuItem('Do Something', _test)
        assert_equals(item.callable, _test)

    def test_creation_with_name_shortcut_in_name(self):
        parent = Parent()
        item = PopupMenuItem('Do\tCtrl-x', parent=parent)
        assert_equals(item.name, 'Do\tCtrl-x')
        assert_equals(item.callable, parent.OnDo)

    def test_creating_separator(self):
        item = PopupMenuItem('---')
        assert_equals(item.name, '---')
        assert_none(item.callable)


if __name__ == "__main__":
    unittest.main()
########NEW FILE########
