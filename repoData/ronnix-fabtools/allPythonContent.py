__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# fabtools documentation build configuration file, created by
# sphinx-quickstart on Thu Sep 13 17:22:32 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, re

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.viewcode',
    'sphinx.ext.intersphinx',
]

# Preserve source order in API documentation
autodoc_member_order = 'bysource'

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'fabtools'
copyright = u'2011-2014, Ronan Amicel and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The full version, including alpha/beta/rc tags.
release = re.search("version='([^']+)'",
    open(os.path.join(os.path.dirname(__file__), os.pardir,
         'setup.py')).read().strip()
).group(1)

# The short X.Y version.
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.

# Use the new Read the Docs theme if available
try:
    import sphinx_rtd_theme
    html_theme = 'sphinx_rtd_theme'
    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# Fall back to the default theme
except ImportError:
    html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'fabtoolsdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'fabtools.tex', u'fabtools Documentation',
   u'Ronan Amicel', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'fabtools', u'fabtools Documentation',
     [u'Ronan Amicel'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'fabtools', u'fabtools Documentation',
   u'Ronan Amicel', 'fabtools', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

intersphinx_mapping = {
    'fabric': ('http://fabric.readthedocs.org/en/latest/', None),
    'python': ('http://docs.python.org/2.7', None),
}

########NEW FILE########
__FILENAME__ = apache
"""
Apache
======

This module provides tools for configuring
the `Apache HTTP Server <http://httpd.apache.org/>`_.

"""
from fabtools.files import is_link
from fabtools.utils import run_as_root


def _get_link_filename(config):
    return '/etc/apache2/sites-enabled/%s' % config


def _get_config_name(config):
    if config not in ('default', 'default-ssl'):
        config += '.conf'

    return config


def is_module_enabled(module):
    """
    Check if an Apache module is enabled.
    """
    return is_link('/etc/apache2/mods-enabled/%s.load' % module)


def enable_module(module):
    """
    Enable an Apache module.

    This creates a symbolic link from ``/etc/apache2/mods-available/``
    into ``/etc/apache2/mods-enabled/``.

    This does not cause Apache to reload its configuration.

    ::

        import fabtools

        fabtools.apache.enable_module('rewrite')
        fabtools.service.reload('apache2')

    .. seealso:: :py:func:`fabtools.require.apache.module_enabled`
    """
    if not is_module_enabled(module):
        run_as_root('a2enmod %s' % module)


def disable_module(module):
    """
    Disable an Apache module.

    This deletes the symbolink link in ``/etc/apache2/mods-enabled/``.

    This does not cause Apache to reload its configuration.

    ::

        import fabtools

        fabtools.apache.disable_module('rewrite')
        fabtools.service.reload('apache2')

    .. seealso:: :py:func:`fabtools.require.apache.module_disabled`
    """
    if is_module_enabled(module):
        run_as_root('a2dismod %s' % module)


def is_site_enabled(config):
    """
    Check if an Apache site is enabled.
    """
    config = _get_config_name(config)
    if config == 'default':
        config = '000-default'

    return is_link(_get_link_filename(config))


def enable_site(config):
    """
    Enable an Apache site.

    This creates a symbolic link from ``/etc/apache2/sites-available/``
    into ``/etc/apache2/sites-enabled/``.

    This does not cause Apache to reload its configuration.

    ::

        import fabtools

        fabtools.apache.enable_site('default')
        fabtools.service.reload('apache2')

    .. seealso:: :py:func:`fabtools.require.apache.site_enabled`
    """
    if not is_site_enabled(config):
        run_as_root('a2ensite %s' % _get_config_name(config))


def disable_site(config):
    """
    Disable an Apache site.

    This deletes the symbolink link in ``/etc/apache2/sites-enabled/``.

    This does not cause Apache to reload its configuration.

    ::

        import fabtools

        fabtools.apache.disable_site('default')
        fabtools.service.reload('apache2')

    .. seealso:: :py:func:`fabtools.require.apache.site_disabled`
    """
    if is_site_enabled(config):
        run_as_root('a2dissite %s' % _get_config_name(config))


# backward compatibility (deprecated)
enable = enable_site
disable = disable_site

__all__ = [
    'is_module_enabled', 'enable_module', 'disable_module',
    'is_site_enabled', 'enable_site', 'disable_site',
]

########NEW FILE########
__FILENAME__ = arch
"""
Archlinux packages
==================

This module provides tools to manage Archlinux packages
and repositories.

"""
from __future__ import with_statement

from fabric.api import hide, run, settings

from fabtools.utils import run_as_root


def pkg_manager():
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        output = run('which yaourt', warn_only=True)
        if output.succeeded:
            manager = 'yaourt'
        else:
            manager = 'pacman'

        return 'LC_ALL=C %s' % manager


def update_index(quiet=True):
    """
    Update pacman package definitions.
    """

    manager = pkg_manager()
    if quiet:
        with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
            run_as_root("%(manager)s -Sy" % locals())
    else:
        run_as_root("%(manager)s -Sy" % locals())


def upgrade():
    """
    Upgrade all packages.
    """
    manager = pkg_manager()
    run_as_root("%(manager)s -Su" % locals(), pty=False)


def is_installed(pkg_name):
    """
    Check if an Archlinux package is installed.
    """

    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = run("pacman -Q %(pkg_name)s" % locals())
        return res.succeeded


def install(packages, update=False, options=None):
    """
    Install one or more Archlinux packages.

    If *update* is ``True``, the package definitions will be updated
    first, using :py:func:`~fabtools.arch.update_index`.

    Extra *options* may be passed to ``pacman`` if necessary.

    Example::

        import fabtools

        # Update index, then install a single package
        fabtools.arch.install('mongodb', update=True)

        # Install multiple packages
        fabtools.arch.install([
            'mongodb',
            'python-pymongo',
        ])

    """
    manager = pkg_manager()
    if update:
        update_index()
    if options is None:
        options = []
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options = " ".join(options)
    cmd = '%(manager)s -S %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)


def uninstall(packages, options=None):
    """
    Remove one or more Archlinux packages.

    Extra *options* may be passed to ``pacman`` if necessary.
    """
    manager = pkg_manager()
    if options is None:
        options = []
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options = " ".join(options)
    cmd = '%(manager)s -R %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)

########NEW FILE########
__FILENAME__ = cron
"""
Cron tasks
==========

This module provides tools to manage periodic tasks using cron.

"""
from __future__ import with_statement


def add_task(name, timespec, user, command, environment=None):
    """
    Add a cron task.

    The *command* will be run as *user* periodically.

    You can use any valid `crontab(5)`_ *timespec*, including the
    ``@hourly``, ``@daily``, ``@weekly``, ``@monthly`` and ``@yearly``
    shortcuts.

    You can also provide an optional dictionary of environment variables
    that should be set when running the periodic command.

    Examples::

        from fabtools.cron import add_task

        # Run every month
        add_task('cleanup', '@monthly', 'alice', '/home/alice/bin/cleanup.sh')

        # Run every tuesday and friday at 5:30am
        add_task('reindex', '30 5 * * 2,4', 'bob', '/home/bob/bin/reindex.sh')

    .. _crontab(5): http://manpages.debian.net/cgi-bin/man.cgi?query=crontab&sektion=5

    """
    if environment is None:
        environment = {}

    lines = []

    # Write optional environment variables first
    for key, value in environment.iteritems():
        lines.append('%(key)s=%(value)s\n' % locals())

    # Write the main crontab line
    lines.append('%(timespec)s %(user)s %(command)s\n' % locals())

    from fabtools.require.files import file as require_file
    require_file(
        path='/etc/cron.d/%(name)s' % locals(),
        contents=''.join(lines),
        owner='root',
        mode='0644',
        use_sudo=True,
    )


def add_daily(name, user, command, environment=None):
    """
    Shortcut to add a daily cron task.

    Example::

        import fabtools

        # Run every day
        fabtools.cron.add_daily('backup', 'root', '/usr/local/bin/backup.sh')

    """
    add_task(name, '@daily', user, command, environment)

########NEW FILE########
__FILENAME__ = deb
"""
Debian packages
===============

This module provides tools to manage Debian/Ubuntu packages
and repositories.

"""
from __future__ import with_statement

from fabric.api import hide, run, settings

from fabtools.utils import run_as_root
from fabtools.files import getmtime, is_file


MANAGER = 'DEBIAN_FRONTEND=noninteractive apt-get'


def update_index(quiet=True):
    """
    Update APT package definitions.
    """
    options = "--quiet --quiet" if quiet else ""
    run_as_root("%s %s update" % (MANAGER, options))


def upgrade(safe=True):
    """
    Upgrade all packages.
    """
    manager = MANAGER
    if safe:
        cmd = 'upgrade'
    else:
        cmd = 'dist-upgrade'
    run_as_root("%(manager)s --assume-yes %(cmd)s" % locals(), pty=False)


def is_installed(pkg_name):
    """
    Check if a package is installed.
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = run("dpkg -s %(pkg_name)s" % locals())
        for line in res.splitlines():
            if line.startswith("Status: "):
                status = line[8:]
                if "installed" in status.split(' '):
                    return True
        return False


def install(packages, update=False, options=None, version=None):
    """
    Install one or more packages.

    If *update* is ``True``, the package definitions will be updated
    first, using :py:func:`~fabtools.deb.update_index`.

    Extra *options* may be passed to ``apt-get`` if necessary.

    Example::

        import fabtools

        # Update index, then install a single package
        fabtools.deb.install('build-essential', update=True)

        # Install multiple packages
        fabtools.deb.install([
            'python-dev',
            'libxml2-dev',
        ])

        # Install a specific version
        fabtools.deb.install('emacs', version='23.3+1-1ubuntu9')

    """
    manager = MANAGER
    if update:
        update_index()
    if options is None:
        options = []
    if version is None:
        version = ''
    if version and not isinstance(packages, list):
        version = '=' + version
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options.append("--quiet")
    options.append("--assume-yes")
    options = " ".join(options)
    cmd = '%(manager)s install %(options)s %(packages)s%(version)s' % locals()
    run_as_root(cmd, pty=False)


def uninstall(packages, purge=False, options=None):
    """
    Remove one or more packages.

    If *purge* is ``True``, the package configuration files will be
    removed from the system.

    Extra *options* may be passed to ``apt-get`` if necessary.
    """
    manager = MANAGER
    command = "purge" if purge else "remove"
    if options is None:
        options = []
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options.append("--assume-yes")
    options = " ".join(options)
    cmd = '%(manager)s %(command)s %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)


def preseed_package(pkg_name, preseed):
    """
    Enable unattended package installation by preseeding ``debconf``
    parameters.

    Example::

        import fabtools

        # Unattended install of Postfix mail server
        fabtools.deb.preseed_package('postfix', {
            'postfix/main_mailer_type': ('select', 'Internet Site'),
            'postfix/mailname': ('string', 'example.com'),
            'postfix/destinations': ('string', 'example.com, localhost.localdomain, localhost'),
        })
        fabtools.deb.install('postfix')

    """
    for q_name, _ in preseed.items():
        q_type, q_answer = _
        run_as_root('echo "%(pkg_name)s %(q_name)s %(q_type)s %(q_answer)s" | debconf-set-selections' % locals())


def get_selections():
    """
    Get the state of ``dkpg`` selections.

    Returns a dict with state => [packages].
    """
    with settings(hide('stdout')):
        res = run_as_root('dpkg --get-selections')
    selections = dict()
    for line in res.splitlines():
        package, status = line.split()
        selections.setdefault(status, list()).append(package)
    return selections


def apt_key_exists(keyid):
    """
    Check if the given key id exists in apt keyring.
    """

    # Command extracted from apt-key source
    gpg_cmd = 'gpg --ignore-time-conflict --no-options --no-default-keyring --keyring /etc/apt/trusted.gpg'

    with settings(hide('everything'), warn_only=True):
        res = run('%(gpg_cmd)s --fingerprint %(keyid)s' % locals())

    return res.succeeded


def _check_pgp_key(path, keyid):
    with settings(hide('everything')):
        return not run('gpg --with-colons %(path)s | cut -d: -f 5 | grep -q \'%(keyid)s$\'' % locals())


def add_apt_key(filename=None, url=None, keyid=None, keyserver='subkeys.pgp.net', update=False):
    """
    Trust packages signed with this public key.

    Example::

        import fabtools

        # Varnish signing key from URL and verify fingerprint)
        fabtools.deb.add_apt_key(keyid='C4DEFFEB', url='http://repo.varnish-cache.org/debian/GPG-key.txt')

        # Nginx signing key from default key server (subkeys.pgp.net)
        fabtools.deb.add_apt_key(keyid='7BD9BF62')

        # From custom key server
        fabtools.deb.add_apt_key(keyid='7BD9BF62', keyserver='keyserver.ubuntu.com')

        # From a file
        fabtools.deb.add_apt_key(keyid='7BD9BF62', filename='nginx.asc'
    """

    if keyid is None:
        if filename is not None:
            run_as_root('apt-key add %(filename)s' % locals())
        elif url is not None:
            run_as_root('wget %(url)s -O - | apt-key add -' % locals())
        else:
            raise ValueError('Either filename, url or keyid must be provided as argument')
    else:
        if filename is not None:
            _check_pgp_key(filename, keyid)
            run_as_root('apt-key add %(filename)s' % locals())
        elif url is not None:
            tmp_key = '/tmp/tmp.fabtools.key.%(keyid)s.key' % locals()
            run_as_root('wget %(url)s -O %(tmp_key)s' % locals())
            _check_pgp_key(tmp_key, keyid)
            run_as_root('apt-key add %(tmp_key)s' % locals())
        else:
            keyserver_opt = '--keyserver %(keyserver)s' % locals() if keyserver is not None else ''
            run_as_root('apt-key adv %(keyserver_opt)s --recv-keys %(keyid)s' % locals())

    if update:
        update_index()


def last_update_time():
    """
    Get the time of last APT index update

    This is the last modification time of ``/var/lib/apt/periodic/fabtools-update-success-stamp``.

    Returns ``-1`` if there was no update before.

    Example::

        import fabtools

        print(fabtools.deb.last_update_time())
        # 1377603808.02

    """
    STAMP = '/var/lib/apt/periodic/fabtools-update-success-stamp'
    if not is_file(STAMP):
        return -1
    return getmtime(STAMP)

########NEW FILE########
__FILENAME__ = disk
"""
Disk Tools
==========
"""
from __future__ import with_statement

import re

from fabric.api import hide, settings, abort

from fabtools.utils import run_as_root


def partitions(device=""):
    """
    Get a partition list for all disk or for selected device only

    Example::

        from fabtools.disk import partitions

        spart = {'Linux': 0x83, 'Swap': 0x82}
        parts = partitions()
        # parts =  {'/dev/sda1': 131, '/dev/sda2': 130, '/dev/sda3': 131}
        r = parts['/dev/sda1'] == spart['Linux']
        r = r and parts['/dev/sda2'] == spart['Swap']
        if r:
            print("You can format these partitions")
    """
    partitions_list = {}
    with settings(hide('running', 'stdout')):
        res = run_as_root('sfdisk -d %(device)s' % locals())

        spart = re.compile(r'(?P<pname>^/.*) : .* Id=(?P<ptypeid>[0-9a-z]+)')
        for line in res.splitlines():
            m = spart.search(line)
            if m:
                partitions_list[m.group('pname')] = int(m.group('ptypeid'), 16)

    return partitions_list


def getdevice_by_uuid(uuid):
    """
    Get a HDD device by uuid

    Example::

        from fabtools.disk import getdevice_by_uuid 

        device = getdevice_by_uuid("356fafdc-21d5-408e-a3e9-2b3f32cb2a8c")
        if device:
            mount(device,'/mountpoint')
    """
    with settings(hide('running', 'warnings', 'stdout'), warn_only=True):
        res = run_as_root('blkid -U %s' % uuid)

        if not res.succeeded:
            return None

        return res


def mount(device, mountpoint):
    """
    Mount a partition

    Example::

        from fabtools.disk import mount

        mount('/dev/sdb1', '/mnt/usb_drive')
    """
    if not ismounted(device):
        run_as_root('mount %(device)s %(mountpoint)s' % locals())


def swapon(device):
    """
    Active swap partition

    Example::

        from fabtools.disk import swapon

        swapon('/dev/sda1')
    """
    if not ismounted(device):
        run_as_root('swapon %(device)s' % locals())


def ismounted(device):
    """
    Check if partition is mounted

    Example::

        from fabtools.disk import ismounted

        if ismounted('/dev/sda1'):
           print ("disk sda1 is mounted")
    """
    # Check filesystem
    with settings(hide('running', 'stdout')):
        res = run_as_root('mount')
    for line in res.splitlines():
        fields = line.split()
        if fields[0] == device:
            return True

    # Check swap
    with settings(hide('running', 'stdout')):
        res = run_as_root('swapon -s')
    for line in res.splitlines():
        fields = line.split()
        if fields[0] == device:
            return True

    return False


def mkfs(device, ftype):
    """
    Format filesystem

    Example::

        from fabtools.disk import mkfs

        mkfs('/dev/sda2', 'ext4')
    """
    if not ismounted('%(device)s' % locals()):
        run_as_root('mkfs.%(ftype)s %(device)s' % locals())
    else:
        abort("Partition is mounted")


def mkswap(device):
    """
    Format swap partition

    Example::

        from fabtools.disk import mkswap

        mkswap('/dev/sda2')
    """
    if not ismounted(device):
        run_as_root('mkswap %(device)s' % locals())
    else:
        abort("swap partition is mounted")

########NEW FILE########
__FILENAME__ = files
"""
Files and directories
=====================
"""
from __future__ import with_statement

from pipes import quote
import os

from fabric.api import (
    abort,
    env,
    hide,
    run,
    settings,
    sudo,
    warn,
)
from fabric.contrib.files import upload_template as _upload_template
from fabric.contrib.files import exists

from fabtools.utils import run_as_root


def is_file(path, use_sudo=False):
    """
    Check if a path exists, and is a file.
    """
    func = use_sudo and run_as_root or run
    with settings(hide('running', 'warnings'), warn_only=True):
        return func('[ -f "%(path)s" ]' % locals()).succeeded


def is_dir(path, use_sudo=False):
    """
    Check if a path exists, and is a directory.
    """
    func = use_sudo and run_as_root or run
    with settings(hide('running', 'warnings'), warn_only=True):
        return func('[ -d "%(path)s" ]' % locals()).succeeded


def is_link(path, use_sudo=False):
    """
    Check if a path exists, and is a symbolic link.
    """
    func = use_sudo and run_as_root or run
    with settings(hide('running', 'warnings'), warn_only=True):
        return func('[ -L "%(path)s" ]' % locals()).succeeded


def owner(path, use_sudo=False):
    """
    Get the owner name of a file or directory.
    """
    func = use_sudo and run_as_root or run
    # I'd prefer to use quiet=True, but that's not supported with older
    # versions of Fabric.
    with settings(hide('running', 'stdout'), warn_only=True):
        result = func('stat -c %%U "%(path)s"' % locals())
        if result.failed and 'stat: illegal option' in result:
            # Try the BSD version of stat
            return func('stat -f %%Su "%(path)s"' % locals())
        else:
            return result


def group(path, use_sudo=False):
    """
    Get the group name of a file or directory.
    """
    func = use_sudo and run_as_root or run
    # I'd prefer to use quiet=True, but that's not supported with older
    # versions of Fabric.
    with settings(hide('running', 'stdout'), warn_only=True):
        result = func('stat -c %%G "%(path)s"' % locals())
        if result.failed and 'stat: illegal option' in result:
            # Try the BSD version of stat
            return func('stat -f %%Sg "%(path)s"' % locals())
        else:
            return result


def mode(path, use_sudo=False):
    """
    Get the mode (permissions) of a file or directory.

    Returns a string such as ``'0755'``, representing permissions as
    an octal number.
    """
    func = use_sudo and run_as_root or run
    # I'd prefer to use quiet=True, but that's not supported with older
    # versions of Fabric.
    with settings(hide('running', 'stdout'), warn_only=True):
        result = func('stat -c %%a "%(path)s"' % locals())
        if result.failed and 'stat: illegal option' in result:
            # Try the BSD version of stat
            return func('stat -f %%Op "%(path)s"|cut -c 4-6' % locals())
        else:
            return result


def umask(use_sudo=False):
    """
    Get the user's umask.

    Returns a string such as ``'0002'``, representing the user's umask
    as an octal number.

    If `use_sudo` is `True`, this function returns root's umask.
    """
    func = use_sudo and run_as_root or run
    return func('umask')


def upload_template(filename, destination, context=None, use_jinja=False,
                    template_dir=None, use_sudo=False, backup=True,
                    mirror_local_mode=False, mode=None,
                    mkdir=False, chown=False, user=None):
    """
    Upload a template file.

    This is a wrapper around :func:`fabric.contrib.files.upload_template`
    that adds some extra parameters.

    If ``mkdir`` is True, then the remote directory will be created, as
    the current user or as ``user`` if specified.

    If ``chown`` is True, then it will ensure that the current user (or
    ``user`` if specified) is the owner of the remote file.
    """

    if mkdir:
        remote_dir = os.path.dirname(destination)
        if use_sudo:
            sudo('mkdir -p %s' % quote(remote_dir), user=user)
        else:
            run('mkdir -p %s' % quote(remote_dir))

    _upload_template(
        filename=filename,
        destination=destination,
        context=context,
        use_jinja=use_jinja,
        template_dir=template_dir,
        use_sudo=use_sudo,
        backup=backup,
        mirror_local_mode=mirror_local_mode,
        mode=mode,
    )

    if chown:
        if user is None:
            user = env.user
        run_as_root('chown %s: %s' % (user, quote(destination)))


def md5sum(filename, use_sudo=False):
    """
    Compute the MD5 sum of a file.
    """
    func = use_sudo and run_as_root or run
    with settings(hide('running', 'stdout', 'stderr', 'warnings'),
                  warn_only=True):
        # Linux (LSB)
        if exists(u'/usr/bin/md5sum'):
            res = func(u'/usr/bin/md5sum %(filename)s' % locals())
        # BSD / OS X
        elif exists(u'/sbin/md5'):
            res = func(u'/sbin/md5 -r %(filename)s' % locals())
        # SmartOS Joyent build
        elif exists(u'/opt/local/gnu/bin/md5sum'):
            res = func(u'/opt/local/gnu/bin/md5sum %(filename)s' % locals())
        # SmartOS Joyent build
        # (the former doesn't exist, at least on joyent_20130222T000747Z)
        elif exists(u'/opt/local/bin/md5sum'):
            res = func(u'/opt/local/bin/md5sum %(filename)s' % locals())
        # Try to find ``md5sum`` or ``md5`` on ``$PATH`` or abort
        else:
            md5sum = func(u'which md5sum')
            md5 = func(u'which md5')
            if exists(md5sum):
                res = func('%(md5sum)s %(filename)s' % locals())
            elif exists(md5):
                res = func('%(md5)s %(filename)s' % locals())
            else:
                abort('No MD5 utility was found on this system.')

    if res.succeeded:
        parts = res.split()
        _md5sum = len(parts) > 0 and parts[0] or None
    else:
        warn(res)
        _md5sum = None

    return _md5sum


class watch(object):
    """
    Context manager to watch for changes to the contents of some files.

    The *filenames* argument can be either a string (single filename)
    or a list (multiple filenames).

    You can read the *changed* attribute at the end of the block to
    check if the contents of any of the watched files has changed.

    You can also provide a *callback* that will be called at the end of
    the block if the contents of any of the watched files has changed.

    Example using an explicit check::

        from fabric.contrib.files import comment, uncomment

        from fabtools.files import watch
        from fabtools.services import restart

        # Edit configuration file
        with watch('/etc/daemon.conf') as config:
            uncomment('/etc/daemon.conf', 'someoption')
            comment('/etc/daemon.conf', 'otheroption')

        # Restart daemon if needed
        if config.changed:
            restart('daemon')

    Same example using a callback::

        from functools import partial

        from fabric.contrib.files import comment, uncomment

        from fabtools.files import watch
        from fabtools.services import restart

        with watch('/etc/daemon.conf', callback=partial(restart, 'daemon')):
            uncomment('/etc/daemon.conf', 'someoption')
            comment('/etc/daemon.conf', 'otheroption')

    """

    def __init__(self, filenames, callback=None, use_sudo=False):
        if isinstance(filenames, basestring):
            self.filenames = [filenames]
        else:
            self.filenames = filenames
        self.callback = callback
        self.use_sudo = use_sudo
        self.digest = dict()
        self.changed = False

    def __enter__(self):
        with settings(hide('warnings')):
            for filename in self.filenames:
                self.digest[filename] = md5sum(filename, self.use_sudo)
        return self

    def __exit__(self, type, value, tb):
        for filename in self.filenames:
            if md5sum(filename, self.use_sudo) != self.digest[filename]:
                self.changed = True
                break
        if self.changed and self.callback:
            self.callback()


def uncommented_lines(filename, use_sudo=False):
    """
    Get the lines of a remote file, ignoring empty or commented ones
    """
    func = run_as_root if use_sudo else run
    res = func('cat %s' % quote(filename), quiet=True)
    if res.succeeded:
        return [line for line in res.splitlines()
                if line and not line.startswith('#')]
    else:
        return []


def getmtime(path, use_sudo=False):
    """
    Return the time of last modification of path.
    The return value is a number giving the number of seconds since the epoch

    Same as :py:func:`os.path.getmtime()`
    """
    func = use_sudo and run_as_root or run
    with settings(hide('running', 'stdout')):
        return int(func('stat -c %%Y "%(path)s" ' % locals()).strip())


def copy(source, destination, recursive=False, use_sudo=False):
    """
    Copy a file or directory
    """
    func = use_sudo and run_as_root or run
    options = '-r' if recursive else ''
    func('/bin/cp {} {} {}'.format(options, quote(source), quote(destination)))


def move(source, destination, use_sudo=False):
    """
    Move a file or directory
    """
    func = use_sudo and run_as_root or run
    func('/bin/mv {} {}'.format(quote(source), quote(destination)))


def symlink(source, destination, use_sudo=False):
    """
    Create a symbolic link to a file or directory
    """
    func = use_sudo and run_as_root or run
    func('/bin/ln -s {} {}'.format(quote(source), quote(destination)))


def remove(path, recursive=False, use_sudo=False):
    """
    Remove a file or directory
    """
    func = use_sudo and run_as_root or run
    options = '-r' if recursive else ''
    func('/bin/rm {} {}'.format(options, quote(path)))

########NEW FILE########
__FILENAME__ = git
"""
Git
===

This module provides low-level tools for managing `Git`_ repositories.  You
should normally not use them directly but rather use the high-level wrapper
:func:`fabtools.require.git.working_copy` instead.

.. _Git: http://git-scm.com/

"""

from __future__ import with_statement

from fabric.api import run
from fabric.api import sudo
from fabric.context_managers import cd

from fabtools.utils import run_as_root


def clone(remote_url, path=None, use_sudo=False, user=None):
    """
    Clone a remote Git repository into a new directory.

    :param remote_url: URL of the remote repository to clone.
    :type remote_url: str

    :param path: Path of the working copy directory.  Must not exist yet.
    :type path: str

    :param use_sudo: If ``True`` execute ``git`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    """

    cmd = 'git clone --quiet %s' % remote_url
    if path is not None:
        cmd = cmd + ' %s' % path

    if use_sudo and user is None:
        run_as_root(cmd)
    elif use_sudo:
        sudo(cmd, user=user)
    else:
        run(cmd)


def add_remote(path, name, remote_url, use_sudo=False, user=None, fetch=True):
    """
    Add a remote Git repository into a directory.

    :param path: Path of the working copy directory.  This directory must exist
                 and be a Git working copy with a default remote to fetch from.
    :type path: str

    :param use_sudo: If ``True`` execute ``git`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str

    :param name: name for the remote repository
    :type name: str

    :param remote_url: URL of the remote repository
    :type remote_url: str

    :param fetch: If ``True`` execute ``git remote add -f``
    :type fetch: bool
    """
    if path is None:
        raise ValueError("Path to the working copy is needed to add a remote")

    if fetch:
        cmd = 'git remote add -f %s %s' % (name, remote_url)
    else:
        cmd = 'git remote add %s %s' % (name, remote_url)

    with cd(path):
        if use_sudo and user is None:
            run_as_root(cmd)
        elif use_sudo:
            sudo(cmd, user=user)
        else:
            run(cmd)


def fetch(path, use_sudo=False, user=None, remote=None):
    """
    Fetch changes from the default remote repository.

    This will fetch new changesets, but will not update the contents of
    the working tree unless yo do a merge or rebase.

    :param path: Path of the working copy directory.  This directory must exist
                 and be a Git working copy with a default remote to fetch from.
    :type path: str

    :param use_sudo: If ``True`` execute ``git`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str

    :type remote: Fetch this remote or default remote if is None
    :type remote: str
    """

    if path is None:
        raise ValueError("Path to the working copy is needed to fetch from a "
                         "remote repository.")

    if remote is not None:
        cmd = 'git fetch %s' % remote
    else:
        cmd = 'git fetch'

    with cd(path):
        if use_sudo and user is None:
            run_as_root(cmd)
        elif use_sudo:
            sudo(cmd, user=user)
        else:
            run(cmd)


def pull(path, use_sudo=False, user=None, force=False):
    """
    Fetch changes from the default remote repository and merge them.

    :param path: Path of the working copy directory.  This directory must exist
                 and be a Git working copy with a default remote to pull from.
    :type path: str

    :param use_sudo: If ``True`` execute ``git`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    :param force: If ``True``, append the ``--force`` option to the command.
    :type force: bool
    """

    if path is None:
        raise ValueError("Path to the working copy is needed to pull from a "
                         "remote repository.")

    options = []
    if force:
        options.append('--force')
    options = ' '.join(options)

    cmd = 'git pull %s' % options

    with cd(path):
        if use_sudo and user is None:
            run_as_root(cmd)
        elif use_sudo:
            sudo(cmd, user=user)
        else:
            run(cmd)


def checkout(path, branch="master", use_sudo=False, user=None, force=False):
    """
    Checkout a branch to the working directory.

    :param path: Path of the working copy directory.  This directory must exist
                 and be a Git working copy.
    :type path: str

    :param branch: Name of the branch to checkout.
    :type branch: str

    :param use_sudo: If ``True`` execute ``git`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    :param force: If ``True``, append the ``--force`` option to the command.
    :type force: bool
    """

    if path is None:
        raise ValueError("Path to the working copy is needed to checkout a "
                         "branch")

    options = []
    if force:
        options.append('--force')
    options = ' '.join(options)

    cmd = 'git checkout %s %s' % (branch, options)

    with cd(path):
        if use_sudo and user is None:
            run_as_root(cmd)
        elif use_sudo:
            sudo(cmd, user=user)
        else:
            run(cmd)

########NEW FILE########
__FILENAME__ = group
"""
Groups
======
"""
from __future__ import with_statement

from fabric.api import hide, run, settings

from fabtools.utils import run_as_root


def exists(name):
    """
    Check if a group exists.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        return run('getent group %(name)s' % locals()).succeeded


def create(name, gid=None):
    """
    Create a new group.

    Example::

        import fabtools

        if not fabtools.group.exists('admin'):
            fabtools.group.create('admin')

    """

    args = []
    if gid:
        args.append('-g %s' % gid)
    args.append(name)
    args = ' '.join(args)
    run_as_root('groupadd %s' % args)

########NEW FILE########
__FILENAME__ = gvm
"""
GVM
===========

This module provides tools for installing `GVM`_ : the Groovy enVironment Manager

.. _GVM: http://gvmtool.net/

"""

from fabric.api import run
from fabric.contrib.files import sed

from fabtools.require.deb import packages as require_deb_packages
from fabtools.require.oracle_jdk import installed as java
from fabtools.require.pkg import packages as require_pkg_packages
from fabtools.require.rpm import packages as require_rpm_packages
from fabtools.system import UnsupportedFamily, distrib_family


def install(java_version=None):
    """
    Install dependencies (curl and unzip) and Install GVM

    ::

        import fabtools

        # Install GVM
        fabtools.gvm.install()

    """
    res = run('gvm help', quiet=True)
    if res.failed:
        family = distrib_family()
        packages = ['curl', 'unzip']
        if family == 'debian':
            require_deb_packages(packages)
        elif family == 'redhat':
            require_rpm_packages(packages)
        elif family == 'sun':
            require_pkg_packages(packages)
        else:
            raise UnsupportedFamily(supported=['debian', 'redhat', 'sun'])

        if java_version is None:
            java()
        else:
            java(version=java_version)

        run('curl -s get.gvmtool.net | bash')
        user = run('whoami')
        run('source "/home/%s/.gvm/bin/gvm-init.sh"' % user)
        configFile = "/home/%s/.gvm/etc/config" % user
        sed(configFile, 'gvm_auto_answer=false', 'gvm_auto_answer=true')


def install_candidate(candidate, version=None, java_version=None):
    """
    Install a candidate

    ::

        import fabtools

        # Install a GVM candidate (For example Groovy)
        fabtools.gvm.install_candidate('groovy')

    """
    install(java_version)

    if version is None:
        cmd = 'gvm install %s' % candidate
    else:
        cmd = 'gvm install %s %s' % (candidate, version)

    run(cmd)

########NEW FILE########
__FILENAME__ = mercurial
"""
Mercurial
=========

This module provides low-level tools for managing `Mercurial`_ repositories.
You should normally not use them directly but rather use the high-level wrapper
:func:`fabtools.require.mercurial.working_copy` instead.

.. _Mercurial: http://mercurial.selenic.com/

"""

from __future__ import with_statement

from fabric.api import run
from fabric.api import sudo
from fabric.context_managers import cd

from fabtools.utils import run_as_root


def clone(remote_url, path=None, use_sudo=False, user=None):
    """
    Clone a remote Mercurial repository into a new directory.

    :param remote_url: URL of the remote repository to clone.
    :type remote_url: str

    :param path: Path of the working copy directory.  Must not exist yet.
    :type path: str

    :param use_sudo: If ``True`` execute ``hg`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    """

    cmd = 'hg --quiet clone %s' % remote_url
    if path is not None:
        cmd = cmd + ' %s' % path

    if use_sudo and user is None:
        run_as_root(cmd)
    elif use_sudo:
        sudo(cmd, user=user)
    else:
        run(cmd)


def update(path, branch="default", use_sudo=False, user=None, force=False):
    """
    Merge changes to a working copy and/or switch branches.

    :param path: Path of the working copy directory.  This directory must exist
                 and be a Mercurial working copy.
    :type path: str

    :param use_sudo: If ``True`` execute ``hg`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str

    """
    cmd = "hg up %s" % branch

    with cd(path):
        if use_sudo and user is None:
            run_as_root(cmd)
        elif use_sudo:
            sudo(cmd, user=user)
        else:
            run(cmd)


def pull(path, use_sudo=False, user=None):
    """
    Pull changes from the default remote repository.

    :param path: Path of the working copy directory.  This directory must exist
                 and be a Mercurial working copy with a default remote to pull
                 from.
    :type path: str

    :param use_sudo: If ``True`` execute ``hg`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    """

    if not path:
        raise ValueError("Path to the working copy is needed to pull from a "
                         "remote repository.")

    cmd = 'hg pull'

    with cd(path):
        if use_sudo and user is None:
            run_as_root(cmd)
        elif use_sudo:
            sudo(cmd, user=user)
        else:
            run(cmd)

########NEW FILE########
__FILENAME__ = mysql
"""
MySQL users and databases
=========================

This module provides tools for creating MySQL users and databases.

"""
from __future__ import with_statement

from pipes import quote

from fabric.api import env, hide, puts, run, settings

from fabtools.utils import run_as_root


def query(query, use_sudo=True, **kwargs):
    """
    Run a MySQL query.
    """
    func = use_sudo and run_as_root or run

    user = kwargs.get('mysql_user') or env.get('mysql_user')
    password = kwargs.get('mysql_password') or env.get('mysql_password')

    options = [
        '--batch',
        '--raw',
        '--skip-column-names',
    ]
    if user:
        options.append('--user=%s' % quote(user))
    if password:
        options.append('--password=%s' % quote(password))
    options = ' '.join(options)

    return func('mysql %(options)s --execute=%(query)s' % {
        'options': options,
        'query': quote(query),
    })


def user_exists(name, host='localhost', **kwargs):
    """
    Check if a MySQL user exists.
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = query("""
            use mysql;
            SELECT COUNT(*) FROM user
                WHERE User = '%(name)s' AND Host = '%(host)s';
            """ % {
                'name': name,
                'host': host,
            }, **kwargs)
    return res.succeeded and (int(res) == 1)


def create_user(name, password, host='localhost', **kwargs):
    """
    Create a MySQL user.

    Example::

        import fabtools

        # Create DB user if it does not exist
        if not fabtools.mysql.user_exists('dbuser'):
            fabtools.mysql.create_user('dbuser', password='somerandomstring')

    """
    with settings(hide('running')):
        query("CREATE USER '%(name)s'@'%(host)s' IDENTIFIED BY '%(password)s';" % {
            'name': name,
            'password': password,
            'host': host
        }, **kwargs)
    puts("Created MySQL user '%s'." % name)


def database_exists(name, **kwargs):
    """
    Check if a MySQL database exists.
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = query("SHOW DATABASES LIKE '%(name)s';" % {
            'name': name
        }, **kwargs)

    return res.succeeded and (res == name)


def create_database(name, owner=None, owner_host='localhost', charset='utf8',
                    collate='utf8_general_ci', **kwargs):
    """
    Create a MySQL database.

    Example::

        import fabtools

        # Create DB if it does not exist
        if not fabtools.mysql.database_exists('myapp'):
            fabtools.mysql.create_database('myapp', owner='dbuser')

    """
    with settings(hide('running')):

        query("CREATE DATABASE %(name)s CHARACTER SET %(charset)s COLLATE %(collate)s;" % {
            'name': name,
            'charset': charset,
            'collate': collate
        }, **kwargs)

        if owner:
            query("GRANT ALL PRIVILEGES ON %(name)s.* TO '%(owner)s'@'%(owner_host)s' WITH GRANT OPTION;" % {
                'name': name,
                'owner': owner,
                'owner_host': owner_host
            }, **kwargs)

    puts("Created MySQL database '%s'." % name)

########NEW FILE########
__FILENAME__ = network
"""
Network
=======
"""
from __future__ import with_statement

from fabric.api import hide, run, settings, sudo
from fabtools.files import is_file


def interfaces():
    """
    Get the list of network interfaces. Will return all datalinks on SmartOS.
    """
    with settings(hide('running', 'stdout')):
        if is_file('/usr/sbin/dladm'):
            res = run('/usr/sbin/dladm show-link')
        else:
            res = sudo('/sbin/ifconfig -s')
    return map(lambda line: line.split(' ')[0], res.splitlines()[1:])


def address(interface):
    """
    Get the IPv4 address assigned to an interface.

    Example::

        import fabtools

        # Print all configured IP addresses
        for interface in fabtools.network.interfaces():
            print(fabtools.network.address(interface))

    """
    with settings(hide('running', 'stdout')):
        res = sudo("/sbin/ifconfig %(interface)s | grep 'inet '" % locals())
    if 'addr' in res:
        return res.split()[1].split(':')[1]
    else:
        return res.split()[1]


def nameservers():
    """
    Get the list of nameserver addresses.

    Example::

        import fabtools

        # Check that all name servers are reachable
        for ip in fabtools.network.nameservers():
            run('ping -c1 %s' % ip)

    """
    with settings(hide('running', 'stdout')):
        res = run(r"cat /etc/resolv.conf | grep 'nameserver' | cut -d\  -f2")
    return res.splitlines()

########NEW FILE########
__FILENAME__ = nginx
"""
Nginx
=====

This module provides tools for managing the Nginx web server.

"""
from pipes import quote

from fabtools.files import is_link
from fabtools.utils import run_as_root


def enable(config):
    """
    Create link from /etc/nginx/sites-available/ in /etc/nginx/sites-enabled/

    (does not reload nginx config)

    ::
        from fabtools import require

        require.nginx.enable('default')

    .. seealso:: :py:func:`fabtools.require.nginx.enabled`
    """
    config_filename = '/etc/nginx/sites-available/%s' % config
    link_filename = '/etc/nginx/sites-enabled/%s' % config

    if not is_link(link_filename):
        run_as_root("ln -s %(config_filename)s %(link_filename)s" % {
            'config_filename': quote(config_filename),
            'link_filename': quote(link_filename),
        })


def disable(config):
    """
    Delete link in /etc/nginx/sites-enabled/

    (does not reload nginx config)

    ::
        from fabtools import require

        require.nginx.disable('default')

    .. seealso:: :py:func:`fabtools.require.nginx.disabled`
    """
    link_filename = '/etc/nginx/sites-enabled/%s' % config

    if is_link(link_filename):
        run_as_root("rm %(link_filename)s" % locals())

########NEW FILE########
__FILENAME__ = nodejs
"""
Node.js
=======

This module provides tools for installing `Node.js`_ and managing
packages using `npm`_.

.. note: the ``simplejson`` module is required on Python 2.5

.. _Node.js: http://nodejs.org/
.. _npm: http://npmjs.org/

"""
from __future__ import with_statement

try:
    import json
except ImportError:
    import simplejson as json

from fabric.api import cd, hide, run, settings

from fabtools.system import cpus, distrib_family
from fabtools.utils import run_as_root


DEFAULT_VERSION = '0.10.13'


def install_from_source(version=DEFAULT_VERSION):
    """
    Install Node JS from source.

    ::

        import fabtools

        # Install Node.js
        fabtools.nodejs.install_nodejs()

    .. note:: This function may not work for old versions of Node.js.

    """

    from fabtools.require.deb import packages as require_deb_packages
    from fabtools.require.rpm import packages as require_rpm_packages
    from fabtools.require import file as require_file

    family = distrib_family()

    if family == 'debian':
        require_deb_packages([
            'build-essential',
            'libssl-dev',
            'python',
        ])

    elif family == 'redhat':
        require_rpm_packages([
            'gcc',
            'gcc-c++',
            'make',
            'openssl-devel',
            'python',
        ])

    filename = 'node-v%s.tar.gz' % version
    foldername = filename[0:-7]

    require_file(url='http://nodejs.org/dist/v%(version)s/%(filename)s' % {
        'version': version,
        'filename': filename,
    })
    run('tar -xzf %s' % filename)
    with cd(foldername):
        run('./configure')
        run('make -j%d' % (cpus() + 1))
        run_as_root('make install')
    run('rm -rf %(filename)s %(foldername)s' % locals())


def version(node='node'):
    """
    Get the version of Node.js currently installed.

    Returns ``None`` if it is not installed.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        res = run('%(node)s --version' % locals())
    if res.failed:
        return None
    else:
        return res[1:]


def install_package(package, version=None, local=False, npm='npm'):
    """
    Install a Node.js package.

    If *local* is ``True``, the package will be installed locally.

    ::

        import fabtools

        # Install package globally
        fabtools.nodejs.install_package('express')

        # Install package locally
        fabtools.nodejs.install_package('underscore', local=False)

    """
    if version:
        package += '@%s' % version

    if local:
        run('%(npm)s install -l %(package)s' % locals())
    else:
        run_as_root('HOME=/root %(npm)s install -g %(package)s' % locals())


def install_dependencies(npm='npm'):
    """
    Install Node.js package dependencies.

    This function calls ``npm install``, which will locally install all
    packages specified as dependencies in the ``package.json`` file
    found in the current directory.

    ::

        from fabric.api import cd
        from fabtools import nodejs

        with cd('/path/to/nodejsapp/'):
            nodejs.install_dependencies()

    """
    run('%(npm)s install' % locals())


def package_version(package, local=False, npm='npm'):
    """
    Get the installed version of a Node.js package.

    Returns ``None``is the package is not installed. If *local* is
    ``True``, returns the version of the locally installed package.
    """
    options = ['--json true', '--silent']
    if local:
        options.append('-l')
    else:
        options.append('-g')
    options = ' '.join(options)

    with hide('running', 'stdout'):
        res = run('%(npm)s list %(options)s' % locals())

    dependencies = json.loads(res)['dependencies']
    pkg_data = dependencies.get(package)
    if pkg_data:
        return pkg_data['version']
    else:
        return None


def update_package(package, local=False, npm='npm'):
    """
    Update a Node.js package.

    If *local* is ``True``, the package will be updated locally.
    """
    if local:
        run('%(npm)s update -l %(package)s' % locals())
    else:
        run_as_root('HOME=/root %(npm)s update -g %(package)s' % locals())


def uninstall_package(package, version=None, local=False, npm='npm'):
    """
    Uninstall a Node.js package.

    If *local* is ``True``, the package will be uninstalled locally.

    ::

        import fabtools

        # Uninstall package globally
        fabtools.nodejs.uninstall_package('express')

        # Uninstall package locally
        fabtools.nodejs.uninstall_package('underscore', local=False)

    """
    if version:
        package += '@%s' % version

    if local:
        run('%(npm)s uninstall -l %(package)s' % locals())
    else:
        run_as_root('HOME=/root %(npm)s uninstall -g %(package)s' % locals())

########NEW FILE########
__FILENAME__ = container
"""
OpenVZ containers
=================
"""
from fabtools import openvz as vz


class Container(object):
    """
    Object-oriented interface to OpenVZ containers.
    """

    def __init__(self, ctid):
        self.ctid = ctid

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        return None

    def create(self, **kwargs):
        """
        Create the container.

        Extra args are passed to :py:func:`fabtools.openvz.create`.
        """
        return vz.create(self.ctid, **kwargs)

    def destroy(self):
        """
        Destroy the container.
        """
        return vz.destroy(self.ctid)

    def set(self, **kwargs):
        """
        Set container parameters.

        Extra args are passed to :py:func:`fabtools.openvz.set`.
        """
        return vz.set(self.ctid, **kwargs)

    def start(self, **kwargs):
        """
        Start the container.

        Extra args are passed to :py:func:`fabtools.openvz.start`.
        """
        return vz.start(self.ctid, **kwargs)

    def stop(self, **kwargs):
        """
        Stop the container.

        Extra args are passed to :py:func:`fabtools.openvz.stop`.
        """
        return vz.stop(self.ctid, **kwargs)

    def restart(self, **kwargs):
        """
        Restart the container.

        Extra args are passed to :py:func:`fabtools.openvz.restart`.
        """
        return vz.restart(self.ctid, **kwargs)

    def status(self):
        """
        Get the container's status.
        """
        return vz.status(self.ctid)

    def running(self):
        """
        Check if the container is running.
        """
        return vz.running(self.ctid)

    def exists(self):
        """
        Check if the container exists.
        """
        return vz.exists(self.ctid)

    def exec2(self, command):
        """
        Run a command inside the container.

        ::

            from fabtools.require.openvz import container

            with container('foo') as ct:
                res = ct.exec2('hostname')

        .. warning:: the command will be run as **root**.

        """
        return vz.exec2(self.ctid, command)

########NEW FILE########
__FILENAME__ = contextmanager
"""
OpenVZ containers
=================
"""
from __future__ import with_statement

from contextlib import contextmanager
import hashlib
import os
import posixpath
import tempfile

from fabric.api import (
    env,
    hide,
    output,
    settings,
    sudo,
)
from fabric.operations import (
    _AttributeString,
    _execute,
    _prefix_commands,
    _prefix_env_vars,
    _shell_wrap,
    _sudo_prefix,
)
from fabric.state import default_channel
from fabric.utils import error
import fabric.operations
import fabric.sftp

from fabric.context_managers import (
    quiet as quiet_manager,
    warn_only as warn_only_manager,
)


@contextmanager
def guest(name_or_ctid):
    """
    Context manager to run commands inside a guest container.

    Supported basic operations are: `run`_, `sudo`_ and `put`_.

    .. warning:: commands executed with ``run()`` will be run as
                 **root** inside the container.
                 Use ``sudo(command, user='foo')`` to run them as
                 an unpriviledged user.

    Example::

        from fabtools.openvz import guest

        with guest('foo'):
            run('hostname')
            sudo('whoami', user='alice')
            put('files/hello.txt')

    .. _run: http://docs.fabfile.org/en/1.4.3/api/core/operations.html#fabric.operations.run
    .. _sudo: http://docs.fabfile.org/en/1.4.3/api/core/operations.html#fabric.operations.sudo
    .. _put: http://docs.fabfile.org/en/1.4.3/api/core/operations.html#fabric.operations.put
    """

    # Monkey patch fabric operations
    _orig_run_command = fabric.operations._run_command
    _orig_put = fabric.sftp.SFTP.put

    def run_guest_command(command, shell=True, pty=True, combine_stderr=True,
        sudo=False, user=None, quiet=False, warn_only=False, stdout=None,
        stderr=None, group=None, timeout=None):
        """
        Run command inside a guest container
        """

        # Use a non-login shell
        _orig_shell = env.shell
        env.shell = '/bin/bash -c'

        # Use double quotes for the sudo prompt
        _orig_sudo_prefix = env.sudo_prefix
        env.sudo_prefix = 'sudo -S -p "%(sudo_prompt)s" '

        # Try to cd to the user's home directory for consistency,
        # as the default directory is "/" with "vzctl exec2"
        if not env.cwd:
            env.command_prefixes.insert(0, 'cd 2>/dev/null || true')

        # Build the guest command
        guest_command = _shell_wrap_inner(
            _prefix_commands(_prefix_env_vars(command), 'remote'),
            True,
            _sudo_prefix(user) if sudo and user else None
        )
        host_command = "vzctl exec2 %s '%s'" % (name_or_ctid, guest_command)

        # Restore env
        env.shell = _orig_shell
        env.sudo_prefix = _orig_sudo_prefix
        if not env.cwd:
            env.command_prefixes.pop(0)

        # Run host command as root
        return _run_host_command(host_command, shell=shell, pty=pty,
                                 combine_stderr=combine_stderr)

    def put_guest(self, local_path, remote_path, use_sudo, mirror_local_mode,
                  mode, local_is_path):
        """
        Upload file to a guest container
        """
        pre = self.ftp.getcwd()
        pre = pre if pre else ''
        if local_is_path and self.isdir(remote_path):
            basename = os.path.basename(local_path)
            remote_path = posixpath.join(remote_path, basename)
        if output.running:
            print("[%s] put: %s -> %s" % (
                env.host_string,
                local_path if local_is_path else '<file obj>',
                posixpath.join(pre, remote_path)
            ))

        # Have to bounce off FS if doing file-like objects
        fd, real_local_path = None, local_path
        if not local_is_path:
            fd, real_local_path = tempfile.mkstemp()
            old_pointer = local_path.tell()
            local_path.seek(0)
            file_obj = os.fdopen(fd, 'wb')
            file_obj.write(local_path.read())
            file_obj.close()
            local_path.seek(old_pointer)

        # Use temporary file with a unique name on the host machine
        guest_path = remote_path
        hasher = hashlib.sha1()
        hasher.update(env.host_string)
        hasher.update(name_or_ctid)
        hasher.update(guest_path)
        host_path = hasher.hexdigest()

        # Upload the file to host machine
        rattrs = self.ftp.put(real_local_path, host_path)

        # Copy file to the guest container
        with settings(hide('everything'), cwd=""):
            cmd = "cat \"%s\" | vzctl exec \"%s\" 'cat - > \"%s\"'" \
                % (host_path, name_or_ctid, guest_path)
            _orig_run_command(cmd, sudo=True)

        # Revert to original remote_path for return value's sake
        remote_path = guest_path

        # Clean up
        if not local_is_path:
            os.remove(real_local_path)

        # Handle modes if necessary
        if (local_is_path and mirror_local_mode) or (mode is not None):
            lmode = os.stat(local_path).st_mode if mirror_local_mode else mode
            lmode = lmode & 07777
            rmode = rattrs.st_mode & 07777
            if lmode != rmode:
                with hide('everything'):
                    sudo('chmod %o \"%s\"' % (lmode, remote_path))

        return remote_path

    fabric.operations._run_command = run_guest_command
    fabric.sftp.SFTP.put = put_guest

    yield

    # Monkey unpatch
    fabric.operations._run_command = _orig_run_command
    fabric.sftp.SFTP.put = _orig_put


@contextmanager
def _noop():
    yield


def _run_host_command(command, shell=True, pty=True, combine_stderr=True,
    quiet=False, warn_only=False, stdout=None, stderr=None, timeout=None):
    """
    Run host wrapper command as root

    (Modified from fabric.operations._run_command to ignore prefixes,
    path(), cd(), and always use sudo.)
    """
    manager = _noop
    if warn_only:
        manager = warn_only_manager
    # Quiet's behavior is a superset of warn_only's, so it wins.
    if quiet:
        manager = quiet_manager
    with manager():
        # Set up new var so original argument can be displayed verbatim later.
        given_command = command
        # Handle context manager modifications, and shell wrapping
        wrapped_command = _shell_wrap(
            command,    # !! removed _prefix_commands() & _prefix_env_vars()
            shell,
            _sudo_prefix(None)  # !! always use sudo
        )
        # Execute info line
        which = 'sudo'          # !! always use sudo
        if output.debug:
            print("[%s] %s: %s" % (env.host_string, which, wrapped_command))
        elif output.running:
            print("[%s] %s: %s" % (env.host_string, which, given_command))

        # Actual execution, stdin/stdout/stderr handling, and termination
        result_stdout, result_stderr, status = _execute(
            channel=default_channel(), command=wrapped_command, pty=pty,
            combine_stderr=combine_stderr, invoke_shell=False, stdout=stdout,
            stderr=stderr, timeout=timeout)

        # Assemble output string
        out = _AttributeString(result_stdout)
        err = _AttributeString(result_stderr)

        # Error handling
        out.failed = False
        out.command = given_command
        out.real_command = wrapped_command
        if status not in env.ok_ret_codes:
            out.failed = True
            msg = "%s() received nonzero return code %s while executing" % (
                which, status
            )
            if env.warn_only:
                msg += " '%s'!" % given_command
            else:
                msg += "!\n\nRequested: %s\nExecuted: %s" % (
                    given_command, wrapped_command
                )
            error(message=msg, stdout=out, stderr=err)

        # Attach return code to output string so users who have set things to
        # warn only, can inspect the error code.
        out.return_code = status

        # Convenience mirror of .failed
        out.succeeded = not out.failed

        # Attach stderr for anyone interested in that.
        out.stderr = err

        return out


def _shell_wrap_inner(command, shell=True, sudo_prefix=None):
    """
    Conditionally wrap given command in env.shell (while honoring sudo.)

    (Modified from fabric.operations._shell_wrap to avoid double escaping,
    as the wrapping host command would also get shell escaped.)
    """
    # Honor env.shell, while allowing the 'shell' kwarg to override it (at
    # least in terms of turning it off.)
    if shell and not env.use_shell:
        shell = False
    # Sudo plus space, or empty string
    if sudo_prefix is None:
        sudo_prefix = ""
    else:
        sudo_prefix += " "
    # If we're shell wrapping, prefix shell and space, escape the command and
    # then quote it. Otherwise, empty string.
    if shell:
        shell = env.shell + " "
        command = '"%s"' % command    # !! removed _shell_escape() here
    else:
        shell = ""
    # Resulting string should now have correct formatting
    return sudo_prefix + shell + command

########NEW FILE########
__FILENAME__ = operations
"""
OpenVZ containers
=================
"""
from __future__ import with_statement

from fabric.api import cd, hide, settings

from fabtools.utils import run_as_root


def create(ctid, ostemplate=None, config=None, private=None,
           root=None, ipadd=None, hostname=None, **kwargs):
    """
    Create an OpenVZ container.
    """
    return _vzctl('create', ctid, ostemplate=ostemplate, config=config,
                  private=private, root=root, ipadd=ipadd, hostname=hostname,
                  **kwargs)


def destroy(ctid_or_name):
    """
    Destroy the container.
    """
    return _vzctl('destroy', ctid_or_name)


def set(ctid_or_name, save=True, **kwargs):
    """
    Set container parameters.
    """
    return _vzctl('set', ctid_or_name, save=save, **kwargs)


def start(ctid_or_name, wait=False, force=False, **kwargs):
    """
    Start the container.

    If *wait* is ``True``, wait until the container is up and running.

    .. warning:: ``wait=True`` is broken with vzctl 3.0.24
                 on Debian 6.0 (*squeeze*)
    """
    return _vzctl('start', ctid_or_name, wait=wait, force=force, **kwargs)


def stop(ctid_or_name, fast=False, **kwargs):
    """
    Stop the container.
    """
    return _vzctl('stop', ctid_or_name, fast=fast, **kwargs)


def restart(ctid_or_name, wait=True, force=False, fast=False, **kwargs):
    """
    Restart the container.
    """
    return _vzctl('restart', ctid_or_name, wait=wait, force=force, fast=fast,
                  **kwargs)


def status(ctid_or_name):
    """
    Get the status of the container.
    """
    with settings(warn_only=True):
        return _vzctl('status', ctid_or_name)


def running(ctid_or_name):
    """
    Check if the container is running.
    """
    return status(ctid_or_name).split(' ')[4] == 'running'


def exists(ctid_or_name):
    """
    Check if the container exists.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        return status(ctid_or_name).succeeded


def exec2(ctid_or_name, command):
    """
    Run a command inside the container.

    ::

        import fabtools

        res = fabtools.openvz.exec2('foo', 'hostname')

    .. warning:: the command will be run as **root**.

    """
    return run_as_root("vzctl exec2 %s '%s'" % (ctid_or_name, command))


def _vzctl(command, ctid_or_name, **kwargs):
    args = _expand_args(**kwargs)
    return run_as_root('vzctl %s %s %s' % (command, ctid_or_name, args))


def _expand_args(**kwargs):
    args = []
    for k, v in kwargs.items():
        if isinstance(v, bool):
            if v is True:
                args.append('--%s' % k)
        elif isinstance(v, (list, tuple)):
            for elem in v:
                args.append('--%s %s' % (k, elem))
        elif v is not None:
            args.append('--%s %s' % (k, v))
    return ' '.join(args)


def download_template(name=None, url=None):
    """
    Download an OpenVZ template.

    Example::

        from fabtools.openvz import download_template

        # Use custom OS template
        download_template(url='http://example.com/templates/mybox.tar.gz')

    If no *url* is provided, the OS template will be downloaded from the
    `download.openvz.org <http://download.openvz.org/template/precreated/>`_
    repository::

        from fabtools.openvz import download_template

        # Use OS template from http://download.openvz.org/template/precreated/
        download_template('debian-6.0-x86_64')

    """
    if url is None:
        url = 'http://download.openvz.org/template/precreated/%s.tar.gz' % name

    with cd('/var/lib/vz/template/cache'):
        run_as_root('wget --progress=dot:mega "%s"' % url)


def list_ctids():
    """
    Get the list of currently used CTIDs.
    """
    with settings(hide('running', 'stdout')):
        res = run_as_root('vzlist -a -1')
    return map(int, res.splitlines())


def get_available_ctid():
    """
    Get an available CTID.
    """
    current_ctids = list_ctids()
    if current_ctids:
        return max(current_ctids) + 1
    else:
        return 1000

########NEW FILE########
__FILENAME__ = opkg
"""
opkg packages
=============

This module provides tools to manage opkg packages
and repositories.

"""
from __future__ import with_statement

from fabric.api import hide, run, settings

from fabtools.utils import run_as_root


MANAGER = 'opkg'


def update_index(quiet=True):
    """
    Update opkg package definitions.
    """
    options = "--verbosity=0" if quiet else ""
    run_as_root("%s %s update" % (MANAGER, options))


def upgrade():
    """
    Upgrade all packages.
    """
    manager = MANAGER
    cmd = 'upgrade'
    run_as_root("%(manager)s %(cmd)s" % locals(), pty=False)


def is_installed(pkg_name):
    """
    Check if a package is installed.
    """
    manager = MANAGER
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = run("%(manager)s  status %(pkg_name)s" % locals())
        return len(res) > 0


def install(packages, update=False, options=None):
    """
    Install one or more packages.

    If *update* is ``True``, the package definitions will be updated
    first, using :py:func:`~fabtools.opkg.update_index`.

    Extra *options* may be passed to ``opkg`` if necessary.

    Example::

        import fabtools

        # Update index, then install a single package
        fabtools.opkg.install('build-essential', update=True)

        # Install multiple packages
        fabtools.opkg.install([
            'mc',
            'htop',
        ])


    """
    manager = MANAGER
    if update:
        update_index()
    if options is None:
        options = []
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options.append("--verbosity=0")
    options = " ".join(options)
    cmd = '%(manager)s install %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)


def uninstall(packages, options=None):
    """
    Remove one or more packages.

    Extra *options* may be passed to ``opkg`` if necessary.
    """
    manager = MANAGER
    command = "remove"
    if options is None:
        options = []
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options = " ".join(options)
    cmd = '%(manager)s %(command)s %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)

########NEW FILE########
__FILENAME__ = oracle_jdk
"""
Oracle JDK
===========

This module provides tools for installing `Oracle JDK`_

.. _Oracle JDK: http://www.oracle.com/technetwork/java/javase/

"""
from __future__ import with_statement

import re

from fabric.api import run, cd, settings, hide

from fabtools.files import is_link
from fabtools.system import get_arch


DEFAULT_VERSION = '7u25-b15'


def install_from_oracle_site(version=DEFAULT_VERSION):
    """
    Download tarball from Oracle site and install JDK.

    ::

        import fabtools

        # Install Oracle JDK
        fabtools.oracle_jdk.install_from_oracle_site()

    """

    from fabtools.require.files import directory as require_directory

    release, build = version.split('-')
    major, update = release.split('u')
    if len(update) == 1:
        update = '0' + update

    jdk_arch = _required_jdk_arch()

    if major == '6':
        jdk_filename = 'jdk-%(release)s-linux-%(jdk_arch)s.bin' % locals()
    else:
        jdk_filename = 'jdk-%(release)s-linux-%(jdk_arch)s.tar.gz' % locals()
    jdk_dir = 'jdk1.%(major)s.0_%(update)s' % locals()

    jdk_url = 'http://download.oracle.com/otn-pub/java/jdk/' +\
              '%(version)s/%(jdk_filename)s' % locals()

    with cd('/tmp'):
        run('rm -rf %s' % jdk_filename)
        run('wget --header "Cookie: oraclelicense=accept-securebackup-cookie" ' +
            '--progress=dot:mega ' +
            '%(jdk_url)s -O /tmp/%(jdk_filename)s' % locals())

    require_directory('/opt', mode='777', use_sudo=True)
    with cd('/opt'):
        if major == '6':
            run('chmod u+x /tmp/%s' % jdk_filename)
            with cd('/tmp'):
                run('./%s' % jdk_filename)
                run('mv %s /opt/' % jdk_dir)
        else:
            run('tar -xzvf /tmp/%s' % jdk_filename)

        if is_link('jdk'):
            run('rm -rf jdk')
        run('ln -s %s jdk' % jdk_dir)

    _create_profile_d_file()


def _create_profile_d_file():
    """
    Create profile.d file with Java environment variables set.
    """
    from fabtools.require.files import file as require_file

    require_file('/etc/profile.d/java.sh', contents=
                 'export JAVA_HOME="/opt/jdk"\n' +
                 'export PATH="$JAVA_HOME/bin:$PATH"\n',
                 mode='0755', use_sudo=True)


def version():
    """
    Get the version of currently installed JDK.

    Returns ``None`` if it is not installed.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        res = run('java -version')
    if res.failed:
        return None
    else:
        return _extract_jdk_version(res)


def _required_jdk_arch():
    """
    Returns required JDK architecture for current system
    in format used in Oracle JDK packages: x64 or i586.

    Raises exception when current system architecture is unsupported.
    """
    system_arch = get_arch()
    if system_arch == 'x86_64':
        return 'x64'
    elif re.match('i[0-9]86', system_arch):
        return 'i586'
    else:
        raise Exception("Unsupported system architecture '%s' for Oracle JDK" %
                        system_arch)


def _extract_jdk_version(java_version_out):
    """
    Extracts JDK version in format like '7u13-b20'
    from 'java -version' command output.
    """
    match = re.search(r'Runtime Environment \(build (.*?)\)', java_version_out)
    if match is None:
        return None
    version, build = match.group(1).split('-')
    release = version.split('_')[0].split('.')[1]
    update = str(int(version.split('_')[1]))
    return '%(release)su%(update)s-%(build)s' % locals()

########NEW FILE########
__FILENAME__ = pkg
"""
SmartOS packages
================

This module provides tools to manage `SmartOS`_ packages.

.. _SmartOS: http://smartos.org/

"""
from __future__ import with_statement

from fabric.api import hide, quiet, run, settings

from fabtools.files import is_file
from fabtools.utils import run_as_root


MANAGER = 'pkgin'


def update_index(force=False):
    """
    Update pkgin package definitions.
    """
    manager = MANAGER
    if force:
        with quiet():
            # clean the package cache
            run_as_root("%(manager)s clean" % locals())
        run_as_root("%(manager)s -f update" % locals())
    else:
        run_as_root("%(manager)s update" % locals())


def upgrade(full=False):
    """
    Upgrade all packages.
    """
    manager = MANAGER
    cmds = {'pkgin': {False: 'uprade', True: 'full-upgrade'}}
    cmd = cmds[manager][full]
    run_as_root("%(manager)s -y %(cmd)s" % locals())


def is_installed(pkg_name):
    """
    Check if a package is installed.
    """
    with settings(warn_only=True):
        res = run('pkg_info -e %s' % pkg_name)
        return res.succeeded is True


def install(packages, update=False, yes=None, options=None):
    """
    Install one or more packages.

    If *update* is ``True``, the package definitions will be updated
    first, using :py:func:`~fabtools.pkg.update_index`.

    Extra *yes* may be passed to ``pkgin`` to validate license if necessary.

    Extra *options* may be passed to ``pkgin`` if necessary.

    Example::

        import fabtools

        # Update index, then verbosely install a single package
        fabtools.pkg.install('redis', update=True, options='-V',)

        # Install multiple packages
        fabtools.pkg.install([
            'unzip',
            'top'
        ])

    """
    manager = MANAGER
    if update:
        update_index()
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options.append("-y")
    options = " ".join(options)
    if isinstance(yes, str):
        run_as_root('yes %(yes)s | %(manager)s %(options)s install %(packages)s' % locals())
    else:
        run_as_root('%(manager)s %(options)s install %(packages)s' % locals())


def uninstall(packages, orphan=False, options=None):
    """
    Remove one or more packages.

    If *orphan* is ``True``, orphan dependencies will be
    removed from the system.

    Extra *options* may be passed to ``pkgin`` if necessary.
    """
    manager = MANAGER
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options.append("-y")
    options = " ".join(options)
    if orphan:
        run_as_root('%(manager)s -y autoremove' % locals())
    run_as_root('%(manager)s %(options)s remove %(packages)s' % locals())


def smartos_build():
    """
    Get the build of SmartOS. Useful to determine provider for example.

    Example::

        from fabtools.pkg import smartos_build

        if smartos_build().startswith('joyent'):
            print('SmartOS Joyent')

    """
    with settings(hide('running', 'stdout')):
        return run('uname -v')


def smartos_image():
    """
    Get the SmartOS image. Useful to determine the image/dataset for example.
    Returns None if it can't be determined.

    Example::

        from fabtools.pkg import smartos_image

        if smartos_image().startswith('percona'):
            sudo("mysql -uroot -psecretpassword -e 'show databases;'")

    """
    with settings(hide('running', 'stdout')):
        if is_file('/etc/product'):
            return run('cat /etc/product | head -n 2 | tail -n 1 | awk \'{ print $2 " " $3 }\'')
        else:
            return None

########NEW FILE########
__FILENAME__ = portage
# -*- coding: utf-8 -*-
"""
Gentoo packages
===============

This module provides tools for managing Gentoo packages and repositories
using the Portage_ package manager.

.. _Portage: http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=2&chap=1

"""
from __future__ import with_statement

import re

from fabric.api import hide, run, settings

from fabtools.utils import run_as_root


MANAGER = 'emerge --color n'


def update_index(quiet=True):
    """
    Update Portage package definitions.
    """
    manager = MANAGER

    if quiet:
        with settings(hide('running', 'stdout', 'stderr', 'warnings'),
                      warn_only=True):
            run_as_root("%(manager)s --sync" % locals())
    else:
        run_as_root("%(manager)s --sync" % locals())


def is_installed(pkg_name):
    """
    Check if a Portage package is installed.
    """
    manager = MANAGER

    with settings(hide("running", "stdout", "stderr", "warnings"),
                  warn_only=True):
        res = run("%(manager)s -p %(pkg_name)s" % locals())

    if not res.succeeded:
        return False

    if pkg_name.startswith("="):
        # The =, which is required when installing/checking for absolute
        # versions, will not appear in the results.
        pkg_name = pkg_name[1:]

    match = re.search(
            r"\n\[ebuild +(?P<code>\w+) *\] .*%(pkg_name)s.*" % locals(),
            res.stdout)
    if match and match.groupdict()["code"] in ("U", "R"):
        return True
    else:
        return False


def install(packages, update=False, options=None):
    """
    Install one or more Portage packages.

    If *update* is ``True``, the package definitions will be updated
    first, using :py:func:`~fabtools.portage.update_index`.

    Extra *options* may be passed to ``emerge`` if necessary.

    Example::

        import fabtools

        # Update index, then install a single package
        fabtools.portage.install('mongodb', update=True)

        # Install multiple packages
        fabtools.arch.install([
            'dev-db/mongodb',
            'pymongo',
        ])

    """
    manager = MANAGER

    if update:
        update_index()

    options = options or []
    options = " ".join(options)

    if not isinstance(packages, basestring):
        packages = " ".join(packages)

    cmd = '%(manager)s %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)


def uninstall(packages, options=None):
    """
    Remove one or more Portage packages.

    Extra *options* may be passed to ``emerge`` if necessary.
    """
    manager = MANAGER

    options = options or []
    options = " ".join(options)

    if not isinstance(packages, basestring):
        packages = " ".join(packages)

    cmd = '%(manager)s --unmerge %(options)s %(packages)s' % locals()
    run_as_root(cmd, pty=False)

########NEW FILE########
__FILENAME__ = postgres
"""
PostgreSQL users and databases
==============================

This module provides tools for creating PostgreSQL users and databases.

"""
from __future__ import with_statement

from fabric.api import cd, hide, sudo, settings


def _run_as_pg(command):
    """
    Run command as 'postgres' user
    """
    with cd('~postgres'):
        return sudo(command, user='postgres')


def user_exists(name):
    """
    Check if a PostgreSQL user exists.
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'),
                  warn_only=True):
        res = _run_as_pg('''psql -t -A -c "SELECT COUNT(*) FROM pg_user WHERE usename = '%(name)s';"''' % locals())
    return (res == "1")


def create_user(name, password, superuser=False, createdb=False,
                createrole=False, inherit=True, login=True,
                connection_limit=None, encrypted_password=False):
    """
    Create a PostgreSQL user.

    Example::

        import fabtools

        # Create DB user if it does not exist
        if not fabtools.postgres.user_exists('dbuser'):
            fabtools.postgres.create_user('dbuser', password='somerandomstring')

        # Create DB user with custom options
        fabtools.postgres.create_user('dbuser2', password='s3cr3t',
            createdb=True, createrole=True, connection_limit=20)

    """
    options = [
        'SUPERUSER' if superuser else 'NOSUPERUSER',
        'CREATEDB' if createdb else 'NOCREATEDB',
        'CREATEROLE' if createrole else 'NOCREATEROLE',
        'INHERIT' if inherit else 'NOINHERIT',
        'LOGIN' if login else 'NOLOGIN',
    ]
    if connection_limit is not None:
        options.append('CONNECTION LIMIT %d' % connection_limit)
    password_type = 'ENCRYPTED' if encrypted_password else 'UNENCRYPTED'
    options.append("%s PASSWORD '%s'" % (password_type, password))
    options = ' '.join(options)
    _run_as_pg('''psql -c "CREATE USER %(name)s %(options)s;"''' % locals())


def drop_user(name):
    """
    Drop a PostgreSQL user.

    Example::

        import fabtools

        # Remove DB user if it exists
        if fabtools.postgres.user_exists('dbuser'):
            fabtools.postgres.drop_user('dbuser')

    """
    _run_as_pg('''psql -c "DROP USER %(name)s;"''' % locals())


def database_exists(name):
    """
    Check if a PostgreSQL database exists.
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'),
                  warn_only=True):
        return _run_as_pg('''psql -d %(name)s -c ""''' % locals()).succeeded


def create_database(name, owner, template='template0', encoding='UTF8',
                    locale='en_US.UTF-8'):
    """
    Create a PostgreSQL database.

    Example::

        import fabtools

        # Create DB if it does not exist
        if not fabtools.postgres.database_exists('myapp'):
            fabtools.postgres.create_database('myapp', owner='dbuser')

    """
    _run_as_pg('''createdb --owner %(owner)s --template %(template)s \
                  --encoding=%(encoding)s --lc-ctype=%(locale)s \
                  --lc-collate=%(locale)s %(name)s''' % locals())


def drop_database(name):
    """
    Delete a PostgreSQL database.

    Example::

        import fabtools

        # Remove DB if it exists
        if fabtools.postgres.database_exists('myapp'):
            fabtools.postgres.drop_database('myapp')

    """
    _run_as_pg('''dropdb %(name)s''' % locals())


def create_schema(name, database, owner=None):
    """
    Create a schema within a database.
    """
    if owner:
        _run_as_pg('''psql %(database)s -c "CREATE SCHEMA %(name)s AUTHORIZATION %(owner)s"''' % locals())
    else:
        _run_as_pg('''psql %(database)s -c "CREATE SCHEMA %(name)s"''' % locals())

########NEW FILE########
__FILENAME__ = python
"""
Python environments and packages
================================

This module provides tools for using Python `virtual environments`_
and installing Python packages using the `pip`_ installer.

.. _virtual environments: http://www.virtualenv.org/
.. _pip: http://www.pip-installer.org/

"""
from __future__ import with_statement

from contextlib import contextmanager
from distutils.version import StrictVersion as V
from pipes import quote
import os
import posixpath
import re

from fabric.api import cd, hide, prefix, run, settings, sudo
from fabric.utils import puts

from fabtools.files import is_file
from fabtools.utils import abspath, download, run_as_root


GET_PIP_URL = 'https://raw.githubusercontent.com/pypa/pip/master/contrib/get-pip.py'


def is_pip_installed(version=None, pip_cmd='pip'):
    """
    Check if `pip`_ is installed.

    .. _pip: http://www.pip-installer.org/
    """
    with settings(hide('running', 'warnings', 'stderr', 'stdout'), warn_only=True):
        res = run('%(pip_cmd)s --version 2>/dev/null' % locals())
        if res.failed:
            return False
        if version is None:
            return res.succeeded
        else:
            m = re.search(r'pip (?P<version>.*) from', res)
            if m is None:
                return False
            installed = m.group('version')
            if V(installed) < V(version):
                puts("pip %s found (version >= %s required)" % (installed, version))
                return False
            else:
                return True


def install_pip(python_cmd='python', use_sudo=True):
    """
    Install the latest version of `pip`_, using the given Python
    interpreter.

    ::

        import fabtools

        if not fabtools.python.is_pip_installed():
            fabtools.python.install_pip()

    .. note::
        pip is automatically installed inside a virtualenv, so there
        is no need to install it yourself in this case.

    .. _pip: http://www.pip-installer.org/
    """

    with cd('/tmp'):

        download(GET_PIP_URL)

        command = '%(python_cmd)s get-pip.py' % locals()
        if use_sudo:
            run_as_root(command, pty=False)
        else:
            run(command, pty=False)

        run('rm -f get-pip.py')


def is_installed(package, pip_cmd='pip'):
    """
    Check if a Python package is installed (using pip).

    Package names are case insensitive.

    Example::

        from fabtools.python import virtualenv
        import fabtools

        with virtualenv('/path/to/venv'):
            fabtools.python.install('Flask')
            assert fabtools.python.is_installed('flask')

    .. _pip: http://www.pip-installer.org/
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = run('%(pip_cmd)s freeze' % locals())
    packages = [line.split('==')[0].lower() for line in res.splitlines()]
    return (package.lower() in packages)


def install(packages, upgrade=False, download_cache=None, allow_external=None,
            allow_unverified=None, quiet=False, pip_cmd='pip', use_sudo=False,
            user=None, exists_action=None):
    """
    Install Python package(s) using `pip`_.

    Package names are case insensitive.

    Starting with version 1.5, pip no longer scrapes insecure external
    urls by default and no longer installs externally hosted files by
    default. Use ``allow_external=['foo', 'bar']`` or
    ``allow_unverified=['bar', 'baz']`` to change these behaviours
    for specific packages.

    Examples::

        import fabtools

        # Install a single package
        fabtools.python.install('package', use_sudo=True)

        # Install a list of packages
        fabtools.python.install(['pkg1', 'pkg2'], use_sudo=True)

    .. _pip: http://www.pip-installer.org/
    """
    if isinstance(packages, basestring):
        packages = [packages]

    if allow_external in (None, False):
        allow_external = []
    elif allow_external == True:
        allow_external = packages

    if allow_unverified in (None, False):
        allow_unverified = []
    elif allow_unverified == True:
        allow_unverified = packages

    options = []
    if upgrade:
        options.append('--upgrade')
    if download_cache:
        options.append('--download-cache="%s"' % download_cache)
    if quiet:
        options.append('--quiet')
    for package in allow_external:
        options.append('--allow-external="%s"' % package)
    for package in allow_unverified:
        options.append('--allow-unverified="%s"' % package)
    if exists_action:
        options.append('--exists-action=%s' % exists_action)
    options = ' '.join(options)

    packages = ' '.join(packages)

    command = '%(pip_cmd)s install %(options)s %(packages)s' % locals()

    if use_sudo:
        sudo(command, user=user, pty=False)
    else:
        run(command, pty=False)


def install_requirements(filename, upgrade=False, download_cache=None,
                         allow_external=None, allow_unverified=None,
                         quiet=False, pip_cmd='pip', use_sudo=False,
                         user=None, exists_action=None):
    """
    Install Python packages from a pip `requirements file`_.

    ::

        import fabtools

        fabtools.python.install_requirements('project/requirements.txt')

    .. _requirements file: http://www.pip-installer.org/en/latest/requirements.html
    """
    if allow_external is None:
        allow_external = []

    if allow_unverified is None:
        allow_unverified = []

    options = []
    if upgrade:
        options.append('--upgrade')
    if download_cache:
        options.append('--download-cache="%s"' % download_cache)
    for package in allow_external:
        options.append('--allow-external="%s"' % package)
    for package in allow_unverified:
        options.append('--allow-unverified="%s"' % package)
    if quiet:
        options.append('--quiet')
    if exists_action:
        options.append('--exists-action=%s' % exists_action)
    options = ' '.join(options)

    command = '%(pip_cmd)s install %(options)s -r %(filename)s' % locals()

    if use_sudo:
        sudo(command, user=user, pty=False)
    else:
        run(command, pty=False)


def create_virtualenv(directory, system_site_packages=False, venv_python=None,
               use_sudo=False, user=None, clear=False, prompt=None,
               virtualenv_cmd='virtualenv'):
    """
    Create a Python `virtual environment`_.

    ::

        import fabtools

        fabtools.python.create_virtualenv('/path/to/venv')

    .. _virtual environment: http://www.virtualenv.org/
    """
    options = ['--quiet']
    if system_site_packages:
        options.append('--system-site-packages')
    if venv_python:
        options.append('--python=%s' % quote(venv_python))
    if clear:
        options.append('--clear')
    if prompt:
        options.append('--prompt=%s' % quote(prompt))
    options = ' '.join(options)

    directory = quote(directory)

    command = '%(virtualenv_cmd)s %(options)s %(directory)s' % locals()
    if use_sudo:
        sudo(command, user=user)
    else:
        run(command)


def virtualenv_exists(directory):
    """
    Check if a Python `virtual environment`_ exists.

    .. _virtual environment: http://www.virtualenv.org/
    """
    return is_file(posixpath.join(directory, 'bin', 'python'))


@contextmanager
def virtualenv(directory, local=False):
    """
    Context manager to activate an existing Python `virtual environment`_.

    ::

        from fabric.api import run
        from fabtools.python import virtualenv

        with virtualenv('/path/to/virtualenv'):
            run('python -V')

    .. _virtual environment: http://www.virtualenv.org/
    """

    path_mod = os.path if local else posixpath

    # Build absolute path to the virtualenv activation script
    venv_path = abspath(directory)
    activate_path = path_mod.join(venv_path, 'bin', 'activate')

    # Source the activation script
    with prefix('. %s' % quote(activate_path)):
        yield

########NEW FILE########
__FILENAME__ = apache
"""
Apache
======

This module provides high-level tools for installing and configuring
the `Apache HTTP Server <http://httpd.apache.org/>`_.

"""
from __future__ import with_statement

from fabric.api import (
    abort,
    hide,
    settings,
)
from fabric.colors import red

from fabtools.apache import (
    disable_module,
    enable_module,
    disable_site,
    enable_site,
    _get_config_name,
)
from fabtools.require.deb import package
from fabtools.require.files import template_file
from fabtools.require.service import started as require_started
from fabtools.service import reload as reload_service
from fabtools.utils import run_as_root


def server():
    """
    Require the Apache HTTP server to be installed and running.

    ::

        from fabtools import require

        require.apache.server()

    """
    package('apache2')
    require_started('apache2')


def module_enabled(module):
    """
    Require an Apache module to be enabled.

    This will cause Apache to reload its configuration.

    ::

        from fabtools import require

        require.apache.module_enabled('rewrite')

    """
    enable_module(module)
    reload_service('apache2')


def module_disabled(module):
    """
    Require an Apache module to be disabled.

    This will cause Apache to reload its configuration.

    ::

        from fabtools import require

        require.apache.module_disabled('rewrite')

    """
    disable_module(module)
    reload_service('apache2')


def site_enabled(config):
    """
    Require an Apache site to be enabled.

    This will cause Apache to reload its configuration.

    ::

        from fabtools import require

        require.apache.site_enabled('mysite')

    """
    enable_site(config)
    reload_service('apache2')


def site_disabled(config):
    """
    Require an Apache site to be disabled.

    This will cause Apache to reload its configuration.

    ::

        from fabtools import require

        require.apache.site_disabled('default')

    """
    disable_site(config)
    reload_service('apache2')


def site(config_name, template_contents=None, template_source=None, enabled=True, check_config=True, **kwargs):
    """
    Require an Apache site.

    You must provide a template for the site configuration, either as a
    string (*template_contents*) or as the path to a local template
    file (*template_source*).

    ::

        from fabtools import require

        CONFIG_TPL = '''
        <VirtualHost *:%(port)s>
            ServerName %(hostname})s

            DocumentRoot %(document_root)s

            <Directory %(document_root)s>
                Options Indexes FollowSymLinks MultiViews

                AllowOverride All

                Order allow,deny
                allow from all
            </Directory>
        </VirtualHost>
        '''

        require.apache.site(
            'example.com',
            template_contents=CONFIG_TPL,
            port=80,
            hostname='www.example.com',
            document_root='/var/www/mysite',
        )

    .. seealso:: :py:func:`fabtools.require.files.template_file`
    """
    server()

    config_filename = '/etc/apache2/sites-available/%s' % _get_config_name(config_name)

    context = {
        'port': 80,
    }
    context.update(kwargs)
    context['config_name'] = config_name

    template_file(config_filename, template_contents, template_source, context, use_sudo=True)

    if enabled:
        enable_site(config_name)
    else:
        disable_site(config_name)

    if check_config:
        with settings(hide('running', 'warnings'), warn_only=True):
            if run_as_root('apache2ctl configtest').failed:
                disable_site(config_name)
                message = red("Error in %(config_name)s apache site config (disabling for safety)" % locals())
                abort(message)

    reload_service('apache2')


# backward compatibility (deprecated)
enabled = site_enabled
disabled = site_disabled


__all__ = [
    'server', 'module_enabled', 'module_disabled',
    'site_enabled', 'site_disabled', 'site',
]

########NEW FILE########
__FILENAME__ = arch
"""
Archlinux packages
==================

This module provides high-level tools for managing Archlinux packages
and repositories.

"""
from __future__ import with_statement

from fabtools.arch import (
    install,
    is_installed,
    uninstall,
)


def package(pkg_name, update=False):
    """
    Require an Archlinux package to be installed.

    Example::

        from fabtools import require

        require.arch.package('foo')
    """
    if not is_installed(pkg_name):
        install(pkg_name, update)


def packages(pkg_list, update=False):
    """
    Require several Archlinux packages to be installed.

    Example::

        from fabtools import require

        require.arch.packages([
            'foo',
            'bar',
            'baz',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg)]
    if pkg_list:
        install(pkg_list, update)


def nopackage(pkg_name):
    """
    Require an Archlinux package to be uninstalled.

    Example::

        from fabtools import require

        require.arch.nopackage('apache2')
    """
    if is_installed(pkg_name):
        uninstall(pkg_name)


def nopackages(pkg_list):
    """
    Require several Archlinux packages to be uninstalled.

    Example::

        from fabtools import require

        require.arch.nopackages([
            'perl',
            'php5',
            'ruby',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)]
    if pkg_list:
        uninstall(pkg_list)

########NEW FILE########
__FILENAME__ = curl
"""
Curl
====

This module provides high-level tools for using curl.

"""
from fabtools.system import UnsupportedFamily, distrib_family


def command():
    """
    Require the curl command-line tool.

    Example::

        from fabric.api import run
        from fabtools import require

        require.curl.command()
        run('curl --help')

    """

    from fabtools.require.deb import package as require_deb_package
    from fabtools.require.rpm import package as require_rpm_package

    family = distrib_family()

    if family == 'debian':
        require_deb_package('curl')
    elif family == 'redhat':
        require_rpm_package('curl')
    else:
        raise UnsupportedFamily(supported=['debian', 'redhat'])

########NEW FILE########
__FILENAME__ = deb
"""
Debian packages
===============

This module provides high-level tools for managing Debian/Ubuntu packages
and repositories.

"""
from __future__ import with_statement

from fabric.utils import puts

from fabtools.deb import (
    add_apt_key,
    apt_key_exists,
    install,
    is_installed,
    uninstall,
    update_index,
    last_update_time,
)
from fabtools.files import is_file, watch
from fabtools.system import distrib_codename, distrib_release
from fabtools.utils import run_as_root
from fabtools import system


def key(keyid, filename=None, url=None, keyserver='subkeys.pgp.net', update=False):
    """
    Require a PGP key for APT.

    ::

        from fabtools import require

        # Varnish signing key from URL
        require.deb.key('C4DEFFEB', url='http://repo.varnish-cache.org/debian/GPG-key.txt')

        # Nginx signing key from default key server (subkeys.pgp.net)
        require.deb.key('7BD9BF62')

        # From custom key server
        require.deb.key('7BD9BF62', keyserver='keyserver.ubuntu.com')

        # From file
        require.deb.key('7BD9BF62', filename='nginx.asc')

    """

    if not apt_key_exists(keyid):
        add_apt_key(keyid=keyid, filename=filename, url=url, keyserver=keyserver, update=update)


def source(name, uri, distribution, *components):
    """
    Require a package source.

    ::

        from fabtools import require

        # Official MongoDB packages
        require.deb.source('mongodb', 'http://downloads-distro.mongodb.org/repo/ubuntu-upstart', 'dist', '10gen')

    """

    from fabtools.require import file as require_file

    path = '/etc/apt/sources.list.d/%(name)s.list' % locals()
    components = ' '.join(components)
    source_line = 'deb %(uri)s %(distribution)s %(components)s\n' % locals()
    with watch(path) as config:
        require_file(path=path, contents=source_line, use_sudo=True)
    if config.changed:
        puts('Added APT repository: %s' % source_line)
        update_index()


def ppa(name, auto_accept=True, keyserver=None):
    """
    Require a `PPA`_ package source.

    Example::

        from fabtools import require

        # Node.js packages by Chris Lea
        require.deb.ppa('ppa:chris-lea/node.js', keyserver='my.keyserver.com')

    .. _PPA: https://help.launchpad.net/Packaging/PPA
    """
    assert name.startswith('ppa:')

    user, repo = name[4:].split('/', 2)

    release = float(distrib_release())
    if release >= 12.04:
        repo = repo.replace('.', '_')
        auto_accept = '--yes' if auto_accept else ''
    else:
        auto_accept = ''

    if not isinstance(keyserver, basestring) and keyserver:
        keyserver = keyserver[0]
    if keyserver:
        keyserver = '--keyserver ' + keyserver
    else:
       keyserver = ''

    distrib = distrib_codename()
    source = '/etc/apt/sources.list.d/%(user)s-%(repo)s-%(distrib)s.list' % locals()

    if not is_file(source):
        package('python-software-properties')
        run_as_root('add-apt-repository %(auto_accept)s %(keyserver)s %(name)s' % locals(), pty=False)
        update_index()


def package(pkg_name, update=False, version=None):
    """
    Require a deb package to be installed.

    Example::

        from fabtools import require

        # Require a package
        require.deb.package('foo')

        # Require a specific version
        require.deb.package('firefox', version='11.0+build1-0ubuntu4')

    """
    if not is_installed(pkg_name):
        install(pkg_name, update=update, version=version)


def packages(pkg_list, update=False):
    """
    Require several deb packages to be installed.

    Example::

        from fabtools import require

        require.deb.packages([
            'foo',
            'bar',
            'baz',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg)]
    if pkg_list:
        install(pkg_list, update)


def nopackage(pkg_name):
    """
    Require a deb package to be uninstalled.

    Example::

        from fabtools import require

        require.deb.nopackage('apache2')
    """
    if is_installed(pkg_name):
        uninstall(pkg_name)


def nopackages(pkg_list):
    """
    Require several deb packages to be uninstalled.

    Example::

        from fabtools import require

        require.deb.nopackages([
            'perl',
            'php5',
            'ruby',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)]
    if pkg_list:
        uninstall(pkg_list)


def _to_seconds(var):
    sec = 0
    MINUTE = 60
    HOUR = 60 * MINUTE
    DAY = 24 * HOUR
    WEEK = 7 * DAY
    MONTH = 31 * DAY
    try:
        for key, value in var.items():
            if key in ('second', 'seconds'):
                sec += value
            elif key in ('minute', 'minutes'):
                sec += value * MINUTE
            elif key in ('hour', 'hours'):
                sec += value * HOUR
            elif key in ('day', 'days'):
                sec += value * DAY
            elif key in ('week', 'weeks'):
                sec += value * WEEK
            elif key in ('month', 'months'):
                sec += value * MONTH
            else:
                raise ValueError("Unknown time unit '%s'" % key)
        return sec
    except AttributeError:
        return var


def uptodate_index(quiet=True, max_age=86400):
    """
    Require an up-to-date package index.

    This will update the package index (using ``apt-get update``) if the last
    update occured more than *max_age* ago.

    *max_age* can be specified either as an integer (a value in seconds),
    or as a dictionary whose keys are units (``seconds``, ``minutes``,
    ``hours``, ``days``, ``weeks``, ``months``) and values are integers.
    The default value is 1 hour.

    Examples: ::

        from fabtools import require

        # Update index if last time was more than 1 day ago
        require.deb.uptodate_index(max_age={'day': 1})

        # Update index if last time was more than 1 hour and 30 minutes ago
        require.deb.uptodate_index(max_age={'hour': 1, 'minutes': 30})

    """

    from fabtools.require import file as require_file
    require_file('/etc/apt/apt.conf.d/15fabtools-update-stamp', contents='''\
APT::Update::Post-Invoke-Success {"touch /var/lib/apt/periodic/fabtools-update-success-stamp 2>/dev/null || true";};
''', use_sudo=True)

    if system.time() - last_update_time() > _to_seconds(max_age):
        update_index(quiet=quiet)

########NEW FILE########
__FILENAME__ = files
"""
Files and directories
=====================

This module provides high-level tools for managing files and
directories.

"""
from __future__ import with_statement

from pipes import quote
from tempfile import mkstemp
from urlparse import urlparse
import hashlib
import os

from fabric.api import hide, put, run, settings

from fabtools.files import (
    group as _group,
    is_file,
    is_dir,
    md5sum,
    mode as _mode,
    owner as _owner,
    umask,
)
from fabtools.utils import run_as_root
import fabtools.files


BLOCKSIZE = 2 ** 20  # 1MB


def directory(path, use_sudo=False, owner='', group='', mode=''):
    """
    Require a directory to exist.

    ::

        from fabtools import require

        require.directory('/tmp/mydir', owner='alice', use_sudo=True)

    .. note:: This function can be accessed directly from the
              ``fabtools.require`` module for convenience.

    """
    func = use_sudo and run_as_root or run

    if not is_dir(path):
        func('mkdir -p "%(path)s"' % locals())

    # Ensure correct owner
    if (owner and _owner(path, use_sudo) != owner) or \
       (group and _group(path, use_sudo) != group):
        func('chown %(owner)s:%(group)s "%(path)s"' % locals())

    # Ensure correct mode
    if mode and _mode(path, use_sudo) != mode:
        func('chmod %(mode)s "%(path)s"' % locals())


def directories(path_list, use_sudo=False, owner='', group='', mode=''):
    """
    Require a list of directories to exist.

    ::

        from fabtools import require
        dirs=[
            '/tmp/mydir',
            '/tmp/mydear',
            '/tmp/my/dir'
        ]
        require.directories(dirs, owner='alice', mode='750')

    .. note:: This function can be accessed directly from the
              ``fabtools.require`` module for convenience.
    """
    for path in path_list:
        directory(path, use_sudo, owner, group, mode)


def file(path=None, contents=None, source=None, url=None, md5=None,
         use_sudo=False, owner=None, group='', mode=None, verify_remote=True,
         temp_dir='/tmp'):
    """
    Require a file to exist and have specific contents and properties.

    You can provide either:

    - *contents*: the required contents of the file::

        from fabtools import require

        require.file('/tmp/hello.txt', contents='Hello, world')

    - *source*: the local path of a file to upload::

        from fabtools import require

        require.file('/tmp/hello.txt', source='files/hello.txt')

    - *url*: the URL of a file to download (*path* is then optional)::

        from fabric.api import cd
        from fabtools import require

        with cd('tmp'):
            require.file(url='http://example.com/files/hello.txt')

    If *verify_remote* is ``True`` (the default), then an MD5 comparison
    will be used to check whether the remote file is the same as the
    source. If this is ``False``, the file will be assumed to be the
    same if it is present. This is useful for very large files, where
    generating an MD5 sum may take a while.

    When providing either the *contents* or the *source* parameter, Fabric's
    ``put`` function will be used to upload the file to the remote host.
    When ``use_sudo`` is ``True``, the file will first be uploaded to a temporary
    directory, then moved to its final location. The default temporary
    directory is ``/tmp``, but can be overridden with the *temp_dir* parameter.
    If *temp_dir* is an empty string, then the user's home directory will
    be used.

    If `use_sudo` is `True`, then the remote file will be owned by root,
    and its mode will reflect root's default *umask*. The optional *owner*,
    *group* and *mode* parameters can be used to override these properties.

    .. note:: This function can be accessed directly from the
              ``fabtools.require`` module for convenience.

    """
    func = use_sudo and run_as_root or run

    # 1) Only a path is given
    if path and not (contents or source or url):
        assert path
        if not is_file(path):
            func('touch "%(path)s"' % locals())

    # 2) A URL is specified (path is optional)
    elif url:
        if not path:
            path = os.path.basename(urlparse(url).path)

        if not is_file(path) or md5 and md5sum(path) != md5:
            func('wget --progress=dot:mega %(url)s -O %(path)s' % locals())

    # 3) A local filename, or a content string, is specified
    else:
        if source:
            assert not contents
            t = None
        else:
            fd, source = mkstemp()
            t = os.fdopen(fd, 'w')
            t.write(contents)
            t.close()

        if verify_remote:
            # Avoid reading the whole file into memory at once
            digest = hashlib.md5()
            f = open(source, 'rb')
            try:
                while True:
                    d = f.read(BLOCKSIZE)
                    if not d:
                        break
                    digest.update(d)
            finally:
                f.close()
        else:
            digest = None

        if (not is_file(path, use_sudo=use_sudo) or
                (verify_remote and
                    md5sum(path, use_sudo=use_sudo) != digest.hexdigest())):
            with settings(hide('running')):
                put(source, path, use_sudo=use_sudo, temp_dir=temp_dir)

        if t is not None:
            os.unlink(source)

    # Ensure correct owner
    if use_sudo and owner is None:
        owner = 'root'
    if (owner and _owner(path, use_sudo) != owner) or \
       (group and _group(path, use_sudo) != group):
        func('chown %(owner)s:%(group)s "%(path)s"' % locals())

    # Ensure correct mode
    if use_sudo and mode is None:
        mode = oct(0666 & ~int(umask(use_sudo=True), base=8))
    if mode and _mode(path, use_sudo) != mode:
        func('chmod %(mode)s "%(path)s"' % locals())


def template_file(path=None, template_contents=None, template_source=None, context=None, **kwargs):
    """
    Require a file whose contents is defined by a template.
    """
    if template_contents is None:
        with open(template_source) as template_file:
            template_contents = template_file.read()

    if context is None:
        context = {}

    file(path=path, contents=template_contents % context, **kwargs)


def temporary_directory(template=None):
    """
    Require a temporary directory.

    The directory is created using the ``mktemp`` command. It will
    be created in ``/tmp``, unless the ``TMPDIR`` environment variable
    is set to another location. ::

        from fabtools.require.files import temporary_directory

        tmp_dir = temporary_directory()

    You can choose a specific location and name template for the
    temporary directory: ::

        from fabtools.require.files import temporary_directory

        tmp_dir = temporary_directory('/var/tmp/temp.XXXXXX')

    You can also call this function as a context manager. In this case,
    the directory and its contents will be automatically deleted when
    exiting the block: ::

        from pipes import quote
        from posixpath import join

        from fabtools.require.files import temporary_directory

        with temporary_directory() as tmp_dir:
            path = join(tmp_dir, 'foo')
            run('touch %s' % quote(path))

    """
    options = ['--directory']
    if template:
        options.append(template)
    options = ' '.join(options)
    with hide('running', 'stdout'):
        path = run('mktemp %s' % options)
    return TemporaryDirectory(path)


class TemporaryDirectory(str):

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        run('rm -rf %s' % quote(self))

########NEW FILE########
__FILENAME__ = git
"""
Git
===

This module provides high-level tools for managing `Git`_ repositories.

.. _Git: http://git-scm.com/

"""

from __future__ import with_statement

from fabric.api import run

from fabtools import git
from fabtools.files import is_dir


def command():
    """
    Require the git command-line tool.

    Example::

        from fabric.api import run
        from fabtools import require

        require.git.command()
        run('git --help')

    """
    from fabtools.require.deb import package as require_deb_package
    from fabtools.require.pkg import package as require_pkg_package
    from fabtools.require.rpm import package as require_rpm_package
    from fabtools.require.portage import package as require_portage_package
    from fabtools.system import distrib_family

    res = run('git --version', quiet=True)
    if res.failed:
        family = distrib_family()
        if family == 'debian':
            require_deb_package('git-core')
        elif family == 'redhat':
            require_rpm_package('git')
        elif family == 'sun':
            require_pkg_package('scmgit-base')
        elif family == 'gentoo':
            require_portage_package('dev-vcs/git')
        else:
            raise NotImplementedError()


def working_copy(remote_url, path=None, branch="master", update=True,
                 use_sudo=False, user=None):
    """
    Require a working copy of the repository from the ``remote_url``.

    The ``path`` is optional, and defaults to the last segment of the
    remote repository URL, without its ``.git`` suffix.

    If the ``path`` does not exist, this will clone the remote
    repository and check out the specified branch.

    If the ``path`` exists and ``update`` is ``True``, it will fetch
    changes from the remote repository, check out the specified branch,
    then merge the remote changes into the working copy.

    If the ``path`` exists and ``update`` is ``False``, it will only
    check out the specified branch, without fetching remote changesets.

    :param remote_url: URL of the remote repository (e.g.
                       https://github.com/ronnix/fabtools.git).  The given URL
                       will be the ``origin`` remote of the working copy.
    :type remote_url: str

    :param path: Absolute or relative path of the working copy on the
                 filesystem.  If this directory doesn't exist yet, a new
                 working copy is created through ``git clone``.  If the
                 directory does exist *and* ``update == True``, a
                 ``git fetch`` is issued.  If ``path is None`` the
                 ``git clone`` is issued in the current working directory and
                 the directory name of the working copy is created by ``git``.
    :type path: str

    :param branch: Branch or tag to check out.  If the given value is a tag
                   name, update must be ``False`` or consecutive calls will
                   fail.
    :type branch: str

    :param update: Whether or not to fetch and merge remote changesets.
    :type update: bool

    :param use_sudo: If ``True`` execute ``git`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    """

    command()

    if path is None:
        path = remote_url.split('/')[-1]
        if path.endswith('.git'):
            path = path[:-4]

    if is_dir(path, use_sudo=use_sudo):
        # always fetch changesets from remote and checkout branch / tag
        git.fetch(path=path, use_sudo=use_sudo, user=user)
        git.checkout(path=path, branch=branch, use_sudo=use_sudo, user=user)
        if update:
            # only 'merge' if update is True
            git.pull(path=path, use_sudo=use_sudo, user=user)

    elif not is_dir(path, use_sudo=use_sudo):
        git.clone(remote_url, path=path, use_sudo=use_sudo, user=user)
        git.checkout(path=path, branch=branch, use_sudo=use_sudo, user=user)

    else:
        raise ValueError("Invalid combination of parameters.")

########NEW FILE########
__FILENAME__ = groups
"""
System groups
=============
"""
from fabtools.group import create, exists


def group(name, gid=None):
    """
    Require a group.

    ::

        from fabtools import require

        require.group('mygroup')

    .. note:: This function can be accessed directly from the
              ``fabtools.require`` module for convenience.

    """

    # Make sure the group exists
    if not exists(name):
        create(name, gid=gid)

########NEW FILE########
__FILENAME__ = mercurial
"""
Mercurial
=========

This module provides high-level tools for managing `Mercurial`_ repositories.

.. _Mercurial: http://mercurial.selenic.com/

"""

from __future__ import with_statement

from fabric.api import run

from fabtools import mercurial
from fabtools.files import is_dir
from fabtools.system import UnsupportedFamily


def command():
    """
    Require the ``hg`` command-line tool.

    Example::

        from fabric.api import run
        from fabtools import require

        require.mercurial.command()
        run('hg --help')

    """
    from fabtools.require.deb import package as require_deb_package
    from fabtools.require.rpm import package as require_rpm_package
    from fabtools.require.portage import package as require_portage_package
    from fabtools.system import distrib_family

    res = run('hg --version', quiet=True)
    if res.failed:
        family = distrib_family()
        if family == 'debian':
            require_deb_package('mercurial')
        elif family == 'gentoo':
            require_portage_package('mercurial')
        elif family == 'redhat':
            require_rpm_package('mercurial')
        else:
            raise UnsupportedFamily(supported=['debian', 'redhat', 'gentoo'])


def working_copy(remote_url, path=None, branch="default", update=True,
                 use_sudo=False, user=None):
    """
    Require a working copy of the repository from the ``remote_url``.

    The ``path`` is optional, and defaults to the last segment of the
    remote repository URL.

    If the ``path`` does not exist, this will clone the remote
    repository and check out the specified branch.

    If the ``path`` exists and ``update`` is ``True``, it will pull
    changes from the remote repository, check out the specified branch,
    then update the working copy.

    If the ``path`` exists and ``update`` is ``False``, it will only
    check out the specified branch, without pulling remote changesets.

    :param remote_url: URL of the remote repository
    :type remote_url: str

    :param path: Absolute or relative path of the working copy on the
                 filesystem.  If this directory doesn't exist yet, a new
                 working copy is created through ``hg clone``.  If the
                 directory does exist *and* ``update == True``, a
                 ``hg pull && hg up`` is issued.  If ``path is None`` the
                 ``hg clone`` is issued in the current working directory and
                 the directory name of the working copy is created by ``hg``.
    :type path: str

    :param branch: Branch or tag to check out.  If the given value is a tag
                   name, update must be ``False`` or consecutive calls will
                   fail.
    :type branch: str

    :param update: Whether or not to pull and update remote changesets.
    :type update: bool

    :param use_sudo: If ``True`` execute ``hg`` with
                     :func:`fabric.operations.sudo`, else with
                     :func:`fabric.operations.run`.
    :type use_sudo: bool

    :param user: If ``use_sudo is True``, run :func:`fabric.operations.sudo`
                 with the given user.  If ``use_sudo is False`` this parameter
                 has no effect.
    :type user: str
    """

    command()

    if path is None:
        path = remote_url.split('/')[-1]

    if is_dir(path, use_sudo=use_sudo):
        mercurial.pull(path, use_sudo=use_sudo, user=user)
        if update:
            mercurial.update(path=path, branch=branch, use_sudo=use_sudo,
                             user=user)
    elif not is_dir(path, use_sudo=use_sudo):
        mercurial.clone(remote_url, path=path, use_sudo=use_sudo, user=user)
        mercurial.update(path=path, branch=branch, use_sudo=use_sudo, user=user)
    else:
        raise ValueError("Invalid combination of parameters.")

########NEW FILE########
__FILENAME__ = mysql
"""
MySQL
=====

This module provides high-level tools for installing a MySQL server
and creating MySQL users and databases.

"""
from __future__ import with_statement

from fabric.api import hide, prompt, settings

from fabtools.deb import is_installed, preseed_package
from fabtools.mysql import (
    create_database,
    create_user,
    database_exists,
    user_exists,
)
from fabtools.require.deb import package
from fabtools.require.service import started


def server(version=None, password=None):
    """
    Require a MySQL server to be installed and running.

    Example::

        from fabtools import require

        require.mysql.server(password='s3cr3t')

    """
    if version:
        pkg_name = 'mysql-server-%s' % version
    else:
        pkg_name = 'mysql-server'

    if not is_installed(pkg_name):
        if password is None:
            password = prompt('Please enter password for MySQL user "root":' % user)

        with settings(hide('running')):
            preseed_package('mysql-server', {
                'mysql-server/root_password': ('password', password),
                'mysql-server/root_password_again': ('password', password),
            })

        package(pkg_name)

    started('mysql')


def user(name, password, **kwargs):
    """
    Require a MySQL user.

    Extra arguments will be passed to :py:func:`fabtools.mysql.create_user`.

    Example::

        from fabric.api import settings
        from fabtools import require

        with settings(mysql_user='root', mysql_password='s3cr3t'):
            require.mysql.user('dbuser', 'somerandomstring')

    """
    if not user_exists(name, **kwargs):
        create_user(name, password, **kwargs)


def database(name, **kwargs):
    """
    Require a MySQL database.

    Extra arguments will be passed to :py:func:`fabtools.mysql.create_database`.

    Example::

        from fabric.api import settings
        from fabtools import require

        with settings(mysql_user='root', mysql_password='s3cr3t'):
            require.mysql.database('myapp', owner='dbuser')

    """
    if not database_exists(name, **kwargs):
        create_database(name, **kwargs)

########NEW FILE########
__FILENAME__ = nginx
"""
Nginx
=====

This module provides high-level tools for installing the `nginx`_
web server and managing the configuration of web sites.

.. _nginx: http://nginx.org/

"""
from __future__ import with_statement

from fabric.api import (
    abort,
    hide,
    settings,
)
from fabric.colors import red

from fabtools.deb import is_installed
from fabtools.files import is_link
from fabtools.nginx import disable, enable
from fabtools.require.deb import package
from fabtools.require.files import template_file
from fabtools.require.service import started as require_started
from fabtools.service import reload as reload_service
from fabtools.utils import run_as_root


def server(package_name='nginx'):
    """
    Require the nginx web server to be installed and running.

    You can override the system package name, if you need to install
    a specific variant such as `nginx-extras` or `nginx-light`.

    ::

        from fabtools import require

        require.nginx.server()

    """
    package(package_name)
    require_started('nginx')


def enabled(config):
    """
    Require an nginx site to be enabled.

    This will cause nginx to reload its configuration.

    ::

        from fabtools import require

        require.nginx.enabled('mysite')

    """
    enable(config)
    reload_service('nginx')


def disabled(config):
    """
    Require an nginx site to be disabled.

    This will cause nginx to reload its configuration.

    ::

        from fabtools import require

        require.nginx.site_disabled('default')

    """
    disable(config)
    reload_service('nginx')


def site(server_name, template_contents=None, template_source=None,
         enabled=True, check_config=True, **kwargs):
    """
    Require an nginx site.

    You must provide a template for the site configuration, either as a
    string (*template_contents*) or as the path to a local template
    file (*template_source*).

    ::

        from fabtools import require

        CONFIG_TPL = '''
        server {
            listen      %(port)d;
            server_name %(server_name)s %(server_alias)s;
            root        %(docroot)s;
            access_log  /var/log/nginx/%(server_name)s.log;
        }'''

        require.nginx.site('example.com',
            template_contents=CONFIG_TPL,
            port=80,
            server_alias='www.example.com',
            docroot='/var/www/mysite',
        )

    .. seealso:: :py:func:`fabtools.require.files.template_file`
    """
    if not is_installed('nginx-common'):
        # nginx-common is always installed if nginx exists
        server()

    config_filename = '/etc/nginx/sites-available/%s.conf' % server_name

    context = {
        'port': 80,
    }
    context.update(kwargs)
    context['server_name'] = server_name

    template_file(config_filename, template_contents, template_source, context, use_sudo=True)

    link_filename = '/etc/nginx/sites-enabled/%s.conf' % server_name
    if enabled:
        if not is_link(link_filename):
            run_as_root("ln -s %(config_filename)s %(link_filename)s" % locals())

        # Make sure we don't break the config
        if check_config:
            with settings(hide('running', 'warnings'), warn_only=True):
                if run_as_root('nginx -t').failed:
                    run_as_root("rm %(link_filename)s" % locals())
                    message = red("Error in %(server_name)s nginx site config (disabling for safety)" % locals())
                    abort(message)
    else:
        if is_link(link_filename):
            run_as_root("rm %(link_filename)s" % locals())

    reload_service('nginx')


PROXIED_SITE_TEMPLATE = """\
server {
    listen %(port)s;
    server_name %(server_name)s;

    gzip_vary on;

    # path for static files
    root %(docroot)s;

    try_files $uri @proxied;

    location @proxied {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_pass %(proxy_url)s;
    }

    access_log /var/log/nginx/%(server_name)s.log;
}
"""


def proxied_site(server_name, enabled=True, **kwargs):
    """
    Require an nginx site for a proxied app.

    This uses a predefined configuration template suitable for proxying
    requests to a backend application server.

    Required keyword arguments are:

    - *port*: the port nginx should listen on
    - *proxy_url*: URL of backend application server
    - *docroot*: path to static files

    ::

        from fabtools import require

        require.nginx.proxied_site('example.com',
            port=80,
            proxy_url='http://127.0.0.1:8080/',
            docroot='/path/to/myapp/static',
        )
    """
    site(server_name, template_contents=PROXIED_SITE_TEMPLATE,
         enabled=enabled, **kwargs)

########NEW FILE########
__FILENAME__ = nodejs
"""
Node.js
=======

This module provides tools for installing `Node.js`_ and managing
packages using `npm`_.

.. note: the ``simplejson`` module is required on Python 2.5

.. _Node.js: http://nodejs.org/
.. _npm: http://npmjs.org/

"""
from fabtools import nodejs


def installed_from_source(version=nodejs.DEFAULT_VERSION):
    """
    Require Node.js to be installed from source.

    ::

        from fabtools import require

        require.nodejs.installed_from_source()

    """
    if nodejs.version() != version:
        nodejs.install_from_source(version)


def package(pkg_name, version=None, local=False):
    """
    Require a Node.js package.

    If the package is not installed, and no *version* is specified, the
    latest available version will be installed.

    If a *version* is specified, and a different version of the package
    is already installed, it will be updated to the specified version.

    If `local` is ``True``, the package will be installed locally.

    ::

        from fabtools import require

        # Install package system-wide
        require.nodejs.package('foo')

        # Install package locally
        require.nodejs.package('bar', local=True)

    """
    pkg_version = nodejs.package_version(pkg_name, local=local)
    if version:
        if pkg_version != version:
            nodejs.install_package(pkg_name, version, local=local)
    else:
        if pkg_version is None:
            nodejs.install_package(pkg_name, local=local)

########NEW FILE########
__FILENAME__ = openvz
"""
OpenVZ containers
=================

This module provides high-level tools for managing OpenVZ_ templates
and containers.

.. _OpenVZ: http://openvz.org/

.. warning:: The remote host needs a patched kernel with OpenVZ support.

"""
import os

from fabtools import openvz
from fabtools.files import is_file
from fabtools.openvz.container import Container


def template(name=None, url=None):
    """
    Require an OpenVZ OS template.

    If the OS template is not installed yet, it will be downloaded from
    *url* using :py:func:`~fabtools.openvz.download_template()`::

        from fabtools import require

        # Use custom OS template
        require.openvz.template(url='http://example.com/templates/mybox.tar.gz')

    If no *url* is provided, :py:func:`~fabtools.openvz.download_template()`
    will attempt to download the OS template from the
    `download.openvz.org <http://download.openvz.org/template/precreated/>`_
    repository::

        from fabtools import require

        # Use OS template from http://download.openvz.org/template/precreated/
        require.openvz.template('debian-6.0-x86_64')

    """
    if name is not None:
        filename = '%s.tar.gz' % name
    else:
        filename = os.path.basename(url)

    if not is_file(os.path.join('/var/lib/vz/template/cache', filename)):
        openvz.download_template(name, url)


def container(name, ostemplate, **kwargs):
    """
    Require an OpenVZ container.

    If it does not exist, the container will be created using the
    specified OS template
    (see :py:func:`fabtools.require.openvz.template()`).

    Extra args will be passed to :py:func:`fabtools.openvz.create()`::

        from fabtools import require

        require.openvz.container('foo', 'debian', ipadd='1.2.3.4')

    This function returns a :py:class:`fabtools.openvz.Container`
    object, that can be used to perform further operations::

        from fabtools.require.openvz import container

        ct = container('foo', 'debian')
        ct.set('ipadd', '1.2.3.4')
        ct.start()
        ct.exec2('hostname')

    This function can also be used as a context manager::

        from fabtools.require.openvz import container

        with container('foo', 'debian') as ct:
            ct.set('ipadd', '1.2.3.4')
            ct.start()
            ct.exec2('hostname')

    """
    if not openvz.exists(name):
        ctid = openvz.get_available_ctid()
        openvz.create(ctid, ostemplate=ostemplate, **kwargs)
        openvz.set(ctid, name=name)
    return Container(name)

########NEW FILE########
__FILENAME__ = opkg
"""
opkg packages
===============

This module provides high-level tools for managing opkg packages
and repositories.

"""
from __future__ import with_statement

from fabtools.opkg import (
    install,
    is_installed,
    uninstall,
    update_index,
)


def package(pkg_name, update=False):
    """
    Require a opkg package to be installed.

    Example::

        from fabtools import require

        # Require a package
        require.opkg.package('foo')

    """
    if not is_installed(pkg_name):
        install(pkg_name, update=update)


def packages(pkg_list, update=False):
    """
    Require several opkg packages to be installed.

    Example::

        from fabtools import require

        require.opkg.packages([
            'foo',
            'bar',
            'baz',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg)]
    if pkg_list:
        install(pkg_list, update)


def nopackage(pkg_name):
    """
    Require a opkg package to be uninstalled.

    Example::

        from fabtools import require

        require.opkg.nopackage('apache2')
    """
    if is_installed(pkg_name):
        uninstall(pkg_name)


def nopackages(pkg_list):
    """
    Require several opkg packages to be uninstalled.

    Example::

        from fabtools import require

        require.opkg.nopackages([
            'perl',
            'php5',
            'ruby',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)]
    if pkg_list:
        uninstall(pkg_list)


########NEW FILE########
__FILENAME__ = oracle_jdk
"""
Oracle JDK
============

This module provides tools for installing `Oracle JDK`_

.. _Oracle JDK: http://www.oracle.com/technetwork/java/javase/

"""
from fabtools import oracle_jdk


def installed(version=oracle_jdk.DEFAULT_VERSION):
    """
    Require Oracle JDK to be installed.

    ::

        from fabtools import require

        require.oracle_jdk.installed()

    """
    if oracle_jdk.version() != version:
        oracle_jdk.install_from_oracle_site(version)

########NEW FILE########
__FILENAME__ = pkg
"""
SmartOS packages
================

This module provides high-level tools to manage `SmartOS`_ packages.

.. _SmartOS: http://smartos.org/

"""
from __future__ import with_statement

from fabtools.pkg import (
    install,
    is_installed,
    uninstall,
)


def package(pkg_name, update=False, yes=None):
    """
    Require a SmartOS package to be installed.

    ::

        from fabtools import require

        require.pkg.package('foo')
    """
    if not is_installed(pkg_name):
        install(pkg_name, update, yes)


def packages(pkg_list, update=False):
    """
    Require several SmartOS packages to be installed.

    ::

        from fabtools import require

        require.pkg.packages([
            'top',
            'unzip',
            'zip',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg)]
    if pkg_list:
        install(pkg_list, update)


def nopackage(pkg_name, orphan=True):
    """
    Require a SmartOS package to be uninstalled.

    ::

        from fabtools import require

        require.pkg.nopackage('top')
    """
    if is_installed(pkg_name):
        uninstall(pkg_name, orphan)


def nopackages(pkg_list, orphan=True):
    """
    Require several SmartOS packages to be uninstalled.

    ::

        from fabtools import require

        require.pkg.nopackages([
            'top',
            'zip',
            'unzip',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)]
    if pkg_list:
        uninstall(pkg_list, orphan)

########NEW FILE########
__FILENAME__ = portage
# -*- coding: utf-8 -*-
"""
Gentoo packages
===============

This module provides high-level tools for managing Gentoo packages
and repositories using the Portage_ package manager.

.. _Portage: http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=2&chap=1

"""
from __future__ import with_statement

from fabtools.portage import (
    install,
    is_installed,
    uninstall,
    update_index,
)


def package(pkg_name, update=False):
    """
    Require a Portage package to be installed.

    Example::

        from fabtools import require

        require.portage.package('foo')
    """
    if not is_installed(pkg_name):
        install(pkg_name, update)


def packages(pkg_list, update=False):
    """
    Require several Portage packages to be installed.

    Example::

        from fabtools import require

        require.portage.packages([
            'foo',
            'bar',
            'baz',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg)]
    if pkg_list:
        install(pkg_list, update)


def nopackage(pkg_name):
    """
    Require a Portage package to be uninstalled.

    Example::

        from fabtools import require

        require.portage.nopackage('apache2')
    """
    if is_installed(pkg_name):
        uninstall(pkg_name)


def nopackages(pkg_list):
    """
    Require several Portage packages to be uninstalled.

    Example::

        from fabtools import require

        require.portage.nopackages([
            'perl',
            'php5',
            'ruby',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)]
    if pkg_list:
        uninstall(pkg_list)

########NEW FILE########
__FILENAME__ = postfix
"""
Postfix
=======

This module provides high-level tools for managing the Postfix_ email server.

.. _Postfix: http://www.postfix.org/

"""

from fabtools.deb import (
    install,
    is_installed,
    preseed_package,
)
from fabtools.require.service import started


def server(mailname):
    """
    Require a Postfix email server.

    This makes sure that Postfix is installed and started.

    ::

        from fabtools import require

        # Handle incoming email for our domain
        require.postfix.server('example.com')

    """

    # Ensure the package is installed
    if not is_installed('postfix'):
        preseed_package('postfix', {
            'postfix/main_mailer_type': ('select', 'Internet Site'),
            'postfix/mailname': ('string', mailname),
            'postfix/destinations': ('string', '%s, localhost.localdomain, localhost ' % mailname),
        })
        install('postfix')

    # Ensure the service is started
    started('postfix')

########NEW FILE########
__FILENAME__ = postgres
"""
PostgreSQL users and databases
==============================
"""
from __future__ import with_statement

from fabric.api import cd, hide, run, settings
from fabtools.files import is_file
from fabtools.postgres import (
    create_database,
    create_user,
    database_exists,
    user_exists,
)
from fabtools.require.deb import package
from fabtools.require.service import started, restarted
from fabtools.require.system import locale as require_locale


def _service_name(version=None):

    if is_file('/etc/init.d/postgresql'):
        return 'postgresql'

    if version and is_file('/etc/init.d/postgresql-%s' % version):
        return 'postgresql-%s' % version

    with cd('/etc/init.d'):
        with settings(hide('running', 'stdout')):
            return run('ls postgresql-*').splitlines()[0]


def server(version=None):
    """
    Require a PostgreSQL server to be installed and running.

    ::

        from fabtools import require

        require.postgres.server()

    """
    if version:
        pkg_name = 'postgresql-%s' % version
    else:
        pkg_name = 'postgresql'
    package(pkg_name)

    started(_service_name(version))


def user(name, password, superuser=False, createdb=False,
         createrole=False, inherit=True, login=True, connection_limit=None,
         encrypted_password=False):
    """
    Require the existence of a PostgreSQL user.

    The password and options provided will only be applied when creating
    a new user (existing users will *not* be modified).

    ::

        from fabtools import require

        require.postgres.user('dbuser', password='somerandomstring')

        require.postgres.user('dbuser2', password='s3cr3t',
            createdb=True, create_role=True, connection_limit=20)

    """
    if not user_exists(name):
        create_user(name, password, superuser, createdb, createrole, inherit,
                    login, connection_limit, encrypted_password)


def database(name, owner, template='template0', encoding='UTF8',
             locale='en_US.UTF-8'):
    """
    Require a PostgreSQL database.

    ::

        from fabtools import require

        require.postgres.database('myapp', owner='dbuser')

    """
    if not database_exists(name):

        if locale not in run('locale -a').split():
            require_locale(locale)
            restarted(_service_name())

        create_database(name, owner, template=template, encoding=encoding,
                        locale=locale)

########NEW FILE########
__FILENAME__ = python
"""
Python environments and packages
================================

This module provides high-level tools for using Python `virtual environments`_
and installing Python packages using the `pip`_ installer.

.. _virtual environments: http://www.virtualenv.org/
.. _pip: http://www.pip-installer.org/

"""

from fabtools.python import (
    create_virtualenv,
    install,
    install_pip,
    install_requirements,
    is_installed,
    is_pip_installed,
    virtualenv_exists,
)
from fabtools.python_setuptools import (
    install_setuptools,
    is_setuptools_installed,
)
from fabtools.system import UnsupportedFamily, distrib_family


MIN_SETUPTOOLS_VERSION = '0.7'
MIN_PIP_VERSION = '1.5'


def setuptools(version=MIN_SETUPTOOLS_VERSION, python_cmd='python'):
    """
    Require `setuptools`_ to be installed.

    If setuptools is not installed, or if a version older than *version*
    is installed, the latest version will be installed.

    .. _setuptools: http://pythonhosted.org/setuptools/
    """

    from fabtools.require.deb import package as require_deb_package
    from fabtools.require.rpm import package as require_rpm_package

    if not is_setuptools_installed(python_cmd=python_cmd):
        family = distrib_family()

        if family == 'debian':
            require_deb_package('python-dev')
        elif family == 'redhat':
            require_rpm_package('python-devel')
        else:
            raise UnsupportedFamily(supported=['debian', 'redhat'])

        install_setuptools(python_cmd=python_cmd)


def pip(version=MIN_PIP_VERSION, pip_cmd='pip', python_cmd='python'):
    """
    Require `pip`_ to be installed.

    If pip is not installed, or if a version older than *version*
    is installed, the latest version will be installed.

    .. _pip: http://www.pip-installer.org/
    """
    setuptools(python_cmd=python_cmd)
    if not is_pip_installed(version, pip_cmd=pip_cmd):
        install_pip(python_cmd=python_cmd)


def package(pkg_name, url=None, pip_cmd='pip', python_cmd='python',
            allow_external=False, allow_unverified=False, **kwargs):
    """
    Require a Python package.

    If the package is not installed, it will be installed
    using the `pip installer`_.

    Package names are case insensitive.

    Starting with version 1.5, pip no longer scrapes insecure external
    urls by default and no longer installs externally hosted files by
    default. Use ``allow_external=True`` or ``allow_unverified=True``
    to change these behaviours.

    ::

        from fabtools.python import virtualenv
        from fabtools import require

        # Install package system-wide (not recommended)
        require.python.package('foo', use_sudo=True)

        # Install package in an existing virtual environment
        with virtualenv('/path/to/venv'):
            require.python.package('bar')

    .. _pip installer: http://www.pip-installer.org/
    """
    pip(MIN_PIP_VERSION, python_cmd=python_cmd)
    if not is_installed(pkg_name, pip_cmd=pip_cmd):
        install(url or pkg_name,
                pip_cmd=pip_cmd,
                allow_external=[url or pkg_name] if allow_external else [],
                allow_unverified=[url or pkg_name] if allow_unverified else [],
                **kwargs)


def packages(pkg_list, pip_cmd='pip', python_cmd='python',
             allow_external=None, allow_unverified=None, **kwargs):
    """
    Require several Python packages.

    Package names are case insensitive.

    Starting with version 1.5, pip no longer scrapes insecure external
    urls by default and no longer installs externally hosted files by
    default. Use ``allow_external=['foo', 'bar']`` or
    ``allow_unverified=['bar', 'baz']`` to change these behaviours
    for specific packages.
    """
    if allow_external is None:
        allow_external = []

    if allow_unverified is None:
        allow_unverified = []

    pip(MIN_PIP_VERSION, python_cmd=python_cmd)

    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg, pip_cmd=pip_cmd)]
    if pkg_list:
        install(pkg_list,
                pip_cmd=pip_cmd,
                allow_external=allow_external,
                allow_unverified=allow_unverified,
                **kwargs)


def requirements(filename, pip_cmd='pip', python_cmd='python',
                 allow_external=None, allow_unverified=None, **kwargs):
    """
    Require Python packages from a pip `requirements file`_.

    Starting with version 1.5, pip no longer scrapes insecure external
    urls by default and no longer installs externally hosted files by
    default. Use ``allow_external=['foo', 'bar']`` or
    ``allow_unverified=['bar', 'baz']`` to change these behaviours
    for specific packages.

    ::

        from fabtools.python import virtualenv
        from fabtools import require

        # Install requirements in an existing virtual environment
        with virtualenv('/path/to/venv'):
            require.python.requirements('requirements.txt')

    .. _requirements file: http://www.pip-installer.org/en/latest/requirements.html
    """
    pip(MIN_PIP_VERSION, python_cmd=python_cmd)
    install_requirements(filename, pip_cmd=pip_cmd, allow_external=allow_external,
                         allow_unverified=allow_unverified, **kwargs)


def virtualenv(directory, system_site_packages=False, venv_python=None,
               use_sudo=False, user=None, clear=False, prompt=None,
               virtualenv_cmd='virtualenv', pip_cmd='pip', python_cmd='python'):
    """
    Require a Python `virtual environment`_.

    ::

        from fabtools import require

        require.python.virtualenv('/path/to/venv')

    .. _virtual environment: http://www.virtualenv.org/
    """

    package('virtualenv', use_sudo=True, pip_cmd=pip_cmd, python_cmd=python_cmd)

    if not virtualenv_exists(directory):
        create_virtualenv(
            directory,
            system_site_packages=system_site_packages,
            venv_python=venv_python,
            use_sudo=use_sudo,
            user=user,
            clear=clear,
            prompt=prompt,
            virtualenv_cmd=virtualenv_cmd,
        )

########NEW FILE########
__FILENAME__ = redis
"""
Redis
=====

This module provides high-level tools for managing `Redis`_ instances.

.. _Redis: http://redis.io/

"""
from __future__ import with_statement

from fabric.api import cd, run, settings

from fabtools.files import is_file, watch
from fabtools.system import distrib_family
from fabtools.utils import run_as_root
import fabtools.supervisor


VERSION = '2.6.16'

BINARIES = [
    'redis-benchmark',
    'redis-check-aof',
    'redis-check-dump',
    'redis-cli',
    'redis-sentinel',
    'redis-server',
]


def installed_from_source(version=VERSION):
    """
    Require Redis to be installed from source.

    The compiled binaries will be installed in ``/opt/redis-{version}/``.
    """
    from fabtools.require import directory as require_directory
    from fabtools.require import file as require_file
    from fabtools.require import user as require_user
    from fabtools.require.deb import packages as require_deb_packages
    from fabtools.require.rpm import packages as require_rpm_packages

    family = distrib_family()

    if family == 'debian':
        require_deb_packages([
            'build-essential',
        ])

    elif family == 'redhat':
        require_rpm_packages([
            'gcc',
            'make',
        ])

    require_user('redis', home='/var/lib/redis', system=True)
    require_directory('/var/lib/redis', owner='redis', use_sudo=True)

    dest_dir = '/opt/redis-%(version)s' % locals()
    require_directory(dest_dir, use_sudo=True, owner='redis')

    if not is_file('%(dest_dir)s/redis-server' % locals()):

        with cd('/tmp'):

            # Download and unpack the tarball
            tarball = 'redis-%(version)s.tar.gz' % locals()
            url = _download_url(version) + tarball
            require_file(tarball, url=url)
            run('tar xzf %(tarball)s' % locals())

            # Compile and install binaries
            with cd('redis-%(version)s' % locals()):
                run('make')

                for filename in BINARIES:
                    run_as_root('cp -pf src/%(filename)s %(dest_dir)s/' % locals())
                    run_as_root('chown redis: %(dest_dir)s/%(filename)s' % locals())


def _download_url(version):
    if _parse_version(version) <= (2, 6, 14):
        return 'http://redis.googlecode.com/files/'
    else:
        return 'http://download.redis.io/releases/'


def _parse_version(version):
    return tuple(map(int, version.split('.')))


def instance(name, version=VERSION, bind='127.0.0.1', port=6379, **kwargs):
    """
    Require a Redis instance to be running.

    The required Redis version will be automatically installed using
    :py:func:`fabtools.require.redis.installed_from_source` if needed.

    You can specify the IP address and port on which to listen to using the
    *bind* and *port* parameters.

    .. warning::
        Redis is designed to be accessed by trusted clients inside trusted
        environments. It is usually not a good idea to expose the Redis
        instance directly to the internet. Therefore, with the default
        settings, the Redis instance will only listen to local clients.

    If you want to make your Redis instance accessible to other servers
    over an untrusted network, you should probably add some firewall rules
    to restrict access. For example: ::

            from fabtools import require
            from fabtools.shorewall import Ping, SSH, hosts, rule

            # The computers that will need to talk to the Redis server
            REDIS_CLIENTS = [
                'web1.example.com',
                'web2.example.com',
            ]

            # The Redis server port
            REDIS_PORT = 6379

            # Setup a basic firewall
            require.shorewall.firewall(
                rules=[
                    Ping(),
                    SSH(),
                    rule(port=REDIS_PORT, source=hosts(REDIS_CLIENTS)),
                ]
            )

            # Make the Redis instance listen on all interfaces
            require.redis.instance('mydb', bind='0.0.0.0', port=REDIS_PORT)

    .. seealso:: `Redis Security <http://redis.io/topics/security>`_

    You can also use any valid Redis configuration directives as extra
    keyword arguments. For directives that can be repeated on multiple
    lines (such as ``save``), you can supply a list of values.

    The instance will be managed using supervisord, as a process named
    ``redis_{name}``, running as the ``redis`` user.

    ::

        from fabtools import require
        from fabtools.supervisor import process_status

        require.redis.instance('mydb')

        print process_status('redis_mydb')

    .. seealso:: :ref:`supervisor_module` and
                 :ref:`require_supervisor_module`

    The default settings enable persistence using periodic RDB snapshots
    saved in the `/var/db/redis` directory.

    You may want to use AOF persistence instead: ::

        require.redis.instance('mydb', appendonly='yes', save=[])

    In certain situations, you may want to disable persistence completely: ::

        require.redis.instance('cache', port=6380, save=[])

    .. seealso:: `Redis Persistence <http://redis.io/topics/persistence>`_

    """
    from fabtools.require import directory as require_directory
    from fabtools.require import file as require_file
    from fabtools.require.supervisor import process as require_process
    from fabtools.require.system import sysctl as require_sysctl

    installed_from_source(version)

    require_directory('/etc/redis', use_sudo=True, owner='redis')
    require_directory('/var/db/redis', use_sudo=True, owner='redis')
    require_directory('/var/log/redis', use_sudo=True, owner='redis')

    # Required for background saving
    with settings(warn_only=True):
        require_sysctl('vm.overcommit_memory', '1')

    # Set default parameters
    params = {}
    params.update(kwargs)
    params.setdefault('bind', bind)
    params.setdefault('port', port)
    params.setdefault('logfile', '/var/log/redis/redis-%(name)s.log' % locals())
    params.setdefault('loglevel', 'verbose')
    params.setdefault('dir', '/var/db/redis')
    params.setdefault('dbfilename', 'redis-%(name)s-dump.rdb' % locals())
    params.setdefault('save', ['900 1', '300 10', '60 10000'])

    # Build config file from parameters
    # (keys such as 'save' may result in multiple config lines)
    lines = []
    for key, value in sorted(params.items()):
        if isinstance(value, list):
            for elem in value:
                lines.append("%s %s" % (key, elem))
        else:
            lines.append("%s %s" % (key, value))

    redis_server = '/opt/redis-%(version)s/redis-server' % locals()
    config_filename = '/etc/redis/%(name)s.conf' % locals()

    # Upload config file
    with watch(config_filename, use_sudo=True) as config:
        require_file(config_filename, contents='\n'.join(lines),
                     use_sudo=True, owner='redis')

    # Use supervisord to manage process
    process_name = 'redis_%s' % name
    require_process(
        process_name,
        user='redis',
        directory='/var/run',
        command="%(redis_server)s %(config_filename)s" % locals(),
    )

    # Restart if needed
    if config.changed:
        fabtools.supervisor.restart_process(process_name)

########NEW FILE########
__FILENAME__ = rpm
"""
RPM packages
============

This module provides high-level tools for managing CentOS/RHEL/SL/Fedora
packages and repositories.

"""
from __future__ import with_statement

from fabric.api import hide, settings
from fabtools.rpm import (
    install,
    is_installed,
    uninstall,
)
from fabtools.system import get_arch, distrib_release
from fabtools.utils import run_as_root


def package(pkg_name, repos=None, yes=None, options=None):
    """
    Require an RPM package to be installed.

    Example::

        from fabtools import require

        require.rpm.package('emacs')
    """
    if not is_installed(pkg_name):
        install(pkg_name, repos, yes, options)


def packages(pkg_list, repos=None, yes=None, options=None):
    """
    Require several RPM packages to be installed.

    Example::

        from fabtools import require

        require.rpm.packages([
            'nano',
            'unzip',
            'vim',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if not is_installed(pkg)]
    if pkg_list:
        install(pkg_list, repos, yes, options)


def nopackage(pkg_name, options=None):
    """
    Require an RPM package to be uninstalled.

    Example::

        from fabtools import require

        require.rpm.nopackage('emacs')
    """
    if is_installed(pkg_name):
        uninstall(pkg_name, options)


def nopackages(pkg_list, options=None):
    """
    Require several RPM packages to be uninstalled.

    Example::

        from fabtools import require

        require.rpm.nopackages([
            'unzip',
            'vim',
            'emacs',
        ])
    """
    pkg_list = [pkg for pkg in pkg_list if is_installed(pkg)]
    if pkg_list:
        uninstall(pkg_list, options)


def repository(name):
    """
    Require a repository. Aimed for 3rd party repositories.

    *Name* currently only supports EPEL and RPMforge.

    Example::

        from fabtools import require

        # RPMforge packages for CentOS 6
        require.rpm.repository('rpmforge')


    """
    name = name.lower()
    epel_url = 'http://download.fedoraproject.org/pub/epel'
    rpmforge_url = 'http://packages.sw.be/rpmforge-release/rpmforge-release'
    rpmforge_version = '0.5.2-2'
    arch = get_arch()
    try:
        release = int(str(distrib_release()))
    except ValueError:
        release = int(float(str(distrib_release())))
    if release == 6:
        epel_version = '6-8'
    elif release == 5:
        epel_version = '5-4'
    if name == 'rpmforge' and arch == 'i386':
        arch = 'i686'
    supported = {
        'rpmforge': {
            '%(arch)s' % locals(): {
                '6': '%(rpmforge_url)s-%(rpmforge_version)s.el6.rf.i686.rpm' % locals(),
                '5': '%(rpmforge_url)s-%(rpmforge_version)s.el5.rf.x86_64.rpm' % locals(),
            },
        },
        'epel': {
            '%(arch)s' % locals(): {
                '6': '%(epel_url)s/6/%(arch)s/epel-release-%(epel_version)s.noarch.rpm' % locals(),
                '5': '%(epel_url)s/5/%(arch)s/epel-release-%(epel_version)s.noarch.rpm' % locals(),
            }
        },
    }
    keys = {
        'rpmforge': 'http://apt.sw.be/RPM-GPG-KEY.dag.txt',
        'epel': '%(epel_url)s/RPM-GPG-KEY-EPEL-%(release)s' % locals(),
    }
    repo = supported[name][str(arch)][str(release)]
    key = keys[name]
    with settings(hide('warnings'), warn_only=True):
        run_as_root('rpm --import %(key)s' % locals())
        run_as_root('rpm -Uh %(repo)s' % locals())

########NEW FILE########
__FILENAME__ = service
"""
System services
===============

This module provides high-level tools for managing system services.
The underlying operations use the ``service`` command, allowing to
support both `upstart`_ services and traditional SysV-style
``/etc/init.d/`` scripts.

.. _upstart: http://upstart.ubuntu.com/

"""

from fabtools.service import is_running, restart, start, stop
from fabtools.system import using_systemd
import fabtools.systemd as systemd


def started(service):
    """
    Require a service to be started.

    ::

        from fabtools import require

        require.service.started('foo')
    """
    if not is_running(service):
        if using_systemd():
            systemd.start(service)
        else:
            start(service)


def stopped(service):
    """
    Require a service to be stopped.

    ::

        from fabtools import require

        require.service.stopped('foo')
    """
    if is_running(service):
        if using_systemd():
            systemd.stop(service)
        else:
            stop(service)


def restarted(service):
    """
    Require a service to be restarted.

    ::

        from fabtools import require

        require.service.restarted('foo')
    """
    if is_running(service):
        if using_systemd():
            systemd.restart(service)
        else:
            restart(service)
    else:
        if using_systemd():
            systemd.start(service)
        else:
            start(service)


__all__ = ['started', 'stopped', 'restarted']

########NEW FILE########
__FILENAME__ = shorewall
"""
Shorewall firewall
==================
"""
from __future__ import with_statement

from fabric.api import hide, puts, settings, shell_env
from fabric.contrib.files import sed

from fabtools.files import watch
from fabtools.service import start, stop, restart
from fabtools.shorewall import (
    Ping,
    SSH,
    HTTP,
    HTTPS,
    SMTP,
    is_started,
    is_stopped,
)

from fabtools.require.deb import package
from fabtools.require.files import file


DEFAULT_ZONES = [
    {
        'name': 'fw',
        'type': 'firewall',
    },
    {
        'name': 'net',
        'type': 'ipv4',
    },
]

ZONE_HEADER = '#ZONE\tTYPE\tOPTIONS\tIN OPTIONS\tOUT OPTIONS\n'

ZONE_FORMAT = '%(name)s\t%(type)s\t%(options)s\t%(in_options)s\t%(out_options)s\n'


def _zone_config(zones):
    """
    Zone configuration
    """
    if zones is None:
        zones = DEFAULT_ZONES

    lines = [ZONE_HEADER]
    for entry in zones:
        entry.setdefault('options', '')
        entry.setdefault('in_options', '')
        entry.setdefault('out_options', '')
        lines.append(ZONE_FORMAT % entry)

    file('/etc/shorewall/zones', contents=''.join(lines), use_sudo=True)


DEFAULT_INTERFACES = [
    {
        'zone': 'net',
        'interface': 'eth0',
    },
]

INTERFACES_HEADER = '#ZONE\tINTERFACE\tBROADCAST\tOPTIONS\n'

INTERFACES_FORMAT = '%(zone)s\t%(interface)s\t%(broadcast)s\t%(options)s\n'


def _interfaces_config(interfaces):
    """
    Interfaces configuration
    """
    if interfaces is None:
        interfaces = DEFAULT_INTERFACES

    lines = [INTERFACES_HEADER]
    for entry in interfaces:
        entry.setdefault('zone', 'net')
        entry.setdefault('broadcast', 'detect')
        entry.setdefault('options', '')
        lines.append(INTERFACES_FORMAT % entry)

    file('/etc/shorewall/interfaces', contents=''.join(lines), use_sudo=True)


DEFAULT_POLICY = [
    {
        'source': '$FW',
        'dest': 'net',
        'policy': 'ACCEPT',
    },
    {
        'source': 'net',
        'dest': 'all',
        'policy': 'DROP',
        'log_level': 'info',
    },
    {
        'source': 'all',
        'dest': 'all',
        'policy': 'REJECT',
        'log_level': 'info',
    },
]

POLICY_HEADER = '''\
#SOURCE\tDEST\tPOLICY\tLOG  \tBURST:LIMIT
#      \t    \t      \tLEVEL
'''

POLICY_FORMAT = '%(source)s\t%(dest)s\t%(policy)s\t%(log_level)s\t%(burst_limit)s\n'


def _policy_config(policy):
    """
    Policy configuration
    """
    if policy is None:
        policy = DEFAULT_POLICY

    lines = [POLICY_HEADER]
    for entry in policy:
        entry.setdefault('log_level', '')
        entry.setdefault('burst_limit', '')
        lines.append(POLICY_FORMAT % entry)

    file('/etc/shorewall/policy', contents=''.join(lines), use_sudo=True)


DEFAULT_RULES = [
    Ping(),
    SSH(),
    HTTP(),
    HTTPS(),
    SMTP(port=[25, 587]),
]


RULES_HEADER = '''\
#ACTION\tSOURCE\tDEST\tPROTO\tDEST   \tSOURCE \tORIG\tRATE \tUSER/\tMARK\tCONN \tTIME
#      \t      \t    \t     \tPORT(S)\tPORT(S)\tDEST\tLIMIT\tGROUP\t    \tLIMIT
'''

RULES_FORMAT = '%(action)s\t%(source)s\t%(dest)s\t%(proto)s\t%(dest_port)s\t%(source_port)s\t%(original_dest)s\t%(rate_limit)s\t%(user)s\t%(mark)s\t%(conn_limit)s\t%(time)s\n'


def _rules_config(rules):
    """
    Policy configuration
    """
    if rules is None:
        rules = DEFAULT_RULES

    lines = [RULES_HEADER]
    for entry in rules:
        entry.setdefault('proto', 'tcp')
        entry.setdefault('dest_port', '-')
        entry.setdefault('source_port', '-')
        entry.setdefault('original_dest', '-')
        entry.setdefault('rate_limit', '-')
        entry.setdefault('user', '-')
        entry.setdefault('mark', '-')
        entry.setdefault('conn_limit', '-')
        entry.setdefault('time', '-')

        if isinstance(entry['dest_port'], list):
            entry['dest_port'] = ','.join(map(str, entry['dest_port']))

        if isinstance(entry['source_port'], list):
            entry['source_port'] = ','.join(map(str, entry['source_port']))

        lines.append(RULES_FORMAT % entry)

    file('/etc/shorewall/rules', contents=''.join(lines), use_sudo=True)


ROUTESTOPPED_HEADER = '''\
#INTERFACE\tHOST(S)\tOPTIONS\tPROTO\tDEST   \tSOURCE
#         \t       \t       \t     \tPORT(S)\tPORT(S)
'''

ROUTESTOPPED_FORMAT = '%(interface)s\t%(host)s\t%(options)s\t%(proto)s\t%(dest_port)s\t%(source_port)s\n'


def _routestopped_config(routestopped):
    """
    Routestopped configuration

    This lists the hosts that should be accessible
    when the firewall is stopped or starting.
    """
    if routestopped is None:
        routestopped = []

    lines = [ROUTESTOPPED_HEADER]
    for entry in routestopped:
        entry.setdefault('interface', 'eth0')
        entry.setdefault('host', '0.0.0.0/0')
        entry.setdefault('options', '-')
        entry.setdefault('proto', '-')
        entry.setdefault('dest_port', '-')
        entry.setdefault('source_port', '-')

        if isinstance(entry['host'], list):
            entry['host'] = ','.join(entry['host'])

        if isinstance(entry['options'], list):
            entry['options'] = ','.join(entry['options'])

        lines.append(ROUTESTOPPED_FORMAT % entry)

    file('/etc/shorewall/routestopped', contents=''.join(lines), use_sudo=True)


MASQ_HEADER = '''\
#INTERFACE\tSOURCE\tADDRESS\tPROTO\tPORT(S)
'''

MASQ_FORMAT = '%(interface)s\t%(source)s\t%(address)s\t%(proto)s\t%(port)s\n'


def _masq_config(masq):
    """
    Masquerading/SNAT configuration
    """
    if masq is None:
        masq = []

    lines = [MASQ_HEADER]
    for entry in masq:
        entry.setdefault('interface', 'eth0')
        entry.setdefault('address', '-')
        entry.setdefault('proto', '-')
        entry.setdefault('port', '-')

        if isinstance(entry['source'], list):
            entry['source'] = ','.join(entry['source'])

        lines.append(MASQ_FORMAT % entry)

    file('/etc/shorewall/masq', contents=''.join(lines), use_sudo=True)


CONFIG_FILES = [
    '/etc/shorewall/interfaces',
    '/etc/shorewall/masq',
    '/etc/shorewall/policy',
    '/etc/shorewall/routestopped',
    '/etc/shorewall/rules',
    '/etc/shorewall/zones',
]


def firewall(zones=None, interfaces=None, policy=None, rules=None,
             routestopped=None, masq=None):
    """
    Ensure that a firewall is configured.

    Example::

        from fabtools.shorewall import *
        from fabtools import require

        # We need a firewall with some custom rules
        require.shorewall.firewall(
            rules=[
                Ping(),
                SSH(),
                HTTP(),
                HTTPS(),
                SMTP(),
                rule(port=1234, source=hosts(['example.com'])),
            ]
        )

    """
    package('shorewall')

    with watch(CONFIG_FILES) as config:
        _zone_config(zones)
        _interfaces_config(interfaces)
        _policy_config(policy)
        _rules_config(rules)
        _routestopped_config(routestopped)
        _masq_config(masq)

    if config.changed:
        puts("Shorewall configuration changed")
        if is_started():
            restart('shorewall')

    with settings(hide('running'), shell_env()):
        sed('/etc/default/shorewall', 'startup=0', 'startup=1', use_sudo=True)


def started():
    """
    Ensure that the firewall is started.
    """
    if not is_started():
        start('shorewall')


def stopped():
    """
    Ensure that the firewall is stopped.
    """
    if not is_stopped():
        stop('shorewall')

########NEW FILE########
__FILENAME__ = supervisor
"""
Supervisor processes
====================

This module provides high-level tools for managing long-running
processes using `supervisor`_.

.. _supervisor: http://supervisord.org/

"""
from __future__ import with_statement

from fabtools.files import watch
from fabtools.supervisor import update_config, process_status, start_process
from fabtools.system import UnsupportedFamily, distrib_family, distrib_id


def process(name, **kwargs):
    """
    Require a supervisor process to be running.

    Keyword arguments will be used to build the program configuration
    file. Some useful arguments are:

    - ``command``: complete command including arguments (**required**)
    - ``directory``: absolute path to the working directory
    - ``user``: run the process as this user
    - ``stdout_logfile``: absolute path to the log file

    You should refer to the `supervisor documentation`_ for the
    complete list of allowed arguments.

    .. note:: the default values for the following arguments differs from
              the ``supervisor`` defaults:

              - ``autorestart``: defaults to ``true``
              - ``redirect_stderr``: defaults to ``true``

    Example::

        from fabtools import require

        require.supervisor.process('myapp',
            command='/path/to/venv/bin/myapp --config production.ini --someflag',
            directory='/path/to/working/dir',
            user='alice',
            stdout_logfile='/path/to/logs/myapp.log',
            )

    .. _supervisor documentation: http://supervisord.org/configuration.html#program-x-section-values
    """

    from fabtools.require import file as require_file
    from fabtools.require.deb import package as require_deb_package
    from fabtools.require.rpm import package as require_rpm_package
    from fabtools.require.arch import package as require_arch_package
    from fabtools.require.service import started as require_started

    family = distrib_family()

    if family == 'debian':
        require_deb_package('supervisor')
        require_started('supervisor')
    elif family == 'redhat':
        require_rpm_package('supervisor')
        require_started('supervisord')
    elif distrib_id() is 'Archlinux':
        require_arch_package('supervisor')
        require_started('supervisord')

    # Set default parameters
    params = {}
    params.update(kwargs)
    params.setdefault('autorestart', 'true')
    params.setdefault('redirect_stderr', 'true')

    # Build config file from parameters
    lines = []
    lines.append('[program:%(name)s]' % locals())
    for key, value in sorted(params.items()):
        lines.append("%s=%s" % (key, value))

    # Upload config file
    if family == 'debian':
        filename = '/etc/supervisor/conf.d/%(name)s.conf' % locals()
    elif family in ['redhat', 'arch']:
        filename = '/etc/supervisord.d/%(name)s.ini' % locals()
    else:
        raise UnsupportedFamily(supported=['debian', 'redhat', 'arch'])

    with watch(filename, callback=update_config, use_sudo=True):
        require_file(filename, contents='\n'.join(lines), use_sudo=True)

    # Start the process if needed
    if process_status(name) == 'STOPPED':
        start_process(name)

########NEW FILE########
__FILENAME__ = system
"""
System settings
===============
"""
from __future__ import with_statement

from re import escape

from fabric.api import settings, warn
from fabric.contrib.files import append, uncomment

from fabtools.files import is_file, watch
from fabtools.system import (
    UnsupportedFamily,
    distrib_family, distrib_id,
    get_hostname, set_hostname,
    get_sysctl, set_sysctl,
    supported_locales,
)
from fabtools.utils import run_as_root


def sysctl(key, value, persist=True):
    """
    Require a kernel parameter to have a specific value.
    """
    if get_sysctl(key) != value:
        set_sysctl(key, value)

    if persist:

        from fabtools.require import file as require_file

        filename = '/etc/sysctl.d/60-%s.conf' % key
        with watch(filename, use_sudo=True) as config:
            require_file(filename,
                         contents='%(key)s = %(value)s\n' % locals(),
                         use_sudo=True)
        if config.changed:
            if distrib_family() == 'debian':
                with settings(warn_only=True):
                    run_as_root('service procps start')


def hostname(name):
    """
    Require the hostname to have a specific value.
    """
    if get_hostname() != name:
        set_hostname(name)


def locales(names):
    """
    Require the list of locales to be available.
    """

    if distrib_id() == "Ubuntu":
        config_file = '/var/lib/locales/supported.d/local'
        if not is_file(config_file):
            run_as_root('touch %s' % config_file)
    else:
         config_file = '/etc/locale.gen'

    # Regenerate locales if config file changes
    with watch(config_file, use_sudo=True) as config:

        # Add valid locale names to the config file
        supported = dict(supported_locales())
        for name in names:
            if name in supported:
                charset = supported[name]
                locale = "%s %s" % (name, charset)
                uncomment(config_file, escape(locale), use_sudo=True, shell=True)
                append(config_file, locale, use_sudo=True, partial=True, shell=True)
            else:
                warn('Unsupported locale name "%s"' % name)

    if config.changed:
        family = distrib_family()
        if family == 'debian':
            run_as_root('dpkg-reconfigure --frontend=noninteractive locales')
        elif family in ['arch', 'gentoo']:
            run_as_root('locale-gen')
        else:
            raise UnsupportedFamily(supported=['debian', 'arch', 'gentoo'])


def locale(name):
    """
    Require the locale to be available.
    """
    locales([name])


def default_locale(name):
    """
    Require the locale to be the default.
    """
    from fabtools.require import file as require_file

    # Ensure the locale is available
    locale(name)

    # Make it the default
    contents = 'LANG="%s"\n' % name
    if distrib_id() == "Archlinux":
        config_file = '/etc/locale.conf'
    else:
        config_file = '/etc/default/locale'
    require_file(config_file, contents, use_sudo=True)

########NEW FILE########
__FILENAME__ = tomcat
"""
Tomcat
============

This module provides tools for installing `Tomcat`_

.. _Tomcat: http://tomcat.apache.org

"""
from fabtools import tomcat


def installed(version=tomcat.DEFAULT_VERSION):
    """
    Require Tomcat to be installed.

    ::

        from fabtools import require

        require.tomcat.installed()

    """
    if tomcat.version(tomcat.DEFAULT_INSTALLATION_PATH) != version:
        tomcat.install_from_source(version=version, overwrite=True)

########NEW FILE########
__FILENAME__ = users
"""
System users
============
"""
from fabtools.files import is_file
from fabtools.user import create, exists, modify
from fabtools.utils import run_as_root


def user(name, comment=None, home=None, create_home=None, skeleton_dir=None,
         group=None, create_group=True, extra_groups=None, password=None,
         system=False, shell=None, uid=None, ssh_public_keys=None,
         non_unique=False):
    """
    Require a user and its home directory.

    See :func:`fabtools.user.create` for a detailed description of
    arguments.

    ::

        from fabtools import require

        # This will also create a home directory for alice
        require.user('alice')

        # Sometimes we don't need a home directory
        require.user('mydaemon', create_home=False)

        # Require a user without shell access
        require.user('nologin', shell='/bin/false')

    .. note:: This function can be accessed directly from the
              ``fabtools.require`` module for convenience.

    """

    from fabtools.require import directory as require_directory

    # Make sure the user exists
    if not exists(name):
        create(name, comment=comment, home=home, create_home=create_home,
               skeleton_dir=skeleton_dir, group=group,
               create_group=create_group, extra_groups=extra_groups,
               password=password, system=system, shell=shell, uid=uid,
               ssh_public_keys=ssh_public_keys, non_unique=non_unique)
    else:
        modify(name, comment=comment, home=home, group=group,
               extra_groups=extra_groups, password=password,
               shell=shell, uid=uid, ssh_public_keys=ssh_public_keys,
               non_unique=non_unique)

    # Make sure the home directory exists and is owned by user
    if home:
        require_directory(home, owner=name, use_sudo=True)


def sudoer(username, hosts="ALL", operators="ALL", passwd=False,
           commands="ALL"):
    """
    Require sudo permissions for a given user.

    .. note:: This function can be accessed directly from the
              ``fabtools.require`` module for convenience.

    """
    tags = "PASSWD:" if passwd else "NOPASSWD:"
    spec = "%(username)s %(hosts)s=(%(operators)s) %(tags)s %(commands)s" %\
           locals()
    filename = '/etc/sudoers.d/fabtools-%s' % username
    if is_file(filename):
        run_as_root('chmod 0640 %(filename)s && rm -f %(filename)s' % locals())
    run_as_root('echo "%(spec)s" >%(filename)s && chmod 0440 %(filename)s' %
                locals(), shell=True)

########NEW FILE########
__FILENAME__ = rpm
"""
RPM packages
============

This module provides tools to manage CentOS/RHEL/SL/Fedora packages
and repositories.

"""
from __future__ import with_statement

from fabric.api import hide, run, settings

from fabtools.utils import run_as_root


MANAGER = 'yum -y --color=never'


def update(kernel=False):
    """
    Upgrade all packages, skip obsoletes if ``obsoletes=0`` in ``yum.conf``.

    Exclude *kernel* upgrades by default.
    """
    manager = MANAGER
    cmds = {'yum -y --color=never': {False: '--exclude=kernel* update', True: 'update'}}
    cmd = cmds[manager][kernel]
    run_as_root("%(manager)s %(cmd)s" % locals())


def upgrade(kernel=False):
    """
    Upgrade all packages, including obsoletes.

    Exclude *kernel* upgrades by default.
    """
    manager = MANAGER
    cmds = {'yum -y --color=never': {False: '--exclude=kernel* upgrade', True: 'upgrade'}}
    cmd = cmds[manager][kernel]
    run_as_root("%(manager)s %(cmd)s" % locals())


def groupupdate(group, options=None):
    """
    Update an existing software group, skip obsoletes if ``obsoletes=1`` in ``yum.conf``.

    Extra *options* may be passed to ``yum`` if necessary.
    """
    manager = MANAGER
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    options = " ".join(options)
    run_as_root('%(manager)s %(options)s groupupdate "%(group)s"' % locals())


def is_installed(pkg_name):
    """
    Check if an RPM package is installed.
    """
    manager = MANAGER
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = run("rpm --query %(pkg_name)s" % locals())
        if res.succeeded:
            return True
        return False


def install(packages, repos=None, yes=None, options=None):
    """
    Install one or more RPM packages.

    Extra *repos* may be passed to ``yum`` to enable extra repositories at install time.

    Extra *yes* may be passed to ``yum`` to validate license if necessary.

    Extra *options* may be passed to ``yum`` if necessary
    (e.g. ``['--nogpgcheck', '--exclude=package']``).

    ::

        import fabtools

        # Install a single package, in an alternative install root
        fabtools.rpm.install('emacs', options='--installroot=/my/new/location')

        # Install multiple packages silently
        fabtools.rpm.install([
            'unzip',
            'nano'
        ], '--quiet')

    """
    manager = MANAGER
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    if repos:
        for repo in repos:
            options.append('--enablerepo=%(repo)s' % locals())
    options = " ".join(options)
    if isinstance(yes, str):
        run_as_root('yes %(yes)s | %(manager)s %(options)s install %(packages)s' % locals())
    else:
        run_as_root('%(manager)s %(options)s install %(packages)s' % locals())


def groupinstall(group, options=None):
    """
    Install a group of packages.

    You can use ``yum grouplist`` to get the list of groups.

    Extra *options* may be passed to ``yum`` if necessary like
    (e.g. ``['--nogpgcheck', '--exclude=package']``).

    ::

        import fabtools

        # Install development packages
        fabtools.rpm.groupinstall('Development tools')

    """
    manager = MANAGER
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    options = " ".join(options)
    run_as_root('%(manager)s %(options)s groupinstall "%(group)s"' % locals(), pty=False)


def uninstall(packages, options=None):
    """
    Remove one or more packages.

    Extra *options* may be passed to ``yum`` if necessary.

    """
    manager = MANAGER
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    if not isinstance(packages, basestring):
        packages = " ".join(packages)
    options = " ".join(options)
    run_as_root('%(manager)s %(options)s remove %(packages)s' % locals())


def groupuninstall(group, options=None):
    """
    Remove an existing software group.

    Extra *options* may be passed to ``yum`` if necessary.

    """
    manager = MANAGER
    if options is None:
        options = []
    elif isinstance(options, str):
        options = [options]
    options = " ".join(options)
    run_as_root('%(manager)s %(options)s groupremove "%(group)s"' % locals())


def repolist(status='', media=None):
    """
    Get the list of ``yum`` repositories.

    Returns enabled repositories by default. Extra *status* may be passed
    to list disabled repositories if necessary.

    Media and debug repositories are kept disabled, except if you pass *media*.

    ::

        import fabtools

        # Install a package that may be included in disabled repositories
        fabtools.rpm.install('vim', fabtools.rpm.repolist('disabled'))

    """
    manager = MANAGER
    with settings(hide('running', 'stdout')):
        if media:
            repos = run_as_root("%(manager)s repolist %(status)s | sed '$d' | sed -n '/repo id/,$p'" % locals())
        else:
            repos = run_as_root("%(manager)s repolist %(status)s | sed '/Media\\|Debug/d' | sed '$d' | sed -n '/repo id/,$p'" % locals())
        return map(lambda line: line.split(' ')[0], repos.splitlines()[1:])

########NEW FILE########
__FILENAME__ = service
"""
System services
===============

This module provides low-level tools for managing system services,
using the ``service`` command. It supports both `upstart`_ services
and traditional SysV-style ``/etc/init.d/`` scripts.

.. _upstart: http://upstart.ubuntu.com/

"""
from __future__ import with_statement

from fabric.api import hide, settings

from fabtools.utils import run_as_root

from fabtools import systemd

from fabtools.system import using_systemd, distrib_family


def is_running(service):
    """
    Check if a service is running.

    ::

        import fabtools

        if fabtools.service.is_running('foo'):
            print "Service foo is running!"
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'),
                  warn_only=True):
        if using_systemd():
            return systemd.is_running(service)
        else:
            if distrib_family() != "gentoo":
                test_upstart = run_as_root('test -f /etc/init/%s.conf' %
                                           service)
                status = _service(service, 'status')
                if test_upstart.succeeded:
                    return 'running' in status
                else:
                    return status.succeeded
            else:
                # gentoo
                status = _service(service, 'status')
                return ' started' in status


def start(service):
    """
    Start a service.

    ::

        import fabtools

        # Start service if it is not running
        if not fabtools.service.is_running('foo'):
            fabtools.service.start('foo')
    """
    _service(service, 'start')


def stop(service):
    """
    Stop a service.

    ::

        import fabtools

        # Stop service if it is running
        if fabtools.service.is_running('foo'):
            fabtools.service.stop('foo')
    """
    _service(service, 'stop')


def restart(service):
    """
    Restart a service.

    ::

        import fabtools

        # Start service, or restart it if it is already running
        if fabtools.service.is_running('foo'):
            fabtools.service.restart('foo')
        else:
            fabtools.service.start('foo')
    """
    _service(service, 'restart')


def reload(service):
    """
    Reload a service.

    ::

        import fabtools

        # Reload service
        fabtools.service.reload('foo')

    .. warning::

        The service needs to support the ``reload`` operation.
    """
    _service(service, 'reload')


def force_reload(service):
    """
    Force reload a service.

    ::

        import fabtools

        # Force reload service
        fabtools.service.force_reload('foo')

    .. warning::

        The service needs to support the ``force-reload`` operation.
    """
    _service(service, 'force-reload')


def _service(service, action):
    """
    Compatibility layer for distros that use ``service`` and those that don't.
    """
    if distrib_family() != "gentoo":
        status = run_as_root('service %(service)s %(action)s' % locals(),
                             pty=False)
    else:
        # gentoo
        status = run_as_root('/etc/init.d/%(service)s %(action)s' % locals(),
                             pty=False)
    return status

########NEW FILE########
__FILENAME__ = shorewall
"""
Shorewall firewall
==================
"""
from __future__ import with_statement

from socket import gethostbyname
import re

from fabric.api import hide, settings

from fabtools.utils import run_as_root


def status():
    """
    Get the firewall status.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        res = run_as_root('shorewall status')
    return re.search(r'\nShorewall is (\w+)', res).group(1)


def is_started():
    """
    Check if the firewall is started.
    """
    return status() == 'running'


def is_stopped():
    """
    Check if the firewall is stopped.
    """
    return status() == 'stopped'


def hosts(hostnames, zone='net'):
    """
    Builds a host list suitable for use in a firewall rule.
    """
    addresses = [gethostbyname(name) for name in hostnames]
    return "%s:%s" % (zone, ','.join(addresses))


def rule(port, action='ACCEPT', source='net', dest='$FW', proto='tcp'):
    """
    Helper to build a firewall rule.

    Examples::

        from fabtools.shorewall import rule

        # Rule to accept connections from example.com on port 1234
        r1 = rule(port=1234, source=hosts(['example.com']))

        # Rule to reject outgoing SMTP connections
        r2 = rule(port=25, action='REJECT', source='$FW', dest='net')

    """
    return {
        'action': action,
        'source': source,
        'dest': dest,
        'proto': proto,
        'dest_port': port,
    }


def Ping(**kwargs):
    """
    Helper to build a firewall rule for ICMP pings.

    Extra args will be passed to :py:func:`~fabtools.shorewall.rule`.
    """
    return rule(port=8, proto='icmp', **kwargs)


def SSH(port=22, **kwargs):
    """
    Helper to build a firewall rule for SSH connections

    Extra args will be passed to :py:func:`~fabtools.shorewall.rule`.
    """
    return rule(port, **kwargs)


def HTTP(port=80, **kwargs):
    """
    Helper to build a firewall rule for HTTP connections

    Extra args will be passed to :py:func:`~fabtools.shorewall.rule`.
    """
    return rule(port, **kwargs)


def HTTPS(port=443, **kwargs):
    """
    Helper to build a firewall rule for HTTPS connections

    Extra args will be passed to :py:func:`~fabtools.shorewall.rule`.
    """
    return rule(port, **kwargs)


def SMTP(port=25, **kwargs):
    """
    Helper to build a firewall rule for SMTP connections

    Extra args will be passed to :py:func:`~fabtools.shorewall.rule`.
    """
    return rule(port, **kwargs)

########NEW FILE########
__FILENAME__ = ssh
"""
OpenSSH tasks
=============

This module provides tools to manage OpenSSH server and client.

"""
from __future__ import with_statement

from fabric.api import hide, shell_env
from fabric.contrib.files import append, sed

from fabtools.service import is_running, restart
from fabtools.files import watch


def harden(allow_root_login=False, allow_password_auth=False,
           sshd_config='/etc/ssh/sshd_config'):
    """
    Apply best practices for ssh security.

    See :func:`fabtools.ssh.disable_password_auth` and
    :func:`fabtools.ssh.disable_root_login` for a detailed
    description.

    ::

        import fabtools

        # This will apply all hardening techniques.
        fabtools.ssh.harden()

        # Only apply some of the techniques.
        fabtools.ssh.harden(allow_password_auth=True)

        # Override the sshd_config file location.
        fabtools.ssh.harden(sshd_config='/etc/sshd_config')

    """

    if not allow_password_auth:
        disable_password_auth(sshd_config=sshd_config)

    if not allow_root_login:
        disable_root_login(sshd_config=sshd_config)


def disable_password_auth(sshd_config='/etc/ssh/sshd_config'):
    """
    Do not allow users to use passwords to login via ssh.
    """

    _update_ssh_setting(sshd_config, 'PasswordAuthentication', 'no')


def enable_password_auth(sshd_config='/etc/ssh/sshd_config'):
    """
    Allow users to use passwords to login via ssh.
    """

    _update_ssh_setting(sshd_config, 'PasswordAuthentication', 'yes')


def disable_root_login(sshd_config='/etc/ssh/sshd_config'):
    """
    Do not allow root to login via ssh.
    """

    _update_ssh_setting(sshd_config, 'PermitRootLogin', 'no')


def enable_root_login(sshd_config='/etc/ssh/sshd_config'):
    """
    Allow root to login via ssh.
    """

    _update_ssh_setting(sshd_config, 'PermitRootLogin', 'yes')


def _update_ssh_setting(sshd_config, name, value):
    """
    Update a yes/no setting in the SSH config file
    """

    with watch(sshd_config) as config_file:

        with shell_env():

            # First try to change existing setting
            sed(sshd_config,
                r'^(\s*#\s*)?%s\s+(yes|no)' % name,
                '%s %s' % (name, value),
                use_sudo=True)

            # Then append setting if it's still missing
            _append(sshd_config,
                    '%s %s' % (name, value),
                    use_sudo=True)

    if config_file.changed and is_running('ssh'):
        restart('ssh')


def _append(filename, regex, use_sudo):
    """
    Less verbose append
    """
    with hide('stdout', 'warnings'):
        return append(filename, regex, use_sudo=use_sudo)

########NEW FILE########
__FILENAME__ = supervisor
"""
Supervisor processes
====================

This module provides high-level tools for managing long-running
processes using `supervisord`_.

.. _supervisord: http://supervisord.org/

"""
from __future__ import with_statement

from fabric.api import hide, settings

from fabtools.utils import run_as_root


def reload_config():
    """
    Reload supervisor configuration.
    """
    run_as_root("supervisorctl reload")


def update_config():
    """
    Reread and update supervisor job configurations.

    Less heavy-handed than a full reload, as it doesn't restart the
    backend supervisor process and all managed processes.
    """
    run_as_root("supervisorctl update")


def process_status(name):
    """
    Get the status of a supervisor process.
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        res = run_as_root("supervisorctl status %(name)s" % locals())
        if res.startswith("No such process"):
            return None
        else:
            return res.split()[1]


def start_process(name):
    """
    Start a supervisor process
    """
    run_as_root("supervisorctl start %(name)s" % locals())


def stop_process(name):
    """
    Stop a supervisor process
    """
    run_as_root("supervisorctl stop %(name)s" % locals())


def restart_process(name):
    """
    Restart a supervisor process
    """
    run_as_root("supervisorctl restart %(name)s" % locals())

########NEW FILE########
__FILENAME__ = system
"""
System settings
===============
"""
from __future__ import with_statement

from fabric.api import hide, run, settings

from fabtools.files import is_file
from fabtools.utils import run_as_root


class UnsupportedFamily(Exception):
    """
    Operation not supported on this system family.

    ::

        from fabtools.system import UnsupportedFamily, distrib_family

        family = distrib_family()
        if family == 'debian':
            do_some_stuff()
        elif family == 'redhat':
            do_other_stuff()
        else:
            raise UnsupportedFamily(supported=['debian', 'redhat'])

    """

    def __init__(self, supported):
        self.supported = supported
        self.distrib = distrib_id()
        msg = "Unsupported system %s (supported families: %s)" % (self.distrib, ', '.join(supported))
        super(UnsupportedFamily, self).__init__(msg)


def distrib_id():
    """
    Get the OS distribution ID.

    Returns a string such as ``"Debian"``, ``"Ubuntu"``, ``"RHEL"``,
    ``"CentOS"``, ``"SLES"``, ``"Fedora"``, ``"Archlinux"``, ``"Gentoo"``,
    ``"SunOS"``...

    Example::

        from fabtools.system import distrib_id

        if distrib_id() != 'Debian':
            abort(u"Distribution is not supported")

    """

    with settings(hide('running', 'stdout')):
        kernel = run('uname -s')

        if kernel == 'Linux':
            # lsb_release works on Ubuntu and Debian >= 6.0
            # but is not always included in other distros such as:
            # Gentoo
            if is_file('/usr/bin/lsb_release'):
                return run('lsb_release --id --short')
            else:
                if is_file('/etc/debian_version'):
                    return "Debian"
                elif is_file('/etc/fedora-release'):
                    return "Fedora"
                elif is_file('/etc/arch-release'):
                    return "Archlinux"
                elif is_file('/etc/redhat-release'):
                    release = run('cat /etc/redhat-release')
                    if release.startswith('Red Hat Enterprise Linux'):
                        return "RHEL"
                    elif release.startswith('CentOS'):
                        return "CentOS"
                    elif release.startswith('Scientific Linux'):
                        return "SLES"
                elif is_file('/etc/gentoo-release'):
                    return "Gentoo"
        elif kernel == "SunOS":
            return "SunOS"


def distrib_release():
    """
    Get the release number of the distribution.

    Example::

        from fabtools.system import distrib_id, distrib_release

        if distrib_id() == 'CentOS' and distrib_release() == '6.1':
            print(u"CentOS 6.2 has been released. Please upgrade.")

    """

    with settings(hide('running', 'stdout')):

        kernel = run('uname -s')

        if kernel == 'Linux':
            return run('lsb_release -r --short')

        elif kernel == 'SunOS':
            return run('uname -v')


def distrib_codename():
    """
    Get the codename of the Linux distribution.

    Example::

        from fabtools.deb import distrib_codename

        if distrib_codename() == 'precise':
            print(u"Ubuntu 12.04 LTS detected")

    """
    with settings(hide('running', 'stdout')):
        return run('lsb_release --codename --short')


def distrib_desc():
    """
    Get the description of the Linux distribution.

    For example: ``Debian GNU/Linux 6.0.7 (squeeze)``.
    """
    with settings(hide('running', 'stdout')):
        if not is_file('/etc/redhat-release'):
            return run('lsb_release --desc --short')
        return run('cat /etc/redhat-release')


def distrib_family():
    """
    Get the distribution family.

    Returns one of ``debian``, ``redhat``, ``arch``, ``gentoo``,
    ``sun``, ``other``.
    """
    distrib = distrib_id()
    if distrib in ['Debian', 'Ubuntu', 'LinuxMint']:
        return 'debian'
    elif distrib in ['RHEL', 'CentOS', 'SLES', 'Fedora']:
        return 'redhat'
    elif distrib in ['SunOS']:
        return 'sun'
    elif distrib in ['Gentoo']:
        return 'gentoo'
    elif distrib in ['Archlinux']:
        return 'arch'
    else:
        return 'other'


def get_hostname():
    """
    Get the fully qualified hostname.
    """
    with settings(hide('running', 'stdout')):
        return run('hostname --fqdn')


def set_hostname(hostname, persist=True):
    """
    Set the hostname.
    """
    run_as_root('hostname %s' % hostname)
    if persist:
        run_as_root('echo %s >/etc/hostname' % hostname)


def get_sysctl(key):
    """
    Get a kernel parameter.

    Example::

        from fabtools.system import get_sysctl

        print "Max number of open files:", get_sysctl('fs.file-max')

    """
    with settings(hide('running', 'stdout')):
        return run_as_root('/sbin/sysctl -n -e %(key)s' % locals())


def set_sysctl(key, value):
    """
    Set a kernel parameter.

    Example::

        import fabtools

        # Protect from SYN flooding attack
        fabtools.system.set_sysctl('net.ipv4.tcp_syncookies', 1)

    """
    run_as_root('/sbin/sysctl -n -e -w %(key)s=%(value)s' % locals())


def supported_locales():
    """
    Gets the list of supported locales.

    Each locale is returned as a ``(locale, charset)`` tuple.
    """
    with settings(hide('running', 'stdout')):
        if distrib_id() == "Archlinux":
            res = run("cat /etc/locale.gen")
        else:
            res = run('cat /usr/share/i18n/SUPPORTED')
    return [line.strip().split(' ') for line in res.splitlines()
            if not line.startswith('#')]


def get_arch():
    """
    Get the CPU architecture.

    Example::

        from fabtools.system import get_arch

        if get_arch() == 'x86_64':
            print(u"Running on a 64-bit Intel/AMD system")

    """
    with settings(hide('running', 'stdout')):
        arch = run('uname -m')
        return arch


def cpus():
    """
    Get the number of CPU cores.

    Example::

        from fabtools.system import cpus

        nb_workers = 2 * cpus() + 1

    """
    with settings(hide('running', 'stdout')):
        res = run('python -c "import multiprocessing; '
                  'print(multiprocessing.cpu_count())"')
        return int(res)


def using_systemd():
    """
    Return True if using systemd

    Example::

        from fabtools.system import use_systemd

        if using_systemd():
            # do stuff with fabtools.systemd ...
            pass

    """
    return run('which systemctl', quiet=True).succeeded


def time():
    """
    Return the current time in seconds since the Epoch.

    Same as :py:func:`time.time()`

    """

    with settings(hide('running', 'stdout')):
        return int(run('date +%s'))

########NEW FILE########
__FILENAME__ = systemd
"""
Systemd services
================

This module provides low-level tools for managing `systemd`_ services.

.. _systemd: http://www.freedesktop.org/wiki/Software/systemd

"""
from __future__ import with_statement

from fabric.api import hide, settings

from fabtools.utils import run_as_root

def action(action, service):
	return run_as_root('systemctl %s %s.service' % (action, service,))


def enable(service):
    """
    Enable a service.

    ::

        fabtools.enable('httpd')

    .. note:: This function is idempotent.
    """
    action('enable', service)


def disable(service):
    """
    Disable a service.

    ::

        fabtools.systemd.disable('httpd')

    .. note:: This function is idempotent.
    """
    action('disable', service)


def is_running(service):
    """
    Check if a service is running.

    ::

        if fabtools.systemd.is_running('httpd'):
            print("Service httpd is running!")
    """
    with settings(hide('running', 'stdout', 'stderr', 'warnings'), warn_only=True):
        return action('status', service).succeeded


def start(service):
    """
    Start a service.

    ::

        if not fabtools.systemd.is_running('httpd'):
            fabtools.systemd.start('httpd')

    .. note:: This function is idempotent.
    """
    action('start', service)


def stop(service):
    """
    Stop a service.

    ::

        if fabtools.systemd.is_running('foo'):
            fabtools.systemd.stop('foo')

    .. note:: This function is idempotent.
    """
    action('stop', service)


def restart(service):
    """
    Restart a service.

    ::

        if fabtools.systemd.is_running('httpd'):
            fabtools.systemd.restart('httpd')
        else:
            fabtools.systemd.start('httpd')
    """
    action('restart', service)


def reload(service):
    """
    Reload a service.

    ::

        fabtools.systemd.reload('foo')

    .. warning::

        The service needs to support the ``reload`` operation.
    """
    action('reload', service)

def start_and_enable(service):
    """
    Start and enable a service (convenience function).

    .. note:: This function is idempotent.
    """
    start(service)
    enable(service)

def stop_and_disable(service):
    """
    Stop and disable a service (convenience function).

    .. note:: This function is idempotent.
    """
    stop(service)
    disable(service)

########NEW FILE########
__FILENAME__ = apache
from __future__ import with_statement

from fabric.api import (
    shell_env,
    task,
)


@task
def apache():
    """
    Check apache server, enabling and disabling sites.
    """

    from fabric.api import run, sudo
    from fabtools import require
    from fabtools.files import is_link
    from fabtools.system import set_hostname

    set_hostname('www.example.com')

    require.apache.server()

    require.apache.module_disabled('rewrite')
    assert not is_link('/etc/apache2/mods-enabled/rewrite.load')

    require.apache.module_enabled('rewrite')
    assert is_link('/etc/apache2/mods-enabled/rewrite.load')

    require.apache.module_disabled('rewrite')
    assert not is_link('/etc/apache2/mods-enabled/rewrite.load')

    require.apache.site_disabled('default')
    assert not is_link('/etc/apache2/sites-enabled/000-default')

    require.apache.site_enabled('default')
    assert is_link('/etc/apache2/sites-enabled/000-default')

    require.apache.site_disabled('default')
    assert not is_link('/etc/apache2/sites-enabled/000-default')

    run('mkdir -p ~/example.com/')
    run('echo "example page" > ~/example.com/index.html')

    require.apache.site(
        'example.com',
        template_contents="""
<VirtualHost *:%(port)s>
    ServerName %(hostname)s

    DocumentRoot %(document_root)s

    <Directory %(document_root)s>
        Options Indexes FollowSymLinks MultiViews

        AllowOverride All

        Order allow,deny
        allow from all
    </Directory>
</VirtualHost>
        """,
        port=80,
        hostname='www.example.com',
        document_root='/home/vagrant/example.com/',
    )

    with shell_env(http_proxy=''):
        body = run('wget -qO- --header="Host: www.example.com" http://localhost/')

    assert body == 'example page'

########NEW FILE########
__FILENAME__ = deb
from __future__ import with_statement

from fabric.api import (
    hide,
    run,
    settings,
    task,
)
from fabtools.utils import run_as_root


def reset():
    with settings(hide('output', 'warnings'), warn_only=True):
        run_as_root('apt-key del 7BD9BF62')
        run_as_root('apt-key del C4DEFFEB')


@task
def test_add_apt_key_with_key_id_from_url():
    from fabtools.deb import add_apt_key
    reset()
    add_apt_key(keyid='C4DEFFEB', url='http://repo.varnish-cache.org/debian/GPG-key.txt')
    run_as_root('apt-key finger | grep -q C4DEFFEB')


@task
def test_add_apt_key_with_key_id_from_specific_key_server():
    from fabtools.deb import add_apt_key
    reset()
    add_apt_key(keyid='7BD9BF62', keyserver='keyserver.ubuntu.com')
    run_as_root('apt-key finger | grep -q 7BD9BF62')


@task
def test_add_apt_key_with_key_id_from_file():
    from fabtools.deb import add_apt_key
    reset()
    run('wget http://repo.varnish-cache.org/debian/GPG-key.txt -O /tmp/tmp.fabtools.test.key')
    add_apt_key(keyid='C4DEFFEB', filename='/tmp/tmp.fabtools.test.key')
    run_as_root('apt-key finger | grep -q C4DEFFEB')


@task
def test_add_apt_key_without_key_id_from_url():
    from fabtools.deb import add_apt_key
    reset()
    add_apt_key(url='http://repo.varnish-cache.org/debian/GPG-key.txt')
    run_as_root('apt-key finger | grep -q C4DEFFEB')


@task
def test_add_apt_key_without_key_id_from_file():
    from fabtools.deb import add_apt_key
    reset()
    run('wget http://repo.varnish-cache.org/debian/GPG-key.txt -O /tmp/tmp.fabtools.test.key')
    add_apt_key(filename='/tmp/tmp.fabtools.test.key')
    run_as_root('apt-key finger | grep -q C4DEFFEB')


@task
def test_require_deb_key_from_url():
    from fabtools.require.deb import key as require_key
    reset()
    require_key(keyid='C4DEFFEB', url='http://repo.varnish-cache.org/debian/GPG-key.txt')
    run_as_root('apt-key finger | grep -q C4DEFFEB')


@task
def test_require_deb_key_from_specific_keyserver():
    from fabtools.require.deb import key as require_key
    reset()
    require_key(keyid='7BD9BF62', keyserver='keyserver.ubuntu.com')
    run_as_root('apt-key finger | grep -q 7BD9BF62')


@task
def test_require_deb_key_from_file():
    from fabtools.require.deb import key as require_key
    reset()
    run('wget http://repo.varnish-cache.org/debian/GPG-key.txt -O /tmp/tmp.fabtools.test.key')
    require_key(keyid='C4DEFFEB', filename='/tmp/tmp.fabtools.test.key')
    run_as_root('apt-key finger | grep -q C4DEFFEB')

########NEW FILE########
__FILENAME__ = disk
from fabric.api import task


@task
def list_partitions():
    """
    List disk partitions
    """

    from fabric.api import puts

    import fabtools

    partitions = fabtools.disk.partitions()
    for pname, ptype in partitions.items():
        puts("%s is %s" % (pname, hex(ptype)))


@task
def format_and_mount():
    """
    Format, mount and unmount a block device
    """

    from fabric.api import sudo

    from fabtools.require.files import directory as require_directory
    import fabtools

    assert not fabtools.disk.ismounted('/dev/loop0')

    try:
        # Make a loopback block device
        sudo('dd if=/dev/zero of=bigfile bs=1024 count=30720')
        sudo('losetup /dev/loop0 bigfile')

        # Format the block device
        fabtools.disk.mkfs('/dev/loop0', 'ext3')

        # Mount the block device
        require_directory('/mnt/loop', use_sudo=True)
        fabtools.disk.mount('/dev/loop0', '/mnt/loop')
        assert fabtools.disk.ismounted('/dev/loop0')

        # Unmount the block device
        sudo('umount /dev/loop0')
        assert not fabtools.disk.ismounted('/dev/loop0')

    finally:
        sudo('umount /dev/loop0', quiet=True)
        sudo('losetup -d /dev/loop0', quiet=True)
        sudo('rm -f bigfile', quiet=True)

########NEW FILE########
__FILENAME__ = files
from __future__ import with_statement

import os
from pipes import quote
from tempfile import mkstemp
from functools import partial

from fabric.api import cd, env, run, sudo, task

from fabtools.utils import run_as_root


@task
def files():
    """
    Check file creation
    """

    from fabtools import require
    import fabtools

    with cd('/tmp'):
        # Require that a file exists
        require.file('foo')
        assert fabtools.files.is_file('foo')
        assert run('cat foo') == '', run('cat foo')

        # Require that a file exists, whose contents should come from a URL
        require.file(url='http://www.google.com/robots.txt')
        assert fabtools.files.is_file('robots.txt')

        # Require that a file exists, whose contents should be this string
        bar_contents = '''This is the contents of the bar file'''
        require.file('bar', contents=bar_contents)
        assert fabtools.files.is_file('bar')
        assert run('cat bar') == bar_contents, run('cat bar')

        # Require that a file exists, whose contents should be this local file
        baz_contents = '''This is the contents of the bar file'''
        fd, filename = mkstemp()
        tmp_file = os.fdopen(fd, 'w')
        tmp_file.write(baz_contents)
        tmp_file.close()
        require.file('baz', source=filename)
        os.remove(filename)
        assert fabtools.files.is_file('baz')
        assert run('cat baz') == baz_contents, run('cat baz')

        # Ensure that changes to watched file are detected
        require.file('watched', contents='aaa')
        with fabtools.files.watch('watched') as f:
            require.file('watched', contents='bbb')
        assert f.changed
        with fabtools.files.watch('watched') as f:
            pass
        assert not f.changed

        # Ensure that the callable is triggered only
        # when the watched file is modified
        require.file('watched', contents='aaa')
        with fabtools.files.watch('watched', callback=partial(require.file, 'modified1')):
            require.file('watched', contents='bbb')
        assert fabtools.files.is_file('modified1')
        with fabtools.files.watch('watched', callback=partial(require.file, 'modified2')):
            pass
        assert not fabtools.files.is_file('modified2')


@task
def directories():
    """
    Check directory creation and modification
    """

    from fabtools import require
    import fabtools

    with cd('/tmp'):

        run_as_root('rm -rf dir1 dir2')

        # Test directory creation

        require.directory('dir1')
        assert fabtools.files.is_dir('dir1')
        assert fabtools.files.owner('dir1') == env.user

        # Test initial owner requirement

        require.user('dirtest', create_home=False)
        require.directory('dir2', owner='dirtest', use_sudo=True)

        assert fabtools.files.is_dir('dir2')
        assert fabtools.files.owner('dir2') == 'dirtest'

        # Test changed owner requirement

        require.user('dirtest2', create_home=False)
        require.directory('dir2', owner='dirtest2', use_sudo=True)

        assert fabtools.files.is_dir('dir2')
        assert fabtools.files.owner('dir2') == 'dirtest2'


@task
def temporary_directories():
    """
    Check temporary directories
    """
    from fabtools.files import is_dir
    from fabtools.require.files import temporary_directory

    path1 = temporary_directory()
    path2 = temporary_directory()

    assert is_dir(path1)
    assert is_dir(path2)
    assert path1 != path2

    run('rmdir %s' % quote(path1))
    run('rmdir %s' % quote(path2))


@task
def temporary_directory_as_context_manager():
    """
    Check temporary directory used as a context manager
    """
    from fabtools.files import is_dir
    from fabtools.require.files import temporary_directory

    with temporary_directory() as path:
        assert is_dir(path)

        with cd(path):
            run('touch foo')

    assert not is_dir(path)


@task
def require_directory_has_correct_permissions():

    from fabtools.files import owner, group, mode
    from fabtools.require.files import directory as require_directory

    try:
        sudo('mkdir foo')
        require_directory('bar', use_sudo=True)

        assert owner('foo') == owner('bar')
        assert group('foo') == group('bar')
        assert mode('foo') == mode('bar')

    finally:
        sudo('rmdir foo bar')


@task
def require_empty_file_has_correct_permissions():

    from fabtools.files import owner, group, mode
    from fabtools.require.files import file as require_file

    try:
        sudo('touch foo')
        require_file('bar', use_sudo=True)

        assert owner('foo') == owner('bar')
        assert group('foo') == group('bar')
        assert mode('foo') == mode('bar')

    finally:
        sudo('rm -f foo bar')


@task
def require_file_with_contents_has_correct_permissions():

    from fabtools.files import owner, group, mode
    from fabtools.require.files import file as require_file

    try:
        sudo('echo "something" > foo')
        require_file('bar', contents='something', use_sudo=True)

        assert owner('foo') == owner('bar')
        assert group('foo') == group('bar')
        assert mode('foo') == mode('bar')

    finally:
        sudo('rm -f foo bar')


@task
def require_file_changes_ownership():

    from fabtools.files import owner
    from fabtools.require.files import file as require_file

    try:
        run('touch foo')
        assert owner('foo') == env.user

        require_file('foo', use_sudo=True)
        assert owner('foo') == 'root'

    finally:
        sudo('rm -f foo')

########NEW FILE########
__FILENAME__ = git
# coding: utf-8

from __future__ import with_statement

from fabric.api import task


REMOTE_URL = 'https://github.com/disko/fabtools.git'


@task
def git_require():
    """
    Test high level git tools.  These tests should also cover the low
    level tools as all of them are called indirectly.
    """

    from fabric.api import cd, sudo

    with cd('/tmp'):

        # Clean up
        sudo('rm -rf *')

        git_require_remote_url()
        git_require_remote_url_and_path()
        git_require_no_update()
        git_require_branch()
        git_require_sudo()
        git_require_sudo_user()


def git_require_remote_url():
    """
    Test with remote URL only
    """

    from fabric.api import cd, run

    from fabtools.files import is_dir
    from fabtools import require

    require.git.working_copy(REMOTE_URL)

    assert is_dir('fabtools')
    assert is_dir('fabtools/.git')
    with cd('fabtools'):
        remotes = run('git remote -v')
        assert remotes == \
            'origin\thttps://github.com/disko/fabtools.git (fetch)\r\n' \
            'origin\thttps://github.com/disko/fabtools.git (push)'
        branch = run('git branch')
        assert branch == '* master'


def git_require_remote_url_and_path():
    """
    Test working_copy() with remote URL and path
    """

    from fabric.api import cd, run

    from fabtools.files import is_dir
    from fabtools import require

    require.git.working_copy(REMOTE_URL, path='wc')

    assert is_dir('wc')
    assert is_dir('wc/.git')
    with cd('wc'):
        remotes = run('git remote -v')
        assert remotes == \
            'origin\thttps://github.com/disko/fabtools.git (fetch)\r\n' \
            'origin\thttps://github.com/disko/fabtools.git (push)'
        branch = run('git branch')
        assert branch == '* master'


def git_require_no_update():
    """
    Test working_copy() with update=False
    """
    from fabric.api import run

    from fabtools.files import md5sum
    from fabtools import require

    run('tar -c -f wc_old.tar --exclude .git wc')
    old_md5 = md5sum('wc_old.tar')

    require.git.working_copy(REMOTE_URL, path='wc', update=False)

    # Test that the working tree was not updated
    run('tar -c -f wc_new.tar --exclude .git wc')
    new_md5 = md5sum('wc_new.tar')
    assert old_md5 == new_md5


def git_require_branch():
    """
    Test checkout of a branch
    """

    from fabric.api import cd, run

    from fabtools.files import is_dir
    from fabtools import require

    require.git.working_copy(REMOTE_URL, path='wc', branch='test_git')

    assert is_dir('wc')
    assert is_dir('wc/.git')
    with cd('wc'):
        remotes = run('git remote -v')
        assert remotes == \
            'origin\thttps://github.com/disko/fabtools.git (fetch)\r\n' \
            'origin\thttps://github.com/disko/fabtools.git (push)'
        branch = run('git branch')
        assert branch == 'master\r\n* test_git'


def git_require_sudo():
    """
    Test working_copy() with sudo
    """

    from fabric.api import cd, sudo

    from fabtools.files import group, is_dir, owner
    from fabtools import require

    require.git.working_copy(REMOTE_URL, path='wc_root', use_sudo=True)

    assert is_dir('wc_root')
    assert is_dir('wc_root/.git')
    with cd('wc_root'):
        remotes = sudo('git remote -v')
        assert remotes == \
            'origin\thttps://github.com/disko/fabtools.git (fetch)\r\n' \
            'origin\thttps://github.com/disko/fabtools.git (push)'
        branch = sudo('git branch')
        assert branch == '* master'
    assert owner('wc_root') == 'root'
    assert group('wc_root') == 'root'


def git_require_sudo_user():
    """
    Test working_copy() with sudo as a user
    """

    from fabric.api import cd, sudo

    from fabtools.files import group, is_dir, owner
    from fabtools import require

    require.user('gituser', group='gitgroup')

    require.git.working_copy(REMOTE_URL, path='wc_nobody', use_sudo=True,
                             user='gituser')

    assert is_dir('wc_nobody')
    assert is_dir('wc_nobody/.git')
    with cd('wc_nobody'):
        remotes = sudo('git remote -v', user='gituser')
        assert remotes == \
            'origin\thttps://github.com/disko/fabtools.git (fetch)\r\n' \
            'origin\thttps://github.com/disko/fabtools.git (push)'
        branch = sudo('git branch', user='gituser')
        assert branch == '* master'
    assert owner('wc_nobody') == 'gituser'
    assert group('wc_nobody') == 'gitgroup'

########NEW FILE########
__FILENAME__ = md5
from __future__ import with_statement

from fabric.api import task


@task
def md5():
    """
    Check MD5 sums (unavailable, empty, with content)
    """

    import hashlib

    from fabric.api import cd, hide, run, settings
    import fabtools

    with cd('/tmp'):

        run('touch f1')
        assert fabtools.files.md5sum('f1') == hashlib.md5('').hexdigest()

        run('echo -n hello > f2')
        assert fabtools.files.md5sum('f2') == hashlib.md5('hello').hexdigest()

        with settings(hide('warnings')):
            assert fabtools.files.md5sum('doesnotexist') is None

########NEW FILE########
__FILENAME__ = mysql
from __future__ import with_statement

from fabric.api import settings, task


@task
def mysql():
    """
    Setup MySQL server, user and database
    """

    from fabtools import require
    import fabtools

    require.mysql.server(password='s3cr3t')

    with settings(mysql_user='root', mysql_password='s3cr3t'):

        fabtools.mysql.create_user('bob', 'password', host='host1')
        fabtools.mysql.create_user('bob', 'password', host='host2')
        assert fabtools.mysql.user_exists('bob', host='host1')
        assert fabtools.mysql.user_exists('bob', host='host2')
        assert not fabtools.mysql.user_exists('bob', host='localhost')

        require.mysql.user('myuser', 'foo')
        assert fabtools.mysql.user_exists('myuser')

        require.mysql.database('mydb', owner='myuser')
        assert fabtools.mysql.database_exists('mydb')

    # Test that we can run queries as user foo
    with settings(mysql_user='myuser', mysql_password='foo'):
        fabtools.mysql.query('select 1;')

    # Test that we can run queries without supplying the password
    require.file('.my.cnf', contents="[mysql]\npassword=foo")
    with settings(mysql_user='myuser'):
        fabtools.mysql.query('select 2;')

########NEW FILE########
__FILENAME__ = network
import socket

from fabric.api import task


def is_valid_ipv4_address(address):
    try:
        _ = socket.inet_pton(socket.AF_INET, address)
    except AttributeError:  # no inet_pton here, sorry
        try:
            _ = socket.inet_aton(address)
        except socket.error:
            return False
        return address.count('.') == 3
    except socket.error:    # not a valid address
        return False
    return True


def is_valid_ipv6_address(address):
    try:
        _ = socket.inet_pton(socket.AF_INET6, address)
    except socket.error:    # not a valid address
        return False
    return True


def is_valid_address(address):
    return is_valid_ipv4_address(address) or is_valid_ipv6_address()


@task
def network():
    """
    Test network interfaces
    """

    import fabtools

    interfaces = fabtools.network.interfaces()

    # Check IPv4 addresses
    for interface in interfaces:
        ipv4_address = fabtools.network.address(interface)
        assert is_valid_ipv4_address(ipv4_address), ipv4_address

    # Check loopback interface
    assert 'lo' in interfaces, interfaces
    assert fabtools.network.address('lo') == '127.0.0.1'

    # Check name servers
    for address in fabtools.network.nameservers():
        assert is_valid_address(address), address

########NEW FILE########
__FILENAME__ = nginx
from __future__ import with_statement

from fabric.api import task


@task
def nginx():
    """
    Check nginx server, enabling and disabling sites.
    """

    from fabtools import require
    from fabtools.files import is_link

    require.nginx.server()

    require.nginx.disabled('default')
    assert not is_link('/etc/nginx/sites-enabled/default')

    require.nginx.enabled('default')
    assert is_link('/etc/nginx/sites-enabled/default')

########NEW FILE########
__FILENAME__ = nodejs
from __future__ import with_statement

try:
    import json
except ImportError:
    import simplejson as json

from fabric.api import *


@task
def install_nodejs():
    """
    Test low level API
    """

    from fabtools import nodejs
    from fabtools import require
    from fabtools.files import is_file

    # Install Node.js from source
    if nodejs.version() != nodejs.DEFAULT_VERSION:
        nodejs.install_from_source()

    assert is_file('/usr/local/bin/node')
    assert nodejs.version() == nodejs.DEFAULT_VERSION

    # Install / uninstall global package
    if not nodejs.package_version('underscore'):
        nodejs.install_package('underscore', version='1.4.2')

    assert nodejs.package_version('underscore') == '1.4.2'
    assert is_file('/usr/local/lib/node_modules/underscore/underscore.js')

    nodejs.uninstall_package('underscore')

    assert nodejs.package_version('underscore') is None
    assert not is_file('/usr/local/lib/node_modules/underscore/underscore.js')

    # Install / uninstall local package
    if not nodejs.package_version('underscore', local=True):
        nodejs.install_package('underscore', version='1.4.2', local=True)

    assert is_file('node_modules/underscore/underscore.js')
    assert nodejs.package_version('underscore', local=True) == '1.4.2'

    nodejs.uninstall_package('underscore', local=True)

    assert nodejs.package_version('underscore', local=True) is None
    assert not is_file('node_modules/underscore/underscore.js')

    # Install dependencies from package.json file
    require.directory('nodetest')
    with cd('nodetest'):
        require.file('package.json', contents=json.dumps({
            'name': 'nodetest',
            'version': '1.0.0',
            'dependencies': {
                'underscore': '1.4.2'
            }
        }))

        nodejs.install_dependencies()

        assert is_file('node_modules/underscore/underscore.js')
        assert nodejs.package_version('underscore', local=True) == '1.4.2'


@task
def require_nodejs():
    """
    Test high level API
    """

    from fabtools import nodejs
    from fabtools import require
    from fabtools.files import is_file

    # Require Node.js

    require.nodejs.installed_from_source()

    assert is_file('/usr/local/bin/node')
    assert nodejs.version() == nodejs.DEFAULT_VERSION

    # Require a global package

    nodejs.uninstall_package('underscore')

    require.nodejs.package('underscore', version='1.4.1')
    assert nodejs.package_version('underscore') == '1.4.1'

    require.nodejs.package('underscore', version='1.4.0')
    assert nodejs.package_version('underscore') == '1.4.0'

    require.nodejs.package('underscore', version='1.4.2')
    assert nodejs.package_version('underscore') == '1.4.2'

    # Require a local package

    nodejs.uninstall_package('underscore', local=True)

    require.nodejs.package('underscore', version='1.4.2', local=True)

    assert nodejs.package_version('underscore', local=True) == '1.4.2'

########NEW FILE########
__FILENAME__ = openvz
from __future__ import with_statement

import time

from fabric.api import cd, local, put, run, settings, sudo, task


@task
def test_openvz():

    import fabtools

    # Skip test if the kernel does not support OpenVZ
    if not fabtools.files.is_dir('/proc/vz'):
        return

    setup_networking()
    setup_containers()


def setup_networking():
    """
    Setup host networking
    """

    setup_nat()
    setup_firewall()


def setup_nat():
    """
    Make sure IP forwarding is enabled
    """

    import fabtools

    fabtools.require.system.sysctl('net.ipv4.ip_forward', 1)


def setup_firewall():
    """
    Shorewall config
    (based on http://www.shorewall.net/OpenVZ.html)
    """

    from fabtools import require

    zones = [
        {
            'name': 'fw',
            'type': 'firewall',
        },
        {
            'name': 'net',
            'type': 'ipv4',
        },
        {
            'name': 'vz',
            'type': 'ipv4',
        },
    ]

    interfaces = [
        {
            'zone':      'net',
            'interface': 'eth0',
            'options':   'proxyarp=1',

        },
        {
            'zone':      'vz',
            'interface': 'venet0',
            'options':   'routeback,arp_filter=0',
        },
    ]

    masq = [
        {
            'interface': 'eth0',
            'source':    '192.168.1.0/24',
        }
    ]

    policy = [
        {
            'source': '$FW',
            'dest':   'net',
            'policy': 'ACCEPT',
        },
        {
            'source': '$FW',
            'dest':   'vz',
            'policy': 'ACCEPT',
        },
        {
            'source': 'vz',
            'dest':   'net',
            'policy': 'ACCEPT',
        },
        {
            'source':    'net',
            'dest':      'all',
            'policy':    'DROP',
            'log_level': 'info',
        },
        {
            'source':    'all',
            'dest':      'all',
            'policy':    'REJECT',
            'log_level': 'info',
        },
    ]

    require.shorewall.firewall(
        zones=zones,
        interfaces=interfaces,
        policy=policy,
        masq=masq,
    )

    require.shorewall.started()


def setup_containers():

    from fabtools import require
    from fabtools.openvz import guest, list_ctids
    from fabtools.require.openvz import container
    from fabtools.require.redis import VERSION as REDIS_VERSION
    from fabtools.system import distrib_family
    import fabtools

    if distrib_family() == 'debian':
        require.deb.package('vzctl')

    NAME = 'debian'
    TEMPLATE = 'debian-6.0-x86_64'
    IPADD = '192.168.1.100'
    NAMESERVERS = fabtools.network.nameservers()

    require.openvz.template(TEMPLATE)

    with container(NAME, TEMPLATE, hostname=NAME, ipadd=IPADD) as ct:

        # Make sure the container is started
        if not ct.running():
            ct.start()

        # Set up name servers
        ct.set(nameserver=NAMESERVERS)

        # Wait until we can ping the container from the host
        with settings(warn_only=True):
            timeout = 0
            while True:
                if run('ping -c 1 %s' % IPADD).succeeded:
                    break
                time.sleep(1)
                timeout += 1
                assert timeout < 10, "Timeout trying to ping container"

        # Check run/sudo
        with guest(NAME):
            assert run('whoami') == 'root'
            assert sudo('whoami') == 'root'
            assert sudo('whoami', user='nobody') == 'nobody'

        # Check put
        with guest(NAME):
            local('echo "toto" > /tmp/toto')
            put('/tmp/toto', '/tmp/toto')
            assert run('test -f /tmp/toto').succeeded

        # Run more complex tasks inside container
        with guest(NAME):

            # Check require.file()
            require.file('/tmp/foo')
            assert fabtools.files.is_file('/tmp/foo')

            # Check cd() inside container
            with cd('/tmp'):
                run('touch bar')
                assert fabtools.files.is_file('bar')
            assert fabtools.files.is_file('/tmp/bar')

            # This directory does not exist in the host
            require.directory('/tmp/newdir')
            with cd('/tmp/newdir'):
                run('touch baz')
            assert fabtools.files.is_file('/tmp/newdir/baz')

            # Check that sudo as user works
            with cd('/tmp'):
                sudo('touch tata', user='nobody')
                assert run('stat -c "%U" tata') == 'nobody'

            # Check Debian package install
            fabtools.deb.update_index()
            require.deb.package('htop')
            assert fabtools.files.is_file('/usr/bin/htop')

            # Install Redis
            require.redis.instance('test')
            assert fabtools.files.is_file('/etc/redis/test.conf')
            assert run('echo PING | /opt/redis-%s/redis-cli' % REDIS_VERSION) == 'PONG'

    assert 'debian' in list_ctids()

    # Stop and destroy container
    with container(NAME, TEMPLATE, hostname=NAME, ipadd=IPADD) as ct:
        ct.stop()
        ct.destroy()

    assert 'debian' not in list_ctids()

########NEW FILE########
__FILENAME__ = oracle_jdk
#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import with_statement

from fabric.api import task


@task
def require_oracle_jdk():
    """
    Test high level API
    """

    from fabtools import oracle_jdk
    from fabtools import require
    from fabtools.files import is_file

    # Require Oracle JDK

    require.oracle_jdk.installed()

    assert is_file('/opt/jdk/bin/java')
    assert oracle_jdk.version() == oracle_jdk.DEFAULT_VERSION

    # Require Oracle JDK version 6
    require.oracle_jdk.installed('6u45-b06')

    assert is_file('/opt/jdk/bin/java')
    assert oracle_jdk.version() == '6u45-b06'

########NEW FILE########
__FILENAME__ = postgres
from __future__ import with_statement

from fabric.api import task


@task
def postgresql():
    """
    Setup PostgreSQL server, user and database
    """

    from fabtools import require
    import fabtools

    # Test Postgres setup
    require.postgres.server()

    # Test low-level operations
    assert not fabtools.postgres.user_exists('alice')
    assert not fabtools.postgres.user_exists('bob')
    fabtools.postgres.create_user('alice', password='1234')
    assert fabtools.postgres.user_exists('alice')
    assert not fabtools.postgres.user_exists('bob')
    fabtools.postgres.create_user('bob', password='5678')
    assert fabtools.postgres.user_exists('alice')
    assert fabtools.postgres.user_exists('bob')

    # Test high-level operations
    require.postgres.user('pguser', 'foo')
    assert fabtools.postgres.user_exists('pguser')

    require.postgres.database('pgdb', 'pguser')
    assert fabtools.postgres.database_exists('pgdb')

########NEW FILE########
__FILENAME__ = python
from __future__ import with_statement

from fabric.api import task


@task
def python_setuptools():
    """
    Test setuptools installation
    """

    from fabtools import require

    require.python.setuptools()


@task
def python_virtualenv():
    """
    Test Python virtualenv creation
    """

    from fabtools import require
    import fabtools

    require.python.virtualenv('/tmp/venv')

    assert fabtools.files.is_dir('/tmp/venv')
    assert fabtools.files.is_file('/tmp/venv/bin/python')


@task
def python_package():
    """
    Test Python package installation
    """

    from fabtools import require
    import fabtools

    require.python.virtualenv('/tmp/venv')
    with fabtools.python.virtualenv('/tmp/venv'):
        require.python.package('fabric')

    assert fabtools.files.is_file('/tmp/venv/bin/fab')

########NEW FILE########
__FILENAME__ = redis
from __future__ import with_statement

from fabric.api import run, task


@task
def redis():
    """
    Setup Redis server
    """

    from fabtools import require
    from fabtools.require.redis import VERSION

    require.redis.installed_from_source()

    require.redis.instance('db1', port='6379')

    # Check that we can save RDB file
    res = run('echo SAVE | /opt/redis-%s/redis-cli' % VERSION)
    assert res == 'OK'

########NEW FILE########
__FILENAME__ = shorewall
from fabric.api import task


@task
def firewall():
    """
    Setup a firewall
    """

    from fabtools import require
    import fabtools

    require.shorewall.firewall(
        rules=[
            fabtools.shorewall.Ping(),
            fabtools.shorewall.SSH(),
            fabtools.shorewall.HTTP(),
            fabtools.shorewall.HTTPS(),
            fabtools.shorewall.SMTP(),
            fabtools.shorewall.rule(
                port=1234,
                source=fabtools.shorewall.hosts(['example.com']),
            ),
        ]
    )

    require.shorewall.started()
    assert fabtools.shorewall.is_started()

    require.shorewall.stopped()
    assert fabtools.shorewall.is_stopped()

########NEW FILE########
__FILENAME__ = ssh
from __future__ import with_statement

from textwrap import dedent

from fabric.api import (
    quiet,
    run,
    task,
)
from fabric.contrib.files import contains


@task
def ssh():
    """
    Test SSH hardening operations
    """

    import fabtools

    SSHD_CONFIG = '/tmp/sshd_config'

    SSHD_CONFIG_CONTENT = [
        '''
        ''',

        '''
        PasswordAuthentication yes
        PermitRootLogin yes
        ''',

        '''
        PasswordAuthentication yes
        PermitRootLogin no
        ''',

        '''
        PasswordAuthentication no
        PermitRootLogin yes
        ''',

        '''
        PasswordAuthentication no
        PermitRootLogin no
        ''',
    ]

    def check_disable_password_auth(sshd_config):
        fabtools.ssh.disable_password_auth(sshd_config=sshd_config)
        with quiet():
            assert contains(sshd_config, 'PasswordAuthentication no', exact=True)
            assert not contains(sshd_config, 'PasswordAuthentication yes', exact=True)

    def check_disable_root_login(sshd_config):
        fabtools.ssh.disable_root_login(sshd_config=sshd_config)
        with quiet():
            assert contains(sshd_config, 'PermitRootLogin no', exact=True)
            assert not contains(sshd_config, 'PermitRootLogin yes', exact=True)

    def check_enable_password_auth(sshd_config):
        fabtools.ssh.enable_password_auth(sshd_config=sshd_config)
        with quiet():
            assert contains(sshd_config, 'PasswordAuthentication yes', exact=True)
            assert not contains(sshd_config, 'PasswordAuthentication no', exact=True)

    def check_enable_root_login(sshd_config):
        fabtools.ssh.enable_root_login(sshd_config=sshd_config)
        with quiet():
            assert contains(sshd_config, 'PermitRootLogin yes', exact=True)
            assert not contains(sshd_config, 'PermitRootLogin no', exact=True)

    for content in SSHD_CONFIG_CONTENT:

        run('rm -f %s' % SSHD_CONFIG)
        fabtools.require.file(SSHD_CONFIG, contents=dedent(content))

        check_disable_password_auth(SSHD_CONFIG)
        check_disable_root_login(SSHD_CONFIG)
        check_enable_password_auth(SSHD_CONFIG)
        check_enable_root_login(SSHD_CONFIG)

    for content in SSHD_CONFIG_CONTENT:

        run('rm -f %s' % SSHD_CONFIG)
        fabtools.require.file(SSHD_CONFIG, contents=dedent(content))

        check_enable_password_auth(SSHD_CONFIG)
        check_enable_root_login(SSHD_CONFIG)
        check_disable_password_auth(SSHD_CONFIG)
        check_disable_root_login(SSHD_CONFIG)

########NEW FILE########
__FILENAME__ = system
from __future__ import with_statement

from fabric.api import task


@task
def locales():
    """
    Check locales configuration
    """

    from fabtools import require

    require.system.locale('en_US.UTF-8')
    require.system.locale('fr_FR.UTF-8')

########NEW FILE########
__FILENAME__ = tomcat
#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import with_statement

import os

from fabric.api import task

from fabtools import require, tomcat
from fabtools.files import is_file


@task
def should_verify_tomcat_7_version(path="/usr/share/tomcat"):
    """
    Test high level API
    """

    require.oracle_jdk.installed()
    require.tomcat.installed()

    assert is_file(os.path.join(path, 'bin/catalina.sh'))
    assert tomcat.DEFAULT_VERSION == tomcat.version(path)


@task
def should_verify_tomcat_6_version(path="/usr/share/tomcat"):
    """
    Test high level API
    """
    tomcat6 = '6.0.36'

    require.oracle_jdk.installed()
    require.tomcat.installed(version=tomcat6)

    assert is_file(os.path.join(path, 'bin/catalina.sh'))
    assert tomcat6 == tomcat.version(path)

########NEW FILE########
__FILENAME__ = users
from __future__ import with_statement

import os

from fabric.api import run, task


@task
def should_create_user_without_home_directory():

    import fabtools

    fabtools.user.create('user1', create_home=False)

    assert fabtools.user.exists('user1')
    assert not fabtools.files.is_dir('/home/user1')


@task
def should_create_user_with_default_home_directory():

    import fabtools

    fabtools.user.create('user2')

    assert fabtools.user.exists('user2')
    assert fabtools.files.is_dir('/home/user2')


@task
def should_create_user_with_home_directory():

    import fabtools

    fabtools.user.create('user3', home='/tmp/user3')

    assert fabtools.user.exists('user3')
    assert not fabtools.files.is_dir('/home/user3')
    assert fabtools.files.is_dir('/tmp/user3')


@task
def should_create_system_user_without_home_directory():

    import fabtools

    fabtools.user.create('user4', system=True)

    assert not fabtools.files.is_dir('/home/user4')


@task
def should_create_system_user_with_home_directory():

    import fabtools

    fabtools.user.create('user5', system=True,
                         create_home=True, home='/var/lib/foo')

    assert fabtools.files.is_dir('/var/lib/foo')

    # create two user with same uid
    fabtools.user.create('user6', uid='1000', non_unique=True)
    uid6 = int(run("id -u user6"))
    fabtools.user.create('user7', uid='1000', non_unique=True)
    uid7 = int(run("id -u user7"))
    assert 1000 == uid6 == uid7


@task
def require_users():
    """
    Check user creation and modification using fabtools.require
    """

    from fabtools import require
    import fabtools

    # require that a user exist, without home directory
    require.user('req1', create_home=False)
    assert fabtools.user.exists('req1')
    assert not fabtools.files.is_dir('/home/req1')

    # require again
    require.user('req1')

    # require that a user exist, with default home directory
    require.user('req2', create_home=True)
    assert fabtools.user.exists('req2')
    assert fabtools.files.is_dir('/home/req2')

    # require that a user exist, with custom home directory
    require.user('req3', home='/home/other')
    assert fabtools.user.exists('req3')
    assert not fabtools.files.is_dir('/home/req3')
    assert fabtools.files.is_dir('/home/other')


@task
def require_ssh_public_keys():
    """
    Check addition of SSH public key
    """

    from fabtools.user import authorized_keys
    from fabtools import require

    tests_dir = os.path.dirname(os.path.dirname(__file__))
    public_key_filename = os.path.join(tests_dir, 'id_test.pub')

    with open(public_key_filename) as public_key_file:
        public_key = public_key_file.read().strip()

    require.user('req4', home='/tmp/req4', ssh_public_keys=public_key_filename)

    keys = authorized_keys('req4')
    assert keys == [public_key], keys

    # let's try add same keys second time
    require.user('req4', home='/tmp/req4', ssh_public_keys=public_key_filename)

    keys = authorized_keys('req4')
    assert keys == [public_key], keys

########NEW FILE########
__FILENAME__ = test_files
import hashlib
import unittest

from mock import patch


@patch('fabtools.require.files._mode')
@patch('fabtools.require.files._owner')
@patch('fabtools.require.files.umask')
@patch('fabtools.require.files.put')
@patch('fabtools.require.files.md5sum')
@patch('fabtools.require.files.is_file')
class FilesTestCase(unittest.TestCase):

    def _file(self, *args, **kwargs):
        """ Proxy to ensure ImportErrors actually cause test failures rather
        than trashing the test run entirely """
        from fabtools import require
        require.files.file(*args, **kwargs)

    def test_verify_remote_false(self, is_file, md5sum, put, umask, owner, mode):
        """ If verify_remote is set to False, then we should find that
        only is_file is used to check for the file's existence. Hashlib's
        md5 should not have been called.
        """
        is_file.return_value = True
        self._file(contents='This is a test', verify_remote=False)
        self.assertTrue(is_file.called)
        self.assertFalse(md5sum.called)

    def test_verify_remote_true(self, is_file, md5sum, put, umask, owner, mode):
        """ If verify_remote is True, then we should find that an MD5 hash is
        used to work out whether the file is different.
        """
        is_file.return_value = True
        md5sum.return_value = hashlib.md5('This is a test').hexdigest()
        self._file(contents='This is a test', verify_remote=True)
        self.assertTrue(is_file.called)
        self.assertTrue(md5sum.called)

    def test_temp_dir(self, is_file, md5sum, put, umask, owner, mode):
        owner.return_value = 'root'
        umask.return_value = '0002'
        mode.return_value = '0664'
        from fabtools import require
        require.file('/var/tmp/foo', source=__file__, use_sudo=True, temp_dir='/somewhere')
        put.assert_called_with(__file__, '/var/tmp/foo', use_sudo=True, temp_dir='/somewhere')

    def test_home_as_temp_dir(self, is_file, md5sum, put, umask, owner, mode):
        owner.return_value = 'root'
        umask.return_value = '0002'
        mode.return_value = '0664'
        from fabtools import require
        require.file('/var/tmp/foo', source=__file__, use_sudo=True, temp_dir='')
        put.assert_called_with(__file__, '/var/tmp/foo', use_sudo=True, temp_dir='')

    def test_default_temp_dir(self, is_file, md5sum, put, umask, owner, mode):
        owner.return_value = 'root'
        umask.return_value = '0002'
        mode.return_value = '0664'
        from fabtools import require
        require.file('/var/tmp/foo', source=__file__, use_sudo=True)
        put.assert_called_with(__file__, '/var/tmp/foo', use_sudo=True, temp_dir='/tmp')


class TestUploadTemplate(unittest.TestCase):

    @patch('fabtools.files.run')
    @patch('fabtools.files._upload_template')
    def test_mkdir(self, mock_upload_template, mock_run):

        from fabtools.files import upload_template

        upload_template('filename', '/path/to/destination', mkdir=True)

        args, kwargs = mock_run.call_args
        self.assertEqual(args[0], 'mkdir -p /path/to')

    @patch('fabtools.files.sudo')
    @patch('fabtools.files._upload_template')
    def test_mkdir_sudo(self, mock_upload_template, mock_sudo):

        from fabtools.files import upload_template

        upload_template('filename', '/path/to/destination', mkdir=True, use_sudo=True)

        args, kwargs = mock_sudo.call_args
        self.assertEqual(args[0], 'mkdir -p /path/to')
        self.assertEqual(kwargs['user'], None)

    @patch('fabtools.files.sudo')
    @patch('fabtools.files._upload_template')
    def test_mkdir_sudo_user(self, mock_upload_template, mock_sudo):

        from fabtools.files import upload_template

        upload_template('filename', '/path/to/destination', mkdir=True, use_sudo=True, user='alice')

        args, kwargs = mock_sudo.call_args
        self.assertEqual(args[0], 'mkdir -p /path/to')
        self.assertEqual(kwargs['user'], 'alice')

    @patch('fabtools.files.run_as_root')
    @patch('fabtools.files._upload_template')
    def test_chown(self, mock_upload_template, mock_run_as_root):

        from fabric.api import env
        from fabtools.files import upload_template

        upload_template('filename', 'destination', chown=True)

        args, kwargs = mock_run_as_root.call_args
        self.assertEqual(args[0], 'chown %s: destination' % env.user)

    @patch('fabtools.files.run_as_root')
    @patch('fabtools.files._upload_template')
    def test_chown_user(self, mock_upload_template, mock_run_as_root):

        from fabtools.files import upload_template

        upload_template('filename', 'destination', chown=True, user='alice')

        args, kwargs = mock_run_as_root.call_args
        self.assertEqual(args[0], 'chown alice: destination')

    @patch('fabtools.files._upload_template')
    def test_use_jinja_true(self, mock_upload_template):

        from fabtools.files import upload_template

        upload_template('filename', 'destination', use_jinja=True)

        args, kwargs = mock_upload_template.call_args
        self.assertEqual(kwargs['use_jinja'], True)

    @patch('fabtools.files._upload_template')
    def test_use_jinja_false(self, mock_upload_template):

        from fabtools.files import upload_template

        upload_template('filename', 'destination', use_jinja=False)

        args, kwargs = mock_upload_template.call_args
        self.assertEqual(kwargs['use_jinja'], False)

########NEW FILE########
__FILENAME__ = test_group
import unittest

import mock


class CreateGroupTestCase(unittest.TestCase):

    @mock.patch('fabtools.group.run_as_root')
    def test_gid_str(self, mock_run_as_root):
        from fabtools.group import create
        create('some_group', gid='421')

    @mock.patch('fabtools.group.run_as_root')
    def test_gid_int(self, mock_run_as_root):
        from fabtools.group import create
        create('some_group', gid=421)

########NEW FILE########
__FILENAME__ = test_oracle_jdk

import mock
import unittest


class OracleJdkTestCase(unittest.TestCase):

    @mock.patch('fabtools.oracle_jdk.get_arch')
    def test_jdk_arch_for_x64_system(self, get_arch):

        from fabtools.oracle_jdk import _required_jdk_arch

        get_arch.return_value = 'x86_64'

        self.assertEqual('x64', _required_jdk_arch())

    @mock.patch('fabtools.oracle_jdk.get_arch')
    def test_jdk_arch_for_32bit_system(self, get_arch):

        from fabtools.oracle_jdk import _required_jdk_arch

        for system_arch in ['i386', 'i486', 'i586', 'i686']:

            get_arch.return_value = system_arch

            self.assertEqual('i586', _required_jdk_arch())

    @mock.patch('fabtools.oracle_jdk.get_arch')
    def test_jdk_arch_for_unknown_system(self, get_arch):

        from fabtools.oracle_jdk import _required_jdk_arch

        get_arch.return_value = 'unknown'

        self.assertRaises(Exception, _required_jdk_arch)

    def test_jdk_version_with_update_over_ten(self):

        from fabtools.oracle_jdk import _extract_jdk_version

        java_version_out = '''java version "1.7.0_13"
Java(TM) SE Runtime Environment (build 1.7.0_13-b20)
Java HotSpot(TM) Client VM (build 23.7-b01, mixed mode)

'''

        self.assertEqual('7u13-b20', _extract_jdk_version(java_version_out))

    def test_jdk_version_with_update_under_ten(self):

        from fabtools.oracle_jdk import _extract_jdk_version

        java_version_out = '''java version "1.7.0_09"
Java(TM) SE Runtime Environment (build 1.7.0_09-b05)
Java HotSpot(TM) 64-Bit Server VM (build 23.5-b02, mixed mode)
'''

        self.assertEqual('7u9-b05', _extract_jdk_version(java_version_out))

    def test_jdk_version_with_openjdk(self):

        from fabtools.oracle_jdk import _extract_jdk_version

        java_version_out = '''java version "1.7.0_21"
OpenJDK Runtime Environment (IcedTea 2.3.9) (7u21-2.3.9-0ubuntu0.12.04.1)
OpenJDK 64-Bit Server VM (build 23.7-b01, mixed mode)
'''

        self.assertEqual(None, _extract_jdk_version(java_version_out))

########NEW FILE########
__FILENAME__ = test_postgres
import mock
import unittest


class TestRequirePostgresDatabase(unittest.TestCase):

    @mock.patch('fabtools.require.postgres._service_name')
    @mock.patch('fabtools.require.postgres.restarted')
    @mock.patch('fabtools.require.postgres.require_locale')
    @mock.patch('fabtools.require.postgres.create_database')
    @mock.patch('fabtools.require.postgres.run')
    @mock.patch('fabtools.require.postgres.database_exists')
    def test_params_respected(self, database_exists, run, create_database,
                              require_locale, restarted, service_name):
        """
        If require.database is called, ensure that the template,
        encoding and locale parameters are passed through to the
        underlying create_database call
        """
        from fabtools import require
        database_exists.return_value = False
        run.return_value = 'en-US.UTF-8\nde-DE.UTF-8'
        require.postgres.database('foo', 'bar', locale='some_locale',
                                  encoding='some_encoding',
                                  template='some_template')
        run.assert_called_with('locale -a')
        require_locale.assert_called_with('some_locale')
        create_database.assert_called_with('foo', 'bar', locale='some_locale',
                                           encoding='some_encoding',
                                           template='some_template')


class TestRequirePostgresUser(unittest.TestCase):

    @mock.patch('fabtools.require.postgres.create_user')
    @mock.patch('fabtools.require.postgres.user_exists')
    def test_require_user_exists(self, user_exists, create_user):
        user_exists.return_value = True
        from fabtools import require
        require.postgres.user('foo', 'bar')
        user_exists.assert_called_with('foo')
        self.assertEqual([], create_user.method_calls)

    @mock.patch('fabtools.require.postgres.create_user')
    @mock.patch('fabtools.require.postgres.user_exists')
    def test_require_user_with_default_options(self, user_exists, create_user):
        user_exists.return_value = False
        from fabtools import require
        require.postgres.user('foo', 'bar')
        create_user.assert_called_with('foo', 'bar', False, False, False, True,
                                       True, None, False)


class TestPostgresCreateUser(unittest.TestCase):

    @mock.patch('fabtools.postgres._run_as_pg')
    def test_create_user_with_no_options(self, _run_as_pg):
        from fabtools import postgres
        postgres.create_user('foo', 'bar')
        expected = (
            'psql -c "CREATE USER foo NOSUPERUSER NOCREATEDB NOCREATEROLE '
            'INHERIT LOGIN UNENCRYPTED PASSWORD \'bar\';"')
        self.assertEqual(expected, _run_as_pg.call_args[0][0])

    @mock.patch('fabtools.postgres._run_as_pg')
    def test_create_user_with_no_connection_limit(self, _run_as_pg):
        from fabtools import postgres
        postgres.create_user('foo', 'bar', connection_limit=-1)
        expected = (
            'psql -c "CREATE USER foo NOSUPERUSER NOCREATEDB NOCREATEROLE '
            'INHERIT LOGIN CONNECTION LIMIT -1 UNENCRYPTED PASSWORD \'bar\';"')
        self.assertEqual(expected, _run_as_pg.call_args[0][0])

    @mock.patch('fabtools.postgres._run_as_pg')
    def test_create_user_with_custom_options(self, _run_as_pg):
        from fabtools import postgres
        postgres.create_user('foo', 'bar', superuser=True, createdb=True,
                             createrole=True, inherit=False, login=False,
                             connection_limit=20, encrypted_password=True)
        expected = (
            'psql -c "CREATE USER foo SUPERUSER CREATEDB CREATEROLE '
            'NOINHERIT NOLOGIN CONNECTION LIMIT 20 '
            'ENCRYPTED PASSWORD \'bar\';"')
        self.assertEqual(expected, _run_as_pg.call_args[0][0])


class TestPostgresDropUser(unittest.TestCase):

    @mock.patch('fabtools.postgres._run_as_pg')
    def test_drop_user(self, _run_as_pg):

        from fabtools.postgres import drop_user

        drop_user('foo')

        _run_as_pg.assert_called_with('psql -c "DROP USER foo;"')


class TestPostgresDropDatabase(unittest.TestCase):

    @mock.patch('fabtools.postgres._run_as_pg')
    def test_drop_database(self, _run_as_pg):

        from fabtools.postgres import drop_database

        drop_database('foo')

        _run_as_pg.assert_called_with('dropdb foo')

########NEW FILE########
__FILENAME__ = test_python
import mock
import unittest


class PythonTestCase(unittest.TestCase):

    @mock.patch('fabtools.python.run')
    def test_is_pip_installed_pythonbrew(self, mock_run):

        from fabric.operations import _AttributeString
        from fabtools.python import is_pip_installed

        fake_result = _AttributeString(
            '\x1b[32mSwitched to Python-2.7.5'
            '\x1b[0mpip 1.4.1 from /home/vagrant/.pythonbrew/pythons/Python-2.7.5/lib/python2.7/site-packages/pip-1.4.1-py2.7.egg (python 2.7)'
        )
        fake_result.failed = False
        fake_result.succeeded = True
        mock_run.return_value = fake_result

        res = is_pip_installed(version='1.3.1')

        self.assertTrue(res)

########NEW FILE########
__FILENAME__ = test_redis
import unittest


class RedisTestCase(unittest.TestCase):

    def test_parse_version(self):

        from fabtools.require.redis import _parse_version

        self.assertEqual(
            _parse_version('2.6.14'),
            (2, 6, 14)
        )

    def test_old_download_url(self):

        from fabtools.require.redis import _download_url

        self.assertEqual(
            _download_url('2.6.14'),
            'http://redis.googlecode.com/files/'
        )

    def test_new_download_url(self):

        from fabtools.require.redis import _download_url

        self.assertEqual(
            _download_url('2.6.15'),
            'http://download.redis.io/releases/'
        )

########NEW FILE########
__FILENAME__ = test_shorewall
import unittest


class ShorewallTestCase(unittest.TestCase):
    pass

########NEW FILE########
__FILENAME__ = test_system
from __future__ import with_statement

try:
    import unittest2 as unittest
except ImportError:
    import unittest

from mock import patch


class TestUnsupportedFamily(unittest.TestCase):

    def test_unsupported_system(self):

        from fabtools.system import UnsupportedFamily

        with self.assertRaises(UnsupportedFamily) as cm:

            with patch('fabtools.system.distrib_id') as mock_distrib_id:
                mock_distrib_id.return_value = 'foo'

                raise UnsupportedFamily(supported=['debian', 'redhat'])


        exception_msg = str(cm.exception)
        self.assertEquals(exception_msg, "Unsupported system foo (supported families: debian, redhat)")

########NEW FILE########
__FILENAME__ = test_user
import unittest

import mock


class CreateUserTestCase(unittest.TestCase):

    @mock.patch('fabtools.user.run_as_root')
    def test_uid_str(self, mock_run_as_root):
        from fabtools.user import create
        create('alice', uid='421')

    @mock.patch('fabtools.user.run_as_root')
    def test_uid_int(self, mock_run_as_root):
        from fabtools.user import create
        create('alice', uid=421)

########NEW FILE########
__FILENAME__ = test_vagrant
import fnmatch
import os
import os.path

from fabric.main import load_fabfile


def load_tests(loader, suite, patterns):
    """
    Custom test loader for functional tests
    """

    # Optional include/exclude list of fabfiles
    include_files = os.environ.get('FABTOOLS_TEST_INCLUDE', '').split()
    exclude_files = os.environ.get('FABTOOLS_TEST_EXCLUDE', '').split()

    # Try to add vagrant functional tests
    from .vagrant import test_boxes, VagrantTestCase, VagrantTestSuite
    boxes = test_boxes()
    if boxes:
        vagrant_suite = VagrantTestSuite(boxes)

        # Add a test case for each task in each fabfile
        fabfiles = os.path.join(os.path.dirname(__file__), 'fabfiles')
        for filename in sorted(os.listdir(fabfiles)):
            if fnmatch.fnmatch(filename, '[!_]*.py'):
                # Skip file if in exclude list
                if filename in exclude_files:
                    continue
                # Skip file if it's not in an explicit include list
                if include_files and filename not in include_files:
                    continue
                fabfile = os.path.join(fabfiles, filename)
                _, tasks, _ = load_fabfile(fabfile)
                for name, callable in tasks.iteritems():
                    test = VagrantTestCase(name, callable)
                    vagrant_suite.addTest(test)

        suite.addTest(vagrant_suite)

    return suite

########NEW FILE########
__FILENAME__ = test_vagrant_base_boxes
import textwrap
import unittest

from mock import patch


class TestParseVagrantMachineReadableBoxList(unittest.TestCase):

    def test_machine_readable_box_list(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent(r"""
                1391708688,,box-name,lucid32
                1391708688,,box-provider,virtualbox
                1391708688,,box-name,precise64
                1391708688,,box-provider,virtualbox
                1391708688,,box-name,precise64
                1391708688,,box-provider,vmware_fusion
                """)
            from fabtools.vagrant import _box_list_machine_readable
            res = _box_list_machine_readable()
            self.assertEqual(res, [
                ('lucid32', 'virtualbox'),
                ('precise64', 'virtualbox'),
                ('precise64', 'vmware_fusion'),
            ])


class TestParseVagrantBoxListWithProvider(unittest.TestCase):

    def test_parse_box_list(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent("""\
                lucid32                   (virtualbox)
                precise64                 (virtualbox)
                precise64                 (vmware_fusion)
                """)
            from fabtools.vagrant import _box_list_human_readable
            res = _box_list_human_readable()
            self.assertEqual(res, [
                ('lucid32', 'virtualbox'),
                ('precise64', 'virtualbox'),
                ('precise64', 'vmware_fusion'),
            ])


class TestParseVagrantBoxListWithoutProvider(unittest.TestCase):

    def test_parse_box_list(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent("""\
                lucid32
                precise64
                """)
            from fabtools.vagrant import _box_list_human_readable
            res = _box_list_human_readable()
            self.assertEqual(res, [
                ('lucid32', 'virtualbox'),
                ('precise64', 'virtualbox'),
            ])


class TestVagrantBaseBoxes(unittest.TestCase):

    def test_vagrant_base_boxes(self):
        with patch('fabtools.vagrant._box_list') as mock_list:
            mock_list.return_value = [
                ('lucid32', 'virtualbox'),
                ('precise64', 'virtualbox'),
                ('precise64', 'vmware_fusion'),
            ]
            from fabtools.vagrant import base_boxes
            self.assertEqual(base_boxes(), ['lucid32', 'precise64'])

########NEW FILE########
__FILENAME__ = test_vagrant_machines
import unittest

from mock import patch


class TestVagrantMachines(unittest.TestCase):

    def test_machines_one(self):
        with patch('fabtools.vagrant._status') as mock_status:
            mock_status.return_value = [('default', 'running')]
            from fabtools.vagrant import machines
            self.assertEqual(machines(), ['default'])

########NEW FILE########
__FILENAME__ = test_vagrant_status
import textwrap
import unittest

from mock import patch


class TestParseVagrantMachineReadableStatus(unittest.TestCase):

    def test_machine_readable_status_running(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent(r"""
                1391354677,default,provider-name,vmware_fusion
                1391354677,default,state,running
                1391354677,default,state-human-short,running
                1391354677,default,state-human-long,The VM is running. To stop this VM%!(VAGRANT_COMMA) you can run `vagrant halt` to\nshut it down%!(VAGRANT_COMMA) or you can run `vagrant suspend` to simply suspend\nthe virtual machine. In either case%!(VAGRANT_COMMA) to restart it again%!(VAGRANT_COMMA) run\n`vagrant up`.
                """)
            from fabtools.vagrant import _status_machine_readable
            res = _status_machine_readable()
            self.assertEqual(res, [('default', 'running')])

    def test_machine_readable_status_not_running(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent(r"""
                1391366299,default,provider-name,vmware_fusion
                1391366299,default,state,not_running
                1391366299,default,state-human-short,not running
                1391366299,default,state-human-long,The VM is powered off. To restart the VM%!(VAGRANT_COMMA) run `vagrant up`
                """)
            from fabtools.vagrant import _status_machine_readable
            res = _status_machine_readable()
            self.assertEqual(res, [('default', 'not running')])


class TestParseVagrantStatusWithProvider(unittest.TestCase):

    def test_parse_status_running(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent("""\
                Current machine states:

                default                   running (vmware_fusion)

                The VM is running. To stop this VM, you can run `vagrant halt` to
                shut it down, or you can run `vagrant suspend` to simply suspend
                the virtual machine. In either case, to restart it again, run
                `vagrant up`.
                """)
            from fabtools.vagrant import _status_human_readable
            res = _status_human_readable()
            self.assertEqual(res, [('default', 'running')])

    def test_parse_status_not_created(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent("""\
                Current machine states:

                default                   not created (vmware_fusion)

                The VMware machine has not yet been created. Run `vagrant up`
                to create the machine. If a machine is not created, only the
                default provider will be shown. Therefore, if a provider is not listed,
                then the machine is not created for that provider.
                """)
            from fabtools.vagrant import _status_human_readable
            res = _status_human_readable()
            self.assertEqual(res, [('default', 'not created')])


class TestParseVagrantStatusWithoutProvider(unittest.TestCase):

    def test_parse_status_running(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent("""\
                Current machine states:

                default                   running

                The VM is running. To stop this VM, you can run `vagrant halt` to
                shut it down, or you can run `vagrant suspend` to simply suspend
                the virtual machine. In either case, to restart it again, run
                `vagrant up`.
                """)
            from fabtools.vagrant import _status_human_readable
            res = _status_human_readable()
            self.assertEqual(res, [('default', 'running')])

    def test_parse_status_not_created(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = textwrap.dedent("""\
                Current machine states:

                default                   not created

                The VMware machine has not yet been created. Run `vagrant up`
                to create the machine. If a machine is not created, only the
                default provider will be shown. Therefore, if a provider is not listed,
                then the machine is not created for that provider.
                """)
            from fabtools.vagrant import _status_human_readable
            res = _status_human_readable()
            self.assertEqual(res, [('default', 'not created')])


class TestVagrantStatus(unittest.TestCase):

    def test_status(self):
        with patch('fabtools.vagrant._status') as mock_status:
            mock_status.return_value = [('default', 'running')]
            from fabtools.vagrant import status
            self.assertEqual(status(), 'running')

########NEW FILE########
__FILENAME__ = test_vagrant_version
import unittest

from mock import patch


class TestVagrantVersion(unittest.TestCase):

    def test_vagrant_version_1_3_0(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = "Vagrant version 1.3.0\n"
            from fabtools.vagrant import version
            self.assertEqual(version(), (1, 3, 0))

    def test_vagrant_version_1_3_1(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = "Vagrant v1.3.1\n"
            from fabtools.vagrant import version
            self.assertEqual(version(), (1, 3, 1))

    def test_vagrant_version_1_4_3(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = "Vagrant 1.4.3\n"
            from fabtools.vagrant import version
            self.assertEqual(version(), (1, 4, 3))

    def test_vagrant_version_1_5_0_dev(self):
        with patch('fabtools.vagrant.local') as mock_local:
            mock_local.return_value = "Vagrant 1.5.0.dev\n"
            from fabtools.vagrant import version
            self.assertEqual(version(), (1, 5, 0, 'dev'))

########NEW FILE########
__FILENAME__ = vagrant
from __future__ import with_statement

import os

try:
    import unittest2 as unittest
except ImportError:
    import unittest

from fabric.api import env, hide, lcd, local, settings, shell_env
from fabric.state import connections

import fabtools
from fabtools import require
from fabtools.vagrant import base_boxes, status, version


def halt_and_destroy():
    """
    Halt and destoy virtual machine
    """
    with lcd(os.path.dirname(__file__)):
        if os.path.exists(os.path.join(env['lcwd'], 'Vagrantfile')):
            local('vagrant halt')
            if version() >= (0, 9, 99):
                local('vagrant destroy -f')
            else:
                local('vagrant destroy')


def test_boxes():
    """
    Get the list of vagrant base boxes to use

    The default is to get the list of all base boxes.

    This can be overridden with the FABTOOLS_TEST_BOXES environment variable.
    """
    boxes = os.environ.get('FABTOOLS_TEST_BOXES')
    if boxes is not None:
        return boxes.split()
    else:
        return base_boxes()


class VagrantTestSuite(unittest.BaseTestSuite):
    """
    Test suite with vagrant support
    """

    def __init__(self, base_boxes):
        self.base_boxes = base_boxes
        self.current_box = None
        unittest.BaseTestSuite.__init__(self)

    def addTest(self, test):
        test._suite = self
        unittest.BaseTestSuite.addTest(self, test)

    def run(self, result):
        """
        Run the test suite on all the virtual machines
        """
        for base_box in self.base_boxes:

            # Start a virtual machine using this base box
            self.current_box = base_box
            self.start_box()

            # Clear fabric connection cache
            with self.settings():
                if env.host_string in connections:
                    del connections[env.host_string]

            # Make sure the vagrant user can sudo to any user
            with self.settings():
                require.sudoer('vagrant')

            # Make sure the package index is up to date
            with self.settings():
                if fabtools.system.distrib_family() == 'debian':
                    fabtools.deb.update_index()

            # Run the test suite
            unittest.BaseTestSuite.run(self, result)

            # Stop the virtual machine and clean up
            self.stop_box()

    def start_box(self):
        """
        Spin up a new vagrant box
        """

        # Support for Vagrant 1.1 providers
        if ':' in self.current_box:
            box_name, provider = self.current_box.split(':', 1)
        else:
            box_name = self.current_box
            provider = None

        with lcd(os.path.dirname(__file__)):

            if not os.path.exists('Vagrantfile') \
               or not os.environ.get('FABTOOLS_TEST_NODESTROY'):

                # Create a fresh vagrant config file
                local('rm -f Vagrantfile')
                local('vagrant init %s' % box_name)

                # Clean up
                if status() != 'not created':
                    halt_and_destroy()

            if provider:
                options = ' --provider %s' % provider
            else:
                options = ''

            # Spin up the box
            # (retry as it sometimes fails for no good reason)
            cmd = 'vagrant up%s' % options
            local('%s || %s' % (cmd, cmd))

    def ssh_config(self):
        """
        Get SSH connection parameters for the current box
        """
        with lcd(os.path.dirname(__file__)):
            if version() >= (0, 9, 0):
                command = 'ssh-config'
            else:
                command = 'ssh_config'
            with settings(hide('running')):
                output = local('vagrant %s' % command, capture=True)

        config = {}
        for line in output.splitlines()[1:]:
            key, value = line.strip().split(' ', 2)
            config[key] = value
        return config

    def stop_box(self):
        """
        Spin down the vagrant box
        """
        if not os.environ.get('FABTOOLS_TEST_NODESTROY'):
            halt_and_destroy()
            with lcd(os.path.dirname(__file__)):
                local('rm -f Vagrantfile')
        self.current_box = None

    def settings(self, *args, **kwargs):
        """
        Return a Fabric context manager with the right host settings
        """
        config = self.ssh_config()

        user = config['User']
        hostname = config['HostName']
        port = config['Port']

        kwargs['host_string'] = "%s@%s:%s" % (user, hostname, port)
        kwargs['user'] = user
        kwargs['key_filename'] = config['IdentityFile'].strip('"')
        kwargs['disable_known_hosts'] = True

        return settings(*args, **kwargs)


class VagrantTestCase(unittest.TestCase):
    """
    Test case with vagrant support
    """

    def __init__(self, name, callable):
        super(VagrantTestCase, self).__init__()
        self._name = name
        self._callable = callable

    def run(self, result=None):
        """
        Run the test case within a Fabric context manager
        """
        with self._suite.settings():
            http_proxy = os.environ.get('FABTOOLS_HTTP_PROXY', '')
            with shell_env(http_proxy=http_proxy):
                unittest.TestCase.run(self, result)

    def runTest(self):
        self._callable()

########NEW FILE########
__FILENAME__ = tomcat
"""
Tomcat
=======

This module provides tools for installing `Tomcat`_.

.. _Tomcat: http://tomcat.apache.org/

"""
from __future__ import with_statement

import os
import re

from fabric.api import cd, hide, run, settings
from fabric.operations import put

from fabtools.files import is_file, is_link, is_dir
from fabtools.service import start, stop
from fabtools.utils import run_as_root

# Default parameters
DEFAULT_VERSION = '7.0.47'
DEFAULT_INSTALLATION_PATH = "/usr/share/tomcat"
DEFAULT_MIRROR = "http://archive.apache.org"


def install_from_source(path=DEFAULT_INSTALLATION_PATH,
                        version=DEFAULT_VERSION,
                        mirror=DEFAULT_MIRROR,
                        overwrite=False):
    """
    Install Tomcat from source.

    ::

        import fabtools

        # Install Tomcat
        fabtools.tomcat.install_from_source(version='6.0.36')

    """
    from fabtools.require import file as require_file
    from fabtools.require.files import directory as require_directory

    # Tokenize version into parts
    version_tokens = version.split('.')
    version_major = version_tokens[0]

    # Parse the filename and folder
    file_name = 'apache-tomcat-%s.tar.gz' % version
    folder_name = 'apache-tomcat-%s' % version

    # Build the distribution in /tmp
    with cd('/tmp'):
        # Make sure we have the tarball downloaded.
        if not is_file(os.path.join('/tmp/', file_name)):
            # Otherwise, download the tarball based on our mirror and version.
            tomcat_url = '%s/dist/tomcat/tomcat-%s/v%s/bin/%s' % (mirror, version_major, version, file_name)

            # Ensure the file has been downloaded
            require_file(url=tomcat_url)

        # Extract the file
        run('tar -xzf %s' % file_name)

        # Handle possibility of existing path
        if is_dir(path):
            if overwrite is False:
                # Raise exception as we don't want to overwrite
                raise OSError("Path %s already exists and overwrite not set." % path)
            else:
                # Otherwise, backup the tomcat path
                backup_installation_path = path + ".backup"
                if is_dir(backup_installation_path):
                    run_as_root("rm -rf %s" % backup_installation_path)
                run_as_root("mv %s %s" % (path, backup_installation_path))

        """
        After all that, let's ensure we have the installation path setup
        properly and place the install.
        """
        require_directory(path, mode='755', use_sudo=True)
        run_as_root('mv %s/* %s' % (folder_name, path))

        # Now cleanup temp.
        run("rm -rf %s*" % file_name)

    # Finally, configure and start Tomcat
    configure_tomcat(path, overwrite=overwrite)
    start_tomcat()


def configure_tomcat(path, overwrite=False):
    from fabric.contrib.files import append
    startup_script = """
# Tomcat auto-start
#
# description: Auto-starts tomcat
# processname: tomcat
# pidfile: /var/run/tomcat.pid

case $1 in
start)
sh %(path)s/bin/startup.sh
;;
stop)
sh %(path)s/bin/shutdown.sh
;;
restart)
sh %(path)s/bin/shutdown.sh
sh %(path)s/bin/startup.sh
;;
esac
exit 0""" % {'path': path}

    # Check for existing files and overwrite.
    if is_file('/etc/init.d/tomcat'):
        if overwrite is False:
            raise OSError("/etc/init.d/tomcat already exists and not overwriting.")
        else:
            run_as_root("rm -f /etc/init.d/tomcat")

    # Now create the file and symlinks.
    append('/etc/init.d/tomcat', startup_script, use_sudo=True)
    run_as_root('chmod 755 /etc/init.d/tomcat')

    if not is_link('/etc/rc1.d/K99tomcat'):
        run_as_root('ln -s /etc/init.d/tomcat /etc/rc1.d/K99tomcat')

    if not is_link('/etc/rc2.d/S99tomcat'):
        run_as_root('ln -s /etc/init.d/tomcat /etc/rc2.d/S99tomcat')


def start_tomcat():
    """
    Start the Tomcat service.
    """
    start('tomcat')


def stop_tomcat():
    """
    Stop the Tomcat service.
    """
    stop('tomcat')


def version(path):
    """
    Get the version of currently installed tomcat.

    Returns ``None`` if it is not installed.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        res = run(os.path.join(path, 'bin/version.sh'))
    if res.failed:
        return None
    else:
        return _extract_tomcat_version(res)


def _extract_tomcat_version(tomcat_version_out):
    """
    Extracts tomcat version in format like '7.0.42'
    from 'tomcat/bin/version.sh' command output.
    """
    match = re.search(r'Server version: (.*)', tomcat_version_out)
    if match is None:
        return None
    match_version = match.group(1).split('/')[1].strip()
    return match_version


def deploy_application(war_file, webapp_path=None):
    """
    Deploy an application into the webapp path for a Tomcat installation.
    """
    # If no webapp path specified, used default installation.
    if not webapp_path:
        webapp_path = os.path.join(DEFAULT_INSTALLATION_PATH, 'webapps')

    # Now copy our WAR into the webapp path.
    put(local_path=war_file, remote_path=os.path.join(webapp_path, war_file), use_sudo=True)

########NEW FILE########
__FILENAME__ = user
"""
Users
=====
"""
from __future__ import with_statement

from pipes import quote
import posixpath
import random
import string

from fabric.api import hide, run, settings, sudo, local

from fabtools.group import (
    exists as _group_exists,
    create as _group_create,
)
from fabtools.files import uncommented_lines
from fabtools.utils import run_as_root


def exists(name):
    """
    Check if a user exists.
    """
    with settings(hide('running', 'stdout', 'warnings'), warn_only=True):
        return run('getent passwd %(name)s' % locals()).succeeded


_SALT_CHARS = string.ascii_letters + string.digits + './'


def _crypt_password(password):
    from crypt import crypt
    random.seed()
    salt = ''
    for _ in range(2):
        salt += random.choice(_SALT_CHARS)
    crypted_password = crypt(password, salt)
    return crypted_password


def create(name, comment=None, home=None, create_home=None, skeleton_dir=None,
           group=None, create_group=True, extra_groups=None, password=None,
           system=False, shell=None, uid=None, ssh_public_keys=None,
           non_unique=False):
    """
    Create a new user and its home directory.

    If *create_home* is ``None`` (the default), a home directory will be
    created for normal users, but not for system users.
    You can override the default behaviour by setting *create_home* to
    ``True`` or ``False``.

    If *system* is ``True``, the user will be a system account. Its UID
    will be chosen in a specific range, and it will not have a home
    directory, unless you explicitely set *create_home* to ``True``.

    If *shell* is ``None``, the user's login shell will be the system's
    default login shell (usually ``/bin/sh``).

    *ssh_public_keys* can be a (local) filename or a list of (local)
    filenames of public keys that should be added to the user's SSH
    authorized keys (see :py:func:`fabtools.user.add_ssh_public_keys`).

    Example::

        import fabtools

        if not fabtools.user.exists('alice'):
            fabtools.user.create('alice')

        with cd('/home/alice'):
            # ...

    """

    # Note that we use useradd (and not adduser), as it is the most
    # portable command to create users across various distributions:
    # http://refspecs.linuxbase.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/useradd.html

    args = []
    if comment:
        args.append('-c %s' % quote(comment))
    if home:
        args.append('-d %s' % quote(home))
    if group:
        args.append('-g %s' % quote(group))
        if create_group:
            if not _group_exists(group):
                _group_create(group)
    if extra_groups:
        groups = ','.join(quote(group) for group in extra_groups)
        args.append('-G %s' % groups)

    if create_home is None:
        create_home = not system
    if create_home is True:
        args.append('-m')
    elif create_home is False:
        args.append('-M')

    if skeleton_dir:
        args.append('-k %s' % quote(skeleton_dir))
    if password:
        crypted_password = _crypt_password(password)
        args.append('-p %s' % quote(crypted_password))
    if system:
        args.append('-r')
    if shell:
        args.append('-s %s' % quote(shell))
    if uid:
        args.append('-u %s' % uid)
        if non_unique:
            args.append('-o')
    args.append(name)
    args = ' '.join(args)
    run_as_root('useradd %s' % args)

    if ssh_public_keys:
        if isinstance(ssh_public_keys, basestring):
            ssh_public_keys = [ssh_public_keys]
        add_ssh_public_keys(name, ssh_public_keys)


def modify(name, comment=None, home=None, move_current_home=False, group=None,
           extra_groups=None, login_name=None, password=None, shell=None,
           uid=None, ssh_public_keys=None, non_unique=False):
    """
    Modify an existing user.

    *ssh_public_keys* can be a (local) filename or a list of (local)
    filenames of public keys that should be added to the user's SSH
    authorized keys (see :py:func:`fabtools.user.add_ssh_public_keys`).

    Example::

        import fabtools

        if fabtools.user.exists('alice'):
            fabtools.user.modify('alice', shell='/bin/sh')

    """

    args = []
    if comment:
        args.append('-c %s' % quote(comment))
    if home:
        args.append('-d %s' % quote(home))
        if move_current_home:
            args.append('-m')
    if group:
        args.append('-g %s' % quote(group))
    if extra_groups:
        groups = ','.join(quote(group) for group in extra_groups)
        args.append('-G %s' % groups)
    if login_name:
        args.append('-l %s' % quote(login_name))
    if password:
        crypted_password = _crypt_password(password)
        args.append('-p %s' % quote(crypted_password))
    if shell:
        args.append('-s %s' % quote(shell))
    if uid:
        args.append('-u %s' % quote(uid))
        if non_unique:
            args.append('-o')

    if args:
        args.append(name)
        args = ' '.join(args)
        run_as_root('usermod %s' % args)

    if ssh_public_keys:
        if isinstance(ssh_public_keys, basestring):
            ssh_public_keys = [ssh_public_keys]
        add_ssh_public_keys(name, ssh_public_keys)


def home_directory(name):
    """
    Get the absolute path to the user's home directory

    Example::

        import fabtools

        home = fabtools.user.home_directory('alice')

    """
    with settings(hide('running', 'stdout')):
        return run('echo ~' + name)


def local_home_directory(name=''):
    """
    Get the absolute path to the local user's home directory

    Example::

        import fabtools

        local_home = fabtools.user.local_home_directory()

    """
    with settings(hide('running', 'stdout')):
        return local('echo ~' + name, capture=True)


def authorized_keys(name):
    """
    Get the list of authorized SSH public keys for the user
    """

    ssh_dir = posixpath.join(home_directory(name), '.ssh')
    authorized_keys_filename = posixpath.join(ssh_dir, 'authorized_keys')

    return uncommented_lines(authorized_keys_filename, use_sudo=True)


def add_ssh_public_key(name, filename):
    """
    Add a public key to the user's authorized SSH keys.

    *filename* must be the local filename of a public key that should be
    added to the user's SSH authorized keys.

    Example::

        import fabtools

        fabtools.user.add_ssh_public_key('alice', '~/.ssh/id_rsa.pub')

    """

    add_ssh_public_keys(name, [filename])


def add_ssh_public_keys(name, filenames):
    """
    Add multiple public keys to the user's authorized SSH keys.

    *filenames* must be a list of local filenames of public keys that
    should be added to the user's SSH authorized keys.

    Example::

        import fabtools

        fabtools.user.add_ssh_public_keys('alice', [
            '~/.ssh/id1_rsa.pub',
            '~/.ssh/id2_rsa.pub',
        ])

    """

    from fabtools.require.files import (
        directory as _require_directory,
        file as _require_file,
    )

    ssh_dir = posixpath.join(home_directory(name), '.ssh')
    _require_directory(ssh_dir, mode='700', owner=name, use_sudo=True)

    authorized_keys_filename = posixpath.join(ssh_dir, 'authorized_keys')
    _require_file(authorized_keys_filename, mode='600', owner=name,
                  use_sudo=True)

    for filename in filenames:

        with open(filename) as public_key_file:
            public_key = public_key_file.read().strip()

        # we don't use fabric.contrib.files.append() as it's buggy
        if public_key not in authorized_keys(name):
            sudo('echo %s >>%s' % (quote(public_key),
                                   quote(authorized_keys_filename)))


def add_host_keys(name, hostname):
    """
    Add all public keys of a host to the user's SSH known hosts file
    """

    from fabtools.require.files import (
        directory as _require_directory,
        file as _require_file,
    )

    ssh_dir = posixpath.join(home_directory(name), '.ssh')
    _require_directory(ssh_dir, mode='700', owner=name, use_sudo=True)

    known_hosts_filename = posixpath.join(ssh_dir, 'known_hosts')
    _require_file(known_hosts_filename, mode='644', owner=name, use_sudo=True)

    known_hosts = uncommented_lines(known_hosts_filename, use_sudo=True)

    with hide('running', 'stdout'):
        res = run('ssh-keyscan -t rsa,dsa %s 2>/dev/null' % hostname)
    for host_key in res.splitlines():
        if host_key not in known_hosts:
            sudo('echo %s >>%s' % (quote(host_key),
                                   quote(known_hosts_filename)))

########NEW FILE########
__FILENAME__ = utils
"""
Utilities
=========
"""
from __future__ import with_statement

import os
import posixpath

from fabric.api import env, hide, run, sudo


def run_as_root(command, *args, **kwargs):
    """
    Run a remote command as the root user.

    When connecting as root to the remote system, this will use Fabric's
    ``run`` function. In other cases, it will use ``sudo``.
    """
    if env.user == 'root':
        func = run
    else:
        func = sudo
    return func(command, *args, **kwargs)


def get_cwd(local=False):

    from fabric.api import local as local_run

    with hide('running', 'stdout'):
        if local:
            return local_run('pwd', capture=True)
        else:
            return run('pwd')


def abspath(path, local=False):

    path_mod = os.path if local else posixpath

    if not path_mod.isabs(path):
        cwd = get_cwd(local=local)
        path = path_mod.join(cwd, path)

    return path_mod.normpath(path)


def download(url, retry=10):
    from fabtools.require.curl import command as require_curl
    require_curl()
    run('curl --silent --retry %s -O %s' % (retry, url))

########NEW FILE########
__FILENAME__ = vagrant
"""
Vagrant helpers
===============
"""
from __future__ import with_statement

import re

from fabric.api import env, hide, local, settings, task


def version():
    """
    Get the Vagrant version.
    """
    with settings(hide('running')):
        output = local('vagrant --version', capture=True)
    line = output.splitlines()[-1]
    version = re.match(r'Vagrant (?:v(?:ersion )?)?(.*)', line).group(1)
    return tuple(_to_int(part) for part in version.split('.'))


def _to_int(val):
    try:
        return int(val)
    except ValueError:
        return val


def ssh_config(name=''):
    """
    Get the SSH parameters for connecting to a vagrant VM.
    """
    with settings(hide('running')):
        output = local('vagrant ssh-config %s' % name, capture=True)

    config = {}
    for line in output.splitlines()[1:]:
        key, value = line.strip().split(' ', 2)
        config[key] = value
    return config


def _settings_dict(config):
    settings = {}

    user = config['User']
    hostname = config['HostName']
    port = config['Port']

    # Build host string
    host_string = "%s@%s:%s" % (user, hostname, port)

    settings['user'] = user
    settings['hosts'] = [host_string]
    settings['host_string'] = host_string

    # Strip leading and trailing double quotes introduced by vagrant 1.1
    settings['key_filename'] = config['IdentityFile'].strip('"')

    settings['forward_agent'] = (config.get('ForwardAgent', 'no') == 'yes')
    settings['disable_known_hosts'] = True

    return settings


@task
def vagrant(name=''):
    """
    Run the following tasks on a vagrant box.

    First, you need to import this task in your ``fabfile.py``::

        from fabric.api import *
        from fabtools.vagrant import vagrant

        @task
        def some_task():
            run('echo hello')

    Then you can easily run tasks on your current Vagrant box::

        $ fab vagrant some_task

    """
    config = ssh_config(name)

    extra_args = _settings_dict(config)
    env.update(extra_args)


def vagrant_settings(name='', *args, **kwargs):
    """
    Context manager that sets a vagrant VM
    as the remote host.

    Use this context manager inside a task to run commands
    on your current Vagrant box::

        from fabtools.vagrant import vagrant_settings

        with vagrant_settings():
            run('hostname')
    """
    config = ssh_config(name)

    extra_args = _settings_dict(config)
    kwargs.update(extra_args)

    return settings(*args, **kwargs)


def status(name='default'):
    """
    Get the status of a vagrant machine
    """
    machine_states = dict(_status())
    return machine_states[name]


def _status():
    if version() >= (1, 4):
        return _status_machine_readable()
    else:
        return _status_human_readable()


def _status_machine_readable():
    with settings(hide('running')):
        output = local('vagrant status --machine-readable', capture=True)
    tuples = [tuple(line.split(',')) for line in output.splitlines() if line.strip() != '']
    return [(target, data) for timestamp, target, type_, data in tuples if type_ == 'state-human-short']


def _status_human_readable():
    with settings(hide('running')):
        output = local('vagrant status', capture=True)
    lines = output.splitlines()[2:]
    states = []
    for line in lines:
        if line == '':
            break
        target = line[:25].strip()
        state = re.match(r'(.{25}) ([^\(]+)( \(.+\))?$', line).group(2)
        states.append((target, state))
    return states


def machines():
    """
    Get the list of vagrant machines
    """
    return [name for name, state in _status()]


def base_boxes():
    """
    Get the list of vagrant base boxes
    """
    return sorted(list(set([name for name, provider in _box_list()])))


def _box_list():
    if version() >= (1, 4):
        return _box_list_machine_readable()
    else:
        return _box_list_human_readable()


def _box_list_machine_readable():
    with settings(hide('running')):
        output = local('vagrant box list --machine-readable', capture=True)
    tuples = [tuple(line.split(',')) for line in output.splitlines() if line.strip() != '']
    res = []
    for timestamp, target, type_, data in tuples:
        if type_ == 'box-name':
            box_name = data
        elif type_ == 'box-provider':
            box_provider = data
            res.append((box_name, box_provider))
        else:
            raise ValueError('Unknown item type')
    return res


def _box_list_human_readable():
    with settings(hide('running')):
        output = local('vagrant box list', capture=True)
    lines = output.splitlines()
    res = []
    for line in lines:
        box_name = line[:25].strip()
        mo = re.match(r'.{25} \((.+)\)$', line)
        box_provider = mo.group(1) if mo is not None else 'virtualbox'
        res.append((box_name, box_provider))
    return res

########NEW FILE########
