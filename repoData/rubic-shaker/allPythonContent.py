__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# shaker documentation build configuration file, created by
# sphinx-quickstart on Tue Jan 31 20:33:49 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

class Mock(object):
    '''
    Mock out specified imports

    This allows autodoc to do it's thing without having oodles of req'd
    installed libs. This doesn't work with ``import *`` imports.

    http://read-the-docs.readthedocs.org/en/latest/faq.html#i-get-import-errors-on-libraries-that-depend-on-c-modules
    '''
    def __init__(self, *args, **kwargs):
        pass

    def __call__(self, *args, **kwargs):
        return Mock()

    @classmethod
    def __getattr__(self, name):
        if name in ('__file__', '__path__'):
            return '/dev/null'
        elif name[0] == name[0].upper():
            return type(name, (), {})
        else:
            return Mock()

MOCK_MODULES = [
    'yaml',
    'M2Crypto',
]

for mod_name in MOCK_MODULES:
    sys.modules[mod_name] = Mock()

import shaker
from shaker import __version__

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Shaker'
copyright = u'2012, Jeff Bauer'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'
pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
sys.path.append(os.path.abspath('_themes'))
html_theme_path = ['_themes']  # custom themes
html_theme = 'shaker'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
    '**':       ['sidebarlogo.html', 'localtoc.html', 'relations.html',
                 'sourcelink.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'shakerdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Shaker.tex', u'Shaker Documentation',
   u'Jeff Bauer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'shaker', u'Shaker Documentation',
     [u'Jeff Bauer'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'shaker', u'Shaker Documentation',
   u'Jeff Bauer', 'shaker', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = ami
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Select the AMI from specified distro

>>> profile = {'ec2_zone': 'us-west-1a'}
>>> get_ami(profile)
'ami-d50c2890'

>>> release = 'lucid'
>>> get_ami(profile, release)
'ami-b988acfc'

>>> profile['ec2_architecture'] = 'x86_64'
>>> get_ami(profile, release)
'ami-bb88acfe'
"""

import yaml

import shaker.log
LOG = shaker.log.getLogger(__name__)

DEFAULT_RELEASE = 'precise'

def get_ami(profile, release=None):
    """Return an AMI ID matching the distro.
    """
    y = yaml.load(EBSImages)
    if not release:
        release = profile.get('ubuntu_release') or DEFAULT_RELEASE
    try:
        region = profile['ec2_zone'][:-1]
        architecture = profile.get('ec2_architecture', 'i386')
        for distro in y['release']:
            if release in y[distro]:
                return y[distro][release][region][architecture]
    except KeyError:
        pass
    except IndexError:
        pass
    return None

# EBSImages to be treated as (and eventually packaged) a yaml file.

EBSImages = """# Amazon EC2 AMIs - EBS Images
release:
  ubuntu: precise

ubuntu:
  precise:
    ap-northeast-1:
      x86_64: ami-c047fac1
      i386: ami-bc47fabd
    ap-southeast-1:
      x86_64: ami-eadb9ab8
      i386: ami-e4db9ab6
    eu-west-1:
      x86_64: ami-db595faf
      i386: ami-d1595fa5
    sa-east-1:
      x86_64: ami-2e845d33
      i386: ami-32845d2f
    us-east-1:
      x86_64: ami-137bcf7a
      i386: ami-057bcf6c
    us-west-1:
      x86_64: ami-d70c2892
      i386: ami-d50c2890
    us-west-2:
      x86_64: ami-1cdd532c
      i386: ami-1add532a
  oneiric:
    ap-northeast-1:
      x86_64: ami-9405b995
      i386: ami-9205b993
    ap-southeast-1:
      x86_64: ami-a86424fa
      i386: ami-aa6424f8
    eu-west-1:
      x86_64: ami-3dcacb49
      i386: ami-33cacb47
    sa-east-1:
      x86_64: ami-00f22b1d
      i386: ami-06f22b1b
    us-east-1:
      x86_64: ami-cdc072a4
      i386: ami-cbc072a2
    us-west-1:
      x86_64: ami-fb5176be
      i386: ami-ff5176ba
    us-west-2:
      x86_64: ami-b47af484
      i386: ami-b27af482
  natty:
    ap-northeast-1:
      x86_64: ami-6c47f56d
      i386: ami-6a47f56b
    ap-southeast-1:
      x86_64: ami-5a5e1f08
      i386: ami-545e1f06
    eu-west-1:
      x86_64: ami-e9bfbb9d
      i386: ami-efbfbb9b
    sa-east-1:
      x86_64: ami-404b955d
      i386: ami-464b955b
    us-east-1:
      x86_64: ami-699f3600
      i386: ami-9f9c35f6
    us-west-1:
      x86_64: ami-1dd0f558
      i386: ami-13d0f556
    us-west-2:
      x86_64: ami-6449c654
      i386: ami-6249c652
  maverick:
    ap-northeast-1:
      x86_64: ami-741dac75
      i386: ami-721dac73
    ap-southeast-1:
      x86_64: ami-0e8acd5c
      i386: ami-0a8acd58
    eu-west-1:
      x86_64: ami-c57942b1
      i386: ami-db7942af
    sa-east-1:
      x86_64: ami-10a9770d
      i386: ami-16a9770b
    us-east-1:
      x86_64: ami-d78f57be
      i386: ami-d38f57ba
    us-west-1:
      x86_64: ami-3b154e7e
      i386: ami-39154e7c
    us-west-2:
      x86_64: ami-64fd7154
      i386: ami-62fd7152
  lucid:
    ap-northeast-1:
      x86_64: ami-8876ca89
      i386: ami-8676ca87
    ap-southeast-1:
      x86_64: ami-903575c2
      i386: ami-923575c0
    eu-west-1:
      x86_64: ami-5d4a4b29
      i386: ami-534a4b27
    sa-east-1:
      x86_64: ami-6ac91077
      i386: ami-68c91075
    us-east-1:
      x86_64: ami-c7b202ae
      i386: ami-c5b202ac
    us-west-1:
      x86_64: ami-bb88acfe
      i386: ami-b988acfc
    us-west-2:
      x86_64: ami-1a4fc12a
      i386: ami-184fc128
"""

if __name__ == "__main__":
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = config
import os

"""
Shaker configuration
"""

from jinja2 import Template
import yaml
import shaker.ami
import shaker.log
LOG = shaker.log.getLogger(__name__)

DEFAULTS = {
    # These values will be overridden in profile/default or
    # a user profile, or command-line options.
    'hostname': None,
    'domain': None,
    'sudouser': None,
    'ssh_port': '22',
    'ssh_import': None,
    'timezone': None,
    'assign_dns': False,  # Hmmm ...?
    'ec2_access_key_id': None,
    'ec2_secret_access_key': None,
    'ec2_region': 'us-east-1',
    'ec2_zone': None,
    'ec2_instance_type': 'm1.small',
    'ec2_ami_id': None,
    'ubuntu_release': None,
    'ec2_size': None,
    'ec2_key_name': None,
    'ec2_security_group': 'default',
    'ec2_security_groups': [],
    'ec2_monitoring_enabled': False,
    'ec2_root_device': '/dev/sda1',
    'ec2_architecture': 'i386',
    'ec2_placement_group': None,
    'salt_master': None,
    'salt_id': None,
    'salt_grains': [],
    'salt_pillar_roots_dir': None,
    'cloud_init_template': None,
    'user_data_template': None,
    'minion_template': None,
    'pre_seed': False,
    'ip_address': None,
    'check_name_before_create': False,
    'check_name_after_create': True,
    'additional_tags': {},
    }


def get_config_dir(path=None):
    """
    Return the shaker configuration directory.  Create and populate
    it if missing.
    """
    if path:
        config_dir = path
    elif os.environ.get('SHAKER_CONFIG_DIR'):
        config_dir = os.environ['SHAKER_CONFIG_DIR']
    else:
        config_dir = os.path.expanduser("~/.shaker")
    if not os.path.isdir(config_dir):
        os.makedirs(config_dir)
    return config_dir


def get_pki_dir(config_dir):
    pki_dir = os.path.join(config_dir, 'pki')
    if not os.path.isdir(pki_dir):
        os.makedirs(pki_dir)
    return pki_dir


def get_userdata_dir(config_dir):
    userdata_dir = os.path.join(config_dir, 'userdata')
    if not os.path.isdir(userdata_dir):
        os.makedirs(userdata_dir)
    return userdata_dir


def default_profile(config_dir):
    profile_dir = os.path.join(config_dir, 'profile')
    default_profile = os.path.join(profile_dir, 'default')
    if not os.path.isdir(profile_dir):
        os.makedirs(profile_dir)
    if not os.path.isfile(default_profile):
        LOG.info("Default profile not found, creating: {0}".format(default_profile))
        template = Template(DEFAULT_PROFILE)
        with open(default_profile, 'w') as f:
            f.write(template.render(DEFAULTS))
    profile = dict(DEFAULTS)
    profile.update(yaml.load(file(default_profile, 'r')) or {})
    return profile


def create_profile(profile, config_dir, profile_name):
    """
    Generate a profile with config parameters and save to disk

    Parameters not specified in the config will inherit from
    the default profile.
    """
    profile_dir = os.path.join(config_dir, 'profile')
    profile_path = os.path.join(profile_dir, profile_name)
    profile_copy = dict(profile)
    if not os.path.isfile(profile_path):
        msg = "Creating new profile: {0}".format(profile_path)
    else:
        msg = "Overwriting profile: {0}".format(profile_path)
    LOG.info(msg)
    print msg
    with open(profile_path, 'w') as f:
        f.write(yaml.dump(profile_copy, default_flow_style=False))
    return profile_copy


def user_profile(cli, config_dir, profile_name=None):
    """User profile, cli overrides defaults.
    """
    profile = default_profile(config_dir) or {}
    if profile_name:
        profile_dir = os.path.join(config_dir, 'profile')
        profile_path = os.path.join(profile_dir, profile_name)
        default_path = os.path.join(profile_dir, 'default')
        if not os.path.isfile(profile_path):
            import shutil
            shutil.copy2(default_path, profile_path)
            LOG.info("Created profile: {0}".format(profile_path))
        else:
            try:
                profile.update(yaml.load(file(profile_path, 'r')) or {})
            except yaml.scanner.ScannerError, err:
                msg = "Error scanning profile {0}: {1}".format(
                    profile_path, err)
                LOG.error(msg)
    else:
        LOG.info("No profile specified.")
    for k, v in cli.__dict__.items():
        if k in profile and v:
            profile[k] = v
    # If the distro is specified in the command-line, we override
    # the profile ec2_ami_id value.
    if cli.distro:
        ec2_ami_id = shaker.ami.get_ami(profile, cli.distro)
        if ec2_ami_id:
            profile['ec2_ami_id'] = ec2_ami_id
        else:
            msg = "Unable to find AMI for distro: {0}".format(cli.distro)
            LOG.info(msg)
    if not profile['ec2_ami_id'] and profile['ubuntu_release']:
        profile['ec2_ami_id'] = shaker.ami.get_ami(profile['ubuntu_release'], profile)
    msg = "Selected AMI {0} in zone {1}".format(
        profile['ec2_ami_id'],
        profile['ec2_zone'])
    LOG.info(msg)
    
    # if grains are specified in command-line, we override the
    # profile grains value
    if cli.salt_grains:
        grains = {}
        for pair in cli.salt_grains.split(';'):
            for key, value in pair.split(':'):
                grains[key] = value.split(',')
        profile['salt_grains'] = grains

    ## override profile pillar_roots_dir by cli
    if cli.salt_pillar_roots_dir:
        profile['salt_pillar_roots_dir'] = cli.salt_pillar_roots_dir
    return profile


DEFAULT_PROFILE = """####################################################################
# hostname, domain to assign the instance.
####################################################################

#hostname:
#domain:

####################################################################
# salt_master is the location (dns or ip) of the salt master
# to connect to, e.g.: master.example.com
####################################################################

#salt_master:

####################################################################
# salt_id identifies this salt minion.  If not specified,
# defaults to the fully qualified hostname.
####################################################################

#salt_id:

####################################################################
# salt_grains identifies grains on this salt minion.
# If not specified, defaults to empty list.
####################################################################

#salt_grains:

####################################################################
# salt_pillar_roots_dir identifies pillar_roots config on this
# salt minion.
# If not specified, defaults to none and pillar_roots aren't set.
####################################################################

#salt_pillar_roots_dir: /srv/pillar

# Pre-seed the master with a generated salt key, which is copied
# to the minion upon instance creation.  Default is false.
####################################################################

#pre_seed: False

####################################################################
# Assign elastic ip address to minion after the instance is
# launched.  If the ip address is already in use, the
# assignment will fail.  Default is None.
####################################################################

#ip_address:

####################################################################
# Check whether there is box with the same Name. Either let it ends
# before the instance is created or leave the instance without Name
####################################################################

#check_name_before_create: False
#check_name_after_create: True

####################################################################
# You can add any custom AWS tags you want
####################################################################

#additional_tags:
#  project: homepage
#  environment: production

####################################################################
# Install the user with sudo privileges.  If sudouser is listed
# in ssh_import, the public key will be installed from
# lauchpad.net.  From the command-line, sudouser will default
# to $LOGNAME, if not otherwise specified.
####################################################################

#sudouser:

####################################################################
# Import public keys from lauchpad.net.  Only applicable for
# Ubuntu cloud-init.  User names are comma-separated, no spaces.
####################################################################

#ssh_import:

####################################################################
# ssh_port: You may define a non-standard ssh port, but verify
# it's open in your ec2_security_group.
####################################################################

#ssh_port: {{ ssh_port }}

####################################################################
# timezone:
# e.g. timezone: America/Chicago
# http://en.wikipedia.org/wiki/List_of_tz_database_time_zones
####################################################################

#timezone:

####################################################################
# aws credentials:
# you can set up your aws credentials for this profile
# or you can leave it out and fallback to boto's defaults
# http://docs.pythonboto.org/en/latest/boto_config_tut.html
####################################################################

#ec2_access_key_id: <AWS_ACCESS_KEY_ID>
#ec2_secret_access_key: <AWS_SECRET_ACCESS_KEY>

####################################################################
# ec2_region: EC2 region - us-east-1 (default), eu-west-1, etc.
# ec2_zone: if not specified, EC2 chooses a zone for you
# ec2_placement_group: placement group of an instance with HPC
####################################################################

#ec2_region: {{ ec2_region }}
#ec2_zone: {{ ec2_zone }}
#ec2_placement_group': {{ ec2_placement_group }}

####################################################################
# ec2_instance_type defaults to m1.small
# http://aws.amazon.com/ec2/instance-types/
#
# t1.micro
# m1.small  (default)
# m2.xlarge, m2.2xlarge, m2.4xlarge
# c1.medium, c1.xlarge, cc1.4xlarge, cc2.8xlarge
#
####################################################################

#ec2_instance_type: {{ ec2_instance_type }}

####################################################################
# ec2_ami_id: AMI image to launch.  Note AMI's are
# region-specific, so you must specify the the appropriate AMI
# for the ec2_zone above.  ec2_ami_id overrides ubuntu_release
# below.
####################################################################

#ec2_ami_id:

####################################################################
# ubuntu_release: precise, oneiric, natty, maverick, lucid, hardy
# TODO: add support for Debian: sid, etc.
####################################################################

#ubuntu_release: {{ ubuntu_release }}

####################################################################
# ec2_size: size of the root file partition in GB.  If not
# specified (or zero), defaults to the instance type.
####################################################################

#ec2_size: {{ ec2_size }}

####################################################################
# ec2_key_name: Name of the key pair used to create the instance.
# If not specified and only one key-pair is available, it will be
# used.  Otherwise you must specify the key-pair.  Further info:
# http://docs.amazonwebservices.com/AWSEC2/latest/UserGuide/generating-a-keypair.html
####################################################################

#ec2_key_name:

####################################################################
# ec2_security_group: The security group to control port access
# to the instance (ssh, http, etc.)  If not specified, use
# 'default', which generally permits port 22 for ssh access.
####################################################################

#ec2_security_group: default

####################################################################
# ec2_security_groups: Overrides ec2_security_group setting if
# multiple groups are needed.
####################################################################

#ec2_security_groups: []

####################################################################
# ec2_monitoring_enabled:
# http://aws.amazon.com/cloudwatch/
####################################################################

#ec2_monitoring_enabled: false

####################################################################
# ec2_root_device: root device will be deleted upon termination
# of the instance by default.
####################################################################

#ec2_root_device: /dev/sda1
"""

########NEW FILE########
__FILENAME__ = log
import os
import logging

LOG_LEVELS = {
    'debug': logging.DEBUG,
    'error': logging.ERROR,
    'info': logging.INFO,
    'none': logging.NOTSET,
    'warning': logging.WARNING,
}

def start_logger(logname, filename, log_level):
    consoleLogger = logging.StreamHandler()
    consoleLogger.setLevel(logging.WARNING)
    logging.getLogger(logname).addHandler(consoleLogger)
    formatter = logging.Formatter(
        '%(asctime)-6s: %(name)s - %(levelname)s - %(message)s')

    directory, _ = os.path.split(filename)
    if not os.path.isdir(directory):
        os.makedirs(directory)

    fileLogger = logging.FileHandler(filename=filename)
    fileLogger.setLevel(LOG_LEVELS[log_level])
    fileLogger.setFormatter(formatter)
    logging.getLogger(logname).addHandler(fileLogger)
    logger = logging.getLogger(logname)
    logger.setLevel(LOG_LEVELS[log_level])


def getLogger(logname):
    return logging.getLogger(logname)

########NEW FILE########
__FILENAME__ = template
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Handle the templates to configure user-data.
"""
import os
import re
from jinja2 import Environment
from jinja2 import FileSystemLoader

from shaker import __version__

import shaker.log
LOG = shaker.log.getLogger(__name__)

CLOUD_INIT_PREFIX = 'cloud-init'
USER_SCRIPT_PREFIX = 'user-script'


class UserData(object):
    def __init__(self, config):
        self.config = config
        self.config.update({'version': __version__})
        self.template_dir = self.get_template_dir(self.config['config_dir'])
        self.env = self.get_jinja_env()
        minion_template = re.sub('\n\n+', '\n\n', self.render_template('minion_template', default_contents=MINION_TEMPLATE))
        self.config['rendered_minion_template'] = minion_template
        self.user_script = re.sub('\n\n+', '\n\n', self.render_template('user_data_template', default_contents=USER_SCRIPT))
        self.cloud_init = re.sub('\n\n+', '\n\n', self.render_template('cloud_init_template', default_contents=CLOUD_INIT))

    def get_jinja_env(self):
        ## Using '/' in loader allows to check for absolute paths.
        loader = FileSystemLoader([os.getcwd(), self.template_dir, '/'])
        env = Environment(loader=loader)
        return env

    def render_template(self, template_arg, default_contents=None):
        """
        Retrieve rendered template text from file.
        """
        prefixes = {
            'cloud_init_template': CLOUD_INIT_PREFIX,
            'user_data_template': USER_SCRIPT_PREFIX,
            'minion_template': 'minion-template'
        }
        prefix = prefixes[template_arg]

        if self.config[template_arg] == None:
            template_name = "%s.%s" % (prefix, __version__)
            template_path = os.path.join(self.template_dir, template_name)
            ## Create from default if it doesn't exist.
            if not os.path.isfile(template_path):
                template_file = open(template_path, 'w')
                template_file.write(default_contents)
                template_file.close()
        else:
            template_name = self.config[template_arg]

        return self.env.get_template(template_name).render(self.config)

    def get_template_dir(self, config_dir):
        """Return the template directory name, creating the
        directory if absent (and populating with boilerplate).
        """
        template_dir = os.path.join(config_dir, 'templates')
        if not os.path.isdir(template_dir):
            os.makedirs(template_dir)
        return template_dir


CLOUD_INIT = """#cloud-config
# Shaker version: {{ version }}
{% if salt_master %}
{% if not ubuntu_release in ['lucid', 'maverick', 'natty'] %}
apt_sources:
  - source: "ppa:saltstack/salt"

apt_upgrade: true
{% endif %}
{% endif %}

{% if ssh_import %}
ssh_import_id: [{{ ssh_import }}]
{% endif %}

{% if hostname %}
hostname: {{ hostname }}
{% if domain %}
fqdn: {{ hostname }}.{{ domain }}
{% endif %}
{% endif %}

{{ rendered_minion_template }}
"""

USER_SCRIPT = """#!/bin/sh
# Shaker version: {{ version }}
{% if timezone %}
# set timezone
echo "{{ timezone }}" | tee /etc/timezone
dpkg-reconfigure --frontend noninteractive tzdata
restart cron
{% endif %}

{% if domain and hostname %}
sed -i "s/127.0.0.1 ubuntu/127.0.0.1 localhost {{ hostname }}.{{ domain }} {{ hostname }}/" /etc/hosts
# temp work-around for cloudinit bug: https://bugs.launchpad.net/cloud-init/
echo "127.0.0.1 localhost {{ hostname }}.{{ domain }} {{ hostname }}" >> /etc/hosts
{% elif hostname %}
  hostname: {{ hostname }}
{% endif %}

{% if ssh_port and ssh_port != '22' %}
# change ssh port 22 to non-standard port and restart sshd
sed -i "s/^Port 22$/Port {{ ssh_port }}/" /etc/ssh/sshd_config
/etc/init.d/ssh restart
{% endif %}

{% if sudouser %}
# create new user with sudo privileges
useradd -m -s /bin/bash {{ sudouser }}
{% if ssh_import %}cp -rp /home/ubuntu/.ssh /home/{{ sudouser }}/.ssh
chown -R {{ sudouser }}:{{ sudouser }} /home/{{ sudouser }}/.ssh
{% endif %}
echo "{{ sudouser }} ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
{% endif %}

{% if size and root_device %}
# resize the filesystem to use specified space
resize2fs {{ root_device }}
{% endif %}

{% if salt_master %}
# Install salt-minion and run as daemon

{% if ubuntu_release in ['lucid', 'maverick'] %}
aptitude -y install python-software-properties && add-apt-repository ppa:chris-lea/libpgm && add-apt-repository ppa:chris-lea/zeromq && add-apt-repository ppa:saltstack/salt && aptitude update
{% endif %}

apt-get -y install salt-minion

service salt-minion stop

cat > /etc/salt/minion <<EOF1
{{ rendered_minion_template }}
EOF1

{% if public_key %}
cat > /etc/salt/pki/minion.pub <<EOF2
{{ public_key }}
EOF2
{% endif %}

{% if private_key %}
cat > /etc/salt/pki/minion.pem <<EOF3
{{ private_key }}
chmod 600 /etc/salt/pki/minion.pem
EOF3
{% endif %}

service salt-minion start
{% endif %}
"""

# MINION_TEMPLATE has been reverted due to a bug in ubuntu cloud-init:
# https://bugs.launchpad.net/bugs/996166
# When the bug is available in the distro, replace MINION_TEMPLATE
# with _MINION_TEMPLATE.

MINION_TEMPLATE = """master: {{ salt_master }}
# Explicitly declare the id for this minion to use, if left commented the
# id will be the hostname as returned by the python call: socket.getfqdn()
{% if salt_id %}
id: {{ salt_id }}
{% else %}
#id:
{% endif %}

{% if salt_grains %}
grains:
  {% for grain in salt_grains %}
  {{ grain }}:
     {% if salt_grains[grain] is string %}
     {{ salt_grains[grain] }}
     {% else %}
       {% for val in  salt_grains[grain] %}
       - {{ val }}
       {% endfor %}
     {% endif %}
  {% endfor %}
{% endif %}

{% if salt_pillar_roots_dir %}
pillar_roots:
  base:
    - {{ salt_pillar_roots_dir }}
{% endif %}
"""

# Re-enable this version when bug 996166 is fixed.
_MINION_TEMPLATE = """
salt_minion:
  # conf contains all the directives to be assigned in /etc/salt/minion.

  conf:
    # Set the location of the salt master server, if the master server cannot be
    # resolved, then the minion will fail to start.
    master: {{ salt_master }}

    {% if salt_id %}
    id: {{ salt_id }}
    {% else %}
    #id:
    {% endif %}

{% if formatted_public_key %}
  # Salt keys are manually generated by: salt-key --gen-keys=GEN_KEYS
  # where GEN_KEYS is the name of the keypair, e.g. 'minion'.  The keypair
  # will be copied to /etc/salt/pki on the minion instance.

  public_key: |
{{ formatted_public_key }}
{% endif %}

{% if formatted_private_key %}
  private_key: |
{{ formatted_private_key }}
{% endif %}
"""


########NEW FILE########
__FILENAME__ = version
__version_info__ = (0, 2, 2)
__version__ = '.'.join(map(str, __version_info__))

########NEW FILE########
__FILENAME__ = ubuntu_cloud_images
#!/usr/bin/env python
import sys
from BeautifulSoup import BeautifulSoup

"""
Utility program to list AMIs for ubuntu cloud server releases:

$ UDISTRO=precise; curl -o $UDISTRO.txt http://cloud-images.ubuntu.com/releases/$UDISTRO/release/
$ echo "  $UDISTRO:"; ./ubuntu_cloud_images.py $UDISTRO.txt
"""

Arch = {'32-bit': 'i386', '64-bit': 'x86_64'}

def ami_tuples(data):
    """Return ubuntu server release info as a list of named tuples
    """
    soup = BeautifulSoup(data)
    table = soup.find('table')
    rows = table.findAll('tr')
    headings = [td.find(text=True).strip() for td in rows[0].findAll('td')]
    ami_list = []

    for row in rows[1:]:
        r = [p.text for p in [td for td in row.findAll('td')]]
        ami = dict(zip(headings, r))
        if not ami['root store'] == 'ebs':
            continue
        ami['architecture'] = Arch[ami['arch']]
        ami['id'] = ami['ami'].replace('Launch', '')
        ami_list.append(ami)
    return ami_list

def ami_yaml(data):
    yaml_list = []
    region = None
    for ami in ami_tuples(data):
        if not ami['Region'] == region:
            yaml_list.append('    {0}:'.format(ami['Region']))
        yaml_list.append('      {0}: {1}'.format(ami['architecture'], ami['id']))
        region = ami['Region']
    return yaml_list

if __name__ == '__main__':
    datafile = sys.argv[1]
    data = open(datafile).read()
    for y in ami_yaml(data):
        print y

########NEW FILE########
