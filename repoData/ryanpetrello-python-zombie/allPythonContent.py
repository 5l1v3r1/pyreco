__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# zombie documentation build configuration file, created by
# sphinx-quickstart on Sun Jun  3 14:04:52 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'zombie'
copyright = u'2012, Ryan Petrello'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1.0a5'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'zombie'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'zombie.tex', u'zombie Documentation',
   u'Ryan Petrello', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'zombie', u'zombie Documentation',
     [u'Ryan Petrello'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'zombie', u'zombie Documentation',
   u'Ryan Petrello', 'zombie', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

def skip(app, what, name, obj, skip, options):
    if name == "__init__":
        return False
    return skip

def setup(app):
    app.connect("autodoc-skip-member", skip)

########NEW FILE########
__FILENAME__ = browser
from zombie.proxy.server import ZombieProxyServer
from zombie.proxy.client import ZombieProxyClient

__all__ = ['Browser', 'DOMNode']


class Literal(object):
    def __init__(self, value):
        self.__value = value

    @property
    def json(self):
        return self.__value


class Browser(object):
    """
    A Browser object, analogous to zombie.js' ``Browser``.
    """

    def __init__(self, server=None):
        """
        Start a new Browser instance.

        :param server: an (optional) instance of
                       :class:`zombie.proxy.server.ZombieProxyServer`.
        """
        #
        # If a proxy server isn't specified, spawn one automatically.
        #
        if server is None:
            server = ZombieProxyServer()
        self.server = server
        self.client = ZombieProxyClient(server.socket)

    #
    # Forms
    #
    def fill(self, field, value):
        """
        Fill a specified form field in the current document.

        :param field: an instance of :class:`zombie.dom.DOMNode`
        :param value: any string value
        :return: self to allow function chaining.
        """
        self.client.nowait('browser.fill', (field, value))
        return self

    def pressButton(self, selector):
        """
        Press a specific button.

        :param selector: CSS selector or innerText
        :return: self to allow function chaining.
        """
        self.client.wait('browser.pressButton', selector)
        return self

    def check(self, selector):
        self.client.nowait('browser.check', (selector,))
        return self

    def uncheck(self, selector):
        self.client.nowait('browser.uncheck', (selector,))
        return self

    def select(self, selector, value):
        self.client.nowait('browser.select', (selector, value))
        return self

    def selectOption(self, selector):
        self.client.nowait('browser.selectOption', (selector,))
        return self

    def unselect(self, selector, value):
        self.client.nowait('browser.unselect', (selector, value))
        return self

    def attach(self, selector, filename):
        self.client.nowait('browser.attach', (selector, filename))
        return self

    def choose(self, selector):
        self.client.nowait('browser.choose', (selector, ))
        return self

    #
    # query
    #
    def field(self, selector, context=None):
        element = self.client.create_element(
            'browser.field', (selector, context))
        return DOMNode(element, self)

    #
    # Document Content
    #
    def load(self, html):
        """
        Loads raw html
        """
        self.client.wait('browser.load', html)

    @property
    def body(self):
        """
        Returns a :class:`zombie.dom.DOMNode` representing the body element of
        the current document.
        """
        element = self.client.create_element('browser.body')
        return DOMNode(element, self)

    def html(self, selector=None, context=None):
        """
        Returns the HTML content (string) of the current document.

        :param selector: an optional string CSS selector
                        (http://zombie.labnotes.org/selectors)
        :param context: an (optional) instance of :class:`zombie.dom.DOMNode`
        """
        return self.client.json('browser.html', (selector, context))

    def query(self, selector, context=None):
        """
        Evaluate a CSS selector against the document (or an optional context
        :class:`zombie.dom.DOMNode`) and return a single
        :class:`zombie.dom.DOMNode` object.

        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        :param context: an (optional) instance of :class:`zombie.dom.DOMNode`
        """
        element = self.client.create_element(
            'browser.query', (selector, context))
        return DOMNode.factory(element, self)

    def queryAll(self, selector, context=None):
        """
        Evaluate a CSS selector against the document (or an optional context
        :class:`zombie.dom.DOMNode`) and return a list of
        :class:`zombie.dom.DOMNode` objects.

        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        :param context: an (optional) instance of :class:`zombie.dom.DOMNode`
        """
        elements = self.client.create_elements(
            'browser.queryAll', (selector, context))
        return [DOMNode(e, self) for e in elements]

    def css(self, selector, context=None):
        """
        An alias for :class:`zombie.browser.Browser.queryAll`.

        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        :param context: an (optional) instance of :class:`zombie.dom.DOMNode`
        """
        return self.queryAll(selector, context)

    def text(self, selector, context=None):
        """
        Returns the text content of specific elements.

        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        :param context: an (optional) instance of :class:`zombie.dom.DOMNode`
        """
        return self.client.json('browser.text', (selector, context))

    def unselectOption(self, selector):
        """
        Unselects the given option

        Special case. It seems there is a problem in Zombie: unselectOption
        doesn't accept a selector.

        Pull request pending in the zombie project
        """
        self.query(selector).unselectOption()
        return self

    #
    # Navigation
    #
    def clickLink(self, selector):
        """
        Clicks on a link. The first argument is the link text or CSS selector.

        :param selector: an optional string CSS selector
                        (http://zombie.labnotes.org/selectors) or inner text

        Returns the :class:`zombie.browser.Browser` to allow function chaining.
        """
        self.client.wait('browser.clickLink', selector)
        return self

    @property
    def location(self):
        """
        Returns the location of the current document (same as
        ``window.location.toString()``).
        """
        return self.client.json('browser.location.toString()')

    @location.setter
    def location(self, url):
        """
        Changes document location, loading a new document if necessary (same as
        setting ``window.location``). This will also work if you just need to
        change the hash (Zombie.js will fire a hashchange event).
        """
        self.visit(url)

    def visit(self, url):
        """
        A shortcut to load the document from the specified URL.

        Returns the :class:`zombie.browser.Browser` to allow function chaining.
        """
        self.client.wait('browser.visit', url)
        return self

    def back(self):
        """
        Navigate to the previous page in history.

        Returns the :class:`zombie.browser.Browser` to allow function chaining.
        """
        self.client.wait('browser.back')
        return self

    def link(self, selector):
        """
        Finds and returns a link ``<a>`` element (:class:`zombie.dom.DOMNode`).
        You can use a CSS selector or find a link by its text contents (case
        sensitive, but ignores leading/trailing spaces).

        :param selector: an optional string CSS selector
                        (http://zombie.labnotes.org/selectors) or inner text
        """
        element = self.client.create_element('browser.link', (selector,))
        return DOMNode(element, self)

    def reload(self):
        """
        Reloads the current page.

        Returns the :class:`zombie.browser.Browser` to allow function chaining.
        """
        self.client.wait('browser.reload')
        return self

    @property
    def statusCode(self):
        """
        Returns the status code returned for this page request (200, 303, etc).
        """
        return self.client.json('browser.statusCode')

    @property
    def success(self):
        """
        Returns ``True`` if the status code is 2xx.
        """
        return self.client.json('browser.success')

    @property
    def redirected(self):
        """
        Returns ``True`` if the page request followed a redirect.
        """
        return self.client.json('browser.redirected')

    def fire(self, selector, event_name):
        self.client.wait('browser.fire', selector, event_name)
        return self

    #
    # Debugging
    #
    def dump(self):
        """
        Prints a debug string including zombie.js version, current URL,
        history, cookies, event loop, etc.  Useful for debugging and submitting
        error reports.
        """
        self.client.json('browser.dump()')

    def get_resource(self, url):
        """
        Gets a resource and returns a json with information
        """
        return self.client.wait_return('browser.resources.get', url)

    def post_resource(self, url, form_params):
        options = {
            'headers': {
                'content-type': 'application/x-www-form-urlencoded'},
            'params': form_params}
        return self.client.wait_return('browser.resources.post', url, options)

    def evaluate(self, code):
        return self.client.json('browser.evaluate', (code, ))

    def wait(self, wait_argument=None):
        arguments = [] if wait_argument is None else [wait_argument]
        self.client.wait('browser.wait', *arguments)

    @property
    def resources(self):
        """
        Returns a list of resources loaded by the browser, e.g.,
        ::
            [{
                'method': 'GET',
                'url': 'http://www.example.com/',
                'statusCode': '200',
                'statusText': 'OK',
                'time': '200ms'
            }]
        """
        js = """
            browser.resources.map(
                function(r){
                    var request = r.request;
                    var response = r.response;
                    return {
                        'method': request.method,
                        'url': request.url,
                        'statusCode': response.statusCode,
                        'statusText': response.statusText,
                        'time': (response.time - request.time) + 'ms',
                    }
                }
            )
        """
        return self.client.json(js)

    def viewInBrowser(self):
        """
        Views the current document in a real Web browser. Uses the default
        system browser on OS X, BSD and Linux. Probably errors on Windows.
        """
        return self.client.send('browser.viewInBrowser()')  # pragma: nocover


class DOMNode(object):
    """
    Represents a node in the current document's DOM.
    """
    @staticmethod
    def factory(element, browser):
        if element is None:
            return None
        return DOMNode(element, browser)

    def __init__(self, element, browser):
        self.element = element
        self.client = browser.client
        self.browser = browser

    def query(self, selector):
        """
        Evaluate a CSS selector against this element and return a single
        (child) :class:`zombie.dom.DOMNode` object.

        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        """
        return self.browser.query(selector, self.element)

    def queryAll(self, selector):
        """
        Evaluate a CSS selector against this element and return a list of
        (child) :class:`zombie.dom.DOMNode` objects.

        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        """
        return self.browser.queryAll(selector, self.element)

    def css(self, selector):
        """
        An alias for :class:`zombie.dom.DOMNode.queryAll`.
        """
        return self.queryAll(selector)

    #
    # Forms
    #
    def fill(self, value):
        """
        If applicable, fill the current node's value.

        :param value: any string value

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.fill(self.element, value)

    def pressButton(self):
        """
        If applicable, press this button

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.pressButton(self.element)

    def check(self):
        """
        If applicable, Checks a checkbox

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.check(self.element)

    def uncheck(self):
        """
        If applicable, unchecks a checkbox

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.uncheck(self.element)

    def select(self, value):
        """
        If applicable, selects an option

        :param value: Value (or label) or option to select

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.select(self.element, value)

    def selectOption(self):
        """
        If applicable, selects this option

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.selectOption(self.element)

    def unselect(self, value):
        """
        If applicable, unselect an option

        :param value: Value (or label) or option to unselect

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.unselect(self.element, value)

    def unselectOption(self):
        """
        If applicable unselect this option

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.client.nowait('browser.unselectOption', (self.element,))

    def attach(self, filename):
        """
        If applicable, attaches a file to the specified input field

        :param filename: Filename of the file to attach.

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        return self.browser.attach(self.element, filename)

    def choose(self):
        """
        If applicable, chooses this radio button
        """
        return self.browser.choose(self.element)

    def field(self):
        """
        The field of a :class:`zombie.dom.DOMNode` is itself. Returns self.
        """
        return self

    #
    # Attribute (normal and specialized)
    # access methods.
    #
    @property
    def text(self):
        """
        The ``textContent`` of the current node.
        """
        return self.textContent

    @property
    def innerText(self):
        """
        The ``textContent`` of the current node.
        """
        return self.textContent

    @property
    def html(self):
        """
        The ``innerHTML`` of the current node.
        """
        return self.innerHTML

    @property
    def tagName(self):
        """
        The ``tagName`` of the current node.
        """
        return self._jsonattr('tagName').lower()

    @property
    def value(self):
        """
        The ``value`` of the current node.
        """
        if self.tagName == 'textarea':
            return self.textContent
        return self._jsonattr('value')

    @value.setter
    def value(self, value):
        """
        Used to set the ``value`` of form elements.
        """
        self.client.nowait(
            'set_field', (Literal('browser'), self.element, value))

    @property
    def checked(self):
        """
        The ``checked`` attribute of an ``<input type="checkbox">``.
        """
        return self._jsonattr('checked')

    @checked.setter
    def checked(self, value):
        """
        Used to set the ``checked`` attribute of an ``<input
        type="checkbox">``.
        """
        self.client.nowait(
            'check_field', (Literal('browser'), self.element, value))

    def _jsonattr(self, attr):
        return self.client.json("%s.%s" % (self.element.json, attr))

    def __getattr__(self, name):
        return self._jsonattr(name)

    def __getitem__(self, name):
        return self._jsonattr(name)

    #
    # Events
    #
    def fire(self, event):
        """
        Fires a specified DOM event on the current node.

        :param event: the name of the event to fire (e.g., 'click').

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        self.browser.fire(self.element, event)
        return self

    def click(self):
        """
        Fires a ``click`` event on the current node.

        Returns the :class:`zombie.dom.DOMNode` to allow function chaining.
        """
        self.fire('click')
        return self

    #
    # Private methods
    #
    @property
    def json(self):
        return self.element.json

    def __repr__(self):
        name, id, className = self.tagName.upper(), self.id, self.className
        if id and className:
            name = "%s#%s.%s" % (name, id, className)
        elif id:
            name = "%s#%s" % (name, id)
        elif className:
            name = "%s.%s" % (name, className)
        return "<%s>" % name

########NEW FILE########
__FILENAME__ = compat
import sys

# True if we are running on Python 3.
PY3 = sys.version_info[0] == 3
PY26 = sys.version_info[0] == 2 and sys.version_info[1] == 6

if PY3:
    from io import BytesIO as StringIO
    from urllib.parse import urlparse
else:
    from urlparse import urlparse  # noqa
    from cStringIO import StringIO  # noqa

if PY26:
    from unittest2 import TestCase
else:
    from unittest import TestCase

if PY3:
    def to_bytes(string):
        return bytes(string, 'utf-8')
else:
    to_bytes = lambda s: s

########NEW FILE########
__FILENAME__ = client
import contextlib
import socket

try:
    from json import loads, dumps
except ImportError:  # pragma: nocover
    from simplejson import loads, dumps  # noqa

from zombie.compat import PY3

__all__ = ['ZombieProxyClient', 'NodeError']


def encode(obj):
    """
    Encode one argument/object to json
    """
    if hasattr(obj, 'json'):
        return obj.json
    if hasattr(obj, '__json__'):
        return obj.__json__()
    return dumps(obj)


def encode_args(args, extra=False):
    """
    Encode a list of arguments
    """
    if not args:
        return ''

    methodargs = ', '.join([encode(a) for a in args])
    if extra:
        methodargs += ', '

    return methodargs


def decode(json):
    """
    Decode json.

    Returns None if None is given as json
    """
    if json is None:
        return None
    return loads(json)


class Element(object):
    """
    Reference to an element stored in the nodejs server
    """
    def __init__(self, index):
        self.__index = index

    @property
    def index(self):
        return self.__index

    @property
    def json(self):
        return "ELEMENTS[%s]" % self.__index

    def __str__(self):
        return self.json


class NodeError(Exception):
    """
    An exception indicating node.js' failure to parse or evaluate Javascript
    instructions it received.
    """
    pass


class ZombieServerConnection(object):
    def __init__(self, socket_address):
        self.__socket_address = socket_address

    def send(self, data):
        if PY3:  # pragma: nocover
            data = bytes(data, 'utf-8')

        with self._open_connection() as con:
            con.send(data)
            response = self._receive(con)

        return response

    def _open_connection(self):
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(self.__socket_address)
        return contextlib.closing(sock)

    def _receive(self, con):
        response = []
        while True:
            data = con.recv(4096)
            if not data:
                break
            if PY3:  # pragma: nocover
                data = str(data, 'utf-8')
            response.append(data)
        return ''.join(response)


class ZombieProxyClient(object):
    """
    Sends data to a :class:`zombie.proxy.server.ZombieProxyServer` bound to
    a specific TCP socket.  Data is evaulated by the server and results
    (if any) are returned.
    """

    def __init__(self, socket_address):
        """
        Establish a new :class:`ZombieProxyClient`.

        :param socket: a unix socket address to connect to.
        """
        self.connection = ZombieServerConnection(socket_address)

    def _send(self, javascript):
        """
        Establishes a socket connection to the zombie.js server and sends
        Javascript instructions.

        :param js: the Javascript string to execute
        """

        # Prepend JS to switch to the proper client context.
        message = """
            var _ctx = ctx_switch('%s'),
                browser = _ctx[0],
                ELEMENTS = _ctx[1];
            %s
        """ % (id(self), javascript)

        response = self.connection.send(message)

        return self._handle_response(response)

    def _handle_response(self, response):
        errno, result = decode(response)
        if errno == 1:
            raise NodeError(result)
        return result

    def json(self, js, args=None):
        """
        A shortcut for passing Javascript instructions and decoding a JSON
        response from node.js.

        :param js: the Javascript string to execute
        """
        return self.nowait("result = %s" % js, args)

    def nowait(self, js, args=None):
        if args:
            js = "%s(%s)" % (js, encode_args(args))

        js = """
            %s;
            return_result(result);
        """ % js
        return self._send(js)

    def wait(self, method, *args):
        """
        Call a method on the zombie.js Browser instance and wait on a callback.

        :param method: the method to call, e.g., html()
        :param args: one of more arguments for the method
        """
        methodargs = encode_args(args, extra=True)
        js = """
        %s(%s wait_callback);
        """ % (method, methodargs)
        self._send(js)

    def wait_return(self, method, *args):
        """
        Call a method on the zombie.js Browser instance and wait on a callback.

        :param method: the method to call, e.g., html()
        :param args: one of more arguments for the method
        """
        methodargs = encode_args(args, extra=True)
        js = """
        %s(%s wait_n_return_callback);
        """ % (method, methodargs)
        return self._send(js)

    def ping(self):
        """
        Send a simple Javascript instruction and wait on a reply.

        A live node.js TCP server will cause this method to return "pong".
        """
        return self.json('ping')

    def cleanup(self):
        """
        Destroy and clean up any browser and elements in the server

        As new browsers are created, memory will be reserved in the node
        process. In order to avoid memory problems you will need to clean up
        those browsers or one by one, or using this clean up in a specific
        moment in your code
        """
        self.nowait('cleanup()')

    def create_element(self, method, args=None):
        """
        Evaluate a browser method and CSS selector against the document
        (or an optional context DOMNode) and return a single
        :class:`zombie.dom.DOMNode` object, e.g.,

        browser._node('query', 'body > div')

        ...roughly translates to the following Javascript...

        browser.query('body > div')

        :param method: the method (e.g., query) to call on the browser
        :param selector: a string CSS selector
                        (http://zombie.labnotes.org/selectors)
        :param context: an (optional) instance of :class:`zombie.dom.DOMNode`
        """
        if args is None:
            arguments = ''
        else:
            arguments = "(%s)" % encode_args(args)
        js = """
            create_element(ELEMENTS, %(method)s%(args)s);
        """ % {
            'method': method,
            'args': arguments
        }

        index = self.json(js)
        if index is None:
            return None

        return Element(index)

    def create_elements(self, method, args=[]):
        """
        Execute a browser method that will return a list of elements.

        Returns a list of the element indexes
        """
        args = encode_args(args)

        js = """
            create_elements(ELEMENTS, %(method)s(%(args)s))
        """ % {
            'method': method,
            'args': args,
        }

        indexes = self.json(js)
        return map(Element, indexes)

########NEW FILE########
__FILENAME__ = server
from socket import error as SocketError
import os
import subprocess
import signal
import threading
import time
import atexit
import random
import sys
import logging

from zombie.proxy.client import ZombieProxyClient

__all__ = ['ZombieProxyServer']


class PipeWorker(threading.Thread):
    """
    A thread that monitors and redirects node.js stdout and stderr to the
    parent process console.
    """

    def __init__(self, pipe):
        super(PipeWorker, self).__init__()
        self.pipe = pipe
        self.daemon = True
        self.log = logging.getLogger(__name__)

    def __worker(self, pipe):
        while True:
            line = pipe.readline()
            if line:
                self.log.debug(line[:-1])
            else:
                break

    def run(self):
        try:
            self.__worker(self.pipe)
        except Exception as e:
            try:
                self.log.error(e)
            except:
                pass

__server_instance__ = None
proxy_path = os.path.join(
    os.path.dirname(os.path.abspath(__file__)),
    'server.js'
)


def singleton(cls):
    instances = {}

    def ZombieProxyServer(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
            global __server_instance__
            __server_instance__ = instances[cls]
        return instances[cls]
    return ZombieProxyServer


@singleton
class ZombieProxyServer(object):

    def __init__(self, socket=None, wait=True):
        """
        Spawns a node.js subprocess that listens on a TCP socket.
        A :class:`zombie.proxy.client.ZombieProxyClient` streams data to
        the server, which evaluates it as Javascript, passes it on to
        a zombie.js Browser object, and returns the results.

        :param socket: a (random, by default) filepath representing the
                       intended TCP socket location
        :param wait: when True, wait until the node.js subprocess is responsive
                    via the specified TCP socket.
        """
        socket = socket or '/tmp/zombie-%s.sock' % random.randint(0, 10000)

        self.socket = socket

        # Kill the node process when finished
        atexit.register(__kill_node_processes__)

        #
        # Spawn the node proxy server in a subprocess.
        # This is a simple socket server that listens for data,
        # evaluates it as Javascript, and passes the eval'ed
        # input to a Zombie.js Browser object.
        #
        args = ['env', 'node', proxy_path, self.socket]
        self.child = subprocess.Popen(
            args,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT
        )
        self.child.stdin.close()
        PipeWorker(self.child.stdout).start()
        if wait:
            # Wait until we can ping the node.js server
            client = ZombieProxyClient(socket)
            retries = 30
            while True:
                retries -= 1
                if retries < 0:  # pragma: nocover
                    raise RuntimeError(
                        "The proxy server has not replied within 3 seconds."
                    )
                try:
                    assert client.ping() == 'pong'
                except (SocketError, AssertionError):
                    pass
                else:
                    break
                time.sleep(.1)


# When this process ends, ensure all node subprocesses terminate
def __kill_node_processes__():  # pragma: nocover
    instance = __server_instance__
    if instance:
        from os import path
        if hasattr(instance.child, 'kill'):
            instance.child.kill()

        # Cleanup the closed socket
        if path.exists(instance.socket):
            from os import remove
            remove(instance.socket)

########NEW FILE########
__FILENAME__ = test_browser
from unittest import TestCase
import os

from zombie.browser import Browser, DOMNode
from zombie.proxy.client import ZombieProxyClient
from zombie.compat import urlparse, PY3
from zombie.tests.webserver import WebServerTestCase


class BaseTestCase(WebServerTestCase):
    def setUp(self):
        super(BaseTestCase, self).setUp()
        self.browser = Browser()
        self.browser.visit(self.base_url)


class TestBrowser(BaseTestCase):
    #
    # BaseNode
    #
    def test_fill(self):
        self.browser.fill('q', 'Zombie.js')
        self.assertEqual(
            'Zombie.js',
            self.browser.css('input[name=q]')[0].value)

    def test_press_button(self):
        browser = self.browser
        browser.pressButton('Search')
        self.assertEqual(self.base_url + 'submit', browser.location)

    def test_check(self):
        browser = self.browser
        selector = 'input[name=mycheckbox]'

        self.assertFalse(browser.query(selector).checked)
        browser.check(selector)
        self.assertTrue(browser.query(selector).checked)

    def test_select(self):
        browser = self.browser
        selector = 'select[name=planet]'

        self.assertEqual('earth', browser.query(selector).value)
        browser.select(selector, 'Planet Mars')
        self.assertEqual('mars', browser.query(selector).value)

    def test_selectOption(self):
        browser = self.browser
        select = 'select[name=planet]'
        option = 'option[value=mars]'

        self.assertEqual('earth', browser.query(select).value)
        browser.selectOption(option)
        self.assertEqual('mars', browser.query(select).value)

    def test_unselect(self):
        browser = self.browser
        select = "select[name=colors]"
        option = "option[value=red]"

        self.assertTrue(browser.query(option).selected)
        browser.unselect(select, 'Color red')
        self.assertFalse(browser.query(option).selected)

    def test_unselectOption(self):
        browser = self.browser
        selector = "option[value=red]"

        self.assertTrue(browser.query(selector).selected)
        browser.unselectOption(selector)
        self.assertFalse(browser.query(selector).selected)

    def test_attach(self):
        browser = self.browser
        selector = 'input[name=myfile]'

        browser.attach(selector, __file__)
        files = [{
            'type': 'application/octet-stream',
            'name': os.path.basename(__file__),
            'size': os.path.getsize(__file__)}]
        self.assertEqual(files, browser.query(selector).files)

    def test_choose(self):
        browser = self.browser
        browser.choose('#color-2')
        self.assertEqual('2', browser.query('input[name=color]:checked').value)

    def test_field(self):
        field = self.browser.field('mycheckbox')
        self.assertEqual('checkbox', field.type)

    #
    # Document Content
    #
    def test_load(self):
        browser = self.browser
        browser.load("<html><head><title>Hey</title></head></html>")
        self.assertEqual('Hey', browser.query('title').text)

    def test_body(self):
        body = self.browser.body
        assert isinstance(body, DOMNode)

        html = body.innerHTML
        assert '<title>Example</title>' not in html
        assert '<p>This is an HTML document</p>' in html

    def test_html(self):
        html = self.browser.html()
        assert '<title>Example</title>' in html
        assert '<p>This is an HTML document</p>' in html

    def test_html_with_selector(self):
        html = self.browser.html('#content')
        assert '<title>Example</title>' not in html
        assert '<p>This is an HTML document</p>' in html

    def test_html_with_context(self):
        html = self.browser.html('#content', self.browser.query('body'))
        assert '<title>Example</title>' not in html
        assert '<p>This is an HTML document</p>' in html

    def test_text(self):
        text = self.browser.text('title')
        assert text == 'Example'

    def test_text_no_match(self):
        text = self.browser.text('blink')
        assert not text

    def test_text_with_context(self):
        text = self.browser.text('title', self.browser.query('head'))
        assert text == 'Example'

    def test_text_with_context_missing(self):
        text = self.browser.text('title', self.browser.query('body'))
        assert not text

    def test_css(self):
        for tag in ['h1', 'p', 'form', 'input', 'button']:
            matches = self.browser.css(tag)
            assert len(matches)

    def test_css_no_results(self):
        matches = self.browser.css('blink')
        self.assertEqual(0, len(matches))

    def test_query(self):
        for tag in ['h1', 'p', 'form', 'input', 'button']:
            match = self.browser.query(tag)
            assert isinstance(match, DOMNode)

    def test_query_no_results(self):
        match = self.browser.query('blink')
        self.assertIsNone(match)

    def test_by_id(self):
        matches = self.browser.css('#submit')
        assert len(matches) == 1
        assert matches[0].tagName.lower() == 'button'

    def test_by_class_name(self):
        matches = self.browser.css('.textfield')
        assert len(matches) == 1
        assert matches[0].tagName.lower() == 'input'

    #
    # Navigation
    #
    def test_location_get(self):
        for p in ('scheme', 'path'):
            getattr(urlparse(self.browser.location), p) == \
                getattr(urlparse(self.base_url), p)

    def test_location_set(self):
        url = self.base_url + 'location2'
        self.browser.location = url
        for p in ('scheme', 'path'):
            getattr(urlparse(self.browser.visit(url).location), p) == \
                getattr(urlparse(url), p)

    def test_click_link(self):
        browser = self.browser
        browser.clickLink('#about-zombie')
        self.assertEqual(self.base_url + 'location2', browser.location)

    def test_link_by_selector(self):
        match = self.browser.link('#about-zombie')
        assert isinstance(match, DOMNode)

        assert match.innerHTML == 'Learn About Zombie'

    def test_link_by_inner_text(self):
        match = self.browser.link('Learn About Zombie')
        assert isinstance(match, DOMNode)

        assert match.id == 'about-zombie'

    def test_back(self):
        browser = self.browser
        browser.clickLink('#about-zombie')
        self.assertTrue(browser.location.endswith('location2'))
        browser.back()
        self.assertEqual(self.browser.location, self.base_url)

    def test_reload(self):
        self.browser.fill('q', 'Zombie.js')
        assert self.browser.css('input')[0].value == 'Zombie.js'

        self.browser.reload()
        assert self.browser.css('input')[0].value == ''

    def test_status_code_200(self):
        assert self.browser.statusCode == 200

    def test_success(self):
        assert self.browser.success is True

    #
    # Forms
    #
    #
    # Debugging
    #

    def test_get_resource(self):
        res = self.browser.get_resource('/location2')
        self.assertEqual(200, res['statusCode'])

    def test_post_resource(self):
        res = self.browser.post_resource('/submit', {})
        self.assertIn('Submitted', res['body'])

    def test_evaluate(self):
        self.assertEqual(2, self.browser.evaluate('1+1'))

    def test_wait(self):
        self.browser.wait()

    def test_resources(self):
        resources = self.browser.resources
        assert len(resources)
        for r in resources:
            assert r['method']
            assert r['url']
            assert r['statusCode']
            assert r['statusText']
            assert r['time']

    def test_not_redirected(self):
        self.assertIn('<title>Example', self.browser.html())
        self.assertFalse(self.browser.redirected)

    def test_redirected(self):
        self.browser.visit(self.base_url + 'redirect')
        self.assertIn('<title>Example', self.browser.html())
        self.assertTrue(self.browser.redirected)


class TestDOMNode(BaseTestCase):
    def test_attribute_lookup(self):
        button = self.browser.query('button')
        assert button.innerHTML == 'Search'

    def test_text_content(self):
        btn = self.browser.query('button')
        assert btn.textContent == btn.innerText == btn.text == 'Search'

    def test_html_content(self):
        btn = self.browser.query('button')
        assert btn.innerHTML == btn.html == 'Search'

    def test_item_lookup(self):
        button = self.browser.query('button')
        assert button['innerHTML'] == 'Search'

    def test_printable(self):
        form = self.browser.css('form')[0]
        assert repr(form) == '<FORM#form.submittable>'

        button = self.browser.css('button')[0]
        assert repr(button) == '<BUTTON#submit>'

        textfield = self.browser.css('input')[0]
        assert repr(textfield) == '<INPUT.textfield>'

        paragraph = self.browser.css('p')[0]
        assert repr(paragraph) == '<P>'

    def test_css_chaining(self):
        # The <form> contains 4 input fields
        form = self.browser.css('form')[0]
        inputs = form.css('input')

        self.assertEqual(6, len(inputs))
        self.assertTrue(all(f.tagName.lower() == 'input' for f in inputs))

        # The document contains a paragraph, but it's *outside* of the form,
        # so it shouldn't be found under the form DOM node.
        self.assertEqual([], form.css('p'))

    def test_query_chaining(self):
        form = self.browser.query('form')
        button = form.query('button')
        assert button.innerHTML == 'Search'

    def test_fill(self):
        node = self.browser.css('input')[0]
        assert not node.value
        node.fill('Zombie.js')
        assert node.value == 'Zombie.js'

    def test_tag_name(self):
        for tag in ['h1', 'p', 'form', 'input', 'button']:
            matches = self.browser.css(tag)
            assert matches[0].tagName.lower() == tag

    def test_simple_field_value(self):
        """
        <input> fields should have a toggleable value.
        """
        assert not self.browser.css('input')[0].value
        self.browser.css('input')[0].value = 'Zombie.js'
        assert self.browser.css('input')[0].value == 'Zombie.js'

    def test_textarea_value(self):
        """
        <textarea> fields should have a toggleable value.
        """
        assert self.browser.css('textarea')[0].value == ''
        self.browser.css('textarea')[0].value = 'Sample Content'
        assert self.browser.css('textarea')[0].value == 'Sample Content'

    def test_checkbox_value(self):
        """
        If a "true" value is set on a checkbox, it should become checked,
        but it's underlying `value` attribute should *not* be changed.
        """
        checkbox = self.browser.css('input[type="checkbox"]')[0]
        assert checkbox.value == '1'
        assert not checkbox.checked
        checkbox.value = True
        assert checkbox.value == '1'
        assert checkbox.checked
        checkbox.value = False
        assert checkbox.value == '1'
        assert not checkbox.checked

    def test_checkbox_checked(self):
        """
        Checkboxes should have a toggleable `checked` property.
        """
        checkbox = self.browser.css('input[type="checkbox"]')[0]
        assert not checkbox.checked
        checkbox.checked = True
        assert checkbox.checked

    def test_radiobox_value(self):
        """
        If a "true" value is set on a radio input, it should become chosen,
        but it's underlying `value` attribute should *not* be changed.
        """
        radios = self.browser.css('input[type="radio"]')
        assert radios[0].value == '1'
        assert radios[1].value == '2'
        assert not radios[0].checked
        assert not radios[1].checked

        radios[0].value = True
        assert radios[0].value == '1'
        assert radios[0].checked

        radios[1].value = True
        assert radios[1].value == '2'
        assert radios[1].checked
        assert not radios[0].checked

    def test_radiobox_checked(self):
        """
        Radio inputs should have a toggleable `checked` property.
        """
        radios = self.browser.css('input[type="radio"]')
        assert radios[0].value == '1'
        assert radios[1].value == '2'
        assert not radios[0].checked
        assert not radios[1].checked

        radios[0].checked = True
        assert radios[0].value == '1'
        assert radios[0].checked

        radios[1].checked = True
        assert radios[1].value == '2'
        assert radios[1].checked
        assert not radios[0].checked

    def test_fire(self):
        self.browser.css('button')[0].click()
        assert urlparse(self.browser.location).path.endswith('/submit')

    def test_pressButton(self):
        self.browser.query('#submit').pressButton()
        self.assertTrue(self.browser.location.endswith('/submit'))

    def test_check(self):
        element = self.browser.query('input[name=mycheckbox]')
        element.check()
        self.assertTrue(element.checked)

    def test_uncheck(self):
        element = self.browser.query('input[name=mycheckedcheckbox]')
        self.assertTrue(element.checked)
        element.uncheck()
        self.assertFalse(element.checked)

    def test_select(self):
        element = self.browser.query('select[name=planet]')
        element.select('Planet Mars')
        self.assertTrue(self.browser.query('option[value=mars]').selected)

    def test_selectOption(self):
        element = self.browser.query('option[value=mars]')
        element.selectOption()
        self.assertTrue(element.selected)

    def test_unselect(self):
        element = self.browser.query('select[name=colors]')
        element.unselect('Color red')
        self.assertFalse(self.browser.query('option[value=red]').selected)

    def test_attach(self):
        element = self.browser.query('input[name=myfile]')

        element.attach(__file__)
        files = [{
            'type': 'application/octet-stream',
            'name': os.path.basename(__file__),
            'size': os.path.getsize(__file__)}]
        self.assertEqual(files, element.files)

    def test_choose(self):
        browser = self.browser
        browser.query('#color-2').choose()
        self.assertEqual('2', browser.query('input[name=color]:checked').value)

    def test_field(self):
        element = self.browser.query('body')
        self.assertIs(element, element.field())

########NEW FILE########
__FILENAME__ = test_client
import os
from zombie.compat import TestCase, PY3
if PY3:
    from socketserver import UnixStreamServer, StreamRequestHandler
else:
    from SocketServer import UnixStreamServer, StreamRequestHandler
import threading

try:
    from json import loads, dumps
except ImportError:
    from simplejson import loads, dumps  # noqa
import fudge

from zombie.proxy.client import (
    encode,
    encode_args,
    decode,
    Element,
    NodeError,
    ZombieServerConnection,
    ZombieProxyClient)
from zombie.proxy.server import ZombieProxyServer
from zombie.tests.webserver import WebServerTestCase


class EncodeTests(TestCase):
    def test_json(self):
        obj = lambda: 1
        obj.json = "myjson"
        self.assertEqual("myjson", encode(obj))

    def test_json_method(self):
        obj = lambda: 1
        obj.__json__ = lambda: "anotherjson"
        self.assertEqual("anotherjson", encode(obj))

    def test_asis(self):
        obj = [1, 2]
        self.assertEqual("[1, 2]", encode(obj))


class EncodeArgsTests(TestCase):
    def test_none(self):
        self.assertEqual('', encode_args(None))

    def test_empty(self):
        self.assertEqual('', encode_args([]))

    def test_arguments(self):
        self.assertEqual('"one", "two"', encode_args(['one', 'two']))

    def test_arguments_extra(self):
        self.assertEqual('"one", ', encode_args(['one'], True))


class DecodeTests(TestCase):
    def test_none(self):
        self.assertEqual(None, decode(None))

    def test_something(self):
        self.assertEqual([1], decode("[1]"))


class ElementTests(TestCase):
    def test_index(self):
        self.assertEqual(15, Element(15).index)

    def test_json(self):
        self.assertEqual("ELEMENTS[15]", Element(15).json)

    def test_str(self):
        self.assertEqual("ELEMENTS[15]", str(Element(15)))


class EchoHandler(StreamRequestHandler):
    def handle(self):
        self.wfile.write(self.rfile.readline())


class EchoServer(threading.Thread):
    def __init__(self, address):
        super(EchoServer, self).__init__()
        self.daemon = True
        self.server = UnixStreamServer(address, EchoHandler)

    def run(self):
        self.server.handle_request()

    def stop(self):
        self.server.shutdown()


class ZombieServerConnectionTests(TestCase):
    address = '/tmp/testing-unix-server'

    def cleanup(self):
        if os.path.exists(self.address):
            os.remove(self.address)

    def setUp(self):
        self.cleanup()
        self.server = EchoServer(self.address)
        self.server.start()
        self.connection = ZombieServerConnection(self.address)

    def tearDown(self):
        self.cleanup()

    def test_send(self):
        res = self.connection.send('Hello world!\n')
        self.assertEqual('Hello world!\n', res)


class ZombieProxyClientTests(WebServerTestCase):
    def setUp(self):
        super(ZombieProxyClientTests, self).setUp()
        # Note, As a singleton so it will be created once, not in every test.
        self.server = ZombieProxyServer()
        self.client = ZombieProxyClient(self.server.socket)

    def tearDown(self):
        super(ZombieProxyClientTests, self).tearDown()

    def test_simple_json(self):
        obj = {
            'foo': 'bar',
            'test': 500
        }
        self.assertEqual(obj, self.client.json(obj))

    def test_malformed_command(self):
        with self.assertRaises(NodeError):
            self.client.json("banana")

    def test_nowait(self):
        self.assertEqual('Test', self.client.nowait("result = 'Test';"))

    def test_wait(self):
        self.client.wait('browser.visit', self.base_url)

    def test_wait_error(self):
        with self.assertRaises(NodeError):
            self.client.wait('browser.visit', self.base_url + 'notfound')

    def test_ping(self):
        self.assertEqual("pong", self.client.ping())

    def test_cleanup(self):
        client = self.client
        self.assertEqual(1, client.json('browser.testing = 1'))
        client.cleanup()
        self.assertFalse(client.json('"testing" in browser'))

    def test_create_element(self):
        client = self.client
        client.wait('browser.visit', self.base_url)
        self.assertEqual(
            0,
            client.create_element('browser.query', ('form',)).index)
        self.assertEqual(
            1,
            client.create_element('browser.query', ('form',)).index)

    def test_create_element_attribute(self):
        client = self.client
        client.wait('browser.visit', self.base_url)
        self.assertEqual(
            0, client.create_element('browser.html').index)

    def test_create_elements(self):
        client = self.client
        client.wait('browser.visit', self.base_url)
        res = client.create_elements('browser.queryAll', ('input', ))
        self.assertEqual(list(range(6)), [x.index for x in res])

########NEW FILE########
__FILENAME__ = test_server
from unittest import TestCase
import subprocess
import os

import fudge

from zombie.proxy.server import ZombieProxyServer, proxy_path
from zombie.compat import StringIO


class FakeNode(object):
    def __json__(self):
        return 'ENCODED'


class FakePopen(object):

    stdin = StringIO()
    stdout = StringIO()


class TestServerSpawn(TestCase):

    def setUp(self):
        super(TestServerSpawn, self).setUp()
        self.server = ZombieProxyServer()

    def tearDown(self):
        super(TestServerSpawn, self).tearDown()
        fudge.clear_expectations()

    @property
    def _args(self):
        return [
            'env',
            'node',
            proxy_path,
            '/tmp/zombie.sock'
        ]

    @fudge.with_fakes
    def test_process_spawn(self):
        with fudge.patched_context(
            subprocess,
            'Popen',
            (fudge.Fake('Popen').
                is_callable().
                with_args(
                    self._args,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                ).returns(FakePopen()))):
            ZombieProxyServer(socket='/tmp/zombie.sock', wait=False)

    @fudge.with_fakes
    def test_configurable_socket(self):
        args = [
            'env',
            'node',
            proxy_path,
            '/tmp/zombie-custom.sock'
        ]
        with fudge.patched_context(
            subprocess,
            'Popen',
            (fudge.Fake('Popen').
                is_callable().
                with_args(
                    args,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                ).returns(FakePopen()))):
            ZombieProxyServer(socket='/tmp/zombie-custom.sock', wait=False)

    @fudge.with_fakes
    def test_stdout_redirect_exception(self):

        fake = FakePopen()
        fake.stdout = None

        with fudge.patched_context(
            subprocess,
            'Popen',
            (fudge.Fake('Popen').
                is_callable().
                with_args(
                    self._args,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                ).
                returns(fake))):
            ZombieProxyServer(socket='/tmp/zombie.sock', wait=False)

    def test_server_running(self):
        assert self.server.child is not None
        assert self.server.child.pid is not None

        #
        # Sending signal 0 will raise an OSError
        # exception if the process is not running,
        # and do nothing otherwise.
        #
        try:
            os.kill(self.server.child.pid, 0)
        except OSError:
            assert False
        else:
            pass

        assert os.path.exists(self.server.socket)

########NEW FILE########
__FILENAME__ = test_webserver
from zombie.compat import PY3, to_bytes
if PY3:
    from urllib.request import urlopen
    from urllib.parse import urlencode
    from urllib.error import HTTPError
else:
    from urllib2 import urlopen, HTTPError
    from urllib import urlencode
from zombie.tests.webserver import WebServerTestCase


class TestServerTests(WebServerTestCase):
    """
    Test the TestServer to make sure it does what we want and avoid misterious
    problems during normal testing
    """
    def test_index(self):
        response = urlopen(self.base_url)
        self.assertEqual(200, response.getcode())
        self.assertEqual(response.headers['Content-type'], 'text/html')
        self.assertIn('<title>Example</title>', str(response.read()))

    def test_post_submit(self):
        data = {'my_input': 'my_value'}
        encoded_data = to_bytes(urlencode(data))
        response = urlopen(self.base_url + 'submit', encoded_data)
        self.assertEqual(200, response.getcode())
        self.assertEqual(response.headers['Content-type'], 'text/html')
        self.assertIn('Submitted', str(response.read()))

    def test_redirect(self):
        response = urlopen(self.base_url + 'redirect')
        self.assertEqual(self.base_url, response.geturl())

    def test_not_found(self):
        with self.assertRaises(HTTPError):
            response = urlopen(self.base_url + 'not_found_asf')

########NEW FILE########
__FILENAME__ = webserver
import logging
import os.path
import random
import threading
from wsgiref.simple_server import make_server, WSGIRequestHandler
from zombie.compat import TestCase, to_bytes

logger = logging.getLogger(__name__)


class WSGIRunner(threading.Thread):
    """
    Wraps a WSGI application in a thread
    """
    def __init__(self, app):
        """Creates the runner with a server inside"""
        super(WSGIRunner, self).__init__()
        self.server = make_server(
            '', 0, app, handler_class=TestWSGIRequestHandler)
        self.daemon = True

    @property
    def port(self):
        """Port assigned to the HTTP server"""
        return self.server.server_address[1]

    def run(self):
        """Used by :class:`threading.Thread` to start the thread"""
        self.server.serve_forever()

    def stop(self):
        """Shutdown the WSGI server and wait for the thread to finish"""
        self.server.shutdown()
        self.join()


class TestWSGIRequestHandler(WSGIRequestHandler):
    """
    This request handler overrides some default functionality:
    - Logging of messages
    """
    # Enable keepalive (default is HTTP/1.0)
    protocol_version = "HTTP/1.1"

    def address_string(self):
        """Client address 'host:port' formatted"""
        host, port = self.client_address[:2]
        return '%s:%s' % (host, port)

    def _log(self, level, msg):
        """Log to the module logger"""
        logger.log(level, msg)

    def log_message(self, format, *args):
        """Override the stdout logging"""
        msg = "%s - - [%s] %s" % (
            self.address_string(),
            self.log_date_time_string(), format % args)
        self._log(logging.INFO, msg)


class AppBuilder(object):
    def __init__(self, base_path):
        self.base = base_path
        self.routes = {}

    def add_html(self, method, path, filename):
        filepath = os.path.join(self.base, filename)
        with open(filepath, 'r') as html_file:
            contents = to_bytes(html_file.read())

        def action(environ, start_response):
            start_response(
                '200 OK',
                [('Content-Type', 'text/html')])
            return contents

        self.add_route(method, path, action)

    def add_redirect(self, method, path, redirect_to):
        def action(environ, start_response):
            response_headers = [
                ('Location', redirect_to),
                ('Content-type', 'text/plain')
            ]
            start_response('302 Found', response_headers)
            return to_bytes('')
        self.add_route(method, path, action)

    def add_route(self, method, path, action):
        route_item = self.routes.get(path, {})
        route_item[method] = action
        self.routes[path] = route_item

    def __call__(self, environ, start_response):
        return App(self.routes, environ, start_response)


class App(object):
    def __init__(self, routes, environ, start_response):
        self.routes = routes
        self.environ = environ
        self.start_response = start_response

    @property
    def path_info(self):
        """The environ['PATH_INFO']"""
        return self.environ['PATH_INFO']

    @property
    def request_method(self):
        """The environ['REQUEST_METHOD']"""
        return self.environ['REQUEST_METHOD']

    def __iter__(self):
        """
        A sample WSGI app that forcibly redirects all requests to /
        """
        route = self.routes.get(self.path_info, {})
        action = route.get(self.request_method, None)
        if action is None:
            yield self.not_found()
        else:
            yield action(self.environ, self.start_response)

    def not_found(self):
        """Called if no URL matches."""
        self.start_response(
            '404 NOT FOUND',
            [('Content-Type', 'text/plain')])
        return to_bytes('Not Found')


def build_test_app():
    """Configure the test app"""
    module_path = os.path.dirname(os.path.abspath(__file__))
    base = os.path.join(module_path, 'helpers')

    builder = AppBuilder(base)
    builder.add_html('GET', '/', 'index.html')
    builder.add_html('GET', '/location2', 'location2.html')
    builder.add_html('POST', '/submit', 'submit.html')
    builder.add_redirect('GET', '/redirect', '/')
    return builder


class WebServerTestCase(TestCase):
    @classmethod
    def setUpClass(cls):
        """Starts the HTTP server with some basic urls"""
        app = build_test_app()
        cls.runner = WSGIRunner(app)
        cls.runner.start()

    @classmethod
    def tearDownClass(cls):
        """Stop the server"""
        cls.runner.stop()
        cls.runner = None

    @property
    def base_url(self):
        """URL with port about where is the server serving"""
        return 'http://127.0.0.1:%s/' % self.runner.port

########NEW FILE########
