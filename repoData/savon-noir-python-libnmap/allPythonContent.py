__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# libnmap documentation build configuration file, created by
# sphinx-quickstart on Thu May 16 15:19:55 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'libnmap'
copyright = u'CC-BY 2013, Ronald Bister'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2'
# The full version, including alpha/beta/rc tags.
release = '0.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'libnmapdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'libnmap.tex', u'libnmap Documentation',
   u'Ronald Bister', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'libnmap', u'libnmap Documentation',
     [u'Ronald Bister'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'libnmap', u'libnmap Documentation',
   u'Ronald Bister', 'libnmap', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = check_cpe
#!/usr/bin/env python

from libnmap.parser import NmapParser

rep = NmapParser.parse_fromfile('libnmap/test/files/full_sudo6.xml')

print("Nmap scan discovered {0}/{1} hosts up".format(rep.hosts_up,
                                                     rep.hosts_total))
for _host in rep.hosts:
    if _host.is_up():
        print("+ Host: {0} {1}".format(_host.address,
                                       " ".join(_host.hostnames)))

        # get CPE from service if available
        for s in _host.services:
            print "    Service: {0}/{1} ({2})".format(s.port,
                                                      s.protocol,
                                                      s.state)
            # NmapService.cpelist returns an array of CPE objects
            for _serv_cpe in s.cpelist:
                print "        CPE: {0}".format(_serv_cpe.cpestring)

        if _host.os_fingerprinted:
            print "  OS Fingerprints"
            for osm in _host.os.osmatches:
                print("    Found Match:{0} ({1}%)".format(osm.name,
                                                          osm.accuracy))
                # NmapOSMatch.get_cpe() method return an array of string
                # unlike NmapOSClass.cpelist which returns an array of CPE obj
                for cpe in osm.get_cpe():
                    print("\t    CPE: {0}".format(cpe))

########NEW FILE########
__FILENAME__ = diff_sample1
#!/usr/bin/env python

from libnmap.parser import NmapParser

rep1 = NmapParser.parse_fromfile('libnmap/test/files/1_hosts.xml')
rep2 = NmapParser.parse_fromfile('libnmap/test/files/1_hosts_diff.xml')

rep1_items_changed = rep1.diff(rep2).changed()
changed_host_id = rep1_items_changed.pop().split('::')[1]

changed_host1 = rep1.get_host_byid(changed_host_id)
changed_host2 = rep2.get_host_byid(changed_host_id)
host1_items_changed = changed_host1.diff(changed_host2).changed()

changed_service_id = host1_items_changed.pop().split('::')[1]
changed_service1 = changed_host1.get_service_byid(changed_service_id)
changed_service2 = changed_host2.get_service_byid(changed_service_id)
service1_items_changed = changed_service1.diff(changed_service2).changed()

for diff_attr in service1_items_changed:
    print "diff({0}, {1}) [{2}:{3}] [{4}:{5}]".format(changed_service1.id,
                                                      changed_service2.id,
                                                      diff_attr,
                                                      getattr(changed_service1,
                                                              diff_attr),
                                                      diff_attr,
                                                      getattr(changed_service2,
                                                              diff_attr))

########NEW FILE########
__FILENAME__ = diff_sample2
#!/usr/bin/env python

from libnmap.parser import NmapParser


def nested_obj(objname):
    rval = None
    splitted = objname.split("::")
    if len(splitted) == 2:
        rval = splitted
    return rval


def print_diff_added(obj1, obj2, added):
    for akey in added:
        nested = nested_obj(akey)
        if nested is not None:
            if nested[0] == 'NmapHost':
                subobj1 = obj1.get_host_byid(nested[1])
            elif nested[0] == 'NmapService':
                subobj1 = obj1.get_service_byid(nested[1])
            print "+ {0}".format(subobj1)
        else:
            print "+ {0} {1}: {2}".format(obj1, akey, getattr(obj1, akey))


def print_diff_removed(obj1, obj2, removed):
    for rkey in removed:
        nested = nested_obj(rkey)
        if nested is not None:
            if nested[0] == 'NmapHost':
                subobj2 = obj2.get_host_byid(nested[1])
            elif nested[0] == 'NmapService':
                subobj2 = obj2.get_service_byid(nested[1])
            print "- {0}".format(subobj2)
        else:
            print "- {0} {1}: {2}".format(obj2, rkey, getattr(obj2, rkey))


def print_diff_changed(obj1, obj2, changes):
    for mkey in changes:
        nested = nested_obj(mkey)
        if nested is not None:
            if nested[0] == 'NmapHost':
                subobj1 = obj1.get_host_byid(nested[1])
                subobj2 = obj2.get_host_byid(nested[1])
            elif nested[0] == 'NmapService':
                subobj1 = obj1.get_service_byid(nested[1])
                subobj2 = obj2.get_service_byid(nested[1])
            print_diff(subobj1, subobj2)
        else:
            print "~ {0} {1}: {2} => {3}".format(obj1, mkey,
                                                 getattr(obj2, mkey),
                                                 getattr(obj1, mkey))


def print_diff(obj1, obj2):
    ndiff = obj1.diff(obj2)

    print_diff_changed(obj1, obj2, ndiff.changed())
    print_diff_added(obj1, obj2, ndiff.added())
    print_diff_removed(obj1, obj2, ndiff.removed())


def main():
    newrep = NmapParser.parse_fromfile('libnmap/test/files/2_hosts_achange.xml')
    oldrep = NmapParser.parse_fromfile('libnmap/test/files/1_hosts.xml')

    print_diff(newrep, oldrep)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = json_serialize
from libnmap.parser import NmapParser
from libnmap.reportjson import ReportDecoder, ReportEncoder
import json

nmap_report_obj = NmapParser.parse_fromfile('libnmap/test/files/1_hosts.xml')

# create a json object from an NmapReport instance
nmap_report_json = json.dumps(nmap_report_obj, cls=ReportEncoder)
print nmap_report_json
# create a NmapReport instance from a json object
nmap_report_obj = json.loads(nmap_report_json, cls=ReportDecoder)
print nmap_report_obj


########NEW FILE########
__FILENAME__ = nmap_task
#!/usr/bin/env python

from libnmap.process import NmapProcess

def mycallback(nmaptask):
    nmaptask = nmap_proc.current_task
    if nmaptask:
        print "Task {0} ({1}): ETC: {2} DONE: {3}%".format(nmaptask.name,
                                                           nmaptask.status,
                                                           nmaptask.etc,
                                                           nmaptask.progress)

nmap_proc = NmapProcess(targets="scanme.nmap.org",
                        options="-sV",
                        event_callback=mycallback)
nmap_proc.run()
print nmap_proc.stdout
print nmap_proc.stderr

########NEW FILE########
__FILENAME__ = nmap_task_bg
#!/usr/bin/env python

from libnmap.process import NmapProcess

nmap_proc = NmapProcess(targets="scanme.nmap.org", options="-sV")
nmap_proc.run_background()
while nmap_proc.is_running():
    nmaptask = nmap_proc.current_task
    if nmaptask:
        print "Task {0} ({1}): ETC: {2} DONE: {3}%".format(nmaptask.name,
                                                           nmaptask.status,
                                                           nmaptask.etc,
                                                           nmaptask.progress)
print "rc: {0} output: {1}".format(nmap_proc.rc, nmap_proc.summary)
print nmap_proc.stdout
print nmap_proc.stderr

########NEW FILE########
__FILENAME__ = os_fingerprint
#!/usr/bin/env python

from libnmap.parser import NmapParser

rep = NmapParser.parse_fromfile('libnmap/test/files/os_scan6.xml')

print("{0}/{1} hosts up".format(rep.hosts_up, rep.hosts_total))
for _host in rep.hosts:
    if _host.is_up():
        print("{0} {1}".format(_host.address, " ".join(_host.hostnames)))
        if _host.os_fingerprinted:
            print("OS Fingerprint:")
            msg = ''
            for osm in _host.os.osmatches:
                print("Found Match:{0} ({1}%)".format(osm.name, osm.accuracy))
                for osc in osm.osclasses:
                    print("\tOS Class: {0}".format(osc.description))
                    for cpe in osc.cpelist:
                        print("\tCPE: {0}".format(cpe.cpestring))
        else:
            print "No fingerprint available"

########NEW FILE########
__FILENAME__ = proc_async
#!/usr/bin/env python

from libnmap.process import NmapProcess
from time import sleep


nmap_proc = NmapProcess(targets="scanme.nmap.org", options="-sT")
nmap_proc.run_background()
while nmap_proc.is_running():
    print "Nmap Scan running: ETC: {0} DONE: {1}%".format(nmap_proc.etc,
                                                          nmap_proc.progress)
    sleep(2)

print "rc: {0} output: {1}".format(nmap_proc.rc, nmap_proc.summary)

########NEW FILE########
__FILENAME__ = proc_nmap_like
#!/usr/bin/env python
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException


# start a new nmap scan on localhost with some specific options
def do_scan(targets, options):
    nm = NmapProcess(targets, options)
    rc = nm.run()
    if rc != 0:
        print "nmap scan failed: %s" % (nm.stderr)

    try:
        parsed = NmapParser.parse(nm.stdout)
    except NmapParserException as e:
        print "Exception raised while parsing scan: %s" % (e.msg)

    return parsed


# print scan results from a nmap report
def print_scan(nmap_report):
    print "Starting Nmap {0} ( http://nmap.org ) at {1}".format(
        nmap_report._nmaprun['version'],
        nmap_report._nmaprun['startstr'])

    for host in nmap_report.hosts:
        if len(host.hostnames):
            tmp_host = host.hostnames.pop()
        else:
            tmp_host = host.address

        print "Nmap scan report for {0} ({1})".format(
            tmp_host,
            host.address)
        print "Host is {0}.".format(host.status)
        print "  PORT     STATE         SERVICE"

        for serv in host.services:
            pserv = "{0:>5s}/{1:3s}  {2:12s}  {3}".format(
                    str(serv.port),
                    serv.protocol,
                    serv.state,
                    serv.service)
            if len(serv.banner):
                pserv += " ({0})".format(serv.banner)
            print pserv
    print nmap_report.summary


if __name__ == "__main__":
    report = do_scan("127.0.0.1", "-sV")
    print_scan(report)

########NEW FILE########
__FILENAME__ = diff
#!/usr/bin/env python


class DictDiffer(object):
    """
        Calculate the difference between two dictionaries as:
        (1) items added
        (2) items removed
        (3) keys same in both but changed values
        (4) keys same in both and unchanged values
    """
    def __init__(self, current_dict, past_dict):
        self.current_dict = current_dict
        self.past_dict = past_dict
        self.set_current = set(current_dict.keys())
        self.set_past = set(past_dict.keys())
        self.intersect = self.set_current.intersection(self.set_past)

    def added(self):
        return self.set_current - self.intersect

    def removed(self):
        return self.set_past - self.intersect

    def changed(self):
        return (set(o for o in self.intersect
                if self.past_dict[o] != self.current_dict[o]))

    def unchanged(self):
        return (set(o for o in self.intersect
                if self.past_dict[o] == self.current_dict[o]))


class NmapDiff(DictDiffer):
    """
        NmapDiff compares two objects of same type to enable the user to check:

        - what has changed
        - what has been added
        - what has been removed
        - what was kept unchanged

        NmapDiff inherit from DictDiffer which makes the actual comparaison.
        The different methods from DictDiffer used by NmapDiff are the
        following:

        - NmapDiff.changed()
        - NmapDiff.added()
        - NmapDiff.removed()
        - NmapDiff.unchanged()

        Each of the returns a python set() of key which have changed in the
        compared objects. To check the different keys that could be returned,
        refer to the get_dict() method of the objects you which to
        compare (i.e: libnmap.objects.NmapHost, NmapService,...).
    """
    def __init__(self, nmap_obj1, nmap_obj2):
        """
            Constructor of NmapDiff:

            - Checks if the two objects are of the same class
            - Checks if the objects are "comparable" via a call to id() (dirty)
            - Inherits from DictDiffer and
        """
        if(nmap_obj1.__class__ != nmap_obj2.__class__ or
           nmap_obj1.id != nmap_obj2.id):
            raise NmapDiffException("Comparing objects with non-matching id")

        self.object1 = nmap_obj1.get_dict()
        self.object2 = nmap_obj2.get_dict()

        DictDiffer.__init__(self, self.object1, self.object2)

    def __repr__(self):
        return ("added: [{0}] -- changed: [{1}] -- "
                "unchanged: [{2}] -- removed [{3}]".format(self.added(),
                                                           self.changed(),
                                                           self.unchanged(),
                                                           self.removed()))


class NmapDiffException(Exception):
    def __init__(self, msg):
        self.msg = msg

########NEW FILE########
__FILENAME__ = cpe

class CPE(object):
    """
        CPE class offers an API for basic CPE objects.
        These objects could be found in NmapService or in <os> tag
        within NmapHost.

        :todo: interpret CPE string and provide appropriate API
    """
    def __init__(self, cpestring):
        self._cpestring = cpestring
        self.cpedict = {}

        zk = ['cpe', 'part', 'vendor', 'product', 'version',
              'update', 'edition', 'language']
        self._cpedict = dict((k, '') for k in zk)
        splitup = cpestring.split(':')
        self._cpedict.update(dict(zip(zk, splitup)))

    @property
    def cpestring(self):
        """
            Accessor for the full CPE string.
        """
        return self._cpestring

    def __repr__(self):
        return self._cpestring

    def get_part(self):
        """
            Returns the cpe part (/o, /h, /a)
        """
        return self._cpedict['part']

    def get_vendor(self):
        """
            Returns the vendor name
        """
        return self._cpedict['vendor']

    def get_product(self):
        """
            Returns the product name
        """
        return self._cpedict['product']

    def get_version(self):
        """
            Returns the version of the cpe
        """
        return self._cpedict['version']

    def get_update(self):
        """
            Returns the update version
        """
        return self._cpedict['update']

    def get_edition(self):
        """
            Returns the cpe edition
        """
        return self._cpedict['edition']

    def get_language(self):
        """
            Returns the cpe language
        """
        return self._cpedict['language']

    def is_application(self):
        """
            Returns True if cpe describes an application
        """
        return (self.get_part() == '/a')

    def is_hardware(self):
        """
            Returns True if cpe describes a hardware
        """
        return (self.get_part() == '/h')

    def is_operating_system(self):
        """
            Returns True if cpe describes an operating system
        """
        return (self.get_part() == '/o')

########NEW FILE########
__FILENAME__ = host
#!/usr/bin/env python
from libnmap.diff import NmapDiff
from libnmap.objects.os import NmapOSFingerprint


class NmapHost(object):
    """
        NmapHost is a class representing a host object of NmapReport
    """
    def __init__(self, starttime='', endtime='', address=None, status=None,
                 hostnames=None, services=None, extras=None):
        """
            NmapHost constructor
            :param starttime: unix timestamp of when the scan against
            that host started
            :type starttime: string
            :param endtime: unix timestamp of when the scan against
            that host ended
            :type endtime: string
            :param address: dict ie :{'addr': '127.0.0.1', 'addrtype': 'ipv4'}
            :param status: dict ie:{'reason': 'localhost-response',
                                    'state': 'up'}
            :return: NmapHost:
        """
        self._starttime = starttime
        self._endtime = endtime
        self._hostnames = hostnames if hostnames is not None else []
        self._status = status if status is not None else {}
        self._services = services if services is not None else []
        self._extras = extras if extras is not None else {}
        self._osfingerprinted = False
        self.os = None
        if 'os' in self._extras:
            self.os = NmapOSFingerprint(self._extras['os'])
            self._osfingerprinted = True
        else:
            self.os = NmapOSFingerprint({})

        self._ipv4_addr = None
        self._ipv6_addr = None
        self._mac_addr = None
        for addr in address:
            if addr['addrtype'] == "ipv4":
                self._ipv4_addr = addr['addr']
            elif addr['addrtype'] == 'ipv6':
                self._ipv6_addr = addr['addr']
            elif addr['addrtype'] == 'mac':
                self._mac_addr = addr['addr']

        self._main_address = self._ipv4_addr or self._ipv6_addr or ''
        self._address = address

    def __eq__(self, other):
        """
            Compare eq NmapHost based on :

                - hostnames
                - address
                - if an associated services has changed

            :return: boolean
        """
        rval = False
        if(self.__class__ == other.__class__ and self.id == other.id):
            rval = (self.changed(other) == 0)
        return rval

    def __ne__(self, other):
        """
            Compare ne NmapHost based on:

                - hostnames
                - address
                - if an associated services has changed

            :return: boolean
        """
        rval = True
        if(self.__class__ == other.__class__ and self.id == other.id):
            rval = (self.changed(other) > 0)
        return rval

    def __repr__(self):
        """
            String representing the object
            :return: string
        """
        return "{0}: [{1} ({2}) - {3}]".format(self.__class__.__name__,
                                               self.address,
                                               " ".join(self._hostnames),
                                               self.status)

    def __hash__(self):
        """
            Hash is needed to be able to use our object in sets
            :return: hash
        """
        return (hash(self.status) ^ hash(self.address) ^
                hash(frozenset(self._services)) ^
                hash(frozenset(" ".join(self._hostnames))))

    def changed(self, other):
        """
            return the number of attribute who have changed
            :param other: NmapHost object to compare
            :return int
        """
        return len(self.diff(other).changed())

    @property
    def starttime(self):
        """
            Accessor for the unix timestamp of when the scan was started

            :return: string
        """
        return self._starttime

    @property
    def endtime(self):
        """
            Accessor for the unix timestamp of when the scan ended

            :return: string
        """
        return self._endtime

    @property
    def address(self):
        """
            Accessor for the IP address of the scanned host

            :return: IP address as a string
        """
        return self._main_address

    @address.setter
    def address(self, addrdict):
        """
            Setter for the address dictionnary.

            :param addrdict: valid dict is {'addr': '1.1.1.1',
                                            'addrtype': 'ipv4'}
        """
        if addrdict['addrtype'] == 'ipv4':
            self._ipv4_addr = addrdict['addr']
        elif addrdict['addrtype'] == 'ipv6':
            self._ipv6_addr = addrdict['addr']
        if addrdict['addrtype'] == 'mac':
            self._mac_addr = addrdict['addr']

        self._main_address = self._ipv4_addr or self._ipv6_addr or ''
        self._address = addrdict

    @property
    def ipv4(self):
        """
            Accessor for the IPv4 address of the scanned host

            :return: IPv4 address as a string
        """
        return self._ipv4_addr or ''

    @property
    def mac(self):
        """
            Accessor for the MAC address of the scanned host

            :return: MAC address as a string
        """
        return self._mac_addr or ''

    @property
    def ipv6(self):
        """
            Accessor for the IPv6 address of the scanned host

            :return: IPv6 address as a string
        """
        return self._ipv6_addr or ''

    @property
    def status(self):
        """
            Accessor for the host's status (up, down, unknown...)

            :return: string
        """
        return self._status['state']

    @status.setter
    def status(self, statusdict):
        """
            Setter for the status dictionnary.

            :param statusdict: valid dict is {"state": "open",
                                              "reason": "syn-ack",
                                              "reason_ttl": "0"}
                                'state' is the only mandatory key.
        """
        self._status = statusdict

    def is_up(self):
        """
            method to determine if host is up or not

            :return: bool
        """
        rval = False
        if self.status == 'up':
            rval = True
        return rval

    @property
    def hostnames(self):
        """
            Accessor returning the list of hostnames (array of strings).

            :return: array of string
        """
        return self._hostnames

    @property
    def services(self):
        """
            Accessor for the array of scanned services for that host.

            An array of NmapService objects is returned.

            :return: array of NmapService
        """
        return self._services

    def get_ports(self):
        """
            Retrieve a list of the port used by each service of the NmapHost

            :return: list: of tuples (port,'proto') ie:[(22,'tcp'),(25, 'tcp')]
        """
        return [(p.port, p.protocol) for p in self._services]

    def get_open_ports(self):
        """
            Same as get_ports() but only for open ports

            :return: list: of tuples (port,'proto') ie:[(22,'tcp'),(25, 'tcp')]
        """
        return ([(p.port, p.protocol)
                for p in self._services if p.state == 'open'])

    def get_service(self, portno, protocol='tcp'):
        """
            :param portno: int the portnumber
            :param protocol='tcp': string ('tcp','udp')

            :return: NmapService or None
        """
        plist = [p for p in self._services if
                 p.port == portno and p.protocol == protocol]
        if len(plist) > 1:
            raise Exception("Duplicate services found in NmapHost object")
        return plist.pop() if len(plist) else None

    def get_service_byid(self, service_id):
        """
            Returns a NmapService by providing its id.

            The id of a nmap service is a python tupl made of (protocol, port)
        """
        rval = None
        for _tmpservice in self._services:
            if _tmpservice.id == service_id:
                rval = _tmpservice
        return rval

    def os_class_probabilities(self):
        """
            Returns an array of possible OS class detected during
            the OS fingerprinting.

            :return: Array of NmapOSClass objects
        """
        rval = []
        if self.os is not None:
            rval = self.os.osclasses
        return rval

    def os_match_probabilities(self):
        """
            Returns an array of possible OS match detected during
            the OS fingerprinting

            :return: array of NmapOSMatches objects
        """
        rval = []
        if self.os is not None:
            rval = self.os.osmatches
        return rval

    @property
    def os_fingerprinted(self):
        """
            Specify if the host has OS fingerprint data available

            :return: Boolean
        """
        return self._osfingerprinted

    @property
    def os_fingerprint(self):
        """
            Returns the fingerprint of the scanned system.

            :return: string
        """
        rval = ''
        if self.os is not None:
            rval = self.os.fingerprints.join("\n")
        return rval

    def os_ports_used(self):
        """
            Returns an array of the ports used for OS fingerprinting

            :return: array of ports used: [{'portid': '22',
                                            'proto': 'tcp',
                                            'state': 'open'},]
        """
        rval = []
        try:
            rval = self._extras['os']['ports_used']
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def tcpsequence(self):
        """
            Returns the difficulty to determine remotely predict
            the tcp sequencing.

            return: string
        """
        rval = ''
        try:
            rval = self._extras['tcpsequence']['difficulty']
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def ipsequence(self):
        """
            Return the class of ip sequence of the remote hosts.

            :return: string
        """
        rval = ''
        try:
            rval = self._extras['ipidsequence']['class']
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def uptime(self):
        """
            uptime of the remote host (if nmap was able to determine it)

            :return: string (in seconds)
        """
        rval = 0
        try:
            rval = int(self._extras['uptime']['seconds'])
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def lastboot(self):
        """
            Since when the host was booted.

            :return: string
        """
        rval = ''
        try:
            rval = self._extras['uptime']['lastboot']
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def distance(self):
        """
            Number of hops to host

            :return: int
        """
        rval = 0
        try:
            rval = int(self._extras['distance']['value'])
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def scripts_results(self):
        """
            Scripts results specific to the scanned host

            :return: array of <script> dictionary
        """
        rval = {}
        try:
            rval = self._extras['hostscript']
        except (KeyError, TypeError):
            pass
        return rval

    @property
    def id(self):
        """
            id of the host. Used for diff()ing NmapObjects

            :return: string
        """
        return self.address

    @property
    def extraports_state(self):
        """
            dictionnary containing state and amount of extra ports scanned
            for which a common state, usually, closed was discovered.

            :return: dict with keys 'state' and 'count'
        """
        _xtrports = self._extras['extraports']
        return {'state': _xtrports['state'], 'count': _xtrports['count']}

    @property
    def extraports_reasons(self):
        """
            dictionnary containing reasons why extra ports scanned
            for which a common state, usually, closed was discovered.

            :return: array of dict containing keys 'state' and 'count'
        """
        return self._extras['extraports']['reasons']

    def get_dict(self):
        """
            Return a dict representation of the object.

            This is needed by NmapDiff to allow comparaison

            :return dict
        """
        d = dict([("%s::%s" % (s.__class__.__name__, str(s.id)),
                   hash(s))
                 for s in self.services])

        d.update({'address': self.address, 'status': self.status,
                  'hostnames': " ".join(self._hostnames)})
        return d

    def diff(self, other):
        """
            Calls NmapDiff to check the difference between self and
            another NmapHost object.

            Will return a NmapDiff object.

            This objects return python set() of keys describing the elements
            which have changed, were added, removed or kept unchanged.

            :param other: NmapHost to diff with

            :return: NmapDiff object
        """
        return NmapDiff(self, other)

########NEW FILE########
__FILENAME__ = os
import warnings
from libnmap.objects.cpe import CPE


class OSFPPortUsed(object):
    """
        Port used class: this enables the user of NmapOSFingerprint class
        to have a common and clear interface to access portused data which
        were collected and used during os fingerprint scan
    """
    def __init__(self, port_used_dict):
        try:
            self._state = port_used_dict['state']
            self._proto = port_used_dict['proto']
            self._portid = port_used_dict['portid']
        except KeyError:
            raise Exception("Cannot create OSFPPortUsed: missing required key")

    @property
    def state(self):
        """
            Accessor for the portused state (closed, open,...)
        """
        return self._state

    @property
    def proto(self):
        """
            Accessor for the portused protocol (tcp, udp,...)
        """
        return self._proto

    @property
    def portid(self):
        """
            Accessor for the referenced port number used
        """
        return self._portid


class NmapOSMatch(object):
    """
        NmapOSMatch is an internal class used for offering results
        from an nmap os fingerprint. This common interfaces makes
        a compatibility between old nmap xml (<1.04) and new nmap
        xml versions (used in nmapv6 for instance).

        In previous xml version, osclass tags from nmap fingerprints
        were not directly mapped to a osmatch. In new xml version,
        osclass could be embedded in osmatch tag.

        The approach to solve this is to create a common class
        which will, for older xml version, match based on the accuracy
        osclass to an osmatch. If no match, an osmatch will be made up
        from a concat of os class attributes: vendor and osfamily.
        Unmatched osclass will have a line attribute of -1.

        More info, see issue #26 or http://seclists.org/nmap-dev/2012/q2/252
    """
    def __init__(self, osmatch_dict):
        _osmatch_dict = osmatch_dict['osmatch']
        if('name' not in _osmatch_dict or
           'line' not in _osmatch_dict or
           'accuracy' not in _osmatch_dict):
            raise Exception("Cannot create NmapOSClass: missing required key")

        self._name = _osmatch_dict['name']
        self._line = _osmatch_dict['line']
        self._accuracy = _osmatch_dict['accuracy']

        # create osclass list
        self._osclasses = []
        try:
            for _osclass in osmatch_dict['osclasses']:
                try:
                    _osclassobj = NmapOSClass(_osclass)
                except:
                    raise Exception("Could not create NmapOSClass object")
                self._osclasses.append(_osclassobj)
        except KeyError:
            pass

    def add_osclass(self, osclass_obj):

        """
            Add a NmapOSClass object to the OSMatch object. This method is
            useful to implement compatibility with older versions of NMAP
            by providing a common interface to access os fingerprint data.
        """
        self._osclasses.append(osclass_obj)

    @property
    def osclasses(self):
        """
            Accessor for all NmapOSClass objects matching with this OS Match
        """
        return self._osclasses

    @property
    def name(self):
        """
            Accessor for name attribute (e.g.: Linux 2.4.26 (Slackware 10.0.0))
        """
        return self._name

    @property
    def line(self):
        """
            Accessor for line attribute as integer. value equals -1 if this
            osmatch holds orphans NmapOSClass objects. This could happen with
            older version of nmap xml engine (<1.04 (e.g: nmapv6)).

            :return: int
        """
        return int(self._line)

    @property
    def accuracy(self):
        """
            Accessor for accuracy

            :return: int
        """
        return int(self._accuracy)

    def get_cpe(self):
        """
            This method return a list of cpe stings and not CPE objects as
            the NmapOSClass.cpelist property. This method is a helper to
            simplify data management.

            For more advanced handling of CPE data, use NmapOSClass.cpelist
            and use the methods from CPE class
        """
        _cpelist = []
        for osc in self.osclasses:
            for cpe in osc.cpelist:
                _cpelist.append(cpe.cpestring)
        return _cpelist

    def __repr__(self):
        rval = "{0}: {1}".format(self.name, self.accuracy)
        for _osclass in self._osclasses:
            rval += "\r\n  |__ os class: {0}".format(str(_osclass))
        return rval


class NmapOSClass(object):
    """
        NmapOSClass offers an unified API to access data from analysed
        osclass tag. As implemented in libnmap and newer version of nmap,
        osclass objects will always be embedded in a NmapOSMatch.
        Unmatched NmapOSClass will be stored in "dummy" NmapOSMatch objects
        which will have the particularity of have a line attribute of -1.
        On top of this, NmapOSClass will have optional CPE objects
        embedded.
    """
    def __init__(self, osclass_dict):
        _osclass = osclass_dict['osclass']
        if('vendor' not in _osclass or
           'osfamily' not in _osclass or
           'accuracy' not in _osclass):
            raise Exception("Wrong osclass structure: missing required key")

        self._vendor = _osclass['vendor']
        self._osfamily = _osclass['osfamily']
        self._accuracy = _osclass['accuracy']

        self._osgen = ''
        self._type = ''
        # optional data
        if 'osgen' in _osclass:
            self._osgen = _osclass['osgen']
        if 'type' in _osclass:
            self._type = _osclass['type']

        self._cpelist = []
        for _cpe in osclass_dict['cpe']:
            self._cpelist.append(CPE(_cpe))

    @property
    def cpelist(self):
        """
            Returns a list of CPE Objects matching with this os class

            :return: list of CPE objects
            :rtype: Array
        """
        return self._cpelist

    @property
    def vendor(self):
        """
            Accessor for vendor information (Microsoft, Linux,...)

            :return: string
        """
        return self._vendor

    @property
    def osfamily(self):
        """
            Accessor for OS family information (Windows, Linux,...)

            :return: string
        """
        return self._osfamily

    @property
    def accuracy(self):
        """
            Accessor for OS class detection accuracy (int)

            :return: int
        """
        return int(self._accuracy)

    @property
    def osgen(self):
        """
            Accessor for OS class generation (7, 8, 2.4.X,...).

            :return: string
        """
        return self._osgen

    @property
    def type(self):
        """
            Accessor for OS class type (general purpose,...)

            :return: string
        """
        return self._type

    @property
    def description(self):
        """
            Accessor helper which returns a concataned string of
            the valuable attributes from NmapOSClass object

            :return: string
        """
        rval = "{0}: {1}, {2}".format(self.type, self.vendor, self.osfamily)
        if len(self.osgen):
            rval += "({0})".format(self.osgen)
        return rval

    def __repr__(self):
        rval = "{0}: {1}, {2}".format(self.type, self.vendor, self.osfamily)
        if len(self.osgen):
            rval += "({0})".format(self.osgen)
        for _cpe in self._cpelist:
            rval += "\r\n    |__ {0}".format(str(_cpe))
        return rval


class NmapOSFingerprint(object):
    """
        NmapOSFingerprint is a easier API for using os fingerprinting.
        Data for OS fingerprint (<os> tag) is instanciated from
        a NmapOSFingerprint which is accessible in NmapHost via NmapHost.os
    """
    def __init__(self, osfp_data):
        self.__osmatches = []
        self.__ports_used = []
        self.__fingerprints = []

        if 'osmatches' in osfp_data:
            for _osmatch in osfp_data['osmatches']:
                _osmatch_obj = NmapOSMatch(_osmatch)
                self.__osmatches.append(_osmatch_obj)
        if 'osclasses' in osfp_data:
            for _osclass in osfp_data['osclasses']:
                _osclass_obj = NmapOSClass(_osclass)
                _osmatched = self.get_osmatch(_osclass_obj)
                if _osmatched is not None:
                    _osmatched.add_osclass(_osclass_obj)
                else:
                    self._add_dummy_osmatch(_osclass_obj)
        if 'osfingerprints' in osfp_data:
            for _osfp in osfp_data['osfingerprints']:
                if 'fingerprint' in _osfp:
                    self.__fingerprints.append(_osfp['fingerprint'])
        if 'ports_used' in osfp_data:
            for _pused_dict in osfp_data['ports_used']:
                _pused = OSFPPortUsed(_pused_dict)
                self.__ports_used.append(_pused)

    def get_osmatch(self, osclass_obj):
        """
            This function enables NmapOSFingerprint to determine if an
            NmapOSClass object could be attached to an existing NmapOSMatch
            object in order to respect the common interface for
            the nmap xml version < 1.04 and >= 1.04

            :return: an NmapOSMatch object matching with the NmapOSClass
            provided in parameter (match is performed based on accuracy)
        """
        rval = None
        for _osmatch in self.__osmatches:
            if _osmatch.accuracy == osclass_obj.accuracy:
                rval = _osmatch
                break  # sorry
        return rval

    def _add_dummy_osmatch(self, osclass_obj):
        """
            This functions creates a dummy NmapOSMatch object in order to
            encapsulate an NmapOSClass object which was not matched with an
            existing NmapOSMatch object
        """
        _dname = "{0}:{1}:{2}".format(osclass_obj.type,
                                      osclass_obj.vendor,
                                      osclass_obj.osfamily)
        _dummy_dict = {'osmatch': {'name': _dname,
                                   'accuracy': osclass_obj.accuracy,
                                   'line': -1},
                       'osclasses': []}
        _dummy_osmatch = NmapOSMatch(_dummy_dict)
        self.__osmatches.append(_dummy_osmatch)

    @property
    def osmatches(self, min_accuracy=0):
        _osmatches = []

        for _osmatch in self.__osmatches:
            if _osmatch.accuracy >= min_accuracy:
                _osmatches.append(_osmatch)

        return _osmatches

    @property
    def fingerprint(self):
        return "\r\n".join(self.__fingerprints)

    @property
    def fingerprints(self):
        return self.__fingerprints

    @property
    def ports_used(self):
        """
            Return an array of OSFPPortUsed object with the ports used to
            perform the os fingerprint. This dict might contain another dict
            embedded containing the ports_reason values.
        """
        return self.__ports_used

    def osmatch(self, min_accuracy=90):
        warnings.warn("NmapOSFingerprint.osmatch is deprecated: "
                      "use NmapOSFingerprint.osmatches", DeprecationWarning)
        os_array = []
        for _osmatch in self.__osmatches:
            if _osmatch.accuracy >= min_accuracy:
                os_array.append(_osmatch.name)
        return os_array

    def osclass(self, min_accuracy=90):
        warnings.warn("NmapOSFingerprint.osclass() is deprecated: "
                      "use NmapOSFingerprint.osclasses() if applicable",
                      DeprecationWarning)
        os_array = []
        for osmatch_entry in self.osmatches():
            if osmatch_entry.accuracy >= min_accuracy:
                for oclass in osmatch_entry.osclasses:
                    _ftstr = "type:{0}|vendor:{1}|osfamily{2}".format(
                             oclass.type,
                             oclass.vendor,
                             oclass.osfamily)
                    os_array.append(_ftstr)
        return os_array

    def __repr__(self):
        rval = ""
        for _osmatch in self.osmatches:
            rval += "\r\n{0}".format(_osmatch)
        rval += "Fingerprints: ".format(self.fingerprint)
        return rval

########NEW FILE########
__FILENAME__ = report
#!/usr/bin/env python
from libnmap.diff import NmapDiff


class NmapReport(object):
    """
        NmapReport is the usual interface for the end user to
        read scans output.

        A NmapReport as the following structure:

        - Scan headers data
        - A list of scanned hosts (NmapReport.hosts)
        - Scan footer data

        It is to note that each NmapHost comprised in NmapReport.hosts array
        contains also a list of scanned services (NmapService object).

        This means that if NmapParser.parse*() is the input interface for the
        end user of the lib. NmapReport is certainly the output interface for
        the end user of the lib.
    """
    def __init__(self, raw_data=None):
        """
            Constructor for NmapReport object.

            This is usually called by the NmapParser module.
        """
        self._nmaprun = {}
        self._scaninfo = {}
        self._hosts = []
        self._runstats = {}
        if raw_data is not None:
            self.__set_raw_data(raw_data)

    def save(self, backend):
        """
            This method gets a NmapBackendPlugin representing the backend.

            :param backend: libnmap.plugins.PluginBackend object.

            Object created by BackendPluginFactory and enabling nmap reports
            to be saved/stored in any type of backend implemented in plugins.

            The primary key of the stored object is returned.

            :return: str
        """
        if backend is not None:
            _id = backend.insert(self)
        else:
            raise RuntimeError
        return _id

    def diff(self, other):
        """
            Calls NmapDiff to check the difference between self and
            another NmapReport object.

            Will return a NmapDiff object.

            :return: NmapDiff object
            :todo: remove is_consistent approach, diff() should be generic.
        """
        if self.is_consistent() and other.is_consistent():
            _rdiff = NmapDiff(self, other)
        else:
            _rdiff = set()
        return _rdiff

    @property
    def started(self):
        """
            Accessor returning a unix timestamp of when the scan was started.

            :return: integer
        """
        rval = -1
        try:
            s_start = self._nmaprun['start']
            rval = int(s_start)
        except(KeyError, TypeError, ValueError):
            pass
        return rval

    @property
    def commandline(self):
        """
            Accessor returning the full nmap command line fired.

            :return: string
        """
        return self._nmaprun['args']

    @property
    def version(self):
        """
            Accessor returning the version of the
            nmap binary used to perform the scan.

            :return: string
        """
        return self._nmaprun['version']

    @property
    def scan_type(self):
        """
            Accessor returning a string which identifies what type of scan
            was launched (syn, ack, tcp,...).

            :return: string
        """
        return self._scaninfo['type']

    @property
    def hosts(self):
        """
            Accessor returning an array of scanned hosts.

            Scanned hosts are NmapHost objects.

            :return: array of NmapHost
        """
        return self._hosts

    def get_host_byid(self, host_id):
        """
           Gets a NmapHost object directly from the host array
           by looking it up by id.

           :param ip_addr: ip address of the host to lookup
           :type ip_addr: string

           :return: NmapHost
        """
        rval = None
        for _rhost in self._hosts:
            if _rhost.address == host_id:
                rval = _rhost
        return rval

    @property
    def endtime(self):
        """
            Accessor returning a unix timestamp of when the scan ended.

            :return: integer
        """
        rval = -1
        try:
            rval = int(self._runstats['finished']['time'])
        except(KeyError, TypeError, ValueError):
            pass
        return rval

    @property
    def endtimestr(self):
        """
            Accessor returning a human readable time string
            of when the scan ended.

            :return: string
        """
        rval = ''
        try:
            rval = self._runstats['finished']['timestr']
        except(KeyError, TypeError, ValueError):
            pass
        return rval

    @property
    def summary(self):
        """
            Accessor returning a string describing and
            summarizing the scan.

            :return: string
        """
        rval = ''
        try:
            rval = self._runstats['finished']['summary']
        except(KeyError, TypeError):
            pass

        if len(rval) == 0:
            rval = ("Nmap ended at {0} ; {1} IP addresses ({2} hosts up)"
                    " scanned in {3} seconds".format(self.endtimestr,
                                                     self.hosts_total,
                                                     self.hosts_up,
                                                     self.elapsed))
        return rval

    @property
    def elapsed(self):
        """
            Accessor returning the number of seconds the scan took

            :return: float (0 >= or -1)
        """
        rval = -1
        try:
            s_elapsed = self._runstats['finished']['elapsed']
            rval = float(s_elapsed)
        except (KeyError, TypeError, ValueError):
            rval = -1
        return rval

    @property
    def hosts_up(self):
        """
            Accessor returning the numer of host detected
            as 'up' during the scan.

            :return: integer (0 >= or -1)
        """
        rval = -1
        try:
            s_up = self._runstats['hosts']['up']
            rval = int(s_up)
        except (KeyError, TypeError, ValueError):
            rval = -1
        return rval

    @property
    def hosts_down(self):
        """
            Accessor returning the numer of host detected
            as 'down' during the scan.

            :return: integer (0 >= or -1)
        """
        rval = -1
        try:
            s_down = self._runstats['hosts']['down']
            rval = int(s_down)
        except (KeyError, TypeError, ValueError):
            rval = -1
        return rval

    @property
    def hosts_total(self):
        """
            Accessor returning the number of hosts scanned in total.

            :return: integer (0 >= or -1)
        """
        rval = -1
        try:
            s_total = self._runstats['hosts']['total']
            rval = int(s_total)
        except (KeyError, TypeError, ValueError):
            rval = -1
        return rval

    def get_raw_data(self):
        """
            Returns a dict representing the NmapReport object.

            :return: dict
            :todo: deprecate. get rid of this uglyness.
        """
        raw_data = {'_nmaprun': self._nmaprun,
                    '_scaninfo': self._scaninfo,
                    '_hosts': self._hosts,
                    '_runstats': self._runstats}
        return raw_data

    def __set_raw_data(self, raw_data):
        self._nmaprun = raw_data['_nmaprun']
        self._scaninfo = raw_data['_scaninfo']
        self._hosts = raw_data['_hosts']
        self._runstats = raw_data['_runstats']

    def is_consistent(self):
        """
            Checks if the report is consistent and can be diffed().

            This needs to be rewritten and removed: diff() should be generic.

            :return: boolean
        """
        rval = False
        rdata = self.get_raw_data()
        _consistent_keys = ['_nmaprun', '_scaninfo', '_hosts', '_runstats']
        if(set(_consistent_keys) == set(rdata.keys()) and
           len([dky for dky in rdata.keys() if rdata[dky] is not None]) == 4):
            rval = True
        return rval

    def get_dict(self):
        """
            Return a python dict representation of the NmapReport object.
            This is used to diff() NmapReport objects via NmapDiff.

            :return: dict
        """
        rdict = dict([("%s::%s" % (_host.__class__.__name__,
                                   str(_host.id)),
                      hash(_host))
                     for _host in self.hosts])
        rdict.update({'commandline': self.commandline,
                      'version': self.version,
                      'scan_type': self.scan_type,
                      'elapsed': self.elapsed,
                      'hosts_up': self.hosts_up,
                      'hosts_down': self.hosts_down,
                      'hosts_total': self.hosts_total})
        return rdict

    @property
    def id(self):
        """
            Dummy id() defined for reports.
        """
        return hash(1)

    def __eq__(self, other):
        """
            Compare eq NmapReport based on :

                - create a diff obj and check the result
                report are equal if added&changed&removed are empty

            :return: boolean
        """
        rval = False
        if(self.__class__ == other.__class__ and self.id == other.id):
            diffobj = self.diff(other)
            rval = (len(diffobj.changed()) == 0 and
                    len(diffobj.added()) == 0 and
                    len(diffobj.removed()) == 0
                    )
        return rval

    def __ne__(self, other):
        """
            Compare ne NmapReport based on:

                - create a diff obj and check the result
                report are ne if added|changed|removed are not empty

            :return: boolean
        """
        rval = True
        if(self.__class__ == other.__class__ and self.id == other.id):
            diffobj = self.diff(other)
            rval = (len(diffobj.changed()) != 0 or
                    len(diffobj.added()) != 0 or
                    len(diffobj.removed()) != 0
                    )
        return rval

    def __repr__(self):
        return "{0}: started at {1} hosts up {2}/{3}".format(
               self.__class__.__name__,
               self.started,
               self.hosts_up,
               self.hosts_total)

########NEW FILE########
__FILENAME__ = service
#!/usr/bin/env python
from libnmap.diff import NmapDiff
from libnmap.objects.os import CPE


class NmapService(object):
    """
        NmapService represents a nmap scanned service. Its id() is comprised
        of the protocol and the port.

        Depending on the scanning options, some additional details might be
        available or not. Like banner or extra datas from NSE (nmap scripts).
    """
    def __init__(self, portid, protocol='tcp', state=None,
                 service=None, owner=None, service_extras=None):
        """
            Constructor

            :param portid: port number
            :type portid: string
            :param protocol: protocol of port scanned (tcp, udp)
            :type protocol: string
            :param state: python dict describing the service status
            :type state: python dict
            :param service: python dict describing the service name and banner
            :type service: python dict
            :param service_extras: additional info about the tested service
            like scripts' data
        """
        try:
            self._portid = int(portid or -1)
        except (ValueError, TypeError):
            raise
        if self._portid < 0 or self._portid > 65535:
            raise ValueError

        self._protocol = protocol
        self._state = state if state is not None else {}
        self._service = service if service is not None else {}

        self._cpelist = []
        if 'cpelist' in self._service:
            for _cpe in self._service['cpelist']:
                _cpeobj = CPE(_cpe)
                self._cpelist.append(_cpeobj)

        self._owner = ''
        if owner is not None and 'name' in owner:
            self._owner = owner['name']

        self._reason = ''
        self._reason_ip = ''
        self._reason_ttl = ''
        self._servicefp = ''
        self._tunnel = ''

        if 'reason' in self._state:
            self._reason = self._state['reason']
        if 'reason_ttl' in self._state:
            self._reason_ttl = self._state['reason_ttl']
        if 'reason_ip' in self._state:
            self._reason_ip = self._state['reason_ip']

        if 'servicefp' in self._service:
            self._servicefp = self._service['servicefp']
        if 'tunnel' in self._service:
            self._servicefp = self._service['tunnel']

        self._service_extras = []
        if service_extras is not None:
            self._service_extras = service_extras

    def __eq__(self, other):
        """
            Compares two NmapService objects to see if they are the same or
            if one of them changed.

            :param other: NmapService

            :return: boolean
        """
        rval = False
        if(self.__class__ == other.__class__ and self.id == other.id):
            rval = (self.changed(other) == 0)
        return rval

    def __ne__(self, other):
        """
            Compares two NmapService objects to see if they are different
            if one of them changed.

            :param other: NmapService

            :return: boolean
        """
        rval = True
        if(self.__class__ == other.__class__ and self.id == other.id):
            rval = (self.changed(other) > 0)
        return rval

    def __repr__(self):
        return "{0}: [{1} {2}/{3} {4} ({5})]".format(self.__class__.__name__,
                                                     self.state,
                                                     str(self.port),
                                                     self.protocol,
                                                     self.service,
                                                     self.banner)

    def __hash__(self):
        return (hash(self.port) ^ hash(self.protocol) ^ hash(self.state) ^
                hash(self.reason) ^ hash(self.service) ^ hash(self.banner))

    def changed(self, other):
        """
            Checks if a NmapService is different from another.

            :param other: NmapService

            :return: boolean
        """
        return len(self.diff(other).changed())

    @property
    def port(self):
        """
            Accessor for port.

            :return: integer or -1
        """
        return self._portid

    @property
    def protocol(self):
        """
            Accessor for protocol

            :return: string
        """
        return self._protocol

    @property
    def state(self):
        """
            Accessor for service's state (open, filtered, closed,...)

            :return: string
        """
        return self._state['state'] if 'state' in self._state else None

    @property
    def reason(self):
        """
            Accessor for service's state reason (syn-ack, filtered,...)

            :return: string or empty if not applicable
        """
        return self._reason

    @property
    def reason_ip(self):
        """
            Accessor for service's state reason ip

            :return: string or empty if not applicable
        """
        return self._reason_ip

    @property
    def reason_ttl(self):
        """
            Accessor for service's state reason ttl

            :return: string or empty if not applicable
        """
        return self._reason_ttl

    @property
    def service(self):
        """
            Accessor for service dictionnary.

            :return: dict or None
        """
        return self._service['name'] if 'name' in self._service else ''

    def open(self):
        """
            Tells if the port was open or not

            :return: boolean
        """
        return 'state' in self._state and self._state['state'] == 'open'

    @property
    def owner(self):
        """
            Accessor for service owner if available
        """
        return self._owner

    @property
    def banner(self):
        """
            Accessor for the service's banner. Only available
            if the nmap option -sV or similar was used.

            :return: string
        """
        notrelevant = ['name', 'method', 'conf', 'cpelist']
        b = ''
        if 'method' in self._service and self._service['method'] == "probed":
            b = " ".join([k + ": " + self._service[k]
                          for k in self._service.keys()
                              if k not in notrelevant])
        return b

    @property
    def cpelist(self):
        """
            Accessor for list of CPE for this particular service
        """
        return self._cpelist

    @property
    def scripts_results(self):
        """
            Gives a python list of the nse scripts results.

            The dict key is the name (id) of the nse script and
            the value is the output of the script.

            :return: dict
        """
        scripts_dict = None
        try:
            scripts_dict = self._service_extras['scripts']
        except (KeyError, TypeError):
            pass
        return scripts_dict

    @property
    def servicefp(self):
        """
            Accessor for the service's fingerprint
            if the nmap option -sV or -A is used

            :return: string if available
        """
        return self._servicefp

    @property
    def tunnel(self):
        """
            Accessor for the service's tunnel type
            if applicable and available from scan
            results

            :return: string if available
        """
        return self._tunnel

    @property
    def id(self):
        """
            Accessor for the id() of the NmapService.

            This is used for diff()ing NmapService object via NmapDiff.

            :return: tuple
        """
        return "{0}.{1}".format(self.protocol, self.port)

    def get_dict(self):
        """
            Return a python dict representation of the NmapService object.

            This is used to diff() NmapService objects via NmapDiff.

            :return: dict
        """
        return ({'id': str(self.id), 'port': str(self.port),
                 'protocol': self.protocol, 'banner': self.banner,
                 'service': self.service, 'state': self.state,
                 'reason': self.reason})

    def diff(self, other):
        """
            Calls NmapDiff to check the difference between self and
            another NmapService object.

            Will return a NmapDiff object.

            This objects return python set() of keys describing the elements
            which have changed, were added, removed or kept unchanged.

            :return: NmapDiff object
        """
        return NmapDiff(self, other)

########NEW FILE########
__FILENAME__ = parser
#!/usr/bin/env python
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
from libnmap.objects import NmapHost, NmapService, NmapReport


class NmapParser(object):
    @classmethod
    def parse(cls, nmap_data=None, data_type='XML', incomplete=False):
        """
            Generic class method of NmapParser class.
            The data to be parsed does not need to be a complete nmap
            scan report. You can possibly give <hosts>...</hosts>
            or <port> XML tags.

            :param nmap_data: any portion of nmap scan result.

            nmap_data should always be a string representing a part
            or a complete nmap scan report.

            :type nmap_data: string

            :param data_type: specifies the type of data to be parsed.
            :type data_type: string ("XML"|"JSON"|"YAML").

            :param incomplete: enable you to parse interrupted nmap scans
            and/or incomplete nmap xml blocks by adding a </nmaprun> at
            the end of the scan.
            :type incomplete: boolean

            As of today, only XML parsing is supported.

            :return: NmapObject (NmapHost, NmapService or NmapReport)
        """

        nmapobj = None
        if data_type == "XML":
            nmapobj = cls._parse_xml(nmap_data, incomplete)
        else:
            raise NmapParserException("Unknown data type provided. "
                                      "Please check documentation for "
                                      "supported data types.")
        return nmapobj

    @classmethod
    def _parse_xml(cls, nmap_data=None, incomplete=False):
        """
            Protected class method used to process a specific data type.
            In this case: XML. This method is called by cls.parse class
            method and receives nmap scan results data (in XML).

            :param nmap_data: any portion of nmap scan result can be given
            as argument. nmap_data should always be a string representing
            a part or a complete nmap scan report.
            :type nmap_data: string

            This method checks which portion of a nmap scan is given
            as argument.
            It could be:

                1. a full nmap scan report;
                2. a scanned host: <host> tag in a nmap scan report
                3. a scanned service: <port> tag
                4. a list of hosts: <hosts/> tag (TODO)
                5. a list of ports: <ports/> tag

            :param incomplete: enable you to parse interrupted nmap scans
            and/or incomplete nmap xml blocks by adding a </nmaprun> at
            the end of the scan.

            :type incomplete: boolean
            :return: NmapObject (NmapHost, NmapService or NmapReport)
                    or a list of NmapObject
        """

        if not nmap_data:
            raise NmapParserException("No report data to parse: please "
                                      "provide a valid XML nmap report")
        elif not isinstance(nmap_data, str):
            raise NmapParserException("wrong nmap_data type given as "
                                      "argument: cannot parse data")

        if incomplete is True:
            nmap_data += "</nmaprun>"

        try:
            root = ET.fromstring(nmap_data)
        except:
            raise NmapParserException("Wrong XML structure: cannot parse data")

        nmapobj = None
        if root.tag == 'nmaprun':
            nmapobj = cls._parse_xml_report(root)
        elif root.tag == 'host':
            nmapobj = cls._parse_xml_host(root)
        elif root.tag == 'ports':
            nmapobj = cls._parse_xml_ports(root)
        elif root.tag == 'port':
            nmapobj = cls._parse_xml_port(root)
        else:
            raise NmapParserException("Unpexpected data structure for XML "
                                      "root node")
        return nmapobj

    @classmethod
    def _parse_xml_report(cls, root=None):
        """
            This method parses out a full nmap scan report from its XML root
            node: <nmaprun>.

            :param root: Element from xml.ElementTree (top of XML the document)
            :type root: Element

            :return: NmapReport object
        """

        nmap_scan = {'_nmaprun': {}, '_scaninfo': {},
                     '_hosts': [], '_runstats': {}}

        if root is None:
            raise NmapParserException("No root node provided to parse XML "
                                      "report")

        nmap_scan['_nmaprun'] = cls.__format_attributes(root)
        for el in root:
            if el.tag == 'scaninfo':
                nmap_scan['_scaninfo'] = cls.__parse_scaninfo(el)
            elif el.tag == 'host':
                nmap_scan['_hosts'].append(cls._parse_xml_host(el))
            elif el.tag == 'runstats':
                nmap_scan['_runstats'] = cls.__parse_runstats(el)
            # else:
            #    print "struct pparse unknown attr: {0} value: {1}".format(
            #        el.tag,
            #        el.get(el.tag))
        return NmapReport(nmap_scan)

    @classmethod
    def parse_fromstring(cls, nmap_data, data_type="XML", incomplete=False):
        """
            Call generic cls.parse() method and ensure that a string is
            passed on as argument. If not, an exception is raised.

            :param nmap_data: Same as for parse(), any portion of nmap scan.

            Reports could be passed as argument. Data type _must_ be a string.

            :type nmap_data: string

            :param data_type: Specifies the type of data passed on as argument.

            :param incomplete: enable you to parse interrupted nmap scans
            and/or incomplete nmap xml blocks by adding a </nmaprun> at
            the end of the scan.
            :type incomplete: boolean

            :return: NmapObject
        """

        if not isinstance(nmap_data, str):
            raise NmapParserException("bad argument type for "
                                      "xarse_fromstring(): should be a string")
        return cls.parse(nmap_data, data_type, incomplete)

    @classmethod
    def parse_fromfile(cls, nmap_report_path,
                       data_type="XML",
                       incomplete=False):
        """
            Call generic cls.parse() method and ensure that a correct file
            path is given as argument. If not, an exception is raised.

            :param nmap_data: Same as for parse().

            Any portion of nmap scan reports could be passed as argument.

            Data type _must be a valid path to a file containing
            nmap scan results.

            :param data_type: Specifies the type of serialization in the file.

            :param incomplete: enable you to parse interrupted nmap scans
            and/or incomplete nmap xml blocks by adding a </nmaprun> at
            the end of the scan.
            :type incomplete: boolean

            :return: NmapObject
        """

        try:
            with open(nmap_report_path, 'r') as fileobj:
                fdata = fileobj.read()
                rval = cls.parse(fdata, data_type, incomplete)
        except IOError:
            raise
        return rval

    @classmethod
    def parse_fromdict(cls, rdict):
        """
            Strange method which transforms a python dict
            representation of a NmapReport and turns it into an
            NmapReport object.
            Needs to be reviewed and possibly removed.

            :param rdict: python dict representation of an NmapReport
            :type rdict: dict

            :return: NmapReport
        """

        nreport = {}
        if rdict.keys()[0] == '__NmapReport__':
            r = rdict['__NmapReport__']
            nreport['_runstats'] = r['_runstats']
            nreport['_scaninfo'] = r['_scaninfo']
            nreport['_nmaprun'] = r['_nmaprun']
            hlist = []
            for h in r['_hosts']:
                slist = []
                for s in h['__NmapHost__']['_services']:
                    cname = '__NmapService__'
                    slist.append(NmapService(portid=s[cname]['_portid'],
                                             protocol=s[cname]['_protocol'],
                                             state=s[cname]['_state'],
                                             owner=s[cname]['_owner'],
                                             service=s[cname]['_service']))

                nh = NmapHost(starttime=h['__NmapHost__']['_starttime'],
                              endtime=h['__NmapHost__']['_endtime'],
                              address=h['__NmapHost__']['_address'],
                              status=h['__NmapHost__']['_status'],
                              hostnames=h['__NmapHost__']['_hostnames'],
                              extras=h['__NmapHost__']['_extras'],
                              services=slist)
                hlist.append(nh)
            nreport['_hosts'] = hlist
            nmapobj = NmapReport(nreport)
        return nmapobj

    @classmethod
    def __parse_scaninfo(cls, scaninfo_data):
        """
            Private method parsing a portion of a nmap scan result.
            Receives a <scaninfo> XML tag.

            :param scaninfo_data: <scaninfo> XML tag from a nmap scan
            :type scaninfo_data: xml.ElementTree.Element or a string

            :return: python dict representing the XML scaninfo tag
        """

        xelement = cls.__format_element(scaninfo_data)
        return cls.__format_attributes(xelement)

    @classmethod
    def _parse_xml_host(cls, scanhost_data):
        """
            Protected method parsing a portion of a nmap scan result.
            Receives a <host> XML tag representing a scanned host with
            its services.

            :param scaninfo_data: <host> XML tag from a nmap scan
            :type scaninfo_data: xml.ElementTree.Element or a string

            :return: NmapHost object
        """

        xelement = cls.__format_element(scanhost_data)
        _host_header = cls.__format_attributes(xelement)
        _hostnames = []
        _services = []
        _status = {}
        _addresses = []
        _host_extras = {}
        extra_tags = ['uptime', 'distance', 'tcpsequence',
                      'ipidsequence', 'tcptssequence', 'times']
        for xh in xelement:
            if xh.tag == 'hostnames':
                for hostname in cls.__parse_hostnames(xh):
                    _hostnames.append(hostname)
            elif xh.tag == 'ports':
                ports_dict = cls._parse_xml_ports(xh)
                for port in ports_dict['ports']:
                    _services.append(port)
                _host_extras['extraports'] = ports_dict['extraports']
            elif xh.tag == 'status':
                _status = cls.__format_attributes(xh)
            elif xh.tag == 'address':
                _addresses.append(cls.__format_attributes(xh))
            elif xh.tag == 'os':
                _os_extra = cls.__parse_os_fingerprint(xh)
                _host_extras.update({'os': _os_extra})
            elif xh.tag == 'hostscript':
                _host_scripts = cls.__parse_host_scripts(xh)
                _host_extras.update({'hostscript': _host_scripts})
            elif xh.tag in extra_tags:
                _host_extras[xh.tag] = cls.__format_attributes(xh)
            # else:
            #    print "struct host unknown attr: %s value: %s" %
            #           (h.tag, h.get(h.tag))
        _stime = ''
        _etime = ''
        if 'starttime' in _host_header:
            _stime = _host_header['starttime']
        if 'endtime' in _host_header:
            _etime = _host_header['endtime']
        nhost = NmapHost(_stime,
                         _etime,
                         _addresses,
                         _status,
                         _hostnames,
                         _services,
                         _host_extras)
        return nhost

    @classmethod
    def __parse_hostnames(cls, scanhostnames_data):
        """
            Private method parsing the hostnames list within a <host> XML tag.

            :param scanhostnames_data: <hostnames> XML tag from a nmap scan
            :type scanhostnames_data: xml.ElementTree.Element or a string

            :return: list of hostnames
        """

        xelement = cls.__format_element(scanhostnames_data)
        hostnames = []
        for hname in xelement:
            if hname.tag == 'hostname':
                hostnames.append(hname.get('name'))
        return hostnames

    @classmethod
    def _parse_xml_ports(cls, scanports_data):
        """
            Protected method parsing the list of scanned services from
            a targeted host. This protected method cannot be called directly
            with a string. A <ports/> tag can be directly passed to parse()
            and the below method will be called and return a list of nmap
            scanned services.

            :param scanports_data: <ports> XML tag from a nmap scan
            :type scanports_data: xml.ElementTree.Element or a string

            :return: list of NmapService
        """

        xelement = cls.__format_element(scanports_data)

        rdict = {'ports': [], 'extraports': None}
        for xservice in xelement:
            if xservice.tag == 'port':
                nport = cls._parse_xml_port(xservice)
                rdict['ports'].append(nport)
            elif xservice.tag == 'extraports':
                extraports = cls.__parse_extraports(xservice)
                rdict['extraports'] = extraports
            # else:
            #    print "struct port unknown attr: %s value: %s" %
            #           (h.tag, h.get(h.tag))
        return rdict

    @classmethod
    def _parse_xml_port(cls, scanport_data):
        """
            Protected method parsing a scanned service from a targeted host.
            This protected method cannot be called directly.
            A <port/> tag can be directly passed to parse() and the below
            method will be called and return a NmapService object
            representing the state of the service.

            :param scanport_data: <port> XML tag from a nmap scan
            :type scanport_data: xml.ElementTree.Element or a string

            :return: NmapService
        """

        xelement = cls.__format_element(scanport_data)

        _port = cls.__format_attributes(xelement)
        _portid = _port['portid'] if 'portid' in _port else None
        _protocol = _port['protocol'] if 'protocol' in _port else None

        _state = None
        _service = None
        _owner = None
        _service_scripts = []
        _service_extras = {}
        for xport in xelement:
            if xport.tag == 'state':
                _state = cls.__format_attributes(xport)
            elif xport.tag == 'service':
                _service = cls.__parse_service(xport)
            elif xport.tag == 'owner':
                _owner = cls.__format_attributes(xport)
            elif xport.tag == 'script':
                _script_dict = cls.__parse_script(xport)
                _service_scripts.append(_script_dict)
        _service_extras['scripts'] = _service_scripts

        if(_portid is None or _protocol is None or _state is None):
            raise NmapParserException("XML <port> tag is incomplete. One "
                                      "of the following tags is missing: "
                                      "portid, protocol or state or tag.")

        nport = NmapService(_portid,
                            _protocol,
                            _state,
                            _service,
                            _owner,
                            _service_extras)
        return nport

    @classmethod
    def __parse_service(cls, xserv):
        """
            Parse <service> tag to manage CPE object
        """
        _service = cls.__format_attributes(xserv)
        _cpelist = []
        for _servnode in xserv:
            if _servnode.tag == 'cpe':
                _cpe_string = _servnode.text
                _cpelist.append(_cpe_string)
        _service['cpelist'] = _cpelist
        return _service

    @classmethod
    def __parse_extraports(cls, extraports_data):
        """
            Private method parsing the data from extra scanned ports.
            X extraports were in state "closed" server returned "conn-refused"
            tag: <extraports>

            :param extraports_data: XML data for extraports
            :type extraports_data: xml.ElementTree.Element or a string

            :return: python dict with following keys: state, count, reason
        """
        rdict = {'state': '', 'count': '', 'reasons': []}
        xelement = cls.__format_element(extraports_data)
        extraports_dict = cls.__format_attributes(xelement)

        if 'state' in extraports_dict:
            rdict['state'] = extraports_dict
        if 'count' in extraports_dict:
            rdict['count'] = extraports_dict
        for xelt in xelement:
            if xelt.tag == 'extrareasons':
                extrareasons_dict = cls.__format_attributes(xelt)
                rdict['reasons'].append(extrareasons_dict)
        return rdict

    @classmethod
    def __parse_script(cls, script_data):
        """
            Private method parsing the data from NSE scripts output

            :param script_data: portion of XML describing the results of the
            script data
            :type script_data: xml.ElementTree.Element or a string

            :return: python dict holding scripts output
        """
        _script_dict = cls.__format_attributes(script_data)

        _elt_dict = {}
        for script_elem in script_data:
            if script_elem.tag == 'elem':
                _elt_dict.update({script_elem.get('key'): script_elem.text})
            elif script_elem.tag == 'table':
                tdict = {}
                for telem in script_elem:
                    tdict[telem.get('key')] = telem.text
                _elt_dict[script_elem.get('key')] = tdict
        _script_dict['elements'] = _elt_dict
        return _script_dict

    @classmethod
    def __parse_host_scripts(cls, scripts_data):
        """
            Private method parsing the data from scripts affecting
            the target host.
            Contents of <hostscript> is returned as a list of dict.

            :param scripts_data: portion of XML describing the results of the
            scripts data
            :type scripts_data: xml.ElementTree.Element or a string

            :return: python list holding scripts output in a dict
        """
        _host_scripts = []
        for xscript in scripts_data:
            if xscript.tag == 'script':
                _script_dict = cls.__parse_script(xscript)
            _host_scripts.append(_script_dict)
        return _host_scripts

    @classmethod
    def __parse_os_fingerprint(cls, os_data):
        """
            Private method parsing the data from an OS fingerprint (-O).
            Contents of <os> is returned as a dict.

            :param os_data: portion of XML describing the results of the
            os fingerprinting attempt
            :type os_data: xml.ElementTree.Element or a string

            :return: python dict representing the XML os tag
        """
        rdict = {}
        xelement = cls.__format_element(os_data)

        os_class_probability = []
        os_match_probability = []
        os_ports_used = []
        os_fingerprints = []
        for xos in xelement:
            # for nmap xml version < 1.04, osclass is not
            # embedded in osmatch
            if xos.tag == 'osclass':
                os_class_proba = cls.__parse_osclass(xos)
                os_class_probability.append(os_class_proba)
            elif xos.tag == 'osmatch':
                os_match_proba = cls.__parse_osmatch(xos)
                os_match_probability.append(os_match_proba)
            elif xos.tag == 'portused':
                os_portused = cls.__format_attributes(xos)
                os_ports_used.append(os_portused)
            elif xos.tag == 'osfingerprint':
                os_fp_dict = cls.__format_attributes(xos)
                os_fingerprints.append(os_fp_dict)

        rdict['osmatches'] = os_match_probability
        rdict['osclasses'] = os_class_probability
        rdict['ports_used'] = os_ports_used
        rdict['osfingerprints'] = os_fingerprints

        return rdict

    @classmethod
    def __parse_osmatch(cls, osmatch_data):
        """
            This methods parses osmatch data and returns a dict. Depending
            on the nmap xml version, osmatch could contain an osclass
            dict.

            :param osmatch_data: <osmatch> XML tag from a nmap scan
            :type osmatch_data: xml.ElementTree.Element or a string

            :return: python dict representing the XML osmatch tag
        """
        rdict = {}
        xelement = cls.__format_element(osmatch_data)
        rdict['osmatch'] = cls.__format_attributes(xelement)
        rdict['osclasses'] = []
        for xmltag in xelement:
            if xmltag.tag == 'osclass':
                _osclass_dict = cls.__parse_osclass(xmltag)
                rdict['osclasses'].append(_osclass_dict)
            else:
                exmsg = "Unexcepted node in <osmatch>: {0}".format(xmltag.tag)
                raise NmapParserException(exmsg)
        return rdict

    @classmethod
    def __parse_osclass(cls, osclass_data):
        """
            This methods parses osclass data and returns a dict. Depending
            on the nmap xml version, osclass could contain a cpe
            dict.

            :param osclass_data: <osclass> XML tag from a nmap scan
            :type osclass_data: xml.ElementTree.Element or a string

            :return: python dict representing the XML osclass tag
        """
        rdict = {}
        xelement = cls.__format_element(osclass_data)
        rdict['osclass'] = cls.__format_attributes(xelement)
        rdict['cpe'] = []
        for xmltag in xelement:
            if xmltag.tag == 'cpe':
                _cpe_string = xmltag.text
                rdict['cpe'].append(_cpe_string)
            else:
                exmsg = "Unexcepted node in <osclass>: {0}".format(xmltag.tag)
                raise NmapParserException(exmsg)
        return rdict

    @classmethod
    def __parse_runstats(cls, scanrunstats_data):
        """
            Private method parsing a portion of a nmap scan result.
            Receives a <runstats> XML tag.

            :param scanrunstats_data: <runstats> XML tag from a nmap scan
            :type scanrunstats_data: xml.ElementTree.Element or a string

            :return: python dict representing the XML runstats tag
        """

        xelement = cls.__format_element(scanrunstats_data)

        rdict = {}
        for xmltag in xelement:
            if xmltag.tag in ['finished', 'hosts']:
                rdict[xmltag.tag] = cls.__format_attributes(xmltag)
            else:
                exmsg = "Unexcepted node in <runstats>: {0}".format(xmltag.tag)
                raise NmapParserException(exmsg)

        return rdict

    @staticmethod
    def __format_element(elt_data):
        """
            Private method which ensures that a XML portion to be parsed is
            of type xml.etree.ElementTree.Element.
            If elt_data is a string, then it is converted to an
            XML Element type.

            :param elt_data: XML Element to be parsed or string
            to be converted to a XML Element

            :return: Element
        """
        if isinstance(elt_data, str):
            try:
                xelement = ET.fromstring(elt_data)
            except:
                raise NmapParserException("Error while trying "
                                          "to instanciate XML Element from "
                                          "string {0}".format(elt_data))
        elif ET.iselement(elt_data):
            xelement = elt_data
        else:
            raise NmapParserException("Error while trying to parse supplied "
                                      "data: unsupported format")
        return xelement

    @staticmethod
    def __format_attributes(elt_data):
        """
            Private method which converts a single XML tag to a python dict.
            It also checks that the elt_data given as argument is of type
            xml.etree.ElementTree.Element

            :param elt_data: XML Element to be parsed or string
            to be converted to a XML Element

            :return: Element
        """

        rval = {}
        if not ET.iselement(elt_data):
            raise NmapParserException("Error while trying to parse supplied "
                                      "data attributes: format is not XML or "
                                      "XML tag is empty")
        try:
            for dkey in elt_data.keys():
                rval[dkey] = elt_data.get(dkey)
                if rval[dkey] is None:
                    raise NmapParserException("Error while trying to build-up "
                                              "element attributes: empty "
                                              "attribute {0}".format(dkey))
        except:
            raise
        return rval


class NmapParserException(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

########NEW FILE########
__FILENAME__ = backendplugin
#!/usr/bin/env python


class NmapBackendPlugin(object):
    """
        Abstract class showing to the minimal implementation for a plugin
        All subclass MUST at least implement the following methods
    """
    def __init__(self):
        self.dbname = 'nmapdb'
        self.store = 'reports'

    def insert(self, NmapReport):
        """
            insert NmapReport in the backend
            :param NmapReport:
            :return: str the ident of the object in the backend for
            future usage
            or None
        """
        raise NotImplementedError

    def delete(self, id):
        """
            delete NmapReport if the backend
            :param id: str
        """
        raise NotImplementedError

    def get(self, id):
        """
            retreive a NmapReport from the backend
            :param id: str
            :return: NmapReport
        """
        raise NotImplementedError

    def getall(self, filter):
        """
            :return: collection of tuple (id,NmapReport)
            :param filter: Nice to have implement a filter capability
        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = backendpluginFactory
#!/usr/bin/env python
import sys
import inspect


class BackendPluginFactory(object):
    """
        This is a backend plugin factory a backend instance MUST be
        created via the static method create()
        ie : mybackend = BackendPluginFactory.create()
    """
    @classmethod
    def create(cls, plugin_name="mongodb", **kwargs):
        """Import the needed lib and return an object NmapBackendPlugin
           representing the backend of your desire.
           NmapBackendPlugin is an abstract class, to know what argument
           need to be given, review the code of the subclass you need
           :param plugin_name: str : name of the py file without .py
           :return: NmapBackend (abstract class on top of all plugin)
        """
        backendplugin = None
        plugin_path = "libnmap.plugins.%s" % (plugin_name)
        __import__(plugin_path)
        pluginobj = sys.modules[plugin_path]
        pluginclasses = inspect.getmembers(pluginobj, inspect.isclass)
        for classname, classobj in pluginclasses:
            if inspect.getmodule(classobj).__name__.find(plugin_path) == 0:
                try:
                    backendplugin = classobj(**kwargs)
                except Exception as error:
                    print "Cannot create Backend: %s" % (error)
        return backendplugin

########NEW FILE########
__FILENAME__ = mongodb
#!/usr/bin/env python
import json
from pymongo import MongoClient
from bson.objectid import ObjectId

from libnmap.reportjson import ReportEncoder
from libnmap.parser import NmapParser
from libnmap.plugins.backendplugin import NmapBackendPlugin


class NmapMongodbPlugin(NmapBackendPlugin):
    """
        This class handle the persistence of NmapRepport object in mongodb
        Implementation is made using pymongo
        Object of this class must be create via the
        BackendPluginFactory.create(**url) where url is a named dict like
        {'plugin_name': "mongodb"} this dict may reeive all the param
        MongoClient() support
    """
    def __init__(self, dbname=None, store=None, **kwargs):
        NmapBackendPlugin.__init__(self)
        if dbname is not None:
            self.dbname = dbname
        if store is not None:
            self.store = store
        self.dbclient = MongoClient(**kwargs)
        self.collection = self.dbclient[self.dbname][self.store]

    def insert(self, report):
        """
            create a json object from an NmapReport instance
            :param NmapReport: obj to insert
            :return: str id
        """
        j = json.dumps(report, cls=ReportEncoder)
        try:
            oid = self.collection.insert(json.loads(j))
        except:
            print "MONGODB cannot insert"
            raise
        return str(oid)

    def get(self, str_report_id=None):
        """ select a NmapReport by Id
            :param str: id
            :return: NmapReport object
        """
        rid = str_report_id
        nmapreport = None
        if str_report_id is not None and isinstance(str_report_id, str):
            rid = ObjectId(str_report_id)

        if isinstance(rid, ObjectId):
            # get a specific report by mongo's id
            resultset = self.collection.find({'_id': rid})
            if resultset.count() == 1:
                # search by id means only one in the iterator
                record = resultset[0]
                # remove mongo's id to recreate the NmapReport Obj
                del record['_id']
                nmapreport = NmapParser.parse_fromdict(record)
        return nmapreport

    def getall(self, dict_filter=None):
        """return a list of tuple (id,NmapReport) saved in the backend
           TODO : add a filter capability
        """
        nmapreportlist = []
        resultset = self.collection.find()
        for report in resultset:
            oid = report['_id']
            del report['_id']
            nmapreport = NmapParser.parse_fromdict(report)
            nmapreportlist.append((oid, nmapreport))
        return nmapreportlist

    def delete(self, report_id=None):
        """
            delete an obj from the backend
            :param str: id
            :return: dict document with result or None
        """
        if report_id is not None and isinstance(report_id, str):
            return self.collection.remove({'_id': ObjectId(report_id)})
        else:
            return self.collection.remove({'_id': report_id})

########NEW FILE########
__FILENAME__ = s3
#!/usr/bin/env python
"""
:mod:`libnmap.plugin.s3` -- S3 Backend Plugin
===================================

.. module:: libnmap.plugin.s3
:platform: Linux
:synopsis: a plugin is representation of a S3 backend using boto
.. moduleauthor:: Ronald Bister
.. moduleauthor:: Mike Boutillier
"""
import json
from bson.objectid import ObjectId
from boto.s3.connection import S3Connection, OrdinaryCallingFormat
from boto.s3.key import Key
from boto.s3.bucketlistresultset import bucket_lister
from boto.exception import S3ResponseError
from libnmap.reportjson import ReportEncoder
from libnmap.parser import NmapParser
from libnmap.plugins.backendplugin import NmapBackendPlugin


class NmapS3Plugin(NmapBackendPlugin):
    """
        This plugin save the reports on S3 and compatible.
    """
    def __init__(self, **kwargs):
        """
            - create the conn object
            - create the bucket (if it doesn't exist)
                - if not given, awsaccessKey_nmapreport
            - may raise exception (ie in case of conflict bucket name)
            - sample :
            To connect to walrus:
            from libnmap.plugins.backendpluginFactory import
                            BackendPluginFactory
            walrusBackend =
              BackendPluginFactory.create(
                    plugin_name='s3',
                    host="walrus.ecc.eucalyptus.com",
                    path="/services/Walrus",port=8773,
                    is_secure=False,
                    aws_access_key_id='UU72FLVJCAYRATLXI70YH',
                    aws_secret_access_key=
                               'wFg7gP5YFHjVlxakw1g1uCC8UR2xVW5ax9ErZCut')
           To connect to S3:
           mybackend_S3 =
             BackendPluginFactory.create(
                plugin_name='s3',
                is_secure=True,
                aws_access_key_id='MYACCESSKEY',
                aws_secret_access_key='MYSECRET')
        """
        NmapBackendPlugin.__init__(self)
        try:
            calling_format = OrdinaryCallingFormat()
            if 'bucket' not in kwargs:
                self.bucket_name = ''.join(
                    [kwargs['aws_access_key_id'].lower(),
                     "_nmapreport"])
            else:
                self.bucket_name = kwargs['bucket']
                del kwargs['bucket']
            kwargs['calling_format'] = calling_format
            self.conn = S3Connection(**kwargs)
            self.bucket = self.conn.lookup(self.bucket_name)
            if self.bucket is None:
                self.bucket = self.conn.create_bucket(self.bucket_name)
        except:
            raise

    def insert(self, report):
        """
            create a json string from an NmapReport instance
            and push it to S3 bucket.

            :param NmapReport: obj to insert
            :rtype: string
            :return: str id
            :todo: Add tagging option
        """
        try:
            oid = ObjectId()
            mykey = Key(self.bucket)
            mykey.key = str(oid)
            strjsonnmapreport = json.dumps(report, cls=ReportEncoder)
            mykey.set_contents_from_string(strjsonnmapreport)
        except:
            print "Bucket cannot insert"
            raise
        return str(oid)

    def get(self, str_report_id=None):
        """
            select a NmapReport by Id.

            :param str: id
            :rtype: NmapReport
            :return: NmapReport object
        """
        nmapreport = None
        if str_report_id is not None and isinstance(str_report_id, str):
            try:
                mykey = Key(self.bucket)
                mykey.key = str_report_id
                nmapreportjson = json.loads(mykey.get_contents_as_string())
                nmapreport = NmapParser.parse_fromdict(nmapreportjson)
            except S3ResponseError:
                print "Not Found"
        return nmapreport

    def getall(self, dict_filter=None):
        """
            :rtype: List of tuple
            :return: list of key/report
            :todo: add a filter capability
        """
        nmapreportlist = []
        for key in bucket_lister(self.bucket):
            if isinstance(key, Key):
                nmapreportjson = json.loads(key.get_contents_as_string())
                nmapreport = NmapParser.parse_fromdict(nmapreportjson)
                nmapreportlist.append((key.key, nmapreport))
        return nmapreportlist

    def delete(self, report_id=None):
        """
            delete an obj from the backend

            :param str: id
            :return: dict document with result or None
        """
        rcode = None
        if report_id is not None and isinstance(report_id, str):
            rcode = self.bucket.delete_key(report_id)
        return rcode

########NEW FILE########
__FILENAME__ = sql
#!/usr/bin/env python
from sqlalchemy import create_engine
from sqlalchemy.schema import Column
from sqlalchemy.types import Integer, DateTime, LargeBinary
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from libnmap.plugins.backendplugin import NmapBackendPlugin
from libnmap.reportjson import ReportEncoder, ReportDecoder

import json
from datetime import datetime

Base = declarative_base()


class NmapSqlPlugin(NmapBackendPlugin):
    """
        This class handle the persistence of NmapRepport object in SQL backend
        Implementation is made using sqlalchemy(0.8.1)
        usage :

        #get a nmapReport object
        from libnmap.parser import NmapParser
        from libnmap.reportjson import ReportDecoder, ReportEncoder
        import json
        nmap_report_obj = NmapParser.parse_fromfile(
               '/home/vagrant/python-nmap-lib/libnmap/test/files/1_hosts.xml')

         #get a backend with in memory sqlite
         from libnmap.plugins.backendpluginFactory import BackendPluginFactory
         mybackend_mem = BackendPluginFactory.create(plugin_name='sql',
                                                     url='sqlite://',
                                                     echo=True)

         mybackend_mysql = BackendPluginFactory.create(plugin_name='sql',
                            url='mysql+mysqldb://scott:tiger@localhost/foo',
                            echo=True)
         mybackend = BackendPluginFactory.create(plugin_name='sql',
                                        url='sqlite:////tmp/reportdb.sql',
                                        echo=True)
         #lets save!!
         nmap_report_obj.save(mybackend)
         mybackend.getall()
         mybackend.get(1)
    """
    class Reports(Base):
        """
            Embeded class for ORM map NmapReport to a
            simple three column table
        """
        __tablename__ = 'reports'

        id = Column('report_id', Integer, primary_key=True)
        inserted = Column('inserted', DateTime(), default='now')
        report_json = Column('report_json', LargeBinary)

        def __init__(self, obj_NmapReport):
            self.inserted = datetime.fromtimestamp(obj_NmapReport.endtime)
            self.report_json = json.dumps(obj_NmapReport,
                                          cls=ReportEncoder)

        def decode(self):
            nmap_report_obj = json.loads(self.report_json,
                                         cls=ReportDecoder)
            return nmap_report_obj

    def __init__(self, **kwargs):
        """
            constructor receive a **kwargs as the **kwargs in the sqlalchemy
            create_engine() method (see sqlalchemy docs)
            You must add to this **kwargs an 'url' key with the url to your
            database
            This constructor will :
            - create all the necessary obj to discuss with the DB
            - create all the mapping(ORM)

            todo : suport the : sqlalchemy.engine_from_config

            :param **kwargs:
            :raises: ValueError if no url is given,
                    all exception sqlalchemy can throw
            ie sqlite in memory url='sqlite://' echo=True
            ie sqlite file on hd url='sqlite:////tmp/reportdb.sql' echo=True
            ie mysql url='mysql+mysqldb://scott:tiger@localhost/foo'
        """
        NmapBackendPlugin.__init__(self)
        self.engine = None
        self.url = None
        self.Session = sessionmaker()

        if 'url' not in kwargs:
            raise ValueError
        self.url = kwargs['url']
        del kwargs['url']
        try:
            self.engine = create_engine(self.url, **kwargs)
            Base.metadata.create_all(bind=self.engine, checkfirst=True)
            self.Session.configure(bind=self.engine)
        except:
            raise

    def insert(self, nmap_report):
        """
           insert NmapReport in the backend
           :param NmapReport:
           :return: the ident of the object in the backend for future usage
           or None
        """
        sess = self.Session()
        report = NmapSqlPlugin.Reports(nmap_report)
        sess.add(report)
        sess.commit()
        reportid = report.id
        sess.close()
        return reportid if reportid else None

    def get(self, report_id=None):
        """
            retreive a NmapReport from the backend
            :param id: str
            :return: NmapReport
        """
        if report_id is None:
            raise ValueError
        sess = self.Session()
        our_report = (
            sess.query(NmapSqlPlugin.Reports).filter_by(id=report_id).first())
        sess.close()
        return our_report.decode() if our_report else None

    def getall(self):
        """
            :return: collection of tuple (id,NmapReport)
            :param filter: Nice to have implement a filter capability
        """
        sess = self.Session()
        nmapreportList = []
        for report in (
                sess.query(NmapSqlPlugin.Reports).
                order_by(NmapSqlPlugin.Reports.inserted)):
            nmapreportList.append((report.id, report.decode()))
        sess.close()
        return nmapreportList

    def delete(self, report_id=None):
        """
            Remove a report from the backend
            :param id: str
            :return: The number of rows deleted
        """
        if report_id is None:
            raise ValueError
        nb_line = 0
        sess = self.Session()
        nb_line = sess.query(NmapSqlPlugin.Reports).\
            filter_by(id=report_id).delete()
        sess.commit()
        sess.close()
        return nb_line

########NEW FILE########
__FILENAME__ = process
#!/usr/bin/env python
import os
import pwd
import shlex
import subprocess
import multiprocessing
from threading import Thread
from xml.dom import pulldom
import warnings
try:
    from Queue import Empty, Full
except ImportError:
    from queue import Empty, Full

__all__ = [
    'NmapProcess'
]


class NmapTask(object):
    """
    NmapTask is a internal class used by process. Each time nmap
    starts a new task during the scan, a new class will be instanciated.
    Classes examples are: "Ping Scan", "NSE script", "DNS Resolve",..
    To each class an estimated time to complete is assigned and updated
    at least every second within the NmapProcess.
    A property NmapProcess.current_task points to the running task at
    time T and a dictionnary NmapProcess.tasks with "task name" as key
    is built during scan execution
    """
    def __init__(self, name, starttime=0, extrainfo=''):
        self.name = name
        self.etc = 0
        self.progress = 0
        self.percent = 0
        self.remaining = 0
        self.status = 'started'
        self.starttime = starttime
        self.endtime = 0
        self.extrainfo = extrainfo
        self.updated = 0


class NmapProcess(Thread):
    """
    NmapProcess is a class which wraps around the nmap executable.
    Consequently, in order to run an NmapProcess, nmap should be installed
    on the host running the script. By default NmapProcess will produce
    the output of the nmap scan in the nmap XML format. This could be then
    parsed out via the NmapParser class from libnmap.parser module.
    """
    def __init__(self, targets="127.0.0.1",
                 options="-sT", event_callback=None, safe_mode=True, fqp=None):
        """
        Constructor of NmapProcess class.

        :param targets: hosts to be scanned. Could be a string of hosts
        separated with a coma or a python list of hosts/ip.
        :type targets: string or list

        :param options: list of nmap options to be applied to scan.
        These options are all documented in nmap's man pages.

        :param event_callback: callable function which will be ran
        each time nmap process outputs data. This function will receive
        two parameters:
            1. the nmap process object
            2. the data produced by nmap process. See readme for examples.

        :param safe_mode: parameter to protect unsafe options like -oN, -oG,
        -iL, -oA,...

        :param fqp: full qualified path, if None, nmap will be searched
        in the PATH

        :return: NmapProcess object

        """
        Thread.__init__(self)
        unsafe_opts = set(['-oG', '-oN', '-iL', '-oA', '-oS', '-oX',
                           '--iflist', '--resume', '--stylesheet',
                           '--datadir'])
        if fqp:
            if os.path.isfile(fqp) and os.access(fqp, os.X_OK):
                self.__nmap_binary = fqp
            else:
                raise EnvironmentError(1, "wrong path or not executable", fqp)
        else:
            nmap_binary_name = "nmap"
            self.__nmap_binary = self._whereis(nmap_binary_name)
        self.__nmap_fixed_options = "-oX - -vvv --stats-every 1s"

        if self.__nmap_binary is None:
            raise EnvironmentError(1, "nmap is not installed or could "
                                      "not be found in system path")

        if isinstance(targets, str):
            self.__nmap_targets = targets.replace(" ", "").split(',')
        elif isinstance(targets, list):
            self.__nmap_targets = targets
        else:
            raise Exception("Supplied target list should be either a "
                            "string or a list")

        self._nmap_options = set(options.split())
        if safe_mode and not self._nmap_options.isdisjoint(unsafe_opts):
            raise Exception("unsafe options activated while safe_mode "
                            "is set True")
        self.__nmap_dynamic_options = options
        self.__sudo_run = ''
        self.__nmap_command_line = self.get_command_line()

        if event_callback and callable(event_callback):
            self.__nmap_event_callback = event_callback
        else:
            self.__nmap_event_callback = None
        (self.DONE, self.READY, self.RUNNING,
         self.CANCELLED, self.FAILED) = range(5)
        self._run_init()

    def _run_init(self):
        self.__process_killed = multiprocessing.Event()
        self.__nmap_command_line = self.get_command_line()
        # API usable in callback function
        self.__nmap_proc = None
        self.__qout = None
        self.__nmap_rc = 0
        self.__state = self.RUNNING
        self.__starttime = 0
        self.__endtime = 0
        self.__version = ''
        self.__elapsed = ''
        self.__summary = ''
        self.__stdout = ''
        self.__stderr = ''
        self.__current_task = ''
        self.__nmap_tasks = {}

    def _whereis(self, program):
        """
        Protected method enabling the object to find the full path of a binary
        from its PATH environment variable.

        :param program: name of a binary for which the full path needs to
        be discovered.

        :return: the full path to the binary.

        :todo: add a default path list in case PATH is empty.
        """
        for path in os.environ.get('PATH', '').split(':'):
            if (os.path.exists(os.path.join(path, program)) and not
               os.path.isdir(os.path.join(path, program))):
                return os.path.join(path, program)
        return None

    def get_command_line(self):
        """
        Public method returning the reconstructed command line ran via the lib

        :return: the full nmap command line to run
        :rtype: string
        """
        return ("{0} {1} {2} {3} {4}".format(self.__sudo_run,
                                             self.__nmap_binary,
                                             self.__nmap_fixed_options,
                                             self.__nmap_dynamic_options,
                                             " ".join(self.__nmap_targets)))

    def sudo_run(self, run_as='root'):
        """
        Public method enabling the library's user to run the scan with
        priviledges via sudo. The sudo configuration should be set manually
        on the local system otherwise sudo will prompt for a password.
        This method alters the command line by prefixing the sudo command to
        nmap and will then call self.run()

        :param run_as: user name to which the lib needs to sudo to run the scan

        :return: return code from nmap execution
        """
        sudo_user = run_as.split().pop()
        try:
            pwd.getpwnam(sudo_user).pw_uid
        except KeyError:
            _exmsg = ("Username {0} does not exists. Please supply"
                      " a valid username".format(run_as))
            raise EnvironmentError(_exmsg)

        sudo_path = self._whereis("sudo")
        if sudo_path is None:
            raise EnvironmentError(2, "sudo is not installed or "
                                      "could not be found in system path: "
                                      "cannot run nmap with sudo")

        self.__sudo_run = "{0} -u {1}".format(sudo_path, sudo_user)
        rc = self.run()
        self.__sudo_run = ""

        return rc

    def sudo_run_background(self, run_as='root'):
        """
        Public method enabling the library's user to run in background a
        nmap scan with priviledges via sudo.
        The sudo configuration should be set manually on the local system
        otherwise sudo will prompt for a password.
        This method alters the command line by prefixing the sudo command to
        nmap and will then call self.run()

        :param run_as: user name to which the lib needs to sudo to run the scan

        :return: return code from nmap execution
        """
        sudo_user = run_as.split().pop()
        try:
            pwd.getpwnam(sudo_user).pw_uid
        except KeyError:
            _exmsg = ("Username {0} does not exists. Please supply"
                      " a valid username".format(run_as))
            raise EnvironmentError(_exmsg)

        sudo_path = self._whereis("sudo")
        if sudo_path is None:
            raise EnvironmentError(2, "sudo is not installed or "
                                      "could not be found in system path: "
                                      "cannot run nmap with sudo")

        self.__sudo_run = "{0} -u {1}".format(sudo_path, sudo_user)
        super(NmapProcess, self).start()

    def run(self):
        """
        Public method which is usually called right after the constructor
        of NmapProcess. This method starts the nmap executable's subprocess.
        It will also bind a Process that will read from subprocess' stdout
        and stderr and push the lines read in a python queue for futher
        processing. This processing is waken-up each time data is pushed
        from the nmap binary into the stdout reading routine. Processing
        could be performed by a user-provided callback. The whole
        NmapProcess object could be accessible asynchroneously.

        return: return code from nmap execution
        """
        def ioreader_routine(proc_stdout, io_queue, data_pushed, producing):
            """
            local function that will read lines from a file descriptor
            and put the data in a python queue for futher processing.

            :param proc_stdout: file descriptor to read lines from.
            :param io_queue: queue in which read lines will be pushed.
            :param data_pushed: queue used to push data read from the
            nmap stdout back into the parent process
            :param producing: shared variable to notify the parent process
            that processing is either running, either over.
            """
            producing.value = 1
            for streamline in iter(proc_stdout.readline, b''):
                if self.__process_killed.is_set():
                    break
                if streamline is not None:
                    try:
                        io_queue.put(streamline)
                    except Full:
                        pass
                    data_pushed.set()
            producing.value = 0
            data_pushed.set()

        self._run_init()
        producing = multiprocessing.Value('i', 1)
        data_pushed = multiprocessing.Event()
        self.__qout = multiprocessing.Queue()

        _tmp_cmdline = shlex.split(self.__nmap_command_line)
        try:
            self.__nmap_proc = subprocess.Popen(args=_tmp_cmdline,
                                                stdout=subprocess.PIPE,
                                                stderr=subprocess.PIPE,
                                                bufsize=0)
            ioreader = multiprocessing.Process(target=ioreader_routine,
                                               args=(self.__nmap_proc.stdout,
                                                     self.__qout,
                                                     data_pushed,
                                                     producing))
            ioreader.start()
            self.__state = self.RUNNING
        except OSError:
            self.__state = self.FAILED
            raise EnvironmentError(1, "nmap is not installed or could "
                                      "not be found in system path")

        thread_stream = ''
        while(self.__nmap_proc.poll() is None or producing.value == 1):
            if self.__process_killed.is_set():
                break
            if producing.value == 1 and self.__qout.empty():
                try:
                    data_pushed.wait()
                except KeyboardInterrupt:
                    break
            try:
                thread_stream = self.__qout.get_nowait()
            except Empty:
                pass
            except KeyboardInterrupt:
                break
            else:
                self.__stdout += thread_stream
                evnt = self.__process_event(thread_stream)
                if self.__nmap_event_callback and evnt:
                    self.__nmap_event_callback(self)
            data_pushed.clear()
        ioreader.join()
        # queue clean-up
        while not self.__qout.empty():
            self.__stdout += self.__qout.get_nowait()
        self.__stderr += self.__nmap_proc.stderr.read()

        self.__nmap_rc = self.__nmap_proc.poll()
        if self.rc is None:
            self.__state = self.CANCELLED
        elif self.rc == 0:
            self.__state = self.DONE
            if self.current_task:
                self.__nmap_tasks[self.current_task.name].progress = 100
        else:
            self.__state = self.FAILED
        return self.rc

    def run_background(self):
        """
        run nmap scan in background as a thread.
        For privileged scans, consider NmapProcess.sudo_run_background()
        """
        self.__state = self.RUNNING
        super(NmapProcess, self).start()

    def is_running(self):
        """
        Checks if nmap is still running.

        :return: True if nmap is still running
        """
        return self.state == self.RUNNING

    def has_terminated(self):
        """
        Checks if nmap has terminated. Could have failed or succeeded

        :return: True if nmap process is not running anymore.
        """
        return (self.state == self.DONE or self.state == self.FAILED
                or self.state == self.CANCELLED)

    def has_failed(self):
        """
        Checks if nmap has failed.

        :return: True if nmap process errored.
        """
        return self.state == self.FAILED

    def is_successful(self):
        """
        Checks if nmap terminated successfully.

        :return: True if nmap terminated successfully.
        """
        return self.state == self.DONE

    def stop(self):
        """
        Send KILL -15 to the nmap subprocess and gently ask the threads to
        stop.
        """
        self.__state = self.CANCELLED
        if self.__nmap_proc.poll() is None:
            self.__nmap_proc.kill()
        self.__qout.cancel_join_thread()
        self.__process_killed.set()

    def __process_event(self, eventdata):
        """
        Private method called while nmap process is running. It enables the
        library to handle specific data/events produced by nmap process.
        So far, the following events are supported:

        1. task progress: updates estimated time to completion and percentage
           done while scan is running. Could be used in combination with a
           callback function which could then handle this data while scan is
           running.
        2. nmap run: header of the scan. Usually displayed when nmap is started
        3. finished: when nmap scan ends.

        :return: True is event is known.

        :todo: handle parsing directly via NmapParser.parse()
        """
        rval = False
        try:
            edomdoc = pulldom.parseString(eventdata)
            for xlmnt, xmlnode in edomdoc:
                if xlmnt is not None and xlmnt == pulldom.START_ELEMENT:
                    if (xmlnode.nodeName == 'taskbegin' and
                            xmlnode.attributes.keys()):
                        xt = xmlnode.attributes
                        taskname = xt['task'].value
                        starttime = xt['time'].value
                        xinfo = ''
                        if 'extrainfo' in xt.keys():
                            xinfo = xt['extrainfo'].value
                        newtask = NmapTask(taskname, starttime, xinfo)
                        self.__nmap_tasks[newtask.name] = newtask
                        self.__current_task = newtask.name
                        rval = True
                    elif (xmlnode.nodeName == 'taskend' and
                            xmlnode.attributes.keys()):
                        xt = xmlnode.attributes
                        tname = xt['task'].value
                        xinfo = ''
                        self.__nmap_tasks[tname].endtime = xt['time'].value
                        if 'extrainfo' in xt.keys():
                            xinfo = xt['extrainfo'].value
                        self.__nmap_tasks[tname].extrainfo = xinfo
                        self.__nmap_tasks[tname].status = "ended"
                        rval = True
                    elif (xmlnode.nodeName == 'taskprogress' and
                            xmlnode.attributes.keys()):
                        xt = xmlnode.attributes
                        tname = xt['task'].value
                        percent = xt['percent'].value
                        etc = xt['etc'].value
                        remaining = xt['remaining'].value
                        updated = xt['time'].value
                        self.__nmap_tasks[tname].percent = percent
                        self.__nmap_tasks[tname].progress = percent
                        self.__nmap_tasks[tname].etc = etc
                        self.__nmap_tasks[tname].remaining = remaining
                        self.__nmap_tasks[tname].updated = updated
                        rval = True
                    elif (xmlnode.nodeName == 'nmaprun' and
                            xmlnode.attributes.keys()):
                        self.__starttime = xmlnode.attributes['start'].value
                        self.__version = xmlnode.attributes['version'].value
                        rval = True
                    elif (xmlnode.nodeName == 'finished' and
                            xmlnode.attributes.keys()):
                        self.__endtime = xmlnode.attributes['time'].value
                        self.__elapsed = xmlnode.attributes['elapsed'].value
                        self.__summary = xmlnode.attributes['summary'].value
                        rval = True
        except:
            pass
        return rval

    @property
    def command(self):
        """
        return the constructed nmap command or empty string if not
        constructed yet.

        :return: string
        """
        return self.__nmap_command_line or ''

    @property
    def targets(self):
        """
        Provides the list of targets to scan

        :return: list of string
        """
        return self.__nmap_targets

    @property
    def options(self):
        """
        Provides the list of options for that scan

        :return: list of string (nmap options)
        """
        return self._nmap_options

    @property
    def state(self):
        """
        Accessor for nmap execution state. Possible states are:

        - self.READY
        - self.RUNNING
        - self.FAILED
        - self.CANCELLED
        - self.DONE

        :return: integer (from above documented enum)
        """
        return self.__state

    @property
    def starttime(self):
        """
        Accessor for time when scan started

        :return: string. Unix timestamp
        """
        return self.__starttime

    @property
    def endtime(self):
        """
        Accessor for time when scan ended

        :return: string. Unix timestamp
        """
        warnings.warn("data collected from finished events are deprecated."
                      "Use NmapParser.parse()", DeprecationWarning)
        return self.__endtime

    @property
    def elapsed(self):
        """
        Accessor returning for how long the scan ran (in seconds)

        :return: string
        """
        warnings.warn("data collected from finished events are deprecated."
                      "Use NmapParser.parse()", DeprecationWarning)
        return self.__elapsed

    @property
    def summary(self):
        """
        Accessor returning a short summary of the scan's results

        :return: string
        """
        warnings.warn("data collected from finished events are deprecated."
                      "Use NmapParser.parse()", DeprecationWarning)
        return self.__summary

    @property
    def tasks(self):
        """
        Accessor returning for the list of tasks ran during nmap scan

        :return: dict of NmapTask object
        """
        return self.__nmap_tasks

    @property
    def version(self):
        """
        Accessor for nmap binary version number

        :return: version number of nmap binary
        :rtype: string
        """
        return self.__version

    @property
    def current_task(self):
        """
        Accessor for the current NmapTask beeing run

        :return: NmapTask or None if no task started yet
        """
        rval = None
        if len(self.__current_task):
            rval = self.tasks[self.__current_task]
        return rval

    @property
    def etc(self):
        """
        Accessor for estimated time to completion

        :return:  estimated time to completion
        """
        rval = 0
        if self.current_task:
            rval = self.current_task.etc
        return rval

    @property
    def progress(self):
        """
        Accessor for progress status in percentage

        :return: percentage of job processed.
        """
        rval = 0
        if self.current_task:
            rval = self.current_task.progress
        return rval

    @property
    def rc(self):
        """
        Accessor for nmap execution's return code

        :return: nmap execution's return code
        """
        return self.__nmap_rc

    @property
    def stdout(self):
        """
        Accessor for nmap standart output

        :return: output from nmap scan in XML
        :rtype: string
        """
        return self.__stdout

    @property
    def stderr(self):
        """
        Accessor for nmap standart error

        :return: output from nmap when errors occured.
        :rtype: string
        """
        return self.__stderr


def main():
    def mycallback(nmapscan=None):
        if nmapscan.is_running() and nmapscan.current_task:
            ntask = nmapscan.current_task
            print("Task {0} ({1}): ETC: {2} DONE: {3}%".format(ntask.name,
                                                               ntask.status,
                                                               ntask.etc,
                                                               ntask.progress))
    nm = NmapProcess("scanme.nmap.org",
                     options="-A",
                     event_callback=mycallback)
    rc = nm.run()
    if rc == 0:
        print("Scan started at {0} nmap version: {1}").format(nm.starttime,
                                                              nm.version)
        print("state: {0} (rc: {1})").format(nm.state, nm.rc)
        print("results size: {0}").format(len(nm.stdout))
        print("Scan ended {0}: {1}").format(nm.endtime, nm.summary)
    else:
        print("state: {0} (rc: {1})").format(nm.state, nm.rc)
        print("Error: {stderr}").format(stderr=nm.stderr)
        print("Result: {0}").format(nm.stdout)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = reportjson
#!/usr/bin/env python
import json
from libnmap.objects import NmapHost, NmapService, NmapReport
from libnmap.objects.os import NmapOSFingerprint, NmapOSMatch, NmapOSClass
from libnmap.objects.os import CPE, OSFPPortUsed
from libnmap.parser import NmapParser


class ReportEncoder(json.JSONEncoder):
    def default(self, obj):
        otype = {'NmapHost': NmapHost,
                 'NmapOSFingerprint': NmapOSFingerprint,
                 'NmapOSMatch': NmapOSMatch,
                 'NmapOSClass': NmapOSClass,
                 'CPE': CPE,
                 'OSFPPortUsed': OSFPPortUsed,
                 'NmapService': NmapService,
                 'NmapReport': NmapReport}
        if isinstance(obj, tuple(otype.values())):
            key = '__%s__' % obj.__class__.__name__
            return {key: obj.__dict__}
        return json.JSONEncoder.default(self, obj)


class ReportDecoder(json.JSONDecoder):
    def decode(self, json_str):
        r = NmapParser.parse_fromdict(json.loads(json_str))
        return r

########NEW FILE########
__FILENAME__ = check_fqp_nmap
#!/usr/bin/env python
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException


# start a new nmap scan on localhost with some specific options
def do_scan(targets, options, fqp=None):
    nm = NmapProcess(targets, options, fqp=fqp)
    rc = nm.run()
    if rc != 0:
        print "nmap scan failed: %s" % (nm.stderr)

    try:
        parsed = NmapParser.parse(nm.stdout)
    except NmapParserException as e:
        print "Exception raised while parsing scan: %s" % (e.msg)

    return parsed


# print scan results from a nmap report
def print_scan(nmap_report):
    print "Starting Nmap {0} ( http://nmap.org ) at {1}".format(
        nmap_report._nmaprun['version'],
        nmap_report._nmaprun['startstr'])

    for host in nmap_report.hosts:
        if len(host.hostnames):
            tmp_host = host.hostnames.pop()
        else:
            tmp_host = host.address

        print "Nmap scan report for {0} ({1})".format(
            tmp_host,
            host.address)
        print "Host is {0}.".format(host.status)
        print "  PORT     STATE         SERVICE"

        for serv in host.services:
            pserv = "{0:>5s}/{1:3s}  {2:12s}  {3}".format(
                    str(serv.port),
                    serv.protocol,
                    serv.state,
                    serv.service)
            if len(serv.banner):
                pserv += " ({0})".format(serv.banner)
            print pserv
    print nmap_report.summary


if __name__ == "__main__":
    report = do_scan("127.0.0.1", "-sV")
    print_scan(report)
    # test with full path to bin
    # /usr/bin/nmap
    report = do_scan("127.0.0.1", "-sV", fqp="/usr/bin/nmap")
    print_scan(report)
    # /usr/bin/lol --> will throw exception
    try:
        report = do_scan("127.0.0.1", "-sV", fqp="/usr/bin/lol")
        print_scan(report)
    except Exception as exc:
        print exc

########NEW FILE########
__FILENAME__ = multi_nmap_process
#!/usr/bin/env python
 
from libnmap.process import NmapProcess
 
def make_nmproc_obj(targets, options):
    return NmapProcess(targets=targets, options=options)
 
def start_all(nmprocs):
    for nmp in nmprocs:
        print("Starting scan for host {0}".format(nmp.targets))
        nmp.run()
 
def summarize(nmprocs):
    for nmp in nmprocs:
        print "rc: {0} output: {1}".format(nmp.rc, len(nmp.stdout))

nm_targets = []
for h in range(20): nm_targets.append("localhost")
nm_opts = "-sT"
 
nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]
start_all(nm_procs)
 
summarize(nm_procs)

########NEW FILE########
__FILENAME__ = multi_nmap_process_background
#!/usr/bin/env python
 
from libnmap.process import NmapProcess
from time import sleep
 
def make_nmproc_obj(targets, options):
  return NmapProcess(targets=targets, options=options)
 
def start_all_bg(nmprocs):
  for nmp in nmprocs: nmp.run_background()
 
def any_running(nmprocs):
  return any([nmp.is_running() for nmp in nmprocs])
 
def summarize(nmprocs):
  for nmp in nmprocs:
      print "rc: {0} output: {1} stdout len: {2}".format(nmp.rc, nmp.summary, len(nmp.stdout))

nm_targets = []
for h in range(10):
    nm_targets.append("localhost")
nm_opts = "-sT"
 
nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]
start_all_bg(nm_procs)
 
while any_running(nm_procs):
    print "Nmap Scan running..."
    sleep(2)
 
summarize(nm_procs)

########NEW FILE########
__FILENAME__ = proc_async
#!/usr/bin/env python

from libnmap.process import NmapProcess
from time import sleep


nmap_proc = NmapProcess(targets="scanme.nmap.org", options="-sT")
nmap_proc.run_background()
while nmap_proc.is_running():
    nmaptask = nmap_proc.current_task
    if nmaptask:
        print "Task {0} ({1}): ETC: {2} DONE: {3}%".format(nmaptask.name,
                                                           nmaptask.status,  
                                                           nmaptask.etc,
                                                           nmaptask.progress)
    sleep(0.5)

print "rc: {0} output: {1}".format(nmap_proc.rc, nmap_proc.summary)
print nmap_proc.stdout

########NEW FILE########
__FILENAME__ = proc_nmap_like
#!/usr/bin/env python
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException


# start a new nmap scan on localhost with some specific options
def do_scan(targets, options):
    nm = NmapProcess(targets, options)
    rc = nm.run()
    if rc != 0:
        print "nmap scan failed: %s" % (nm.stderr)

    try:
        parsed = NmapParser.parse(nm.stdout)
    except NmapParserException as e:
        print "Exception raised while parsing scan: %s" % (e.msg)

    return parsed


# print scan results from a nmap report
def print_scan(nmap_report):
    print "Starting Nmap {0} ( http://nmap.org ) at {1}".format(
        nmap_report._nmaprun['version'],
        nmap_report._nmaprun['startstr'])

    for host in nmap_report.hosts:
        if len(host.hostnames):
            tmp_host = host.hostnames.pop()
        else:
            tmp_host = host.address

        print "Nmap scan report for {0} ({1})".format(
            tmp_host,
            host.address)
        print "Host is {0}.".format(host.status)
        print "  PORT     STATE         SERVICE"

        for serv in host.services:
            pserv = "{0:>5s}/{1:3s}  {2:12s}  {3}".format(
                    str(serv.port),
                    serv.protocol,
                    serv.state,
                    serv.service)
            if len(serv.banner):
                pserv += " ({0})".format(serv.banner)
            print pserv
    print nmap_report.summary


if __name__ == "__main__":
    report = do_scan("127.0.0.1", "-sV")
    print_scan(report)

########NEW FILE########
__FILENAME__ = stop_scan
#!/usr/bin/env python

from libnmap.process import NmapProcess
from time import sleep


nmap_proc = NmapProcess(targets="scanme.nmap.org", options="-sV")
nmap_proc.run_background()
while nmap_proc.is_running():
    nmaptask = nmap_proc.current_task
    if nmaptask:
        print "Task {0} ({1}): ETC: {2} DONE: {3}%".format(nmaptask.name,
                                                           nmaptask.status,
                                                           nmaptask.etc,
                                                           nmaptask.progress)
    sleep(3)
    nmap_proc.stop()

print "rc: {0} output: {1}".format(nmap_proc.rc, nmap_proc.summary)
print nmap_proc.stdout
print nmap_proc.stderr

########NEW FILE########
__FILENAME__ = stressback
#!/usr/bin/env python
 
from libnmap.process import NmapProcess
from time import sleep
 
def make_nmproc_obj(targets, options):
    return NmapProcess(targets=targets, options=options)
 
def start_all_bg(nmprocs):
    for nmp in nmprocs: nmp.run_background()
 
def any_running(nmprocs):
    return any([nmp.is_running() for nmp in nmprocs])
 
def summarize(nmprocs):
    for nmp in nmprocs:
        print "rc: {0} output: {1}".format(nmp.rc, len(nmp.stdout))
 
nb_targets = 10
nm_target = "localhost"
nm_opts = "-sP"

nm_targets = [nm_target for i in range(nb_targets)]
nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]
start_all_bg(nm_procs)
 
while any_running(nm_procs):
    sleep(5)
 
summarize(nm_procs)

########NEW FILE########
__FILENAME__ = stresstest
#!/usr/bin/env python
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException

nm = NmapProcess('127.0.0.1', '-sP')
rc = nm.run()
if rc != 0:
    print "nmap scan failed: %s" % (nm.stderr)

try:
    report = NmapParser.parse(nm.stdout)
except NmapParserException as e:
    print "Exception raised while parsing scan: %s" % (e.msg)

print len(nm.stdout)

########NEW FILE########
__FILENAME__ = test_backend_plugin_factory
#!/usr/bin/env python

import unittest
import os
from libnmap.parser import NmapParser
from libnmap.plugins.backendplugin import NmapBackendPlugin
from libnmap.plugins.backendpluginFactory import BackendPluginFactory


class TestNmapBackendPlugin(unittest.TestCase):
    """
    This testing class will tests each plugins
    The following test need to be done :
       - test the factory
       - test all the method of the class NmapBackendPlugin:
          - Verify implmented/notImplemented
          - Verify the behaviour (ie insert must insert)
    To support a new plugin or a new way to instanciate a plugin, add a dict
    with the necessary parameter in the urls table define in setUp
    All testcase must loop thru theses urls to validate a plugins
    """
    def setUp(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        self.flist_full = [{'file': "%s/%s" % (fdir, 'files/2_hosts.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir, 'files/1_hosts.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                    'files/1_hosts_banner_ports_notsyn.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                    'files/1_hosts_banner_ports.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                    'files/1_hosts_banner.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                               'files/2_hosts_version.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir,
                                               'files/2_tcp_hosts.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir,
                                               'files/1_hosts_nohostname.xml'),
                            'hosts': 1}]
        self.flist = self.flist_full
        #build a list of NmapReport
        self.reportList = []
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            s = fd.read()
            fd.close()
            nrp = NmapParser.parse(s)
            self.reportList.append(nrp)

        self.urls = [{'plugin_name': "mongodb"},
                     #{'plugin_name':'sql','url':'sqlite://','echo':'debug'},
                     {'plugin_name': 'sql',
                         'url': 'sqlite:////tmp/reportdb.sql',
                         'echo': False},
                     {'plugin_name': 'sql',
                         'url': 'mysql+mysqldb://root@localhost/poulet',
                         'echo': False},
                     #Walrus
                     ###{'plugin_name': 's3',
                     ###    'aws_access_key_id': 'UU72FLVJCAYRATLXI70YH',
                     ###    'aws_secret_access_key': 'wFg7gP5YFHjVlxakw1g1uCC8UR2xVW5ax9ErZCut',
                     ###    'host':"walrus.ecc.eucalyptus.com",
                     ###    'path':'/services/Walrus',
                     ###    'port':8773,
                     ###    'is_secure':False,
                     ###    'bucket':"uu72flvjcayratlxi70yh_nmapreport33333",
                     ###},
                     ####Walrus
                   #  {'plugin_name': 's3',   # disabled for now
                   #      'aws_access_key_id': 'UU72FLVJCAYRATLXI70YH',
                   #      'aws_secret_access_key': 'wFg7gP5YFHjVlxakw1g1uCC8UR2xVW5ax9ErZCut',
                   #      'host':"walrus.ecc.eucalyptus.com",
                   #      'path':'/services/Walrus',
                   #      'port':8773,
                   #      'is_secure':False,
                   #  },
                     #S3
                     ###{'plugin_name': 's3',
                     ###    'aws_access_key_id': 'YOURKEY',
                     ###    'aws_secret_access_key': 'YOURPASSWKEY',
                     ###},
                  ]

    def test_backend_factory(self):
        """ test_factory BackendPluginFactory.create(**url)
            Invoke factory and test that the object is of the right classes
        """
        for url in self.urls:
            backend = BackendPluginFactory.create(**url)
            self.assertEqual(isinstance(backend, NmapBackendPlugin), True)
            className = "Nmap%sPlugin" % url['plugin_name'].title()
            self.assertEqual(backend.__class__.__name__, className, True)

    def test_backend_insert(self):
        """ test_insert
            best way to insert is to call save() of nmapreport :P
        """
        for nrp in self.reportList:
            for url in self.urls:
                #create the backend factory object
                backend = BackendPluginFactory.create(**url)
                #save the report
                returncode = nrp.save(backend)
                #test return code
                self.assertNotEqual(returncode, None)

    def test_backend_get(self):
        """ test_backend_get
            inset all report and save the returned id in a list
            then get each id and create a new list of report
            compare each report (assume eq)
        """
        id_list = []
        result_list = []
        for url in self.urls:
            backend = BackendPluginFactory.create(**url)
            for nrp in self.reportList:
                id_list.append(nrp.save(backend))
            for rep_id in id_list:
                result_list.append(backend.get(rep_id))
            #print result_list[0]
            #print self.reportList[0]
            self.assertEqual(len(result_list), len(self.reportList))
            self.assertEqual((result_list), (self.reportList))
            id_list = []
            result_list = []

    def test_backend_getall(self):
        pass

    def test_backend_delete(self):
        """ test_backend_delete
            inset all report and save the returned id in a list
            for each id remove the item and test if not present
        """
        id_list = []
        result_list = []
        for url in self.urls:
            backend = BackendPluginFactory.create(**url)
            for nrp in self.reportList:
                id_list.append(nrp.save(backend))
            for rep_id in id_list:
                result_list.append(backend.delete(rep_id))
                self.assertEqual(backend.get(rep_id), None)
            id_list = []
            result_list = []


if __name__ == '__main__':
    test_suite = ['test_backend_factory',
                  'test_backend_insert',
                  'test_backend_get',
                  'test_backend_getall',
                  'test_backend_delete'
                  ]
    suite = unittest.TestSuite(map(TestNmapBackendPlugin, test_suite))
    test_result = unittest.TextTestRunner(verbosity=5).run(suite)

########NEW FILE########
__FILENAME__ = test_cpe
#!/usr/bin/env python

from libnmap.objects.os import CPE
import unittest


class TestNmapFP(unittest.TestCase):
    def setUp(self):
        self.cpelist = ['cpe:/a:apache:http_server:2.2.22',
                        'cpe:/a:heimdal:kerberos',
                        'cpe:/a:openbsd:openssh:5.9p1',
                        'cpe:/o:apple:iphone_os:5',
                        'cpe:/o:apple:mac_os_x:10.8',
                        'cpe:/o:apple:mac_os_x',
                        'cpe:/o:linux:linux_kernel:2.6.13',
                        'cpe:/o:linux:linux_kernel',
                        'cpe:/o:microsoft:windows_7',
                        'cpe:/o:microsoft:windows_7::-:professional',
                        'cpe:/o:microsoft:windows_7::sp1',
                        'cpe:/o:microsoft:windows',
                        'cpe:/o:microsoft:windows_server_2008::beta3',
                        'cpe:/o:microsoft:windows_server_2008',
                        'cpe:/o:microsoft:windows_server_2008::sp1',
                        'cpe:/o:microsoft:windows_vista::-',
                        'cpe:/o:microsoft:windows_vista::sp1',
                        'cpe:/o:microsoft:windows_vista::sp2']

    def test_cpe(self):
        apa = CPE(self.cpelist[0])

        self.assertTrue(apa.is_application())
        self.assertFalse(apa.is_hardware())
        self.assertFalse(apa.is_operating_system())
   

        win = CPE(self.cpelist[12])
        self.assertEqual(win.get_vendor(), 'microsoft')
        self.assertEqual(win.get_product(), 'windows_server_2008')
        self.assertEqual(win.get_version(), '')
        self.assertEqual(win.get_update(), 'beta3')
        self.assertEqual(win.get_edition(), '')
        self.assertEqual(win.get_language(), '')

    def test_full_cpe(self):
        cpestr = 'cpe:/a:mozilla:firefox:2.0::osx:es-es'
        resdict = { 'part':'/a', 'vendor':"mozilla", 'product':"firefox", 'version':"2.0", 'update':'', 'edition':"osx", 'language':'es-es' }
        ocpe = CPE(cpestr)
        objdict = {'part': ocpe.get_part(),
                   'vendor': ocpe.get_vendor(),
                   'product': ocpe.get_product(),
                   'version': ocpe.get_version(),
                   'update': ocpe.get_update(),
                   'language': ocpe.get_language(),
                   'edition': ocpe.get_edition()
        }
        self.assertEqual(objdict, resdict)

if __name__ == '__main__':
    test_suite = ['test_cpe', 'test_full_cpe']
    suite = unittest.TestSuite(map(TestNmapFP, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_fp
#!/usr/bin/env python

import unittest
import os
from libnmap.parser import NmapParser


class TestNmapFP(unittest.TestCase):
    def setUp(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        self.flist_full = [{ 'file': "%s/%s" % (fdir, 'files/1_os_banner_scripts.xml'), 'os': 1},
                { 'file': "%s/%s" % (fdir, 'files/2_hosts_version.xml'), 'os': 1},
                { 'file': "%s/%s" % (fdir, 'files/1_hosts_banner_ports_notsyn.xml'), 'os': 0},
                { 'file': "%s/%s" % (fdir, 'files/1_hosts_banner.xml'), 'os': 0},
                { 'file': "%s/%s" % (fdir, 'files/1_hosts_down.xml'), 'os': 0}]
        self.flist = self.flist_full
        self.flist_os =  {'nv6': {'file': "%s/%s" % (fdir, 'files/full_sudo6.xml'), 'os': 0},
                'fullscan': { 'file': "%s/%s" % (fdir, 'files/fullscan.xml'), 'os': 0},
                'nv5': { 'file': "%s/%s" % (fdir, 'files/os_scan5.xml'), 'os': 0}}

    def test_fp(self):
        for file_e in self.flist_full:
            rep = NmapParser.parse_fromfile(file_e['file'])
            for _host in rep.hosts:
                if file_e['os'] != 0:
                    self.assertTrue(_host.os_fingerprinted)
                elif file_e['os'] == 0:
                    self.assertFalse(_host.os_fingerprinted)
                else:
                    raise Exception

    def test_osclasses_new(self):
        oclines = [[[{'type': 'general purpose', 'accuracy': 100, 'vendor': 'Apple', 'osfamily': 'Mac OS X', 'osgen': '10.8.X'},
                    {'type': 'phone', 'accuracy': 100, 'vendor': 'Apple', 'osfamily': 'iOS', 'osgen': '5.X'},
                    {'type': 'media device', 'accuracy': 100, 'vendor': 'Apple', 'osfamily': 'iOS', 'osgen': '5.X'}]],
                    [
                        [{'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': '2008'}],
                        [{'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': '7'}],
                        [{'type': 'phone',           'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': 'Phone'}],
                        [{'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': 'Vista'},
                        {'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': '2008'},
                        {'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': '7'}],
                        [{'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': 'Vista'},
                        {'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': '7'},
                        {'type': 'general purpose', 'accuracy': 100, 'vendor': 'Microsoft', 'osfamily': 'Windows', 'osgen': '2008'}]]
        ]
        rep = NmapParser.parse_fromfile(self.flist_os['nv6']['file'])
        hlist = []
        hlist.append(rep.hosts.pop())
        hlist.append(rep.hosts.pop())
        i=0
        j=0
        k=0
        for h in hlist:
            for om in h.os.osmatches:
                for oc in om.osclasses:
                    tdict = {'type': oc.type, 'accuracy': oc.accuracy, 'vendor': oc.vendor, 'osfamily': oc.osfamily, 'osgen': oc.osgen}
                    self.assertEqual(oclines[i][j][k], tdict)
                    k+=1
                j+=1
                k=0
            j=0
            i+=1

    def test_osmatches_new(self):
        rep = NmapParser.parse_fromfile(self.flist_os['nv6']['file'])
        hlist = []
        hlist.append(rep.hosts.pop())
        hlist.append(rep.hosts.pop())

        baseline = [[{'line': 6014, 'accuracy': 100, 'name': 'Apple Mac OS X 10.8 - 10.8.1 (Mountain Lion) (Darwin 12.0.0 - 12.1.0) or iOS 5.0.1'}],
                    [{'line': 52037, 'accuracy': 100, 'name': 'Microsoft Windows Server 2008 Beta 3'},
                    {'line': 52938, 'accuracy': 100, 'name': 'Microsoft Windows 7 Professional'},
                    {'line': 54362, 'accuracy': 100, 'name': 'Microsoft Windows Phone 7.5'},
                    {'line': 54897, 'accuracy': 100, 'name': 'Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7'},
                    {'line': 55210, 'accuracy': 100, 'name': 'Microsoft Windows Vista SP2, Windows 7 SP1, or Windows Server 2008'}]
                ]
        i=0
        j=0
        for h in hlist:
            for om in h.os.osmatches:
                tdict = {'line': om.line, 'accuracy': om.accuracy, 'name': om.name}
                self.assertEqual(baseline[i][j], tdict)
                j+=1
            j=0
            i+=1

    def test_osmatches_old(self):
        rep = NmapParser.parse_fromfile(self.flist_os['nv5']['file'])
        h1 = rep.hosts[4]
        h1osmatches = [{'line': -1, 'accuracy': 95, 'name': 'general purpose:Linux:Linux'},
            {'line': -1, 'accuracy': 90, 'name': 'WAP:Gemtek:embedded'},
            {'line': -1, 'accuracy': 89, 'name': 'general purpose:Nokia:Linux'},
            {'line': -1, 'accuracy': 88, 'name': 'webcam:AXIS:Linux'}]

        j=0
        for om in h1.os.osmatches:
            tdict = {'line': om.line, 'accuracy': om.accuracy, 'name': om.name}
            self.assertEqual(h1osmatches[j], tdict)
            j+=1

    def test_fpv6(self):
        fpval = "OS:SCAN(V=6.40-2%E=4%D=5/9%OT=88%CT=%CU=%PV=Y%DS=0%DC=L%G=N%TM=536BFF2F%P=x\nOS:86_64-apple-darwin10.8.0)SEQ(SP=F9%GCD=1%ISR=103%TI=RD%TS=A)OPS(O1=M3FD8\nOS:NW4NNT11SLL%O2=M3FD8NW4NNT11SLL%O3=M3FD8NW4NNT11%O4=M3FD8NW4NNT11SLL%O5=\nOS:M3FD8NW4NNT11SLL%O6=M3FD8NNT11SLL)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5\nOS:=FFFF%W6=FFFF)ECN(R=Y%DF=Y%TG=40%W=FFFF%O=M3FD8NW4SLL%CC=N%Q=)T1(R=Y%DF=\nOS:Y%TG=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%TG=40%W=0%S=A%A=\nOS:Z%F=R%O=%RD=0%Q=)U1(R=N)IE(R=N)\n"
        fparray = ['OS:SCAN(V=6.40-2%E=4%D=5/9%OT=88%CT=%CU=%PV=Y%DS=0%DC=L%G=N%TM=536BFF2F%P=x\nOS:86_64-apple-darwin10.8.0)SEQ(SP=F9%GCD=1%ISR=103%TI=RD%TS=A)OPS(O1=M3FD8\nOS:NW4NNT11SLL%O2=M3FD8NW4NNT11SLL%O3=M3FD8NW4NNT11%O4=M3FD8NW4NNT11SLL%O5=\nOS:M3FD8NW4NNT11SLL%O6=M3FD8NNT11SLL)WIN(W1=FFFF%W2=FFFF%W3=FFFF%W4=FFFF%W5\nOS:=FFFF%W6=FFFF)ECN(R=Y%DF=Y%TG=40%W=FFFF%O=M3FD8NW4SLL%CC=N%Q=)T1(R=Y%DF=\nOS:Y%TG=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%TG=40%W=0%S=A%A=\nOS:Z%F=R%O=%RD=0%Q=)U1(R=N)IE(R=N)\n']
        rep = NmapParser.parse_fromfile(self.flist_os['nv6']['file'])
        h1 = rep.hosts.pop()
        self.assertEqual(h1.os.fingerprint, fpval)
        self.assertEqual(h1.os.fingerprints, fparray)

    def test_fpv5(self):
        fpval = 'OS:SCAN(V=5.21%D=5/8%OT=22%CT=1%CU=37884%PV=Y%DS=0%DC=L%G=Y%TM=536BFE32%P=x\nOS:86_64-unknown-linux-gnu)SEQ(SP=100%GCD=1%ISR=106%TI=Z%CI=Z%II=I%TS=8)SEQ\nOS:(SP=101%GCD=1%ISR=107%TI=Z%CI=Z%II=I%TS=8)OPS(O1=M400CST11NW3%O2=M400CST\nOS:11NW3%O3=M400CNNT11NW3%O4=M400CST11NW3%O5=M400CST11NW3%O6=M400CST11)WIN(\nOS:W1=8000%W2=8000%W3=8000%W4=8000%W5=8000%W6=8000)ECN(R=Y%DF=Y%T=40%W=8018\nOS:%O=M400CNNSNW3%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(\nOS:R=Y%DF=Y%T=40%W=8000%S=O%A=S+%F=AS%O=M400CST11NW3%RD=0%Q=)T4(R=Y%DF=Y%T=\nOS:40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0\nOS:%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z\nOS:%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G\nOS:%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S)\n'
        fparray = ['OS:SCAN(V=5.21%D=5/8%OT=22%CT=1%CU=37884%PV=Y%DS=0%DC=L%G=Y%TM=536BFE32%P=x\nOS:86_64-unknown-linux-gnu)SEQ(SP=100%GCD=1%ISR=106%TI=Z%CI=Z%II=I%TS=8)SEQ\nOS:(SP=101%GCD=1%ISR=107%TI=Z%CI=Z%II=I%TS=8)OPS(O1=M400CST11NW3%O2=M400CST\nOS:11NW3%O3=M400CNNT11NW3%O4=M400CST11NW3%O5=M400CST11NW3%O6=M400CST11)WIN(\nOS:W1=8000%W2=8000%W3=8000%W4=8000%W5=8000%W6=8000)ECN(R=Y%DF=Y%T=40%W=8018\nOS:%O=M400CNNSNW3%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(\nOS:R=Y%DF=Y%T=40%W=8000%S=O%A=S+%F=AS%O=M400CST11NW3%RD=0%Q=)T4(R=Y%DF=Y%T=\nOS:40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0\nOS:%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z\nOS:%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G\nOS:%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S)\n']
        rep = NmapParser.parse_fromfile(self.flist_os['nv5']['file'])
        h1 = rep.hosts[4]
        self.assertEqual(h1.os.fingerprint, fpval)
        self.assertEqual(h1.os.fingerprints, fparray)

    def test_cpeservice(self):
        cpelist = ['cpe:/a:openbsd:openssh:5.9p1','cpe:/o:linux:linux_kernel']
        rep = NmapParser.parse_fromfile(self.flist_os['fullscan']['file'])
        h1 = rep.hosts.pop()
        s = h1.services[0]
        self.assertEqual(s.cpelist[0].cpestring, cpelist[0])
        self.assertEqual(s.cpelist[1].cpestring, cpelist[1])
        

if __name__ == '__main__':
    test_suite = ['test_fp', 'test_fpv6', 'test_osmatches_new', 'test_osclasses_new',
            'test_fpv5', 'test_osmatches_old', 'test_cpeservice']
    suite = unittest.TestSuite(map(TestNmapFP, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_host
#!/usr/bin/env python

import unittest
from libnmap.parser import NmapParser

host1 = """
<host starttime="1361738377" endtime="1361738377">
<status state="up" reason="localhost-response"/>
<address addr="127.0.0.1" addrtype="ipv4"/>
<hostnames>
<hostname name="localhost" type="user"/>
<hostname name="localhost" type="PTR"/>
</hostnames>
<ports><extraports state="WILLY_WONCKA" count="995">
<extrareasons reason="conn-refused" count="995"/>
</extraports>
<port protocol="tcp" portid="22">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ssh" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="25">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="smtp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="111">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="rpcbind" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="631">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ipp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="3306">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="mysql" method="table" conf="3"/>
</port>
</ports>
<times srtt="2100" rttvar="688" to="100000"/>
</host>
"""
host2 = """
<host starttime="1361738318" endtime="13617386177">
<status state="up" reason="localhost-respoe"/>
<address addr="127.0.0.1" addrtype="ipv4"/>
<hostnames>
<hostname name="localhost" type="user"/>
<hostname name="localhost" type="PTR"/>
<hostname name="localhost2" type="PTR"/>
</hostnames>
<ports><extraports state="closed" count="995">
<extrareasons reason="conn-refused" count="995"/>
</extraports>
<port protocol="tcp" portid="22">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ssh" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="25">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="smtp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="111">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="rpcbind" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="631">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ipp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="3306">
<state state="open" reason="syn-ack" reason_ttl="1"/>
<service name="mysql" method="table" conf="3"/>
</port>
</ports>
<times srtt="2100" rttvar="688" to="100000"/>
</host>
"""

host3 = """<host starttime="13617" endtime="13617">
<status state="down" reason="localhost-response"/>
<address addr="127.0.0.1" addrtype="ipv4"/>
<hostnames>
<hostname name="localhost" type="user"/>
<hostname name="localhost" type="PTR"/>
</hostnames>
<ports><extraports state="closed" count="995">
<extrareasons reason="conn-refused" count="995"/>
</extraports>
<port protocol="tcp" portid="22">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ssh" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="111">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="rpcbind" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="631">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ipp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="3306">
<state state="closed" reason="syn-ack" reason_ttl="0"/>
<service name="mysql" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="3307">
<state state="closed" reason="syn-ack" reason_ttl="0"/>
<service name="mysql" method="table" conf="3"/>
</port>
</ports>
<times srtt="2100" rttvar="688" to="100000"/>
</host>
"""
host4 = """
<host starttime="77" endtime="13">
<status state="up" reason="locaonse"/>
<address addr="127.0.0.1" addrtype="ipv4"/>
<hostnames>
<hostname name="localhost" type="user"/>
<hostname name="localhost" type="PTR"/>
</hostnames>
<ports><extraports state="azeazeaze" count="995">
<extrareasons reason="conn-refused" count="995"/>
</extraports>
<port protocol="tcp" portid="22">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ssh" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="25">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="smtp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="111">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="rpcbind" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="631">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="ipp" method="table" conf="3"/>
</port>
<port protocol="tcp" portid="3306">
<state state="open" reason="syn-ack" reason_ttl="0"/>
<service name="mysql" method="table" conf="3"/>
</port>
</ports>
<times srtt="200" rttvar="68" to="100"/>
</host>
"""


class TestNmapHost(unittest.TestCase):
    def test_eq_host(self):
        h1 = NmapParser.parse(host1)
        h2 = NmapParser.parse(host2)
        h3 = NmapParser.parse(host3)
        h4 = NmapParser.parse(host4)

        self.assertNotEqual(h1, h2)
        self.assertEqual(h1, h1)
        self.assertNotEqual(h1, h3)
        self.assertEqual(h1, h4)
        self.assertNotEqual(h2, h3)

    def test_host_api(self):
        h = NmapParser.parse(host2)
        self.assertEqual(h.starttime, "1361738318")
        self.assertEqual(h.endtime, "13617386177")
        self.assertEqual(h.address, '127.0.0.1')
        self.assertEqual(h.status, "up")
        self.assertEqual(h.hostnames, ['localhost', 'localhost', 'localhost2'])

        h2 = NmapParser.parse(host3)
        self.assertEqual(len(h2.services), 5)
        self.assertEqual(len(h2.get_ports()), 5)
        self.assertEqual(len(h2.get_open_ports()), 3)
        self.assertEqual(h2.get_service(22, "tcp").state, "open")

    def test_extra_ports(self):
        h1 = NmapParser.parse(host1)
        h2 = NmapParser.parse(host2)

        self.assertEqual(h1.extraports_state['state'], {'count': '995', 'state': 'WILLY_WONCKA'})
        self.assertEqual(h1.extraports_reasons, [{'reason': 'conn-refused', 'count': '995'}])

        self.assertEqual(h2.extraports_state['state'], {'count': '995', 'state': 'closed'})
        self.assertEqual(h2.extraports_reasons, [{'reason': 'conn-refused', 'count': '995'}])

    def test_diff_host(self):
        h1 = NmapParser.parse(host1)
        h2 = NmapParser.parse(host2)
        h3 = NmapParser.parse(host3)

        c1 = h1.diff(h2)
        c2 = h1.diff(h3)
        c3 = h2.diff(h3)

        self.assertEqual(c1.changed(), set(['hostnames']))
        self.assertEqual(c1.added(), set([]))
        self.assertEqual(c1.removed(), set([]))

        self.assertEqual(c1.unchanged(), set(['status',
                                              "NmapService::tcp.22",
                                              "NmapService::tcp.111",
                                              "NmapService::tcp.631",
                                              "NmapService::tcp.3306",
                                              'address',
                                              "NmapService::tcp.25"]))

        self.assertEqual(c2.changed(), set(['status',
                                            "NmapService::tcp.3306"]))
        self.assertEqual(c2.added(), set(["NmapService::tcp.25"]))
        self.assertEqual(c2.removed(), set(["NmapService::tcp.3307"]))
        self.assertEqual(c2.unchanged(), set(["NmapService::tcp.631",
                                              'hostnames',
                                              "NmapService::tcp.22",
                                              "NmapService::tcp.111",
                                              'address']))

        self.assertEqual(c3.changed(), set(['status', 'hostnames',
                                            "NmapService::tcp.3306"]))
        self.assertEqual(c3.added(), set(["NmapService::tcp.25"]))
        self.assertEqual(c3.removed(), set(["NmapService::tcp.3307"]))
        self.assertEqual(c3.unchanged(), set(["NmapService::tcp.631",
                                              "NmapService::tcp.22",
                                              "NmapService::tcp.111",
                                              'address']))


if __name__ == '__main__':
    test_suite = ['test_eq_host', 'test_host_api', 'test_diff_host']
    suite = unittest.TestSuite(map(TestNmapHost, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_new_parser
#!/usr/bin/env python

import unittest
from libnmap.parser import NmapParser, NmapParserException

baddatalist = ["<host>aaa", None, '', 123, "ports/>>>", "<port<>",
               "<port/>", "<ports/aaaa>"]


class TestNmapParser(unittest.TestCase):
    def test_parse(self):
        for baddata in baddatalist:
            self.assertRaises(NmapParserException, NmapParser.parse,
                              baddata, "zz")
            self.assertRaises(NmapParserException, NmapParser.parse,
                              baddata, "XML")
            self.assertRaises(NmapParserException, NmapParser.parse,
                              baddata, "YAML")

if __name__ == '__main__':
    test_suite = ['test_parse']

    suite = unittest.TestSuite(map(TestNmapParser, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_parser
#!/usr/bin/env python

import unittest
import os
from libnmap.parser import NmapParser, NmapParserException


class TestNmapParser(unittest.TestCase):
    def setUp(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        self.flist_full = [
            {'file': "%s/%s" % (fdir,
                                'files/2_hosts.xml'), 'hosts': 2},
            {'file': "%s/%s" % (fdir,
                                'files/1_hosts.xml'), 'hosts': 1},
            {'file': "%s/%s" % (fdir,
                                'files/1_hosts_banner_ports_notsyn.xml'),
             'hosts': 1},
            # {'file': "%s/%s" % (fdir,
            #                      'files/1_hosts_banner_ports_xmas.xml'),
            #                      'hosts': 1},
            {'file': "%s/%s" % (fdir,
                                'files/1_hosts_banner_ports.xml'), 'hosts': 1},
            {'file': "%s/%s" % (fdir,
                                'files/1_hosts_banner.xml'), 'hosts': 1},
            {'file': "%s/%s" % (fdir,
                                'files/2_hosts_version.xml'), 'hosts': 2},
            # {'file': "%s/%s" % (fdir,
            #                      'files/2_null_hosts.xml'), 'hosts': 2},
            {'file': "%s/%s" % (fdir,
                                'files/2_tcp_hosts.xml'), 'hosts': 2},
            {'file': "%s/%s" % (fdir,
                                'files/1_hosts_nohostname.xml'), 'hosts': 1},
        ]
        self.flist = self.flist_full

        self.ports_string = """<ports><extraports state="closed" count="996">
        <extrareasons reason="resets" count="996"/>
        </extraports>
        <port protocol="tcp" portid="22">
            <state state="open" reason="syn-ack" reason_ttl="53"/>
            <service name="ssh" method="table" conf="3"/>
        </port>
        <port protocol="tcp" portid="25">
            <state state="filtered" reason="admin-prohibited" \
                    reason_ttl="253" reason_ip="109.133.192.1"/>
        <service name="smtp" method="table" conf="3"/>
        </port>
        <port protocol="tcp" portid="80">
            <state state="open" reason="syn-ack" reason_ttl="51"/>
            <service name="http" method="table" conf="3"/>
        </port>
        <port protocol="tcp" portid="9929">
            <state state="open" reason="syn-ack" reason_ttl="53"/>
            <service name="nping-echo" method="table" conf="3"/>
        </port>
        </ports>"""

        self.ports_string2 = """<ports><extraports state="closed" count="996">
        <extrareasons reason="resets" count="996"/>
        </extraports>
        <port protocol="tcp" portid="A2">
            <state state="open" reason="syn-ack" reason_ttl="53"/>
            <service name="ssh" method="table" conf="3"/>
        </port>
        <port protocol="tcp" portid="25">
            <state state="filtered" reason="admin-prohibited" \
                    reason_ttl="253" reason_ip="109.133.192.1"/>
            <service name="smtp" method="table" conf="3"/>
        </port>
        <port protocol="tcp" portid="80">
            <state state="open" reason="syn-ack" reason_ttl="51"/>i
            <service name="http" method="table" conf="3"/></port>
        <port protocol="tcp" portid="9929">
            <state state="open" reason="syn-ack" reason_ttl="53"/>
            <service name="nping-echo" method="table" conf="3"/>
        </port>
        </ports>"""

        self.port_string = """
        <port protocol="tcp" portid="25">
        <state state="filtered" reason="admin-prohibited"
                reason_ttl="253" reason_ip="109.133.192.1"/>
        <service name="smtp" method="table" conf="3"/>
        </port>"""

        self.port_string2 = """
        <port protocol="tcp" portid="">
            <state state="filtered" reason="admin-prohibited"
                    reason_ttl="253" reason_ip="109.133.192.1"/>
            <service name="smtp" method="table" conf="3"/>
        </port>"""

        self.port_string3 = '<port></port>'
        self.port_string4 = ''
        self.port_string5 = 'GINGERBREADMAN'
        self.port_string6 = """
        <port protocol="tcp" portid="FOOL">
        <state state="filtered" reason="admin-prohibited"
                reason_ttl="253" reason_ip="109.133.192.1"/>
        <service name="smtp" method="table" conf="3"/>
        </port>"""

        self.port_string7 = """
        <port protocol="tcp" portid="22">
        <stAAte state="filtered" reason="admin-prohibited"
                reason_ttl="253" reason_ip="109.133.192.1"/>
        <service name="smtp" method="table" conf="3"/></port>"""

        self.port_string8 = """
        <port protocol="tcp" portid="22">
        <service name="smtp" method="table" conf="3"/>
        </port>"""
        self.port_string9 = """
        <port protocol="tcp" portid="22">
        <state/>
        <service name="smtp" method="table" conf="3"/>
        </port>"""

    def test_class_parser(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            s = fd.read()
            fd.close()
            NmapParser.parse(s)

    def test_class_ports_parser(self):
        pdict = NmapParser.parse(self.ports_string)
        plist = pdict['ports']
        self.assertEqual(len(plist), 4)
        self.assertEqual(sorted([p.port for p in plist]),
                         sorted([22, 25, 9929, 80]))
        self.assertRaises(ValueError,
                              NmapParser.parse,
                              self.ports_string2)

    def test_class_port_parser(self):
            p = NmapParser.parse(self.port_string)
            self.assertEqual(p.port, 25)
            self.assertNotEqual(p.state, "open")
            self.assertEqual(p.state, "filtered")
            self.assertEqual(p.service, "smtp")
            self.assertEqual(p.reason, "admin-prohibited")
            self.assertEqual(p.reason_ttl, "253")
            self.assertEqual(p.reason_ip, "109.133.192.1")


    def test_port_except(self):
        self.assertRaises(ValueError,
                          NmapParser.parse,
                          self.port_string2)
        self.assertRaises(NmapParserException,
                          NmapParser.parse,
                          self.port_string3)
        self.assertRaises(NmapParserException,
                          NmapParser.parse,
                          self.port_string4)
        self.assertRaises(NmapParserException,
                          NmapParser.parse,
                          self.port_string5)
        self.assertRaises(ValueError,
                          NmapParser.parse,
                          self.port_string6)
        self.assertRaises(NmapParserException,
                          NmapParser.parse,
                          self.port_string7)
        self.assertRaises(NmapParserException,
                          NmapParser.parse,
                          self.port_string8)
        serv = NmapParser.parse(self.port_string9)
        self.assertEqual(serv.state, None)

    def test_parser_generic(self):
        plist = NmapParser.parse_fromstring(self.ports_string)
        for p in plist:
            print p

if __name__ == '__main__':
    test_suite = ['test_class_parser', 'test_class_ports_parser',
                  'test_class_port_parser', 'test_port_except',
                  'test_parser_generic']
    suite = unittest.TestSuite(map(TestNmapParser, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_report
#!/usr/bin/env python

import unittest
import os

#sys.path.append("".join([os.path.dirname(__file__), "/../"]))
from libnmap.parser import NmapParser
from libnmap.diff import NmapDiffException


class TestNmapParser(unittest.TestCase):
    def setUp(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        self.flist_full = [{'file': "%s/%s" % (fdir, 'files/2_hosts.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir, 'files/1_hosts.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                    'files/1_hosts_banner_ports_notsyn.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                    'files/1_hosts_banner_ports.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                    'files/1_hosts_banner.xml'),
                            'hosts': 1},
                           {'file': "%s/%s" % (fdir,
                                               'files/2_hosts_version.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir,
                                               'files/2_tcp_hosts.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir,
                                               'files/1_hosts_nohostname.xml'),
                            'hosts': 1}]

        self.flist_one = [{'file': "%s/%s" % (fdir,
                                              'files/1_hosts_nohostname.xml'),
                           'hosts': 1}]
        self.flist_two = [{'file': "%s/%s" % (fdir, 'files/2_hosts.xml'),
                           'hosts': 2,
                           'elapsed': '134.36', 'endtime': "1361738040",
                           'summary': ("Nmap done at Sun Feb 24 21:34:00 2013;"
                                       " 2 IP addresses (2 hosts up) scanned"
                                       " in 134.36 seconds")}]

        self.hlist = [{'hostname': 'localhost', 'ports': 5, 'open': 5},
                      {'hostname': 'localhost2', 'ports': 4, 'open': 2},
                      {'hostname': 'scanme.nmap.org', 'ports': 4, 'open': 3},
                      {'hostname': '1.1.1.1', 'ports': 2, 'open': 0}]
        self.flist_banner = [{'file': "%s/%s" % (fdir,
                                                 'files/1_hosts_banner.xml'),
                              'banner': {
                                  '631': 'product: CUPS version: 1.4',
                                  '3306':
                                      'product: MySQL version: 5.1.61',
                                  '22': ("product: OpenSSH extrainfo:"
                                         " protocol 2.0 version: 5.3"),
                                  '25': ("product: Postfix smtpd"
                                         " hostname:  jambon.localdomain"),
                                  '111': ''}}]

        self.flist = self.flist_full

    def test_report_constructor(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            s = fd.read()
            fd.close()
            nr = NmapParser.parse(s)
            nr2 = NmapParser.parse(s)

            self.assertEqual(len(nr.hosts), testfile['hosts'])

            self.assertEqual(len(nr2.hosts), testfile['hosts'])
            self.assertEqual(sorted(nr2.get_raw_data()),
                             sorted(nr.get_raw_data()))

    def test_get_ports(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            s = fd.read()
            fd.close()

            nr = NmapParser.parse(s)
            for h in nr.hosts:
                for th in self.hlist:
                    continue
# TODO FIX THIS TEST
#                    if th['hostname'] == h.hostnames[0]:
#                    self.assertEqual(th['ports'], len(h.get_ports()))
#                   self.assertEqual(th['open'], len(h.get_open_ports()))

                for np in h.get_open_ports():
                    sport = h.get_service(np[0], np[1])
                    self.assertEqual((sport.port, sport.protocol), np)

    def test_runstats(self):
        for testfile in self.flist_two:
            fd = open(testfile['file'], 'r')
            s = fd.read()
            fd.close()
            nr = NmapParser.parse(s)
            self.assertEqual(getattr(nr, 'endtime'), int(testfile['endtime']))
            self.assertEqual(getattr(nr, 'summary'), testfile['summary'])
            self.assertEqual(getattr(nr, 'elapsed'), float(testfile['elapsed']))

    def test_banner(self):
        for testfile in self.flist_banner:
            fd = open(testfile['file'], 'r')
            nr = NmapParser.parse(fd.read())
            fd.close()

            for h in nr.hosts:
                for service in h.services:
                    b = service.banner
                    self.assertEqual(b, testfile['banner'][str(service.port)])

    def test_service_equal(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            np1 = NmapParser.parse(fd.read())
            fd.close()
            fd = open(testfile['file'], 'r')
            np2 = NmapParser.parse(fd.read())
            fd.close()

            host1 = np1.hosts.pop()
            host2 = np2.hosts.pop()
            """All the service of the host must be compared and
               the hash should be also the same"""
            for i in range(len(host1.services)):
                self.assertEqual(hash(host1.services[i]),
                                 hash(host2.services[i]))
                self.assertEqual(host1.services[i],
                                 host2.services[i])

            #print host1.serviceChanged(host2)

    def test_service_not_equal(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            np1 = NmapParser.parse(fd.read())
            fd.close()
            fd = open(testfile['file'], 'r')
            np2 = NmapParser.parse(fd.read())
            fd.close()

            host1 = np1.hosts.pop()
            host2 = np2.hosts.pop()
            for i in range(len(host1.services)):
                host1.services[i]._state['state'] = 'changed'
                self.assertNotEqual(host1.services[i], host2.services[i])
            #print "-----------"
            #print host1.serviceChanged(host2)
            #print "-----------"

    def test_host_not_equal(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            np1 = NmapParser.parse(fd.read())
            fd.close()
            fd = open(testfile['file'], 'r')
            np2 = NmapParser.parse(fd.read())
            fd.close()

            host1 = np1.hosts.pop()
            host2 = np2.hosts.pop()

            host1.address = {'addr': '1.3.3.7', 'addrtype': 'ipv4'}
            self.assertNotEqual(host1, host2)

    def test_host_equal(self):
        for testfile in self.flist:
            fd = open(testfile['file'], 'r')
            np1 = NmapParser.parse(fd.read())
            fd.close()
            fd = open(testfile['file'], 'r')
            np2 = NmapParser.parse(fd.read())
            fd.close()

            host1 = np1.hosts.pop()
            host2 = np2.hosts.pop()

            host1.services[0]._portid = '23'
            self.assertEqual(host1, host2)

    def test_host_address_changed(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        fd1 = open("%s/%s" % (fdir, 'files/1_hosts_down.xml'), 'r')
        fd2 = open("%s/%s" % (fdir, 'files/1_hosts.xml'), 'r')
        nr1 = NmapParser.parse(fd1.read())
        nr2 = NmapParser.parse(fd2.read())
        h1 = nr1.hosts[0]
        h2 = nr2.hosts[0]
        self.assertRaises(NmapDiffException, h1.diff, h2)

    def test_host_address_unchanged(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        fd1 = open("%s/%s" % (fdir, 'files/1_hosts_down.xml'), 'r')
        fd2 = open("%s/%s" % (fdir, 'files/1_hosts.xml'), 'r')
        fd3 = open("%s/%s" % (fdir, 'files/1_hosts.xml'), 'r')
        nr1 = NmapParser.parse(fd1.read())
        nr2 = NmapParser.parse(fd2.read())
        nr3 = NmapParser.parse(fd3.read())

        h1 = nr1.hosts.pop()
        h2 = nr2.hosts.pop()
        h3 = nr3.hosts.pop()

        self.assertRaises(NmapDiffException, h1.diff, h2)
        self.assertEqual(h2.diff(h3).changed(), set([]))
        self.assertEqual(h2.diff(h3).added(), set([]))
        self.assertEqual(h2.diff(h3).removed(), set([]))
        self.assertEqual(h2.diff(h3).unchanged(),
                         set(['status',
                              "NmapService::tcp.22",
                              "NmapService::tcp.111",
                              "NmapService::tcp.631",
                              'hostnames',
                              "NmapService::tcp.3306",
                              'address',
                              "NmapService::tcp.25"]))

if __name__ == '__main__':
    test_suite = ['test_report_constructor', 'test_get_ports',
                  'test_runstats', 'test_banner', 'test_service_equal',
                  'test_service_not_equal', 'test_host_not_equal',
                  'test_host_equal', 'test_host_address_changed',
                  'test_host_address_unchanged']

    suite = unittest.TestSuite(map(TestNmapParser, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_report_diff
#!/usr/bin/env python

import unittest
import os
from libnmap.parser import NmapParser


class TestNmapReportDiff(unittest.TestCase):
    def setUp(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        self.flist_full = [{'file': "%s/%s" % (fdir, 'files/2_hosts.xml'),
                            'hosts': 2},
                           {'file': "%s/%s" % (fdir, 'files/1_hosts.xml'),
                            'hosts': 1}]
        self.flist = self.flist_full

    def test_diff_host_list(self):
        fdir = os.path.dirname(os.path.realpath(__file__))
        r1 = NmapParser.parse_fromfile("%s/%s" % (fdir, 'files/1_hosts.xml'))
        r2 = NmapParser.parse_fromfile("%s/%s" % (fdir, 'files/2_hosts.xml'))
        r3 = NmapParser.parse_fromfile("%s/%s" % (fdir, 'files/1_hosts.xml'))
        r4 = NmapParser.parse_fromfile("%s/%s" % (fdir,
                                                  'files/2_hosts_achange.xml'))

        d1 = r1.diff(r2)
        self.assertEqual(d1.changed(), set(['hosts_total', 'commandline',
                                            'hosts_up', 'scan_type',
                                            'elapsed']))
        self.assertEqual(d1.unchanged(), set(['hosts_down', 'version',
                                              'NmapHost::127.0.0.1']))
        self.assertEqual(d1.removed(), set(['NmapHost::74.207.244.221']))

        d2 = r1.diff(r3)
        self.assertEqual(d2.changed(), set([]))
        self.assertEqual(d2.unchanged(), set(['hosts_total',
                                              'commandline',
                                              'hosts_up',
                                              'NmapHost::127.0.0.1',
                                              'elapsed',
                                              'version',
                                              'scan_type',
                                              'hosts_down']))
        self.assertEqual(d2.added(), set([]))
        self.assertEqual(d2.removed(), set([]))

        d3 = r2.diff(r4)
        self.assertEqual(d3.changed(), set(['NmapHost::127.0.0.1']))
        self.assertEqual(d3.unchanged(), set(['hosts_total',
                                              'commandline',
                                              'hosts_up',
                                              'NmapHost::74.207.244.221',
                                              'version',
                                              'elapsed',
                                              'scan_type',
                                              'hosts_down']))
        self.assertEqual(d3.added(), set([]))
        self.assertEqual(d3.removed(), set([]))


if __name__ == '__main__':
    test_suite = ['test_diff_host_list']
    suite = unittest.TestSuite(map(TestNmapReportDiff, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
__FILENAME__ = test_service
#!/usr/bin/env python

import unittest
from libnmap.parser import NmapParser
from libnmap.diff import NmapDiffException

service1 = """
<port protocol="tcp" portid="22">
    <state state="open" reason="syn-ack" reason_ttl="0"/>
    <service name="ssh" method="table" conf="3"/>
</port>
"""

service2 = """
<port protocol="udp" portid="22">
    <state state="open" reason="syn-ack" reason_ttl="0"/>
    <service name="ssh" method="table" conf="3"/>
</port>
"""

service3 = """
<port protocol="udp" portid="53">
    <state state="open" reason="syn-ack" reason_ttl="0"/>
    <service name="ssh" method="table" conf="3"/>
</port>
"""

service4 = """
<port protocol="tcp" portid="22">
    <state state="closed" reason="syn-ack" reason_ttl="0"/>
    <service name="ssh" method="table" conf="3"/>
</port>
"""

service5 = """
<port protocol="tcp" portid="3306">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="mysql" product="MySQL" version="5.1.62"
            method="probed" conf="10"/>
</port>
"""

service6 = """
<port protocol="tcp" portid="3306">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="mysql" product="MySQL"
        version="5.1.61" method="probed" conf="10"/>
</port>
"""

service7 = """
<port protocol="tcp" portid="3306">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="mysql"
        product="MySQL" version="5.1.61" method="probed" conf="10"/>
</port>
"""

port_string = """
<port protocol="tcp" portid="25">
    <state state="filtered" reason="admin-prohibited"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="smtp" method="table" conf="3"/>
</port>"""

port_string_other2 = """
<port protocol="tcp" portid="25">
    <state state="open" reason="admin-prohibited"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="smtp" method="table" conf="3"/>
</port>"""

port_string_other3 = """
<port protocol="tcp" portid="22">
    <state state="open" reason="admin-prohibited"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="ssh" method="table" conf="3"/>
</port>"""

port_string_other4 = """
<port protocol="tcp" portid="22">
    <state state="willy_woncka" reason="admin-prohibited"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="willywoncka" method="table" conf="3"/>
</port>"""

port_string_other5 = """
<port protocol="tcp" portid="22">
    <state state="willy_woncka" reason="admin-prohibited"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="ssh" method="table" conf="3"/>
</port>"""

port_string_other6 = """
<port protocol="tcp" portid="25">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="smtp" product="Postfix smtpd"
        hostname=" jambon.localdomain" method="probed" conf="10"/>
</port>"""

port_string_other7 = """
<port protocol="tcp" portid="111">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="rpcbind" method="probed" conf="10"/>
</port>"""

port_string_other8 = """
<port protocol="tcp" portid="631">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="ipp" product="CUPS" version="1.4"
        method="probed" conf="10"/>
</port>"""

port_string_other9 = """
<port protocol="tcp" portid="631">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="ipp" product="COPS" version="1.4"
        method="probed" conf="10"/>
</port>"""

port_string_other10 = """
<port protocol="tcp" portid="25">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="smtp" product="Postfix smtpd"
        hostname=" jambon.localdomain" method="probed" conf="10"/>
</port>"""

port_string_other11 = """
<port protocol="tcp" portid="25">
    <state state="open" reason="syn-ack" reason_ttl="69"/>
    <service name="smtp" product="Postfix smtpd"
        hostname=" jambon.localdomain" method="probed" conf="10"/>
</port>"""

port_string_other12 = """
<port protocol="tcp" portid="25">
    <state state="filtered" reason="admin-prohibited"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="smtp" method="table" conf="3"/>
</port>"""

port_string_other13 = """
<port protocol="tcp" portid="25">
    <state state="filtered" reason="patin"
        reason_ttl="253" reason_ip="109.133.192.1"/>
    <service name="smtp" method="table" conf="3"/>
</port>"""

port_noservice = """
<port protocol="udp" portid="3306">
<state state="closed" reason="port-unreach" reason_ttl="64" />
</port>"""

port_owner = """
<port protocol="tcp" portid="25">
    <state state="open" reason="syn-ack" reason_ttl="64"/>
    <service name="smtp" product="Postfix smtpd"
        hostname=" jambon.localdomain" method="probed" conf="10"/>
    <owner name="edwige"/>
</port>"""


class TestNmapService(unittest.TestCase):
    def setUp(self):
        self.s1 = NmapParser.parse(service1)
        self.s2 = NmapParser.parse(service2)
        self.s3 = NmapParser.parse(service3)
        self.s4 = NmapParser.parse(service4)
        self.s5 = NmapParser.parse(service5)
        self.s6 = NmapParser.parse(service6)
        self.s7 = NmapParser.parse(service7)

    def test_port_state_changed(self):
        nservice1 = NmapParser.parse(port_string)
        nservice2 = NmapParser.parse(port_string_other2)
        nservice3 = NmapParser.parse(port_string_other3)
        nservice4 = NmapParser.parse(port_string_other4)

        self.assertEqual(nservice1.diff(nservice2).changed(), set(['state']))
        self.assertRaises(NmapDiffException, nservice1.diff, nservice3)
        self.assertRaises(NmapDiffException, nservice1.diff, nservice4)
#
        self.assertRaises(NmapDiffException, nservice2.diff, nservice3)
        self.assertEqual(nservice3.diff(nservice4).changed(),
                         set(['state', 'service']))

    def test_port_state_unchanged(self):
        nservice1 = NmapParser.parse(port_string)
        nservice2 = NmapParser.parse(port_string_other2)
        #nservice3 = NmapParser.parse(port_string_other3)
        #nservice4 = NmapParser.parse(port_string_other4)

        self.assertEqual(nservice1.diff(nservice2).unchanged(),
                         set(['banner', 'protocol', 'port', 'service', 'id', 'reason']))

    def test_port_service_changed(self):
        nservice1 = NmapParser.parse(port_string)
        nservice2 = NmapParser.parse(port_string_other2)
        nservice4 = NmapParser.parse(port_string_other4)
        nservice5 = NmapParser.parse(port_string_other5)
        nservice8 = NmapParser.parse(port_string_other8)
        nservice9 = NmapParser.parse(port_string_other9)

        self.assertEqual(nservice1.diff(nservice2).changed(),
                         set(['state']))
        self.assertEqual(nservice5.diff(nservice4).changed(),
                         set(['service']))
        # banner changed
        self.assertEqual(nservice8.diff(nservice9).changed(),
                         set(['banner']))

    def test_eq_service(self):
        self.assertNotEqual(NmapDiffException, self.s1, self.s2)
        self.assertNotEqual(self.s1, self.s3)
        self.assertNotEqual(self.s1, self.s4)

        self.assertNotEqual(self.s5, self.s6)
        self.assertEqual(self.s6, self.s7)

    def test_diff_service(self):
        self.assertRaises(NmapDiffException, self.s1.diff, self.s2)
        self.assertRaises(NmapDiffException, self.s1.diff, self.s3)
        self.assertEqual(self.s1.diff(self.s4).changed(), set(['state']))
        self.assertEqual(self.s1.diff(self.s4).unchanged(),
                         set(['banner', 'protocol', 'port', 'service',
                              'id', 'reason']))

        self.assertEqual(self.s5.diff(self.s6).changed(), set(['banner']))
        self.assertEqual(self.s6.diff(self.s6).changed(), set([]))

    def test_diff_reason(self):
        nservice12 = NmapParser.parse(port_string_other12)
        nservice13 = NmapParser.parse(port_string_other13)
        ddict = nservice12.diff(nservice13)
        self.assertEqual(ddict.changed(), set(['reason']))

    def test_noservice(self):
        noservice = NmapParser.parse(port_noservice)
        self.assertEqual(noservice.service, "")

    def test_owner(self):
        serviceowner = NmapParser.parse(port_owner)
        self.assertEqual(serviceowner.owner, "edwige")


if __name__ == '__main__':
    test_suite = ['test_port_state_changed', 'test_port_state_unchanged',
                  'test_port_service_changed', 'test_eq_service',
                  'test_diff_service']
    suite = unittest.TestSuite(map(TestNmapService, test_suite))
    test_result = unittest.TextTestRunner(verbosity=2).run(suite)

########NEW FILE########
