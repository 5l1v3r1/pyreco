__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# remoteobjects documentation build configuration file, created by
# sphinx-quickstart on Mon Apr 20 14:23:05 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

sys.path.append(os.path.abspath('exts'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.coverage', 'github.tools.sphinx', 'document_init_methods']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'remoteobjects'
copyright = u'2009-2010 Six Apart'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.1'
# The full version, including alpha/beta/rc tags.
release = '1.1.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'remoteobjectsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'remoteobjects.tex', u'remoteobjects Documentation',
   u'Six Apart', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = document_init_methods
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

A Sphinx extension to autodocument __init__ methods.

"""


import logging

def document_init_methods(app, what, name, obj, skip, options):
    if not skip:
        return
    if name != '__init__':
        return
    if not getattr(obj, '__doc__', None):
        return

    # Don't skip it.
    return False

def setup(app):
    app.connect('autodoc-skip-member', document_init_methods)

########NEW FILE########
__FILENAME__ = readme_from_docstring
#!/usr/bin/env python

# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import remoteobjects

readme = file('README.rst', 'w')
readme.write(remoteobjects.__doc__.strip())
readme.write("\n")
readme.close()

########NEW FILE########
__FILENAME__ = couchdb
#!/usr/bin/env python

# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

A generic example CouchDB client, implemented using remoteobjects.

"""

__version__ = '1.0'
__date__ = '24 August 2009'
__author__ = 'Mark Paschal'


import httplib
from optparse import OptionParser
import simplejson as json
import sys
from urlparse import urljoin, urlparse

from remoteobjects import RemoteObject, fields, ListObject


class CouchObject(RemoteObject):

    # CouchDB omits Locations for Created responses, so don't expect them.
    location_headers = dict(RemoteObject.location_headers)
    location_headers[httplib.CREATED] = None

    def update_from_response(self, url, response, content):
        if response.status == httplib.CREATED:
            # CouchDB CREATED responses don't contain full content, so only
            # unpack the ID and revision.
            data = json.loads(content)
            assert data['ok']
            self.update_from_created_dict(data)
            return

        try:
            super(CouchObject, self).update_from_response(url, response, content)
        except self.NotFound:
            # Count that as a delivery, too, since there was nothing to get.
            self._delivered = True
            raise

    def update_from_created_dict(self, data):
        pass


class Database(CouchObject):
    pass


class Document(CouchObject):

    id        = fields.Field(api_name='_id')
    revision  = fields.Field(api_name='_rev')

    def update_from_created_dict(self, data):
        self.id       = data['id']
        self.revision = data['rev']


class ListItem(RemoteObject):

    id    = fields.Field()
    key   = fields.Field()
    value = fields.Field()


class ViewResult(CouchObject, ListObject):

    total_rows = fields.Field()
    offset     = fields.Field()
    entries    = fields.List(fields.Object(ListItem), api_name='rows')

    def filter(self, **kwargs):
        for k, v in kwargs.iteritems():
            if isinstance(v, list) or isinstance(v, dict) or isinstance(v, bool):
                kwargs[k] = json.dumps(v)
        return super(ViewResult, self).filter(**kwargs)


class View(CouchObject):

    mapfn    = fields.Field(api_name='map')
    reducefn = fields.Field(api_name='reduce')


class Viewset(CouchObject):

    language = fields.Constant('javascript')
    views    = fields.Dict(fields.Object(View))


def create_db(url):
    db = Database.get(url)
    try:
        db.deliver()
    except Database.NotFound:
        db.put()
        print "Database %s created" % url
    else:
        print "Database %s already exists" % url


def create_view(dburl):
    viewset = Viewset.get(urljoin(dburl, '_design/profiles'))
    try:
        viewset.deliver()
        print "Retrieved existing 'profiles' views"
    except Viewset.NotFound:
        # Start with an empty set of views.
        viewset.views = {}

    profiles_url_code = """
        function (doc) {
            if (doc.class == 'profile')
                emit([doc.person], doc);
        }
    """
    viewset.views['url'] = View(mapfn=profiles_url_code)

    viewset.put()
    print "Updated 'profiles' views for %s" % dburl


def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = OptionParser()
    parser.add_option("-d", "--database", dest="database",
        help="URL of CouchDB database")
    opts, args = parser.parse_args()

    db = opts.database
    if db is None:
        print >>sys.stderr, "Option --database is required"
        return 1

    # Create the database, if necessary.
    create_db(db)

    # Create a view.
    create_view(db)

    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))

########NEW FILE########
__FILENAME__ = giantbomb
#!/usr/bin/env python

# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

An example Giant Bomb API client, implemented using remoteobjects.

"""

__version__ = '1.0'
__date__ = '24 August 2009'
__author__ = 'Mark Paschal'


from cgi import parse_qs
from datetime import datetime
from optparse import OptionParser
import sys
import time
from urllib import urlencode
from urlparse import urljoin, urlparse, urlunparse

from remoteobjects import RemoteObject, fields


class Bombject(RemoteObject):

    content_types = ('application/json', 'text/javascript')
    api_key = None

    @classmethod
    def get(cls, url, **kwargs):
        if not urlparse(url)[1]:
            url = urljoin('http://api.giantbomb.com/', url)

        self = super(Bombject, cls).get(url, **kwargs)
        self = self.filter(api_key=cls.api_key, format='json')
        return self

    def filter(self, **kwargs):
        url = self._location
        parts = list(urlparse(url))
        query = parse_qs(parts[4])
        query = dict([(k, v[0]) for k, v in query.iteritems()])

        for k, v in kwargs.iteritems():
            if v is None and k in query:
                del query[k]
            else:
                query[k] = v

        parts[4] = urlencode(query)
        url = urlunparse(parts)
        return super(Bombject, self).get(url)


class Image(Bombject):

    tiny_url = fields.Field()
    small_url = fields.Field()
    thumb_url = fields.Field()
    screen_url = fields.Field()
    super_url = fields.Field()


class Game(Bombject):

    id = fields.Field()
    name = fields.Field()
    api_detail_url = fields.Field()
    site_detail_url = fields.Field()

    summary = fields.Field(api_name='deck')
    description = fields.Field()
    image = fields.Object(Image)
    published = fields.Datetime(dateformat='%Y-%m-%d %H:%M:%S', api_name='date_added')
    updated = fields.Datetime(dateformat='%Y-%m-%d %H:%M:%S', api_name='date_last_updated')

    characters = fields.Field()
    concepts = fields.Field()
    developers = fields.Field()
    platforms = fields.Field()
    publishers = fields.Field()

    @classmethod
    def get(cls, url, **kwargs):
        res = GameResult.get(url)
        res = res.filter()
        return res.results[0]


class GameResult(Bombject):

    status_code = fields.Field()
    error = fields.Field()
    total = fields.Field(api_name='number_of_total_results')
    count = fields.Field(api_name='number_of_page_results')
    limit = fields.Field()
    offset = fields.Field()
    results = fields.List(fields.Object(Game))

    def update_from_dict(self, data):
        if not isinstance(data['results'], list):
            data = dict(data)
            data['results'] = [data['results']]
        super(GameResult, self).update_from_dict(data)


def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = OptionParser()
    parser.add_option("-k", "--key", dest="key",
        help="your Giant Bomb API key")
    opts, args = parser.parse_args()

    if opts.key is None:
        print >>sys.stderr, "Option --key is required"
        return 1

    query = ' '.join(args)

    Bombject.api_key = opts.key

    search = GameResult.get('/search/').filter(resources='game')
    search = search.filter(query=query)

    if len(search.results) == 0:
        print "No results for %r" % query
    elif len(search.results) == 1:
        (game,) = search.results
        print "## %s ##" % game.name
        print
        print game.summary
    else:
        print "## Search results for %r ##" % query
        for game in search.results:
            print game.name

    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))

########NEW FILE########
__FILENAME__ = netflix
#!/usr/bin/env python

# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

An example Netflix API client, implemented using remoteobjects.

"""

__version__ = '1.0'
__date__ = '25 August 2009'
__author__ = 'Mark Paschal'


import cgi
from optparse import OptionParser
import sys
from urllib import urlencode
import urlparse
from xml.etree import ElementTree

import httplib2
from oauth.oauth import OAuthConsumer, OAuthRequest, OAuthSignatureMethod_HMAC_SHA1

from remoteobjects import RemoteObject, fields, PageObject


class Flixject(RemoteObject):

    content_types = ('text/xml', 'application/xml')
    api_token = None

    def get_request(self, headers=None, **kwargs):
        request = super(Flixject, self).get_request(headers=headers, **kwargs)
        method = request.get('method', 'GET')

        # Apply OAuthness.
        csr = OAuthConsumer(*self.api_token)
        orq = OAuthRequest.from_consumer_and_token(csr, http_method=method,
            http_url=request['uri'])

        # OAuthRequest will strip our query parameters, so add them back in.
        parts = list(urlparse.urlparse(self._location))
        queryargs = cgi.parse_qs(parts[4], keep_blank_values=True)
        for key, value in queryargs.iteritems():
            orq.set_parameter(key, value[0])

        # Sign the request.
        osm = OAuthSignatureMethod_HMAC_SHA1()
        orq.set_parameter('oauth_signature_method', osm.get_name())
        orq.sign_request(osm, csr, None)

        if method == 'GET':
            request['uri'] = orq.to_url()
        else:
            request['headers'].update(orq.to_header())

        return request

    def update_from_tree(self, tree):
        data = dict((k, v(tree)) for k, v in self.decoder_ring.items())
        self.update_from_dict(data)
        return self

    def update_from_response(self, url, response, content):
        self.raise_for_response(url, response, content)

        tree = ElementTree.fromstring(content)
        self.update_from_tree(tree)


class Title(Flixject):

    api_url = fields.Field()
    title   = fields.Field()
    link    = fields.Field()
    thumb   = fields.Field()
    #synopsis = fields.Link(...)

    decoder_ring = {
        'title': lambda x: x.find('title').get('regular'),
        'link':  lambda x: [j for j in x.findall('link') if j.get('rel') == 'alternate'][0].get('href'),
        'thumb': lambda x: x.find('box_art').get('large'),
        'api_url': lambda x: x.find('id'),
    }


class Catalog(Flixject):

    results = fields.List(fields.Field())
    total   = fields.Field()
    offset  = fields.Field()
    limit   = fields.Field()

    decoder_ring = {
        'results': lambda x: [Title().update_from_tree(tree) for tree in x.findall('catalog_title')],
        'total':   lambda x: int(x.find('number_of_results').text),
        'offset':  lambda x: int(x.find('start_index').text),
        'limit':   lambda x: int(x.find('results_per_page').text),
    }


def do_search(opts, args):
    query = ' '.join(args)

    search = Catalog.get('http://api.netflix.com/catalog/titles').filter(term=query)
    search.deliver()

    if len(search.results) == 0:
        print "No results for %r" % query
    elif len(search.results) == 1:
        result = search.results[0]
        print "## %s ##" % result.title
    else:
        print "## Results for %r ##" % query
        print
        for title in search.results:
            if title is None:
                print "(oops, none)"
            else:
                print title.title

    return 0


def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = OptionParser()
    parser.add_option("-k", "--key", dest="key",
        help="Netflix API key (required)")
    parser.add_option("-s", "--secret", dest="secret",
        help="Netflix API shared secret (required)")
    parser.add_option("--search", action="store_const", const=do_search,
        dest="action", default=do_search,
        help="Search for an item by title (default)")
    opts, args = parser.parse_args()

    if opts.key is None or opts.secret is None:
        print >>sys.stderr, "Options --key and --secret are required"
        return 1

    Flixject.api_token = (opts.key, opts.secret)

    return opts.action(opts, args)


if __name__ == '__main__':
    sys.exit(main(sys.argv))

########NEW FILE########
__FILENAME__ = twitter
#!/usr/bin/env python

# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

A Twitter API client, implemented using remoteobjects.

"""

__version__ = '1.1'
__date__ = '17 April 2009'
__author__ = 'Brad Choate'


import httplib
from optparse import OptionParser
import sys
from urllib import urlencode, quote_plus
from urlparse import urljoin, urlunsplit

from httplib2 import Http

from remoteobjects import RemoteObject, fields, ListObject


class User(RemoteObject):

    """A Twitter account.

    A User can be retrieved from ``http://twitter.com/users/show.json`` with
    the appropriate ``id``, ``user_id``, or ``screen_name`` parameter.

    """

    id = fields.Field()
    name = fields.Field()
    screen_name = fields.Field()
    location = fields.Field()
    description = fields.Field()
    profile_image_url = fields.Field()
    protected = fields.Field()
    followers_count = fields.Field()
    status = fields.Object('Status')

    @classmethod
    def get_user(cls, http=None, **kwargs):
        url = '/users/show'
        if 'id' in kwargs:
            url += '/%s.json' % quote_plus(kwargs['id'])
        else:
            url += '.json'
        query = urlencode(filter(lambda x: x in ('screen_name', 'user_id'), kwargs))
        url = urlunsplit((None, None, url, query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)


class DirectMessage(RemoteObject):

    """A Twitter direct message.

    The authenticated user's most recent direct messages are at
    ``http://twitter.com/direct_messages.json``.

    """

    id = fields.Field()
    sender_id = fields.Field()
    text = fields.Field()
    recipient_id = fields.Field()
    created_at = fields.Field()
    sender_screen_name = fields.Field()
    recipient_screen_name = fields.Field()
    sender = fields.Object(User)
    recipient = fields.Object(User)

    def __unicode__(self):
        return u"%s: %s" % (self.sender.screen_name, self.text)


class Status(RemoteObject):

    """A Twitter update.

    Statuses can be fetched from
    ``http://twitter.com/statuses/show/<id>.json``.

    """

    created_at = fields.Field()
    id = fields.Field()
    text = fields.Field()
    source = fields.Field()
    truncated = fields.Field()
    in_reply_to_status_id = fields.Field()
    in_reply_to_user_id = fields.Field()
    in_reply_to_screen_name = fields.Field()
    favorited = fields.Field()
    user = fields.Object(User)

    @classmethod
    def get_status(cls, id, http=None):
        return cls.get(urljoin(Twitter.endpoint, "/statuses/show/%d.json" % int(id)), http=http)

    def __unicode__(self):
        return u"%s: %s" % (self.user.screen_name, self.text)


class DirectMessageList(ListObject):

    entries = fields.List(fields.Object(DirectMessage))

    def __getitem__(self, key):
        return self.entries.__getitem__(key)

    @classmethod
    def get_messages(cls, http=None, **kwargs):
        url = '/direct_messages.json'
        query = urlencode(filter(lambda x: x in ('since_id', 'page'), kwargs))
        url = urlunsplit((None, None, url, query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)

    @classmethod
    def get_sent_messages(cls, http=None, **kwargs):
        url = '/direct_messages/sent.json'
        query = urlencode(filter(lambda x: x in ('since_id', 'page'), kwargs))
        url = urlunsplit((None, None, url, query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)


class UserList(ListObject):

    entries = fields.List(fields.Object(User))

    def __getitem__(self, key):
        return self.entries.__getitem__(key)

    @classmethod
    def get_friends(cls, http=None, **kwargs):
        return cls.get_related("friends", http=http, **kwargs)

    @classmethod
    def get_followers(cls, http=None, **kwargs):
        return cls.get_related("followers", http=http, **kwargs)

    @classmethod
    def get_related(cls, relation, http=None, **kwargs):
        url = '/statuses/%s' % relation
        if 'id' in kwargs:
            url += '/%s.json' % quote_plus(kwargs['id'])
        else:
            url += '.json'
        query = urlencode(filter(lambda x: x in ('screen_name', 'user_id', 'page'), kwargs))
        url = urlunsplit((None, None, url, query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)


class Timeline(ListObject):

    entries = fields.List(fields.Object(Status))

    def __getitem__(self, key):
        return self.entries.__getitem__(key)

    @classmethod
    def public(cls, http=None):
        return cls.get(urljoin(Twitter.endpoint, '/statuses/public_timeline.json'), http=http)

    @classmethod
    def friends(cls, http=None, **kwargs):
        query = urlencode(filter(lambda x: x in ('since_id', 'max_id', 'count', 'page'), kwargs))
        url = urlunsplit((None, None, '/statuses/friends_timeline.json', query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)

    @classmethod
    def user(cls, http=None, **kwargs):
        url = '/statuses/user_timeline'
        if 'id' in kwargs:
            url += '/%s.json' % quote_plus(kwargs['id'])
        else:
            url += '.json'
        query = urlencode(filter(lambda x: x in ('screen_name', 'user_id', 'since_id', 'max_id', 'page'), kwargs))
        url = urlunsplit((None, None, url, query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)

    @classmethod
    def mentions(cls, http=None, **kwargs):
        query = urlencode(filter(lambda x: x in ('since_id', 'max_id', 'page'), kwargs))
        url = urlunsplit((None, None, '/statuses/mentions.json', query, None))
        return cls.get(urljoin(Twitter.endpoint, url), http=http)


class Twitter(Http):

    """A user agent for interacting with Twitter.

    Instances of this class are full ``httplib2.Http`` HTTP user agent
    objects, but provide convenient convenience methods for interacting with
    Twitter and its data objects.

    """

    endpoint = 'http://twitter.com/'

    def public_timeline(self):
        return Timeline.public(http=self)

    def friends_timeline(self, **kwargs):
        return Timeline.friends(http=self, **kwargs)

    def user_timeline(self, **kwargs):
        return Timeline.user(http=self, **kwargs)

    def show(self, id):
        return Status.get_status(id, http=self)

    def user(self, id, **kwargs):
        return User.get_user(http=self, **kwargs)

    def mentions(self, **kwargs):
        return Timeline.mentions(http=self, **kwargs)

    def friends(self, **kwargs):
        return UserList.get_friends(http=self, **kwargs)

    def direct_messages_received(self, **kwargs):
        return DirectMessageList.get_messages(http=self, **kwargs)

    def direct_messages_sent(self, **kwargs):
        return DirectMessageList.get_messages_sent(http=self, **kwargs)


def show_public(twitter):
    print "## Public timeline ##"
    for tweet in twitter.public_timeline():
        print unicode(tweet)


def show_dms(twitter):
    print "## Direct messages sent to me ##"
    for dm in twitter.direct_messages_received():
        print unicode(dm)


def show_friends(twitter):
    print "## Tweets from my friends ##"
    for tweet in twitter.friends_timeline():
        print unicode(tweet)


def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = OptionParser()
    parser.add_option("-u", "--username", dest="username",
        help="name of user for authentication")
    parser.add_option("--public", action="store_const", const=show_public,
        dest="action", default=show_public,
        help="Show tweets from the public timeline")
    parser.add_option("--dms", action="store_const", const=show_dms,
        dest="action", help="Show DMs sent to you (requires -u)")
    parser.add_option("--friends", action="store_const", const=show_friends,
        dest="action", help="Show your friends' recent tweets (requires -u)")
    opts, args = parser.parse_args()

    twitter = Twitter()

    # We'll use regular HTTP authentication, so ask for a password and add
    # it in the regular httplib2 way.
    if opts.username is not None:
        password = raw_input("Password (will echo): ")
        twitter.add_credentials(opts.username, password)

    try:
        print
        opts.action(twitter)
        print
    except httplib.HTTPException, exc:
        # The API could be down, or the credentials on an auth-only request
        # could be wrong, so show the error to the end user.
        print >>sys.stderr, "Error making request: %s: %s" \
            % (type(exc).__name__, str(exc))
        return 1

    return 0


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = dataobject
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

`DataObject` is a class of object that provides coding between object
attributes and dictionaries, suitable for

In `DataObject` is the mechanism for converting between dictionaries and
objects. These conversions are performed with aid of `Field` instances
declared on `DataObject` subclasses. `Field` classes reside in the
`remoteobjects.field` module.

"""


from copy import deepcopy
import logging

import remoteobjects.fields


classes_by_name = {}
classes_by_constant_field = {}


def find_by_name(name):
    """Finds and returns the DataObject subclass with the given name.

    Parameter `name` should be a bare class name with no module. If there is
    no class by that name, raises `KeyError`.

    """
    return classes_by_name[name]


class DataObjectMetaclass(type):
    """Metaclass for `DataObject` classes.

    This metaclass installs all `remoteobjects.fields.Property` instances
    declared as attributes of the new class, including all `Field` and `Link`
    instances.

    This metaclass also makes the new class findable through the
    `dataobject.find_by_name()` function.

    """

    def __new__(cls, name, bases, attrs):
        """Creates and returns a new `DataObject` class with its declared
        fields and name."""
        fields = {}
        new_fields = {}
        new_properties = {}

        # Inherit all the parent DataObject classes' fields.
        for base in bases:
            if isinstance(base, DataObjectMetaclass):
                fields.update(base.fields)

        # Move all the class's attributes that are Fields to the fields set.
        for attrname, field in attrs.items():
            if isinstance(field, remoteobjects.fields.Property):
                new_properties[attrname] = field
                if isinstance(field, remoteobjects.fields.Field):
                    new_fields[attrname] = field
            elif attrname in fields:
                # Throw out any parent fields that the subclass defined as
                # something other than a Field.
                del fields[attrname]

        fields.update(new_fields)
        attrs['fields'] = fields
        obj_cls = super(DataObjectMetaclass, cls).__new__(cls, name, bases, attrs)

        for field, value in new_properties.items():
            obj_cls.add_to_class(field, value)

        # Register the new class so Object fields can have forward-referenced it.
        classes_by_name[name] = obj_cls

        # Tell this class's fields what this class is, so they can find their
        # forward references later.
        for field in new_properties.values():
            field.of_cls = obj_cls

        return obj_cls

    def add_to_class(cls, name, value):
        try:
            value.install(name, cls)
        except (NotImplementedError, AttributeError):
            setattr(cls, name, value)


class DataObject(object):

    """An object that can be decoded from or encoded as a dictionary.

    DataObject subclasses should be declared with their different data
    attributes defined as instances of fields from the `remoteobjects.fields`
    module. For example:

    >>> from remoteobjects import dataobject, fields
    >>> class Asset(dataobject.DataObject):
    ...     name    = fields.Field()
    ...     updated = fields.Datetime()
    ...     author  = fields.Object('Author')
    ...

    A DataObject's fields then provide the coding between live DataObject
    instances and dictionaries.

    """

    __metaclass__ = DataObjectMetaclass

    def __init__(self, **kwargs):
        """Initializes a new `DataObject` with the given field values."""
        self.api_data = {}
        self.__dict__.update(kwargs)

    def __eq__(self, other):
        """Returns whether two `DataObject` instances are equivalent.

        If the `DataObject` instances are of the same type and contain the
        same data in all their fields, the objects are equivalent.

        """
        if type(self) != type(other):
            return False
        for k, v in self.fields.iteritems():
            if isinstance(v, remoteobjects.fields.Field):
                if getattr(self, k) != getattr(other, k):
                    return False
        return True

    def __ne__(self, other):
        """Returns whether two `DataObject` instances are different.

        `DataObject` instances are different if they are not equivalent as
        determined through `__eq__()`.

        """
        return not self == other

    @classmethod
    def statefields(cls):
        return cls.fields.keys() + ['api_data']

    def __getstate__(self):
        return dict((k, self.__dict__[k]) for k in self.statefields()
            if k in self.__dict__)

    def get(self, attr, *args):
        return getattr(self, attr, *args)

    def __iter__(self):
        for key in self.fields.keys():
            yield key

    def to_dict(self):
        """Encodes the DataObject to a dictionary."""
        # Start with the last set of data we got from the API
        data = deepcopy(self.api_data)

        # Now replace the data with what's actually in our object
        for field_name, field in self.fields.iteritems():
            value = getattr(self, field.attrname, None)
            if value is not None:
                data[field.api_name] = field.encode(value)
            else:
                data[field.api_name] = None

        # Now delete any fields that ended up being None
        # since we should exclude them in the resulting dict.
        for k in data.keys():
            if data[k] is None:
                del data[k]

        return data

    @classmethod
    def from_dict(cls, data):
        """Decodes a dictionary into a new `DataObject` instance."""
        self = cls()
        self.update_from_dict(data)
        return self

    def update_from_dict(self, data):
        """Adds the content of a dictionary to this DataObject.

        Parameter `data` is the dictionary from which to update the object.

        Use this only when receiving newly updated or partial content for a
        DataObject; that is, when the data is from the outside data source and
        needs decoded through the object's fields. Data from "inside" your
        application should be added to an object manually by setting the
        object's attributes. Data that constitutes a new object should be
        turned into another object with `from_dict()`.

        """
        if not isinstance(data, dict):
            raise TypeError
        # Clear any local instance field data
        for k in self.fields.iterkeys():
            if k in self.__dict__:
                del self.__dict__[k]
        self.api_data = data

    @classmethod
    def subclass_with_constant_field(cls, fieldname, value):
        """Returns the closest subclass of this class that has a `Constant`
        field with the given value.

        Use this method in combination with the `fields.Constant` field class
        to find the most appropriate subclass of `cls` based on a content
        field. For example, if you have an ``Asset`` class, but want to
        declare subclasses with special behavior based on the ``kind`` field
        of the ``Asset`` instances, declare ``kind`` as a `Constant` field on
        each subclass. Then when you want to create a new ``Asset`` instance
        (as in ``Asset.from_dict()``), you can use this method to select a
        more appropriate class to instantiate.

        Parameters `fieldname` and `value` are the name and value of the
        `Constant` field for which to search respectively.

        If a subclass of `cls` has been declared with a `Constant` field of
        the given name and value, it will be returned. If multiple subclasses
        of `cls` declare a matching `Constant` field, one of the matching
        subclasses will be returned, but which subclass is not defined.

        """
        try:
            clsname = classes_by_constant_field[fieldname][tuple(value)]
        except KeyError:
            # No matching classes, then.
            pass
        else:
            return find_by_name(clsname)

        raise ValueError('No such subclass of %s with field %r equivalent to %r'
            % (cls.__name__, fieldname, value))

########NEW FILE########
__FILENAME__ = fields
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""

Fields are class attributes for `RemoteObject` subclasses that provide data
coding functionality for your properties.

The `remoteobjects.fields` module also provides functionality for other
field-like properties through the `Property` class, and a `Property` subclass
that offers links between `RemoteObject` instances, `Link`.

"""

from datetime import datetime, tzinfo, timedelta
import dateutil.parser
import logging
import time
import urlparse

import remoteobjects.dataobject


class Property(object):

    """An attribute that can be installed declaratively on a `DataObject` to
    provide data encoding or loading behavior.

    The primary kinds of `Property` objects are `Field` (and its subclasses)
    and `Link` objects.

    """

    def install(self, cls, attrname):
        """Signals to the `Property` that it has been installed on the given
        class as an attribute with the given name.

        This implementation does nothing. Override this method to customize
        the behavior to install an attribute on DataObject classes where your
        field is declared.

        """
        pass


class Field(Property):

    """A property for encoding object attributes as dictionary values and
    decoding dictionary values into object attributes.

    Declare a `Field` instance for each attribute of a `DataObject` that
    should be encoded to or decoded from a dictionary.

    Use a `Field` instance directly for simple `DataObject` attributes that
    can be the same type as their dictionary values. That is, use `Field`
    fields for strings, numbers, and boolean values. If your attribute data
    does need converted, use one of the `Field` subclasses from the
    `remoteobjects.fields` module to encode and decode your data as
    appropriate.

    If your attribute needs converted specially, override the `decode()` and
    `encode()` methods in a new subclass of `Field`. For example, the
    `fields.Datetime` subclass of `Field` encodes Python `datetime.datetime`
    instances in a dictionary as timestamp strings.

    """

    def __init__(self, api_name=None, default=None):
        """Sets the field's matching deserialization field and default value.

        Optional parameter `api_name` is the key of this field's matching
        value in a dictionary. If not given, the attribute name of the field
        when its class was defined is used. (The attribute of the object
        containing the decoded value will always be the attribute name of the
        field as declared.)

        Optional parameter `default` is the default value to use for this
        attribute when the dictionary to decode does not contain a value.
        `default` can be a value or callable function. If `default` is a
        callable function, it is called when a dictionary is decoded into an
        instance, is passed the object to decode into and the dictionary to
        decode from, and should return the default value of the attribute. As
        fields are processed in no particular order, a `default` function
        should not set the value itself, nor should it depend on values
        already decoded into the DataObject instance.

        Default values are *not* special when encoding an object, so those
        values will stick on `DataObject` instances that are saved and
        retrieved (such as `RemoteObject` instances).

        """
        self.api_name = api_name
        self.default  = default

    def install(self, attrname, cls):
        self.attrname = attrname
        if self.api_name is None:
            self.api_name = attrname
        # attrname has to be set before of_cls or Constant fields break.
        self.of_cls = cls

    def __get__(self, obj, cls):
        """Returns the field's value on the given object instance, or the
        field's default value if no value for the field is available.

        Note the field's value will be decoded from API data if necessary,
        raising any exceptions that the field's `decode()` method may raise.

        """
        if obj is None:
            # Yield the real field instance when gotten through the class.
            return self

        if self.attrname not in obj.__dict__:
            try:
                value = obj.api_data[self.api_name]
            except KeyError:
                if callable(self.default):
                    value = self.default(obj)
                else:
                    value = self.default
            else:
                value = self.decode(value)
            # Store the value so we need decode it only once.
            obj.__dict__[self.attrname] = value

        return obj.__dict__[self.attrname]

    def __set__(self, obj, value):
        obj.__dict__[self.attrname] = value

    def __delete__(self, obj):
        # Delete both the instance and API data, so we'll get a real
        # attribute miss next time and return the field's default.
        try:
            del obj.__dict__[self.attrname]
        except KeyError:
            pass

        try:
            del obj.api_data[self.api_name]
        except KeyError:
            pass

    def decode(self, value):
        """Decodes a dictionary value into a `DataObject` attribute value.

        This implementation returns the `value` parameter unchanged. This is
        generally only appropriate for strings, numbers, and boolean values.
        Use another `Field` class (or a custom `Field` implementation that
        overrides this method) if you need to convert objects.

        """
        return value

    def encode(self, value):
        """Encodes a `DataObject` attribute value into a dictionary value.

        This implementation returns the `value` parameter unchanged. This is
        generally only appropriate for strings, numbers, and boolean values.
        Use another `Field` class (or a custom `Field` implementation that
        overrides this method) if you need to convert objects.

        """
        return value


class Constant(Field):

    """A field for data that always has a certain value for all instances of
    the owning class.

    Use this field for an attribute of an object that is always the same for
    every instance of that class. For instance, if you define subclasses for a
    `DataObject` that represent different kinds of search results based on
    type, and there's a `type` field that says which class the result will be,
    use this field for the invariant `type` field with a different matching
    value for each subclass.

    """

    def __init__(self, value, **kwargs):
        """Sets the field's constant value to parameter `value`."""
        super(Constant, self).__init__(**kwargs)
        self.value = value

    def install(self, attrname, cls):
        """Records the class that owns this field.

        This implementation also registers the owning class by this constant
        field's value, so that `DataObject.subclass_with_constant_field()`
        will find this field's class.

        """
        super(Constant, self).install(attrname, cls)

        # Register class by this field.
        cf = remoteobjects.dataobject.classes_by_constant_field
        attrname, value = self.attrname, self.value
        if attrname not in cf:
            cf[attrname] = dict()
        cf[attrname][value] = cls.__name__

    def __get__(self, obj, cls):
        if obj is None:
            # Yield the real field instance when gotten through the class.
            return self
        # Since it's a constant, always return the same value.
        return self.value
    
    def __set__(self, obj, value):
        # If it's the correct value, do nothing. Else, raise an exception.
        if value != self.value:
            raise ValueError('Value %r is not expected value %r'
                % (value, self.value))

    def decode(self, value):
        if value != self.value:
            raise ValueError('Value %r is not expected value %r'
                % (value, self.value))
        return self.value

    def encode(self, value):
        # Don't even bother caring what we were given; it's our constant.
        return self.value


class List(Field):

    """A field representing a homogeneous list of data.

    The elements of the list are decoded through another field specified when
    the `List` is declared.

    """

    def __init__(self, fld, **kwargs):
        """Sets the type of field representing the content of the list.

        Parameter `fld` is another field instance representing the list's
        content. For instance, if the field were to represent a list of
        timestamps, `fld` would be a `Datetime` instance.

        """
        super(List, self).__init__(**kwargs)
        self.fld = fld

    def install(self, attrname, cls):
        super(List, self).install(attrname, cls)

        # Make sure our content field knows its owner too.
        self.fld.install(attrname, cls)

    def decode(self, value):
        """Decodes the dictionary value (a list of dictionary values) into a
        `DataObject` attribute (a list of `DataObject` attribute values)."""
        if value is None:
            if callable(self.default):
                return self.default()
            return self.default or None
        return [self.fld.decode(v) for v in value]

    def encode(self, value):
        """Encodes a `DataObject` attribute (a list of `DataObject` attribute
        values) into a dictionary value (a list of dictionary values)."""
        return [self.fld.encode(v) for v in value]


class Dict(List):

    """A field representing a homogeneous mapping of data.

    The elements of the mapping are decoded through another field specified
    when the `Dict` is declared.

    """

    def decode(self, value):
        """Decodes the dictionary value (a dictionary with dictionary values
        for values) into a `DataObject` attribute (a dictionary with
        `DataObject` attributes for values)."""
        if value is None:
            if callable(self.default):
                return self.default()
            return self.default or None
        return dict((k, self.fld.decode(v)) for k, v in value.iteritems())

    def encode(self, value):
        """Encodes a `DataObject` attribute (a dictionary with decoded
        `DataObject` attribute values for values) into a dictionary value (a
        dictionary with encoded dictionary values for values)."""
        return dict((k, self.fld.encode(v)) for k, v in value.iteritems())


class AcceptsStringCls(object):
    """Mixin for fields with a ``cls`` attribute that can either be a
    ``DataObject`` subclass or a string name of a ``DataObject`` subclass (to
    allow forward references)."""

    def get_cls(self):
        cls = self.__dict__['cls']
        if not callable(cls):
            cls = remoteobjects.dataobject.find_by_name(cls)
        return cls

    def set_cls(self, cls):
        self.__dict__['cls'] = cls

    cls = property(get_cls, set_cls)

class Object(AcceptsStringCls, Field):

    """A field representing a nested `DataObject`."""

    def __init__(self, cls, **kwargs):
        """Sets the the `DataObject` class the field represents.

        Parameter `cls` is the `DataObject` class representing the nested
        objects.

        `cls` may also be the name of a class, in which case the referenced
        class is the leafmost `DataObject` subclass declared with that name.
        This means you can not only forward-reference a class by specifying
        its name, but subclassing a `DataObject` class with the same name in
        another module will make all name-based `Object` fields reference the
        new subclass.

        """
        super(Object, self).__init__(**kwargs)
        self.cls = cls

    def decode(self, value):
        """Decodes the dictionary value into an instance of the `DataObject`
        class the field references."""
        if value is None:
            if callable(self.default):
                return self.default()
            return self.default
        return self.cls.from_dict(value)

    def encode(self, value):
        """Encodes an instance of the field's DataObject class into its
        representative dictionary value."""
        return value.to_dict()


class UTC(tzinfo):
    """UTC"""
    ZERO = timedelta(0)

    def utcoffset(self, dt):
        return UTC.ZERO

    def tzname(self, dt):
        return "UTC"

    def dst(self, dt):
        return UTC.ZERO


class Datetime(Field):

    """A field representing a timestamp."""

    dateformat = "%Y-%m-%dT%H:%M:%SZ"
    utc = UTC()

    def __init__(self, dateformat=None, **kwargs):
        super(Datetime, self).__init__(**kwargs)

    def decode(self, value):
        """Decodes a timestamp string into a `DataObject` attribute (a Python
        `datetime` instance).

        Timestamp strings should be of in valid ISO-8601 format, such as
        ``YYYY-MM-DDTHH:MM:SSZ``,  The resulting `datetime` will have UTC
        tzinfo.
        """
        if value is None:
            if callable(self.default):
                return self.default()
            return self.default
        try:
            # Use dateutil to handle parsing and TZ conversion
            return dateutil.parser.parse(value).astimezone(Datetime.utc)
        except (TypeError, ValueError):
            raise TypeError('Value to decode %r is not a valid date time stamp' % (value,))

    def encode(self, value):
        """Encodes a `DataObject` attribute (a Python `datetime` instance)
        into a timestamp string.

        The `datetime` instance should have no time zone set. Timestamp
        strings will be of the format ``YYYY-MM-DDTHH:MM:SSZ``.

        """
        if not isinstance(value, datetime):
            raise TypeError('Value to encode %r is not a datetime' % (value,))
        if value.tzinfo is not None:
            value = value.astimezone(Datetime.utc)
        return value.replace(microsecond=0).strftime(self.dateformat)


class Link(AcceptsStringCls, Property):

    """A `RemoteObject` property representing a link from one `RemoteObject`
    instance to another.

    Use this property when related content is not *part* of a RemoteObject,
    but is instead available at a URL relative to it. By default the target
    object's URL should be available at the property name relative to the
    owning instance's URL.

    For example:

    >>> class Item(RemoteObject):
    ...     feed = Link(Event)
    ...
    >>> i = Item.get('http://example.com/item/')
    >>> f = i.feed  # f's URL: http://example.com/item/feed

    Override the `__get__` method of a `Link` subclass to customize how the
    URLs to linked objects are constructed.

    """

    def __init__(self, cls, api_name=None, **kwargs):
        """Sets the `RemoteObject` class of the target resource and,
        optionally, the real relative URL of the resource.

        Optional parameter `api_name` is used as the link's relative URL. If
        not given, the name of the attribute to which the Link is assigned
        will be used.

        """
        self.cls = cls
        self.api_name = api_name
        super(Link, self).__init__(**kwargs)

    def install(self, attrname, cls):
        """Installs the `Link` instance as an attribute of the `RemoteObject`
        class in which it was declared."""
        self.of_cls = cls
        self.attrname = attrname
        if self.api_name is None:
            self.api_name = attrname

    def __get__(self, instance, owner):
        """Generates the RemoteObject for the target resource of this Link.

        By default, target resources are at a URL relative to the "parent"
        object's URL, named by the `api_name` attribute of the `Link`
        instance. Override this method to define some other strategy for
        building links for your target API.

        """
        if instance._location is None:
            raise AttributeError('Cannot find URL of %s relative to URL-less %s' % (self.cls.__name__, owner.__name__))
        newurl = urlparse.urljoin(instance._location, self.api_name)
        return self.cls.get(newurl)

########NEW FILE########
__FILENAME__ = http
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import simplejson as json
from remoteobjects.json import ForgivingDecoder

import httplib2
import httplib
import logging

from remoteobjects.dataobject import DataObject, DataObjectMetaclass
from remoteobjects import fields

userAgent = httplib2.Http()

log = logging.getLogger('remoteobjects.http')


def omit_nulls(data):
    """Strips `None` values from a dictionary or `RemoteObject` instance."""
    if not isinstance(data, dict):
        if not hasattr(data, '__dict__'):
            return str(data)
        data = dict(data.__dict__)
    for key in data.keys():
        if data[key] is None:
            del data[key]
    return data


class HttpObject(DataObject):

    """A `DataObject` that can be fetched and put over HTTP through a RESTful
    JSON API."""

    response_has_content = {
        httplib.OK:                True,
        httplib.ACCEPTED:          False,
        httplib.CREATED:           True,
        httplib.NO_CONTENT:        False,
        httplib.MOVED_PERMANENTLY: True,
        httplib.FOUND:             True,
        httplib.NOT_MODIFIED:      True,
    }

    location_headers = {
        httplib.OK:                'Content-Location',
        httplib.CREATED:           'Location',
        httplib.MOVED_PERMANENTLY: 'Location',
        httplib.FOUND:             'Location',
    }

    location_header_required = {
        httplib.CREATED:           True,
        httplib.MOVED_PERMANENTLY: True,
        httplib.FOUND:             True,
    }

    content_types = ('application/json',)

    class NotFound(httplib.HTTPException):
        """An HTTPException thrown when the server reports that the requested
        resource was not found."""
        pass

    class Unauthorized(httplib.HTTPException):
        """An HTTPException thrown when the server reports that the requested
        resource is not available through an unauthenticated request.

        This exception corresponds to the HTTP status code 401. Thus when this
        exception is received, the caller may need to try again using the
        available authentication credentials.

        """
        pass

    class Forbidden(httplib.HTTPException):
        """An HTTPException thrown when the server reports that the client, as
        authenticated, is not authorized to request the requested resource.

        This exception corresponds to the HTTP status code 403. Thus when this
        exception is received, nothing the caller (as currently authenticated) can
        do will make the requested resource available.

        """
        pass

    class PreconditionFailed(httplib.HTTPException):
        """An HTTPException thrown when the server reports that some of the
        conditions in a conditional request were not true.

        This exception corresponds to the HTTP status code 412. The most
        common cause of this status is an attempt to ``PUT`` a resource that
        has already changed on the server.

        """
        pass

    class RequestError(httplib.HTTPException):
        """An HTTPException thrown when the server reports an error in the
        client's request.

        This exception corresponds to the HTTP status code 400.
        
        """
        pass

    class ServerError(httplib.HTTPException):
        """An HTTPException thrown when the server reports an unexpected error.

        This exception corresponds to the HTTP status code 500.

        """
        pass

    class BadResponse(httplib.HTTPException):
        """An HTTPException thrown when the client receives some other
        non-success HTTP response."""
        pass

    def __init__(self, **kwargs):
        self._location = None
        super(HttpObject, self).__init__(**kwargs)

    @classmethod
    def statefields(cls):
        return super(HttpObject, cls).statefields() + ['_location', '_etag']

    def get_request(self, url=None, headers=None, **kwargs):
        """Returns the parameters for requesting this `RemoteObject` instance
        as a dictionary of keyword arguments suitable for passing to
        `httplib2.Http.request()`.

        Optional parameter `headers` are also included in the request as HTTP
        headers. Other optional keyword parameters are also included as
        specified.

        """
        if url is None:
            url = self._location
        if headers is None:
            headers = {}
        if 'accept' not in headers:
            headers['accept'] = ', '.join(self.content_types)

        # Use 'uri' because httplib2.request does.
        request = dict(uri=url, headers=headers)
        request.update(kwargs)
        return request

    @classmethod
    def raise_for_response(cls, url, response, content):
        """Raises exceptions corresponding to invalid HTTP responses that
        instances of this class can't be updated from.

        Override this method to customize the error handling behavior of
        `RemoteObject` for your target API. For example, if your API illegally
        omits ``Location`` headers from 201 Created responses, override this
        method to check for and allow them.

        """
        # Turn exceptional httplib2 responses into exceptions.
        classname = cls.__name__
        if response.status == httplib.NOT_FOUND:
            raise cls.NotFound('No such %s %s' % (classname, url))
        if response.status == httplib.UNAUTHORIZED:
            raise cls.Unauthorized('Not authorized to fetch %s %s' % (classname, url))
        if response.status == httplib.FORBIDDEN:
            raise cls.Forbidden('Forbidden from fetching %s %s' % (classname, url))
        if response.status == httplib.PRECONDITION_FAILED:
            raise cls.PreconditionFailed('Precondition failed for %s request to %s' % (classname, url))

        if response.status in (httplib.INTERNAL_SERVER_ERROR, httplib.BAD_REQUEST):
            if response.status == httplib.BAD_REQUEST:
                err_cls = cls.RequestError
            else:
                err_cls = cls.ServerError
            # Pull out an error if we can.
            content_type = response.get('content-type', '').split(';', 1)[0].strip()
            if content_type == 'text/plain':
                error = content.split('\n', 2)[0]
                exc = err_cls('%d %s requesting %s %s: %s'
                    % (response.status, response.reason, classname, url,
                       error))
                exc.response_error = error
                raise exc
            raise err_cls('%d %s requesting %s %s'
                % (response.status, response.reason, classname, url))

        try:
            response_has_content = cls.response_has_content[response.status]
        except KeyError:
            # we only expect the statuses that we know do or don't have content
            raise cls.BadResponse('Unexpected response requesting %s %s: %d %s'
                % (classname, url, response.status, response.reason))

        try:
            location_header = cls.location_headers[response.status]
        except KeyError:
            pass
        else:
            if cls.location_header_required.get(response.status) and location_header.lower() not in response:
                raise cls.BadResponse(
                    "%r header missing from %d %s response requesting %s %s"
                    % (location_header, response.status, response.reason,
                       classname, url))

        if not response_has_content:
            # then there's no content-type either, so we're done
            return

        # check that the response body was json
        content_type = response.get('content-type', '').split(';', 1)[0].strip()
        if content_type not in cls.content_types:
            raise cls.BadResponse(
                'Bad response fetching %s %s: content-type %s is not an expected type'
                % (classname, url, response.get('content-type')))

    def update_from_response(self, url, response, content):
        """Adds the content of this HTTP response and message body to this
        `RemoteObject` instance.

        Use `update_from_response()` only when you would use
        `DataObject.update_from_dict()`: when decoding outside content (in
        this case an HTTP response) into an existing `RemoteObject` instance.

        If the response is not a successful response from which the
        `RemoteObject` instance can be updated, an appropriate exception will
        be raised (as determined by the instance's `raise_from_response()`
        method).

        If the response includes a new location URL in the appropriate header
        (depending on the response status), the location of the `RemoteObject`
        instance is updated as well.

        """
        self.raise_for_response(url, response, content)

        if self.response_has_content.get(response.status):
            try:
                data = json.loads(content)
            except UnicodeDecodeError:
                data = json.loads(content, cls=ForgivingDecoder)

            self.update_from_dict(data)

        location_header = self.location_headers.get(response.status)
        if location_header is None:
            self._location = url
        elif self.location_header_required.get(response.status):
            self._location = response[location_header.lower()]
        else:
            self._location = response.get(location_header.lower(), url)

        if 'etag' in response:
            self._etag = response['etag']

    @classmethod
    def get(cls, url, http=None, **kwargs):
        """Fetches a new `RemoteObject` instance from a URL.

        Parameter `url` is the URL from which the object should be requested.
        Optional parameter `http` is the user agent object to use for
        fetching. `http` should be compatible with `httplib2.Http` instances.

        """
        self = cls()
        request = self.get_request(url=url, **kwargs)

        if http is None:
            http = userAgent
        response, content = http.request(**request)

        self.update_from_response(url, response, content)
        return self

    def post(self, obj, http=None):
        """Add another `RemoteObject` to this remote resource through an HTTP
        ``POST`` request.

        Parameter `obj` is a `RemoteObject` instance to save to this
        instance's resource. For example, this (`self`) may be a collection to
        which you want to post an asset (`obj`).

        Optional parameter `http` is the user agent object to use for posting.
        `http` should be compatible with `httplib2.Http` objects.

        """
        if getattr(self, '_location', None) is None:
            raise ValueError('Cannot add %r to %r with no URL to POST to'
                % (obj, self))

        body = json.dumps(obj.to_dict(), default=omit_nulls)

        headers = {'content-type': self.content_types[0]}

        request = obj.get_request(url=self._location, method='POST',
            body=body, headers=headers)
        if http is None:
            http = userAgent
        response, content = http.request(**request)

        obj.update_from_response(self._location, response, content)

    def put(self, http=None):
        """Save a previously requested `RemoteObject` back to its remote
        resource through an HTTP ``PUT`` request.

        Optional `http` parameter is the user agent object to use. `http`
        objects should be compatible with `httplib2.Http` objects.

        """
        if getattr(self, '_location', None) is None:
            raise ValueError('Cannot save %r with no URL to PUT to' % self)

        body = json.dumps(self.to_dict(), default=omit_nulls)

        headers = {}
        if hasattr(self, '_etag') and self._etag is not None:
            headers['if-match'] = self._etag
        headers['content-type'] = self.content_types[0]

        request = self.get_request(method='PUT', body=body, headers=headers)
        if http is None:
            http = userAgent
        response, content = http.request(**request)

        log.debug('Yay saved my obj, now turning %r into new content', content)
        self.update_from_response(self._location, response, content)

    def delete(self, http=None):
        """Delete the remote resource represented by the `RemoteObject`
        instance through an HTTP ``DELETE`` request.

        Optional parameter `http` is the user agent object to use. `http`
        objects should be compatible with `httplib2.Http` objects.

        """
        if getattr(self, '_location', None) is None:
            raise ValueError('Cannot delete %r with no URL to DELETE' % self)

        headers = {}
        if hasattr(self, '_etag') and self._etag is not None:
            headers['if-match'] = self._etag

        request = self.get_request(method='DELETE', headers=headers)
        if http is None:
            http = userAgent
        response, content = http.request(**request)

        self.raise_for_response(self._location, response, content)

        log.debug('Yay deleted the remote resource, now disconnecting %r from it', self)

        # No more resource, no more URL.
        self._location = None
        try:
            del self._etag
        except AttributeError:
            # Don't mind if there's no etag.
            pass

    def head(self, http=None):
        """Issues a HTTP ``HEAD`` request for the object.

        Optional parameter `http` is the user agent object to use. `http`
        objects should be compatible with `httplib2.Http` objects.

        """
        if getattr(self, '_location', None) is None:
            raise ValueError('Cannot issue HEAD for %r with no URL' % self)

        if http is None:
            http = userAgent
        response, content = http.request(uri=self._location, method='HEAD')

        return response

    def options(self, http=None):
        """Issues a HTTP ``OPTIONS`` request for the object.

        Optional parameter `http` is the user agent object to use. `http`
        objects should be compatible with `httplib2.Http` objects.

        This method returns both the `HttpResponse` and content data.

        """
        if getattr(self, '_location', None) is None:
            raise ValueError('Cannot issue OPTIONS for %r with no URL' % self)

        if http is None:
            http = userAgent
        response, content = http.request(uri=self._location, method='OPTIONS')

        return response

########NEW FILE########
__FILENAME__ = json
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from simplejson import JSONDecoder
from simplejson.decoder import FLAGS, BACKSLASH, STRINGCHUNK, DEFAULT_ENCODING
from simplejson.scanner import py_make_scanner
import re


# Truly heinous... we are going to the trouble of reproducing this
# entire routine, because we need to supply an errors="replace"
# keyword argument at the point this function invokes unicode().
def forgiving_scanstring(s, end, encoding=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):
    """Scan the string s for a JSON string. End is the index of the
    character in s after the quote that started the JSON string.
    Unescapes all valid JSON string escape sequences and raises ValueError
    on attempt to decode an invalid string. If strict is False then literal
    control characters are allowed in the string.
    
    Returns a tuple of the decoded string and the index of the character in s
    after the end quote."""
    if encoding is None:
        encoding = DEFAULT_ENCODING
    chunks = []
    _append = chunks.append
    begin = end - 1
    while 1:
        chunk = _m(s, end)
        if chunk is None:
            raise ValueError(
                errmsg("Unterminated string starting at", s, begin))
        end = chunk.end()
        content, terminator = chunk.groups()
        # Content is contains zero or more unescaped string characters
        if content:
            if not isinstance(content, unicode):
                content = unicode(content, encoding, errors="replace")
            _append(content)
        # Terminator is the end of string, a literal control character,
        # or a backslash denoting that an escape sequence follows
        if terminator == '"':
            break
        elif terminator != '\\':
            if strict:
                msg = "Invalid control character %r at" % (terminator,)
                #msg = "Invalid control character {0!r} at".format(terminator)
                raise ValueError(errmsg(msg, s, end))
            else:
                _append(terminator)
                continue
        try:
            esc = s[end]
        except IndexError:
            raise ValueError(
                errmsg("Unterminated string starting at", s, begin))
        # If not a unicode escape sequence, must be in the lookup table
        if esc != 'u':
            try:
                char = _b[esc]
            except KeyError:
                msg = "Invalid \\escape: " + repr(esc)
                raise ValueError(errmsg(msg, s, end))
            end += 1
        else:
            # Unicode escape sequence
            esc = s[end + 1:end + 5]
            next_end = end + 5
            if len(esc) != 4:
                msg = "Invalid \\uXXXX escape"
                raise ValueError(errmsg(msg, s, end))
            uni = int(esc, 16)
            # Check for surrogate pair on UCS-4 systems
            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:
                msg = "Invalid \\uXXXX\\uXXXX surrogate pair"
                if not s[end + 5:end + 7] == '\\u':
                    raise ValueError(errmsg(msg, s, end))
                esc2 = s[end + 7:end + 11]
                if len(esc2) != 4:
                    raise ValueError(errmsg(msg, s, end))
                uni2 = int(esc2, 16)
                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))
                next_end += 6
            char = unichr(uni)
            end = next_end
        # Append the unescaped character
        _append(char)
    return u''.join(chunks), end


class ForgivingDecoder(JSONDecoder):
    def __init__(self, *args, **kwargs):
        super(ForgivingDecoder, self).__init__(*args, **kwargs)
        self.parse_string = forgiving_scanstring
        self.scan_once = py_make_scanner(self)

########NEW FILE########
__FILENAME__ = listobject
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from urlparse import urljoin, urlparse, urlunparse
import cgi
import inspect
import sys
import urllib

import remoteobjects.fields as fields
from remoteobjects.dataobject import find_by_name
from remoteobjects.promise import PromiseObject, PromiseError


class SequenceProxy(object):

    """An abstract class implementing the sequence protocol by proxying it to
    an instance attribute.

    `SequenceProxy` instances act like sequences by forwarding all sequence
    method calls to their `entries` attributes. The `entries` attribute should
    be a list or some other that implements the sequence protocol.

    """

    def make_sequence_method(methodname):
        """Makes a new function that proxies calls to `methodname` to the
        `entries` attribute of the instance on which the function is called as
        an instance method."""
        def seqmethod(self, *args, **kwargs):
            # Proxy these methods to self.entries.
            return getattr(self.entries, methodname)(*args, **kwargs)
        seqmethod.__name__ = methodname
        return seqmethod

    __len__      = make_sequence_method('__len__')
    __getitem__  = make_sequence_method('__getitem__')
    __setitem__  = make_sequence_method('__setitem__')
    __delitem__  = make_sequence_method('__delitem__')
    __iter__     = make_sequence_method('__iter__')
    __reversed__ = make_sequence_method('__reversed__')
    __contains__ = make_sequence_method('__contains__')


class OfOf(type):

    class _Module(object):
        pass

    def __new__(cls, name, bases, attr):
        modulename = attr['_modulename']
        sys.modules[modulename] = cls._Module()

        attr['_subclasses'] = {}
        attr['_basemodule'] = None

        return type.__new__(cls, name, bases, attr)


class PageOf(PromiseObject.__metaclass__):

    """Metaclass defining a `PageObject` containing a set of some other
    class's instances.

    Unlike most metaclasses, this metaclass can be called directly to define
    new `PageObject` classes that contain objects of a specified other class,
    like so:

    >>> PageOfEntry = PageOf(Entry)

    This is equivalent to defining ``PageOfEntry`` yourself:

    >>> class PageOfEntry(PageObject):
    ...     entryclass = Entry

    which is a `PageObject` of ``Entry`` instances.

    """

    __metaclass__ = OfOf

    _modulename = 'remoteobjects.listobject._pages'

    def __new__(cls, name, bases=None, attr=None):
        """Creates a new `PageObject` subclass.

        If `bases` and `attr` are specified, as in a regular subclass
        declaration, a new class is created as per the specified settings.

        If only `name` is specified, that value is used as a reference to a
        `RemoteObject` class to which the new `PageObject` class is bound.
        The `name` parameter can be either a name or a `RemoteObject` class,
        as when declaring a `remoteobjects.fields.Object` field.

        """
        direct = attr is None
        if direct:
            # Don't bother making a new subclass if we already made one for
            # this target.
            if name in cls._subclasses:
                return cls._subclasses[name]

            entryclass = name
            if callable(entryclass):
                name = cls.__name__ + entryclass.__name__
            else:
                name = cls.__name__ + entryclass

            bases = (cls._basemodule,)

            attr = {
                'entries': fields.List(fields.Object(entryclass)),
            }

        newcls = super(PageOf, cls).__new__(cls, name, bases, attr)

        # Save the result for later direct invocations.
        if direct:
            cls._subclasses[entryclass] = newcls
            newcls.__module__ = cls._modulename
            setattr(sys.modules[cls._modulename], name, newcls)
        elif cls._basemodule is None:
            cls._basemodule = newcls

        return newcls


class PageObject(SequenceProxy, PromiseObject):

    """A `RemoteObject` representing a set of other `RemoteObject` instances.

    Endpoints in APIs are often not objects themselves but lists of objects.

    As with regular `PromiseObject` instances, `PageObject` instances can be
    filtered by parameters that are then passed to your target API, such as a
    list of recent objects or a search. Filtering a `PageObject` instance by a
    parameter returns a new copy of that `PageObject` instance that includes
    the new parameter.

    The contents of regular `PageObject` instances will be decoded as with
    `Field` fields; that is, not decoded at all. To customize decoding of API
    contents, subclass `PageObject` and redefine the ``entries`` member with a
    `Field` instance that decodes the list content as necessary.

    As many API endpoints are sets of objects, to create a `PageObject`
    subclass for those endpoints, you can directly call its metaclass,
    `PageOf`, with the class reference you would use to construct an `Object`
    field. That is, these declarations are equivalent:

    >>> PageOfEntry = PageOf(Entry)

    >>> class PageOfEntry(PageObject):
    ...     entries = fields.List(fields.Object(Entry))

    For an ``Entry`` list you then fetch with the `PageOfEntry` class's
    `get()` method, all the entities in the list resource's `entries` member
    will be decoded into ``Entry`` instances.

    """

    __metaclass__ = PageOf

    entries = fields.List(fields.Field())

    def __getitem__(self, key):
        """Translates slice notation on a `ListObject` instance into ``limit``
        and ``offset`` filter parameters."""
        if isinstance(key, slice):
            args = dict()
            if key.start is not None:
                args['offset'] = key.start
                if key.stop is not None:
                    args['limit'] = key.stop - key.start
            elif key.stop is not None:
                args['limit'] = key.stop
            return self.filter(**args)

        try:
            getitem = super(PageObject, self).__getitem__
        except AttributeError:
            raise TypeError("'%s' object is unsubscriptable except by slices"
                % (type(self).__name__,))
        else:
            return getitem(key)


class ListOf(PageOf):

    _modulename = 'remoteobjects.listobject._lists'


class ListObject(PageObject):

    __metaclass__ = ListOf

    def update_from_dict(self, data):
        super(ListObject, self).update_from_dict({ 'entries': data })

    def to_dict(self):
        return super(ListObject, self).to_dict()['entries']

########NEW FILE########
__FILENAME__ = promise
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import urlparse
import urllib
import cgi

import httplib
import httplib2

import remoteobjects.http
from remoteobjects.fields import Property


class PromiseError(Exception):
    """An exception representing an error promising or delivering a
    `PromiseObject` instance."""
    pass


class PromisedResponse(httplib2.Response):
    def __init__(self, *args, **kwargs):
        self._delivered = True
        self._location = None
        self._http = None
        self._method = None
        super(PromisedResponse, self).__init__(*args, **kwargs)

    def __getattribute__(self, attr, *args):
        if (attr not in ('deliver', 'get_request', 'update_from_response')) and (attr.find('_') != 0):
            if not self._delivered:
                self.deliver()
        return super(PromisedResponse, self).__getattribute__(attr, *args)

    def deliver(self):
        """Attempts to fill the instance with the data it represents.

        If the instance has already been delivered or the instance has no URL
        from which to fetch data, `deliver()` raises a `PromiseError`. Other
        exceptions from requesting and decoding a `RemoteObject` that might
        normally result from a `RemoteObject.get()` may also be thrown.

        """
        if self._delivered:
            raise PromiseError('%s instance %r has already been delivered' % (type(self).__name__, self))
        if self._location is None:
            raise PromiseError('Instance %r has no URL from which to deliver' % (self,))

        http = self._http
        if self._http is None:
            http = remoteobjects.http.userAgent

        request = self.get_request()
        response, content = http.request(**request)
        self.update_from_response(request['uri'], response, content)

    def get_request(self, url=None, headers=None, **kwargs):
        """Returns the parameters for requesting this `RemoteObject` instance
        as a dictionary of keyword arguments suitable for passing to
        `httplib2.Http.request()`.

        Optional parameter `headers` are also included in the request as HTTP
        headers. Other optional keyword parameters are also included as
        specified.

        """
        if url is None:
            url = self._location
        if headers is None:
            headers = {}

        # Use 'uri' because httplib2.request does.
        request = dict(uri=url, headers=headers, method=self._method)
        request.update(kwargs)
        return request

    def update_from_response(self, url, response, content=''):
        self._delivered = True
        super(PromisedResponse, self).__init__(response)

    def found(self):
        """Returns True when the HTTP is in the 200-299 range."""
        return 300 > self.status >= 200

    def can_delete(self):
        try:
            return self['allow'].find('DELETE') > -1
        except KeyError:
            return False


class PromiseObject(remoteobjects.http.HttpObject):
    """A `RemoteObject` that delays actual retrieval of the remote resource until
    required by the use of its data.

    A PromiseObject is only "promised" to the caller until its data is used.
    When the caller tries to use attributes that should have data in them from
    the remote resource, only *then* is the resource actually fetched.

    """

    def __init__(self, **kwargs):
        """Initializes a delivered, empty `PromiseObject`."""
        self._delivered = True
        self._http = None
        super(PromiseObject, self).__init__(**kwargs)

    def _get_api_data(self):
        if not self._delivered:
            self.deliver()
        return self.__dict__['api_data']

    def _set_api_data(self, value):
        self.__dict__['api_data'] = value

    def _del_api_data(self):
        del self.__dict__['api_data']

    api_data = property(_get_api_data, _set_api_data, _del_api_data)

    @classmethod
    def statefields(cls):
        return super(PromiseObject, cls).statefields() + ['_delivered']

    @classmethod
    def get(cls, url, http=None, **kwargs):
        """Creates a new undelivered `PromiseObject` instance that, when
        delivered, will contain the data at the given URL."""
        # Make a fake empty instance of this class.
        self = cls()
        self._location = url
        self._http = http
        self._delivered = False
        self._get_kwargs = kwargs

        return self

    def head(self, http=None, **kwargs):
        """Creates a new undelivered `PromisedResponse` instance that, when
        delivered, will contain the HTTP Response for the given object."""

        resp = PromisedResponse({})
        resp._delivered = False
        resp._location = self._location
        resp._http = http
        resp._method = 'HEAD'
        return resp

    def options(self, http=None, **kwargs):
        """Creates a new undelivered `PromisedResponse` instance that, when
        delivered, will contain the HTTP Response for the given object."""

        resp = PromisedResponse({})
        resp._delivered = False
        resp._location = self._location
        resp._http = http
        resp._method = 'OPTIONS'
        return resp

    def __setattr__(self, name, value):
        if name is not '_delivered' and not self._delivered and name in self.fields:
            self.deliver()
        return super(PromiseObject, self).__setattr__(name, value)

    def __delattr__(self, name):
        if name is not '_delivered' and not self._delivered and name in self.fields:
            self.deliver()
        return super(PromiseObject, self).__delattr__(name)

    def deliver(self):
        """Attempts to fill the instance with the data it represents.

        If the instance has already been delivered or the instance has no URL
        from which to fetch data, `deliver()` raises a `PromiseError`. Other
        exceptions from requesting and decoding a `RemoteObject` that might
        normally result from a `RemoteObject.get()` may also be thrown.

        """
        if self._delivered:
            raise PromiseError('%s instance %r has already been delivered' % (type(self).__name__, self))
        if self._location is None:
            raise PromiseError('Instance %r has no URL from which to deliver' % (self,))

        http = self._http
        if self._http is None:
            http = remoteobjects.http.userAgent

        request = self.get_request(**self._get_kwargs)
        response, content = http.request(**request)
        self.update_from_response(request['uri'], response, content)

    def update_from_dict(self, data):
        if not isinstance(data, dict):
            raise TypeError("Cannot update %r from non-dictionary data source %r"
                % (self, data))
        # Clear any local instance field data
        for k in self.fields.iterkeys():
            if k in self.__dict__:
                del self.__dict__[k]
        # Update directly to avoid triggering delivery.
        self.__dict__['api_data'] = data

    def update_from_response(self, url, response, content):
        """Fills the `PromiseObject` instance with the data from the given
        HTTP response and if successful marks the instance delivered."""
        super(PromiseObject, self).update_from_response(url, response, content)
        # Any updating from a response constitutes delivery.
        self._delivered = True

    def filter(self, **kwargs):
        """Returns a new undelivered `PromiseObject` instance, equivalent to
        this `PromiseObject` instance but further filtered by the given
        keyword parameters.

        By default, all filter parameters are added as parameters to the
        `PromiseObject` instance's query string.

        If your endpoint takes only certain parameters, or accepts parameters
        in some way other than query parameters in the URL, override this
        method to build the URL and return the new `PromiseObject` instance as
        you require.

        """
        parts = list(urlparse.urlparse(self._location))
        queryargs = cgi.parse_qs(parts[4], keep_blank_values=True)
        queryargs = dict([(k, v[0]) for k, v in queryargs.iteritems()])
        queryargs.update(kwargs)
        parts[4] = urllib.urlencode(queryargs)
        newurl = urlparse.urlunparse(parts)

        return self.get(newurl, http=self._http)

########NEW FILE########
__FILENAME__ = extra_dataobject
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from remoteobjects import fields, dataobject

class Referencive(dataobject.DataObject):
    related = fields.Object('Related')
    other   = fields.Object('OtherRelated')

class Related(dataobject.DataObject):
    pass

class OtherRelated(dataobject.DataObject):
    pass

########NEW FILE########
__FILENAME__ = benchmark_decoding
#!/usr/bin/env python

# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""
This will benchmark remoteobjects decoding speed. It will decode the JSON data
you specify as the first argument into the remoteobject subclass you specify as
the second argument. The decode process is run as many times as you specify (via
the -n flag). The raw times to decode the JSON data will be dumped to stdout.
"""

import optparse
import time
import remoteobjects
import mox

from tests import utils


def test_decoding(object_class, json, count):
    request = {
        'uri': 'http://example.com/ohhai',
        'headers': {'accept': 'application/json'},
    }
    h = utils.mock_http(request, json)

    # warm up remoteobjects
    o = object_class.get('http://example.com/ohhai', http=h)
    o.deliver()

    for _ in xrange(count):
        h = utils.mock_http(request, json)

        t = time.time()
        o = object_class.get('http://example.com/ohhai', http=h)
        o.deliver()
        yield (time.time() - t)


if __name__ == '__main__':
    parser = optparse.OptionParser(
        usage="%prog [options] json_file remoteobject_class",
        description=("Test the performance of decoding JSON into remoteobjects."))
    parser.add_option("-n", action="store", type="int", default=100,
                      dest="num_runs", help="Number of times to run the test.")
    options, args = parser.parse_args()

    if len(args) != 2:
        parser.error("Incorrect number of arguments")

    try:
        fd = open(args[0])
        json = fd.read()
    except:
        parser.error("Unable to read file: '%s'" % args[1])
    finally:
        fd.close()

    module_name, _, class_name = args[1].rpartition('.')
    try:
        module = __import__(module_name)
    except ImportError, e:
        parser.error(e.message)

    try:
        RemoteObject = getattr(module, class_name)
    except AttributeError, e:
        parser.error(e.message)

    for t in test_decoding(RemoteObject, json, options.num_runs):
        print t

########NEW FILE########
__FILENAME__ = twiddle
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from remoteobjects import RemoteObject, fields

class Frob(RemoteObject):
    kind = fields.Constant("tag:api.example.com,2009;Frobnitz")
    name = fields.Field()
    size = fields.Field()
    attr = fields.Dict(fields.Field())

class Zot(RemoteObject):
    kind = fields.Constant("tag:api.example.com,2009;Zot")
    size = fields.Field()
    born = fields.Datetime()

class Twiddle(RemoteObject):
    kind = fields.Constant("tag:api.example.com,2009;Twiddle")
    name = fields.Field()
    frob = fields.Object(Frob, api_name="frobnitz")
    zotz = fields.List(fields.Object(Zot))

########NEW FILE########
__FILENAME__ = test_dataobject
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from datetime import datetime, timedelta, tzinfo
import logging
import pickle
import sys
import unittest

import mox

from remoteobjects import fields, dataobject
from tests import utils


class TestDataObjects(unittest.TestCase):

    cls = dataobject.DataObject

    def test_basic(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        b = BasicMost.from_dict({ 'name': 'foo', 'value': '4' })
        self.assert_(b, 'from_dict() returned something True')
        self.assertEquals(b.name, 'foo', 'from_dict() result has correct name')
        self.assertEquals(b.value, '4', 'from_dict() result has correct value')

        b = BasicMost(name='bar', value='47').to_dict()
        self.assert_(b, 'to_dict() returned something True')
        self.assertEquals({ 'name': 'bar', 'value': '47' }, b, 'Basic dict has proper contents')

        self.assertEquals(BasicMost.__name__, 'BasicMost',
            "metaclass magic didn't break our class's name")

        bm = BasicMost(name='fred', value=2)
        bm.api_data = {"name": "fred", "value": 2}
        bm_dict = bm.to_dict()
        self.assertEquals({ 'name': 'fred', 'value': 2 }, bm_dict, 'First go-round has proper contents')
        bm.name = 'tom'
        bm_dict = bm.to_dict()
        self.assertEquals({ 'name': 'tom', 'value': 2 }, bm_dict, 'Setting name to another string works')
        bm.name = None
        bm_dict = bm.to_dict()
        self.assertEquals({ 'value': 2 }, bm_dict, 'Setting name to None works, and name is omitted in the dict')

    def test_descriptorwise(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        b = BasicMost()
        b.name = 'hi'
        self.assertEquals(b.name, 'hi')

        del b.name
        self.assert_(b.name is None)

    def test_types(self):

        class WithTypes(self.cls):
            name  = fields.Field()
            value = fields.Field()
            when  = fields.Datetime()

        w = WithTypes.from_dict({
            'name': 'foo',
            'value': 4,
            'when': '2008-12-31T04:00:01Z',
        })
        self.assert_(w, 'from_dict returned something True')
        self.assertEquals(w.name, 'foo', 'Typething got the right name')
        self.assertEquals(w.value, 4, 'Typething got the right value')
        self.assertEquals(w.when, datetime(2008, 12, 31, 4, 0, 1,
            tzinfo=fields.Datetime.utc),
            'Typething got something like the right when')

        w = WithTypes.from_dict({
            'name': 'bar',
            'value': 99,
            'when': '2012-08-17T14:49:50-05:00'
        })

        self.assertEquals(w.when, datetime(2012, 8, 17, 19, 49, 50,
            tzinfo=fields.Datetime.utc),
            'Non-UTC timezone was parsed and converted to UTC')

        w = WithTypes.from_dict({
            'when': '2012-13-01T24:01:01-05:00'
        })

        try:
            w.when
            self.fail('No TypeError parsing invalid, well-formatted timestamp')
        except TypeError:
            pass
        except Exception:
            self.fail('No TypeError parsing invalid, well-formatted timestamp')

        w = WithTypes.from_dict({
            'when': 'pack my bag with six dozen liquor jugs'
        })

        try:
            w.when
            self.fail('No TypeError parsing malformatted timestamp')
        except TypeError:
            pass
        except Exception:
            self.fail('No TypeError parsing malformatted timestamp')

        w = WithTypes(name='hi', value=99, when=datetime(2009, 2, 3, 10, 44, 0, tzinfo=None)).to_dict()
        self.assert_(w, 'to_dict() returned something True')
        self.assertEquals(w, { 'name': 'hi', 'value': 99, 'when': '2009-02-03T10:44:00Z' },
            'Typething dict has proper contents')

    def test_must_ignore(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        b = BasicMost.from_dict({
            'name':   'foo',
            'value':  '4',
            'secret': 'codes',
        })

        self.assert_(b)
        self.assert_(b.name)
        self.assertRaises(AttributeError, lambda: b.secret)

        d = b.to_dict()
        self.assert_('name' in d)
        self.assert_('secret' in d)
        self.assertEquals(d['secret'], 'codes')

        d['blah'] = 'meh'
        d = b.to_dict()
        self.assert_('blah' not in d)

        x = BasicMost.from_dict({
            'name':  'foo',
            'value': '4',
        })
        self.assertNotEqual(id(b), id(x))
        self.assert_(x)
        self.assert_(x.name)

        x.update_from_dict({ 'secret': 'codes' })
        self.assertRaises(AttributeError, lambda: x.secret)

        d = x.to_dict()
        self.assert_('name' not in d)
        self.assert_('secret' in d)
        self.assertEquals(d['secret'], 'codes')

    def test_spooky_action(self):
        """Tests that an instance's content can't be changed through the data
        structures it was created with, or a data structure pulled out of
        it."""

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        initial = {
            'name': 'foo',
            'value': '4',
            'secret': {
                'code': 'uuddlrlrba'
            },
        }
        x = BasicMost.from_dict(initial)

        initial['name'] = 'bar'
        self.assertEquals(x.name, 'bar',
            "Changing initial data does change instance's "
            "internal data")

        initial['secret']['code'] = 'steak'
        d = x.to_dict()
        self.assertEquals(d['secret']['code'], 'steak',
            "Changing deep hidden initial data *does* change instance's "
            "original data for export")

        d['name'] = 'baz'
        self.assertEquals(x.name, 'bar',
            "Changing shallow exported data doesn't change instance's "
            "internal data retroactively")

        d['secret']['code'] = 'walt sent me'
        self.assertEquals(x.to_dict()['secret']['code'], 'steak',
            "Changing deep exported data doesn't change instance's "
            "internal data retroactively")

    def test_strong_types(self):

        class Blah(self.cls):
            name = fields.Field()

        class WithTypes(self.cls):
            name  = fields.Field()
            value = fields.Field()
            when  = fields.Datetime()
            bleh  = fields.Object(Blah)

        testobj = WithTypes.from_dict({
            'name':  'foo',
            'value': 4,
            'when':  'magenta',
            'bleh':  {'name': 'what'},
        })

        self.assertRaises(TypeError, lambda: testobj.when)
        self.assert_(testobj.bleh, 'Accessing properly formatted subobject raises no exceptions')

        testobj = WithTypes.from_dict({
            'name':  'foo',
            'value': 4,
            'when':  '2008-12-31T04:00:01Z',
            'bleh':  True,
        })

        self.assert_(testobj.when, 'Accessing properly formatted datetime attribute raises no exceptions')
        self.assertRaises(TypeError, lambda: testobj.bleh)

    def test_complex(self):

        class Childer(self.cls):
            name = fields.Field()

        class Parentish(self.cls):
            name     = fields.Field()
            children = fields.List(fields.Object(Childer))

        p = Parentish.from_dict({
            'name': 'the parent',
            'children': [
                { 'name': 'fredina' },
                { 'name': 'billzebub' },
                { 'name': 'wurfledurf' },
            ],
        })

        self.assert_(p, 'from_dict() returned something True for a parent')
        self.assertEquals(p.name, 'the parent', 'parent has correct name')
        self.assert_(p.children, 'parent has some children')
        self.assert_(isinstance(p.children, list), 'children set is a Python list')
        self.assertEquals(len(p.children), 3, 'parent has 3 children')
        f, b, w = p.children
        self.assert_(isinstance(f, Childer), "parent's first child is a Childer")
        self.assert_(isinstance(b, Childer), "parent's twoth child is a Childer")
        self.assert_(isinstance(w, Childer), "parent's third child is a Childer")
        self.assertEquals(f.name, 'fredina', "parent's first child is named fredina")
        self.assertEquals(b.name, 'billzebub', "parent's twoth child is named billzebub")
        self.assertEquals(w.name, 'wurfledurf', "parent's third child is named wurfledurf")

        childs = Childer(name='jeff'), Childer(name='lisa'), Childer(name='conway')
        p = Parentish(name='molly', children=childs).to_dict()
        self.assert_(p, 'to_dict() returned something True')
        self.assertEquals(p, {
            'name': 'molly',
            'children': [
                { 'name': 'jeff' },
                { 'name': 'lisa' },
                { 'name': 'conway' },
            ],
        }, 'Parentish dict has proper contents')

        p = Parentish.from_dict({
            'name': 'the parent',
            'children': None
        })

        self.assertEquals(p.children, None)

    def test_complex_dict(self):

        class Thing(self.cls):
            name     = fields.Field()
            attributes = fields.Dict(fields.Field())

        t = Thing.from_dict({
            'name': 'the thing',
            'attributes': None,
        })

        self.assertEquals(t.attributes, None)


    def test_self_reference(self):

        class Reflexive(self.cls):
            itself     = fields.Object('Reflexive')
            themselves = fields.List(fields.Object('Reflexive'))

        r = Reflexive.from_dict({
            'itself': {},
            'themselves': [ {}, {}, {} ],
        })

        self.assert_(r)
        self.assert_(isinstance(r, Reflexive))
        self.assert_(isinstance(r.itself, Reflexive))
        self.assert_(isinstance(r.themselves[0], Reflexive))

    def test_post_reference(self):

        from tests import extra_dataobject

        class Referencive(extra_dataobject.Referencive):
            pass

        class Related(extra_dataobject.Related):
            pass

        class NotRelated(extra_dataobject.OtherRelated):
            pass

        r = Referencive.from_dict({ 'related': {}, 'other': {} })

        self.assert_(isinstance(r, Referencive))
        self.assert_(isinstance(r.related, Related))  # not extra_dataobject.Related
        self.assert_(isinstance(r.other,   extra_dataobject.OtherRelated))  # not NotRelated

        r = extra_dataobject.Referencive.from_dict({ 'related': {}, 'other': {} })

        self.assert_(isinstance(r, extra_dataobject.Referencive))
        self.assert_(isinstance(r.related, Related))  # not extra_dataobject.Related
        self.assert_(isinstance(r.other,   extra_dataobject.OtherRelated))  # not NotRelated

    def set_up_pickling_class(self):
        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        # Simulate a special module for this BasicMost, so pickle can find
        # the class for it.
        pickletest_module = mox.MockAnything()
        pickletest_module.BasicMost = BasicMost
        # Note this pseudomodule has no file, so coverage doesn't get a mock
        # method by mistake.
        pickletest_module.__file__ = None
        BasicMost.__module__ = 'remoteobjects._pickletest'
        sys.modules['remoteobjects._pickletest'] = pickletest_module

        return BasicMost

    def test_pickling(self):

        BasicMost = self.set_up_pickling_class()

        obj = BasicMost(name='fred', value=7)

        pickled_obj = pickle.dumps(obj)
        self.assert_(pickled_obj)
        unpickled_obj = pickle.loads(pickled_obj)
        self.assertEquals(unpickled_obj, obj)

        obj = BasicMost.from_dict({'name': 'fred', 'value': 7})

        cloned_obj = pickle.loads(pickle.dumps(obj))
        self.assert_(cloned_obj)
        self.assert_(hasattr(cloned_obj, 'api_data'), "unpickled instance has api_data too")
        self.assertEquals(cloned_obj.api_data, obj.api_data,
            "unpickled instance kept original's api_data")

    def test_field_override(self):

        class Parent(dataobject.DataObject):
            fred = fields.Field()
            ted  = fields.Field()

        class Child(Parent):
            ted = fields.Datetime()

        self.assert_('fred' in Child.fields, 'Child class inherited the fred field')
        self.assert_('ted'  in Child.fields, 'Child class has a ted field (from somewhere')
        self.assert_(isinstance(Child.fields['ted'], fields.Datetime),
            'Child class has overridden ted field, yay')

    def test_field_api_name(self):

        class WeirdNames(dataobject.DataObject):
            normal    = fields.Field()
            fooBarBaz = fields.Field(api_name='foo-bar-baz')
            xyzzy     = fields.Field(api_name='plugh')

        w = WeirdNames.from_dict({
            'normal': 'asfdasf',
            'foo-bar-baz': 'wurfledurf',
            'plugh':       'http://en.wikipedia.org/wiki/Xyzzy#Poor_password_choice',
        })

        self.assertEquals(w.normal,    'asfdasf', 'normal value carried through')
        self.assertEquals(w.fooBarBaz, 'wurfledurf', 'fbb value carried through')
        self.assertEquals(w.xyzzy,     'http://en.wikipedia.org/wiki/Xyzzy#Poor_password_choice',
            'xyzzy value carried through')

        w = WeirdNames(normal='gloing', fooBarBaz='grumdabble', xyzzy='slartibartfast')
        d = w.to_dict()

        self.assert_(d, 'api_named to_dict() returned something True')
        self.assertEquals(d, {
            'normal':      'gloing',
            'foo-bar-baz': 'grumdabble',
            'plugh':       'slartibartfast',
        }, 'WeirdNames dict has proper contents')

    def test_field_default(self):

        global cheezCalled
        cheezCalled = False

        def cheezburgh(obj):
            self.assert_(isinstance(obj, WithDefaults))
            global cheezCalled
            cheezCalled = True
            return 'CHEEZBURGH'

        class WithDefaults(dataobject.DataObject):
            plain               = fields.Field()
            itsAlwaysSomething  = fields.Field(default=7)
            itsUsuallySomething = fields.Field(default=cheezburgh)

        w = WithDefaults.from_dict({
            'plain': 'awesome',
            'itsAlwaysSomething': 'haptics',
            'itsUsuallySomething': 'omg hi',
        })

        self.assertEquals(w.plain, 'awesome')
        self.assertEquals(w.itsAlwaysSomething, 'haptics')
        self.assertEquals(w.itsUsuallySomething, 'omg hi')
        self.failIf(cheezCalled)

        for x in (WithDefaults.from_dict({}), WithDefaults()):
            self.assert_(x.plain is None)
            self.assertEquals(x.itsAlwaysSomething, 7)
            self.assertEquals(x.itsUsuallySomething, 'CHEEZBURGH')
            self.assert_(cheezCalled)

        d = WithDefaults().to_dict()
        self.assert_('plain' not in d)
        self.assertEquals(d['itsAlwaysSomething'], 7)
        self.assertEquals(d['itsUsuallySomething'], 'CHEEZBURGH')

    def test_field_constant(self):

        noninconstant = 'liono'

        class WithConstant(dataobject.DataObject):
            alwaysTheSame = fields.Constant(noninconstant)

        d = WithConstant().to_dict()
        self.assertEquals(d['alwaysTheSame'], noninconstant)

        x = WithConstant()
        self.assertEquals(x.alwaysTheSame, noninconstant)

        try:
            x.alwaysTheSame = 'snarf'
        except ValueError:
            pass
        else:
            self.fail('Set Constant field to invalid value.')
        x.alwaysTheSame = noninconstant

        # Just to make sure
        self.assertEquals(x.alwaysTheSame, noninconstant)

    def test_field_link(self):

        class Frob(dataobject.DataObject):
            blerg = fields.Field()

        class WithLink(dataobject.DataObject):
            link = fields.Link(Frob)

        x = WithLink()
        x.link = Frob()
        # Links don't serialize... for now anyways.
        self.assertEquals(x.to_dict(), {})

    def test_forwards_link(self):
        class Foo(dataobject.DataObject):
            link = fields.Link('Bar')

        class Bar(dataobject.DataObject):
            thing = fields.Field()

        # The string class name should be converted to the class
        self.assertEquals(Foo.__dict__["link"].cls, Bar)

    def test_field_datetime(self):

        class Timely(dataobject.DataObject):
            when = fields.Datetime()

        t = Timely.from_dict({
            'when': '2008-12-31T04:00:01Z',
        })

        self.assert_(isinstance(t, Timely), 'Datetime class decoded properly')
        self.assert_(isinstance(t.when, datetime), 'Datetime data decoded into a datetime')
        when = datetime(year=2008, month=12, day=31, hour=4, minute=0, second=1,
                tzinfo=fields.Datetime.utc)
        self.assertEquals(t.when, when, 'Datetime data decoded into the expected datetime')
        self.assert_(t.when.tzinfo is fields.Datetime.utc, 
                'Datetime data decoded with utc timezone info')

        when = datetime(year=2010, month=2, day=11, hour=4, minute=37, second=44)
        t_data = Timely(when=when).to_dict()
        self.assert_(isinstance(t_data, dict), 'Datetime dict encoded properly')
        self.assertEquals(t_data['when'], '2010-02-11T04:37:44Z', 'Datetime dict encoded with expected timestamp')

        when = datetime(year=2010, month=2, day=11, hour=4, minute=37,
                second=44, tzinfo=fields.Datetime.utc)
        t_data = Timely(when=when).to_dict()
        self.assert_(isinstance(t_data, dict), 'Datetime dict with UTC tzinfo encoded properly')
        self.assertEquals(t_data['when'], '2010-02-11T04:37:44Z', 'Datetime dict encoded with expected timestamp')

        class EST(tzinfo):

            def utcoffset(self, dt):
                return timedelta(hours=-5)

            def tzname(self, dt):
                return "UTC"

            def dst(self, dt):
                return timedelta(0)

        when = datetime(year=2010, month=2, day=10, hour=23, minute=37,
                second=44, tzinfo=EST())
        t_data = Timely(when=when).to_dict()
        self.assert_(isinstance(t_data, dict), 'Datetime dict with non-UTC tzinfo encoded properly')
        self.assertEquals(t_data['when'], '2010-02-11T04:37:44Z', 'Datetime dict encoded with expected timestamp')

        t = Timely.from_dict({
            'when': None,
        })
        self.assert_(isinstance(t, Timely), 'Datetime with None data decoded properly')
        self.assert_(t.when is None, 'Datetime with None data decoded to None timestamp')

        t = Timely.from_dict({})
        self.assert_(isinstance(t, Timely), 'Datetime with missing data decoded properly')
        self.assert_(t.when is None, 'Datetime with missing data decoded to None timestamp')


if __name__ == '__main__':
    utils.log()
    unittest.main()

########NEW FILE########
__FILENAME__ = test_http
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from datetime import datetime
import logging
import sys
import unittest

import mox

from remoteobjects import fields, http
from tests import test_dataobject
from tests import utils


# Ensure DataObject API is preserved.
class TestDataObjects(test_dataobject.TestDataObjects):

    cls = http.HttpObject


class TestHttpObjects(unittest.TestCase):

    cls = http.HttpObject

    def test_get(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        request = {
            'uri': 'http://example.com/ohhai',
            'headers': {'accept': 'application/json', 'x-test': 'boo'},
        }
        content = """{"name": "Fred", "value": 7}"""

        h = utils.mock_http(request, content)
        b = BasicMost.get('http://example.com/ohhai', http=h,
                          headers={"x-test": "boo"})
        self.assertEquals(b.name, 'Fred')
        self.assertEquals(b.value, 7)
        mox.Verify(h)

    def test_get_bad_encoding(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        request = {
            'uri': 'http://example.com/ohhai',
            'headers': {'accept': 'application/json'},
        }
        content = """{"name": "Fred\xf1", "value": "image by \xefrew Example"}"""

        h = utils.mock_http(request, content)
        b = BasicMost.get('http://example.com/ohhai', http=h)
        self.assertEquals(b.name, u"Fred\ufffd")
        # Bad characters are replaced with the unicode Replacement Character 0xFFFD.
        self.assertEquals(b.value, u"image by \ufffdrew Example")
        mox.Verify(h)

    def test_post(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        class ContainerMost(self.cls):
            name = fields.Field()

        request = {
            'uri': 'http://example.com/asfdasf',
            'headers': {'accept': 'application/json'},
        }
        content = """{"name": "CBS"}"""
        h = utils.mock_http(request, content)
        c = ContainerMost.get('http://example.com/asfdasf', http=h)
        self.assertEquals(c.name, 'CBS')
        mox.Verify(h)

        b = BasicMost(name='Fred Friendly', value=True)

        headers = {
            'accept': 'application/json',
            'content-type': 'application/json',
        }
        content = """{"name": "Fred Friendly", "value": true}"""
        request = dict(uri='http://example.com/asfdasf', method='POST',
                       body=content, headers=headers)
        response = dict(content=content, status=201, etag='xyz',
                        location='http://example.com/fred')
        h = utils.mock_http(request, response)
        c.post(b, http=h)
        mox.Verify(h)

        self.assertEquals(b._location, 'http://example.com/fred')
        self.assertEquals(b._etag, 'xyz')

    def test_put(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        b = BasicMost()
        self.assertRaises(ValueError, lambda: b.put())

        request = {
            'uri': 'http://example.com/bwuh',
            'headers': {'accept': 'application/json'},
        }
        content = """{"name": "Molly", "value": 80}"""
        h = utils.mock_http(request, content)
        b = BasicMost.get('http://example.com/bwuh', http=h)
        self.assertEquals(b.name, 'Molly')
        mox.Verify(h)

        headers = {
            'accept':       'application/json',
            'content-type': 'application/json',
            'if-match':     '7',  # default etag
        }
        request  = dict(uri='http://example.com/bwuh', method='PUT', headers=headers, body=content)
        response = dict(content=content, etag='xyz')
        h = utils.mock_http(request, response)
        b.put(http=h)
        mox.Verify(h)

        self.assertEquals(b._etag, 'xyz')

    def test_put_no_content(self):
        """
        Don't try to update from a no-content response.

        """

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        request = {
            'uri': 'http://example.com/bwuh',
            'headers': {'accept': 'application/json'},
        }
        content = """{"name": "Molly", "value": 80}"""
        h = utils.mock_http(request, content)
        b = BasicMost.get('http://example.com/bwuh', http=h)
        self.assertEquals(b.name, 'Molly')
        mox.Verify(h)

        headers = {
            'accept':       'application/json',
            'content-type': 'application/json',
            'if-match': '7',
        }
        request  = dict(uri='http://example.com/bwuh', method='PUT', headers=headers, body=content)
        response = dict(content="", status=204)
        h = utils.mock_http(request, response)
        b.put(http=h)
        mox.Verify(h)

        self.assertEquals(b.name, 'Molly')

    def test_put_failure(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        request = {
            'uri': 'http://example.com/bwuh',
            'headers': {'accept': 'application/json'},
        }
        content = """{"name": "Molly", "value": 80}"""
        h = utils.mock_http(request, content)
        b = BasicMost.get('http://example.com/bwuh', http=h)
        self.assertEquals(b.value, 80)
        mox.Verify(h)

        b.value = 'superluminal'

        headers = {
            'accept':       'application/json',
            'content-type': 'application/json',
            'if-match':     '7',  # default etag
        }
        content = """{"name": "Molly", "value": "superluminal"}"""
        request = dict(uri='http://example.com/bwuh', method='PUT',
                       body=content, headers=headers)
        # Simulate a changed resource.
        response = dict(status=412)
        h = utils.mock_http(request, response)
        self.assertRaises(BasicMost.PreconditionFailed, lambda: b.put(http=h))
        mox.Verify(h)

    def test_delete(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        b = BasicMost()
        self.assertRaises(ValueError, lambda: b.put())

        request = {
            'uri': 'http://example.com/bwuh',
            'headers': {'accept': 'application/json'},
        }
        content = """{"name": "Molly", "value": 80}"""
        h = utils.mock_http(request, content)
        b = BasicMost.get('http://example.com/bwuh', http=h)
        self.assertEquals(b.value, 80)
        mox.Verify(h)

        headers = {
            'accept':   'application/json',
            'if-match': '7',  # default etag
        }
        request  = dict(uri='http://example.com/bwuh', method='DELETE', headers=headers)
        response = dict(status=204)
        h = utils.mock_http(request, response)
        b.delete(http=h)
        mox.Verify(h)

        self.failIf(b._location is not None)
        self.failIf(hasattr(b, '_etag'))

    def test_delete_failure(self):

        class BasicMost(self.cls):
            name  = fields.Field()
            value = fields.Field()

        b = BasicMost(name='Molly', value=80)
        b._location = 'http://example.com/bwuh'
        b._etag = 'asfdasf'

        headers = {
            'accept':   'application/json',
            'if-match': 'asfdasf',
        }
        request  = dict(uri='http://example.com/bwuh', method='DELETE', headers=headers)
        response = dict(status=412)  # Precondition Failed

        h = utils.mock_http(request, response)
        self.assertRaises(BasicMost.PreconditionFailed, lambda: b.delete(http=h))
        mox.Verify(h)

    def test_not_found(self):
        self.assert_(self.cls.NotFound)

        class Huh(self.cls):
            name = fields.Field()

        self.assert_(Huh.NotFound)

        request = {
            'uri': 'http://example.com/bwuh',
            'headers': {'accept': 'application/json'},
        }
        response = {'content': '', 'status': 404}
        http = utils.mock_http(request, response)
        self.assertRaises(Huh.NotFound, lambda: Huh.get('http://example.com/bwuh', http=http).name)
        mox.Verify(http)

    @utils.todo
    def test_not_found_discrete(self):
        """Checks that the NotFound exceptions for different HttpObjects are
        really different classes, so you can catch them discretely and treat
        different unfound objects differently, like:

        >>> try:
        ...     h = Huh.get(huh_url)
        ...     w = What.get(what_url)
        ... except Huh.NotFound:
        ...     # oops, no Huh
        ... except What.NotFound:
        ...     # oops, no What

        This feature is not implemented.

        """

        class Huh(self.cls):
            pass

        class What(self.cls):
            pass

        def try_that(http):
            try:
                What.get('http://example.com/bwuh', http=http)
            # Let through What.NotFound only if it's not equivalent to Huh.NotFound.
            except Huh.NotFound:
                pass

        request = {
            'uri': 'http://example.com/bwuh',
            'headers': {'accept': 'application/json'},
        }
        response = dict(status=404)
        http = utils.MockedHttp(request, response)
        self.assertRaises(What.NotFound, lambda: try_that(http))
        mox.Verify(http)


if __name__ == '__main__':
    utils.log()
    unittest.main()

########NEW FILE########
__FILENAME__ = test_listobject
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import unittest

import httplib2
import mox

from remoteobjects import fields, http, promise, listobject
from tests import test_dataobject, test_http
from tests import utils


class TestPageObjects(unittest.TestCase):

    cls = listobject.PageObject

    def test_slice_filter(self):

        class Toybox(self.cls):
            pass

        h = mox.MockObject(httplib2.Http)
        mox.Replay(h)

        b = Toybox.get('http://example.com/foo', http=h)
        self.assertEquals(b._location, 'http://example.com/foo')

        j = b[0:10]
        self.assert_(isinstance(j, Toybox))
        self.assertEquals(j._location, 'http://example.com/foo?limit=10&offset=0')

        j = b[300:370]
        self.assert_(isinstance(j, Toybox))
        self.assertEquals(j._location, 'http://example.com/foo?limit=70&offset=300')

        j = b[1:]
        self.assert_(isinstance(j, Toybox))
        self.assertEquals(j._location, 'http://example.com/foo?offset=1')

        j = b[:10]
        self.assert_(isinstance(j, Toybox))
        self.assertEquals(j._location, 'http://example.com/foo?limit=10')

        # Nobody did any HTTP, right?
        mox.Verify(h)

    def test_index(self):

        class Toybox(self.cls):
            pass

        url = 'http://example.com/whahay'
        headers = {"accept": "application/json"}
        request = dict(uri=url, headers=headers)
        content = """{"entries":[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}"""
        h = utils.mock_http(request, content)
        mox.Replay(h)

        b = Toybox.get('http://example.com/whahay', http=h)
        self.assertEqual(b[7], 7)

        mox.Verify(h)        

########NEW FILE########
__FILENAME__ = test_promise
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import unittest

import httplib2
import mox

from remoteobjects import fields, http, promise
from tests import test_dataobject, test_http
from tests import utils


class TestDataObjects(test_dataobject.TestDataObjects):

    cls = promise.PromiseObject


class TestHttpObjects(test_http.TestHttpObjects):

    cls = promise.PromiseObject


class TestPromiseObjects(unittest.TestCase):

    cls = promise.PromiseObject

    def test_basic(self):

        class Tiny(self.cls):
            name = fields.Field()

        h = mox.MockObject(httplib2.Http)
        mox.Replay(h)

        url = 'http://example.com/whahay'
        t = Tiny.get(url, http=h)

        # Check that we didn't do anything.
        mox.Verify(h)

        headers = {"accept": "application/json"}
        request = dict(uri=url, headers=headers)
        content = """{"name": "Mollifred"}"""
        h = utils.mock_http(request, content)
        t._http = h  # inject, oops
        self.assertEquals(t.name, 'Mollifred')
        mox.Verify(h)

    def test_filter(self):

        class Toy(self.cls):
            name = fields.Field()

        h = mox.MockObject(httplib2.Http)
        mox.Replay(h)

        b = Toy.get('http://example.com/foo', http=h)
        self.assertEquals(b._location, 'http://example.com/foo')

        x = b.filter(limit=10, offset=7)
        self.assert_(x is not b)
        self.assertEquals(b._location, 'http://example.com/foo')
        self.assertEquals(x._location, 'http://example.com/foo?limit=10&offset=7')

        y = b.filter(awesome='yes')
        self.assertEquals(y._location, 'http://example.com/foo?awesome=yes')
        y = y.filter(awesome='no')
        self.assertEquals(y._location, 'http://example.com/foo?awesome=no')

        # Nobody did any HTTP, right?
        mox.Verify(h)

    def test_awesome(self):

        class Toy(self.cls):
            name = fields.Field()

        class Room(self.cls):
            toybox = fields.Link(Toy)

        r = Room.get('http://example.com/bwuh/')
        b = r.toybox
        self.assert_(isinstance(b, Toy))
        self.assertEquals(b._location, 'http://example.com/bwuh/toybox')

    def test_set_before_delivery(self):

        class Toy(self.cls):
            names = fields.List(fields.Field())
            foo = fields.Field()

        url = 'http://example.com/whahay'
        headers = {"accept": "application/json"}
        request = dict(uri=url, headers=headers)
        content = """{"names": ["Mollifred"], "foo":"something"}"""
        h = utils.mock_http(request, content)

        # test case where attribute is assigned to object ahead of delivery
        t = Toy.get(url, http=h)
        t.names = ["New name"]
        d = t.to_dict() # this delivers the object

        # self.assertEquals(t.foo, "something")
        self.assertEquals(d['names'][0], "New name")
        self.assertEquals(t.names[0], "New name")

        h = utils.mock_http(request, content)
        # test case where we update_from_dict explictly after setting attributes
        t = Toy.get(url, http=h)
        t.foo = "local change"
        t.update_from_dict({"names": ["local update"]})

        self.assertEquals(t.foo, None)

########NEW FILE########
__FILENAME__ = test_remoteobject
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from remoteobjects import RemoteObject
from tests import test_dataobject, test_http, test_promise


class TestDataObjects(test_dataobject.TestDataObjects):

    cls = RemoteObject


class TestHttpObjects(test_http.TestHttpObjects):

    cls = RemoteObject


class TestPromiseObjects(test_promise.TestPromiseObjects):

    cls = RemoteObject

########NEW FILE########
__FILENAME__ = utils
# Copyright (c) 2009-2010 Six Apart Ltd.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Six Apart Ltd. nor the names of its contributors may
#   be used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import httplib2
import logging
import os

import mox
import nose
import nose.tools


def todo(fn):
    @nose.tools.make_decorator(fn)
    def test_reverse(*args, **kwargs):
        try:
            fn(*args, **kwargs)
        except:
            pass
        else:
            raise AssertionError('test %s unexpectedly succeeded' % fn.__name__)
    return test_reverse


def mock_http(req, resp_or_content):
    mock = mox.MockObject(httplib2.Http)

    if not isinstance(req, dict):
        req = dict(uri=req)

    def make_response(response, url):
        default_response = {
            'status':           200,
            'etag':             '7',
            'content-type':     'application/json',
            'content-location': url,
        }

        if isinstance(response, dict):
            if 'content' in response:
                content = response['content']
                del response['content']
            else:
                content = ''

            status = response.get('status', 200)
            if 200 <= status < 300:
                response_info = dict(default_response)
                response_info.update(response)
            else:
                # Homg all bets are off!! Use specified headers only.
                response_info = dict(response)
        else:
            response_info = dict(default_response)
            content = response

        return httplib2.Response(response_info), content

    resp, content = make_response(resp_or_content, req['uri'])
    mock.request(**req).AndReturn((resp, content))
    mox.Replay(mock)
    return mock


def log():
    import sys
    logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format="%(asctime)s %(levelname)s %(message)s")

########NEW FILE########
