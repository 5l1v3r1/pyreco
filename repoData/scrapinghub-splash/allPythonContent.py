__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Splash documentation build configuration file, created by
# sphinx-quickstart on Fri Apr 25 10:45:59 2014.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Splash'
copyright = u'2014, Scrapinghub'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Splashdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'Splash.tex', u'Splash Documentation',
   u'Scrapinghub', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'splash', u'Splash Documentation',
     [u'Scrapinghub'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Splash', u'Splash Documentation',
   u'Scrapinghub', 'Splash', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = cache
# -*- coding: utf-8 -*-
from __future__ import absolute_import
from PyQt4.QtNetwork import QNetworkDiskCache
from twisted.python import log
from splash import defaults


def construct(path=defaults.CACHE_PATH, size=defaults.CACHE_SIZE):
    log.msg("Initializing cache on %s (maxsize: %d Mb)" % (path, size))
    cache = QNetworkDiskCache()
    cache.setCacheDirectory(path)
    cache.setMaximumCacheSize(size * 1024**2)
    cache.cacheSize()  # forces immediate initialization
    return cache

########NEW FILE########
__FILENAME__ = defaults

# timeouts
TIMEOUT = 30
WAIT_TIME = 0.0

MAX_TIMEOUT = 60.0
MAX_WAIT_TIME = 10.0

# png rendering options
VIEWPORT = '1024x768'
VIEWPORT_FALLBACK = VIEWPORT  # do not set it to 'full'
VIEWPORT_MAX_WIDTH = 20000
VIEWPORT_MAX_HEIGTH = 20000
VIEWPORT_MAX_AREA = 4000*4000

MAX_WIDTH = 1920
MAX_HEIGTH = 1080

# defaults for render.json endpoint
DO_HTML = 0
DO_IFRAMES = 0
DO_PNG = 0
SHOW_SCRIPT = 0
SHOW_CONSOLE = 0

# servers
SPLASH_PORT = 8050
PROXY_PORT = 8051
MANHOLE_PORT = 5023
MANHOLE_USERNAME = 'admin'
MANHOLE_PASSWORD = 'admin'

# pool options
SLOTS = 50
CACHE_ENABLED = False
CACHE_SIZE = 50  # MB
CACHE_PATH = '.splash-cache'

# JS rendering options
JS_CROSS_DOMAIN_ENABLED = False

########NEW FILE########
__FILENAME__ = network_manager
# -*- coding: utf-8 -*-
from __future__ import absolute_import
import re
from PyQt4.QtCore import QUrl
from PyQt4.QtNetwork import QNetworkAccessManager, QNetworkProxyQuery, QNetworkReply
from PyQt4.QtWebKit import QWebFrame
from splash.utils import getarg
from twisted.python import log


# See: http://pyqt.sourceforge.net/Docs/PyQt4/qnetworkreply.html#NetworkError-enum
REQUEST_ERRORS = {
    QNetworkReply.NoError : 'no error condition. Note: When the HTTP protocol returns a redirect no error will be reported. You can check if there is a redirect with the QNetworkRequest::RedirectionTargetAttribute attribute.',
    QNetworkReply.ConnectionRefusedError : 'the remote server refused the connection (the server is not accepting requests)',
    QNetworkReply.RemoteHostClosedError : 'the remote server closed the connection prematurely, before the entire reply was received and processed',
    QNetworkReply.HostNotFoundError : 'the remote host name was not found (invalid hostname)',
    QNetworkReply.TimeoutError : 'the connection to the remote server timed out',
    QNetworkReply.OperationCanceledError : 'the operation was canceled via calls to abort() or close() before it was finished.',
    QNetworkReply.SslHandshakeFailedError : 'the SSL/TLS handshake failed and the encrypted channel could not be established. The sslErrors() signal should have been emitted.',
    QNetworkReply.TemporaryNetworkFailureError : 'the connection was broken due to disconnection from the network, however the system has initiated roaming to another access point. The request should be resubmitted and will be processed as soon as the connection is re-established.',
    QNetworkReply.ProxyConnectionRefusedError : 'the connection to the proxy server was refused (the proxy server is not accepting requests)',
    QNetworkReply.ProxyConnectionClosedError : 'the proxy server closed the connection prematurely, before the entire reply was received and processed',
    QNetworkReply.ProxyNotFoundError : 'the proxy host name was not found (invalid proxy hostname)',
    QNetworkReply.ProxyTimeoutError : 'the connection to the proxy timed out or the proxy did not reply in time to the request sent',
    QNetworkReply.ProxyAuthenticationRequiredError : 'the proxy requires authentication in order to honour the request but did not accept any credentials offered (if any)',
    QNetworkReply.ContentAccessDenied : 'the access to the remote content was denied (similar to HTTP error 401)',
    QNetworkReply.ContentOperationNotPermittedError : 'the operation requested on the remote content is not permitted',
    QNetworkReply.ContentNotFoundError : 'the remote content was not found at the server (similar to HTTP error 404)',
    QNetworkReply.AuthenticationRequiredError : 'the remote server requires authentication to serve the content but the credentials provided were not accepted (if any)',
    QNetworkReply.ContentReSendError : 'the request needed to be sent again, but this failed for example because the upload data could not be read a second time.',
    QNetworkReply.ProtocolUnknownError : 'the Network Access API cannot honor the request because the protocol is not known',
    QNetworkReply.ProtocolInvalidOperationError : 'the requested operation is invalid for this protocol',
    QNetworkReply.UnknownNetworkError : 'an unknown network-related error was detected',
    QNetworkReply.UnknownProxyError : 'an unknown proxy-related error was detected',
    QNetworkReply.UnknownContentError : 'an unknown error related to the remote content was detected',
    QNetworkReply.ProtocolFailure : 'a breakdown in protocol was detected (parsing error, invalid or unexpected responses, etc.)',
}

class SplashQNetworkAccessManager(QNetworkAccessManager):
    """
    This QNetworkAccessManager subclass enables "splash proxy factories"
    support. Qt provides similar functionality via setProxyFactory method,
    but standard QNetworkProxyFactory is not flexible enough.
    """

    def __init__(self):
        super(SplashQNetworkAccessManager, self).__init__()
        self.sslErrors.connect(self._sslErrors)
        self.finished.connect(self._finished)

        assert self.proxyFactory() is None, "Standard QNetworkProxyFactory is not supported"

    def _sslErrors(self, reply, errors):
        reply.ignoreSslErrors()

    def _finished(self, reply):
        reply.deleteLater()

    def createRequest(self, operation, request, outgoingData=None):
        old_proxy = self.proxy()

        splash_proxy_factory = self._getSplashProxyFactory(request)
        if splash_proxy_factory:
            proxy_query = QNetworkProxyQuery(request.url())
            proxy = splash_proxy_factory.queryProxy(proxy_query)[0]
            self.setProxy(proxy)

        # this method is called createRequest, but in fact it creates a reply
        reply = super(SplashQNetworkAccessManager, self).createRequest(
            operation, request, outgoingData
        )

        reply.error.connect(self._handle_error)
        self.setProxy(old_proxy)
        return reply

    def _getSplashRequest(self, request):
        return self._getWebPageAttribute(request, 'splash_request')

    def _getSplashProxyFactory(self, request):
        return self._getWebPageAttribute(request, 'splash_proxy_factory')

    def _getWebPageAttribute(self, request, attribute):
        web_frame = request.originatingObject()
        if isinstance(web_frame, QWebFrame):
            return getattr(web_frame.page(), attribute, None)

    def _drop_request(self, request):
        # hack: set invalid URL
        request.setUrl(QUrl('forbidden://localhost/'))

    def _handle_error(self, error_id):
        url = self.sender().url().toString()
        error_msg = REQUEST_ERRORS.get(error_id, 'unknown error')
        log.msg("Error %d: %s (%s)" % (error_id, error_msg, url), system='network')


class FilteringQNetworkAccessManager(SplashQNetworkAccessManager):
    """
    This SplashQNetworkAccessManager subclass enables request filtering
    based on 'allowed_domains' GET parameter in original Splash request.
    """
    def __init__(self, allow_subdomains=True):
        self.allow_subdomains = allow_subdomains
        super(FilteringQNetworkAccessManager, self).__init__()

    def createRequest(self, operation, request, outgoingData=None):
        splash_request = self._getSplashRequest(request)
        if splash_request:
            allowed_domains = self._get_allowed_domains(splash_request)
            host_re = self._get_host_regex(allowed_domains, self.allow_subdomains)
            if not host_re.match(unicode(request.url().host())):
                self._drop_request(request)

        return super(FilteringQNetworkAccessManager, self).createRequest(operation, request, outgoingData)

    def _get_allowed_domains(self, splash_request):
        allowed_domains = getarg(splash_request, "allowed_domains", None)
        if allowed_domains is not None:
            return allowed_domains.split(',')

    def _get_host_regex(self, allowed_domains, allow_subdomains):
        """Override this method to implement a different offsite policy"""
        if not allowed_domains:
            return re.compile('')  # allow all by default
        domains = [d.replace('.', r'\.') for d in allowed_domains]
        if allow_subdomains:
            regex = r'(.*\.)?(%s)$' % '|'.join(domains)
        else:
            regex = r'(%s)$' % '|'.join(domains)
        return re.compile(regex, re.IGNORECASE)

########NEW FILE########
__FILENAME__ = pool
from twisted.internet import defer
from twisted.python import log


class RenderPool(object):
    """A pool of renders. The number of slots determines how many
    renders will be run in parallel, at the most."""

    def __init__(self, slots, network_manager, get_splash_proxy_factory, js_profiles_path, verbose=0):
        self.network_manager = network_manager
        self.get_splash_proxy_factory = get_splash_proxy_factory
        self.js_profiles_path = js_profiles_path
        self.active = set()
        self.queue = defer.DeferredQueue()
        self.verbose = verbose
        for n in range(slots):
            self._wait_for_render(None, n)

    def render(self, rendercls, splash_request, *args):
        if self.get_splash_proxy_factory:
            splash_proxy_factory = self.get_splash_proxy_factory(splash_request)
        else:
            splash_proxy_factory = None

        pool_d = defer.Deferred()
        self.log("queued %s" % id(splash_request))
        self.queue.put((rendercls, splash_request, splash_proxy_factory, args, pool_d))
        return pool_d

    def _wait_for_render(self, _, slot):
        self.log("SLOT %d available" % slot)
        d = self.queue.get()
        d.addCallback(self._start_render, slot)
        d.addBoth(self._wait_for_render, slot)
        return _

    def _start_render(self, (rendercls, splash_request, splash_proxy_factory, args, pool_d), slot):
        self.log("initializing SLOT %d" % (slot, ))
        render = rendercls(
            network_manager=self.network_manager,
            splash_proxy_factory=splash_proxy_factory,
            splash_request=splash_request,
            verbose=self.verbose >= 2,
        )
        self.active.add(render)
        render.deferred.chainDeferred(pool_d)
        pool_d.addBoth(self._close_render, render, slot)

        self.log("SLOT %d creating request %s" % (slot, id(splash_request)))
        render.doRequest(*args)
        self.log("SLOT %d is working on %s" % (slot, id(splash_request)))

        return render.deferred

    def _close_render(self, _, render, slot):
        self.log("SLOT %d closing %s %s" % (slot, id(render.splash_request), render))
        self.active.remove(render)
        render.deferred.cancel()
        render.close()
        self.log("SLOT %d done with %s %s" % (slot, id(render.splash_request), render))
        return _

    def log(self, text):
        if self.verbose:
            log.msg(text, system='pool')

########NEW FILE########
__FILENAME__ = proxy
# -*- coding: utf-8 -*-
from __future__ import absolute_import
import re, os, ConfigParser
from PyQt4.QtNetwork import QNetworkProxy
from splash.utils import getarg, BadRequest


class BlackWhiteSplashProxyFactory(object):
    """
    Proxy factory that enables non-default proxy list when
    requested URL is matched by one of whitelist patterns
    while not being matched by one of the blacklist patterns.
    """
    def __init__(self, blacklist=None, whitelist=None, proxy_list=None):
        self.blacklist = blacklist or []
        self.whitelist = whitelist or []
        self.proxy_list = proxy_list or []

    def queryProxy(self, query=None, *args, **kwargs):
        protocol = unicode(query.protocolTag())
        url = unicode(query.url().toString())
        if self.shouldUseProxyList(protocol, url):
            return self._customProxyList()

        return self._defaultProxyList()

    def shouldUseProxyList(self, protocol, url):
        if not self.proxy_list:
            return False

        if protocol != 'http':  # don't try to proxy https
            return False

        if any(re.match(p, url) for p in self.blacklist):
            return False

        if any(re.match(p, url) for p in self.whitelist):
            return True

        return not bool(self.whitelist)

    def _defaultProxyList(self):
        return [QNetworkProxy(QNetworkProxy.DefaultProxy)]

    def _customProxyList(self):
        proxies = []
        for host, port, username, password in self.proxy_list:
            if username is not None and password is not None:
                proxy = QNetworkProxy(QNetworkProxy.HttpProxy,
                                      host, port, username, password)
            else:
                proxy = QNetworkProxy(QNetworkProxy.HttpProxy, host, port)
            proxies.append(proxy)
        return proxies


class ProfilesSplashProxyFactory(BlackWhiteSplashProxyFactory):
    """
    This proxy factory reads BlackWhiteQNetworkProxyFactory
    parameters from ini file; name of the profile can be set per-request
    using GET parameter.

    Example config file for 'mywebsite' proxy profile::

        ; /etc/splash/proxy-profiles/mywebsite.ini
        [proxy]
        host=proxy.crawlera.com
        port=8010
        username=username
        password=password

        [rules]
        whitelist=
            .*mywebsite\.com.*

        blacklist=
            .*\.js.*
            .*\.css.*
            .*\.png

    If there is ``default.ini`` proxy profile in profiles folder
    it will be used when no profile is specified in GET parameter.
    If GET parameter is 'none' or empty ('') no proxy will be used even if
    ``default.ini`` is present.
    """
    GET_ARGUMENT = 'proxy'
    NO_PROXY_PROFILE_MSG = 'Proxy profile does not exist'

    def __init__(self, proxy_profiles_path, request):
        self.proxy_profiles_path = proxy_profiles_path
        profile_name = getarg(request, self.GET_ARGUMENT, None)
        blacklist, whitelist, proxy_list = self._getFilterParams(profile_name)
        super(ProfilesSplashProxyFactory, self).__init__(blacklist, whitelist, proxy_list)

    def _getFilterParams(self, profile_name=None):
        """
        Return (blacklist, whitelist, proxy_list) tuple
        loaded from profile ``profile_name``.
        """
        if profile_name is None:
            profile_name = 'default'
            ini_path = self._getIniPath(profile_name)
            if not os.path.isfile(ini_path):
                profile_name = 'none'

        if profile_name == 'none':
            return [], [], []
        ini_path = self._getIniPath(profile_name)
        return self._parseIni(ini_path)

    def _getIniPath(self, profile_name):
        proxy_profiles_path =  os.path.abspath(self.proxy_profiles_path)
        filename = profile_name + '.ini'
        ini_path = os.path.abspath(os.path.join(proxy_profiles_path, filename))
        if not ini_path.startswith(proxy_profiles_path + os.path.sep):
            # security check fails
            raise BadRequest(self.NO_PROXY_PROFILE_MSG)
        else:
            return ini_path

    def _parseIni(self, ini_path):
        parser = ConfigParser.ConfigParser(allow_no_value=True)
        if not parser.read(ini_path):
            raise BadRequest(self.NO_PROXY_PROFILE_MSG)

        blacklist = _get_lines(parser, 'rules', 'blacklist', [])
        whitelist = _get_lines(parser, 'rules', 'whitelist', [])
        try:
            proxy = dict(parser.items('proxy'))
        except ConfigParser.NoSectionError:
            raise BadRequest("Invalid proxy profile: no [proxy] section found")

        try:
            host = proxy['host']
        except KeyError:
            raise BadRequest("Invalid proxy profile: [proxy] host is not found")

        try:
            port = int(proxy['port'])
        except KeyError:
            raise BadRequest("Invalid proxy profile: [proxy] port is not found")
        except ValueError:
            raise BadRequest("Invalid proxy profile: [proxy] port is incorrect")

        proxy_list = [(host, port, proxy.get('username'), proxy.get('password'))]
        return blacklist, whitelist, proxy_list


def _get_lines(config_parser, section, option, default):
    try:
        lines = config_parser.get(section, option).splitlines()
        return [line for line in lines if line]
    except (ConfigParser.NoOptionError, ConfigParser.NoSectionError):
        return default

########NEW FILE########
__FILENAME__ = proxy_server
from __future__ import absolute_import
from twisted.web import http
from twisted.web.error import UnsupportedMethod
from twisted.python import log, failure
from splash.resources import RenderHtml, RenderPng, RenderJson


NOT_DONE_YET = 1
SPLASH_HEADER_PREFIX = 'x-splash-'
SPLASH_RESOURCES = {'html': RenderHtml,
                    'png': RenderPng,
                    'json': RenderJson,
                    }

# Note the http header use '-' instead of '_' for the parameter names
HTML_PARAMS = ['baseurl', 'timeout', 'wait', 'proxy', 'allowed-domains',
               'viewport', 'js', 'js-source']
PNG_PARAMS = ['width', 'height']
JSON_PARAMS = ['html', 'png', 'iframes', 'script', 'console']


class SplashProxyRequest(http.Request):
    pass_headers = True

    def __init__(self, channel, queued):
        http.Request.__init__(self, channel, queued)
        self.pool = channel.pool

    def _get_header(self, name):
        return self.getHeader(SPLASH_HEADER_PREFIX + name)

    def _set_header_as_params(self, param_list):
        for parameter in param_list:
            value = self._get_header(parameter)
            if value is not None:
                # normal splash parameter use underscore instead of dash
                parameter = parameter.replace('-', '_')
                self.args[parameter] = [value]

    def _remove_splash_headers(self):
        headers = self.getAllHeaders()
        for name, value in headers.items():
            if SPLASH_HEADER_PREFIX in name.lower():
                self.requestHeaders.removeHeader(name)

    def process(self):
        try:

            # load resource class
            resource_name = self._get_header('render')
            resource_cls = SPLASH_RESOURCES.get(resource_name)
            if resource_cls is None:
                self.invalidParameter('render')
                return

            # setup request parameters
            self.args['url'] = [self.uri]
            self._set_header_as_params(HTML_PARAMS)

            if resource_name == 'png':
                self._set_header_as_params(PNG_PARAMS)
            elif resource_name == 'json':
                self._set_header_as_params(PNG_PARAMS)
                self._set_header_as_params(JSON_PARAMS)

            # make sure no splash headers are sent to the target
            self._remove_splash_headers()

            resource = resource_cls(self.pool, True)
            self.render(resource)

        except Exception as e:
            print e
            self.processingFailed(failure.Failure())

    def render(self, resource):
        try:
            body = resource.render(self)
        except UnsupportedMethod:
            return self.methodNotAllowed()

        if body == NOT_DONE_YET:
            return

        # errors handled by resources don't return a body, they write
        # to the request directly.
        if body:
            self.setHeader('content-length', str(len(body)))
            self.write(body)
        self.finish()

    def processingFailed(self, reason):
        self.setResponseCode(500)
        self.write('Error handling request')
        self.finish()

    def methodNotAllowed(self):
        self.setResponseCode(405)
        self.write('Method Not Allowed')
        self.finish()

    def invalidParameter(self, name):
        self.setResponseCode(400)
        self.write('%s header is invalid or missing' % (SPLASH_HEADER_PREFIX + name))
        self.finish()


class SplashProxy(http.HTTPChannel):
    requestFactory = SplashProxyRequest


class SplashProxyFactory(http.HTTPFactory):
    protocol = SplashProxy

    def __init__(self, pool, logPath=None, timeout=60 * 60 * 12):
        http.HTTPFactory.__init__(self, logPath=logPath, timeout=timeout)
        self.pool = pool

    def buildProtocol(self, addr):
        p = http.HTTPFactory.buildProtocol(self, addr)
        p.pool = self.pool
        return p

########NEW FILE########
__FILENAME__ = qtrender
from __future__ import absolute_import
import os, json, base64
from collections import namedtuple
import sip
from PyQt4.QtWebKit import QWebPage, QWebSettings, QWebView
from PyQt4.QtCore import Qt, QUrl, QBuffer, QSize, QTimer, QObject, pyqtSlot, QByteArray
from PyQt4.QtGui import QPainter, QImage
from PyQt4.QtNetwork import QNetworkRequest, QNetworkAccessManager
from twisted.internet import defer
from twisted.python import log
from splash import defaults


class RenderError(Exception):
    pass


RenderErrorInfo = namedtuple('RenderErrorInfo', 'type code text url')


class SplashQWebPage(QWebPage):
    errorInfo = None

    custom_user_agent = None

    def javaScriptAlert(self, frame, msg):
        return

    def javaScriptConfirm(self, frame, msg):
        return False

    def javaScriptConsoleMessage(self, msg, line_number, source_id):
        log.msg("JsConsole(%s:%d): %s" % (source_id, line_number, msg), system='render')

    def userAgentForUrl(self, url):
        if self.custom_user_agent is None:
            return super(SplashQWebPage, self).userAgentForUrl(url)
        else:
            return self.custom_user_agent

    # loadFinished signal handler receives ok=False at least these cases:
    # 1. when there is an error with the page (e.g. the page is not available);
    # 2. when a redirect happened before all related resource are loaded;
    # 3. when page sends headers that are not parsed correctly
    #    (e.g. a bad Content-Type).
    # By implementing ErrorPageExtension we can catch (1) and
    # distinguish it from (2) and (3).
    def extension(self, extension, info=None, errorPage=None):
        if extension == QWebPage.ErrorPageExtension:
            # catch the error, populate self.errorInfo and return an error page

            info = sip.cast(info, QWebPage.ErrorPageExtensionOption)

            domain = 'Unknown'
            if info.domain == QWebPage.QtNetwork:
                domain = 'Network'
            elif info.domain == QWebPage.Http:
                domain = 'HTTP'
            elif info.domain == QWebPage.WebKit:
                domain = 'WebKit'

            self.errorInfo = RenderErrorInfo(
                domain,
                int(info.error),
                unicode(info.errorString),
                unicode(info.url.toString())
            )

            # XXX: this page currently goes nowhere
            content = u"""
                <html><head><title>Failed loading page</title></head>
                <body>
                    <h1>Failed loading page ({0.text})</h1>
                    <h2>{0.url}</h2>
                    <p>{0.type} error #{0.code}</p>
                </body></html>""".format(self.errorInfo)

            errorPage = sip.cast(errorPage, QWebPage.ErrorPageExtensionReturn)
            errorPage.content = QByteArray(content.encode('utf-8'))
            return True

        # XXX: this method always returns True, even if we haven't
        # handled the extension. Is it correct? When can this method be
        # called with extension which is not ErrorPageExtension if we
        # are returning False in ``supportsExtension`` for such extensions?
        return True

    def supportsExtension(self, extension):
        if extension == QWebPage.ErrorPageExtension:
            return True
        return False


class WebpageRender(object):

    def __init__(self, network_manager, splash_proxy_factory, splash_request, verbose=False):
        self.network_manager = network_manager
        self.web_view = QWebView()
        self.web_page = SplashQWebPage()
        self.web_page.setNetworkAccessManager(self.network_manager)
        self.web_view.setPage(self.web_page)
        self.web_view.setAttribute(Qt.WA_DeleteOnClose, True)
        settings = self.web_page.settings()
        settings.setAttribute(QWebSettings.JavascriptEnabled, True)
        settings.setAttribute(QWebSettings.PluginsEnabled, False)
        settings.setAttribute(QWebSettings.PrivateBrowsingEnabled, True)
        settings.setAttribute(QWebSettings.LocalStorageEnabled, True)
        settings.setAttribute(QWebSettings.LocalContentCanAccessRemoteUrls, True)
        self.web_page.mainFrame().setScrollBarPolicy(Qt.Vertical, Qt.ScrollBarAlwaysOff)
        self.web_page.mainFrame().setScrollBarPolicy(Qt.Horizontal, Qt.ScrollBarAlwaysOff)

        self.splash_request = splash_request
        self.web_page.splash_request = splash_request
        self.web_page.splash_proxy_factory = splash_proxy_factory
        self.verbose = verbose

        self.deferred = defer.Deferred()

    # ======= General request/response handling:


    def doRequest(self, url, baseurl=None, wait_time=None, viewport=None, js_source=None, js_profile=None, console=False):
        self.url = url
        self.wait_time = defaults.WAIT_TIME if wait_time is None else wait_time
        self.js_source = js_source
        self.js_profile = js_profile
        self.console = console
        self.viewport = defaults.VIEWPORT if viewport is None else viewport

        request = QNetworkRequest()
        request.setUrl(QUrl(url.decode('utf8')))

        if self.viewport != 'full':
            # viewport='full' can't be set if content is not loaded yet
            self._setViewportSize(self.viewport)

        if getattr(self.splash_request, 'pass_headers', False):
            headers = self.splash_request.getAllHeaders()
            for name, value in headers.items():
                request.setRawHeader(name, value)
                if name.lower() == 'user-agent':
                    self.web_page.custom_user_agent = value

        if baseurl:
            self._baseUrl = QUrl(baseurl.decode('utf8'))
            request.setOriginatingObject(self.web_page.mainFrame())
            self._reply = self.network_manager.get(request)
            self._reply.finished.connect(self._requestFinished)
        else:
            self.web_page.loadFinished.connect(self._loadFinished)
            if self.splash_request.method == 'POST':
                self.web_page.mainFrame().load(request,
                                               QNetworkAccessManager.PostOperation,
                                               self.splash_request.content.getvalue())
            else:
                self.web_page.mainFrame().load(request)

    def close(self):
        self.web_view.stop()
        self.web_view.close()
        self.web_page.deleteLater()
        self.web_view.deleteLater()

    def _requestFinished(self):
        self.log("_requestFinished %s" % id(self.splash_request))
        self.web_page.loadFinished.connect(self._loadFinished)
        mimeType = self._reply.header(QNetworkRequest.ContentTypeHeader).toString()
        data = self._reply.readAll()
        self.web_page.mainFrame().setContent(data, mimeType, self._baseUrl)
        if self._reply.error():
            log.msg("Error loading %s: %s" % (self.url, self._reply.errorString()), system='render')
        self._reply.close()
        self._reply.deleteLater()

    def _loadFinished(self, ok):
        self.log("_loadFinished %s" % id(self.splash_request))
        if self.deferred.called:
            # sometimes this callback is called multiple times
            self.log("_loadFinished called multiple times")
            return

        page_ok = ok and self.web_page.errorInfo is None
        maybe_redirect = not ok and self.web_page.errorInfo is None
        error_loading = ok and self.web_page.errorInfo is not None

        if maybe_redirect:
            self.log("Redirect or other non-fatal error detected %s" % id(self.splash_request))
            # XXX: It assumes loadFinished will be called again because
            # redirect happens. If redirect is detected improperly,
            # loadFinished won't be called again, and Splash will return
            # the result only after a timeout.
            #
            # FIXME: This can happen if server returned incorrect
            # Content-Type header; there is no an additional loadFinished
            # signal in this case.
            return

        if page_ok:
            time_ms = int(self.wait_time * 1000)
            QTimer.singleShot(time_ms, self._loadFinishedOK)
        elif error_loading:
            self.log("loadFinished %s: %s" % (id(self.splash_request), str(self.web_page.errorInfo))) #, min_level=1)
            # XXX: maybe return a meaningful error page instead of generic
            # error message?
            self.deferred.errback(RenderError())
        else:
            self.log("loadFinished %s: unknown error" % id(self.splash_request)) #, min_level=1)
            self.deferred.errback(RenderError())

    def _loadFinishedOK(self):
        self.log("_loadFinishedOK %s" % id(self.splash_request))
        try:
            self._prerender()
            self.deferred.callback(self._render())
        except:
            self.deferred.errback()

    # ======= Rendering methods that subclasses can use:

    def _getHtml(self):
        frame = self.web_page.mainFrame()
        return bytes(frame.toHtml().toUtf8())

    def _getPng(self, width=None, height=None):
        image = QImage(self.web_page.viewportSize(), QImage.Format_ARGB32)
        painter = QPainter(image)
        self.web_page.mainFrame().render(painter)
        painter.end()
        if width:
            image = image.scaledToWidth(width, Qt.SmoothTransformation)
        if height:
            image = image.copy(0, 0, width, height)
        b = QBuffer()
        image.save(b, "png")
        return bytes(b.data())

    def _getIframes(self, children=True, html=True):
        frame = self.web_page.mainFrame()
        return self._frameToDict(frame, children, html)

    def _render(self):
        raise NotImplementedError()

    # ======= Other helper methods:

    def _setViewportSize(self, viewport):
        w, h = map(int, viewport.split('x'))
        size = QSize(w, h)
        self.web_page.setViewportSize(size)

    def _setFullViewport(self):
        size = self.web_page.mainFrame().contentsSize()
        if size.isEmpty():
            self.log("contentsSize method doesn't work %s" % id(self.splash_request))
            self._setViewportSize(defaults.VIEWPORT_FALLBACK)
        else:
            self.web_page.setViewportSize(size)


    def _loadJsLibs(self, frame, js_profile):
        if js_profile:
            for jsfile in os.listdir(js_profile):
                if jsfile.endswith('.js'):
                    with open(os.path.join(js_profile, jsfile)) as f:
                        frame.evaluateJavaScript(f.read().decode('utf-8'))

    def _runJS(self, js_source, js_profile):
        js_output = None
        js_console_output = None
        if js_source:
            frame = self.web_page.mainFrame()
            if self.console:
                js_console = JavascriptConsole()
                frame.addToJavaScriptWindowObject('console', js_console)
            if js_profile:
                self._loadJsLibs(frame, js_profile)
            ret = frame.evaluateJavaScript(js_source)
            js_output = bytes(ret.toString().toUtf8())
            if self.console:
                js_console_output = [bytes(s.toUtf8()) for s in js_console.messages]
        return js_output, js_console_output

    def _frameToDict(self, frame, children=True, html=True):
        g = frame.geometry()
        res = {
            "url": unicode(frame.url().toString()),
            "requestedUrl": unicode(frame.requestedUrl().toString()),
            "geometry": (g.x(), g.y(), g.width(), g.height()),
            "title": unicode(frame.title())
        }
        if html:
            res["html"] = unicode(frame.toHtml())

        if children:
            res["childFrames"] = [self._frameToDict(f, True, html) for f in frame.childFrames()]
            res["frameName"] = unicode(frame.frameName())

        return res

    def _prerender(self):
        if self.viewport == 'full':
            self._setFullViewport()
        self.js_output, self.js_console_output = self._runJS(self.js_source, self.js_profile)

    def log(self, text):
        if self.verbose:
            log.msg(text, system='render')


class HtmlRender(WebpageRender):
    def _render(self):
        return self._getHtml()


class PngRender(WebpageRender):

    def doRequest(self, url, baseurl=None, wait_time=None, viewport=None, js_source=None, js_profile=None,
                        width=None, height=None):
        self.width = width
        self.height = height
        super(PngRender, self).doRequest(url, baseurl, wait_time, viewport, js_source, js_profile)

    def _render(self):
        return self._getPng(self.width, self.height)


class JsonRender(WebpageRender):

    def doRequest(self, url, baseurl=None, wait_time=None, viewport=None, js_source=None, js_profile=None,
                        html=True, iframes=True, png=True, script=True, console=False,
                        width=None, height=None):
        self.width = width
        self.height = height
        self.include = {'html': html, 'png': png, 'iframes': iframes,
                        'script': script, 'console': console}
        super(JsonRender, self).doRequest(url, baseurl, wait_time, viewport, js_source, js_profile, console)

    def _render(self):
        res = {}

        if self.include['png']:
            png = self._getPng(self.width, self.height)
            res['png'] = base64.encodestring(png)

        if self.include['script'] and self.js_output:
            res['script'] = self.js_output
        if self.include['console'] and self.js_console_output:
            res['console'] = self.js_console_output

        res.update(self._getIframes(
            children=self.include['iframes'],
            html=self.include['html'],
        ))
        return json.dumps(res)


class JavascriptConsole(QObject):
    def __init__(self, parent=None):
        self.messages = []
        super(JavascriptConsole, self).__init__(parent)

    @pyqtSlot(str)
    def log(self, message):
        self.messages.append(message)

########NEW FILE########
__FILENAME__ = resources
import os, time, resource, json
from twisted.web.server import NOT_DONE_YET
from twisted.web.resource import Resource
from twisted.internet import reactor, defer
from twisted.python import log
from splash.qtrender import HtmlRender, PngRender, JsonRender, RenderError
from splash.utils import getarg, BadRequest, get_num_fds, get_leaks
from splash import sentry
from splash import defaults


class RenderBase(Resource):

    isLeaf = True
    content_type = "text/html; charset=utf-8"

    def __init__(self, pool, is_proxy_request=False):
        Resource.__init__(self)
        self.pool = pool
        self.js_profiles_path = self.pool.js_profiles_path
        self.is_proxy_request = is_proxy_request

    def render_GET(self, request):
        #log.msg("%s %s %s %s" % (id(request), request.method, request.path, request.args))
        pool_d = self._getRender(request)
        timeout = getarg(request, "timeout", defaults.TIMEOUT, type=float, range=(0, defaults.MAX_TIMEOUT))
        wait_time = getarg(request, "wait", defaults.WAIT_TIME, type=float, range=(0, defaults.MAX_WAIT_TIME))

        timer = reactor.callLater(timeout+wait_time, pool_d.cancel)
        pool_d.addCallback(self._cancelTimer, timer)
        pool_d.addCallback(self._writeOutput, request)
        pool_d.addErrback(self._timeoutError, request)
        pool_d.addErrback(self._renderError, request)
        pool_d.addErrback(self._internalError, request)
        pool_d.addBoth(self._finishRequest, request)
        request.starttime = time.time()
        return NOT_DONE_YET

    def render_POST(self, request):
        # this check is required only in request not coming from the splash proxy service.
        if not self.is_proxy_request:
            content_type = request.getHeader('content-type')
            if content_type != 'application/javascript':
                request.setResponseCode(415)
                request.write("Request content-type not supported\n")
                return

        return self.render_GET(request)

    def render(self, request):
        try:
            return Resource.render(self, request)
        except BadRequest as e:
            request.setResponseCode(400)
            return str(e) + "\n"

    def _cancelTimer(self, _, timer):
        #log.msg("_cancelTimer")
        timer.cancel()
        return _

    def _writeOutput(self, html, request):
        #log.msg("_writeOutput: %s" % id(request))
        stats = {
            "path": request.path,
            "args": request.args,
            "rendertime": time.time() - request.starttime,
            "maxrss": resource.getrusage(resource.RUSAGE_SELF).ru_maxrss,
            "load": os.getloadavg(),
            "fds": get_num_fds(),
            "active": len(self.pool.active),
            "qsize": len(self.pool.queue.pending),
            "_id": id(request),
        }
        log.msg(json.dumps(stats), system="stats")
        request.setHeader("content-type", self.content_type)
        request.write(html)

    def _timeoutError(self, failure, request):
        failure.trap(defer.CancelledError)
        request.setResponseCode(504)
        request.write("Timeout exceeded rendering page\n")
        #log.msg("_timeoutError: %s" % id(request))

    def _renderError(self, failure, request):
        failure.trap(RenderError)
        request.setResponseCode(502)
        request.write("Error rendering page\n")
        #log.msg("_renderError: %s" % id(request))

    def _internalError(self, failure, request):
        request.setResponseCode(500)
        request.write(failure.getErrorMessage())
        log.err()
        sentry.capture(failure)

    def _finishRequest(self, _, request):
        if not request._disconnected:
            request.finish()
        #log.msg("_finishRequest: %s" % id(request))

    def _getRender(self, request):
        raise NotImplementedError()


def _check_viewport(viewport, wait, max_width, max_heigth, max_area):
    if viewport is None:
        return

    if viewport == 'full':
        if wait == 0:
            raise BadRequest("Pass non-zero 'wait' to render full webpage")
        return

    try:
        w, h = map(int, viewport.split('x'))
        if (0 < w <= max_width) and (0 < h <= max_heigth) and (w*h < max_area):
            return
        raise BadRequest("Viewport is out of range (%dx%d, area=%d)" % (max_width, max_heigth, max_area))
    except (ValueError):
        raise BadRequest("Invalid viewport format: %s" % viewport)


def _get_javascript_params(request, js_profiles_path):
    js_profile = _check_js_profile(request, js_profiles_path, getarg(request, 'js', None))
    js_source = getarg(request, 'js_source', None)
    if js_source is not None:
        return js_source, js_profile
    
    if request.method == 'POST':
        return request.content.getvalue(), js_profile
    else:
        return None, js_profile


def _check_js_profile(request, js_profiles_path, js_profile):
    if js_profile:
        if js_profiles_path is None:
            raise BadRequest('Javascript profiles are not enabled')
        profile_dir = os.path.join(js_profiles_path, js_profile)
        if not profile_dir.startswith(js_profiles_path + os.path.sep):
            # security check fails
            raise BadRequest('Javascript profile does not exist')
        if not os.path.isdir(profile_dir):
            raise BadRequest('Javascript profile does not exist')
        return profile_dir


def _get_png_params(request, js_profiles_path):
    url, baseurl, wait_time, viewport, js_source, js_profile = _get_common_params(request, js_profiles_path)
    width = getarg(request, "width", None, type=int, range=(1, defaults.MAX_WIDTH))
    height = getarg(request, "height", None, type=int, range=(1, defaults.MAX_HEIGTH))
    return url, baseurl, wait_time, viewport, js_source, js_profile, width, height


def _get_common_params(request, js_profiles_path):
    url = getarg(request, "url")
    baseurl = getarg(request, "baseurl", None)
    wait_time = getarg(request, "wait", defaults.WAIT_TIME, type=float, range=(0, defaults.MAX_WAIT_TIME))
    js_source, js_profile = _get_javascript_params(request, js_profiles_path)

    viewport = getarg(request, "viewport", defaults.VIEWPORT)
    _check_viewport(viewport, wait_time, defaults.VIEWPORT_MAX_WIDTH,
                    defaults.VIEWPORT_MAX_HEIGTH, defaults.VIEWPORT_MAX_AREA)

    return url, baseurl, wait_time, viewport, js_source, js_profile


class RenderHtml(RenderBase):

    content_type = "text/html; charset=utf-8"

    def _getRender(self, request):
        return self.pool.render(HtmlRender, request, *_get_common_params(request, self.js_profiles_path))


class RenderPng(RenderBase):

    content_type = "image/png"

    def _getRender(self, request):
        return self.pool.render(PngRender, request, *_get_png_params(request, self.js_profiles_path))


class RenderJson(RenderBase):

    content_type = "application/json"

    def _getRender(self, request):
        url, baseurl, wait_time, viewport, js_source, js_profile, width, height = _get_png_params(request, self.js_profiles_path)

        html = getarg(request, "html", defaults.DO_HTML, type=int, range=(0, 1))
        iframes = getarg(request, "iframes", defaults.DO_IFRAMES, type=int, range=(0, 1))
        png = getarg(request, "png", defaults.DO_PNG, type=int, range=(0, 1))
        script = getarg(request, "script", defaults.SHOW_SCRIPT, type=int, range=(0, 1))
        console = getarg(request, "console", defaults.SHOW_CONSOLE, type=int, range=(0, 1))

        return self.pool.render(JsonRender, request,
                                url, baseurl, wait_time, viewport, js_source, js_profile,
                                html, iframes, png, script, console,
                                width, height)


class Debug(Resource):

    isLeaf = True

    def __init__(self, pool):
        Resource.__init__(self)
        self.pool = pool

    def render_GET(self, request):
        request.setHeader("content-type", "application/json")
        return json.dumps({
            "leaks": get_leaks(),
            "active": [x.url for x in self.pool.active],
            "qsize": len(self.pool.queue.pending),
            "maxrss": resource.getrusage(resource.RUSAGE_SELF).ru_maxrss,
            "fds": get_num_fds(),
        })


class Root(Resource):

    def __init__(self, pool):
        Resource.__init__(self)
        self.putChild("render.html", RenderHtml(pool))
        self.putChild("render.png", RenderPng(pool))
        self.putChild("render.json", RenderJson(pool))
        self.putChild("debug", Debug(pool))

    def getChild(self, name, request):
        if name == "":
            return self
        return Resource.getChild(self, name, request)

    def render_GET(self, request):
        return ""

########NEW FILE########
__FILENAME__ = sentry
import os

class SentryLogger():

    def __init__(self):
        try:
            import raven
            self.enabled = True
            dsn = os.environ['SPLASH_SENTRY_DSN']
            if dsn.startswith('https'):
                dsn = dsn.replace('https://', 'twisted+https://')
            self.client = raven.Client(dsn)
        except (ImportError, KeyError):
            self.enabled = False

    def capture(self, failure):
        if self.enabled:
            self.client.captureException((failure.type, failure.value, failure.getTracebackObject()))

capture = SentryLogger().capture

########NEW FILE########
__FILENAME__ = server
import os, sys, optparse, resource, traceback, signal
from psutil import phymem_usage
from splash import defaults

# A global reference must be kept to QApplication, otherwise the process will
# segfault
qtapp = None


def install_qtreactor():
    global qtapp

    from PyQt4.QtGui import QApplication
    qtapp = QApplication(sys.argv)
    import qt4reactor
    qt4reactor.install()


def parse_opts():
    _bool_default = {True:' (default)', False: ''}

    op = optparse.OptionParser()
    op.add_option("-f", "--logfile", help="log file")
    op.add_option("-m", "--maxrss", type=float, default=0,
        help="exit if max RSS reaches this value (in MB or ratio of physical mem) (default: %default)")
    op.add_option("-p", "--port", type="int", default=defaults.SPLASH_PORT,
        help="port to listen to (default: %default)")
    op.add_option("-s", "--slots", type="int", default=defaults.SLOTS,
        help="number of render slots (default: %default)")
    op.add_option("--proxy-profiles-path",
        help="path to a folder with proxy profiles")
    op.add_option("--js-profiles-path",
        help="path to a folder with javascript profiles")
    op.add_option("--no-js-cross-domain-access",
        action="store_false",
        dest="js_cross_domain_enabled",
        default=not defaults.JS_CROSS_DOMAIN_ENABLED,
        help="disable support for cross domain access when executing custom javascript" + _bool_default[not defaults.JS_CROSS_DOMAIN_ENABLED])
    op.add_option("--js-cross-domain-access",
        action="store_true",
        dest="js_cross_domain_enabled",
        default=defaults.JS_CROSS_DOMAIN_ENABLED,
        help="enable support for cross domain access when executing custom javascript "
             "(WARNING: it could break rendering for some of the websites)" + _bool_default[defaults.JS_CROSS_DOMAIN_ENABLED])
    op.add_option("--no-cache", action="store_false", dest="cache_enabled",
        help="disable local cache" + _bool_default[not defaults.CACHE_ENABLED])
    op.add_option("--cache", action="store_true", dest="cache_enabled",
        help="enable local cache (WARNING: don't enable it unless you know what are you doing)" + _bool_default[defaults.CACHE_ENABLED])
    op.add_option("-c", "--cache-path", help="local cache folder")
    op.add_option("--cache-size", type=int, default=defaults.CACHE_SIZE,
        help="maximum cache size in MB (default: %default)")
    op.add_option("--manhole", action="store_true",
        help="enable manhole server")
    op.add_option("--disable-proxy", action="store_true", default=False,
        help="enable proxy server")
    op.add_option("--proxy-portnum", type="int", default=defaults.PROXY_PORT,
        help="proxy port to listen to (default: %default)")

    return op.parse_args()


def start_logging(opts):
    from twisted.python import log
    from twisted.python.logfile import DailyLogFile
    if opts.logfile:
        logfile = DailyLogFile.fromFullPath(opts.logfile)
    else:
        logfile = sys.stderr
    log.startLogging(logfile)


def splash_started(opts, stderr):
    if opts.logfile:
        stderr.write("Splash started - logging to: %s\n" % opts.logfile)


def bump_nofile_limit():
    from twisted.python import log
    log.msg("Open files limit: %d" % resource.getrlimit(resource.RLIMIT_NOFILE)[0])
    soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
    values_to_try = [v for v in [hard, 100000, 10000] if v > soft]
    for new_soft in values_to_try:
        try:
            resource.setrlimit(resource.RLIMIT_NOFILE, (new_soft, hard))
        except ValueError:
            continue
        else:
            log.msg("Open files limit increased from %d to %d" % (soft, new_soft))
            break
    else:
        log.msg("Can't bump open files limit")


def manhole_server(portnum=None, username=None, password=None):
    from twisted.internet import reactor
    from twisted.manhole import telnet

    f = telnet.ShellFactory()
    f.username = defaults.MANHOLE_USERNAME if username is None else username
    f.password = defaults.MANHOLE_PASSWORD if password is None else password
    portnum = defaults.MANHOLE_PORT if portnum is None else portnum
    reactor.listenTCP(portnum, f)


def splash_server(portnum, slots, network_manager, get_splash_proxy_factory=None,
                  js_profiles_path=None, disable_proxy=False, proxy_portnum=None):
    from twisted.internet import reactor
    from twisted.web.server import Site
    from splash.resources import Root
    from splash.pool import RenderPool
    from twisted.python import log

    slots = defaults.SLOTS if slots is None else slots
    log.msg("slots=%s" % slots)

    pool = RenderPool(
        slots=slots,
        network_manager=network_manager,
        get_splash_proxy_factory=get_splash_proxy_factory,
        js_profiles_path=js_profiles_path
    )

    # HTTP API
    root = Root(pool)
    factory = Site(root)
    reactor.listenTCP(portnum, factory)

    # HTTP Proxy
    if disable_proxy is False:
        from splash.proxy_server import SplashProxyFactory
        splash_proxy_factory = SplashProxyFactory(pool)
        proxy_portnum = defaults.PROXY_PORT if proxy_portnum is None else proxy_portnum
        reactor.listenTCP(proxy_portnum, splash_proxy_factory)


def monitor_maxrss(maxrss):
    from twisted.internet import reactor, task
    from twisted.python import log

    # Support maxrss as a percent of total physical memory
    if 0.0 < maxrss < 1.0:
        maxrss = phymem_usage().total * maxrss / (1024 ** 2)

    def check_maxrss():
        if resource.getrusage(resource.RUSAGE_SELF).ru_maxrss > maxrss * 1024:
            log.msg("maxrss exceeded %d MB, shutting down..." % maxrss)
            reactor.stop()
    if maxrss:
        log.msg("maxrss limit: %d MB" % maxrss)
        t = task.LoopingCall(check_maxrss)
        t.start(60, now=False)


def default_splash_server(portnum, slots=None,
                          cache_enabled=None, cache_path=None, cache_size=None,
                          proxy_profiles_path=None, js_profiles_path=None,
                          js_disable_cross_domain_access=False,
                          disable_proxy=False, proxy_portnum=None):
    from splash import network_manager
    manager = network_manager.FilteringQNetworkAccessManager()
    manager.setCache(_default_cache(cache_enabled, cache_path, cache_size))
    get_splash_proxy_factory = _default_proxy_config(proxy_profiles_path)
    js_profiles_path = _check_js_profiles_path(js_profiles_path)
    _set_global_render_settings(js_disable_cross_domain_access)
    return splash_server(portnum, slots, manager, get_splash_proxy_factory,
                         js_profiles_path, disable_proxy, proxy_portnum)


def _default_cache(cache_enabled, cache_path, cache_size):
    from twisted.python import log
    from splash import cache

    cache_enabled = defaults.CACHE_ENABLED if cache_enabled is None else cache_enabled
    cache_path = defaults.CACHE_PATH if cache_path is None else cache_path
    cache_size = defaults.CACHE_SIZE if cache_size is None else cache_size

    if cache_enabled:
        log.msg("cache_enabled=%s, cache_path=%r, cache_size=%sMB" % (cache_enabled, cache_path, cache_size))
        log.msg("[WARNING] You have enabled cache support. QT cache is known "
                "to cause segfaults and other issues for splash; "
                "enable it on your own risk. We recommend using a separate "
                "caching forward proxy like squid.")
        return cache.construct(cache_path, cache_size)


def _default_proxy_config(proxy_profiles_path):
    from twisted.python import log
    from splash import proxy

    if proxy_profiles_path is not None and not os.path.isdir(proxy_profiles_path):
        log.msg("--proxy-profiles-path does not exist or it is not a folder; proxy won't be used")
        proxy_enabled = False
    else:
        proxy_enabled = proxy_profiles_path is not None

    if proxy_enabled:
        log.msg("proxy support is enabled, proxy profiles path: %s" % proxy_profiles_path)
        def get_splash_proxy_factory(request):
            return proxy.ProfilesSplashProxyFactory(proxy_profiles_path, request)
        return get_splash_proxy_factory


def _check_js_profiles_path(js_profiles_path):
    from twisted.python import log

    if js_profiles_path is not None and not os.path.isdir(js_profiles_path):
        log.msg("--js-profiles-path does not exist or it is not a folder; js profiles won't be used")
    return js_profiles_path


def _set_global_render_settings(js_disable_cross_domain_access):
    from PyQt4.QtWebKit import QWebSecurityOrigin
    if js_disable_cross_domain_access is False:
        # In order to enable cross domain requests it is necessary to add
        # the http and https to the local scheme, this way all the urls are
        # seen as inside the same security origin.
        for scheme in ['http', 'https']:
            QWebSecurityOrigin.addLocalScheme(scheme)


def main():
    install_qtreactor()
    opts, _ = parse_opts()

    start_logging(opts)
    bump_nofile_limit()
    monitor_maxrss(opts.maxrss)
    if opts.manhole:
        manhole_server()

    default_splash_server(portnum=opts.port,
                  slots=opts.slots,
                  cache_enabled=opts.cache_enabled,
                  cache_path=opts.cache_path,
                  cache_size=opts.cache_size,
                  proxy_profiles_path=opts.proxy_profiles_path,
                  js_profiles_path=opts.js_profiles_path,
                  js_disable_cross_domain_access=not opts.js_cross_domain_enabled,
                  disable_proxy=opts.disable_proxy,
                  proxy_portnum=opts.proxy_portnum)
    signal.signal(signal.SIGUSR1, lambda s, f: traceback.print_stack(f))

    from twisted.internet import reactor
    reactor.callWhenRunning(splash_started, opts, sys.stderr)
    reactor.run()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = mockserver
# -*- coding: utf-8 -*-
from __future__ import absolute_import
import os
import optparse
import base64
from twisted.web.server import Site, NOT_DONE_YET
from twisted.web.resource import Resource
from twisted.web import proxy, http
from twisted.internet import reactor, ssl
from twisted.internet.task import deferLater
from splash.utils import getarg


def _html_resource(html):

    class HtmlResource(Resource):
        isLeaf = True

        def __init__(self, http_port=None, https_port=None):
            Resource.__init__(self)
            self.http_port = http_port
            self.https_port = https_port

        def render(self, request):
            return html % dict(
                http_port=self.http_port,
                https_port=self.https_port
            )

    return HtmlResource


JsRender = _html_resource("""
<html>
<body>

<p id="p1">Before</p>

<script>
document.getElementById("p1").innerHTML="After";
</script>

</body>
</html>
""")

JsAlert = _html_resource("""
<html>
<body>
<p id="p1">Before</p>
<script>
alert("hello");
document.getElementById("p1").innerHTML="After";
</script>
</body>
</html>
""")

JsConfirm = _html_resource("""
<html>
<body>
<p id="p1">Before</p>
<script>
confirm("are you sure?");
document.getElementById("p1").innerHTML="After";
</script>
</body>
</html>
""")

JsInterval = _html_resource("""
<html><body>
<div id='num'>not started</div>
<script>
var num=0;
setInterval(function(){
    document.getElementById('num').innerHTML = num;
    num += 1;
}, 1);
</script>
</body></html>
""")


JsViewport = _html_resource("""
<html><body>
<script>
document.write(window.innerWidth);
document.write('x');
document.write(window.innerHeight);
</script>
</body></html>
""")


TallPage = _html_resource("""
<html style='height:2000px'>
<body>Hello</body>
</html>
""")


class BaseUrl(Resource):

    def render_GET(self, request):
        return """
<html>
<body>
<p id="p1">Before</p>
<script src="script.js"></script>
</body>
</html>
"""

    def getChild(self, name, request):
        if name == "script.js":
            return self.ScriptJs()
        return self


    class ScriptJs(Resource):

        isLeaf = True

        def render_GET(self, request):
            request.setHeader("Content-Type", "application/javascript")
            return 'document.getElementById("p1").innerHTML="After";'


class Delay(Resource):

    isLeaf = True

    def render_GET(self, request):
        n = getarg(request, "n", 1, type=float)
        d = deferLater(reactor, n, lambda: (request, n))
        d.addCallback(self._delayedRender)
        return NOT_DONE_YET

    def _delayedRender(self, (request, n)):
        request.write("Response delayed for %0.3f seconds\n" % n)
        if not request._disconnected:
            request.finish()


class SlowImage(Resource):
    """ 1x1 black gif that loads n seconds """

    isLeaf = True

    def render_GET(self, request):
        request.setHeader("Content-Type", "image/gif")
        request.write("GIF89a")
        n = getarg(request, "n", 1, type=float)
        d = deferLater(reactor, n, lambda: (request, n))
        d.addCallback(self._delayedRender)
        return NOT_DONE_YET

    def _delayedRender(self, (request, n)):
        # write 1px black gif
        gif_data = b'AQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs='
        request.write(base64.decodestring(gif_data))
        if not request._disconnected:
            request.finish()


class IframeResource(Resource):

    def __init__(self, http_port):
        Resource.__init__(self)
        self.putChild("1.html", self.IframeContent1())
        self.putChild("2.html", self.IframeContent2())
        self.putChild("3.html", self.IframeContent3())
        self.putChild("4.html", self.IframeContent4())
        self.putChild("5.html", self.IframeContent5())
        self.putChild("6.html", self.IframeContent6())
        self.putChild("script.js", self.ScriptJs())
        self.putChild("script2.js", self.OtherDomainScript())
        self.putChild("nested.html", self.NestedIframeContent())
        self.http_port = http_port

    def render(self, request):
        return """
<html>
<head>
    <script src="/iframes/script.js"></script>
    <script src="http://0.0.0.0:%s/iframes/script2.js"></script>
</head>
<body>

<iframe src="/iframes/1.html">
  <p>no iframe 1</p>
</iframe>

<iframe src="/iframes/2.html">
  <p>no iframe 2</p>
</iframe>

<p id="js-iframe">no js iframes</p>
<p id="js-iframe2">no delayed js iframes</p>
<p id="js-iframe3">no js iframes created in window.onload</p>

<script type="text/javascript">
document.getElementById('js-iframe').innerHTML="<iframe src='/iframes/3.html'>js iframes don't work</iframe>"
</script>

<script type="text/javascript">
window.setTimeout(function(){
    document.getElementById('js-iframe2').innerHTML="<iframe src='/iframes/4.html'>delayed js iframes don't work</iframe>";
}, 100);
</script>

<script type="text/javascript">
window.onload = function(){
    document.getElementById('js-iframe3').innerHTML="<iframe src='/iframes/5.html'>js iframes created in window.onload don't work</iframe>";
};
</script>

</body>
</html>
""" % self.http_port

    IframeContent1 = _html_resource("<html><body>iframes work IFRAME_1_OK</body></html>")
    IframeContent2 = _html_resource("""
        <html><body>
        <iframe src="/iframes/nested.html" width=200 height=200>
            <p>nested iframes don't work</p>
        </iframe>
        </body></html>
        """)
    IframeContent3 = _html_resource("<html><body>js iframes work IFRAME_2_OK</body></html>")
    IframeContent4 = _html_resource("<html><body>delayed js iframes work IFRAME_3_OK</body></html>")
    IframeContent5 = _html_resource("<html><body>js iframes created in window.onoad work IFRAME_4_OK</body></html>")
    IframeContent6 = _html_resource("<html><body>js iframes created by document.write in external script work IFRAME_5_OK</body></html>")
    NestedIframeContent = _html_resource("<html><body><p>nested iframes work IFRAME_6_OK</p></body></html>")

    class ScriptJs(Resource):
        isLeaf = True
        def render(self, request):
            request.setHeader("Content-Type", "application/javascript")
            iframe_html = " SAME_DOMAIN <iframe src='/iframes/6.html'>js iframe created by document.write in external script doesn't work</iframe>"
            return '''document.write("%s");''' % iframe_html

    class OtherDomainScript(Resource):
        isLeaf = True
        def render(self, request):
            request.setHeader("Content-Type", "application/javascript")
            return "document.write(' OTHER_DOMAIN ');"


class PostResource(Resource):

    def render_POST(self, request):
        headers = request.getAllHeaders()
        payload = request.content.getvalue() if request.content is not None else ''
        return """
<html>
<body>
<p id="p1">From POST</p>
<p id="headers">
%s
</p>
<p id="payload">
%s
</p>
</body>
</html>
""" % (headers, payload)


class GetResource(Resource):

    def render_GET(self, request):
        headers = request.getAllHeaders()
        payload = request.args
        return """
<html>
<body>
<p id="p1">GET request</p>
<p id="headers">
%s
</p>
<p id="arguments">
%s
</p>
</body>
</html>
""" % (headers, payload)


ExternalIFrameResource = _html_resource("""
<html>
<body>
<iframe id='external' src="https://localhost:%(https_port)s/external">
</iframe>
</body>
</html>
""")

ExternalResource = _html_resource("""
<html>
<body>EXTERNAL</body>
</html>
""")


JsRedirect = _html_resource("""
<html><body>
Redirecting now..
<script> window.location = '/jsredirect-target'; </script>
</body></html>
""")

JsRedirectSlowImage = _html_resource("""
<html><body>
Redirecting now..
<img width=10 heigth=10 src="/slow.gif?n=2">
<script> window.location = '/jsredirect-target'; </script>
</body></html>
""")

JsRedirectOnload = _html_resource("""
<html>
<head>
<script>
window.onload = function(){
    window.location = '/jsredirect-target';
}
</script>
</head>
<body>Redirecting on window.load...</body>
</html>
""")

JsRedirectTimer = _html_resource("""
<html>
<head>
<script>
window.setTimeout(function(){
    window.location = '/jsredirect-target';
}, 100);
</script>
</head>
<body>Redirecting on setTimeout callback...</body>
</html>
""")

JsRedirectInfinite = _html_resource("""
<html>
<head><script> window.location = '/jsredirect-infinite2'; </script></head>
<body>Redirecting infinitely, step #1</body>
</html>
""")

JsRedirectInfinite2 = _html_resource("""
<html>
<head><script> window.location = '/jsredirect-infinite'; </script></head>
<body>Redirecting infinitely, step #2</body>
</html>
""")

JsRedirectToJsRedirect = _html_resource("""
<html><body>
Redirecting to an another redirecting page..
<script>
window.location = '/jsredirect';
</script>
</body></html>
""")

JsRedirectTarget = _html_resource("""
<html><body> JS REDIRECT TARGET </body></html>
""")

MetaRedirect0 = _html_resource("""
<html><head>
<meta http-equiv="REFRESH" content="0; URL=/meta-redirect-target/">
</head>
<body></body></html>
""")

MetaRedirectSlowLoad = _html_resource("""
<html><head>
<meta http-equiv="REFRESH" content="0; URL=/meta-redirect-target/">
</head>
<body><img src="/delay?n=0.2"></body></html>
""")

MetaRedirectSlowLoad2 = _html_resource("""
<html><head>
<meta http-equiv="REFRESH" content="0; URL=/meta-redirect-target/">
</head>
<body><img width=10 heigth=10 src="/slow.gif?n=2"></body></html>
""")

MetaRedirect1 = _html_resource("""
<html><head>
<meta http-equiv="REFRESH" content="0.2; URL=/meta-redirect-target/">
</head>
<body>
""")

MetaRedirectTarget = _html_resource("""
<html><body> META REDIRECT TARGET </body></html>
""")


class HttpRedirectResource(Resource):
    def render_GET(self, request):
        code = request.args['code'][0]
        url = '/getrequest?http_code=%s' % code
        request.setResponseCode(int(code))
        request.setHeader(b"location", url)
        request.finish()
        return NOT_DONE_YET


class CP1251Resource(Resource):
    def render_GET(self, request):
        request.setHeader("Content-Type", "text/html; charset=windows-1251")
        return u'''
                <html>
                <head>
                <meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
                </head>
                <body>проверка</body>
                </html>
                '''.strip().encode('cp1251')


class InvalidContentTypeResource(Resource):
    def render_GET(self, request):
        request.setHeader("Content-Type", "ABRACADABRA: text/html; charset=windows-1251")
        return u'''проверка'''.encode('cp1251')


class Index(Resource):
    isLeaf = True

    def __init__(self, rootChildren):
        self.rootChildren = rootChildren

    def render(self, request):

        links = "\n".join([
            "<li><a href='%s'>%s</a></li>" % (path, path)
            for (path, child) in self.rootChildren.items() if path
        ])
        return """
        <html>
        <body><ul>%s</ul></body>
        </html>
        """ % links


class Root(Resource):

    def __init__(self, http_port, https_port, proxy_port):
        Resource.__init__(self)
        self.log = []
        self.putChild("postrequest", PostResource())
        self.putChild("getrequest", GetResource())

        self.putChild("jsrender", JsRender())
        self.putChild("jsalert", JsAlert())
        self.putChild("jsconfirm", JsConfirm())
        self.putChild("jsinterval", JsInterval())
        self.putChild("jsviewport", JsViewport())
        self.putChild("tall", TallPage())
        self.putChild("baseurl", BaseUrl())
        self.putChild("delay", Delay())
        self.putChild("slow.gif", SlowImage())
        self.putChild("iframes", IframeResource(http_port))
        self.putChild("externaliframe", ExternalIFrameResource(https_port=https_port))
        self.putChild("external", ExternalResource())
        self.putChild("cp1251", CP1251Resource())
        self.putChild("cp1251-invalid", InvalidContentTypeResource())

        self.putChild("jsredirect", JsRedirect())
        self.putChild("jsredirect-slowimage", JsRedirectSlowImage())
        self.putChild("jsredirect-onload", JsRedirectOnload())
        self.putChild("jsredirect-timer", JsRedirectTimer())
        self.putChild("jsredirect-chain", JsRedirectToJsRedirect())
        self.putChild("jsredirect-target", JsRedirectTarget())
        self.putChild("jsredirect-infinite", JsRedirectInfinite())
        self.putChild("jsredirect-infinite2", JsRedirectInfinite2())

        self.putChild("meta-redirect0", MetaRedirect0())
        self.putChild("meta-redirect-slowload", MetaRedirectSlowLoad())
        self.putChild("meta-redirect-slowload2", MetaRedirectSlowLoad2())
        self.putChild("meta-redirect1", MetaRedirect1())
        self.putChild("meta-redirect-target", MetaRedirectTarget())
        self.putChild("http-redirect", HttpRedirectResource())

        self.putChild("", Index(self.children))


def cert_path():
    return os.path.join(os.path.dirname(__file__), "server.pem")

def ssl_factory():
    pem = cert_path()
    return ssl.DefaultOpenSSLContextFactory(pem, pem)


class ProxyClient(proxy.ProxyClient):
    def handleResponsePart(self, buffer):
        buffer = buffer.replace('</body>', ' PROXY_USED</body>')
        proxy.ProxyClient.handleResponsePart(self, buffer)

class ProxyClientFactory(proxy.ProxyClientFactory):
    protocol = ProxyClient

class ProxyRequest(proxy.ProxyRequest):
    protocols = {'http': ProxyClientFactory}

class Proxy(proxy.Proxy):
    requestFactory = ProxyRequest

class ProxyFactory(http.HTTPFactory):
    protocol = Proxy


def run(port_num, sslport_num, proxyport_num):
    root = Root(port_num, sslport_num, proxyport_num)
    factory = Site(root)
    port = reactor.listenTCP(port_num, factory)
    sslport = reactor.listenSSL(sslport_num, factory, ssl_factory())
    proxyport = reactor.listenTCP(proxyport_num, ProxyFactory())

    def print_listening():
        h = port.getHost()
        s = sslport.getHost()
        p = proxyport.getHost()
        print "Mock server running at http://%s:%d (http), https://%s:%d (https) and http://%s:%d (proxy)" % \
            (h.host, h.port, s.host, s.port, p.host, p.port)
    reactor.callWhenRunning(print_listening)
    reactor.run()


if __name__ == "__main__":
    op = optparse.OptionParser()
    op.add_option("--http-port", type=int, default=8998)
    op.add_option("--https-port", type=int, default=8999)
    op.add_option("--proxy-port", type=int, default=8990)
    opts, _ = op.parse_args()

    run(opts.http_port, opts.https_port, opts.proxy_port)

########NEW FILE########
__FILENAME__ = stress
import sys, requests, random, optparse, time, json
from itertools import islice
from Queue import Queue
from threading import Thread
from collections import Counter


class StressTest():

    def __init__(self, reqs, host="localhost:8050", requests=1000, concurrency=50, shuffle=False, verbose=False):
        self.reqs = reqs
        self.host = host
        self.requests = requests
        self.concurrency = concurrency
        self.shuffle = shuffle
        self.verbose = verbose

    def run(self):
        args = list(islice(self.reqs, self.requests))
        if self.shuffle:
            random.shuffle(args)
        print "Total requests: %d" % len(args)
        print "Concurrency   : %d" % self.concurrency

        starttime = time.time()
        q, p = Queue(), Queue()
        for _ in xrange(self.concurrency):
            t = Thread(target=worker, args=(self.host, q, p, self.verbose))
            t.daemon = True
            t.start()
        for a in args:
            q.put(a)
        q.join()

        outputs = []
        for _ in xrange(self.requests):
            outputs.append(p.get())

        elapsed = time.time() - starttime
        print
        print "Total requests: %d" % len(args)
        print "Concurrency   : %d" % self.concurrency
        print "Elapsed time  : %.3fs" % elapsed
        print "Avg time p/req: %.3fs" % (elapsed/len(args))
        print "Received (per status code or error):"
        for c, n in Counter(outputs).items():
            print "  %s: %d" % (c, n)

def worker(host, q, p, verbose=False):
    url = "http://%s/render.html" % host
    while True:
        try:
            args = q.get()
            t = time.time()
            r = requests.get(url, params=args)
            t = time.time() -t
            p.put(r.status_code)
            if verbose:
                print ". %.3fs %s" % (t, args)
            else:
                sys.stdout.write(".")
                sys.stdout.flush()
        except Exception as e:
            p.put(type(e))
            if verbose:
                print "E %.3fs %s" % (t, args)
            else:
                sys.stdout.write("E")
                sys.stdout.flush()
        finally:
            q.task_done()


class MockArgs(object):

    ok_urls = 0.5
    error_urls = 0.3
    timeout_urls = 0.2

    def __init__(self, requests=1000):
        self.requests = requests

    def _ok_urls(self):
        url = ["http://localhost:8998/jsrender"]
        return int(self.requests * self.ok_urls) * url

    def _error_urls(self):
        url = ["http://non-existent-host/"]
        return int(self.requests * self.error_urls) * url

    def _timeout_urls(self):
        url = ["http://localhost:8998/delay?n=10&timeout=0.5"]
        return int(self.requests * self.timeout_urls) * url

    def __iter__(self):
        ok_urls = self._ok_urls()
        error_urls = self._error_urls()
        timeout_urls = self._timeout_urls()
        urls = ok_urls + error_urls + timeout_urls
        return ({"url": x} for x in urls)


class ArgsFromUrlFile(object):

    def __init__(self, urlfile):
        self.urlfile = urlfile

    def __iter__(self):
        for l in open(self.urlfile):
            yield {"url": l.rstrip()}

class ArgsFromLogfile(object):

    def __init__(self, logfile):
        self.logfile = logfile

    def __iter__(self):
        for l in open(self.logfile):
            if "[stats]" in l:
                d = json.loads(l[33:].rstrip())
                yield d['args']


def parse_opts():
    op = optparse.OptionParser()
    op.add_option("-H", dest="host", default="localhost:8050",
            help="splash hostname & port (default: %default)")
    op.add_option("-u", dest="urlfile", metavar="FILE",
            help="read urls from FILE instead of using mock server ones")
    op.add_option("-l", dest="logfile", metavar="FILE",
            help="read urls from splash log file (useful for replaying)")
    op.add_option("-s", dest="shuffle", action="store_true", default=False,
            help="shuffle (randomize) requests (default: %default)")
    op.add_option("-v", dest="verbose", action="store_true", default=False,
            help="verbose mode (default: %default)")
    op.add_option("-c", dest="concurrency", type="int", default=50,
            help="concurrency (default: %default)")
    op.add_option("-n", dest="requests", type="int", default=1000,
            help="number of requests (default: %default)")
    return op.parse_args()

def main():
    opts, _ = parse_opts()
    if opts.urlfile:
        urls = ArgsFromUrlFile(opts.urlfile)
    elif opts.logfile:
        urls = ArgsFromLogfile(opts.logfile)
    else:
        urls = MockArgs(opts.requests)
    t = StressTest(urls, opts.host, opts.requests, opts.concurrency, opts.shuffle, opts.verbose)
    t.run()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = test_proxy
# -*- coding: utf-8 -*-
from __future__ import absolute_import
import os
import shutil
import unittest
import requests
from splash.proxy import BlackWhiteSplashProxyFactory, ProfilesSplashProxyFactory
from splash.tests.test_render import BaseRenderTest
from splash.tests import ts
from splash.tests.utils import TestServers

class BlackWhiteProxyFactoryTest(unittest.TestCase):

    def _factory(self, **kwargs):
        params = {
            "proxy_list": [("proxy.crawlera.com", 8010, "username", "password")],
            "whitelist": [
                r".*scrapinghub\.com.*",
            ],
            "blacklist": [
                r".*\.js",
                r".*\.css",
            ]
        }
        params.update(kwargs)
        return BlackWhiteSplashProxyFactory(**params)

    def test_noproxy(self):
        f = BlackWhiteSplashProxyFactory()
        self.assertFalse(f.shouldUseProxyList('http', 'crawlera.com'))

    def test_whitelist(self):
        self.assertUsesCustom('http://www.scrapinghub.com')
        self.assertUsesDefault('http://www.google-analytics.com/ga.js')
        self.assertUsesDefault('http://crawlera.com')

    def test_blacklist(self):
        self.assertUsesDefault('http://www.scrapinghub.com/static/styles/screen.css')

    def test_no_whitelist(self):
        self.assertUsesCustom('http://crawlera.com', whitelist=[])
        self.assertUsesDefault('http://www.google-analytics.com/ga.js', whitelist=[])


    def assertUsesDefault(self, url, protocol='http', **kwargs):
        f = self._factory(**kwargs)
        self.assertFalse(f.shouldUseProxyList(protocol, url))

    def assertUsesCustom(self, url, protocol='http', **kwargs):
        f = self._factory(**kwargs)
        self.assertTrue(f.shouldUseProxyList(protocol, url))


class BaseHtmlProxyTest(BaseRenderTest):
    def assertProxied(self, html):
        assert 'PROXY_USED' in html

    def assertNotProxied(self, html):
        assert 'PROXY_USED' not in html


class HtmlProxyRenderTest(BaseHtmlProxyTest):

    def test_proxy_works(self):
        r1 = self.request({'url': ts.mockserver.url('jsrender')})
        self.assertNotProxied(r1.text)

        r2 = self.request({'url': ts.mockserver.url('jsrender'), 'proxy': 'test'})
        self.assertProxied(r2.text)

    def test_blacklist(self):
        params = {'url': ts.mockserver.url('iframes'),
                  'proxy': 'test', 'html': 1, 'iframes': 1}
        r = self.request(params, render_format='json')
        data = r.json()

        # only 1.html is blacklisted in test.ini
        self.assertProxied(data['html'])
        assert any('1.html' in f['requestedUrl'] for f in data['childFrames'])

        for frame in data['childFrames']:
            if '1.html' in frame['requestedUrl']:
                self.assertNotProxied(frame['html'])
            else:
                self.assertProxied(frame['html'])

    def test_insecure(self):
        r = self.request({'url': ts.mockserver.url('jsrender'),
                          'proxy': '../this-is-not-a-proxy-profile'})
        self.assertEqual(r.status_code, 400)
        self.assertEqual(r.text.strip(), ProfilesSplashProxyFactory.NO_PROXY_PROFILE_MSG)


    def test_nonexisting(self):
        r = self.request({'url': ts.mockserver.url('jsrender'),
                          'proxy': 'nonexisting'})
        self.assertEqual(r.status_code, 400)
        self.assertEqual(r.text.strip(), ProfilesSplashProxyFactory.NO_PROXY_PROFILE_MSG)

    def test_no_proxy_settings(self):
        r = self.request({'url': ts.mockserver.url('jsrender'),
                          'proxy': 'no-proxy-settings'})
        self.assertEqual(r.status_code, 400)


class HtmlProxyDefaultProfileTest(BaseHtmlProxyTest):

    def ts2_request(self, ts2, query, render_format='html'):
        url = "http://localhost:%s/render.%s" % (ts2.splashserver.portnum, render_format)
        return requests.get(url, params=query)

    def create_default_ini(self, ts2):
        src = os.path.join(ts2.proxy_profiles_path, 'test.ini')
        dst = os.path.join(ts2.proxy_profiles_path, 'default.ini')
        shutil.copyfile(src, dst)

    def remove_default_ini(self, ts2):
        dst = os.path.join(ts2.proxy_profiles_path, 'default.ini')
        os.unlink(dst)

    def test_ts_setup(self):
        with TestServers() as ts2:
            r1 = self.ts2_request(ts2, {'url': ts2.mockserver.url('jsrender')})
            self.assertNotProxied(r1.text)

            r2 = self.ts2_request(ts2, {
                'url': ts2.mockserver.url('jsrender'),
                'proxy': 'test',
            })
            self.assertProxied(r2.text)

    def test_default_profile_works(self):
        with TestServers() as ts2:
            self.create_default_ini(ts2)
            try:
                # default.ini present, proxy is used by default
                r1 = self.ts2_request(ts2, {'url': ts2.mockserver.url('jsrender')})
                self.assertProxied(r1.text)

                # another proxy
                r2 = self.ts2_request(ts2, {
                    'url': ts2.mockserver.url('jsrender'),
                    'proxy': 'test',
                })
                self.assertProxied(r2.text)

                # invalid proxy profile
                r3 = self.ts2_request(ts2, {
                    'url': ts2.mockserver.url('jsrender'),
                    'proxy': 'nonexisting',
                })
                self.assertEqual(r3.status_code, 400)

                # 'none' disables default.ini
                r4 = self.ts2_request(ts2, {
                    'url': ts2.mockserver.url('jsrender'),
                    'proxy': 'none',
                })
                self.assertNotProxied(r4.text)

                # empty 'proxy' argument disables default.ini
                r5 = self.ts2_request(ts2, {
                    'url': ts2.mockserver.url('jsrender'),
                    'proxy': '',
                })
                self.assertNotProxied(r5.text)

            finally:
                self.remove_default_ini(ts2)

########NEW FILE########
__FILENAME__ = test_proxy_server
import unittest, requests, urlparse, json
from splash.tests import ts, test_render


SPLASH_HEADER_PREFIX = 'x-splash-'


class ProxyRequestHandler(object):

    render_format = "html"

    @property
    def proxies(self):
        return {'http': 'http://localhost:%d' % ts.splashserver.proxy_portnum}

    def _get_val(self, v):
        if isinstance(v, list):
            return v[0]
        else:
            return v

    def _get_header(self, name):
        return SPLASH_HEADER_PREFIX + name.replace('_', '-')

    def request(self, query, render_format=None, headers=None):
        render_format = render_format or self.render_format

        _headers = {self._get_header('render'): render_format}
        _headers.update(headers or {})
        if not isinstance(query, dict):
            query = urlparse.parse_qs(query)

        url = self._get_val(query.get('url'))
        for k, v in query.items():
            if k != 'url':
                _headers[self._get_header(k)] = self._get_val(v)

        return requests.get(url, headers=_headers, proxies=self.proxies)

    def post(self, query, render_format=None, payload=None, headers=None):
        render_format = render_format or self.render_format

        _headers = {self._get_header('render'): render_format}
        _headers.update(headers or {})

        if not isinstance(query, dict):
            query = urlparse.parse_qs(query)

        url = self._get_val(query.get('url'))
        for k, v in query.items():
            if k != 'url':
                _headers[self._get_header(k)] = self._get_val(v)

        return requests.post(url, data=payload, headers=_headers,
                             proxies=self.proxies)


class ProxyRenderHtmlTest(test_render.RenderHtmlTest):

    request_handler = ProxyRequestHandler
    https_supported = False
    proxy_test = True


class ProxyRenderPngTest(test_render.RenderPngTest):

    request_handler = ProxyRequestHandler
    https_supported = False
    proxy_test = True


class ProxyRenderJsonTest(test_render.RenderJsonTest):

    request_handler = ProxyRequestHandler
    https_supported = False
    proxy_test = True


class ProxyRunJsTest(test_render.RunJsTest):

    request_handler = ProxyRequestHandler
    proxy_test = True

    def _runjs_request(self, js_source, render_format=None, params=None, headers=None):
        query = {'url': ts.mockserver.url("jsrender"),
                 'js_source': js_source,
                 'script': 1}
        query.update(params or {})
        return self.request(query, render_format=render_format)


class ProxyPostTest(test_render.BaseRenderTest):

    request_handler = ProxyRequestHandler

    def test_post_request(self):
        r = self.post({"url": ts.mockserver.url("postrequest")})
        self.assertEqual(r.status_code, 200)
        self.assertTrue("From POST" in r.text)

    def test_post_headers(self):
        headers = {
            'X-Custom-Header1': 'some-val1',
            'Custom-Header2': 'some-val2',
        }
        r = self.post({"url": ts.mockserver.url("postrequest")}, headers=headers)
        self.assertEqual(r.status_code, 200)
        self.assertIn("'x-custom-header1': 'some-val1'", r.text)
        self.assertIn("'custom-header2': 'some-val2'", r.text)
        self.assertNotIn("x-splash", r.text.lower())

    # unittest.expectedFailure doesn't work with nose
    @unittest.skipIf(True, "expected failure")
    def test_post_request_baseurl(self):
        r = self.post({
            "url": ts.mockserver.url("postrequest"),
            "baseurl": ts.mockserver.url("postrequest"),
        })
        self.assertEqual(r.status_code, 200)
        self.assertTrue("From POST" in r.text)

    # unittest.expectedFailure doesn't work with nose
    @unittest.skipIf(True, "expected failure")
    def test_post_headers_baseurl(self):
        headers = {
            'X-Custom-Header1': 'some-val1',
            'Custom-Header2': 'some-val2',
        }
        r = self.post({
                "url": ts.mockserver.url("postrequest"),
                "baseurl": ts.mockserver.url("postrequest")
            },
            headers=headers
        )
        self.assertEqual(r.status_code, 200)
        self.assertIn("'x-custom-header1': 'some-val1'", r.text)
        self.assertIn("'custom-header2': 'some-val2'", r.text)
        self.assertNotIn("x-splash", r.text.lower())

    def test_post_user_agent(self):
        r = self.post({"url": ts.mockserver.url("postrequest")}, headers={
            'User-Agent': 'Mozilla',
        })
        self.assertEqual(r.status_code, 200)
        self.assertNotIn("x-splash", r.text.lower())
        self.assertIn("'user-agent': 'Mozilla'", r.text)

    def test_post_payload(self):
        # simply post body
        payload = {'some': 'data'}
        json_payload = json.dumps(payload)
        r = self.post({"url": ts.mockserver.url("postrequest")}, payload=json_payload)
        self.assertEqual(r.status_code, 200)
        self.assertIn(json_payload, r.text)

        # form encoded fields
        payload = {'form_field1': 'value1',
                   'form_field2': 'value2', }
        r = self.post({"url": ts.mockserver.url("postrequest")}, payload=payload)
        self.assertEqual(r.status_code, 200)
        self.assertIn('form_field2=value2&amp;form_field1=value1', r.text)


class ProxyGetTest(test_render.BaseRenderTest):
    request_handler = ProxyRequestHandler

    def test_get_headers(self):
        headers = {
            'X-Custom-Header1': 'some-val1',
            'Custom-Header2': 'some-val2',
            'User-Agent': 'Mozilla',
        }
        r = self.request({"url": ts.mockserver.url("getrequest")}, headers=headers)
        self.assertEqual(r.status_code, 200)
        self.assertIn("'x-custom-header1': 'some-val1'", r.text)
        self.assertIn("'custom-header2': 'some-val2'", r.text)
        self.assertIn("'user-agent': 'Mozilla'", r.text)
        self.assertNotIn("x-splash", r.text)


class NoProxyGetTest(test_render.BaseRenderTest):

    def test_get_headers(self):
        headers = {
            'X-Custom-Header1': 'some-val1',
            'Custom-Header2': 'some-val2',
            'User-Agent': 'Mozilla',
        }
        r = self.request({"url": ts.mockserver.url("getrequest")}, headers=headers)
        self.assertEqual(r.status_code, 200)
        self.assertNotIn("'x-custom-header1': 'some-val1'", r.text)
        self.assertNotIn("'custom-header2': 'some-val2'", r.text)
        self.assertNotIn("'user-agent': 'Mozilla'", r.text)
        self.assertNotIn("x-splash", r.text)


class NoProxyPostTest(test_render.BaseRenderTest):

    def test_post_headers(self):
        headers = {
            'X-Custom-Header1': 'some-val1',
            'Custom-Header2': 'some-val2',
            'Content-Type': 'application/javascript', # required by non-proxy POSTs
        }
        r = self.post({"url": ts.mockserver.url("postrequest")}, headers=headers)
        self.assertEqual(r.status_code, 200)
        self.assertNotIn("'x-custom-header1': 'some-val1'", r.text)
        self.assertNotIn("'custom-header2': 'some-val2'", r.text)
        self.assertNotIn("x-splash", r.text.lower())
        self.assertNotIn("'content-type': 'application/javascript'", r.text)

    def test_post_user_agent(self):
        r = self.post({"url": ts.mockserver.url("postrequest")}, headers={
            'User-Agent': 'Mozilla',
            'Content-Type': 'application/javascript',  # required by non-proxy POSTs
        })
        self.assertEqual(r.status_code, 200)
        self.assertNotIn("x-splash", r.text.lower())
        self.assertNotIn("'user-agent': 'Mozilla'", r.text)
        self.assertNotIn("'content-type': 'application/javascript'", r.text)

########NEW FILE########
__FILENAME__ = test_redirects
# -*- coding: utf-8 -*-
from __future__ import absolute_import
from splash.tests.test_render import BaseRenderTest
from splash.tests import ts


class HttpRedirectTest(BaseRenderTest):

    def assertHttpRedirectWorks(self, code):
        r = self.request({"url": ts.mockserver.url("http-redirect?code=%s" % code)})
        self.assertEqual(r.status_code, 200)
        self.assertIn("GET request", r.text)
        self.assertIn("{'http_code': ['%s']}" % code, r.text)

    def test_301(self):
        self.assertHttpRedirectWorks(301)

    def test_302(self):
        self.assertHttpRedirectWorks(302)

    def test_303(self):
        self.assertHttpRedirectWorks(303)

    def test_307(self):
        self.assertHttpRedirectWorks(307)


class MetaRedirectTest(BaseRenderTest):

    def assertRedirected(self, resp):
        self.assertEqual(resp.status_code, 200)
        self.assertIn("META REDIRECT TARGET", resp.text)

    def assertNotRedirected(self, resp):
        self.assertEqual(resp.status_code, 200)
        self.assertIn('<meta http-equiv="REFRESH"', resp.text)

    def test_meta_redirect_nowait(self):
        r = self.request({'url': ts.mockserver.url('meta-redirect0')})
        self.assertNotRedirected(r)

    def test_meta_redirect_wait(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect0'),
            'wait': 0.1,
        })
        self.assertRedirected(r)

    def test_meta_redirect_delay_wait(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect1'),
            'wait': 0.1,
        })
        self.assertNotRedirected(r)

    def test_meta_redirect_delay_wait_enough(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect1'),
            'wait': 0.3,
        })
        self.assertRedirected(r)

    def test_meta_redirect_slowload(self):
        r = self.request({'url': ts.mockserver.url('meta-redirect-slowload')})
        self.assertNotRedirected(r)

    def test_meta_redirect_slowload_wait(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect-slowload'),
            'wait': 0.1,
        })
        self.assertRedirected(r)

    def test_meta_redirect_slowload_wait_more(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect-slowload'),
            'wait': 0.3,
        })
        self.assertRedirected(r)

    def test_meta_redirect_slowload2(self):
        r = self.request({'url': ts.mockserver.url('meta-redirect-slowload2')})
        self.assertNotRedirected(r)

    def test_meta_redirect_slowload2_wait(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect-slowload2'),
            'wait': 0.1,
        })
        self.assertRedirected(r)

    def test_meta_redirect_slowload2_wait_more(self):
        r = self.request({
            'url': ts.mockserver.url('meta-redirect-slowload2'),
            'wait': 0.3,
        })
        self.assertRedirected(r)


class JsRedirectTest(BaseRenderTest):
    def assertRedirected(self, resp):
        self.assertEqual(resp.status_code, 200)
        self.assertIn("JS REDIRECT TARGET", resp.text)

    def assertNotRedirected(self, resp):
        self.assertEqual(resp.status_code, 200)
        self.assertNotIn("JS REDIRECT TARGET", resp.text)
        self.assertIn("Redirecting", resp.text)

    def test_redirect_nowait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect')})
        self.assertNotRedirected(r)

    def test_redirect_wait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect'), 'wait': 0.1})
        self.assertRedirected(r)

    def test_redirect_onload_nowait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-onload')})
        self.assertNotRedirected(r)

    def test_redirect_onload_wait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-onload'), 'wait': 0.1})
        self.assertRedirected(r)

    def test_redirect_timer_nowait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-timer')})
        self.assertNotRedirected(r)

    def test_redirect_timer_wait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-timer'), 'wait': 0.05})
        self.assertNotRedirected(r)

    def test_redirect_timer_wait_enough(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-timer'), 'wait': 0.2})
        self.assertRedirected(r)

    def test_redirect_chain_nowait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-chain')})
        self.assertNotRedirected(r)

    def test_redirect_chain_wait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-chain'), 'wait': 0.2})
        self.assertRedirected(r)

    def test_redirect_slowimage_nowait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-slowimage')})
        self.assertRedirected(r)

    def test_redirect_slowimage_wait(self):
        r = self.request({'url': ts.mockserver.url('jsredirect-slowimage'), 'wait': 0.1})
        self.assertRedirected(r)

    def test_redirect_slowimage_nowait_baseurl(self):
        r = self.request({
            'url': ts.mockserver.url('jsredirect-slowimage'),
            'baseurl': ts.mockserver.url('/'),
        })
        self.assertRedirected(r)

    def test_redirect_slowimage_wait_baseurl(self):
        r = self.request({
            'url': ts.mockserver.url('jsredirect-slowimage'),
            'baseurl': ts.mockserver.url('/'),
            'wait': 0.1
        })
        self.assertRedirected(r)

    # TODO: support for jsredirect-infinite

########NEW FILE########
__FILENAME__ = test_render
# -*- coding: utf-8 -*-
import unittest, requests, json, base64, urllib
from functools import wraps
from cStringIO import StringIO
from PIL import Image
from splash.tests import ts
from splash.tests.utils import NON_EXISTING_RESOLVABLE
from splash.tests.utils import SplashServer


def https_only(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            if self.__class__.https_supported:
                func(self, *args, **kwargs)
        except AttributeError:
            func(self, *args, **kwargs)
    return wrapper


def skip_proxy(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            if self.__class__.proxy_test is False:
                func(self, *args, **kwargs)
        except AttributeError:
            func(self, *args, **kwargs)
    return wrapper


class DirectRequestHandler(object):

    render_format = "html"

    @property
    def host(self):
        return "localhost:%s" % ts.splashserver.portnum

    def request(self, query, render_format=None, headers=None):
        render_format = render_format or self.render_format
        if isinstance(query, dict):
            url = "http://%s/render.%s" % (self.host, render_format)
            return requests.get(url, params=query, headers=headers)
        else:
            url = "http://%s/render.%s?%s" % (self.host, render_format, query)
            return requests.get(url, headers=headers)

    def post(self, query, render_format=None, payload=None, headers=None):
        render_format = render_format or self.render_format
        if isinstance(query, dict):
            url = "http://%s/render.%s" % (self.host, render_format)
            return requests.post(url, params=query, data=payload, headers=headers)
        else:
            url = "http://%s/render.%s?%s" % (self.host, render_format, query)
            return requests.post(url, data=payload, headers=headers)


class BaseRenderTest(unittest.TestCase):

    render_format = "html"
    request_handler = DirectRequestHandler

    def tearDown(self):
        # we must consume splash output because subprocess.PIPE is used
        ts.print_output()
        super(BaseRenderTest, self).tearDown()

    def _get_handler(self):
        handler = self.request_handler()
        handler.render_format = self.render_format
        return handler

    def request(self, query, render_format=None, headers=None):
        return self._get_handler().request(query, render_format, headers)

    def post(self, query, render_format=None, payload=None, headers=None):
        return self._get_handler().post(query, render_format, payload, headers)


class _RenderTest(BaseRenderTest):

    @unittest.skipIf(NON_EXISTING_RESOLVABLE, "non existing hosts are resolvable")
    def test_render_error(self):
        r = self.request({"url": "http://non-existent-host/"})
        self.assertEqual(r.status_code, 502)

    def test_timeout(self):
        r = self.request({"url": ts.mockserver.url("delay?n=10"), "timeout": "0.5"})
        self.assertEqual(r.status_code, 504)

    def test_timeout_out_of_range(self):
        r = self.request({"url": ts.mockserver.url("delay?n=10"), "timeout": "999"})
        self.assertEqual(r.status_code, 400)

    @skip_proxy
    def test_missing_url(self):
        r = self.request("")
        self.assertEqual(r.status_code, 400)
        self.assertTrue("url" in r.text)

    def test_jsalert(self):
        r = self.request({"url": ts.mockserver.url("jsalert"), "timeout": "3"})
        self.assertEqual(r.status_code, 200)

    def test_jsconfirm(self):
        r = self.request({"url": ts.mockserver.url("jsconfirm"), "timeout": "3"})
        self.assertEqual(r.status_code, 200)

    def test_iframes(self):
        r = self.request({"url": ts.mockserver.url("iframes"), "timeout": "3"})
        self.assertEqual(r.status_code, 200)

    def test_wait(self):
        r1 = self.request({"url": ts.mockserver.url("jsinterval")})
        r2 = self.request({"url": ts.mockserver.url("jsinterval")})
        r3 = self.request({"url": ts.mockserver.url("jsinterval"), "wait": "0.2"})
        self.assertEqual(r1.status_code, 200)
        self.assertEqual(r2.status_code, 200)
        self.assertEqual(r3.status_code, 200)
        self.assertEqual(r1.content, r2.content)
        self.assertNotEqual(r1.content, r3.content)


class RenderHtmlTest(_RenderTest):

    render_format = "html"

    def test_ok(self):
        self._test_ok(ts.mockserver.url("jsrender"))

    @https_only
    def test_ok_https(self):
        self._test_ok(ts.mockserver.https_url("jsrender"))

    def _test_ok(self, url):
        r = self.request("url=%s" % url)
        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers["content-type"].lower(), "text/html; charset=utf-8")
        self.assertTrue("Before" not in r.text)
        self.assertTrue("After" in r.text)

    def test_baseurl(self):
        # first make sure that script.js is served under the right url
        self.assertEqual(404, requests.get(ts.mockserver.url("script.js")).status_code)
        self.assertEqual(200, requests.get(ts.mockserver.url("baseurl/script.js")).status_code)

        # r = self.request("url=http://localhost:8998/baseurl&baseurl=http://localhost:8998/baseurl/")
        r = self.request({
            "url": ts.mockserver.url("baseurl"),
            "baseurl": ts.mockserver.url("baseurl/"),
        })
        self.assertEqual(r.status_code, 200)
        self.assertTrue("Before" not in r.text)
        self.assertTrue("After" in r.text)

    def test_otherdomain(self):
        r = self.request({"url": ts.mockserver.url("iframes")})
        self.assertEqual(r.status_code, 200)
        self.assertTrue('SAME_DOMAIN' in r.text)
        self.assertTrue('OTHER_DOMAIN' in r.text)

    def test_allowed_domains(self):
        r = self.request({'url': ts.mockserver.url('iframes'), 'allowed_domains': 'localhost'})
        self.assertEqual(r.status_code, 200)
        self.assertTrue('SAME_DOMAIN' in r.text)
        self.assertFalse('OTHER_DOMAIN' in r.text)

    def test_viewport(self):
        r = self.request({'url': ts.mockserver.url('jsviewport'), 'viewport': '300x400'})
        self.assertEqual(r.status_code, 200)
        self.assertIn('300x400', r.text)

    def test_nonascii_url(self):
        nonascii_value =  u'тест'.encode('utf8')
        url = ts.mockserver.url('getrequest') + '?param=' + nonascii_value
        r = self.request({'url': url})
        self.assertEqual(r.status_code, 200)
        self.assertTrue(
            repr(nonascii_value) in r.text or  # direct request
            urllib.quote(nonascii_value) in r.text,  # request in proxy mode
            r.text
        )

    def test_result_encoding(self):
        r1 = requests.get(ts.mockserver.url('cp1251'))
        self.assertEqual(r1.status_code, 200)
        self.assertEqual(r1.encoding, 'windows-1251')
        self.assertTrue(u'проверка' in r1.text)

        r2 = self.request({'url': ts.mockserver.url('cp1251')})
        self.assertEqual(r2.status_code, 200)
        self.assertEqual(r2.encoding, 'utf-8')
        self.assertTrue(u'проверка' in r2.text)


class RenderPngTest(_RenderTest):

    render_format = "png"

    def test_ok(self):
        self._test_ok(ts.mockserver.url("jsrender"))

    @https_only
    def test_ok_https(self):
        self._test_ok(ts.mockserver.https_url("jsrender"))

    def _test_ok(self, url):
        r = self.request("url=%s" % url)
        self.assertPng(r, width=1024, height=768)

    def test_width(self):
        r = self.request({"url": ts.mockserver.url("jsrender"), "width": "300"})
        self.assertPng(r, width=300)

    def test_width_height(self):
        r = self.request({"url": ts.mockserver.url("jsrender"), "width": "300", "height": "100"})
        self.assertPng(r, width=300, height=100)

    def test_range_checks(self):
        for arg in ('width', 'height'):
            for val in (-1, 99999):
                url = ts.mockserver.url("jsrender")
                r = self.request("url=%s&%s=%d" % (url, arg, val))
                self.assertEqual(r.status_code, 400)

    def test_viewport_full_wait(self):
        r = self.request({'url': ts.mockserver.url("jsrender"), 'viewport': 'full'})
        self.assertEqual(r.status_code, 400)

        r = self.request({'url': ts.mockserver.url("jsrender"), 'viewport': 'full', 'wait': 0.1})
        self.assertEqual(r.status_code, 200)

    def test_viewport_checks(self):
        for viewport in ['99999x1', '1x99999', 'foo', '1xfoo', 'axe', '9000x9000', '-1x300']:
            r = self.request({'url': ts.mockserver.url("jsrender"), 'viewport': viewport})
            self.assertEqual(r.status_code, 400)

    def test_viewport_full(self):
        r = self.request({'url': ts.mockserver.url("tall"), 'viewport': 'full', 'wait': 0.1})
        self.assertPng(r, height=2000)  # 2000px is hardcoded in that html

    def assertPng(self, response, width=None, height=None):
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "image/png")
        img = Image.open(StringIO(response.content))
        self.assertEqual(img.format, "PNG")
        if width is not None:
            self.assertEqual(img.size[0], width)
        if height is not None:
            self.assertEqual(img.size[1], height)
        return img.size


class RenderJsonTest(_RenderTest):

    render_format = 'json'

    def test_jsrender_html(self):
        self.assertSameHtml(ts.mockserver.url("jsrender"))

    @https_only
    def test_jsrender_https_html(self):
        self.assertSameHtml(ts.mockserver.https_url("jsrender"))

    def test_jsalert_html(self):
        self.assertSameHtml(ts.mockserver.url("jsalert"), {'timeout': 3})

    def test_jsconfirm_html(self):
        self.assertSameHtml(ts.mockserver.url("jsconfirm"), {'timeout': 3})

    def test_iframes_html(self):
        self.assertSameHtml(ts.mockserver.url("iframes"), {'timeout': 3})

    def test_allowed_domains_html(self):
        self.assertSameHtml(ts.mockserver.url("iframes"), {'allowed_domains': 'localhost'})


    def test_jsrender_png(self):
        self.assertSamePng(ts.mockserver.url("jsrender"))

    @https_only
    def test_jsrender_https_png(self):
        self.assertSamePng(ts.mockserver.https_url("jsrender"))

    def test_jsalert_png(self):
        self.assertSamePng(ts.mockserver.url("jsalert"), {'timeout': 3})

    def test_jsconfirm_png(self):
        self.assertSamePng(ts.mockserver.url("jsconfirm"), {'timeout': 3})

    def test_iframes_png(self):
        self.assertSamePng(ts.mockserver.url("iframes"), {'timeout': 3})

    def test_png_size(self):
        self.assertSamePng(ts.mockserver.url("jsrender"), {'width': 100})
        self.assertSamePng(ts.mockserver.url("jsrender"), {'width': 100, 'height': 200})
        self.assertSamePng(ts.mockserver.url("jsrender"),
                           {'width': 100, 'height': 200, 'vwidth': 100, 'vheight': 200})
        self.assertSamePng(ts.mockserver.url("jsrender"),
                           {'vwidth': 100})

    def test_png_size_viewport(self):
        self.assertSamePng(ts.mockserver.url("jsrender"), {'wait': 0.1, 'viewport': 'full'})
        self.assertSamePng(ts.mockserver.url("tall"), {'wait': 0.1, 'viewport': 'full'})

    @https_only
    def test_fields_all(self):
        query = {'url': ts.mockserver.https_url("iframes"),
                 "html": 1, "png": 1, "iframes": 1}

        res = self.request(query).json()
        self.assertFieldsInResponse(res, ["html", "png", "url", "requestedUrl",
                                          "childFrames", "geometry", "title"])
        frames = res['childFrames']
        self.assertTrue(frames)
        for frame in frames:
            self.assertFieldsInResponse(frame, ["html", "url", "requestedUrl",
                                               "childFrames", "geometry", "title"])
            # no screenshots for individual frames
            self.assertFieldsNotInResponse(frame, ['png'])

    @https_only
    def test_fields_no_html(self):
        # turn off returning HTML
        query = {'url': ts.mockserver.https_url("iframes"),
                 'html': 0, 'png': 1, 'iframes': 1}

        res = self.request(query).json()
        self.assertFieldsInResponse(res, ["png", "url", "requestedUrl",
                                          "childFrames", "geometry", "title"])
        self.assertFieldsNotInResponse(res, ['html'])

        # html=0 also turns off html for iframes
        frames = res['childFrames']
        self.assertTrue(frames)
        for frame in frames:
            self.assertFieldsInResponse(frame, ["url", "requestedUrl",
                                                "childFrames", "geometry", "title"])
            self.assertFieldsNotInResponse(frame, ['html', 'png'])

    @https_only
    def test_fields_no_screenshots(self):
        # turn off screenshots
        query = {'url': ts.mockserver.https_url("iframes"),
                 'html': 1, 'png': 0, 'iframes': 1}
        res = self.request(query).json()
        self.assertFieldsInResponse(res, ["url", "requestedUrl", "childFrames",
                                          "geometry", "title", "html"])
        self.assertFieldsNotInResponse(res, ["png"])

    @https_only
    def test_fields_no_iframes(self):
        query = {'url': ts.mockserver.https_url("iframes"),
                 'html': 1, 'png': 1, 'iframes': 0}
        res = self.request(query).json()
        self.assertFieldsInResponse(res, ["url", "requestedUrl", "geometry",
                                          "title", "html", "png"])
        self.assertFieldsNotInResponse(res, ["childFrames"])

    @https_only
    def test_fields_default(self):
        query = {'url': ts.mockserver.https_url("iframes")}
        res = self.request(query).json()
        self.assertFieldsInResponse(res, ["url", "requestedUrl", "geometry",
                                          "title"])
        self.assertFieldsNotInResponse(res, ["childFrames", "html", "png"])

    def test_wait(self):
        # override parent's test to make it aware of render.json endpoint
        r1 = self.request({"url": ts.mockserver.url("jsinterval"), 'html': 1})
        r2 = self.request({"url": ts.mockserver.url("jsinterval"), 'html': 1})
        r3 = self.request({"url": ts.mockserver.url("jsinterval"), 'wait': 0.2, 'html': 1})
        self.assertEqual(r1.status_code, 200)
        self.assertEqual(r2.status_code, 200)
        self.assertEqual(r3.status_code, 200)

        html1 = r1.json()['html']
        html2 = r2.json()['html']
        html3 = r3.json()['html']
        self.assertEqual(html1, html2)
        self.assertNotEqual(html1, html3)

    def test_result_encoding(self):
        r = self.request({'url': ts.mockserver.url('cp1251'), 'html': 1})
        self.assertEqual(r.status_code, 200)
        html = r.json()['html']
        self.assertTrue(u'проверка' in html)
        self.assertTrue(u'1251' in html)


    def assertFieldsInResponse(self, res, fields):
        for key in fields:
            self.assertTrue(key in res, "%s is not in response" % key)

    def assertFieldsNotInResponse(self, res, fields):
        for key in fields:
            self.assertTrue(key not in res, "%s is in response" % key)

    def assertSameHtml(self, url, params=None):
        defaults = {'html': 1}
        defaults.update(params or {})
        r1, r2 = self._do_same_requests(url, defaults, 'html')
        html1 = r1.json()['html']
        html2 = r2.text
        self.assertEqual(html1, html2)

    def assertSamePng(self, url, params=None):
        defaults = {'png': 1}
        defaults.update(params or {})
        r1, r2 = self._do_same_requests(url, defaults, 'png')
        png1 = base64.decodestring(r1.json()['png'])
        png2 = r2.content
        self.assertEqual(png1, png2)

    def _do_same_requests(self, url, params, other_format):
        query = {'url': url}
        query.update(params or {})
        r1 = self.request(query, render_format='json')
        r2 = self.request(query, render_format=other_format)
        self.assertEqual(r1.status_code, 200)
        self.assertEqual(r2.status_code, 200)
        return r1, r2


class IframesRenderTest(BaseRenderTest):
    render_format = 'json'

    def test_basic(self):
        self.assertIframesText('IFRAME_1_OK')

    def test_js_iframes(self):
        self.assertIframesText('IFRAME_2_OK')

    def test_delayed_js_iframes(self):
        self.assertNoIframesText('IFRAME_3_OK', {'wait': 0.0})
        self.assertIframesText('IFRAME_3_OK', {'wait': 0.5})

    def test_onload_iframes(self):
        self.assertIframesText('IFRAME_4_OK')

    def test_document_write_iframes(self):
        self.assertIframesText('IFRAME_5_OK')

    def test_nested_iframes(self):
        self.assertIframesText('IFRAME_6_OK')


    def assertIframesText(self, text, params=None):
        data = self._iframes_request(params)
        self.assertTrue(self._text_is_somewhere(data, text))

    def assertNoIframesText(self, text, params=None):
        data = self._iframes_request(params)
        self.assertFalse(self._text_is_somewhere(data, text))

    def _text_is_somewhere(self, result, text):
        if text in result['html']:
            return True
        return any(self._text_is_somewhere(child, text)
                   for child in result['childFrames'])

    def _iframes_request(self, params):
        query = {'url': ts.mockserver.https_url("iframes"),
                 'iframes': 1, 'html': 1}
        query.update(params or {})
        return self.request(query).json()


class RunJsTest(BaseRenderTest):
    render_format = 'json'

    CROSS_DOMAIN_JS = """
    function getContents(){
        var iframe = document.getElementById('external');
        return iframe.contentDocument.getElementsByTagName('body')[0].innerHTML;
    };
    getContents();"""


    def test_simple_js(self):
        js_source = "function test(x){ return x; } test('abc');"
        r = self._runjs_request(js_source).json()
        self.assertEqual(r['script'], "abc")

    def test_js_and_console(self):
        js_source = """function test(x){ return x; }
console.log('some log');
console.log('another log');
test('abc');"""
        params = {'console': '1'}
        r = self._runjs_request(js_source, params=params).json()
        self.assertEqual(r['script'], "abc")
        self.assertEqual(r['console'], ["some log", "another log"])

    def test_js_modify_html(self):
        js_source = """function test(x){ document.getElementById("p1").innerHTML=x; }
test('Changed');"""
        params = {'url': ts.mockserver.url("jsrender")}
        r = self._runjs_request(js_source, render_format='html', params=params)
        self.assertTrue("Before" not in r.text)
        self.assertTrue("Changed" in r.text)

    def test_js_profile(self):
        js_source = """test('abc');"""
        params = {'url': ts.mockserver.url("jsrender"), 'js' : 'test'}
        r = self._runjs_request(js_source, params=params).json()
        self.assertEqual(r['script'], "abc")

    def test_js_profile_another_lib(self):
        js_source = """test2('abc');"""
        params = {'url': ts.mockserver.url("jsrender"), 'js' : 'test'}
        r = self._runjs_request(js_source, params=params).json()
        self.assertEqual(r['script'], "abcabc")

    def test_js_utf8_lib(self):
        js_source = """console.log(test_utf8('abc')); test_utf8('abc');"""
        params = {'url': ts.mockserver.url("jsrender"), 'js' : 'test', 'console': '1'}
        r = self._runjs_request(js_source, params=params).json()
        self.assertEqual(r['script'], u'abc\xae')
        self.assertEqual(r['console'], [u'abc\xae'])

    def test_js_external_iframe(self):
        # by default, cross-domain access is disabled, so this does nothing
        params = {'url': ts.mockserver.url("externaliframe")}
        r = self._runjs_request(self.CROSS_DOMAIN_JS, params=params).json()
        self.assertNotIn('script', r)

    @skip_proxy
    def test_js_external_iframe_cross_domain_enabled(self):
        # cross-domain access should work if we enable it
        with SplashServer(extra_args=['--js-cross-domain-access']) as splash:
            query = {'url': ts.mockserver.url("externaliframe"), 'script': 1}
            headers = {'content-type': 'application/javascript'}
            response = requests.post(
                splash.url("render.json"),
                params=query,
                headers=headers,
                data=self.CROSS_DOMAIN_JS,
            )
            self.assertEqual(response.json()['script'], u'EXTERNAL\n\n')

    @skip_proxy
    def test_js_incorrect_content_type(self):
        js_source = "function test(x){ return x; } test('abc');"
        headers = {'content-type': 'text/plain'}
        r = self._runjs_request(js_source, headers=headers)
        self.assertEqual(r.status_code, 415)

    def test_proper_viewport(self):
        js_source = """
            function size() {
                return [window.innerWidth, window.innerHeight].toString();
            }
            size();
            """
        params = {'viewport': '123x234'}
        r = self._runjs_request(js_source, params=params).json()
        self.assertEqual(r['script'], '123,234')

    def test_js_invalid_profile(self):
        js_source = """test('abc');"""
        params = {'url': ts.mockserver.url("jsrender"), 'js' : 'not_a_profile'}
        r = self._runjs_request(js_source, params=params)
        self.assertEqual(r.status_code, 400)

    def _runjs_request(self, js_source, render_format=None, params=None, headers=None):
        query = {'url': ts.mockserver.url("jsrender"), 'script': 1}
        query.update(params or {})
        req_headers = {'content-type': 'application/javascript'}
        req_headers.update(headers or {})
        return self.post(query, render_format=render_format,
                         payload=js_source, headers=req_headers)


class TestTestSetup(unittest.TestCase):
    def tearDown(self):
        # we must consume splash output because subprocess.PIPE is used
        ts.print_output()

    def test_mockserver_works(self):
        r = requests.get(ts.mockserver.url("jsrender"))
        self.assertEqual(r.status_code, 200)

    def test_mockserver_https_works(self):
        r = requests.get(ts.mockserver.https_url("jsrender"), verify=False)
        self.assertEqual(r.status_code, 200)

    def test_splashserver_works(self):
        r = requests.get('http://localhost:%s/debug' % ts.splashserver.portnum)
        self.assertEqual(r.status_code, 200)

########NEW FILE########
__FILENAME__ = utils
import sys, os, time, tempfile, shutil, socket, fcntl
from subprocess import Popen, PIPE


try:
    socket.getaddrinfo('non-existing-host', 80)
    NON_EXISTING_RESOLVABLE = True
except socket.gaierror:
    NON_EXISTING_RESOLVABLE = False


def get_testenv():
    env = os.environ.copy()
    env['PYTHONPATH'] = os.getcwd()
    return env


def get_ephemeral_port():
    s = socket.socket()
    s.bind(("", 0))
    return s.getsockname()[1]


def _non_block_read(output):
    fd = output.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
    try:
        return output.read()
    except Exception:
        return ""


def _wait_for_port(portnum, delay=0.1, attempts=30):
    while attempts > 0:
        s = socket.socket()
        if s.connect_ex(('127.0.0.1', portnum)) == 0:
            s.close()
            return
        time.sleep(delay)
        attempts -= 1
    raise RuntimeError("Port %d is not open" % portnum)


class SplashServer(object):

    def __init__(self, logfile=None, proxy_profiles_path=None,
                 js_profiles_path=None, portnum=None,
                 proxy_portnum=None, extra_args=None):
        self.logfile = logfile
        self.proxy_profiles_path = proxy_profiles_path
        self.js_profiles_path = js_profiles_path
        self.portnum = portnum if portnum is not None else get_ephemeral_port()
        self.proxy_portnum = proxy_portnum if proxy_portnum is not None else get_ephemeral_port()
        self.tempdir = tempfile.mkdtemp()
        self.extra_args = extra_args or []

    def __enter__(self):
        args = [sys.executable, '-u', '-m', 'splash.server']
        args += ['--cache-path', self.tempdir]
        args += ['--port', str(self.portnum)]
        if self.logfile:
            args += ['-f', self.logfile]
        if self.proxy_profiles_path:
            args += ['--proxy-profiles-path', self.proxy_profiles_path]
        if self.js_profiles_path:
            args += ['--js-profiles-path', self.js_profiles_path]
        if self.proxy_portnum:
            args += ['--proxy-portnum', str(self.proxy_portnum)]

        args.extend(self.extra_args)

        self.proc = Popen(args, stderr=PIPE, env=get_testenv())
        self.proc.poll()
        if self.proc.returncode:
            msg = "unable to start splash server. error code: %d - stderr follows: \n%s" % \
                (self.proc.returncode, self.proc.stderr.read())
            raise RuntimeError(msg)

        try:
            _wait_for_port(self.portnum)
        finally:
            print(_non_block_read(self.proc.stderr))

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.proc.kill()
        self.proc.wait()
        time.sleep(0.2)
        shutil.rmtree(self.tempdir)

    def url(self, path):
        return "http://localhost:%s/%s" % (self.portnum, path.lstrip('/'))

    def proxy_url(self, path):
        return "http://localhost:%s/%s" % (self.proxy_portnum, path.lstrip('/'))


class MockServer(object):

    def __init__(self, http_port=None, https_port=None, proxy_port=None):
        self.http_port = http_port if http_port is not None else get_ephemeral_port()
        self.https_port = https_port if https_port is not None else get_ephemeral_port()
        self.proxy_port = proxy_port if proxy_port is not None else get_ephemeral_port()

    def __enter__(self):
        self.proc = Popen([
                sys.executable,
                '-u', '-m', 'splash.tests.mockserver',
                '--http-port', str(self.http_port),
                '--https-port', str(self.https_port),
                '--proxy-port', str(self.proxy_port),
            ],
            stdout=PIPE,
            env=get_testenv()
        )
        for port in (self.http_port, self.https_port, self.proxy_port):
            _wait_for_port(port)
        print(_non_block_read(self.proc.stdout))

    def __exit__(self, exc_type, exc_value, traceback):
        self.proc.kill()
        self.proc.wait()
        time.sleep(0.2)

    def url(self, path):
        return "http://localhost:%s/%s" % (self.http_port, path.lstrip('/'))

    def https_url(self, path):
        return "https://localhost:%s/%s" % (self.https_port, path.lstrip('/'))


class TestServers(object):

    def __init__(self, logfile=None):
        self.logfile = logfile
        self.tmp_folder = tempfile.mkdtemp("splash-tests-tmp")
        self.proxy_profiles_path = self._copy_test_folder('proxy_profiles')
        self.js_profiles_path = self._copy_test_folder('js_profiles')

        self.mock_http_port = get_ephemeral_port()
        self.mock_https_port = get_ephemeral_port()
        self.mock_proxy_port = get_ephemeral_port()

        print("TestServers mock ports: %s http, %s https, %s proxy" % (
            self.mock_http_port, self.mock_https_port, self.mock_proxy_port))

        self._fix_testproxy_port()

    def _copy_test_folder(self, src, dst=None):
        src_path = os.path.join(os.path.dirname(__file__), src)
        dst_path = os.path.join(self.tmp_folder, dst or src)
        shutil.copytree(src_path, dst_path)
        return dst_path

    def _fix_testproxy_port(self):
        filename = os.path.join(self.proxy_profiles_path, 'test.ini')
        with open(filename, 'rb') as f:
            data = f.read()
        data = data.replace('8990', str(self.mock_proxy_port))
        with open(filename, 'wb') as f:
            f.write(data)

    def __enter__(self):
        self.mockserver = MockServer(
            self.mock_http_port,
            self.mock_https_port,
            self.mock_proxy_port,
        )
        self.mockserver.__enter__()
        self.splashserver = SplashServer(self.logfile, self.proxy_profiles_path,
                                         self.js_profiles_path)
        self.splashserver.__enter__()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.splashserver.__exit__(None, None, None)
        self.mockserver.__exit__(None, None, None)
        shutil.rmtree(self.tmp_folder)

    def print_output(self):
        print(_non_block_read(self.splashserver.proc.stderr))
        print(_non_block_read(self.mockserver.proc.stdout))


########NEW FILE########
__FILENAME__ = utils
import os, gc, inspect
from collections import defaultdict
import psutil

_REQUIRED = object()

class BadRequest(Exception):
    pass

def getarg(request, name, default=_REQUIRED, type=str, range=None):
    if name in request.args:
        value = type(request.args[name][0])
        if range is not None and not (range[0] <= value <= range[1]):
            raise BadRequest("Argument %r out of range (%d-%d)" % (name, range[0], range[1]))
        return value
    elif default is _REQUIRED:
        raise BadRequest("Missing argument: %s" % name)
    else:
        return default

PID = os.getpid()
def get_num_fds():
    proc = psutil.Process(PID)
    return proc.get_num_fds()

def get_leaks():
    relevant_types = frozenset(('SplashQWebPage', 'SplashQNetworkAccessManager',
        'QWebView', 'HtmlRender', 'PngRender', 'QNetworkRequest', 'QSize',
        'QBuffer', 'QPainter', 'QImage'))
    leaks = defaultdict(int)
    gc.collect()
    for o in gc.get_objects():
        if not inspect.isclass(o):
            cname = type(o).__name__
            if cname in relevant_types:
                leaks[cname] += 1
    return leaks

########NEW FILE########
