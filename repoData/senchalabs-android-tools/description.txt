EventRecorder
===

What it is
---
_EventRecorder_ is an infrastructure that provides automated web application testing on Android-based devices. It consists of a device tool and a host machine recording client. This client application receives a playback script from the device tool at the end of the recording. The script is a self-contained program that is able to contact the device tool and send all the recorded events in order to reproduce the session as closely as possible.

Currently it is possible to:

* Load URLs
* Execute JavaScript and log evaluations via _console.log()_
* Record and play back touch and physical keyboard events
* Capture the device screen leaving status and title bars out
* Fill text in form fields via the host machine

Supported platforms
---
Any platform that is simultaneously supported by the [Android Debug Bridge](http://developer.android.com/guide/developing/tools/adb.html) (adb), and [Python](http://www.python.org/).
Currently, it is targeted at devices running [Android](http://www.android.com) and it has been tested with Froyo, Gingerbread and Honeycomb. If you successfully use it on Eclair, please let us know. You can either use a real device or an [emulator](http://developer.android.com/guide/developing/tools/emulator.html).

Tested Devices
---
Please help us grow this list by reporting your working devices:

* Android emulator
* Droid Incredible
* Evo 4G
* Nexus One
* Nexus S
* Galaxy Tab (see also _Known Issues_)
* Xoom

Requirements
---
The Android [SDK](http://developer.android.com/sdk/) is necessary to run the application. In particular, the adb tool is required to be in your _$PATH_.
To run the shell recorder, a Python (v2.6+) environment is required.

How to record
---
Run the [recorder.py](https://github.com/senchalabs/android-tools/blob/master/eventrecorder/src/shell/recorder.py) file with the test name as an argument, i.e.

    python recorder.py <test>

The recorder script will then automatically install an android tool on your device. If you wish to bypass this step, you can pass the "-n" option. Next, a prompt will be displayed where you can use a few commands. These are as follows:

* __s__ or __screen__: Capture screen.
* __t__ or __text__: Input text.

Any commands not using any of these prefixes will be either interpreted as an URL load (if it starts with _http://_ or _www_) or as JavaScript input, which will be evaluated by the browser. Your first command should always be an URL.

JavaScript values can be logged using the [console.log()](http://getfirebug.com/wiki/index.php/Console_API#console.log.28object.5B.2C_object.2C_....5D.29) method.

All touch events and hardware keyboard events will also be recorded in this stage.

When recording is complete simply press _ENTER_ at the prompt. This will cause the recording to stop and a python script named _testname.py_ should be available in your current directory when the recorder exits. Note that an initial run of the generated playback script is necessary to generate the baseline result.

How to play
---
Simply execute the script generated by the recorder:

    python <test.py>

The recorded events will then be played back, and all screen captures and the console log will be available in the current directory. They can then be compared against a baseline if wished.

Detecting Visual Regressions
---
For convenience, we provide the simple [imagediff.py](https://github.com/extjs/Orchid/blob/master/autotouch/src/shell/imagediff.py) tool. It expects two input screen captures and an output file name. The generated image will represent a grayscale difference between the input images. This tool can be easily incorporated in regression suites to generate fault reports. If the two input images are identical, no output image is generated. The format of the output image will be determined by the file name extension.

Note: if you need a more complete solution, you might want to consider using the ImageMagick [compare](http://www.imagemagick.org/script/compare.php) tool.

Detecting Non-Visual Regressions
---
The other existing mechanism consists of logging JavaScript code results. The _console.log_ output file resulting from a playback contains everything that was logged during the execution of the test. In order to detect regressions, one simply needs to perform a _diff_ between the log present in the baseline and the log that resulted from the latest playback.

How it works
---
When the application is started, it automatically installs an Android package ([APK](http://en.wikipedia.org/wiki/APK_\(file_format\))) called _EventRecorder_ on your selected device. If a package already exists, it is uninstalled first.

The android package is responsible for recording all events the user initiates and write this to a file that is later fetched from the phone. It is also responsible for replaying events from an existing file when told to do so.

The application on the host is responsible for notifying the android side when the user initiates certain events (loading URLs, capturing screenshots etc) and also has to fetch the event file when recording is complete. When replaying, it also needs to send the event file to the device for execution.

Known Issues
---
* Events recorded through soft keyboard typing won't be reproduced in the playback.
* The Samsung Galaxy Tab will always send the framebuffer in landscape mode. This means the user needs to test applications in landscape mode on this device.
* Some event sequences might not be exactly reproduced on playback compared to their results during recording. This is because the timing between the events is not 100% accurate in relation to the originally recorded. In particular, fling scroll might lead to different end offsets.

Customizing the Android Tool
---
If you wish to make changes to the Android tool for your own needs you'll need, in addition to the above mentioned requirements, an [Ant](http://ant.apache.org/) environment. Make sure the _android_ application is in your _$PATH_. Once ready, go to the [android](https://github.com/senchalabs/android-tools/blob/master/eventrecorder/src/android/) folder and run the following on your shell:

    android update project -p .

Please note that the above step only needs to be executed once per workstation. It will generate a file called _local.properties_.

Next, type:

    ant debug

A debug package named _bin/EventRecorder-debug.apk_ will be generated. If you wish to sign your application, follow [these steps](http://developer.android.com/guide/publishing/app-signing.html).

Finally, switch to the [shell](https://github.com/senchalabs/android-tools/blob/master/eventrecorder/src/shell/) directory and run:

    python inline-apk.py

This will embed the APK in the recorder, so that it doesn't need to be installed manually on all devices. The recorder is now ready to be used.

Collection of tools to help web developers on Android

Copyright (c) 2010 Sencha Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


RemoteJS
===

What it is
---
_RemoteJS_ is an application that works as a remote [JavaScript](http://en.wikipedia.org/wiki/JavaScript) console.  Think of [Web Inspector](http://trac.webkit.org/wiki/WebInspector) running on your workstation, debugging code running on your mobile phone or tablet device.
There are two versions of the application.  One has a GUI and is meant to be run on a desktop, the other is a [Python](http://www.python.org/) application that runs on a shell.  The latter is useful for quick debugging on a text environment, but is particularly designed for scripting and test automation.

Supported platforms
---
The applications run on Windows, Mac OS X, and Linux, and should run on any platform that is simultaneously supported by the [Android Debug Bridge](http://developer.android.com/guide/developing/tools/adb.html) (adb) and Python (in the non-GUI version).
Currently, it is able to debug code on any devices running [Android](http://www.android.com) ([2.1](http://developer.android.com/sdk/android-2.1.html) or [2.2](http://developer.android.com/sdk/android-2.2.html)). The Android [emulator](http://developer.android.com/guide/developing/tools/emulator.html) is also supported, allowing you to debug your code without a physical device. 

Requirements
---
The Android [SDK](http://developer.android.com/sdk/) is necessary to run the application. In particular, the adb tool is required to be in your _$PATH_.
To run the shell version, a Python environment is required.
 
Features
---

When you launch _RemoteJS_ (GUI version), it will try to detect all attached devices.  If there is none, it will wait for the first to be connected and make it the target device.  If there' more than one device attached, you'll be asked to select one.

After your target device is finally set, you can simply unplug it and the application will automatically detect the disconnection.  Again, if there's only one device left, that will be chosen for you.  If there are at least two, then you'll need to select one again, otherwise the console will wait for one to be attached indefinitely.

After all is set up, most of the times you want to debug a specific web page. In order to load an URL, enter it:

    www.sencha.com

The page will start being loaded on the device and the message `Opening www.sencha.com` will be shown on the console. Expressions starting with `www.`, `http://`, `https://` or `ftp://` are automatically identified as _URL_'s.

You can print values with the `console.log` function:

    > for (var x in document) console.log(x)
    bgColor
    alinkColor
    width
    ...

Multiple instructions are also supported:

    > var a = [1,2,3]; console.log(a)
    1,2,3

Sometimes you might get an error:

    > console.log(documant.title)
    ReferenceError: Can't find variable: documant

To recover previously entered expressions, press `Arrow/Page Up` and you will be able to browse the history. `Arrow/Page Down` works in the usual opposite way, giving you the expressions entered after the current one. The history is stored when you quit the application, which means it will still be available when you start a new session.

The non-GUI version works in a very similar way.  You can type `python remotejs.py -h` to check the usage.

How it works
---
When the application is started, it automatically installs an Android package ([apk](http://en.wikipedia.org/wiki/APK_(file_format)) called _RemoteJS_ on your selected device. If a package already exists, it is *uninstalled* first. This ensures total compatibility with the remote console.

This proxy [activity](http://developer.android.com/guide/topics/fundamentals.html#appcomp) will be the one receiving [intents](http://developer.android.com/guide/topics/fundamentals.html#actcomp) requesting the execution of the _JavaScript_ code.  The evaluation results are then [logged](http://developer.android.com/reference/android/util/Log.html) in Android.  Meanwhile, our console is already listening and filtering that very same log through _adb_ and [logcat](http://developer.android.com/guide/developing/debug-tasks.html).  The processed output is finally presented on the screen. 

Implementation details
---
_RemoteJS_ is a native application, but in reality there's only a very thin layer of native code.  It is only necessary to deal with _adb_ at a system level.  This component of the program is written in [C++](http://en.wikipedia.org/wiki/C%2B%2B) and [Qt](http://qt.nokia.com/).  In particular, the [QtWebKit](http://doc.qt.nokia.com/qtwebkit.html) module is crucial, since the rest of the application is written with _HTML_, _JavaScript_ and _CSS_.

The thin system-level functionality is exported from the _Qt_ space to the [web view](http://doc.qt.nokia.com/qwebview.html) through a very simple API.  All the logic is then implemented on the _JS_ side, including the entire console window, turning the native nature of the application into hybrid.

RemoteJS Device Tool
===

What it is
---

It's a tool that needs to be installed on the Android device or emulator for the remote JavaScript console to work.
You don't need to manually install it, the applications will do it for you.

How to build
---

You can import the folder as a new project in Eclipse and [build the project](http://developer.android.com/guide/developing/eclipse-adt.html).
If you prefer a lighter environment, you can generate an [Ant](http://ant.apache.org/) _build.xml_ file by running _./generate.ant.sh_ or simply executing `android update project -p .`.  Then type `ant debug` and the APK will be generated in the _bin_ folder.

RemoteJS desktop application
===

What it is
---

It's the GUI version of RemoteJS.

How to build
---

It requires the [Qt](http://qt.nokia.com/) framework.
After the dependency is met, to build, run:

    qmake
    make

RemoteJS shell application
===

What it is
---

It's the non-GUI version of RemoteJS.

How to build
---

Since it's written in the Python programming language, it doesn't require any build.
Python version 2.6 or above is required to run it though.
To run, type `python remotejs.py`.  For help on usage, add the `-h` or `--help` option.

