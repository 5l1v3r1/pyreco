__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Servee documentation build configuration file, created by
# sphinx-quickstart on Tue Jul 13 11:12:35 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Servee'
copyright = u'2011, Servee LLC'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.6'
# The full version, including alpha/beta/rc tags.
release = '0.6.0a1.dev22'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Serveedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Servee.tex', u'Servee Documentation',
   u'Issac Kelly', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'servee', u'Servee Documentation',
     [u'Issac Kelly'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Servee'
epub_author = u'Issac Kelly'
epub_publisher = u'Issac Kelly'
epub_copyright = u'2011, Servee LLC'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager

try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from sample_image_insert.models import Image


class ImageAdmin(admin.ModelAdmin):
    list_display = ('title',)
    
admin.site.register(Image, ImageAdmin)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.conf import settings


class Image(models.Model):
    """
    Image model, really just a default, a more reasonable one
    would create some thumbnails based on the need of the site.
    """
    title = models.CharField(max_length=255, blank=True, null=True)
    image = models.ImageField(upload_to="images")
    description = models.TextField(blank=True, null=True)
    uploaded = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)

    def __unicode__(self):
        return '%s' % self.title
        
    def save(self, *args, **kwargs):
        if not self.title:
            self.title = self.image.name
        super(Image, self).save(*args, **kwargs) # Call the "real" save() method.

    @property
    def url(self):
        return '%s%s' % (settings.MEDIA_URL, self.image)

    class Meta:
        verbose_name = "basic image"
        verbose_name_plural = "basic images"
        ordering = ['-modified',]
########NEW FILE########
__FILENAME__ = servee_registry
from servee import frontendadmin
from servee.frontendadmin.insert import ModelInsert
from sample_image_insert.models import Image

class ImageInsert(ModelInsert):
    model = Image

frontendadmin.site.register_insert(ImageInsert)
########NEW FILE########
__FILENAME__ = models
# just here because apps expect a models file.
########NEW FILE########
__FILENAME__ = servee_registry
from servee import frontendadmin
from django.contrib.flatpages.models import FlatPage
from django.contrib.flatpages.admin import FlatpageForm
from django.utils.translation import ugettext_lazy as _

class FlatPageFrontendadminAdmin(frontendadmin.ServeeModelAdmin):
    """
    This class extends from the normal FlatPageAdmin, as well as frontendadmin.ServeeModelAdmin
    The later simply adds to the templates that should be processed when looking
    for the templates to render this page.
    """
    form = FlatpageForm
    fieldsets = (
        (None, {'fields': ('url', 'title', 'content', 'sites')}),
        (_('Advanced options'), {'classes': ('collapse',), 'fields': ('enable_comments', 'registration_required', 'template_name')}),
    )
    list_display = ('url', 'title')
    list_filter = ('sites', 'enable_comments', 'registration_required')
    search_fields = ('url', 'title')

frontendadmin.site.register(FlatPage, FlatPageFrontendadminAdmin)
########NEW FILE########
__FILENAME__ = settings
import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": "dev.db",
    }
}

TIME_ZONE = "America/New_York"
LANGUAGE_CODE = "en-us"
SITE_ID = 1
USE_I18N = True
USE_L10N = True
MEDIA_ROOT = os.path.join(PROJECT_ROOT,"site_media","media")
MEDIA_URL = "/site_media/media/"
STATIC_ROOT = os.path.join(PROJECT_ROOT,"site_media","static")
STATIC_URL = "/site_media/static/"
ADMIN_MEDIA_PREFIX = "/site_media/static/admin/"

STATICFILES_DIRS = (
    os.path.join(PROJECT_ROOT, "static"),
)

STATICFILES_FINDERS = (
    "django.contrib.staticfiles.finders.FileSystemFinder",
    "django.contrib.staticfiles.finders.AppDirectoriesFinder",
)

SECRET_KEY = "$dqgg1dt%!19ms5j1t4+7fixlqzp7&ji_^vhq7!g$r5#*(@=kf"

TEMPLATE_LOADERS = [
    "django.template.loaders.filesystem.Loader",
    "django.template.loaders.app_directories.Loader",
]

FIXTURE_DIRS = [
    os.path.join(PROJECT_ROOT, "fixtures"),
]

MIDDLEWARE_CLASSES = [
    "django.middleware.common.CommonMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.contrib.flatpages.middleware.FlatpageFallbackMiddleware",
]

ROOT_URLCONF = "example_project.urls"

TEMPLATE_DIRS = [
    os.path.join(PROJECT_ROOT, "templates"),
]

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "mail_admins": {
            "level": "ERROR",
            "class": "django.utils.log.AdminEmailHandler"
        }
    },
    "loggers": {
        "django.request":{
            "handlers": ["mail_admins"],
            "level": "ERROR",
            "propagate": True,
        },
    }
}

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.contrib.messages.context_processors.messages",
    "django.core.context_processors.request",
)

INSTALLED_APPS = [
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.sites",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.admin",
    "django.contrib.admindocs",

    # We're going to assume flatpages is
    # Installed, and that is the app that
    # you want to be editable.
    "django.contrib.flatpages",

    # servee dependancies
    "uni_form",

    # servee
    "servee.frontendadmin",
    "servee.wysiwyg",

    # tinymce is currently the only
    # supported wysiwyg backend.
    # I'd like to support a "none (plain html)" backend
    # and also possibly a markdown backend.
    # There are other cool editors poping up as well,
    # Aloha, Dojo, and classics like FCK.  Please contribute.
    "servee_redactor",

    # sample insert, a nieve image placer.
    "sample_image_insert",

    # minimal app that is used to write servee forms/registrations
    # for the flatpages app.  This is the convention for adding servee
    # frontend editing to 3rd party apps.
    "servee_extensions",
]

LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "/"

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.conf.urls.defaults import patterns, include, url
from django.contrib import admin
admin.autodiscover()

from servee import frontendadmin
frontendadmin.autodiscover()

urlpatterns = patterns("",
    (r"^admin/doc/", include("django.contrib.admindocs.urls")),
    (r"^admin/", include(admin.site.urls)),
    (r"^servee/", include(frontendadmin.site.urls)),
    
    (r"^login/$", "django.contrib.auth.views.login", {"template_name": "registration/login.html"}),
    (r"^logout/$", "django.contrib.auth.views.logout", {"template_name": "registration/logout.html", "next_page": "/"}),
)

if settings.DEBUG:
    urlpatterns += patterns("",
        url(r"^site_media/media/(?P<path>.*)$", "django.views.static.serve", {
            "document_root": settings.MEDIA_ROOT,
        }),
    )
########NEW FILE########
__FILENAME__ = forms
from django import forms

class AddForm(forms.ModelForm):
    """
    Primiarly used as a fallback in the insert, safe to ignore.
    """
    pass
########NEW FILE########
__FILENAME__ = insert
from django.forms.models import modelform_factory
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.core.urlresolvers import reverse
from django.contrib.admin.util import unquote
from django.http import HttpResponse
from django.template import RequestContext
from django.template.loader import select_template
from django.shortcuts import render_to_response
from functools import update_wrapper
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt

from servee.frontendadmin.forms import AddForm
from servee.utils import space_out_camel_case


class BaseInsert(object):
    """
    Insert classes are the things that go on the wysiwyg tools under 'Insert'.

    Some Examples might include [and we have written a few plugins already]:
    * Pictures
    * Video
    * Documents
    * YouTube Representations
    * Other Model Representations
    * oEmbed Links

    ModelInsert is what you should use if you are creating an Insert from a
    Django Model, otherwise use BaseInsert and extend from there.
    """
    def __init__(self, admin_site, add_form=None):

        self.add_form = add_form
        if not self.add_form:
            self.add_form = AddForm

        self.admin_site = admin_site

    def base_url(self):
        """
        Should not be overwritten, also used as a slug
        """
        return self.__class__.__name__.lower()

    def nav_title(self):
        return space_out_camel_case(self.__class__.__name__)

    def title(self):
        return space_out_camel_case(self.__class__.__name__)

    def items(self):
        return NotImplementedError

    def get_items(self):
        return NotImplementedError

    def add_item(self):
        return NotImplementedError

    def edit_item(self, item):
        return NotImplementedError

    def content(self):
        return NotImplementedError

    def render_url(self):
        return NotImplementedError

    def get_urls():
        """
        get_urls() should return a set of patterns to be added to the /servee/ urls.
        """
        return []


class ModelInsert(BaseInsert):
    """
    Should only be subclassed, never just _used_, always set the model in the subclass

    Fair amounts of this have been cargo-culted from Django, Tests should be written,
    and any review/notes would be helpful.
    """
    ordering = None
    model = None
    add_form = None

    def __init__(self, *args, **kwargs):
        """
        self.model should be set before calling super(<NewClass>, self).__init__...
        """
        if not self.model:
            raise ImproperlyConfigured("Model must be set before super(%s, self).__init__ is called" % self.__class__.__name__)

        self.item_panel_template = [
            "servee/wysiwyg/insert/%s/%s/_panel.html" % (self.model._meta.app_label, self.model._meta.module_name),
            "servee/wysiwyg/insert/%s/_panel.html" % (self.model._meta.app_label),
            "servee/wysiwyg/insert/_panelt.html",
        ]
        self.item_display_template = [
            "servee/wysiwyg/insert/%s/%s/_list.html" % (self.model._meta.app_label, self.model._meta.module_name),
            "servee/wysiwyg/insert/%s/_list.html" % (self.model._meta.app_label),
            "servee/wysiwyg/insert/_item_list.html",
        ]
        self.item_detail_template = [
            "servee/wysiwyg/insert/%s/%s/_detail.html" % (self.model._meta.app_label, self.model._meta.module_name),
            "servee/wysiwyg/insert/%s/_detail.html" % (self.model._meta.app_label),
            "servee/wysiwyg/insert/_item_detail.html",
        ]
        self.item_list_template = [
            "servee/wysiwyg/insert/%s/%s/_list.html" % (self.model._meta.app_label, self.model._meta.module_name),
            "servee/wysiwyg/insert/%s/_list.html" % (self.model._meta.app_label),
            "servee/wysiwyg/insert/_item_list.html",
        ]
        self.item_render_template = [
            "servee/wysiwyg/insert/%s/%s/_render.html" % (self.model._meta.app_label, self.model._meta.module_name),
            "servee/wysiwyg/insert/%s/_render.html" % (self.model._meta.app_label),
            "servee/wysiwyg/insert/_item_render.html",
        ]
        self.item_add_template = [
            "servee/wysiwyg/insert/%s/%s/_add.html" % (self.model._meta.app_label, self.model._meta.module_name),
            "servee/wysiwyg/insert/%s/_add.html" % (self.model._meta.app_label),
            "servee/wysiwyg/insert/_item_add.html",
        ]

        super(ModelInsert, self).__init__(*args, **kwargs)

    def get_object(self, object_id):
        """
        Returns an instance matching the primary key provided.
        """
        model = self.model
        object_id = model._meta.pk.to_python(object_id)
        return self.queryset().get(pk=object_id)

    def queryset(self, ordering=None):
        """
        The queryset method is provided so that it can be overridden.
        """
        qs = self.model._default_manager.get_query_set()
        if not ordering:
            ordering = self.ordering or ()  # otherwise we might try to *None, which is bad ;)
        if ordering:
            qs = qs.order_by(*ordering)
        return qs

    def items(self):
        return self.queryset()

    def render(self, item):
        """
        Gets an item pk, and renders it to HTML string to be insert.
        item is passed to the template (item_render_template) with context
        item,
        MEDIA_URL,
        STATIC_URL
        """
        item = self.model._default_manager.get(pk=item)
        t = select_template(self.item_render_template)
        return t.render({
            "MEDIA_URL": settings.MEDIA_URL,
            "STATIC_URL": settings.STATIC_URL,
            "item": item,
        })

    def get_items(self):
        """
        Ideally, this will be a method that will also sort, for pagination, or filtering
        """
        return self.items()

    def nav_title(self):
        """
        A string representation of the ModelInsert to be used in the markup of our editor.
        """
        return self.model._meta.module_name.title()

    def get_urls(self):
        """
        Returns urls to get the panel, get/filter list, add/upload, delete and get rendered output.
        """
        from django.conf.urls.defaults import patterns, url

        def wrap(view):
            def wrapper(*args, **kwargs):
                return self.admin_site.admin_view(view)(*args, **kwargs)
            return update_wrapper(wrapper, view)

        info = (self.model._meta.app_label, self.model._meta.module_name)

        return patterns("",
            url(r"^panel/$",
                wrap(self.panel_view),
                name="insert_%s_%s_panel" % info),
            url(r"^list/$",
                wrap(self.list_view),
                name="insert_%s_%s_list" % info),
            url(r"^add_minimal/$",
                self.add_view,
                name="insert_%s_%s_add" % info),
            url(r"^(.+)/detail/$",
                wrap(self.detail_view),
                name="insert_%s_%s_detail" % info),
            url(r"^(.+)/render/$",
                wrap(self.render_view),
                name="insert_%s_%s_render" % info),
            url(r"^(.+)/delete/$",
                wrap(self.delete_view),
                name="insert_%s_%s_delete" % info),
        )

    @property
    def urls(self):
        return self.get_urls()

    # Several methods for getting a view (from a templatetag) can be cleaned up using {% with %}
    # and 1.3 style {% url %} tags which accept a variable.
    # I am happy about this, but it is a ##@@TODO, preferrably before release, so that I can start
    # without worrying about regressions.

    def panel_view(self, request):
        return render_to_response(self.item_panel_template, {"insert": self},
            context_instance=RequestContext(request))

    def list_url(self):
        return reverse("%s:insert_%s_%s_list" % (
            self.admin_site.name,
            self.model._meta.app_label,
            self.model._meta.module_name
        ))

    def list_view(self, request):
        form = self.get_minimal_add_form()

        return render_to_response(self.item_list_template, {
            "insert": self,
            "form": form(prefix=self.base_url()),
        }, context_instance=RequestContext(request))

    def detail_url(self, object_id):
        return reverse("%s:insert_%s_%s_detail" % (
            self.admin_site.name,
            self.model._meta.app_label,
            self.model._meta.module_name
        ), args=(object_id,))

    def detail_view(self, request, object_id):
        obj = self.get_object(unquote(object_id))

        form = self.get_minimal_add_form()

        return render_to_response(self.item_detail_template, {
                "insert": self,
                "object": obj,
                "form": form(prefix=self.base_url()),
            }, context_instance=RequestContext(request))

    def render_url(self, object_id):
        """
        Render_url is useful, because we can't really dynamically get the reverse.
        """
        return reverse("%s:insert_%s_%s_render" % (
            self.admin_site.name,
            self.model._meta.app_label,
            self.model._meta.module_name
        ), args=(object_id,))

    def render_view(self, request, object_id):
        obj = self.get_object(unquote(object_id))

        return render_to_response(self.item_render_template, {"insert": self, "object": obj},
            context_instance=RequestContext(request))

    def get_minimal_add_form(self):
        """
        This is the most basic form that can be used to save the model.
        Useful for adding an instance quickly.

        It will _only_ pull required fields.
        """

        # Get all the required fields and make a modelform for it.
        exclude_fields = []

        for field in self.model._meta.fields:
            if field.blank:
                exclude_fields.append(field.name)

        instance_form = modelform_factory(self.model, form=self.add_form,
            exclude=exclude_fields)

        return instance_form

    @csrf_exempt
    def add_view(self, request):
        """
        new_instance is the created instance of self.model or none, depending on if form.is_valid.
        Passed, for consistancy's sake to the template as "object"

        This view is csrf_exempt, which aparently conflicts with django's admin_view wrapper.
        This is problematic, as it exposes this view to anybody who knows the URL. @@TODO

        Uploadify doesn't properly pass the csrf_token, hopefully this is fixed in the release version of
        Uploadify.
        """
        instance_form = self.get_minimal_add_form()
        form = instance_form(request.POST, request.FILES, prefix=self.base_url())

        new_instance = None
        if form.is_valid():
            new_instance = form.save()
            template = select_template(self.item_add_template)
            context = RequestContext(request)
            context.update({
                    "insert": self,
                    "form": form,
                    "object": new_instance
                })
            response = HttpResponse(template.render(context))
            response.status_code = 201
            return response
        response = HttpResponse(form.errors)
        response.status_code = 400
        return response

    def delete_view(self, request, object_id):
        """
        This view isn't really safe to cross-site attacks,
        some sort of post confirmation with CSRF would be better.
        """
        obj = self.get_object(unquote(object_id))
        obj.delete()
        return HttpResponse("Deleted")

########NEW FILE########
__FILENAME__ = models
# Empty file on purpose

########NEW FILE########
__FILENAME__ = options
from django.contrib.admin.options import ModelAdmin, StackedInline, TabularInline
from django.contrib.admin.views.main import ChangeList
from django.contrib.admin.util import quote
from django.http import HttpResponse, HttpResponseRedirect

class ServeeChangeList(ChangeList):
    """
    I need full path links everywhere in the admin,
    so I subclassed the changelist.  This makes me a sad
    panda.
    """
    
    def url_for_result(self, result):    
        return "/servee/%s/%s/%s/" % (
            self.model._meta.app_label,
            self.model._meta.object_name.lower(),
            quote(getattr(result, self.pk_attname)),
        )


class ServeeModelAdmin(ModelAdmin):
    """
    ServeeModelAdmin is just like the normal ModelAdmin, but with a larger pool of default
    templates.  First it uses the template specifically registered with the ModelAdmin (normal behavior)
    the difference is the fallback, where normally it would check admin/...  it first checks servee/...
    """
        
    def __init__(self, *args, **kwargs):
        super(ServeeModelAdmin, self).__init__(*args, **kwargs)
        opts = self.model._meta
        app_label = opts.app_label
        
        self.change_form_template =  [
            "servee/%s/%s/change_form.html" % (app_label, opts.object_name.lower()),
            "servee/%s/change_form.html" % app_label,
            "servee/change_form.html",
            "admin/%s/%s/change_form.html" % (app_label, opts.object_name.lower()),
            "admin/%s/change_form.html" % app_label,
            "admin/change_form.html",
        ]
        self.add_form_template =  [
            "servee/%s/%s/add_form.html" % (app_label, opts.object_name.lower()),
            "servee/%s/add_form.html" % app_label,
            "admin/%s/%s/add_form.html" % (app_label, opts.object_name.lower()),
            "admin/%s/add_form.html" % app_label,
        ].append(self.change_form_template)
        self.change_list_template =  [
            "servee/%s/%s/change_list.html" % (app_label, opts.object_name.lower()),
            "servee/%s/change_list.html" % app_label,
            "servee/change_list.html",
            "admin/%s/%s/change_list.html" % (app_label, opts.object_name.lower()),
            "admin/%s/change_list.html" % app_label,
            "admin/change_list.html",
        ]
        self.delete_confirmation_template = [
            "servee/%s/%s/delete_confirmation.html" % (app_label, opts.object_name.lower()),
            "servee/%s/delete_confirmation.html" % app_label,
            "servee/delete_confirmation.html",
            "admin/%s/%s/delete_confirmation.html" % (app_label, opts.object_name.lower()),
            "admin/%s/delete_confirmation.html" % app_label,
            "admin/delete_confirmation.html",
        ]
        self.delete_selected_confirmation_template = [
            "servee/%s/%s/delete_selected_confirmation.html" % (app_label, opts.object_name.lower()),
            "servee/%s/delete_selected_confirmation.html" % app_label,
            "servee/delete_selected_confirmation.html",
            "admin/%s/%s/delete_selected_confirmation.html" % (app_label, opts.object_name.lower()),
            "admin/%s/delete_selected_confirmation.html" % app_label,
            "admin/delete_selected_confirmation.html",
        ]
        self.object_history_template = [
            "servee/%s/%s/object_history.html" % (app_label, opts.object_name.lower()),
            "servee/%s/object_history.html" % app_label,
            "servee/object_history.html",
            "admin/%s/%s/object_history.html" % (app_label, opts.object_name.lower()),
            "admin/%s/object_history.html" % app_label,
            "admin/object_history.html",
        ]
    

    def response_add(self, request, obj):
        """
        Act differently during frontendadmin(ajax) just reload the page.
        """

        # in these cases, the redirect is good
        if list(set(request.POST.keys()) & set(["_addanother", "_continue"])):
            return super(ServeeModelAdmin, self).response_change(request, obj)

        # we want to override the default save case in the frontend
        ref = request.META.get("HTTP_REFERER")
        if ref and (ref.find("/servee/") == -1):
            if request.is_ajax():
                return HttpResponse("<script type='text/javascript'>window.location.reload(true);</script>")
            else:
                return HttpResponseRedirect(ref)

        # fallback to normal functionality
        return super(ServeeModelAdmin, self).response_add(request, obj)


    def response_change(self, request, obj):
        """
        Act differently during frontendadmin(ajax) just reload the page.
        """
        
        # in these cases, the redirect is good
        if list(set(request.POST.keys()) & set(["_addanother", "_saveasnew", "_continue"])):
            return super(ServeeModelAdmin, self).response_change(request, obj)
        
        # we want to override the default save case in the frontend
        ref = request.META.get("HTTP_REFERER")
        if ref and (ref.find("/servee/") == -1):
            if request.is_ajax():
                return HttpResponse("<script type='text/javascript'>window.location.reload(true);</script>")
            else:
                return HttpResponseRedirect(ref)
        
        # fallback to normal functionality
        return super(ServeeModelAdmin, self).response_change(request, obj)
    
    def change_view(self, *args, **kwargs):
        """
        Add the insert_classes to the template context.
        """
        if not kwargs.get("extra_context"):
            kwargs["extra_context"] = {}
        kwargs["extra_context"].update({
            "insert_classes": self.admin_site.insert_classes,
        })
        return super(ServeeModelAdmin, self).change_view(*args, **kwargs)
    
    def add_view(self, *args, **kwargs):
        """
        Add the insert_classes to the template context.
        """
        if not kwargs.get("extra_context"):
            kwargs["extra_context"] = {}
        kwargs["extra_context"].update({
            "insert_classes": self.admin_site.insert_classes,
            "form_url": "herp"
        })
        return super(ServeeModelAdmin, self).add_view(*args, **kwargs)

    def get_changelist(self, request, **kwargs):
        return ServeeChangeList


class ServeeStackedInline(StackedInline):
    template = 'servee/edit_inline/stacked.html'

class ServeeTabularInline(TabularInline):
    template = 'servee/edit_inline/tabular.html'

########NEW FILE########
__FILENAME__ = sites
from django.contrib.admin.sites import AdminSite, AlreadyRegistered
from django.conf import settings

class ServeeAdminSite(AdminSite):
    """
    Like AdminSite, but the registered ModelAdmin classes are expected to be used
    by frontend administrators, content editors, etc.
    """

    insert_classes = {}
    custom_views = []

    def register_view(self, path, view, name=None):
        """
        Lifted from AdminPlus: https://github.com/jsocol/django-adminplus/blob/master/adminplus/__init__.py
        Add a custom admin view.

        * `path` is the path in the admin where the view will live, e.g.
            http://example.com/admin/somepath
        * `view` is any view function you can imagine.
        * `name` is an optional pretty name for the list of custom views. If
            empty, we'll guess based on view.__class__.__name__.
        """
        self.custom_views.append((path, view, name))

    def register_insert(self, class_registered):
        """
        ...
        """
        insert_class = class_registered(self)

        if self.insert_classes.get(insert_class.base_url()):
            raise AlreadyRegistered("An insert with the base_url (lowercase classname) of %s is already registered" % insert_class.base_url)

        # Add to registry of instantiated models
        self.insert_classes[insert_class.base_url()] = insert_class

    def unregister_insert(self, class_registered):
        """
        Removes a class from the insert_classes dictionary.  This is useful if a
        third party registerd the class, and you want to edit it.
        """
        insert_class = class_registered(self)

        if self.insert_classes.get(insert_class.base_url()):
            self.insert_classes.pop(insert_class.base_url())

    def get_urls(self):
        """Add our custom views to the admin urlconf."""
        urls = super(ServeeAdminSite, self).get_urls()
        from django.conf.urls import patterns, url, include

        # Custom Views
        for path, view, name in self.custom_views:
            urls += patterns('',
                url(r'^%s$' % path, self.admin_view(view)),
            )

        # Inserts
        for insert_model_lookup, insert in self.insert_classes.iteritems():
            urls += patterns("",
                (r"^insert/%s/%s/" % (insert.model._meta.app_label, insert.model._meta.module_name), include(insert.urls))
            )
        return urls

    def __init__(self, *args, **kwargs):
        """
        Servee is not currently safely namespaced, it _really_ expects
        to be at /servee/, so don't #$%^ that up.
        """
        super(ServeeAdminSite, self).__init__(*args, **kwargs)

        self.name = "servee"
        self.app_name = "servee"
        self.uses_wysiwyg = "servee.wysiwyg" in settings.INSTALLED_APPS

        self.index_template = ["servee/index.html", "admin/index.html"]
        self.login_template = ["servee/login.html", "admin/login.html"]
        self.logout_template = ["servee/logout.html", "admin/logout.html"]
        self.password_change_template = ["servee/password_change.html", "admin/password_change.html"]
        self.password_change_done_template = ["servee/password_change_done.html", "admin/password_change_done.html"]

    def app_index(self, request, app_label, extra_context=None):
        """
        Yet another mini-view hack to override the template list.
        """
        self.app_index_template = (
            "servee/%s/app_index.html" % app_label,
            "servee/app_index.html",
            "admin/%s/app_index.html" % app_label,
            "admin/app_index.html",
        )
        super(ServeeAdminSite, self).app_index(request, app_label, extra_context)

site = ServeeAdminSite()

########NEW FILE########
__FILENAME__ = frontendadmin_tags
from classytags.core import Tag, Options
from classytags.arguments import Argument
from django import template
from django.core.urlresolvers import reverse
from django.contrib.contenttypes.models import ContentType
from django.db.models import Model
from django.db.models.query import QuerySet
from django.utils.translation import ugettext_lazy as _


register = template.Library()

def check_permission(user, action_name, app_label, model_name):
    """
    Check for proper permissions. action_name may be either add, change or delete.
    """
    p = '%s.%s_%s' % (app_label, action_name, model_name)
    return user and user.is_active and user.has_perm(p)

class AddObject(Tag):
    """
    This tag takes either a queryset or a contenttype label and renders the add object tag
    if you have proper permissions.::

        {% frontendadmin_add querysetish [label] [add_class] %}

    **quertysetish** Required. A string like 'auth.User' or a queryset.
    **label** Optional. Default "Add", a string like "Add User"
    **add_class** Optional. Optional class to add to the link.
    """
    name = "frontendadmin_add"

    options = Options(
        Argument('querysetish', required=True),
        Argument('label', required=False, resolve=False),
        Argument('add_class', required=False, resolve=False)
    )

    def render_tag(self, context, querysetish, label=None, add_class=None):
        if isinstance(querysetish, basestring) and "." in querysetish:
            app_label, model_name = querysetish.lower().split(".")
            content_type = ContentType.objects.get(app_label=app_label, model=model_name)
            model = content_type.model_class()
            queryset_instance = model._default_manager.get_query_set()
        elif isinstance(querysetish, QuerySet):
            queryset_instance = querysetish
        else:
            raise template.TemplateSyntaxError, "'%s' argument must be a queryset or string representation, got %s" % (querysetish, type(querysetish))

        user = context["request"].user
        app_label = queryset_instance.model._meta.app_label
        model_name = queryset_instance.model._meta.module_name

        if not check_permission(user, "add", app_label, model_name):
            return ""

        if not label:
            label = _("Add")

        return '<a class="frontendadmin frontendadmin_add %s" href="%s">%s</a>' % (
            add_class,
            reverse("servee:%s_%s_add" % (app_label, model_name,)),
            unicode(label)
        )

class ChangeObject(Tag):
    """
    The Change Object Tag will take a model instance and render the change link
    if you have the proper permissions.::

        {% frontendadmin_change model_instance [label] [add_class] %}

    **model_instance** Required. an instance of a model.
    **label** Optional. Default "Change", a string like "Change User"
    **add_class** Optional. Optional class to add to the link.
    """
    name = "frontendadmin_change"

    options = Options(
        Argument('model_instance', required=True),
        Argument('label', required=False, resolve=False),
        Argument('add_class', required=False, resolve=False)
    )

    def render_tag(self, context, model_instance, label=None, add_class=None):
        if not isinstance(model_instance, Model):
            raise template.TemplateSyntaxError, "'%s' argument must be a model-instance" % model_instance

        user = context["request"].user
        app_label = model_instance._meta.app_label
        model_name = model_instance._meta.module_name

        if not check_permission(user, "change", app_label, model_name):
            return ""

        if not label:
            label = _("Change")

        return '<a class="frontendadmin frontendadmin_edit %s" href="%s">%s</a>' % (
            add_class,
            reverse("servee:%s_%s_change" % (
                    app_label,
                    model_name,
                ), args=[model_instance.pk,]
            ),
            unicode(label)
        )


class ListObjects(Tag):
    """
    The List Object Tag will take a model string, an instance, or a queryset and render the link
    if you have the proper permissions.::

        {% frontendadmin_list modelish [label] [add_class] %}

    **modelish** Required. an instance of a model, or a queryset, or a content type string.
    **label** Optional. Default "List", a string like "List Users"
    **add_class** Optional. Optional class to add to the link.
    """

    name = "frontendadmin_list"

    options = Options(
        Argument('modelish', required=True),
        Argument('label', required=False, resolve=False),
        Argument('add_class', required=False, resolve=False)
    )

    def render_tag(self, context, modelish, label=None, add_class=None):
        if isinstance(modelish, basestring) and "." in modelish:
            app_label, model_name = modelish.lower().split(".")
            content_type = ContentType.objects.get(app_label=app_label, model=model_name)
            model = content_type.model_class()
        elif isinstance(modelish, QuerySet):
            model = modelish.model
        elif isinstance(modelish, Model):
            model = modelish
        else:
            raise template.TemplateSyntaxError, "'%s' argument must be a model-instance, queryset, or string representation" % modelish

        user = context["request"].user
        app_label = model._meta.app_label
        model_name = model._meta.module_name

        if not check_permission(user, "change", app_label, model_name):
            return ""

        if not label:
            label = _("List")

        return '<a class="frontendadmin frontendadmin_list %s" href="%s">%s</a>' % (
            add_class,
            reverse("servee:%s_%s_changelist" % (
                    app_label,
                    model_name,
                )
            ),
            unicode(label)
        )


class DeleteObject(Tag):
    """
    The Delete Object Tag will take a model instance and render the link
    if you have the proper permissions.::

        {% frontendadmin_delete model_instance [label] [add_class] %}

    **modelish** Required. an instance of a model, or a queryset, or a content type string.
    **label** Optional. Default "Delete", a string like "Delete User"
    **add_class** Optional. Optional class to add to the link.
    """
    name = "frontendadmin_delete"

    options = Options(
        Argument('model_instance', required=True),
        Argument('label', required=False, resolve=False),
        Argument('add_class', required=False, resolve=False)
    )

    def render_tag(self, context, model_instance, label=None, add_class=None):
        if not isinstance(model_instance, Model):
            raise template.TemplateSyntaxError, "'%s' argument must be a model-instance" % model_instance

        user = context["request"].user
        app_label = model_instance._meta.app_label
        model_name = model_instance._meta.module_name

        if not check_permission(user, "delete", app_label, model_name):
            return ""

        if not label:
            label = _("Delete")

        return '<a class="frontendadmin frontendadmin_delete %s" href="%s">%s</a>' % (
            add_class,
            reverse("servee:%s_%s_delete" % (
                    app_label,
                    model_name,
                ), args=[model_instance.pk,]
            ),
            unicode(label)
        )

register.tag(AddObject)
register.tag(ChangeObject)
register.tag(DeleteObject)
register.tag(ListObjects)

########NEW FILE########
__FILENAME__ = insert_tags
"""
Some lame tags so that we can get urls.  This can be sorted out properly in 1.3, it's just not.
"""
from classytags.core import Tag, Options
from classytags.arguments import Argument
from django import template

register = template.Library()


class InsertRenderUrl(Tag):
    """
    Pass an insert and an object and get the insert.render_url(object)
    """
    name = "insert_render_url"
    
    options = Options(
        Argument('insert', required=True),
        Argument('obj', required=True)
    )
    
    def render_tag(self, context, insert, obj):
        return insert.render_url(obj)
    
register.tag(InsertRenderUrl)

class InsertDetailUrl(Tag):
    """
    Pass an insert and an object and get the insert.render_url(object)
    """
    name = "insert_detail_url"
    
    options = Options(
        Argument('insert', required=True),
        Argument('obj', required=True)
    )
    
    def render_tag(self, context, insert, obj):
        return insert.detail_url(obj)
    
register.tag(InsertDetailUrl)
########NEW FILE########
__FILENAME__ = servee_admin_list
from django import template
register = template.Library()

def search_form_servee(context, cl):
    """
    Yet another thing I had to subclass strictly so
    I could put a proper full-url into a form action or a link
    """
    return {
        "request": context["request"],
        "cl": cl,
        "show_result_count": cl.result_count != cl.full_result_count,
        "search_var": "q"
    }
search_form_servee = register.inclusion_tag("servee/_search_form.html", takes_context=True)(search_form_servee)
########NEW FILE########
__FILENAME__ = servee_admin_modify
from django import template

register = template.Library()

def submit_row_frontendadmin(context):
    """
    Displays the row of buttons for delete and save.
    """
    opts = context['opts']
    change = context['change']
    is_popup = context['is_popup']
    save_as = context['save_as']
    return {
        #'show_delete_link': (not is_popup and context['has_delete_permission']
        #                      and (change or context['show_delete'])),
        'show_save_as_new': not is_popup and change and save_as,
        'show_save_and_add_another': context['has_add_permission'] and
                            not is_popup and (not save_as or context['add']),
        'show_save_and_continue': not is_popup and context['has_change_permission'],
        'is_popup': is_popup,
        'show_save': True
    }
register.inclusion_tag('servee/_submit_line.html', takes_context=True)(submit_row_frontendadmin)

########NEW FILE########
__FILENAME__ = frontendadmin_registry
from django.contrib.flatpages.models import FlatPage
from django.contrib.flatpages.admin import FlatPageAdmin

import frontendadmin

class FlatPageFrontendadminAdmin(FlatPageAdmin, frontendadmin.ServeeModelAdmin):
    """
    This class extends from the normal FlatPageAdmin, as well as frontendadmin.ServeeModelAdmin
    The later simply adds to the templates that should be processed when looking
    for the templates to render this page.
    """
    pass

frontendadmin.site.register(FlatPage, FlatPageFrontendadminAdmin)

########NEW FILE########
__FILENAME__ = helpers
from django.test import Client
from django.core.handlers.wsgi import WSGIRequest
from django.core.handlers.base import BaseHandler

# From: http://djangosnippets.org/snippets/2231/
# Adapted from Simon Willison's snippet: http://djangosnippets.org/snippets/963/
class RequestFactory(Client):
    """
    Class that lets you create mock Request objects for use in testing.

    Usage:

    rf = RequestFactory()
    get_request = rf.get('/hello/')
    post_request = rf.post('/submit/', {'foo': 'bar'})

    This class re-uses the django.test.client.Client interface, docs here:
    http://www.djangoproject.com/documentation/testing/#the-test-client

    Once you have a request object you can pass it to any view function,
    just as if that view had been hooked up using a URLconf.

    """
    def request(self, **request):
        """
        Similar to parent class, but returns the request object as soon as it
        has created it.
        """
        environ = {
            'HTTP_COOKIE': self.cookies,
            'PATH_INFO': '/',
            'QUERY_STRING': '',
            'REQUEST_METHOD': 'GET',
            'SCRIPT_NAME': '',
            'SERVER_NAME': 'testserver',
            'SERVER_PORT': 80,
            'SERVER_PROTOCOL': 'HTTP/1.1',
        }
        environ.update(self.defaults)
        environ.update(request)
        request = WSGIRequest(environ)

        handler = BaseHandler()
        handler.load_middleware()
        for middleware_method in handler._request_middleware:
            if middleware_method(request):
                raise Exception("Couldn't create request object - "
                                "request middleware returned a response")

        return request

########NEW FILE########
__FILENAME__ = models
# Django models go here

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

import os, sys

os.environ["DJANGO_SETTINGS_MODULE"] = "test_settings"

parent = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "..")
root = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "..", "..")
sys.path.insert(0, parent)
sys.path.insert(0, root)

from django.test.simple import DjangoTestSuiteRunner
from django.conf import settings

def runtests():
    runner = DjangoTestSuiteRunner()
    failures = runner.run_tests(["frontendadmin"], verbosity=1, interactive=True)
    sys.exit(failures)

if __name__ == "__main__":
    runtests()


########NEW FILE########
__FILENAME__ = tests
from unittest import TestCase as UnittestTestCase
from django.contrib.auth import authenticate, login
from django.contrib.auth.models import User
from django.contrib.flatpages.models import FlatPage
from django.template import RequestContext, Template
from django.test import Client, TestCase

# Django 1.3's RequestFactory doesn't run requests through MiddleWare
from helpers import RequestFactory


class SpaceOutTestCase(UnittestTestCase):
    def test_variants(self):
        from servee.utils import space_out_camel_case

        self.assertEqual(space_out_camel_case('nospacesanywhere'), 'nospacesanywhere')
        self.assertEqual(space_out_camel_case('A'), 'A')
        self.assertEqual(space_out_camel_case('AB'), 'AB')
        self.assertEqual(space_out_camel_case('Abc'), 'Abc')
        self.assertEqual(space_out_camel_case('ABc'), 'A Bc')
        self.assertEqual(space_out_camel_case('AbCd'), 'Ab Cd')
        self.assertEqual(space_out_camel_case('TypicalCamelCase'), 'Typical Camel Case')
        self.assertEqual(space_out_camel_case('DMLSServicesOtherBSTextLLC'), 'DMLS Services Other BS Text LLC')


class TestTemplateTags(TestCase):
    def setUp(self):
        self.user = User.objects.create(username="test")
        self.user.set_password("secret")
        self.user.is_staff = True
        self.user.is_superuser = True
        self.user.save()

        self.factory = RequestFactory()

        FlatPage.objects.create(
            url="/",
            title="Test",
            content="This is a test.",
        )

    def tearDown(self):
        pass

    def get_request_for_url(self, url):
        request = self.factory.get(url)
        user = authenticate(username=self.user.username, password="secret")
        login(request, user)
        return request

    def test_frontendadmin_add(self):
        frontendadmin_add_html = """<a class="frontendadmin frontendadmin_add" href="/servee/flatpages/flatpage/add/">Add a Flatpage</a>"""
        frontendadmin_add_plain_html = """<a class="frontendadmin frontendadmin_add" href="/servee/flatpages/flatpage/add/">Add</a>"""
        template = Template("""\
{% load frontendadmin_tags %}\
{% frontendadmin_add flatpages "Add a Flatpage" %}\
"""     )
        template_plain = Template("""\
{% load frontendadmin_tags %}\
{% frontendadmin_add flatpages %}\
"""     )
        request = self.get_request_for_url("/frontendadmin_add/")

        flatpages = FlatPage.objects.all()
        context = RequestContext(request, {"flatpages": flatpages})
        # Test with custom label
        content = template.render(context)
        self.assertEqual(content, frontendadmin_add_html)
        # Test without custom label
        content = template_plain.render(context)
        self.assertEqual(content, frontendadmin_add_plain_html)

    def test_frontendadmin_change(self):
        frontendadmin_change_html = """<a class="frontendadmin frontendadmin_edit" href="/servee/flatpages/flatpage/1/">Edit This Flatpage</a>"""
        frontendadmin_change_plain_html = """<a class="frontendadmin frontendadmin_edit" href="/servee/flatpages/flatpage/1/">Change</a>"""
        template = Template("""\
{% load frontendadmin_tags %}\
{% frontendadmin_change flatpage "Edit This Flatpage" %}\
"""     )
        template_plain = Template("""\
{% load frontendadmin_tags %}\
{% frontendadmin_change flatpage %}\
"""     )
        request = self.get_request_for_url("/frontendadmin_change/")

        flatpage = FlatPage.objects.get(pk=1)
        context = RequestContext(request, {"flatpage": flatpage})
        # Test with custom label
        content = template.render(context)
        self.assertEqual(content, frontendadmin_change_html)
        # Test without custom label
        content = template_plain.render(context)
        self.assertEqual(content, frontendadmin_change_plain_html)

    def test_frontendadmin_delete(self):
        frontendadmin_delete_html = """<a class="frontendadmin frontendadmin_delete" href="/servee/flatpages/flatpage/1/delete/">Delete This Flatpage</a>"""
        frontendadmin_delete_plain_html = """<a class="frontendadmin frontendadmin_delete" href="/servee/flatpages/flatpage/1/delete/">Delete</a>"""
        template = Template("""\
{% load frontendadmin_tags %}\
{% frontendadmin_delete flatpage "Delete This Flatpage" %}\
"""     )
        template_plain = Template("""\
{% load frontendadmin_tags %}\
{% frontendadmin_delete flatpage %}\
"""     )
        request = self.get_request_for_url("/frontendadmin_delete/")

        flatpage = FlatPage.objects.get(pk=1)
        context = RequestContext(request, {"flatpage": flatpage})
        # Test with custom label
        content = template.render(context)
        self.assertEqual(content, frontendadmin_delete_html)
        # Test without custom label
        content = template_plain.render(context)
        self.assertEqual(content, frontendadmin_delete_plain_html)

########NEW FILE########
__FILENAME__ = test_settings
import os

BASE_DIR = os.path.dirname(__file__)

INSTALLED_APPS = (
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.flatpages",
    "django.contrib.sessions",
    "django.contrib.contenttypes",
    "servee",
    "frontendadmin",
)

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
    }
}

MIDDLEWARE_CLASSES = (
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.flatpages.middleware.FlatpageFallbackMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    'django.core.context_processors.request',
)

ROOT_URLCONF = "frontendadmin.tests.urls"

SITE_ID = 1

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
import frontendadmin
import frontendadmin_registry


urlpatterns = patterns("",
    url(r"^servee/", include(frontendadmin.site.urls)),
)

########NEW FILE########
__FILENAME__ = utils
def space_out_camel_case(camel):
    """
    Converts a "CamelCasedName" to "Camel Case Name".
    """
    chars = []

    for char in camel:
        if len(chars) >= 2 and chars[-1] != ' ':
            if char.isupper() and chars[-1].islower():
                chars.append(' ')
            elif char.islower() and chars[-1].isupper() and chars[-2].isupper():
                chars.insert(len(chars) - 1, ' ')

        chars.append(char)

    return ''.join(chars)

########NEW FILE########
__FILENAME__ = models
# intentionally blank
########NEW FILE########
__FILENAME__ = tests

########NEW FILE########
