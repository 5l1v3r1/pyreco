__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Requests documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 13 23:54:25 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# This environment variable makes decorators not decorate functions, so their
# signatures in the generated documentation are still correct
os.environ['GENERATING_DOCUMENTATION'] = "github3"

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
import github3

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'github3.py'
copyright = u'2012 - Ian Cordasco'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = github3.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
# pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None


# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'github3.pydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'github3.py.tex', u'github3.py Documentation',
   u'Ian Cordasco', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'github3.py', u'github3.py Documentation',
     [u'Ian Cordasco'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False

# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'github3.py', u'github3.py Documentation', u'Ian Cordasco',
   'github3.py', 'Wrapper for GitHub API v3', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
texinfo_appendices = []

########NEW FILE########
__FILENAME__ = browser
import webbrowser
import tempfile
import github3

template = """<html><head></head><body>{0}</body></html>"""

i = github3.issue('kennethreitz', 'requests', 868)

with tempfile.NamedTemporaryFile() as tmpfd:
    tmpfd.write(template.format(i.body_html))
    webbrowser.open('file://' + tmpfd.name)

########NEW FILE########
__FILENAME__ = logging_ex
import github3
import logging

# Set up a file to have all the logs written to
file_handler = logging.FileHandler('github_script.log')

# Send the logs to stderr as well
stream_handler = logging.StreamHandler()

# Format the log output and include the log level's name and the time it was
# generated
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')

# Use that Formatter on both handlers
file_handler.setFormatter(formatter)
stream_handler.setFormatter(formatter)

# Get the logger used by github3.py internally by referencing its name
# directly
logger = logging.getLogger('github3')
# Add the handlers to it
logger.addHandler(file_handler)
logger.addHandler(stream_handler)
# Set the level which determines what you see
logger.setLevel(logging.DEBUG)

# Make a library call and see the information posted
r = github3.repository('sigmavirus24', 'github3.py')
print('{0} - {0.html_url}'.format(r))

########NEW FILE########
__FILENAME__ = octocat_say
import github3

print("Hey Octocat!")
print(github3.octocat("Hey Ian!"))
print("What do you think about github3.py?")
print(github3.octocat("github3.py rocks!"))
print("Thanks Octocat, that means a lot coming from you.")
print("FIN.")
print("""Epilog:
    The preceding conversation was entirely fictional. If you didn't realize
    that, you need to get out more.
""")

########NEW FILE########
__FILENAME__ = wrap_text
import github3
import textwrap

i = github3.issue('kennethreitz', 'requests', 868)
for line in textwrap.wrap(i.body_text, 78, replace_whitespace=False):
    print line

########NEW FILE########
__FILENAME__ = api
# -*- coding: utf-8 -*-
"""
github3.api
===========

:copyright: (c) 2012 by SigmaVirus24
:license: Modified BSD, see LICENSE for more details

"""

from .github import GitHub, GitHubEnterprise

gh = GitHub()


def authorize(login, password, scopes, note='', note_url='', client_id='',
              client_secret='', two_factor_callback=None):
    """Obtain an authorization token for the GitHub API.

    :param str login: (required)
    :param str password: (required)
    :param list scopes: (required), areas you want this token to apply to,
        i.e., 'gist', 'user'
    :param str note: (optional), note about the authorization
    :param str note_url: (optional), url for the application
    :param str client_id: (optional), 20 character OAuth client key for which
        to create a token
    :param str client_secret: (optional), 40 character OAuth client secret for
        which to create the token
    :param func two_factor_callback: (optional), function to call when a
        Two-Factor Authentication code needs to be provided by the user.
    :returns: :class:`Authorization <Authorization>`

    """
    gh = GitHub()
    gh.login(two_factor_callback=two_factor_callback)
    return gh.authorize(login, password, scopes, note, note_url, client_id,
                        client_secret)


def login(username=None, password=None, token=None, url=None,
          two_factor_callback=None):
    """Construct and return an authenticated GitHub session.

    This will return a GitHubEnterprise session if a url is provided.

    :param str username: login name
    :param str password: password for the login
    :param str token: OAuth token
    :param str url: (optional), URL of a GitHub Enterprise instance
    :param func two_factor_callback: (optional), function you implement to
        provide the Two Factor Authentication code to GitHub when necessary
    :returns: :class:`GitHub <github3.github.GitHub>`

    """
    g = None

    if (username and password) or token:
        g = GitHubEnterprise(url) if url is not None else GitHub()
        g.login(username, password, token, two_factor_callback)

    return g


def emojis():
    return gh.emojis()
emojis.__doc__ = gh.emojis.__doc__


def gist(id_num):
    """Retrieve the gist identified by ``id_num``.

    :param int id_num: (required), unique id of the gist
    :returns: :class:`Gist <github3.gists.Gist>`

    """
    return gh.gist(id_num)


def gitignore_template(language):
    """Return the template for language.

    :returns: str

    """
    return gh.gitignore_template(language)


def gitignore_templates():
    """Return the list of available templates.

    :returns: list of template names

    """
    return gh.gitignore_templates()


def iter_all_repos(number=-1, etag=None):
    """Iterate over every repository in the order they were created.

    :param int number: (optional), number of repositories to return.
        Default: -1, returns all of them
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Repository <github3.repos.Repository>`

    """
    return gh.iter_all_repos(number, etag)


def iter_all_users(number=-1, etag=None):
    """Iterate over every user in the order they signed up for GitHub.

    :param int number: (optional), number of users to return. Default: -1,
        returns all of them
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`User <github3.users.User>`

    """
    return gh.iter_all_users(number, etag)


def iter_events(number=-1, etag=None):
    """Iterate over public events.

    :param int number: (optional), number of events to return. Default: -1
        returns all available events
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Event <github3.events.Event>`

    """
    return gh.iter_events(number, etag)


def iter_followers(username, number=-1, etag=None):
    """List the followers of ``username``.

    :param str username: (required), login of the person to list the followers
        of
    :param int number: (optional), number of followers to return, Default: -1,
        return all of them
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`User <github3.users.User>`

    """
    return gh.iter_followers(username, number, etag) if username else []


def iter_following(username, number=-1, etag=None):
    """List the people ``username`` follows.

    :param str username: (required), login of the user
    :param int number: (optional), number of users being followed by username
        to return. Default: -1, return all of them
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`User <github3.users.User>`

    """
    return gh.iter_following(username, number, etag) if username else []


def iter_gists(username=None, number=-1, etag=None):
    """Iterate over public gists or gists for the provided username.

    :param str username: (optional), if provided, get the gists for this user
        instead of the authenticated user.
    :param int number: (optional), number of gists to return. Default: -1,
        return all of them
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Gist <github3.gists.Gist>`

    """
    return gh.iter_gists(username, number, etag)


def iter_repo_issues(owner, repository, milestone=None, state=None,
                     assignee=None, mentioned=None, labels=None, sort=None,
                     direction=None, since=None, number=-1, etag=None):
    """List issues on owner/repository. Only owner and repository are
    required.

    .. versionchanged:: 0.9.0

        - The ``state`` parameter now accepts 'all' in addition to 'open'
          and 'closed'.

    :param str owner: login of the owner of the repository
    :param str repository: name of the repository
    :param int milestone: None, '*', or ID of milestone
    :param str state: accepted values: ('all', 'open', 'closed')
        api-default: 'open'
    :param str assignee: '*' or login of the user
    :param str mentioned: login of the user
    :param str labels: comma-separated list of label names, e.g.,
        'bug,ui,@high'
    :param str sort: accepted values: ('created', 'updated', 'comments')
        api-default: created
    :param str direction: accepted values: ('asc', 'desc')
        api-default: desc
    :param since: (optional), Only issues after this date will
        be returned. This can be a `datetime` or an ISO8601 formatted
        date string, e.g., 2012-05-20T23:10:27Z
    :type since: datetime or string
    :param int number: (optional), number of issues to return.
        Default: -1 returns all issues
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Issue <github3.issues.Issue>`\ s

    """
    if owner and repository:
        return gh.iter_repo_issues(owner, repository, milestone, state,
                                   assignee, mentioned, labels, sort,
                                   direction, since, number, etag)
    return iter([])


def iter_orgs(username, number=-1, etag=None):
    """List the organizations associated with ``username``.

    :param str username: (required), login of the user
    :param int number: (optional), number of orgs to return. Default: -1,
        return all of the issues
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of
        :class:`Organization <github3.orgs.Organization>`

    """
    return gh.iter_orgs(username, number, etag) if username else []


def iter_user_repos(login, type=None, sort=None, direction=None, number=-1,
                    etag=None):
    """List public repositories for the specified ``login``.

    .. versionadded:: 0.6

    .. note:: This replaces github3.iter_repos

    :param str login: (required)
    :param str type: (optional), accepted values:
        ('all', 'owner', 'member')
        API default: 'all'
    :param str sort: (optional), accepted values:
        ('created', 'updated', 'pushed', 'full_name')
        API default: 'created'
    :param str direction: (optional), accepted values:
        ('asc', 'desc'), API default: 'asc' when using 'full_name',
        'desc' otherwise
    :param int number: (optional), number of repositories to return.
        Default: -1 returns all repositories
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Repository <github3.repos.Repository>`
        objects

    """
    if login:
        return gh.iter_user_repos(login, type, sort, direction, number, etag)
    return iter([])


def iter_starred(username, number=-1, etag=None):
    """Iterate over repositories starred by ``username``.

    :param str username: (optional), name of user whose stars you want to see
    :param int number: (optional), number of repositories to return.
        Default: -1 returns all repositories
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Repository <github3.repos.Repository>`

    """
    return gh.iter_starred(username, number, etag)


def iter_subscriptions(username, number=-1, etag=None):
    """Iterate over repositories subscribed to by ``username``.

    :param str username: (optional), name of user whose subscriptions you want
        to see
    :param int number: (optional), number of repositories to return.
        Default: -1 returns all repositories
    :param str etag: (optional), ETag from a previous request to the same
        endpoint
    :returns: generator of :class:`Repository <github3.repos.Repository>`

    """
    return gh.iter_subscriptions(username, number, etag)


def create_gist(description, files):
    """Create an anonymous public gist.

    :param str description: (required), short description of the gist
    :param dict files: (required), file names with associated
        dictionaries for content, e.g.
        {'spam.txt': {'content': 'File contents ...'}}
    :returns: :class:`Gist <github3.gists.Gist>`

    """
    return gh.create_gist(description, files)  # (No coverage)


def issue(owner, repository, number):
    """Anonymously gets issue :number on :owner/:repository.

    :param str owner: (required), repository owner
    :param str repository: (required), repository name
    :param int number: (required), issue number
    :returns: :class:`Issue <github3.issues.Issue>`

    """
    return gh.issue(owner, repository, number)


def markdown(text, mode='', context='', raw=False):
    """Render an arbitrary markdown document.

    :param str text: (required), the text of the document to render
    :param str mode: (optional), 'markdown' or 'gfm'
    :param str context: (optional), only important when using mode 'gfm',
        this is the repository to use as the context for the rendering
    :param bool raw: (optional), renders a document like a README.md, no gfm,
        no context
    :returns: str -- HTML formatted text

    """
    return gh.markdown(text, mode, context, raw)


def octocat(say=None):
    """Return an easter egg from the API.

    :params str say: (optional), pass in what you'd like Octocat to say
    :returns: ascii art of Octocat

    """
    return gh.octocat(say)


def organization(login):
    return gh.organization(login)
organization.__doc__ = gh.organization.__doc__


def pull_request(owner, repository, number):
    """Anonymously retrieve pull request :number on :owner/:repository.

    :param str owner: (required), repository owner
    :param str repository: (required), repository name
    :param int number: (required), pull request number
    :returns: :class:`PullRequest <github3.pulls.PullRequest>`

    """
    return gh.pull_request(owner, repository, number)


def rate_limit():
    return gh.rate_limit()
rate_limit.__doc__ = gh.rate_limit.__doc__


def repository(owner, repository):
    return gh.repository(owner, repository)
repository.__doc__ = gh.repository.__doc__


def ratelimit_remaining():
    """Get the remaining number of requests allowed.

    :returns: int

    """
    return gh.ratelimit_remaining


def search_code(query, sort=None, order=None, per_page=None,
                text_match=False, number=-1, etag=None):
    """Find code via the code search API.

    .. warning::

        You will only be able to make 5 calls with this or other search
        functions. To raise the rate-limit on this set of endpoints, create an
        authenticated :class:`GitHub <github3.github.GitHub>` Session with
        ``login``.

    The query can contain any combination of the following supported
    qualifiers:

    - ``in`` Qualifies which fields are searched. With this qualifier you
      can restrict the search to just the file contents, the file path, or
      both.
    - ``language`` Searches code based on the language it’s written in.
    - ``fork`` Specifies that code from forked repositories should be
      searched.  Repository forks will not be searchable unless the fork
      has more stars than the parent repository.
    - ``size`` Finds files that match a certain size (in bytes).
    - ``path`` Specifies the path that the resulting file must be at.
    - ``extension`` Matches files with a certain extension.
    - ``user`` or ``repo`` Limits searches to a specific user or
      repository.

    For more information about these qualifiers, see: http://git.io/-DvAuA

    :param str query: (required), a valid query as described above, e.g.,
        ``addClass in:file language:js repo:jquery/jquery``
    :param str sort: (optional), how the results should be sorted;
        option(s): ``indexed``; default: best match
    :param str order: (optional), the direction of the sorted results,
        options: ``asc``, ``desc``; default: ``desc``
    :param int per_page: (optional)
    :param bool text_match: (optional), if True, return matching search
        terms. See http://git.io/4ct1eQ for more information
    :param int number: (optional), number of repositories to return.
        Default: -1, returns all available repositories
    :param str etag: (optional), previous ETag header value
    :return: generator of :class:`CodeSearchResult
        <github3.search.CodeSearchResult>`
    """
    return gh.search_code(query, sort, order, per_page, text_match, number,
                          etag)


def search_issues(query, sort=None, order=None, per_page=None,
                  text_match=False, number=-1, etag=None):
    """Find issues by state and keyword

    .. warning::

        You will only be able to make 5 calls with this or other search
        functions. To raise the rate-limit on this set of endpoints, create an
        authenticated :class:`GitHub <github3.github.GitHub>` Session with
        ``login``.

    The query can contain any combination of the following supported
    qualifers:

    - ``type`` With this qualifier you can restrict the search to issues or
      pull request only.
    - ``in`` Qualifies which fields are searched. With this qualifier you can
      restrict the search to just the title, body, comments, or any
      combination of these.
    - ``author`` Finds issues created by a certain user.
    - ``assignee`` Finds issues that are assigned to a certain user.
    - ``mentions`` Finds issues that mention a certain user.
    - ``commenter`` Finds issues that a certain user commented on.
    - ``involves`` Finds issues that were either created by a certain user,
      assigned to that user, mention that user, or were commented on by that
      user.
    - ``state`` Filter issues based on whether they’re open or closed.
    - ``labels`` Filters issues based on their labels.
    - ``language`` Searches for issues within repositories that match a
      certain language.
    - ``created`` or ``updated`` Filters issues based on times of creation, or
      when they were last updated.
    - ``comments`` Filters issues based on the quantity of comments.
    - ``user`` or ``repo`` Limits searches to a specific user or repository.

    For more information about these qualifiers, see: http://git.io/d1oELA

    :param str query: (required), a valid query as described above, e.g.,
        ``windows label:bug``
    :param str sort: (optional), how the results should be sorted;
        options: ``created``, ``comments``, ``updated``; default: best match
    :param str order: (optional), the direction of the sorted results,
        options: ``asc``, ``desc``; default: ``desc``
    :param int per_page: (optional)
    :param bool text_match: (optional), if True, return matching search
        terms. See http://git.io/QLQuSQ for more information
    :param int number: (optional), number of issues to return.
        Default: -1, returns all available issues
    :param str etag: (optional), previous ETag header value
    :return: generator of :class:`IssueSearchResult
        <github3.search.IssueSearchResult>`
    """
    return gh.search_issues(query, sort, order, per_page, text_match,
                            number, etag)


def search_repositories(query, sort=None, order=None, per_page=None,
                        text_match=False, number=-1, etag=None):
    """Find repositories via various criteria.

    .. warning::

        You will only be able to make 5 calls with this or other search
        functions. To raise the rate-limit on this set of endpoints, create an
        authenticated :class:`GitHub <github3.github.GitHub>` Session with
        ``login``.

    The query can contain any combination of the following supported
    qualifers:

    - ``in`` Qualifies which fields are searched. With this qualifier you
      can restrict the search to just the repository name, description,
      readme, or any combination of these.
    - ``size`` Finds repositories that match a certain size (in
      kilobytes).
    - ``forks`` Filters repositories based on the number of forks, and/or
      whether forked repositories should be included in the results at
      all.
    - ``created`` or ``pushed`` Filters repositories based on times of
      creation, or when they were last updated. Format: ``YYYY-MM-DD``.
      Examples: ``created:<2011``, ``pushed:<2013-02``,
      ``pushed:>=2013-03-06``
    - ``user`` or ``repo`` Limits searches to a specific user or
      repository.
    - ``language`` Searches repositories based on the language they're
      written in.
    - ``stars`` Searches repositories based on the number of stars.

    For more information about these qualifiers, see: http://git.io/4Z8AkA

    :param str query: (required), a valid query as described above, e.g.,
        ``tetris language:assembly``
    :param str sort: (optional), how the results should be sorted;
        options: ``stars``, ``forks``, ``updated``; default: best match
    :param str order: (optional), the direction of the sorted results,
        options: ``asc``, ``desc``; default: ``desc``
    :param int per_page: (optional)
    :param bool text_match: (optional), if True, return matching search
        terms. See http://git.io/4ct1eQ for more information
    :param int number: (optional), number of repositories to return.
        Default: -1, returns all available repositories
    :param str etag: (optional), previous ETag header value
    :return: generator of :class:`Repository <github3.repos.Repository>`
    """
    return gh.search_repositories(query, sort, order, per_page, text_match,
                                  number, etag)


def search_users(query, sort=None, order=None, per_page=None,
                 text_match=False, number=-1, etag=None):
    """Find users via the Search API.

    .. warning::

        You will only be able to make 5 calls with this or other search
        functions. To raise the rate-limit on this set of endpoints, create an
        authenticated :class:`GitHub <github3.github.GitHub>` Session with
        ``login``.

    The query can contain any combination of the following supported
    qualifers:


    - ``type`` With this qualifier you can restrict the search to just
      personal accounts or just organization accounts.
    - ``in`` Qualifies which fields are searched. With this qualifier you
      can restrict the search to just the username, public email, full
      name, or any combination of these.
    - ``repos`` Filters users based on the number of repositories they
      have.
    - ``location`` Filter users by the location indicated in their
      profile.
    - ``language`` Search for users that have repositories that match a
      certain language.
    - ``created`` Filter users based on when they joined.
    - ``followers`` Filter users based on the number of followers they
      have.

    For more information about these qualifiers see: http://git.io/wjVYJw

    :param str query: (required), a valid query as described above, e.g.,
        ``tom repos:>42 followers:>1000``
    :param str sort: (optional), how the results should be sorted;
        options: ``followers``, ``repositories``, or ``joined``; default:
        best match
    :param str order: (optional), the direction of the sorted results,
        options: ``asc``, ``desc``; default: ``desc``
    :param int per_page: (optional)
    :param bool text_match: (optional), if True, return matching search
        terms. See http://git.io/_V1zRwa for more information
    :param int number: (optional), number of search results to return;
        Default: -1 returns all available
    :param str etag: (optional), ETag header value of the last request.
    :return: generator of :class:`UserSearchResult
        <github3.search.UserSearchResult>`
    """
    return gh.search_users(query, sort, order, per_page, text_match, number,
                           etag)


def user(login):
    return gh.user(login)
user.__doc__ = gh.user.__doc__


def zen():
    """Return a quote from the Zen of GitHub. Yet another API Easter Egg.

    :returns: str

    """
    return gh.zen()

########NEW FILE########
__FILENAME__ = auths
# -*- coding: utf-8 -*-
"""
github3.auths
=============

This module contains the Authorization object.

"""
from __future__ import unicode_literals

from github3.decorators import requires_basic_auth
from github3.models import GitHubCore


class Authorization(GitHubCore):

    """The :class:`Authorization <Authorization>` object.

    Two authorization instances can be checked like so::

        a1 == a2
        a1 != a2

    And is equivalent to::

        a1.id == a2.id
        a1.id != a2.id

    See also: http://developer.github.com/v3/oauth/#oauth-authorizations-api

    """

    def __init__(self, auth, session=None):
        super(Authorization, self).__init__(auth, session)
        #: Details about the application (name, url)
        self.app = auth.get('app', {})
        #: Returns the Authorization token
        self.token = auth.get('token', '')
        #: App name
        self.name = self.app.get('name', '')
        #: URL about the note
        self.note_url = auth.get('note_url') or ''
        #: Note about the authorization
        self.note = auth.get('note') or ''
        #: List of scopes this applies to
        self.scopes = auth.get('scopes', [])
        #: Unique id of the authorization
        self.id = auth.get('id', 0)
        self._api = self._build_url('authorizations', str(self.id))
        #: datetime object representing when the authorization was created.
        self.created_at = self._strptime(auth.get('created_at'))
        #: datetime object representing when the authorization was updated.
        self.updated_at = self._strptime(auth.get('updated_at'))

    def _repr(self):
        return '<Authorization [{0}]>'.format(self.name)

    def _update_(self, auth):
        self.__init__(auth, self._session)

    @requires_basic_auth
    def delete(self):
        """delete this authorization"""
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_basic_auth
    def update(self, scopes=[], add_scopes=[], rm_scopes=[], note='',
               note_url=''):
        """Update this authorization.

        :param list scopes: (optional), replaces the authorization scopes with
            these
        :param list add_scopes: (optional), scopes to be added
        :param list rm_scopes: (optional), scopes to be removed
        :param str note: (optional), new note about authorization
        :param str note_url: (optional), new note URL about this authorization
        :returns: bool

        """
        success = False
        json = None
        if scopes:
            d = {'scopes': scopes}
            json = self._json(self._post(self._api, data=d), 200)
        if add_scopes:
            d = {'add_scopes': add_scopes}
            json = self._json(self._post(self._api, data=d), 200)
        if rm_scopes:
            d = {'remove_scopes': rm_scopes}
            json = self._json(self._post(self._api, data=d), 200)
        if note or note_url:
            d = {'note': note, 'note_url': note_url}
            json = self._json(self._post(self._api, data=d), 200)

        if json:
            self._update_(json)
            success = True

        return success

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-
"""
github3.decorators
==================

This module provides decorators to the rest of the library

"""

from functools import wraps
from requests.models import Response
import os

try:  # (No coverage)
    # python2
    from StringIO import StringIO  # (No coverage)
except ImportError:  # (No coverage)
    # python3
    from io import BytesIO as StringIO


class RequestsStringIO(StringIO):
    def read(self, n=-1, *args, **kwargs):
        # StringIO is an old-style class, so can't use super
        return StringIO.read(self, n)


def requires_auth(func):
    """Decorator to note which object methods require authorization."""
    @wraps(func)
    def auth_wrapper(self, *args, **kwargs):
        auth = False
        if hasattr(self, '_session'):
            auth = (self._session.auth or
                    self._session.headers.get('Authorization'))

        if auth:
            return func(self, *args, **kwargs)
        else:
            from github3.models import GitHubError
            # Mock a 401 response
            r = generate_fake_error_response(
                '{"message": "Requires authentication"}'
            )
            raise GitHubError(r)
    return auth_wrapper


def requires_basic_auth(func):
    """Specific (basic) authentication decorator.

    This is used to note which object methods require username/password
    authorization and won't work with token based authorization.

    """
    @wraps(func)
    def auth_wrapper(self, *args, **kwargs):
        if hasattr(self, '_session') and self._session.auth:
            return func(self, *args, **kwargs)
        else:
            from github3.models import GitHubError
            # Mock a 401 response
            r = generate_fake_error_response(
                '{"message": "Requires username/password authentication"}'
            )
            raise GitHubError(r)
    return auth_wrapper


def requires_app_credentials(func):
    """Require client_id and client_secret to be associated.

    This is used to note and enforce which methods require a client_id and
    client_secret to be used.

    """
    @wraps(func)
    def auth_wrapper(self, *args, **kwargs):
        client_id, client_secret = self._session.retrieve_client_credentials()
        if client_id and client_secret:
            return func(self, *args, **kwargs)
        else:
            from github3.models import GitHubError
            # Mock a 401 response
            r = generate_fake_error_response(
                '{"message": "Requires username/password authentication"}'
            )
            raise GitHubError(r)

    return auth_wrapper


def generate_fake_error_response(msg, status_code=401, encoding='utf-8'):
    r = Response()
    r.status_code = status_code
    r.encoding = encoding
    r.raw = RequestsStringIO(msg.encode())
    r._content_consumed = True
    r._content = r.raw.read()
    return r

# Use mock decorators when generating documentation, so all functino signatures
# are displayed correctly
if os.getenv('GENERATING_DOCUMENTATION', None) == 'github3':
    requires_auth = requires_basic_auth = lambda x: x  # noqa  # (No coverage)

########NEW FILE########
__FILENAME__ = events
# -*- coding: utf-8 -*-
"""
github3.events
==============

This module contains the class(es) related to Events

"""
from __future__ import unicode_literals

from github3.models import GitHubObject


class Event(GitHubObject):

    """The :class:`Event <Event>` object. It structures and handles the data
    returned by via the `Events <http://developer.github.com/v3/events>`_
    section of the GitHub API.

    Two events can be compared like so::

        e1 == e2
        e1 != e2

    And that is equivalent to::

        e1.id == e2.id
        e1.id != e2.id

    """

    def __init__(self, event):
        super(Event, self).__init__(event)
        from github3.users import User
        from github3.orgs import Organization
        #: :class:`User <github3.users.User>` object representing the actor.
        self.actor = User(event.get('actor')) if event.get('actor') else None
        #: datetime object representing when the event was created.
        self.created_at = self._strptime(event.get('created_at'))
        #: Unique id of the event
        self.id = event.get('id')
        #: List all possible types of Events
        self.org = None
        if event.get('org'):
            self.org = Organization(event.get('org'))
        #: Event type http://developer.github.com/v3/activity/events/types/
        self.type = event.get('type')
        handler = _payload_handlers.get(self.type, identity)
        #: Dictionary with the payload. Payload structure is defined by type_.
        #  _type: http://developer.github.com/v3/events/types
        self.payload = handler(event.get('payload'))
        #: Return ``tuple(owner, repository_name)``
        self.repo = event.get('repo')
        if self.repo is not None:
            self.repo = tuple(self.repo['name'].split('/'))
        #: Indicates whether the Event is public or not.
        self.public = event.get('public')

    def _repr(self):
        return '<Event [{0}]>'.format(self.type[:-5])

    @staticmethod
    def list_types():
        """List available payload types"""
        return sorted(_payload_handlers.keys())

    def is_public(self):
        """Indicates whether the Event is public or not.

        .. warning:: This will be deprecated in 0.6

        :returns: bool -- True if event is pubic, False otherwise
        """
        return self.public


def _commitcomment(payload):
    from github3.repos.comment import RepoComment
    if payload.get('comment'):
        payload['comment'] = RepoComment(payload['comment'], None)
    return payload


def _follow(payload):
    from github3.users import User
    if payload.get('target'):
        payload['target'] = User(payload['target'], None)
    return payload


def _forkev(payload):
    from github3.repos import Repository
    if payload.get('forkee'):
        payload['forkee'] = Repository(payload['forkee'], None)
    return payload


def _gist(payload):
    from github3.gists import Gist
    if payload.get('gist'):
        payload['gist'] = Gist(payload['gist'], None)
    return payload


def _issuecomm(payload):
    from github3.issues import Issue
    from github3.issues.comment import IssueComment
    if payload.get('issue'):
        payload['issue'] = Issue(payload['issue'], None)
    if payload.get('comment'):
        payload['comment'] = IssueComment(payload['comment'], None)
    return payload


def _issueevent(payload):
    from github3.issues import Issue
    if payload.get('issue'):
        payload['issue'] = Issue(payload['issue'], None)
    return payload


def _member(payload):
    from github3.users import User
    if payload.get('member'):
        payload['member'] = User(payload['member'], None)
    return payload


def _pullreqev(payload):
    from github3.pulls import PullRequest
    if payload.get('pull_request'):
        payload['pull_request'] = PullRequest(payload['pull_request'], None)
    return payload


def _pullreqcomm(payload):
    from github3.pulls import ReviewComment
    if payload.get('comment'):
        payload['comment'] = ReviewComment(payload['comment'], None)
    return payload


def _release(payload):
    from github3.repos.release import Release
    release = payload.get('release')
    if release:
        payload['release'] = Release(release)
    return payload


def _team(payload):
    from github3.orgs import Team
    from github3.repos import Repository
    from github3.users import User
    if payload.get('team'):
        payload['team'] = Team(payload['team'], None)
    if payload.get('repo'):
        payload['repo'] = Repository(payload['repo'], None)
    if payload.get('user'):
        payload['user'] = User(payload['user'], None)
    return payload


def identity(x):
    return x


_payload_handlers = {
    'CommitCommentEvent': _commitcomment,
    'CreateEvent': identity,
    'DeleteEvent': identity,
    'FollowEvent': _follow,
    'ForkEvent': _forkev,
    'ForkApplyEvent': identity,
    'GistEvent': _gist,
    'GollumEvent': identity,
    'IssueCommentEvent': _issuecomm,
    'IssuesEvent': _issueevent,
    'MemberEvent': _member,
    'PublicEvent': lambda x: '',
    'PullRequestEvent': _pullreqev,
    'PullRequestReviewCommentEvent': _pullreqcomm,
    'PushEvent': identity,
    'ReleaseEvent': _release,
    'StatusEvent': identity,
    'TeamAddEvent': _team,
    'WatchEvent': identity,
}

########NEW FILE########
__FILENAME__ = comment
# -*- coding: utf-8 -*-
"""
github3.gists.comment
---------------------

Module containing the logic for a GistComment

"""
from __future__ import unicode_literals

from github3.models import BaseComment
from github3.users import User


class GistComment(BaseComment):

    """This object represents a comment on a gist.

    Two comment instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.id == c2.id
        c1.id != c2.id

    See also: http://developer.github.com/v3/gists/comments/

    """

    def __init__(self, comment, session=None):
        super(GistComment, self).__init__(comment, session)

        #: :class:`User <github3.users.User>` who made the comment
        #: Unless it is not associated with an account
        self.user = None
        if comment.get('user'):
            self.user = User(comment.get('user'), self)  # (No coverage)

    def _repr(self):
        return '<Gist Comment [{0}]>'.format(self.user.login)

########NEW FILE########
__FILENAME__ = file
# -*- coding: utf-8 -*-
"""
github3.gists.file
------------------

Module containing the logic for the GistFile object.
"""
from __future__ import unicode_literals

from github3.models import GitHubObject


class GistFile(GitHubObject):

    """This represents the file object returned by interacting with gists.

    It stores the raw url of the file, the file name, language, size and
    content.

    """

    def __init__(self, attributes):
        super(GistFile, self).__init__(attributes)

        #: The raw URL for the file at GitHub.
        self.raw_url = attributes.get('raw_url')
        #: The name of the file.
        self.filename = attributes.get('filename')
        #: The name of the file.
        self.name = attributes.get('filename')
        #: The language associated with the file.
        self.language = attributes.get('language')
        #: The size of the file.
        self.size = attributes.get('size')
        #: The content of the file.
        self.content = attributes.get('content')

    def _repr(self):
        return '<Gist File [{0}]>'.format(self.name)

########NEW FILE########
__FILENAME__ = gist
# -*- coding: utf-8 -*-
"""
github3.gists.gist
==================

This module contains the Gist class alone for simplicity.

"""
from __future__ import unicode_literals

from json import dumps
from github3.models import GitHubCore
from github3.decorators import requires_auth
from github3.gists.comment import GistComment
from github3.gists.file import GistFile
from github3.gists.history import GistHistory
from github3.users import User


class Gist(GitHubCore):

    """This object holds all the information returned by Github about a gist.

    With it you can comment on or fork the gist (assuming you are
    authenticated), edit or delete the gist (assuming you own it).  You can
    also "star" or "unstar" the gist (again assuming you have authenticated).

    Two gist instances can be checked like so::

        g1 == g2
        g1 != g2

    And is equivalent to::

        g1.id == g2.id
        g1.id != g2.id

    See also: http://developer.github.com/v3/gists/

    """

    def __init__(self, data, session=None):
        super(Gist, self).__init__(data, session)
        #: Number of comments on this gist
        self.comments = data.get('comments', 0)

        #: Unique id for this gist.
        self.id = '{0}'.format(data.get('id', ''))

        #: Description of the gist
        self.description = data.get('description', '')

        # e.g. https://api.github.com/gists/1
        self._api = data.get('url', '')

        #: URL of this gist at Github, e.g., https://gist.github.com/1
        self.html_url = data.get('html_url')
        #: Boolean describing if the gist is public or private
        self.public = data.get('public')

        self._forks = data.get('forks', [])
        #: The number of forks of this gist.
        self.forks = len(self._forks)

        #: Git URL to pull this gist, e.g., git://gist.github.com/1.git
        self.git_pull_url = data.get('git_pull_url', '')

        #: Git URL to push to gist, e.g., git@gist.github.com/1.git
        self.git_push_url = data.get('git_push_url', '')

        #: datetime object representing when the gist was created.
        self.created_at = self._strptime(data.get('created_at'))

        #: datetime object representing the last time this gist was updated.
        self.updated_at = self._strptime(data.get('updated_at'))

        owner = data.get('owner')
        #: :class:`User <github3.users.User>` object representing the owner of
        #: the gist.
        self.owner = User(owner, self) if owner else None

        self._files = [GistFile(data['files'][f]) for f in data['files']]
        #: Number of files in this gist.
        self.files = len(self._files)

        #: History of this gist, list of
        #: :class:`GistHistory <github3.gists.history.GistHistory>`
        self.history = [GistHistory(h, self) for h in data.get('history', [])]

        ## New urls

        #: Comments URL (not a template)
        self.comments_url = data.get('comments_url', '')

        #: Commits URL (not a template)
        self.commits_url = data.get('commits_url', '')

        #: Forks URL (not a template)
        self.forks_url = data.get('forks_url', '')

        #: Whether the content of this Gist has been truncated or not
        self.truncated = data.get('truncated')

    def __str__(self):
        return self.id

    def _repr(self):
        return '<Gist [{0}]>'.format(self.id)

    def _update_(self, data):
        self.__init__(data, self._session)

    @requires_auth
    def create_comment(self, body):
        """Create a comment on this gist.

        :param str body: (required), body of the comment
        :returns: :class:`GistComment <github3.gists.comment.GistComment>`

        """
        json = None
        if body:
            url = self._build_url('comments', base_url=self._api)
            json = self._json(self._post(url, data={'body': body}), 201)
        return GistComment(json, self) if json else None

    @requires_auth
    def delete(self):
        """Delete this gist.

        :returns: bool -- whether the deletion was successful

        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def edit(self, description='', files={}):
        """Edit this gist.

        :param str description: (optional), description of the gist
        :param dict files: (optional), files that make up this gist; the
            key(s) should be the file name(s) and the values should be another
            (optional) dictionary with (optional) keys: 'content' and
            'filename' where the former is the content of the file and the
            latter is the new name of the file.
        :returns: bool -- whether the edit was successful

        """
        data = {}
        json = None
        if description:
            data['description'] = description
        if files:
            data['files'] = files
        if data:
            json = self._json(self._patch(self._api, data=dumps(data)), 200)
        if json:
            self._update_(json)
            return True
        return False

    @requires_auth
    def fork(self):
        """Fork this gist.

        :returns: :class:`Gist <Gist>` if successful, ``None`` otherwise

        """
        url = self._build_url('forks', base_url=self._api)
        json = self._json(self._post(url), 201)
        return Gist(json, self) if json else None

    def is_public(self):
        """Check to see if this gist is public or not.

        :returns: bool -- True if public, False if private

        """
        return self.public

    @requires_auth
    def is_starred(self):
        """Check to see if this gist is starred by the authenticated user.

        :returns: bool -- True if it is starred, False otherwise

        """
        url = self._build_url('star', base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def iter_comments(self, number=-1, etag=None):
        """List comments on this gist.

        :param int number: (optional), number of comments to iterate over.
            Default: -1 will iterate over all comments on the gist
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`GistComment <github3.gists.comment.GistComment>`

        """
        url = self._build_url('comments', base_url=self._api)
        return self._iter(int(number), url, GistComment, etag=etag)

    def iter_commits(self, number=-1, etag=None):
        """Iter over the commits on this gist.

        These commits will be requested from the API and should be the same as
        what is in ``Gist.history``.

        .. versionadded:: 0.6

        .. versionchanged:: 0.9

            Added param ``etag``.

        :param int number: (optional), number of commits to iterate over.
            Default: -1 will iterate over all commits associated with this
            gist.
        :param str etag: (optional), ETag from a previous request to this
            endpoint.
        :returns: generator of
            :class:`GistHistory <github3.gists.history.GistHistory>`

        """
        url = self._build_url('commits', base_url=self._api)
        return self._iter(int(number), url, GistHistory)

    def iter_files(self):
        """Iterator over the files stored in this gist.

        :returns: generator of :class`GistFile <github3.gists.file.GistFile>`

        """
        return iter(self._files)

    def iter_forks(self, number=-1, etag=None):
        """Iterator of forks of this gist.

        .. versionchanged:: 0.9

            Added params ``number`` and ``etag``.

        :param int number: (optional), number of forks to iterate over.
            Default: -1 will iterate over all forks of this gist.
        :param str etag: (optional), ETag from a previous request to this
            endpoint.
        :returns: generator of :class:`Gist <Gist>`

        """
        url = self._build_url('forks', base_url=self._api)
        return self._iter(int(number), url, Gist, etag=etag)

    @requires_auth
    def star(self):
        """Star this gist.

        :returns: bool -- True if successful, False otherwise

        """
        url = self._build_url('star', base_url=self._api)
        return self._boolean(self._put(url), 204, 404)

    @requires_auth
    def unstar(self):
        """Un-star this gist.

        :returns: bool -- True if successful, False otherwise

        """
        url = self._build_url('star', base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

########NEW FILE########
__FILENAME__ = history
# -*- coding: utf-8 -*-
"""
github3.gists.history
---------------------

Module containing the logic for the GistHistory object.

"""
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.users import User


class GistHistory(GitHubCore):

    """Thisobject represents one version (or revision) of a gist.

    Two history instances can be checked like so::

        h1 == h2
        h1 != h2

    And is equivalent to::

        h1.version == h2.version
        h1.version != h2.version

    """

    def __init__(self, history, session=None):
        super(GistHistory, self).__init__(history, session)
        self._api = history.get('url', '')

        #: SHA of the commit associated with this version
        self.version = history.get('version', '')

        #: user who made these changes
        self.user = User(history.get('user') or {}, session)

        #: dict containing the change status; see also: deletions, additions,
        #: total
        self.change_status = history.get('change_status', {})

        #: number of additions made
        self.additions = self.change_status.get('additions', 0)

        #: number of deletions made
        self.deletions = self.change_status.get('deletions', 0)

        #: total number of changes made
        self.total = self.change_status.get('total', 0)

        #: datetime representation of when the commit was made
        self.committed_at = self._strptime(history.get('committed_at'))

    def _repr(self):
        return '<Gist History [{0}]>'.format(self.version)

    def get_gist(self):
        """Retrieve the gist at this version.

        :returns: :class:`Gist <github3.gists.gist.Gist>`

        """
        from github3.gists.gist import Gist
        json = self._json(self._get(self._api), 200)
        return Gist(json, self)

########NEW FILE########
__FILENAME__ = git
# -*- coding: utf-8 -*-
"""
github3.git
===========

This module contains all the classes relating to Git Data.

See also: http://developer.github.com/v3/git/
"""
from __future__ import unicode_literals

from json import dumps
from base64 import b64decode
from github3.models import GitHubObject, GitHubCore, BaseCommit
from github3.users import User
from github3.decorators import requires_auth


class Blob(GitHubObject):

    """The :class:`Blob <Blob>` object.

    See also: http://developer.github.com/v3/git/blobs/

    """

    def __init__(self, blob):
        super(Blob, self).__init__(blob)
        self._api = blob.get('url', '')

        #: Raw content of the blob.
        self.content = blob.get('content').encode()

        #: Encoding of the raw content.
        self.encoding = blob.get('encoding')

        #: Decoded content of the blob.
        self.decoded = self.content
        if self.encoding == 'base64':
            self.decoded = b64decode(self.content)

        #: Size of the blob in bytes
        self.size = blob.get('size')
        #: SHA1 of the blob
        self.sha = blob.get('sha')

    def _repr(self):
        return '<Blob [{0:.10}]>'.format(self.sha)


class GitData(GitHubCore):

    """The :class:`GitData <GitData>` object. This isn't directly returned to
    the user (developer) ever. This is used to prevent duplication of some
    common items among other Git Data objects.

    """

    def __init__(self, data, session=None):
        super(GitData, self).__init__(data, session)
        #: SHA of the object
        self.sha = data.get('sha')
        self._api = data.get('url', '')


class Commit(BaseCommit):

    """The :class:`Commit <Commit>` object. This represents a commit made in a
    repository.

    See also: http://developer.github.com/v3/git/commits/

    """

    def __init__(self, commit, session=None):
        super(Commit, self).__init__(commit, session)

        #: dict containing at least the name, email and date the commit was
        #: created
        self.author = commit.get('author', {}) or {}
        # If GH returns nil/None then make sure author is a dict
        self._author_name = self.author.get('name', '')

        #: dict containing similar information to the author attribute
        self.committer = commit.get('committer', {}) or {}
        # blank the data if GH returns no data

        self._commit_name = self.committer.get('name', '')

        #: :class:`Tree <Tree>` the commit belongs to.
        self.tree = None
        if commit.get('tree'):
            self.tree = Tree(commit.get('tree'), self._session)

    def _repr(self):
        return '<Commit [{0}:{1}]>'.format(self._author_name, self.sha)

    def author_as_User(self):
        """Attempt to return the author attribute as a
        :class:`User <github3.users.User>`. No guarantees are made about the
        validity of this object, i.e., having a login or created_at object.

        """
        return User(self.author, self._session)

    def committer_as_User(self):
        """Attempt to return the committer attribute as a
        :class:`User <github3.users.User>` object. No guarantees are made
        about the validity of this object.

        """
        return User(self.committer, self._session)


class Reference(GitHubCore):

    """The :class:`Reference <Reference>` object. This represents a reference
    created on a repository.

    See also: http://developer.github.com/v3/git/refs/

    """

    def __init__(self, ref, session=None):
        super(Reference, self).__init__(ref, session)
        self._api = ref.get('url', '')
        #: The reference path, e.g., refs/heads/sc/featureA
        self.ref = ref.get('ref')
        #: :class:`GitObject <GitObject>` the reference points to
        self.object = GitObject(ref.get('object', {}))

    def _repr(self):
        return '<Reference [{0}]>'.format(self.ref)

    def _update_(self, ref):
        self.__init__(ref, self._session)

    @requires_auth
    def delete(self):
        """Delete this reference.

        :returns: bool

        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def update(self, sha, force=False):
        """Update this reference.

        :param str sha: (required), sha of the reference
        :param bool force: (optional), force the update or not
        :returns: bool

        """
        data = {'sha': sha, 'force': force}
        json = self._json(self._patch(self._api, data=dumps(data)), 200)
        if json:
            self._update_(json)
            return True
        return False


class GitObject(GitData):

    """The :class:`GitObject <GitObject>` object."""

    def __init__(self, obj):
        super(GitObject, self).__init__(obj, None)
        #: The type of object.
        self.type = obj.get('type')

    def _repr(self):
        return '<Git Object [{0}]>'.format(self.sha)


class Tag(GitData):

    """The :class:`Tag <Tag>` object.

    See also: http://developer.github.com/v3/git/tags/

    """

    def __init__(self, tag):
        super(Tag, self).__init__(tag, None)
        #: String of the tag
        self.tag = tag.get('tag')
        #: Commit message for the tag
        self.message = tag.get('message')
        #: dict containing the name and email of the person
        self.tagger = tag.get('tagger')
        #: :class:`GitObject <GitObject>` for the tag
        self.object = GitObject(tag.get('object', {}))

    def _repr(self):
        return '<Tag [{0}]>'.format(self.tag)


class Tree(GitData):

    """The :class:`Tree <Tree>` object.

    See also: http://developer.github.com/v3/git/trees/

    """

    def __init__(self, tree, session=None):
        super(Tree, self).__init__(tree, session)
        #: list of :class:`Hash <Hash>` objects
        self.tree = [Hash(t) for t in tree.get('tree', [])]

    def _repr(self):
        return '<Tree [{0}]>'.format(self.sha)

    def recurse(self):
        """Recurse into the tree.

        :returns: :class:`Tree <Tree>`
        """
        json = self._json(self._get(self._api, params={'recursive': '1'}),
                          200)
        return Tree(json, self._session) if json else None


class Hash(GitHubObject):

    """The :class:`Hash <Hash>` object.

    See also: http://developer.github.com/v3/git/trees/#create-a-tree

    """

    def __init__(self, info):
        super(Hash, self).__init__(info)
        #: Path to file
        self.path = info.get('path')
        #: File mode
        self.mode = info.get('mode')
        #: Type of hash, e.g., blob
        self.type = info.get('type')
        #: Size of hash
        self.size = info.get('size')
        #: SHA of the hash
        self.sha = info.get('sha')
        #: URL of this object in the GitHub API
        self.url = info.get('url')

    def _repr(self):
        return '<Hash [{0}]>'.format(self.sha)

########NEW FILE########
__FILENAME__ = github
# -*- coding: utf-8 -*-
"""
github3.github
==============

This module contains the main GitHub session object.

"""
from __future__ import unicode_literals

from github3.auths import Authorization
from github3.decorators import (requires_auth, requires_basic_auth,
                                requires_app_credentials)
from github3.events import Event
from github3.gists import Gist
from github3.issues import Issue, issue_params
from github3.models import GitHubCore
from github3.orgs import Organization, Team
from github3.repos import Repository
from github3.search import (CodeSearchResult, IssueSearchResult,
                            RepositorySearchResult, UserSearchResult)
from github3.structs import SearchIterator
from github3.users import User, Key
from github3.notifications import Thread
from uritemplate import URITemplate


class GitHub(GitHubCore):
    """Stores all the session information.

    There are two ways to log into the GitHub API

    ::

        from github3 import login
        g = login(user, password)
        g = login(token=token)
        g = login(user, token=token)

    or

    ::

        from github3 import GitHub
        g = GitHub(user, password)
        g = GitHub(token=token)
        g = GitHub(user, token=token)

    This is simple backward compatibility since originally there was no way to
    call the GitHub object with authentication parameters.
    """
    def __init__(self, login='', password='', token=''):
        super(GitHub, self).__init__({})
        if token:
            self.login(login, token=token)
        elif login and password:
            self.login(login, password)

    def _repr(self):
        if self._session.auth:
            return '<GitHub [{0[0]}]>'.format(self._session.auth)
        return '<GitHub at 0x{0:x}>'.format(id(self))

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass

    @requires_auth
    def _iter_follow(self, which, number, etag):
        url = self._build_url('user', which)
        return self._iter(number, url, User, etag=etag)

    @requires_basic_auth
    def authorization(self, id_num):
        """Get information about authorization ``id``.

        :param int id_num: (required), unique id of the authorization
        :returns: :class:`Authorization <Authorization>`
        """
        json = None
        if int(id_num) > 0:
            url = self._build_url('authorizations', str(id_num))
            json = self._json(self._get(url), 200)
        return Authorization(json, self) if json else None

    def authorize(self, login, password, scopes=None, note='', note_url='',
                  client_id='', client_secret=''):
        """Obtain an authorization token from the GitHub API for the GitHub
        API.

        :param str login: (required)
        :param str password: (required)
        :param list scopes: (optional), areas you want this token to apply to,
            i.e., 'gist', 'user'
        :param str note: (optional), note about the authorization
        :param str note_url: (optional), url for the application
        :param str client_id: (optional), 20 character OAuth client key for
            which to create a token
        :param str client_secret: (optional), 40 character OAuth client secret
            for which to create the token
        :returns: :class:`Authorization <Authorization>`
        """
        json = None
        # TODO: Break this behaviour in 1.0 (Don't rely on self._session.auth)
        auth = None
        if self._session.auth:
            auth = self._session.auth
        elif login and password:
            auth = (login, password)

        if auth:
            url = self._build_url('authorizations')
            data = {'note': note, 'note_url': note_url,
                    'client_id': client_id, 'client_secret': client_secret}
            if scopes:
                data['scopes'] = scopes

            with self._session.temporary_basic_auth(*auth):
                json = self._json(self._post(url, data=data), 201)

        return Authorization(json, self) if json else None

    def check_authorization(self, access_token):
        """OAuth applications can use this method to check token validity
        without hitting normal rate limits because of failed login attempts.
        If the token is valid, it will return True, otherwise it will return
        False.

        :returns: bool
        """
        p = self._session.params
        auth = (p.get('client_id'), p.get('client_secret'))
        if access_token and auth:
            url = self._build_url('applications', str(auth[0]), 'tokens',
                                  str(access_token))
            resp = self._get(url, auth=auth, params={
                'client_id': None, 'client_secret': None
            })
            return self._boolean(resp, 200, 404)
        return False

    def create_gist(self, description, files, public=True):
        """Create a new gist.

        If no login was provided, it will be anonymous.

        :param str description: (required), description of gist
        :param dict files: (required), file names with associated dictionaries
            for content, e.g. ``{'spam.txt': {'content': 'File contents
            ...'}}``
        :param bool public: (optional), make the gist public if True
        :returns: :class:`Gist <github3.gists.Gist>`
        """
        new_gist = {'description': description, 'public': public,
                    'files': files}
        url = self._build_url('gists')
        json = self._json(self._post(url, data=new_gist), 201)
        return Gist(json, self) if json else None

    @requires_auth
    def create_issue(self,
                     owner,
                     repository,
                     title,
                     body=None,
                     assignee=None,
                     milestone=None,
                     labels=[]):
        """Create an issue on the project 'repository' owned by 'owner'
        with title 'title'.

        body, assignee, milestone, labels are all optional.

        :param str owner: (required), login of the owner
        :param str repository: (required), repository name
        :param str title: (required), Title of issue to be created
        :param str body: (optional), The text of the issue, markdown
            formatted
        :param str assignee: (optional), Login of person to assign
            the issue to
        :param int milestone: (optional), id number of the milestone to
            attribute this issue to (e.g. ``m`` is a :class:`Milestone
            <github3.issues.Milestone>` object, ``m.number`` is what you pass
            here.)
        :param list labels: (optional), List of label names.
        :returns: :class:`Issue <github3.issues.Issue>` if successful, else
            None
        """
        repo = None
        if owner and repository and title:
            repo = self.repository(owner, repository)

        if repo:
            return repo.create_issue(title, body, assignee, milestone, labels)

        # Regardless, something went wrong. We were unable to create the
        # issue
        return None

    @requires_auth
    def create_key(self, title, key):
        """Create a new key for the authenticated user.

        :param str title: (required), key title
        :param key: (required), actual key contents, accepts path as a string
            or file-like object
        :returns: :class:`Key <github3.users.Key>`
        """
        created = None

        if title and key:
            url = self._build_url('user', 'keys')
            req = self._post(url, data={'title': title, 'key': key})
            json = self._json(req, 201)
            if json:
                created = Key(json, self)
        return created

    @requires_auth
    def create_repo(self,
                    name,
                    description='',
                    homepage='',
                    private=False,
                    has_issues=True,
                    has_wiki=True,
                    has_downloads=True,
                    auto_init=False,
                    gitignore_template=''):
        """Create a repository for the authenticated user.

        :param str name: (required), name of the repository
        :param str description: (optional)
        :param str homepage: (optional)
        :param str private: (optional), If ``True``, create a
            private repository. API default: ``False``
        :param bool has_issues: (optional), If ``True``, enable
            issues for this repository. API default: ``True``
        :param bool has_wiki: (optional), If ``True``, enable the
            wiki for this repository. API default: ``True``
        :param bool has_downloads: (optional), If ``True``, enable
            downloads for this repository. API default: ``True``
        :param bool auto_init: (optional), auto initialize the repository
        :param str gitignore_template: (optional), name of the git template to
            use; ignored if auto_init = False.
        :returns: :class:`Repository <github3.repos.Repository>`

        .. warning: ``name`` should be no longer than 100 characters
        """
        url = self._build_url('user', 'repos')
        data = {'name': name, 'description': description,
                'homepage': homepage, 'private': private,
                'has_issues': has_issues, 'has_wiki': has_wiki,
                'has_downloads': has_downloads, 'auto_init': auto_init,
                'gitignore_template': gitignore_template}
        json = self._json(self._post(url, data=data), 201)
        return Repository(json, self) if json else None

    @requires_auth
    def delete_key(self, key_id):
        """Delete user key pointed to by ``key_id``.

        :param int key_id: (required), unique id used by Github
        :returns: bool
        """
        key = self.key(key_id)
        if key:
            return key.delete()
        return False  # (No coverage)

    def emojis(self):
        """Retrieves a dictionary of all of the emojis that GitHub supports.

        :returns: dictionary where the key is what would be in between the
            colons and the value is the URL to the image, e.g., ::

                {
                    '+1': 'https://github.global.ssl.fastly.net/images/...',
                    # ...
                }
        """
        url = self._build_url('emojis')
        return self._json(self._get(url), 200)

    @requires_basic_auth
    def feeds(self):
        """List GitHub's timeline resources in Atom format.

        :returns: dictionary parsed to include URITemplates
        """
        url = self._build_url('feeds')
        json = self._json(self._get(url), 200)
        del json['ETag']
        del json['Last-Modified']

        urls = [
            'timeline_url', 'user_url', 'current_user_public_url',
            'current_user_url', 'current_user_actor_url',
            'current_user_organization_url',
            ]

        for url in urls:
            json[url] = URITemplate(json[url])

        links = json.get('_links', {})
        for d in links.values():
            d['href'] = URITemplate(d['href'])

        return json

    @requires_auth
    def follow(self, login):
        """Make the authenticated user follow login.

        :param str login: (required), user to follow
        :returns: bool
        """
        resp = False
        if login:
            url = self._build_url('user', 'following', login)
            resp = self._boolean(self._put(url), 204, 404)
        return resp

    def gist(self, id_num):
        """Gets the gist using the specified id number.

        :param int id_num: (required), unique id of the gist
        :returns: :class:`Gist <github3.gists.Gist>`
        """
        url = self._build_url('gists', str(id_num))
        json = self._json(self._get(url), 200)
        return Gist(json, self) if json else None

    def gitignore_template(self, language):
        """Returns the template for language.

        :returns: str
        """
        url = self._build_url('gitignore', 'templates', language)
        json = self._json(self._get(url), 200)
        if not json:
            return ''
        return json.get('source', '')

    def gitignore_templates(self):
        """Returns the list of available templates.

        :returns: list of template names
        """
        url = self._build_url('gitignore', 'templates')
        return self._json(self._get(url), 200) or []

    @requires_auth
    def is_following(self, login):
        """Check if the authenticated user is following login.

        :param str login: (required), login of the user to check if the
            authenticated user is checking
        :returns: bool
        """
        json = False
        if login:
            url = self._build_url('user', 'following', login)
            json = self._boolean(self._get(url), 204, 404)
        return json

    @requires_auth
    def is_starred(self, login, repo):
        """Check if the authenticated user starred login/repo.

        :param str login: (required), owner of repository
        :param str repo: (required), name of repository
        :returns: bool
        """
        json = False
        if login and repo:
            url = self._build_url('user', 'starred', login, repo)
            json = self._boolean(self._get(url), 204, 404)
        return json

    @requires_auth
    def is_subscribed(self, login, repo):
        """Check if the authenticated user is subscribed to login/repo.

        :param str login: (required), owner of repository
        :param str repo: (required), name of repository
        :returns: bool
        """
        json = False
        if login and repo:
            url = self._build_url('user', 'subscriptions', login, repo)
            json = self._boolean(self._get(url), 204, 404)
        return json

    def issue(self, owner, repository, number):
        """Fetch issue #:number: from https://github.com/:owner:/:repository:

        :param str owner: (required), owner of the repository
        :param str repository: (required), name of the repository
        :param int number: (required), issue number
        :return: :class:`Issue <github3.issues.Issue>`
        """
        repo = self.repository(owner, repository)
        if repo:
            return repo.issue(number)
        return None

    def iter_all_repos(self, number=-1, since=None, etag=None, per_page=None):
        """Iterate over every repository in the order they were created.

        :param int number: (optional), number of repositories to return.
            Default: -1, returns all of them
        :param int since: (optional), last repository id seen (allows
            restarting this iteration)
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :param int per_page: (optional), number of repositories to list per
            request
        :returns: generator of :class:`Repository <github3.repos.Repository>`
        """
        url = self._build_url('repositories')
        return self._iter(int(number), url, Repository,
                          params={'since': since, 'per_page': per_page},
                          etag=etag)

    def iter_all_users(self, number=-1, etag=None, per_page=None):
        """Iterate over every user in the order they signed up for GitHub.

        :param int number: (optional), number of users to return. Default: -1,
            returns all of them
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :param int per_page: (optional), number of users to list per request
        :returns: generator of :class:`User <github3.users.User>`
        """
        url = self._build_url('users')
        return self._iter(int(number), url, User,
                          params={'per_page': per_page}, etag=etag)

    @requires_basic_auth
    def iter_authorizations(self, number=-1, etag=None):
        """Iterate over authorizations for the authenticated user. This will
        return a 404 if you are using a token for authentication.

        :param int number: (optional), number of authorizations to return.
            Default: -1 returns all available authorizations
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Authorization <Authorization>`\ s
        """
        url = self._build_url('authorizations')
        return self._iter(int(number), url, Authorization, etag=etag)

    @requires_auth
    def iter_emails(self, number=-1, etag=None):
        """Iterate over email addresses for the authenticated user.

        :param int number: (optional), number of email addresses to return.
            Default: -1 returns all available email addresses
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of dicts
        """
        url = self._build_url('user', 'emails')
        return self._iter(int(number), url, dict, etag=etag)

    def iter_events(self, number=-1, etag=None):
        """Iterate over public events.

        :param int number: (optional), number of events to return. Default: -1
            returns all available events
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Event <github3.events.Event>`\ s
        """
        url = self._build_url('events')
        return self._iter(int(number), url, Event, etag=etag)

    def iter_followers(self, login=None, number=-1, etag=None):
        """If login is provided, iterate over a generator of followers of that
        login name; otherwise return a generator of followers of the
        authenticated user.

        :param str login: (optional), login of the user to check
        :param int number: (optional), number of followers to return. Default:
            -1 returns all followers
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        if login:
            return self.user(login).iter_followers()
        return self._iter_follow('followers', int(number), etag=etag)

    def iter_following(self, login=None, number=-1, etag=None):
        """If login is provided, iterate over a generator of users being
        followed by login; otherwise return a generator of people followed by
        the authenticated user.

        :param str login: (optional), login of the user to check
        :param int number: (optional), number of people to return. Default: -1
            returns all people you follow
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        if login:
            return self.user(login).iter_following()
        return self._iter_follow('following', int(number), etag=etag)

    def iter_gists(self, username=None, number=-1, etag=None):
        """If no username is specified, GET /gists, otherwise GET
        /users/:username/gists

        :param str login: (optional), login of the user to check
        :param int number: (optional), number of gists to return. Default: -1
            returns all available gists
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Gist <github3.gists.Gist>`\ s
        """
        if username:
            url = self._build_url('users', username, 'gists')
        else:
            url = self._build_url('gists')
        return self._iter(int(number), url, Gist, etag=etag)

    @requires_auth
    def iter_notifications(self, all=False, participating=False, number=-1,
                           etag=None):
        """Iterate over the user's notification.

        :param bool all: (optional), iterate over all notifications
        :param bool participating: (optional), only iterate over notifications
            in which the user is participating
        :param int number: (optional), how many notifications to return
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`Thread <github3.notifications.Thread>`
        """
        params = None
        if all:
            params = {'all': all}
        elif participating:
            params = {'participating': participating}

        url = self._build_url('notifications')
        return self._iter(int(number), url, Thread, params, etag=etag)

    @requires_auth
    def iter_org_issues(self, name, filter='', state='', labels='', sort='',
                        direction='', since=None, number=-1, etag=None):
        """Iterate over the organnization's issues if the authenticated user
        belongs to it.

        :param str name: (required), name of the organization
        :param str filter: accepted values:
            ('assigned', 'created', 'mentioned', 'subscribed')
            api-default: 'assigned'
        :param str state: accepted values: ('open', 'closed')
            api-default: 'open'
        :param str labels: comma-separated list of label names, e.g.,
            'bug,ui,@high'
        :param str sort: accepted values: ('created', 'updated', 'comments')
            api-default: created
        :param str direction: accepted values: ('asc', 'desc')
            api-default: desc
        :param since: (optional), Only issues after this date will
            be returned. This can be a `datetime` or an ISO8601 formatted
            date string, e.g., 2012-05-20T23:10:27Z
        :type since: datetime or string
        :param int number: (optional), number of issues to return. Default:
            -1, returns all available issues
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Issue <github3.issues.Issue>`
        """
        url = self._build_url('orgs', name, 'issues')
        # issue_params will handle the since parameter
        params = issue_params(filter, state, labels, sort, direction, since)
        return self._iter(int(number), url, Issue, params, etag)

    @requires_auth
    def iter_issues(self, filter='', state='', labels='', sort='',
                    direction='', since=None, number=-1, etag=None):
        """List all of the authenticated user's (and organization's) issues.

        .. versionchanged:: 0.9.0

            - The ``state`` parameter now accepts 'all' in addition to 'open'
              and 'closed'.

        :param str filter: accepted values:
            ('assigned', 'created', 'mentioned', 'subscribed')
            api-default: 'assigned'
        :param str state: accepted values: ('all', 'open', 'closed')
            api-default: 'open'
        :param str labels: comma-separated list of label names, e.g.,
            'bug,ui,@high'
        :param str sort: accepted values: ('created', 'updated', 'comments')
            api-default: created
        :param str direction: accepted values: ('asc', 'desc')
            api-default: desc
        :param since: (optional), Only issues after this date will
            be returned. This can be a `datetime` or an ISO8601 formatted
            date string, e.g., 2012-05-20T23:10:27Z
        :type since: datetime or string
        :param int number: (optional), number of issues to return.
            Default: -1 returns all issues
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Issue <github3.issues.Issue>`
        """
        url = self._build_url('issues')
        # issue_params will handle the since parameter
        params = issue_params(filter, state, labels, sort, direction, since)
        return self._iter(int(number), url, Issue, params, etag)

    @requires_auth
    def iter_user_issues(self, filter='', state='', labels='', sort='',
                         direction='', since=None, number=-1, etag=None):
        """List only the authenticated user's issues. Will not list
        organization's issues

        .. versionchanged:: 0.9.0

            - The ``state`` parameter now accepts 'all' in addition to 'open'
              and 'closed'.

        :param str filter: accepted values:
            ('assigned', 'created', 'mentioned', 'subscribed')
            api-default: 'assigned'
        :param str state: accepted values: ('all', 'open', 'closed')
            api-default: 'open'
        :param str labels: comma-separated list of label names, e.g.,
            'bug,ui,@high'
        :param str sort: accepted values: ('created', 'updated', 'comments')
            api-default: created
        :param str direction: accepted values: ('asc', 'desc')
            api-default: desc
        :param since: (optional), Only issues after this date will
            be returned. This can be a `datetime` or an ISO8601 formatted
            date string, e.g., 2012-05-20T23:10:27Z
        :type since: datetime or string
        :param int number: (optional), number of issues to return.
            Default: -1 returns all issues
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Issue <github3.issues.Issue>`
        """
        url = self._build_url('user', 'issues')
        # issue_params will handle the since parameter
        params = issue_params(filter, state, labels, sort, direction, since)
        return self._iter(int(number), url, Issue, params, etag)

    def iter_repo_issues(self, owner, repository, milestone=None,
                         state=None, assignee=None, mentioned=None,
                         labels=None, sort=None, direction=None, since=None,
                         number=-1, etag=None):
        """List issues on owner/repository. Only owner and repository are
        required.

        .. versionchanged:: 0.9.0

            - The ``state`` parameter now accepts 'all' in addition to 'open'
              and 'closed'.

        :param str owner: login of the owner of the repository
        :param str repository: name of the repository
        :param int milestone: None, '*', or ID of milestone
        :param str state: accepted values: ('all', 'open', 'closed')
            api-default: 'open'
        :param str assignee: '*' or login of the user
        :param str mentioned: login of the user
        :param str labels: comma-separated list of label names, e.g.,
            'bug,ui,@high'
        :param str sort: accepted values: ('created', 'updated', 'comments')
            api-default: created
        :param str direction: accepted values: ('asc', 'desc')
            api-default: desc
        :param since: (optional), Only issues after this date will
            be returned. This can be a `datetime` or an ISO8601 formatted
            date string, e.g., 2012-05-20T23:10:27Z
        :type since: datetime or string
        :param int number: (optional), number of issues to return.
            Default: -1 returns all issues
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Issue <github3.issues.Issue>`\ s
        """
        if owner and repository:
            repo = self.repository(owner, repository)
            return repo.iter_issues(milestone, state, assignee, mentioned,
                                    labels, sort, direction, since, number,
                                    etag)
        return iter([])

    @requires_auth
    def iter_keys(self, number=-1, etag=None):
        """Iterate over public keys for the authenticated user.

        :param int number: (optional), number of keys to return. Default: -1
            returns all your keys
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Key <github3.users.Key>`\ s
        """
        url = self._build_url('user', 'keys')
        return self._iter(int(number), url, Key, etag=etag)

    def iter_orgs(self, login=None, number=-1, etag=None):
        """Iterate over public organizations for login if provided; otherwise
        iterate over public and private organizations for the authenticated
        user.

        :param str login: (optional), user whose orgs you wish to list
        :param int number: (optional), number of organizations to return.
            Default: -1 returns all available organizations
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`Organization <github3.orgs.Organization>`\ s
        """
        if login:
            url = self._build_url('users', login, 'orgs')
        else:
            url = self._build_url('user', 'orgs')

        return self._iter(int(number), url, Organization, etag=etag)

    @requires_auth
    def iter_repos(self, type=None, sort=None, direction=None, number=-1,
                   etag=None):
        """List public repositories for the authenticated user.

        .. versionchanged:: 0.6
           Removed the login parameter for correctness. Use iter_user_repos
           instead

        :param str type: (optional), accepted values:
            ('all', 'owner', 'public', 'private', 'member')
            API default: 'all'
        :param str sort: (optional), accepted values:
            ('created', 'updated', 'pushed', 'full_name')
            API default: 'created'
        :param str direction: (optional), accepted values:
            ('asc', 'desc'), API default: 'asc' when using 'full_name',
            'desc' otherwise
        :param int number: (optional), number of repositories to return.
            Default: -1 returns all repositories
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
            objects
        """
        url = self._build_url('user', 'repos')

        params = {}
        if type in ('all', 'owner', 'public', 'private', 'member'):
            params.update(type=type)
        if sort in ('created', 'updated', 'pushed', 'full_name'):
            params.update(sort=sort)
        if direction in ('asc', 'desc'):
            params.update(direction=direction)

        return self._iter(int(number), url, Repository, params, etag)

    def iter_starred(self, login=None, sort=None, direction=None, number=-1,
                     etag=None):
        """Iterate over repositories starred by ``login`` or the authenticated
        user.

        .. versionchanged:: 0.5
           Added sort and direction parameters (optional) as per the change in
           GitHub's API.

        :param str login: (optional), name of user whose stars you want to see
        :param str sort: (optional), either 'created' (when the star was
            created) or 'updated' (when the repository was last pushed to)
        :param str direction: (optional), either 'asc' or 'desc'. Default:
            'desc'
        :param int number: (optional), number of repositories to return.
            Default: -1 returns all repositories
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
        """
        if login:
            return self.user(login).iter_starred(sort, direction)

        params = {'sort': sort, 'direction': direction}
        self._remove_none(params)
        url = self._build_url('user', 'starred')
        return self._iter(int(number), url, Repository, params, etag)

    def iter_subscriptions(self, login=None, number=-1, etag=None):
        """Iterate over repositories subscribed to by ``login`` or the
        authenticated user.

        :param str login: (optional), name of user whose subscriptions you want
            to see
        :param int number: (optional), number of repositories to return.
            Default: -1 returns all repositories
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
        """
        if login:
            return self.user(login).iter_subscriptions()

        url = self._build_url('user', 'subscriptions')
        return self._iter(int(number), url, Repository, etag=etag)

    def iter_user_repos(self, login, type=None, sort=None, direction=None,
                        number=-1, etag=None):
        """List public repositories for the specified ``login``.

        .. versionadded:: 0.6

        :param str login: (required), username
        :param str type: (optional), accepted values:
            ('all', 'owner', 'member')
            API default: 'all'
        :param str sort: (optional), accepted values:
            ('created', 'updated', 'pushed', 'full_name')
            API default: 'created'
        :param str direction: (optional), accepted values:
            ('asc', 'desc'), API default: 'asc' when using 'full_name',
            'desc' otherwise
        :param int number: (optional), number of repositories to return.
            Default: -1 returns all repositories
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
            objects
        """
        url = self._build_url('users', login, 'repos')

        params = {}
        if type in ('all', 'owner', 'member'):
            params.update(type=type)
        if sort in ('created', 'updated', 'pushed', 'full_name'):
            params.update(sort=sort)
        if direction in ('asc', 'desc'):
            params.update(direction=direction)

        return self._iter(int(number), url, Repository, params, etag)

    @requires_auth
    def iter_user_teams(self, number=-1, etag=None):
        """Gets the authenticated user's teams across all of organizations.

        List all of the teams across all of the organizations to which the
        authenticated user belongs. This method requires user or repo scope
        when authenticating via OAuth.

        :returns: generator of :class:`Team <github3.orgs.Team>` objects
        """
        url = self._build_url('user', 'teams')
        return self._iter(int(number), url, Team, etag=etag)

    @requires_auth
    def key(self, id_num):
        """Gets the authenticated user's key specified by id_num.

        :param int id_num: (required), unique id of the key
        :returns: :class:`Key <github3.users.Key>`
        """
        json = None
        if int(id_num) > 0:
            url = self._build_url('user', 'keys', str(id_num))
            json = self._json(self._get(url), 200)
        return Key(json, self) if json else None

    def login(self, username=None, password=None, token=None,
              two_factor_callback=None):
        """Logs the user into GitHub for protected API calls.

        :param str username: login name
        :param str password: password for the login
        :param str token: OAuth token
        :param func two_factor_callback: (optional), function you implement to
            provide the Two Factor Authentication code to GitHub when necessary
        """
        if username and password:
            self._session.basic_auth(username, password)
        elif token:
            self._session.token_auth(token)

        # The Session method handles None for free.
        self._session.two_factor_auth_callback(two_factor_callback)

    def markdown(self, text, mode='', context='', raw=False):
        """Render an arbitrary markdown document.

        :param str text: (required), the text of the document to render
        :param str mode: (optional), 'markdown' or 'gfm'
        :param str context: (optional), only important when using mode 'gfm',
            this is the repository to use as the context for the rendering
        :param bool raw: (optional), renders a document like a README.md, no
            gfm, no context
        :returns: str -- HTML formatted text
        """
        data = None
        json = False
        headers = {}
        if raw:
            url = self._build_url('markdown', 'raw')
            data = text
            headers['content-type'] = 'text/plain'
        else:
            url = self._build_url('markdown')
            data = {}

            if text:
                data['text'] = text

            if mode in ('markdown', 'gfm'):
                data['mode'] = mode

            if context:
                data['context'] = context
            json = True

        if data:
            req = self._post(url, data=data, json=json, headers=headers)
            if req.ok:
                return req.content
        return ''  # (No coverage)

    def meta(self):
        """Returns a dictionary with arrays of addresses in CIDR format
        specifying theaddresses that the incoming service hooks will originate
        from.

        .. versionadded:: 0.5
        """
        url = self._build_url('meta')
        return self._json(self._get(url), 200)

    def octocat(self, say=None):
        """Returns an easter egg of the API.

        :params str say: (optional), pass in what you'd like Octocat to say
        :returns: ascii art of Octocat
        """
        url = self._build_url('octocat')
        req = self._get(url, params={'s': say})
        return req.content if req.ok else ''
        # TODO: Switch to req.text. Unicode is better.

    def organization(self, login):
        """Returns a Organization object for the login name

        :param str login: (required), login name of the org
        :returns: :class:`Organization <github3.orgs.Organization>`
        """
        url = self._build_url('orgs', login)
        json = self._json(self._get(url), 200)
        return Organization(json, self) if json else None

    @requires_auth
    def pubsubhubbub(self, mode, topic, callback, secret=''):
        """Create/update a pubsubhubbub hook.

        :param str mode: (required), accepted values: ('subscribe',
            'unsubscribe')
        :param str topic: (required), form:
            https://github.com/:user/:repo/events/:event
        :param str callback: (required), the URI that receives the updates
        :param str secret: (optional), shared secret key that generates a
            SHA1 HMAC of the payload content.
        :returns: bool
        """
        from re import match
        m = match('https://[\w\d\-\.\:]+/\w+/[\w\._-]+/events/\w+', topic)
        status = False
        if mode and topic and callback and m:
            data = [('hub.mode', mode), ('hub.topic', topic),
                    ('hub.callback', callback)]
            if secret:
                data.append(('hub.secret', secret))
            url = self._build_url('hub')
            # This is not JSON data. It is meant to be form data
            # application/x-www-form-urlencoded works fine here, no need for
            # multipart/form-data
            status = self._boolean(self._post(url, data=data, json=False), 204,
                                   404)
        return status

    def pull_request(self, owner, repository, number):
        """Fetch pull_request #:number: from :owner:/:repository

        :param str owner: (required), owner of the repository
        :param str repository: (required), name of the repository
        :param int number: (required), issue number
        :return: :class:`Issue <github3.issues.Issue>`
        """
        r = self.repository(owner, repository)
        return r.pull_request(number) if r else None

    def rate_limit(self):
        """Returns a dictionary with information from /rate_limit.

        The dictionary has two keys: ``resources`` and ``rate``. In
        ``resources`` you can access information about ``core`` or ``search``.

        Note: the ``rate`` key will be deprecated before version 3 of the
        GitHub API is finalized. Do not rely on that key. Instead, make your
        code future-proof by using ``core`` in ``resources``, e.g.,

        ::

            rates = g.rate_limit()
            rates['resources']['core']  # => your normal ratelimit info
            rates['resources']['search']  # => your search ratelimit info

        .. versionadded:: 0.8

        :returns: dict
        """
        url = self._build_url('rate_limit')
        return self._json(self._get(url), 200)

    def repository(self, owner, repository):
        """Returns a Repository object for the specified combination of
        owner and repository

        :param str owner: (required)
        :param str repository: (required)
        :returns: :class:`Repository <github3.repos.Repository>`
        """
        json = None
        if owner and repository:
            url = self._build_url('repos', owner, repository)
            json = self._json(self._get(url), 200)
        return Repository(json, self) if json else None

    @requires_app_credentials
    def revoke_authorization(self, access_token):
        """Revoke specified authorization for an OAuth application.

        Revoke all authorization tokens created by your application. This will
        only work if you have already called ``set_client_id``.

        :param str access_token: (required), the access_token to revoke
        :returns: bool -- True if successful, False otherwise
        """
        client_id, client_secret = self._session.retrieve_client_credentials()
        url = self._build_url('applications', str(client_id), 'tokens',
                              access_token)
        with self._session.temporary_basic_auth(client_id, client_secret):
            response = self._delete(url, params={'client_id': None,
                                                 'client_secret': None})

        return self._boolean(response, 204, 404)

    @requires_app_credentials
    def revoke_authorizations(self):
        """Revoke all authorizations for an OAuth application.

        Revoke all authorization tokens created by your application. This will
        only work if you have already called ``set_client_id``.

        :param str client_id: (required), the client_id of your application
        :returns: bool -- True if successful, False otherwise
        """
        client_id, client_secret = self._session.retrieve_client_credentials()
        url = self._build_url('applications', str(client_id), 'tokens')
        with self._session.temporary_basic_auth(client_id, client_secret):
            response = self._delete(url, params={'client_id': None,
                                                 'client_secret': None})

        return self._boolean(response, 204, 404)

    def search_code(self, query, sort=None, order=None, per_page=None,
                    text_match=False, number=-1, etag=None):
        """Find code via the code search API.

        The query can contain any combination of the following supported
        qualifiers:

        - ``in`` Qualifies which fields are searched. With this qualifier you
          can restrict the search to just the file contents, the file path, or
          both.
        - ``language`` Searches code based on the language it’s written in.
        - ``fork`` Specifies that code from forked repositories should be
          searched.  Repository forks will not be searchable unless the fork
          has more stars than the parent repository.
        - ``size`` Finds files that match a certain size (in bytes).
        - ``path`` Specifies the path that the resulting file must be at.
        - ``extension`` Matches files with a certain extension.
        - ``user`` or ``repo`` Limits searches to a specific user or
          repository.

        For more information about these qualifiers, see: http://git.io/-DvAuA

        :param str query: (required), a valid query as described above, e.g.,
            ``addClass in:file language:js repo:jquery/jquery``
        :param str sort: (optional), how the results should be sorted;
            option(s): ``indexed``; default: best match
        :param str order: (optional), the direction of the sorted results,
            options: ``asc``, ``desc``; default: ``desc``
        :param int per_page: (optional)
        :param bool text_match: (optional), if True, return matching search
            terms. See http://git.io/iRmJxg for more information
        :param int number: (optional), number of repositories to return.
            Default: -1, returns all available repositories
        :param str etag: (optional), previous ETag header value
        :return: generator of :class:`CodeSearchResult
            <github3.search.CodeSearchResult>`
        """
        params = {'q': query}
        headers = {}

        if sort == 'indexed':
            params['sort'] = sort

        if sort and order in ('asc', 'desc'):
            params['order'] = order

        if text_match:
            headers = {
                'Accept': 'application/vnd.github.v3.full.text-match+json'
                }

        url = self._build_url('search', 'code')
        return SearchIterator(number, url, CodeSearchResult, self, params,
                              etag, headers)

    def search_issues(self, query, sort=None, order=None, per_page=None,
                      text_match=False, number=-1, etag=None):
        """Find issues by state and keyword

        The query can contain any combination of the following supported
        qualifers:

        - ``type`` With this qualifier you can restrict the search to issues
          or pull request only.
        - ``in`` Qualifies which fields are searched. With this qualifier you
          can restrict the search to just the title, body, comments, or any
          combination of these.
        - ``author`` Finds issues created by a certain user.
        - ``assignee`` Finds issues that are assigned to a certain user.
        - ``mentions`` Finds issues that mention a certain user.
        - ``commenter`` Finds issues that a certain user commented on.
        - ``involves`` Finds issues that were either created by a certain user,
          assigned to that user, mention that user, or were commented on by
          that user.
        - ``state`` Filter issues based on whether they’re open or closed.
        - ``labels`` Filters issues based on their labels.
        - ``language`` Searches for issues within repositories that match a
          certain language.
        - ``created`` or ``updated`` Filters issues based on times of creation,
          or when they were last updated.
        - ``comments`` Filters issues based on the quantity of comments.
        - ``user`` or ``repo`` Limits searches to a specific user or
          repository.

        For more information about these qualifiers, see: http://git.io/d1oELA

        :param str query: (required), a valid query as described above, e.g.,
            ``windows label:bug``
        :param str sort: (optional), how the results should be sorted;
            options: ``created``, ``comments``, ``updated``;
            default: best match
        :param str order: (optional), the direction of the sorted results,
            options: ``asc``, ``desc``; default: ``desc``
        :param int per_page: (optional)
        :param bool text_match: (optional), if True, return matching search
          terms. See http://git.io/QLQuSQ for more information
        :param int number: (optional), number of issues to return.
            Default: -1, returns all available issues
        :param str etag: (optional), previous ETag header value
        :return: generator of :class:`IssueSearchResult
            <github3.search.IssueSearchResult>`
        """
        params = {'q': query}
        headers = {}

        if sort in ('comments', 'created', 'updated'):
            params['sort'] = sort

        if order in ('asc', 'desc'):
            params['order'] = order

        if text_match:
            headers = {
                'Accept': 'application/vnd.github.v3.full.text-match+json'
                }

        url = self._build_url('search', 'issues')
        return SearchIterator(number, url, IssueSearchResult, self, params,
                              etag, headers)

    def search_repositories(self, query, sort=None, order=None,
                            per_page=None, text_match=False, number=-1,
                            etag=None):
        """Find repositories via various criteria.

        The query can contain any combination of the following supported
        qualifers:

        - ``in`` Qualifies which fields are searched. With this qualifier you
          can restrict the search to just the repository name, description,
          readme, or any combination of these.
        - ``size`` Finds repositories that match a certain size (in
          kilobytes).
        - ``forks`` Filters repositories based on the number of forks, and/or
          whether forked repositories should be included in the results at
          all.
        - ``created`` or ``pushed`` Filters repositories based on times of
          creation, or when they were last updated. Format: ``YYYY-MM-DD``.
          Examples: ``created:<2011``, ``pushed:<2013-02``,
          ``pushed:>=2013-03-06``
        - ``user`` or ``repo`` Limits searches to a specific user or
          repository.
        - ``language`` Searches repositories based on the language they're
          written in.
        - ``stars`` Searches repositories based on the number of stars.

        For more information about these qualifiers, see: http://git.io/4Z8AkA

        :param str query: (required), a valid query as described above, e.g.,
            ``tetris language:assembly``
        :param str sort: (optional), how the results should be sorted;
            options: ``stars``, ``forks``, ``updated``; default: best match
        :param str order: (optional), the direction of the sorted results,
            options: ``asc``, ``desc``; default: ``desc``
        :param int per_page: (optional)
        :param bool text_match: (optional), if True, return matching search
            terms. See http://git.io/4ct1eQ for more information
        :param int number: (optional), number of repositories to return.
            Default: -1, returns all available repositories
        :param str etag: (optional), previous ETag header value
        :return: generator of :class:`Repository <github3.repos.Repository>`
        """
        params = {'q': query}
        headers = {}

        if sort in ('stars', 'forks', 'updated'):
            params['sort'] = sort

        if order in ('asc', 'desc'):
            params['order'] = order

        if text_match:
            headers = {
                'Accept': 'application/vnd.github.v3.full.text-match+json'
                }

        url = self._build_url('search', 'repositories')
        return SearchIterator(number, url, RepositorySearchResult, self,
                              params, etag, headers)

    def search_users(self, query, sort=None, order=None, per_page=None,
                     text_match=False, number=-1, etag=None):
        """Find users via the Search API.

        The query can contain any combination of the following supported
        qualifers:


        - ``type`` With this qualifier you can restrict the search to just
          personal accounts or just organization accounts.
        - ``in`` Qualifies which fields are searched. With this qualifier you
          can restrict the search to just the username, public email, full
          name, or any combination of these.
        - ``repos`` Filters users based on the number of repositories they
          have.
        - ``location`` Filter users by the location indicated in their
          profile.
        - ``language`` Search for users that have repositories that match a
          certain language.
        - ``created`` Filter users based on when they joined.
        - ``followers`` Filter users based on the number of followers they
          have.

        For more information about these qualifiers see: http://git.io/wjVYJw

        :param str query: (required), a valid query as described above, e.g.,
            ``tom repos:>42 followers:>1000``
        :param str sort: (optional), how the results should be sorted;
            options: ``followers``, ``repositories``, or ``joined``; default:
            best match
        :param str order: (optional), the direction of the sorted results,
            options: ``asc``, ``desc``; default: ``desc``
        :param int per_page: (optional)
        :param bool text_match: (optional), if True, return matching search
            terms. See http://git.io/_V1zRwa for more information
        :param int number: (optional), number of search results to return;
            Default: -1 returns all available
        :param str etag: (optional), ETag header value of the last request.
        :return: generator of :class:`UserSearchResult
            <github3.search.UserSearchResult>`
        """
        params = {'q': query}
        headers = {}

        if sort in ('followers', 'repositories', 'joined'):
            params['sort'] = sort

        if order in ('asc', 'desc'):
            params['order'] = order

        if text_match:
            headers = {
                'Accept': 'application/vnd.github.v3.full.text-match+json'
                }

        url = self._build_url('search', 'users')
        return SearchIterator(number, url, UserSearchResult, self, params,
                              etag, headers)

    def set_client_id(self, id, secret):
        """Allows the developer to set their client_id and client_secret for
        their OAuth application.

        :param str id: 20-character hexidecimal client_id provided by GitHub
        :param str secret: 40-character hexidecimal client_secret provided by
            GitHub
        """
        self._session.params = {'client_id': id, 'client_secret': secret}

    def set_user_agent(self, user_agent):
        """Allows the user to set their own user agent string to identify with
        the API.

        :param str user_agent: String used to identify your application.
            Library default: "github3.py/{version}", e.g., "github3.py/0.5"
        """
        if not user_agent:
            return
        self._session.headers.update({'User-Agent': user_agent})

    @requires_auth
    def star(self, login, repo):
        """Star to login/repo

        :param str login: (required), owner of the repo
        :param str repo: (required), name of the repo
        :return: bool
        """
        resp = False
        if login and repo:
            url = self._build_url('user', 'starred', login, repo)
            resp = self._boolean(self._put(url), 204, 404)
        return resp

    @requires_auth
    def subscribe(self, login, repo):
        """Subscribe to login/repo

        :param str login: (required), owner of the repo
        :param str repo: (required), name of the repo
        :return: bool
        """
        resp = False
        if login and repo:
            url = self._build_url('user', 'subscriptions', login, repo)
            resp = self._boolean(self._put(url), 204, 404)
        return resp

    @requires_auth
    def unfollow(self, login):
        """Make the authenticated user stop following login

        :param str login: (required)
        :returns: bool
        """
        resp = False
        if login:
            url = self._build_url('user', 'following', login)
            resp = self._boolean(self._delete(url), 204, 404)
        return resp

    @requires_auth
    def unstar(self, login, repo):
        """Unstar to login/repo

        :param str login: (required), owner of the repo
        :param str repo: (required), name of the repo
        :return: bool
        """
        resp = False
        if login and repo:
            url = self._build_url('user', 'starred', login, repo)
            resp = self._boolean(self._delete(url), 204, 404)
        return resp

    @requires_auth
    def unsubscribe(self, login, repo):
        """Unsubscribe to login/repo

        :param str login: (required), owner of the repo
        :param str repo: (required), name of the repo
        :return: bool
        """
        resp = False
        if login and repo:
            url = self._build_url('user', 'subscriptions', login, repo)
            resp = self._boolean(self._delete(url), 204, 404)
        return resp

    @requires_auth
    def update_user(self, name=None, email=None, blog=None,
                    company=None, location=None, hireable=False, bio=None):
        """If authenticated as this user, update the information with
        the information provided in the parameters. All parameters are
        optional.

        :param str name: e.g., 'John Smith', not login name
        :param str email: e.g., 'john.smith@example.com'
        :param str blog: e.g., 'http://www.example.com/jsmith/blog'
        :param str company: company name
        :param str location: where you are located
        :param bool hireable: defaults to False
        :param str bio: GitHub flavored markdown
        :returns: bool
        """
        user = self.user()
        return user.update(name, email, blog, company, location, hireable,
                           bio)

    def user(self, login=None):
        """Returns a User object for the specified login name if
        provided. If no login name is provided, this will return a User
        object for the authenticated user.

        :param str login: (optional)
        :returns: :class:`User <github3.users.User>`
        """
        if login:
            url = self._build_url('users', login)
        else:
            url = self._build_url('user')

        json = self._json(self._get(url), 200)
        return User(json, self._session) if json else None

    def zen(self):
        """Returns a quote from the Zen of GitHub. Yet another API Easter Egg

        :returns: str
        """
        url = self._build_url('zen')
        resp = self._get(url)
        return resp.content if resp.status_code == 200 else ''


class GitHubEnterprise(GitHub):
    """For GitHub Enterprise users, this object will act as the public API to
    your instance. You must provide the URL to your instance upon
    initializaiton and can provide the rest of the login details just like in
    the :class:`GitHub <GitHub>` object.

    There is no need to provide the end of the url (e.g., /api/v3/), that will
    be taken care of by us.
    
    If you have a self signed SSL for your local github enterprise you can 
    override the validation by passing `verify=False`.
    """
    def __init__(self, url, login='', password='', token='', verify=True):
        super(GitHubEnterprise, self).__init__(login, password, token)
        self._session.base_url = url.rstrip('/') + '/api/v3'
        self._session.verify = verify

    def _repr(self):
        return '<GitHub Enterprise [0.url]>'.format(self)

    @requires_auth
    def admin_stats(self, option):
        """This is a simple way to get statistics about your system.

        :param str option: (required), accepted values: ('all', 'repos',
            'hooks', 'pages', 'orgs', 'users', 'pulls', 'issues',
            'milestones', 'gists', 'comments')
        :returns: dict
        """
        stats = {}
        if option.lower() in ('all', 'repos', 'hooks', 'pages', 'orgs',
                              'users', 'pulls', 'issues', 'milestones',
                              'gists', 'comments'):
            url = self._build_url('enterprise', 'stats', option.lower())
            stats = self._json(self._get(url), 200)
        return stats


class GitHubStatus(GitHubCore):
    """A sleek interface to the GitHub System Status API. This will only ever
    return the JSON objects returned by the API.
    """
    def __init__(self):
        super(GitHubStatus, self).__init__({})
        self._session.base_url = 'https://status.github.com'

    def _repr(self):
        return '<GitHub Status>'

    def _recipe(self, *args):
        url = self._build_url(*args)
        resp = self._get(url)
        return resp.json() if self._boolean(resp, 200, 404) else {}

    def api(self):
        """GET /api.json"""
        return self._recipe('api.json')

    def status(self):
        """GET /api/status.json"""
        return self._recipe('api', 'status.json')

    def last_message(self):
        """GET /api/last-message.json"""
        return self._recipe('api', 'last-message.json')

    def messages(self):
        """GET /api/messages.json"""
        return self._recipe('api', 'messages.json')

########NEW FILE########
__FILENAME__ = comment
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import BaseComment
from github3.users import User


class IssueComment(BaseComment):
    """The :class:`IssueComment <IssueComment>` object. This structures and
    handles the comments on issues specifically.

    Two comment instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.id == c2.id
        c1.id != c2.id

    See also: http://developer.github.com/v3/issues/comments/
    """
    def __init__(self, comment, session=None):
        super(IssueComment, self).__init__(comment, session)

        user = comment.get('user')
        #: :class:`User <github3.users.User>` who made the comment
        self.user = User(user, self) if user else None

        #: Issue url (not a template)
        self.issue_url = comment.get('issue_url')

    def _repr(self):
        return '<Issue Comment [{0}]>'.format(self.user.login)

########NEW FILE########
__FILENAME__ = event
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.users import User


class IssueEvent(GitHubCore):
    """The :class:`IssueEvent <IssueEvent>` object. This specifically deals
    with events described in the
    `Issues\>Events <http://developer.github.com/v3/issues/events>`_ section of
    the GitHub API.

    Two event instances can be checked like so::

        e1 == e2
        e1 != e2

    And is equivalent to::

        e1.commit_id == e2.commit_id
        e1.commit_id != e2.commit_id

    """
    def __init__(self, event, session=None):
        super(IssueEvent, self).__init__(event, session)
        # The type of event:
        #   ('closed', 'reopened', 'subscribed', 'merged', 'referenced',
        #    'mentioned', 'assigned')
        #: The type of event, e.g., closed
        self.event = event.get('event')
        #: SHA of the commit.
        self.commit_id = event.get('commit_id')
        self._api = event.get('url', '')

        #: :class:`Issue <github3.issues.Issue>` where this comment was made.
        self.issue = event.get('issue')
        if self.issue:
            from github3.issues import Issue
            self.issue = Issue(self.issue, self)

        #: :class:`User <github3.users.User>` who caused this event.
        self.actor = event.get('actor')
        if self.actor:
            self.actor = User(self.actor, self)

        #: :class:`User <github3.users.User>` that generated the event.
        self.actor = event.get('actor')
        if self.actor:
            self.actor = User(self.actor, self._session)

        #: Number of comments
        self.comments = event.get('comments', 0)

        #: datetime object representing when the event was created.
        self.created_at = self._strptime(event.get('created_at'))

        #: Dictionary of links for the pull request
        self.pull_request = event.get('pull_request', {})

        self._uniq = self.commit_id

    def __repr__(self):
        return '<Issue Event [{0} by {1}]>'.format(
            self.event, self.actor
            )

########NEW FILE########
__FILENAME__ = issue
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from re import match
from json import dumps
from github3.decorators import requires_auth
from github3.issues.comment import IssueComment
from github3.issues.event import IssueEvent
from github3.issues.label import Label
from github3.issues.milestone import Milestone
from github3.models import GitHubCore
from github3.users import User
from uritemplate import URITemplate


class Issue(GitHubCore):

    """The :class:`Issue <Issue>` object. It structures and handles the data
    returned via the `Issues <http://developer.github.com/v3/issues>`_ section
    of the GitHub API.

    Two issue instances can be checked like so::

        i1 == i2
        i1 != i2

    And is equivalent to::

        i1.id == i2.id
        i1.id != i2.id

    """

    def __init__(self, issue, session=None):
        super(Issue, self).__init__(issue, session)
        self._api = issue.get('url', '')
        #: :class:`User <github3.users.User>` representing the user the issue
        #: was assigned to.
        self.assignee = issue.get('assignee')
        if self.assignee:
            self.assignee = User(issue.get('assignee'), self._session)
        #: Body (description) of the issue.
        self.body = issue.get('body', '')
        #: HTML formatted body of the issue.
        self.body_html = issue.get('body_html', '')
        #: Plain text formatted body of the issue.
        self.body_text = issue.get('body_text', '')

        # If an issue is still open, this field will be None
        #: datetime object representing when the issue was closed.
        self.closed_at = self._strptime(issue.get('closed_at'))

        #: Number of comments on this issue.
        self.comments = issue.get('comments')
        #: Comments url (not a template)
        self.comments_url = issue.get('comments_url')
        #: datetime object representing when the issue was created.
        self.created_at = self._strptime(issue.get('created_at'))
        #: Events url (not a template)
        self.events_url = issue.get('events_url')
        #: URL to view the issue at GitHub.
        self.html_url = issue.get('html_url')
        #: Unique ID for the issue.
        self.id = issue.get('id')
        #: Returns the list of :class:`Label <github3.issues.label.Label>`\ s
        #: on this issue.
        self.labels = [Label(l, self._session) for l in issue.get('labels')]
        labels_url = issue.get('labels_url')
        #: Labels URL Template. Expand with ``name``
        self.labels_urlt = URITemplate(labels_url) if labels_url else None
        #: :class:`Milestone <github3.issues.milestone.Milestone>` this
        #: issue was assigned to.
        self.milestone = None
        if issue.get('milestone'):
            self.milestone = Milestone(issue.get('milestone'), self._session)
        #: Issue number (e.g. #15)
        self.number = issue.get('number')
        #: Dictionary URLs for the pull request (if they exist)
        self.pull_request = issue.get('pull_request')
        m = match('https://[\w\d\-\.\:]+/(\S+)/(\S+)/(?:issues|pull)/\d+',
                  self.html_url)
        #: Returns ('owner', 'repository') this issue was filed on.
        self.repository = m.groups()
        #: State of the issue, e.g., open, closed
        self.state = issue.get('state')
        #: Title of the issue.
        self.title = issue.get('title')
        #: datetime object representing the last time the issue was updated.
        self.updated_at = self._strptime(issue.get('updated_at'))
        #: :class:`User <github3.users.User>` who opened the issue.
        self.user = User(issue.get('user'), self)

        closed_by = issue.get('closed_by')
        #: :class:`User <github3.users.User>` who closed the issue.
        self.closed_by = User(closed_by, self) if closed_by else None

    def _repr(self):
        return '<Issue [{r[0]}/{r[1]} #{n}]>'.format(r=self.repository,
                                                     n=self.number)

    def _update_(self, issue):
        self.__init__(issue, self._session)

    @requires_auth
    def add_labels(self, *args):
        """Add labels to this issue.

        :param str args: (required), names of the labels you wish to add
        :returns: list of :class:`Label`\ s
        """
        url = self._build_url('labels', base_url=self._api)
        json = self._json(self._post(url, data=args), 200)
        return [Label(l, self) for l in json] if json else []

    @requires_auth
    def assign(self, login):
        """Assigns user ``login`` to this issue. This is a short cut for
        ``issue.edit``.

        :param str login: username of the person to assign this issue to
        :returns: bool
        """
        if not login:
            return False
        number = self.milestone.number if self.milestone else None
        labels = [str(l) for l in self.labels]
        return self.edit(self.title, self.body, login, self.state, number,
                         labels)

    @requires_auth
    def close(self):
        """Close this issue.

        :returns: bool
        """
        assignee = self.assignee.login if self.assignee else ''
        number = self.milestone.number if self.milestone else None
        labels = [str(l) for l in self.labels]
        return self.edit(self.title, self.body, assignee, 'closed',
                         number, labels)

    def comment(self, id_num):
        """Get a single comment by its id.

        The catch here is that id is NOT a simple number to obtain. If
        you were to look at the comments on issue #15 in
        sigmavirus24/Todo.txt-python, the first comment's id is 4150787.

        :param int id_num: (required), comment id, see example above
        :returns: :class:`IssueComment <github3.issues.comment.IssueComment>`
        """
        json = None
        if int(id_num) > 0:  # Might as well check that it's positive
            owner, repo = self.repository
            url = self._build_url('repos', owner, repo, 'issues', 'comments',
                                  str(id_num))
            json = self._json(self._get(url), 200)
        return IssueComment(json) if json else None

    @requires_auth
    def create_comment(self, body):
        """Create a comment on this issue.

        :param str body: (required), comment body
        :returns: :class:`IssueComment <github3.issues.comment.IssueComment>`
        """
        json = None
        if body:
            url = self._build_url('comments', base_url=self._api)
            json = self._json(self._post(url, data={'body': body}),
                              201)
        return IssueComment(json, self) if json else None

    @requires_auth
    def edit(self, title=None, body=None, assignee=None, state=None,
             milestone=None, labels=None):
        """Edit this issue.

        :param str title: Title of the issue
        :param str body: markdown formatted body (description) of the issue
        :param str assignee: login name of user the issue should be assigned
            to
        :param str state: accepted values: ('open', 'closed')
        :param int milestone: the NUMBER (not title) of the milestone to
            assign this to [1]_, or 0 to remove the milestone
        :param list labels: list of labels to apply this to
        :returns: bool

        .. [1] Milestone numbering starts at 1, i.e. the first milestone you
               create is 1, the second is 2, etc.
        """
        json = None
        data = {'title': title, 'body': body, 'assignee': assignee,
                'state': state, 'milestone': milestone, 'labels': labels}
        self._remove_none(data)
        if data:
            if 'milestone' in data and data['milestone'] == 0:
                data['milestone'] = None
            json = self._json(self._patch(self._api, data=dumps(data)), 200)
        if json:
            self._update_(json)
            return True
        return False

    def is_closed(self):
        """Checks if the issue is closed.

        :returns: bool
        """
        if self.closed_at or (self.state == 'closed'):
            return True
        return False

    def iter_comments(self, number=-1):
        """Iterate over the comments on this issue.

        :param int number: (optional), number of comments to iterate over
        :returns: iterator of
            :class:`IssueComment <github3.issues.comment.IssueComment>`\ s
        """
        url = self._build_url('comments', base_url=self._api)
        return self._iter(int(number), url, IssueComment)

    def iter_events(self, number=-1):
        """Iterate over events associated with this issue only.

        :param int number: (optional), number of events to return. Default: -1
            returns all events available.
        :returns: generator of
            :class:`IssueEvent <github3.issues.event.IssueEvent>`\ s
        """
        url = self._build_url('events', base_url=self._api)
        return self._iter(int(number), url, IssueEvent)

    def iter_labels(self, number=-1, etag=None):
        """Iterate over the labels associated with this issue.

        :param int number: (optional), number of labels to return. Default: -1
            returns all labels applied to this issue.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Label <github3.issues.label.Label>`\ s
        """
        url = self._build_url('labels', base_url=self._api)
        return self._iter(int(number), url, Label, etag=etag)

    @requires_auth
    def remove_label(self, name):
        """Removes label ``name`` from this issue.

        :param str name: (required), name of the label to remove
        :returns: bool
        """
        url = self._build_url('labels', name, base_url=self._api)
        # Docs say it should be a list of strings returned, practice says it
        # is just a 204/404 response. I'm tenatively changing this until I
        # hear back from Support.
        return self._boolean(self._delete(url), 204, 404)

    @requires_auth
    def remove_all_labels(self):
        """Remove all labels from this issue.

        :returns: an empty list if successful
        """
        # Can either send DELETE or [] to remove all labels
        return self.replace_labels([])

    @requires_auth
    def replace_labels(self, labels):
        """Replace all labels on this issue with ``labels``.

        :param list labels: label names
        :returns: bool
        """
        url = self._build_url('labels', base_url=self._api)
        json = self._json(self._put(url, data=dumps(labels)), 200)
        return [Label(l, self) for l in json] if json else []

    @requires_auth
    def reopen(self):
        """Re-open a closed issue.

        :returns: bool
        """
        assignee = self.assignee.login if self.assignee else ''
        number = self.milestone.number if self.milestone else None
        labels = [str(l) for l in self.labels]
        return self.edit(self.title, self.body, assignee, 'open',
                         number, labels)

########NEW FILE########
__FILENAME__ = label
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from json import dumps
from github3.decorators import requires_auth
from github3.models import GitHubCore


class Label(GitHubCore):
    """The :class:`Label <Label>` object. Succintly represents a label that
    exists in a repository.

    See also: http://developer.github.com/v3/issues/labels/
    """
    def __init__(self, label, session=None):
        super(Label, self).__init__(label, session)
        self._api = label.get('url', '')
        #: Color of the label, e.g., 626262
        self.color = label.get('color')
        #: Name of the label, e.g., 'bug'
        self.name = label.get('name')

        self._uniq = self._api

    def _repr(self):
        return '<Label [{0}]>'.format(self)

    def __str__(self):
        return self.name

    def _update_(self, label):
        self.__init__(label, self._session)

    @requires_auth
    def delete(self):
        """Delete this label.

        :returns: bool
        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def update(self, name, color):
        """Update this label.

        :param str name: (required), new name of the label
        :param str color: (required), color code, e.g., 626262, no leading '#'
        :returns: bool
        """
        json = None

        if name and color:
            if color[0] == '#':
                color = color[1:]
            json = self._json(self._patch(self._api, data=dumps({
                'name': name, 'color': color})), 200)

        if json:
            self._update_(json)
            return True

        return False

########NEW FILE########
__FILENAME__ = milestone
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from json import dumps
from github3.decorators import requires_auth
from github3.issues.label import Label
from github3.models import GitHubCore
from github3.users import User


class Milestone(GitHubCore):
    """The :class:`Milestone <Milestone>` object. This is a small class to
    handle information about milestones on repositories and issues.

    See also: http://developer.github.com/v3/issues/milestones/
    """
    def __init__(self, mile, session=None):
        super(Milestone, self).__init__(mile, session)
        self._api = mile.get('url', '')
        #: Identifying number associated with milestone.
        self.number = mile.get('number')
        #: State of the milestone, e.g., open or closed.
        self.state = mile.get('state')
        #: Title of the milestone, e.g., 0.2.
        self.title = mile.get('title')
        #: Description of this milestone.
        self.description = mile.get('description')
        #: :class:`User <github3.users.User>` object representing the creator
        #: of the milestone.
        self.creator = User(mile.get('creator'), self._session)
        #: Number of issues associated with this milestone which are still
        #: open.
        self.open_issues = mile.get('open_issues')
        #: The number of closed issues associated with this milestone.
        self.closed_issues = mile.get('closed_issues')
        #: datetime object representing when the milestone was created.
        self.created_at = self._strptime(mile.get('created_at'))
        #: datetime representing when this milestone is due.
        self.due_on = self._strptime(mile.get('due_on'))
        #: datetime object representing when the milestone was updated.
        self.updated_at = self._strptime(mile.get('updated_at'))

    def _repr(self):
        return '<Milestone [{0}]>'.format(self)

    def __str__(self):
        return self.title

    def _update_(self, mile):
        self.__init__(mile, self._session)

    @requires_auth
    def delete(self):
        """Delete this milestone.

        :returns: bool
        """
        return self._boolean(self._delete(self._api), 204, 404)

    def iter_labels(self, number=-1, etag=None):
        """Iterate over the labels for every issue associated with this
        milestone.

        .. versionchanged:: 0.9

            Add etag parameter.

        :param int number: (optional), number of labels to return. Default: -1
            returns all available labels.
        :param str etag: (optional), ETag header from a previous response
        :returns: generator of :class:`Label <github3.issues.label.Label>`\ s
        """
        url = self._build_url('labels', base_url=self._api)
        return self._iter(int(number), url, Label, etag=etag)

    @requires_auth
    def update(self, title=None, state=None, description=None, due_on=None):
        """Update this milestone.

        All parameters are optional, but it makes no sense to omit all of them
        at once.

        :param str title: (optional), new title of the milestone
        :param str state: (optional), ('open', 'closed')
        :param str description: (optional)
        :param str due_on: (optional), ISO 8601 time format:
            YYYY-MM-DDTHH:MM:SSZ
        :returns: bool
        """
        data = {'title': title, 'state': state,
                'description': description, 'due_on': due_on}
        self._remove_none(data)
        json = None

        if data:
            json = self._json(self._patch(self._api, data=dumps(data)), 200)
        if json:
            self._update_(json)
            return True
        return False

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
github3.models
==============

This module provides the basic models used in github3.py

"""
from __future__ import unicode_literals

from json import dumps
from requests.compat import urlparse, is_py2
from github3.decorators import requires_auth
from github3.session import GitHubSession
from github3.utils import UTC
from datetime import datetime
from logging import getLogger

__timeformat__ = '%Y-%m-%dT%H:%M:%SZ'
__logs__ = getLogger(__package__)


class GitHubObject(object):
    """The :class:`GitHubObject <GitHubObject>` object. A basic class to be
    subclassed by GitHubCore and other classes that would otherwise subclass
    object."""
    def __init__(self, json):
        super(GitHubObject, self).__init__()
        if json is not None:
            self.etag = json.pop('ETag', None)
            self.last_modified = json.pop('Last-Modified', None)
        self._json_data = json
        self._uniq = json.get('url', None)

    def to_json(self):
        """Return the json representing this object."""
        return self._json_data

    def _strptime(self, time_str):
        """Convert an ISO 8601 formatted string in UTC into a
        timezone-aware datetime object."""
        if time_str:
            # Parse UTC string into naive datetime, then add timezone
            dt = datetime.strptime(time_str, __timeformat__)
            return dt.replace(tzinfo=UTC())
        return None

    def _repr(self):
        return ''

    def __repr__(self):
        repr_string = self._repr()
        if is_py2:
            return repr_string.encode('utf-8')
        return repr_string

    @classmethod
    def from_json(cls, json):
        """Return an instance of ``cls`` formed from ``json``."""
        return cls(json)

    def __eq__(self, other):
        return self._uniq == other._uniq

    def __ne__(self, other):
        return self._uniq != other._uniq

    def __hash__(self):
        return hash(self._uniq)


class GitHubCore(GitHubObject):
    """The :class:`GitHubCore <GitHubCore>` object. This class provides some
    basic attributes to other classes that are very useful to have.
    """
    def __init__(self, json, session=None):
        super(GitHubCore, self).__init__(json)
        if hasattr(session, '_session'):
            # i.e. session is actually a GitHub object
            session = session._session
        elif session is None:
            session = GitHubSession()
        self._session = session

        # set a sane default
        self._github_url = 'https://api.github.com'

    def _repr(self):
        return '<github3-core at 0x{0:x}>'.format(id(self))

    def _remove_none(self, data):
        if not data:
            return
        for (k, v) in list(data.items()):
            if v is None:
                del(data[k])

    def _json(self, response, status_code):
        ret = None
        if self._boolean(response, status_code, 404) and response.content:
            __logs__.info('Attempting to get JSON information from a Response '
                          'with status code %d expecting %d',
                          response.status_code, status_code)
            ret = response.json()
            headers = response.headers
            if ((headers.get('Last-Modified') or headers.get('ETag')) and
                    isinstance(ret, dict)):
                ret['Last-Modified'] = response.headers.get(
                    'Last-Modified', ''
                )
                ret['ETag'] = response.headers.get('ETag', '')
        __logs__.info('JSON was %sreturned', 'not ' if ret is None else '')
        return ret

    def _boolean(self, response, true_code, false_code):
        if response is not None:
            status_code = response.status_code
            if status_code == true_code:
                return True
            if status_code != false_code and status_code >= 400:
                raise GitHubError(response)
        return False

    def _delete(self, url, **kwargs):
        __logs__.debug('DELETE %s with %s', url, kwargs)
        return self._session.delete(url, **kwargs)

    def _get(self, url, **kwargs):
        __logs__.debug('GET %s with %s', url, kwargs)
        return self._session.get(url, **kwargs)

    def _patch(self, url, **kwargs):
        __logs__.debug('PATCH %s with %s', url, kwargs)
        return self._session.patch(url, **kwargs)

    def _post(self, url, data=None, json=True, **kwargs):
        if json:
            data = dumps(data) if data is not None else data
        elif 'headers' in kwargs:
            # Override the Content-Type header
            kwargs['headers'] = {
                'Content-Type': None
                }.update(kwargs['headers'])
        __logs__.debug('POST %s with %s, %s', url, data, kwargs)
        return self._session.post(url, data, **kwargs)

    def _put(self, url, **kwargs):
        __logs__.debug('PUT %s with %s', url, kwargs)
        return self._session.put(url, **kwargs)

    def _build_url(self, *args, **kwargs):
        """Builds a new API url from scratch."""
        return self._session.build_url(*args, **kwargs)

    @property
    def _api(self):
        return "{0.scheme}://{0.netloc}{0.path}".format(self._uri)

    @_api.setter
    def _api(self, uri):
        self._uri = urlparse(uri)

    def _iter(self, count, url, cls, params=None, etag=None):
        """Generic iterator for this project.

        :param int count: How many items to return.
        :param int url: First URL to start with
        :param class cls: cls to return an object of
        :param params dict: (optional) Parameters for the request
        :param str etag: (optional), ETag from the last call
        """
        from github3.structs import GitHubIterator
        return GitHubIterator(count, url, cls, self, params, etag)

    @property
    def ratelimit_remaining(self):
        """Number of requests before GitHub imposes a ratelimit.

        :returns: int
        """
        json = self._json(self._get(self._github_url + '/rate_limit'), 200)
        core = json.get('resources', {}).get('core', {})
        self._remaining = core.get('remaining', 0)
        return self._remaining

    def refresh(self, conditional=False):
        """Re-retrieve the information for this object and returns the
        refreshed instance.

        :param bool conditional: If True, then we will search for a stored
            header ('Last-Modified', or 'ETag') on the object and send that
            as described in the `Conditional Requests`_ section of the docs
        :returns: self

        The reasoning for the return value is the following example: ::

            repos = [r.refresh() for r in g.iter_repos('kennethreitz')]

        Without the return value, that would be an array of ``None``'s and you
        would otherwise have to do: ::

            repos = [r for i in g.iter_repos('kennethreitz')]
            [r.refresh() for r in repos]

        Which is really an anti-pattern.

        .. versionchanged:: 0.5

        .. _Conditional Requests:
            http://developer.github.com/v3/#conditional-requests
        """
        headers = {}
        if conditional:
            if self.last_modified:
                headers['If-Modified-Since'] = self.last_modified
            elif self.etag:
                headers['If-None-Match'] = self.etag

        headers = headers or None
        json = self._json(self._get(self._api, headers=headers), 200)
        if json is not None:
            self.__init__(json, self._session)
        return self


class BaseComment(GitHubCore):
    """The :class:`BaseComment <BaseComment>` object. A basic class for Gist,
    Issue and Pull Request Comments."""
    def __init__(self, comment, session):
        super(BaseComment, self).__init__(comment, session)
        #: Unique ID of the comment.
        self.id = comment.get('id')
        #: Body of the comment. (As written by the commenter)
        self.body = comment.get('body')
        #: Body of the comment formatted as plain-text. (Stripped of markdown,
        #: etc.)
        self.body_text = comment.get('body_text')
        #: Body of the comment formatted as html.
        self.body_html = comment.get('body_html')
        #: datetime object representing when the comment was created.
        self.created_at = self._strptime(comment.get('created_at'))
        #: datetime object representing when the comment was updated.
        self.updated_at = self._strptime(comment.get('updated_at'))

        self._api = comment.get('url', '')
        self.links = comment.get('_links')
        #: The url of this comment at GitHub
        self.html_url = ''
        #: The url of the pull request, if it exists
        self.pull_request_url = ''
        if self.links:
            self.html_url = self.links.get('html')
            self.pull_request_url = self.links.get('pull_request')

    def _update_(self, comment):
        self.__init__(comment, self._session)

    @requires_auth
    def delete(self):
        """Delete this comment.

        :returns: bool
        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def edit(self, body):
        """Edit this comment.

        :param str body: (required), new body of the comment, Markdown
            formatted
        :returns: bool
        """
        if body:
            json = self._json(self._patch(self._api,
                              data=dumps({'body': body})), 200)
            if json:
                self._update_(json)
                return True
        return False


class BaseCommit(GitHubCore):
    """The :class:`BaseCommit <BaseCommit>` object. This serves as the base for
    the various types of commit objects returned by the API.
    """
    def __init__(self, commit, session):
        super(BaseCommit, self).__init__(commit, session)
        self._api = commit.get('url', '')
        #: SHA of this commit.
        self.sha = commit.get('sha')
        #: Commit message
        self.message = commit.get('message')
        #: List of parents to this commit.
        self.parents = commit.get('parents', [])
        #: URL to view the commit on GitHub
        self.html_url = commit.get('html_url', '')
        if not self.sha:
            i = self._api.rfind('/')
            self.sha = self._api[i + 1:]

        self._uniq = self.sha


class BaseAccount(GitHubCore):
    """The :class:`BaseAccount <BaseAccount>` object. This is used to do the
    heavy lifting for :class:`Organization <github3.orgs.Organization>` and
    :class:`User <github3.users.User>` objects.
    """
    def __init__(self, acct, session):
        super(BaseAccount, self).__init__(acct, session)
        #: Tells you what type of account this is
        self.type = None
        if acct.get('type'):
            self.type = acct.get('type')
        self._api = acct.get('url', '')

        #: URL of the avatar at gravatar
        self.avatar_url = acct.get('avatar_url', '')
        #: URL of the blog
        self.blog = acct.get('blog', '')
        #: Name of the company
        self.company = acct.get('company', '')

        #: datetime object representing the date the account was created
        self.created_at = self._strptime(acct.get('created_at'))

        #: E-mail address of the user/org
        self.email = acct.get('email')

        ## The number of people following this acct
        #: Number of followers
        self.followers = acct.get('followers', 0)

        ## The number of people this acct follows
        #: Number of people the user is following
        self.following = acct.get('following', 0)

        #: Unique ID of the account
        self.id = acct.get('id', 0)
        #: Location of the user/org
        self.location = acct.get('location', '')
        #: login name of the user/org
        self.login = acct.get('login', '')

        ## e.g. first_name last_name
        #: Real name of the user/org
        self.name = acct.get('name') or ''
        self.name = self.name

        ## The number of public_repos
        #: Number of public repos owned by the user/org
        self.public_repos = acct.get('public_repos', 0)

        ## e.g. https://github.com/self._login
        #: URL of the user/org's profile
        self.html_url = acct.get('html_url', '')

        #: Markdown formatted biography
        self.bio = acct.get('bio')

    def _repr(self):
        return '<{s.type} [{s.login}:{s.name}]>'.format(s=self)

    def _update_(self, acct):
        self.__init__(acct, self._session)


class GitHubError(Exception):
    def __init__(self, resp):
        super(GitHubError, self).__init__(resp)
        #: Response code that triggered the error
        self.response = resp
        self.code = resp.status_code
        self.errors = []
        try:
            error = resp.json()
            #: Message associated with the error
            self.msg = error.get('message')
            #: List of errors provided by GitHub
            if error.get('errors'):
                self.errors = error.get('errors')
        except:  # Amazon S3 error
            self.msg = resp.content or '[No message]'

    def __repr__(self):
        return '<GitHubError [{0}]>'.format(self.msg or self.code)

    def __str__(self):
        return '{0} {1}'.format(self.code, self.msg)

    @property
    def message(self):
        return self.msg

########NEW FILE########
__FILENAME__ = notifications
# -*- coding: utf-8 -*-
"""
github3.notifications
=====================

This module contains the classes relating to notifications.

See also: http://developer.github.com/v3/activity/notifications/
"""
from __future__ import unicode_literals

from json import dumps
from github3.models import GitHubCore


class Thread(GitHubCore):
    """The :class:`Thread <Thread>` object wraps notification threads. This
    contains information about the repository generating the notification, the
    subject, and the reason.

    Two thread instances can be checked like so::

        t1 == t2
        t1 != t2

    And is equivalent to::

        t1.id == t2.id
        t1.id != t2.id

    See also:
    http://developer.github.com/v3/activity/notifications/#view-a-single-thread
    """
    def __init__(self, notif, session=None):
        super(Thread, self).__init__(notif, session)
        self._api = notif.get('url')
        #: Comment responsible for the notification
        self.comment = notif.get('comment', {})
        #: Thread information
        self.thread = notif.get('thread', {})

        from github3.repos import Repository
        #: Repository the comment was made on
        self.repository = Repository(notif.get('repository', {}), self)
        #: When the thread was last updated
        self.updated_at = self._strptime(notif.get('updated_at'))
        #: Id of the thread
        self.id = notif.get('id')
        #: Dictionary of urls for the thread
        self.urls = notif.get('urls')
        #: datetime object representing the last time the user read the thread
        self.last_read_at = self._strptime(notif.get('last_read_at'))
        #: The reason you're receiving the notification
        self.reason = notif.get('reason')
        #: Subject of the Notification, e.g., which issue/pull/diff is this in
        #: relation to. This is a dictionary
        self.subject = notif.get('subject')
        self.unread = notif.get('unread')

    def _repr(self):
        return '<Thread [{0}]>'.format(self.subject.get('title'))

    def delete_subscription(self):
        """Delete subscription for this thread.

        :returns: bool
        """
        url = self._build_url('subscription', base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

    def is_unread(self):
        """Tells you if the thread is unread or not."""
        return self.unread

    def mark(self):
        """Mark the thread as read.

        :returns: bool
        """
        return self._boolean(self._patch(self._api), 205, 404)

    def set_subscription(self, subscribed, ignored):
        """Set the user's subscription for this thread

        :param bool subscribed: (required), determines if notifications should
            be received from this thread.
        :param bool ignored: (required), determines if notifications should be
            ignored from this thread.
        :returns: :class:`Subscription <Subscription>`
        """
        url = self._build_url('subscription', base_url=self._api)
        sub = {'subscribed': subscribed, 'ignored': ignored}
        json = self._json(self._put(url, data=dumps(sub)), 200)
        return Subscription(json, self) if json else None

    def subscription(self):
        """Checks the status of the user's subscription to this thread.

        :returns: :class:`Subscription <Subscription>`
        """
        url = self._build_url('subscription', base_url=self._api)
        json = self._json(self._get(url), 200)
        return Subscription(json, self) if json else None


class Subscription(GitHubCore):
    """The :class:`Subscription <Subscription>` object wraps thread and
    repository subscription information.

    See also:
    http://developer.github.com/v3/activity/notifications/#get-a-thread-subscription
    """
    def __init__(self, sub, session=None):
        super(Subscription, self).__init__(sub, session)
        self._api = sub.get('url')
        #: reason user is subscribed to this thread/repository
        self.reason = sub.get('reason')
        #: datetime representation of when the subscription was created
        self.created_at = self._strptime(sub.get('created_at'))
        #: API url of the thread if it exists
        self.thread_url = sub.get('thread_url')
        #: API url of the repository if it exists
        self.repository_url = sub.get('repository_url')
        self.ignored = sub.get('ignored', False)
        self.subscribed = sub.get('subscribed', False)

    def _repr(self):
        return '<Subscription [{0}]>'.format(self.subscribed)

    def delete(self):
        return self._boolean(self._delete(self._api), 204, 404)

    def is_ignored(self):
        return self.ignored

    def is_subscribed(self):
        return self.subscribed

    def set(self, subscribed, ignored):
        """Set the user's subscription for this subscription

        :param bool subscribed: (required), determines if notifications should
            be received from this thread.
        :param bool ignored: (required), determines if notifications should be
            ignored from this thread.
        """
        sub = {'subscribed': subscribed, 'ignored': ignored}
        json = self._json(self._put(self._api, data=dumps(sub)), 200)
        self.__init__(json, self._session)

########NEW FILE########
__FILENAME__ = orgs
# -*- coding: utf-8 -*-
"""
github3.orgs
============

This module contains all of the classes related to organizations.

"""
from __future__ import unicode_literals

from json import dumps
from github3.events import Event
from github3.models import BaseAccount, GitHubCore
from github3.repos import Repository
from github3.users import User
from github3.decorators import requires_auth
from uritemplate import URITemplate


class Team(GitHubCore):

    """The :class:`Team <Team>` object.

    Two team instances can be checked like so::

        t1 == t2
        t1 != t2

    And is equivalent to::

        t1.id == t2.id
        t1.id != t2.id

    See also: http://developer.github.com/v3/orgs/teams/

    """

    def __init__(self, team, session=None):
        super(Team, self).__init__(team, session)
        self._api = team.get('url', '')
        #: This team's name.
        self.name = team.get('name')
        #: Unique ID of the team.
        self.id = team.get('id')
        #: Permission leve of the group
        self.permission = team.get('permission')
        #: Number of members in this team.
        self.members_count = team.get('members_count')
        members = team.get('members_url')
        #: Members URL Template. Expands with ``member``
        self.members_urlt = URITemplate(members) if members else None
        #: Number of repos owned by this team.
        self.repos_count = team.get('repos_count')
        #: Repositories url (not a template)
        self.repositories_url = team.get('repositories_url')

    def _repr(self):
        return '<Team [{0}]>'.format(self.name)

    def _update_(self, team):
        self.__init__(team, self._session)

    @requires_auth
    def add_member(self, login):
        """Add ``login`` to this team.

        :returns: bool
        """
        url = self._build_url('members', login, base_url=self._api)
        return self._boolean(self._put(url), 204, 404)

    @requires_auth
    def add_repo(self, repo):
        """Add ``repo`` to this team.

        :param str repo: (required), form: 'user/repo'
        :returns: bool
        """
        url = self._build_url('repos', repo, base_url=self._api)
        return self._boolean(self._put(url), 204, 404)

    @requires_auth
    def delete(self):
        """Delete this team.

        :returns: bool
        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def edit(self, name, permission=''):
        """Edit this team.

        :param str name: (required)
        :param str permission: (optional), ('pull', 'push', 'admin')
        :returns: bool
        """
        if name:
            data = {'name': name, 'permission': permission}
            json = self._json(self._patch(self._api, data=dumps(data)), 200)
            if json:
                self._update_(json)
                return True
        return False

    def has_repo(self, repo):
        """Checks if this team has access to ``repo``

        :param str repo: (required), form: 'user/repo'
        :returns: bool
        """
        url = self._build_url('repos', repo, base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def is_member(self, login):
        """Check if ``login`` is a member of this team.

        :param str login: (required), login name of the user
        :returns: bool
        """
        url = self._build_url('members', login, base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def iter_members(self, number=-1, etag=None):
        """Iterate over the members of this team.

        :param int number: (optional), number of users to iterate over.
            Default: -1 iterates over all values
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('members', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_repos(self, number=-1, etag=None):
        """Iterate over the repositories this team has access to.

        :param int number: (optional), number of repos to iterate over.
            Default: -1 iterates over all values
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
            objects
        """
        url = self._build_url('repos', base_url=self._api)
        return self._iter(int(number), url, Repository, etag=etag)

    @requires_auth
    def remove_member(self, login):
        """Remove ``login`` from this team.

        :param str login: (required), login of the member to remove
        :returns: bool
        """
        url = self._build_url('members', login, base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

    @requires_auth
    def remove_repo(self, repo):
        """Remove ``repo`` from this team.

        :param str repo: (required), form: 'user/repo'
        :returns: bool
        """
        url = self._build_url('repos', repo, base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)


class Organization(BaseAccount):

    """The :class:`Organization <Organization>` object.

    Two organization instances can be checked like so::

        o1 == o2
        o1 != o2

    And is equivalent to::

        o1.id == o2.id
        o1.id != o2.id

    See also: http://developer.github.com/v3/orgs/

    """

    def __init__(self, org, session=None):
        super(Organization, self).__init__(org, session)
        if not self.type:
            self.type = 'Organization'

        #: Events url (not a template)
        self.events_url = org.get('events_url')
        #: Number of private repositories.
        self.private_repos = org.get('private_repos', 0)

        members = org.get('members_url')
        #: Members URL Template. Expands with ``member``
        self.members_urlt = URITemplate(members) if members else None

        members = org.get('public_members_url')
        #: Public Members URL Template. Expands with ``member``
        self.public_members_urlt = URITemplate(members) if members else None
        #: Repositories url (not a template)
        self.repos_url = org.get('repos_url')

    @requires_auth
    def add_member(self, login, team):
        """Add ``login`` to ``team`` and thereby to this organization.

        Any user that is to be added to an organization, must be added
        to a team as per the GitHub api.

        .. note::
            This method is of complexity O(n). This iterates over all teams in
            your organization and only adds the user when the team name
            matches the team parameter above. If you want constant time, you
            should retrieve the team and call ``add_member`` on that team
            directly.

        :param str login: (required), login name of the user to be added
        :param str team: (required), team name
        :returns: bool
        """
        for t in self.iter_teams():
            if team == t.name:
                return t.add_member(login)
        return False

    @requires_auth
    def add_repo(self, repo, team):
        """Add ``repo`` to ``team``.

        .. note::
            This method is of complexity O(n). This iterates over all teams in
            your organization and only adds the repo when the team name
            matches the team parameter above. If you want constant time, you
            should retrieve the team and call ``add_repo`` on that team
            directly.

        :param str repo: (required), form: 'user/repo'
        :param str team: (required), team name
        """
        for t in self.iter_teams():
            if team == t.name:
                return t.add_repo(repo)
        return False

    @requires_auth
    def create_repo(self,
                    name,
                    description='',
                    homepage='',
                    private=False,
                    has_issues=True,
                    has_wiki=True,
                    has_downloads=True,
                    team_id=0,
                    auto_init=False,
                    gitignore_template=''):
        """Create a repository for this organization if the authenticated user
        is a member.

        :param str name: (required), name of the repository
        :param str description: (optional)
        :param str homepage: (optional)
        :param bool private: (optional), If ``True``, create a private
            repository. API default: ``False``
        :param bool has_issues: (optional), If ``True``, enable issues for
            this repository. API default: ``True``
        :param bool has_wiki: (optional), If ``True``, enable the wiki for
            this repository. API default: ``True``
        :param bool has_downloads: (optional), If ``True``, enable downloads
            for this repository. API default: ``True``
        :param int team_id: (optional), id of the team that will be granted
            access to this repository
        :param bool auto_init: (optional), auto initialize the repository.
        :param str gitignore_template: (optional), name of the template; this
            is ignored if auto_int = False.
        :returns: :class:`Repository <github3.repos.Repository>`

        .. warning: ``name`` should be no longer than 100 characters
        """
        url = self._build_url('repos', base_url=self._api)
        data = {'name': name, 'description': description,
                'homepage': homepage, 'private': private,
                'has_issues': has_issues, 'has_wiki': has_wiki,
                'has_downloads': has_downloads, 'auto_init': auto_init,
                'gitignore_template': gitignore_template}
        if team_id > 0:
            data.update({'team_id': team_id})
        json = self._json(self._post(url, data), 201)
        return Repository(json, self) if json else None

    @requires_auth
    def conceal_member(self, login):
        """Conceal ``login``'s membership in this organization.

        :returns: bool
        """
        url = self._build_url('public_members', login, base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

    @requires_auth
    def create_team(self, name, repo_names=[], permission=''):
        """Assuming the authenticated user owns this organization,
        create and return a new team.

        :param str name: (required), name to be given to the team
        :param list repo_names: (optional) repositories, e.g.
            ['github/dotfiles']
        :param str permission: (optional), options:

            - ``pull`` -- (default) members can not push or administer
                repositories accessible by this team
            - ``push`` -- members can push and pull but not administer
                repositories accessible by this team
            - ``admin`` -- members can push, pull and administer
                repositories accessible by this team

        :returns: :class:`Team <Team>`
        """
        data = {'name': name, 'repo_names': repo_names,
                'permission': permission}
        url = self._build_url('teams', base_url=self._api)
        json = self._json(self._post(url, data), 201)
        return Team(json, self._session) if json else None

    @requires_auth
    def edit(self,
             billing_email=None,
             company=None,
             email=None,
             location=None,
             name=None):
        """Edit this organization.

        :param str billing_email: (optional) Billing email address (private)
        :param str company: (optional)
        :param str email: (optional) Public email address
        :param str location: (optional)
        :param str name: (optional)
        :returns: bool
        """
        json = None
        data = {'billing_email': billing_email, 'company': company,
                'email': email, 'location': location, 'name': name}
        self._remove_none(data)

        if data:
            json = self._json(self._patch(self._api, data=dumps(data)), 200)

        if json:
            self._update_(json)
            return True
        return False

    def is_member(self, login):
        """Check if the user with login ``login`` is a member.

        :returns: bool
        """
        url = self._build_url('members', login, base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def is_public_member(self, login):
        """Check if the user with login ``login`` is a public member.

        :returns: bool
        """
        url = self._build_url('public_members', login, base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def iter_events(self, number=-1, etag=None):
        """Iterate over events for this org.

        :param int number: (optional), number of events to return. Default: -1
            iterates over all events available.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Event <github3.events.Event>`\ s
        """
        url = self._build_url('events', base_url=self._api)
        return self._iter(int(number), url, Event, etag=etag)

    def iter_members(self, number=-1, etag=None):
        """Iterate over members of this organization.

        :param int number: (optional), number of members to return. Default:
            -1 will return all available.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('members', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_public_members(self, number=-1, etag=None):
        """Iterate over public members of this organization.

        :param int number: (optional), number of members to return. Default:
            -1 will return all available.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('public_members', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_repos(self, type='', number=-1, etag=None):
        """Iterate over repos for this organization.

        :param str type: (optional), accepted values:
            ('all', 'public', 'member', 'private', 'forks', 'sources'), API
            default: 'all'
        :param int number: (optional), number of members to return. Default:
            -1 will return all available.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
        """
        url = self._build_url('repos', base_url=self._api)
        params = {}
        if type in ('all', 'public', 'member', 'private', 'forks', 'sources'):
            params['type'] = type
        return self._iter(int(number), url, Repository, params, etag)

    @requires_auth
    def iter_teams(self, number=-1, etag=None):
        """Iterate over teams that are part of this organization.

        :param int number: (optional), number of teams to return. Default: -1
            returns all available teams.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Team <Team>`\ s
        """
        url = self._build_url('teams', base_url=self._api)
        return self._iter(int(number), url, Team, etag=etag)

    @requires_auth
    def publicize_member(self, login):
        """Make ``login``'s membership in this organization public.

        :returns: bool
        """
        url = self._build_url('public_members', login, base_url=self._api)
        return self._boolean(self._put(url), 204, 404)

    @requires_auth
    def remove_member(self, login):
        """Remove the user with login ``login`` from this
        organization.

        :returns: bool
        """
        url = self._build_url('members', login, base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

    @requires_auth
    def remove_repo(self, repo, team):
        """Remove ``repo`` from ``team``.

        :param str repo: (required), form: 'user/repo'
        :param str team: (required)
        :returns: bool
        """
        for t in self.iter_teams():
            if team == t.name:
                return t.remove_repo(repo)
        return False

    @requires_auth
    def team(self, team_id):
        """Returns Team object with information about team specified by
        ``team_id``.

        :param int team_id: (required), unique id for the team
        :returns: :class:`Team <Team>`
        """
        json = None
        if int(team_id) > 0:
            url = self._build_url('teams', str(team_id))
            json = self._json(self._get(url), 200)
        return Team(json, self._session) if json else None

########NEW FILE########
__FILENAME__ = pulls
# -*- coding: utf-8 -*-
"""
github3.pulls
=============

This module contains all the classes relating to pull requests.

"""
from __future__ import unicode_literals

from re import match
from json import dumps
from github3.git import Commit
from github3.models import GitHubObject, GitHubCore, BaseComment
from github3.users import User
from github3.decorators import requires_auth
from github3.issues.comment import IssueComment
from uritemplate import URITemplate


class PullDestination(GitHubCore):

    """The :class:`PullDestination <PullDestination>` object.

    See also: http://developer.github.com/v3/pulls/#get-a-single-pull-request

    """

    def __init__(self, dest, direction):
        super(PullDestination, self).__init__(dest)
        #: Direction of the merge with respect to this destination
        self.direction = direction
        #: Full reference string of the object
        self.ref = dest.get('ref')
        #: label of the destination
        self.label = dest.get('label')
        #: :class:`User <github3.users.User>` representing the owner
        self.user = None
        if dest.get('user'):
            self.user = User(dest.get('user'), None)
        #: SHA of the commit at the head
        self.sha = dest.get('sha')
        self._repo_name = ''
        self._repo_owner = ''
        if dest.get('repo'):
            self._repo_name = dest['repo'].get('name')
            self._repo_owner = dest['repo']['owner'].get('login')
        self.repo = (self._repo_owner, self._repo_name)

    def _repr(self):
        return '<{0} [{1}]>'.format(self.direction, self.label)


class PullFile(GitHubObject):
    """The :class:`PullFile <PullFile>` object.

    See also: http://developer.github.com/v3/pulls/#list-pull-requests-files
    """
    def __init__(self, pfile):
        super(PullFile, self).__init__(pfile)
        #: SHA of the commit
        self.sha = pfile.get('sha')
        #: Name of the file
        self.filename = pfile.get('filename')
        #: Status of the file, e.g., 'added'
        self.status = pfile.get('status')
        #: Number of additions on this file
        self.additions = pfile.get('additions')
        #: Number of deletions on this file
        self.deletions = pfile.get('deletions')
        #: Number of changes made to this file
        self.changes = pfile.get('changes')
        #: URL to view the blob for this file
        self.blob_url = pfile.get('blob_url')
        #: URL to view the raw diff of this file
        self.raw_url = pfile.get('raw_url')
        #: Patch generated by this pull request
        self.patch = pfile.get('patch')

    def _repr(self):
        return '<Pull Request File [{0}]>'.format(self.filename)


class PullRequest(GitHubCore):
    """The :class:`PullRequest <PullRequest>` object.

    Two pull request instances can be checked like so::

        p1 == p2
        p1 != p2

    And is equivalent to::

        p1.id == p2.id
        p1.id != p2.id

    See also: http://developer.github.com/v3/pulls/
    """
    def __init__(self, pull, session=None):
        super(PullRequest, self).__init__(pull, session)
        self._api = pull.get('url', '')
        #: Base of the merge
        self.base = PullDestination(pull.get('base'), 'Base')
        #: Body of the pull request message
        self.body = pull.get('body', '')
        #: Body of the pull request as HTML
        self.body_html = pull.get('body_html', '')
        #: Body of the pull request as plain text
        self.body_text = pull.get('body_text', '')
        #: Number of additions on this pull request
        self.additions = pull.get('additions')
        #: Number of deletions on this pull request
        self.deletions = pull.get('deletions')

        #: datetime object representing when the pull was closed
        self.closed_at = self._strptime(pull.get('closed_at'))
        #: Number of comments
        self.comments = pull.get('comments')
        #: Comments url (not a template)
        self.comments_url = pull.get('comments_url')
        #: Number of commits
        self.commits = pull.get('commits')
        #: GitHub.com url of commits in this pull request
        self.commits_url = pull.get('commits_url')
        #: datetime object representing when the pull was created
        self.created_at = self._strptime(pull.get('created_at'))
        #: URL to view the diff associated with the pull
        self.diff_url = pull.get('diff_url')
        #: The new head after the pull request
        self.head = PullDestination(pull.get('head'), 'Head')
        #: The URL of the pull request
        self.html_url = pull.get('html_url')
        #: The unique id of the pull request
        self.id = pull.get('id')
        #: The URL of the associated issue
        self.issue_url = pull.get('issue_url')
        #: Statuses URL
        self.statuses_url = pull.get('statuses_url')

        # These are the links provided by the dictionary in the json called
        # '_links'. It's structure is horrific, so to make this look a lot
        # cleaner, I reconstructed what the links would be:
        #  - ``self`` is just the api url, e.g.,
        #    https://api.github.com/repos/:user/:repo/pulls/:number
        #  - ``comments`` is just the api url for comments on the issue, e.g.,
        #    https://api.github.com/repos/:user/:repo/issues/:number/comments
        #  - ``issue`` is the api url for the issue, e.g.,
        #    https://api.github.com/repos/:user/:repo/issues/:number
        #  - ``html`` is just the html_url attribute
        #  - ``review_comments`` is just the api url for the pull, e.g.,
        #    https://api.github.com/repos/:user/:repo/pulls/:number/comments
        #: Dictionary of _links
        self.links = {
            'self': self._api,
            'comments': '/'.join([self._api.replace('pulls', 'issues'),
                                  'comments']),
            'issue': self._api.replace('pulls', 'issues'),
            'html': self.html_url,
            'review_comments': self._api + '/comments'
        }

        #: datetime object representing when the pull was merged
        self.merged_at = self._strptime(pull.get('merged_at'))
        #: Whether the pull is deemed mergeable by GitHub
        self.mergeable = pull.get('mergeable', False)
        #: Whether it would be a clean merge or not
        self.mergeable_state = pull.get('mergeable_state', '')
        #: SHA of the merge commit. DEPRECATED
        self.merge_commit_sha = pull.get('merge_commit_sha', '')
        user = pull.get('merged_by')
        #: :class:`User <github3.users.User>` who merged this pull
        self.merged_by = User(user, self) if user else None
        #: Number of the pull/issue on the repository
        self.number = pull.get('number')
        #: The URL of the patch
        self.patch_url = pull.get('patch_url')

        comments = pull.get('review_comment_url')
        #: Review comment URL Template. Expands with ``number``
        self.review_comment_url = URITemplate(comments) if comments else None
        #: Number of review comments on the pull request
        self.review_comments = pull.get('review_comments')
        #: GitHub.com url for review comments (not a template)
        self.review_comments_url = pull.get('review_comments_url')

        m = match('https://[\w\d\-\.\:]+/(\S+)/(\S+)/(?:issues|pull)?/\d+',
                  self.issue_url)
        #: Returns ('owner', 'repository') this issue was filed on.
        self.repository = m.groups()
        #: The state of the pull
        self.state = pull.get('state')
        #: The title of the request
        self.title = pull.get('title')
        #: datetime object representing the last time the object was changed
        self.updated_at = self._strptime(pull.get('updated_at'))
        #: :class:`User <github3.users.User>` object representing the creator
        #: of the pull request
        self.user = pull.get('user')
        if self.user:
            self.user = User(self.user, self)
        #: :class:`User <github3.users.User>` object representing the assignee
        #: of the pull request
        self.assignee = pull.get('assignee')
        if self.assignee:
            self.assignee = User(self.assignee, self)

    def _repr(self):
        return '<Pull Request [#{0}]>'.format(self.number)

    def _update_(self, pull):
        self.__init__(pull, self._session)

    @requires_auth
    def close(self):
        """Closes this Pull Request without merging.

        :returns: bool
        """
        return self.update(self.title, self.body, 'closed')

    def diff(self):
        """Return the diff"""
        resp = self._get(self._api,
                         headers={'Accept': 'application/vnd.github.diff'})
        return resp.content if self._boolean(resp, 200, 404) else None

    def is_merged(self):
        """Checks to see if the pull request was merged.

        :returns: bool
        """
        url = self._build_url('merge', base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def iter_comments(self, number=-1, etag=None):
        """Iterate over the comments on this pull request.

        :param int number: (optional), number of comments to return. Default:
            -1 returns all available comments.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`ReviewComment <ReviewComment>`\ s
        """
        url = self._build_url('comments', base_url=self._api)
        return self._iter(int(number), url, ReviewComment, etag=etag)

    def iter_commits(self, number=-1, etag=None):
        """Iterates over the commits on this pull request.

        :param int number: (optional), number of commits to return. Default:
            -1 returns all available commits.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Commit <github3.git.Commit>`\ s
        """
        url = self._build_url('commits', base_url=self._api)
        return self._iter(int(number), url, Commit, etag=etag)

    def iter_files(self, number=-1, etag=None):
        """Iterate over the files associated with this pull request.

        :param int number: (optional), number of files to return. Default:
            -1 returns all available files.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`PullFile <PullFile>`\ s
        """
        url = self._build_url('files', base_url=self._api)
        return self._iter(int(number), url, PullFile, etag=etag)

    def iter_issue_comments(self, number=-1, etag=None):
        """Iterate over the issue comments on this pull request.

        :param int number: (optional), number of comments to return. Default:
            -1 returns all available comments.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`IssueComment <IssueComment>`\ s
        """
        url = self._build_url(base_url=self.links['comments'])
        return self._iter(int(number), url, IssueComment, etag=etag)

    @requires_auth
    def merge(self, commit_message=''):
        """Merge this pull request.

        :param str commit_message: (optional), message to be used for the
            merge commit
        :returns: bool
        """
        data = None
        if commit_message:
            data = dumps({'commit_message': commit_message})
        url = self._build_url('merge', base_url=self._api)
        json = self._json(self._put(url, data=data), 200)
        self.merge_commit_sha = json['sha']
        return json['merged']

    def patch(self):
        """Return the patch"""
        resp = self._get(self._api,
                         headers={'Accept': 'application/vnd.github.patch'})
        return resp.content if self._boolean(resp, 200, 404) else None

    @requires_auth
    def reopen(self):
        """Re-open a closed Pull Request.

        :returns: bool
        """
        return self.update(self.title, self.body, 'open')

    @requires_auth
    def update(self, title=None, body=None, state=None):
        """Update this pull request.

        :param str title: (optional), title of the pull
        :param str body: (optional), body of the pull request
        :param str state: (optional), ('open', 'closed')
        :returns: bool
        """
        data = {'title': title, 'body': body, 'state': state}
        json = None
        self._remove_none(data)

        if data:
            json = self._json(self._patch(self._api, data=dumps(data)), 200)

        if json:
            self._update_(json)
            return True
        return False


class ReviewComment(BaseComment):
    """The :class:`ReviewComment <ReviewComment>` object. This is used to
    represent comments on pull requests.

    Two comment instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.id == c2.id
        c1.id != c2.id

    See also: http://developer.github.com/v3/pulls/comments/
    """
    def __init__(self, comment, session=None):
        super(ReviewComment, self).__init__(comment, session)

        #: :class:`User <github3.users.User>` who made the comment
        self.user = None
        if comment.get('user'):
            self.user = User(comment.get('user'), self)

        #: Original position inside the file
        self.original_position = comment.get('original_position')

        #: Path to the file
        self.path = comment.get('path')

        #: Position within the commit
        self.position = comment.get('position') or 0

        #: SHA of the commit the comment is on
        self.commit_id = comment.get('commit_id')

        #: The diff hunk
        self.diff_hunk = comment.get('diff_hunk')

        #: Original commit SHA
        self.original_commit_id = comment.get('original_commit_id')

    def _repr(self):
        return '<Review Comment [{0}]>'.format(self.user.login)

########NEW FILE########
__FILENAME__ = branch
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.repos.commit import RepoCommit


class Branch(GitHubCore):
    """The :class:`Branch <Branch>` object. It holds the information GitHub
    returns about a branch on a
    :class:`Repository <github3.repos.repo.Repository>`.
    """
    def __init__(self, branch, session=None):
        super(Branch, self).__init__(branch, session)
        #: Name of the branch.
        self.name = branch.get('name')
        #: Returns the branch's
        #: :class:`RepoCommit <github3.repos.commit.RepoCommit>` or ``None``.
        self.commit = branch.get('commit')
        if self.commit:
            self.commit = RepoCommit(self.commit, self._session)
        #: Returns '_links' attribute.
        self.links = branch.get('_links', {})

    def _repr(self):
        return '<Repository Branch [{0}]>'.format(self.name)

########NEW FILE########
__FILENAME__ = comment
# -*- coding: utf-8 -*-
"""
github3.repos.comment
=====================

This module contains the RepoComment class

"""
from __future__ import unicode_literals

from github3.decorators import requires_auth
from github3.models import BaseComment
from github3.users import User


class RepoComment(BaseComment):
    """The :class:`RepoComment <RepoComment>` object. This stores the
    information about a comment on a file in a repository.

    Two comment instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.id == c2.id
        c1.id != c2.id

    """
    def __init__(self, comment, session=None):
        super(RepoComment, self).__init__(comment, session)
        #: Commit id on which the comment was made.
        self.commit_id = comment.get('commit_id')
        #: URL of the comment on GitHub.
        self.html_url = comment.get('html_url')
        #: The line number where the comment is located.
        self.line = comment.get('line')
        #: The path to the file where the comment was made.
        self.path = comment.get('path')
        #: The position in the diff where the comment was made.
        self.position = comment.get('position')
        #: datetime object representing when the comment was updated.
        self.updated_at = self._strptime(comment.get('updated_at'))
        #: Login of the user who left the comment.
        self.user = None
        if comment.get('user'):
            self.user = User(comment.get('user'), self)

    def _repr(self):
        return '<Repository Comment [{0}/{1}]>'.format(
            self.commit_id[:7], self.user.login or ''
        )

    def _update_(self, comment):
        super(RepoComment, self)._update_(comment)
        self.__init__(comment, self._session)

    @requires_auth
    def update(self, body):
        """Update this comment.

        :param str body: (required)
        :returns: bool
        """
        json = None
        if body:
            json = self._json(self._post(self._api, data={'body': body}), 200)

        if json:
            self._update_(json)
            return True
        return False

########NEW FILE########
__FILENAME__ = commit
# -*- coding: utf-8 -*-
"""
github3.repos.commit
====================

This module contains the RepoCommit class alone

"""
from __future__ import unicode_literals

from github3.git import Commit
from github3.models import BaseCommit
from github3.users import User


class RepoCommit(BaseCommit):
    """The :class:`RepoCommit <RepoCommit>` object. This represents a commit as
    viewed by a :class:`Repository`. This is different from a Commit object
    returned from the git data section.

    Two commit instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.sha == c2.sha
        c1.sha != c2.sha

    """
    def __init__(self, commit, session=None):
        super(RepoCommit, self).__init__(commit, session)
        #: :class:`User <github3.users.User>` who authored the commit.
        self.author = commit.get('author')
        if self.author:
            self.author = User(self.author, self._session)
        #: :class:`User <github3.users.User>` who committed the commit.
        self.committer = commit.get('committer')
        if self.committer:
            self.committer = User(self.committer, self._session)
        #: :class:`Commit <github3.git.Commit>`.
        self.commit = commit.get('commit')
        if self.commit:
            self.commit = Commit(self.commit, self._session)

        self.sha = commit.get('sha')
        #: The number of additions made in the commit.
        self.additions = 0
        #: The number of deletions made in the commit.
        self.deletions = 0
        #: Total number of changes in the files.
        self.total = 0
        if commit.get('stats'):
            self.additions = commit['stats'].get('additions')
            self.deletions = commit['stats'].get('deletions')
            self.total = commit['stats'].get('total')

        #: The files that were modified by this commit.
        self.files = commit.get('files', [])

        self._uniq = self.sha

    def _repr(self):
        return '<Repository Commit [{0}]>'.format(self.sha[:7])

    def diff(self):
        """Return the diff"""
        resp = self._get(self._api,
                         headers={'Accept': 'application/vnd.github.diff'})
        return resp.content if self._boolean(resp, 200, 404) else None

    def patch(self):
        """Return the patch"""
        resp = self._get(self._api,
                         headers={'Accept': 'application/vnd.github.patch'})
        return resp.content if self._boolean(resp, 200, 404) else None

########NEW FILE########
__FILENAME__ = comparison
# -*- coding: utf-8 -*-
"""
github3.repos.comparison
========================

This module contains the Comparison object for comparing two commits via the
GitHub API.

"""
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.repos.commit import RepoCommit


class Comparison(GitHubCore):
    """The :class:`Comparison <Comparison>` object. This encapsulates the
    information returned by GitHub comparing two commit objects in a
    repository.

    Two comparison instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.commits == c2.commits
        c1.commits != c2.commits

    See also:
    http://developer.github.com/v3/repos/commits/#compare-two-commits
    """
    def __init__(self, compare):
        super(Comparison, self).__init__(compare)
        self._api = compare.get('url', '')
        #: URL to view the comparison at GitHub
        self.html_url = compare.get('html_url')
        #: Permanent link to this comparison.
        self.permalink_url = compare.get('permalink_url')
        #: URL to see the diff between the two commits.
        self.diff_url = compare.get('diff_url')
        #: Patch URL at GitHub for the comparison.
        self.patch_url = compare.get('patch_url')
        #: :class:`RepoCommit <github3.repos.commit.RepoCommit>` object
        #: representing the base of comparison.
        self.base_commit = RepoCommit(compare.get('base_commit'), None)
        #: Behind or ahead.
        self.status = compare.get('status')
        #: Number of commits ahead by.
        self.ahead_by = compare.get('ahead_by')
        #: Number of commits behind by.
        self.behind_by = compare.get('behind_by')
        #: Number of commits difference in the comparison.
        self.total_commits = compare.get('total_commits')
        #: List of :class:`RepoCommit <github3.repos.commit.RepoCommit>`
        #: objects.
        self.commits = [RepoCommit(com) for com in compare.get('commits')]
        #: List of dicts describing the files modified.
        self.files = compare.get('files', [])

        self._uniq = self.commits

    def _repr(self):
        return '<Comparison of {0} commits>'.format(self.total_commits)

    def diff(self):
        """Return the diff"""
        resp = self._get(self._api,
                         headers={'Accept': 'application/vnd.github.diff'})
        return resp.content if self._boolean(resp, 200, 404) else None

    def patch(self):
        """Return the patch"""
        resp = self._get(self._api,
                         headers={'Accept': 'application/vnd.github.patch'})
        return resp.content if self._boolean(resp, 200, 404) else None

########NEW FILE########
__FILENAME__ = contents
# -*- coding: utf-8 -*-
"""
github3.repos.contents
======================

This module contains the Contents object pertaining to READMEs and other files
that can be accessed via the GitHub API.

"""
from __future__ import unicode_literals

from json import dumps
from base64 import b64decode, b64encode
from github3.git import Commit
from github3.models import GitHubCore
from github3.decorators import requires_auth


class Contents(GitHubCore):
    """The :class:`Contents <Contents>` object. It holds the information
    concerning any content in a repository requested via the API.

    Two content instances can be checked like so::

        c1 == c2
        c1 != c2

    And is equivalent to::

        c1.sha == c2.sha
        c1.sha != c2.sha

    See also: http://developer.github.com/v3/repos/contents/
    """
    def __init__(self, content, session=None):
        super(Contents, self).__init__(content, session)
        # links
        self._api = content.get('url')
        #: Dictionary of links
        self.links = content.get('_links')

        #: URL of the README on github.com
        self.html_url = content.get('html_url')

        #: URL for the git api pertaining to the README
        self.git_url = content.get('git_url')

        #: git:// URL of the content if it is a submodule
        self.submodule_git_url = content.get('submodule_git_url')

        # should always be 'base64'
        #: Returns encoding used on the content.
        self.encoding = content.get('encoding', '')

        # content, base64 encoded and decoded
        #: Base64-encoded content of the file.
        self.content = content.get('content', '')

        #: Decoded content of the file as a bytes object. If we try to decode
        #: to character set for you, we might encounter an exception which
        #: will prevent the object from being created. On python2 this is the
        #: same as a string, but on python3 you should call the decode method
        #: with the character set you wish to use, e.g.,
        #: ``content.decoded.decode('utf-8')``.
        #: .. versionchanged:: 0.5.2
        self.decoded = ''
        if self.encoding == 'base64' and self.content:
            self.decoded = b64decode(self.content.encode())

        # file name, path, and size
        #: Name of the content.
        self.name = content.get('name', '')
        #: Path to the content.
        self.path = content.get('path', '')
        #: Size of the content
        self.size = content.get('size', 0)
        #: SHA string.
        self.sha = content.get('sha', '')
        #: Type of content. ('file', 'symlink', 'submodule')
        self.type = content.get('type', '')
        #: Target will only be set of type is a symlink. This is what the link
        #: points to
        self.target = content.get('target', '')

        self._uniq = self.sha

    def _repr(self):
        return '<Content [{0}]>'.format(self.path)

    def __eq__(self, other):
        return self.decoded == other

    def __ne__(self, other):
        return self.sha != other

    @requires_auth
    def delete(self, message, committer=None, author=None):
        """Delete this file.

        :param str message: (required), commit message to describe the removal
        :param dict committer: (optional), if no information is given the
            authenticated user's information will be used. You must specify
            both a name and email.
        :param dict author: (optional), if omitted this will be filled in with
            committer information. If passed, you must specify both a name and
            email.
        :returns: :class:`Commit <github3.git.Commit>`

        """
        json = None
        if message:
            data = {'message': message, 'sha': self.sha,
                    'committer': validate_commmitter(committer),
                    'author': validate_commmitter(author)}
            self._remove_none(data)
            json = self._json(self._delete(self._api, data=dumps(data)), 200)
            if 'commit' in json:
                json = Commit(json['commit'], self)
        return json

    @requires_auth
    def update(self, message, content, committer=None, author=None):
        """Update this file.

        :param str message: (required), commit message to describe the update
        :param str content: (required), content to update the file with
        :param dict committer: (optional), if no information is given the
            authenticated user's information will be used. You must specify
            both a name and email.
        :param dict author: (optional), if omitted this will be filled in with
            committer information. If passed, you must specify both a name and
            email.
        :returns: :class:`Commit <github3.git.Commit>`

        """
        if content and not isinstance(content, bytes):
            raise ValueError(  # (No coverage)
                'content must be a bytes object')  # (No coverage)

        json = None
        if message and content:
            content = b64encode(content).decode('utf-8')
            data = {'message': message, 'content': content, 'sha': self.sha,
                    'committer': validate_commmitter(committer),
                    'author': validate_commmitter(author)}
            self._remove_none(data)
            json = self._json(self._put(self._api, data=dumps(data)), 200)
            if 'content' in json and 'commit' in json:
                self.__init__(json['content'], self)
                json = Commit(json['commit'], self)
        return json


def validate_commmitter(d):
    if d and d.get('name') and d.get('email'):
        return d
    return None

########NEW FILE########
__FILENAME__ = deployment
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.users import User


class Deployment(GitHubCore):
    CUSTOM_HEADERS = {
        'Accept': 'application/vnd.github.cannonball-preview+json'
        }

    def __init__(self, deployment, session=None):
        super(Deployment, self).__init__(deployment, session)
        self._api = deployment.get('url')

        #: GitHub's id of this deployment
        self.id = deployment.get('id')

        #: SHA of the branch on GitHub
        self.sha = deployment.get('sha')

        #: The reference used to create the Deployment, e.g.,
        #: `deploy-20140526`
        self.ref = deployment.get('ref')

        #: User object representing the creator of the deployment
        self.creator = deployment.get('creator')
        if self.creator:
            self.creator = User(self.creator, self)

        #: JSON string payload of the Deployment
        self.payload = deployment.get('payload')

        #: Date the Deployment was created
        self.created_at = self._strptime(deployment.get('created_at'))

        #: Date the Deployment was updated
        self.updated_at = self._strptime(deployment.get('updated_at'))

        #: Description of the deployment
        self.description = deployment.get('description')

        #: Target for the deployment, e.g., 'production', 'staging'
        self.environment = deployment.get('environment')

        #: URL to get the statuses of this deployment
        self.statuses_url = deployment.get('statuses_url')

    def _repr(self):
        return '<Deployment [{0} @ {1}]>'.format(self.id, self.sha)

    def create_status(self, state, target_url='', description=''):
        """Create a new deployment status for this deployment.

        :param str state: (required), The state of the status. Can be one of
            ``pending``, ``success``, ``error``, or ``failure``.
        :param str target_url: The target URL to associate with this status.
            This URL should contain output to keep the user updated while the
            task is running or serve as historical information for what
            happened in the deployment. Default: ''.
        :param str description: A short description of the status. Default: ''.
        :return: partial :class:`DeploymentStatus <DeploymentStatus>`
        """
        json = None

        if state in ('pending', 'success', 'error', 'failure'):
            data = {'state': state, 'target_url': target_url,
                    'description': description}
            response = self._post(self.statuses_url, data=data,
                                  headers=Deployment.CUSTOM_HEADERS)
            json = self._json(response, 201)

        return DeploymentStatus(json, self) if json else None

    def iter_statuses(self, number=-1, etag=None):
        """Iterate over the deployment statuses for this deployment.

        :param int number: (optional), the number of statuses to return.
            Default: -1, returns all statuses.
        :param str etag: (optional), the ETag header value from the last time
            you iterated over the statuses.
        :returns: generator of :class:`DeploymentStatus`\ es
        """
        i = self._iter(int(number), self.statuses_url, DeploymentStatus,
                       etag=etag)
        i.headers = Deployment.CUSTOM_HEADERS
        return i


class DeploymentStatus(GitHubCore):
    def __init__(self, status, session=None):
        super(DeploymentStatus, self).__init__(status, session)
        self._api = status.get('url')

        #: GitHub's id for this deployment status
        self.id = status.get('id')

        #: State of the deployment status
        self.state = status.get('state')

        #: Creater of the deployment status
        self.creator = status.get('creator')
        if self.creator:
            self.creator = User(self.creator, self)

        #: JSON payload as a string
        self.payload = status.get('payload', {})

        #: Target URL of the deployment
        self.target_url = status.get('target_url')

        #: Date the deployment status was created
        self.created_at = self._strptime(status.get('created_at'))

        #: Date the deployment status was updated
        self.updated_at = self._strptime(status.get('updated_at'))

        #: Description of the deployment
        self.description = status.get('description')

        #: :class:`Deployment` representing the deployment this status is
        #: associated with
        self.deployment = status.get('deployment')
        if self.deployment:
            self.deployment = Deployment(self.deployment, self)

        #: URL for the deployment this status is associated with
        self.deployment_url = status.get('deployment_url')

    def _repr(self):
        return '<DeploymentStatus [{0}]>'.format(self.id)

########NEW FILE########
__FILENAME__ = hook
# -*- coding: utf-8 -*-
"""
github3.repos.hook
==================

This module contains only the Hook object for GitHub's Hook API.

"""
from __future__ import unicode_literals

from json import dumps
from github3.decorators import requires_auth
from github3.models import GitHubCore


class Hook(GitHubCore):
    """The :class:`Hook <Hook>` object. This handles the information returned
    by GitHub about hooks set on a repository.

    Two hook instances can be checked like so::

        h1 == h2
        h1 != h2

    And is equivalent to::

        h1.id == h2.id
        h1.id != h2.id

    See also: http://developer.github.com/v3/repos/hooks/
    """
    def __init__(self, hook, session=None):
        super(Hook, self).__init__(hook, session)
        self._api = hook.get('url', '')
        #: datetime object representing when this hook was last updated.
        self.updated_at = self._strptime(hook.get('updated_at'))
        #: datetime object representing the date the hook was created.
        self.created_at = self._strptime(hook.get('created_at'))
        #: The name of the hook.
        self.name = hook.get('name')
        #: Events which trigger the hook.
        self.events = hook.get('events')
        #: Whether or not this Hook is marked as active on GitHub
        self.active = hook.get('active')
        #: Dictionary containing the configuration for the Hook.
        self.config = hook.get('config')
        #: Unique id of the hook.
        self.id = hook.get('id')

    def _repr(self):
        return '<Hook [{0}]>'.format(self.name)

    def _update_(self, hook):
        self.__init__(hook, self._session)

    @requires_auth
    def delete(self):
        """Delete this hook.

        :returns: bool
        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def edit(self, config={}, events=[], add_events=[], rm_events=[],
             active=True):
        """Edit this hook.

        :param dict config: (optional), key-value pairs of settings for this
            hook
        :param list events: (optional), which events should this be triggered
            for
        :param list add_events: (optional), events to be added to the list of
           events that this hook triggers for
        :param list rm_events: (optional), events to be remvoed from the list
            of events that this hook triggers for
        :param bool active: (optional), should this event be active
        :returns: bool
        """
        data = {'config': config, 'active': active}
        if events:
            data['events'] = events

        if add_events:
            data['add_events'] = add_events

        if rm_events:
            data['remove_events'] = rm_events

        json = self._json(self._patch(self._api, data=dumps(data)), 200)

        if json:
            self._update_(json)
            return True

        return False

    @requires_auth
    def ping(self):
        """Ping this hook.

        :returns: bool
        """
        url = self._build_url('pings', base_url=self._api)
        return self._boolean(self._post(url), 204, 404)

    @requires_auth
    def test(self):
        """Test this hook

        :returns: bool
        """
        url = self._build_url('tests', base_url=self._api)
        return self._boolean(self._post(url), 204, 404)

########NEW FILE########
__FILENAME__ = pages
from github3.models import GitHubObject


class PagesInfo(GitHubObject):
    def __init__(self, info):
        super(PagesInfo, self).__init__(info)
        self._api = info.get('url')

        #: Status of the pages site, e.g., built
        self.status = info.get('status')

        #: CName used for the pages site
        self.cname = info.get('cname')

        #: Boolean indicating whether there is a custom 404 for the pages site
        self.custom_404 = info.get('custom_404')


class PagesBuild(GitHubObject):
    def __init__(self, build):
        super(PagesBuild, self).__init__(build)
        self._api = build.get('url')

        #: Status of the pages build, e.g., building
        self.status = build.get('status')

        #: Error dictionary containing the error message
        self.error = build.get('error')

        from github3.users import User
        #: :class:`User <github3.users.User>` representing who pushed the
        #: commit
        self.pusher = User(build.get('pusher'))

        #: SHA of the commit that triggered the build
        self.commit = build.get('commit')

        #: Time the build took to finish
        self.duration = build.get('duration')

        #: Datetime the build was created
        self.created_at = self._strptime(build.get('created_at'))

        #: Datetime the build was updated
        self.updated_at = self._strptime(build.get('updated_at'))

########NEW FILE########
__FILENAME__ = release
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import json

from github3.decorators import requires_auth
from github3.models import GitHubCore, GitHubError
from github3.utils import stream_response_to_file
from uritemplate import URITemplate


class Release(GitHubCore):

    """The :class:`Release <Release>` object.

    It holds the information GitHub returns about a release from a
    :class:`Repository <github3.repos.repo.Repository>`.

    """

    CUSTOM_HEADERS = {'Accept': 'application/vnd.github.manifold-preview'}

    def __init__(self, release, session=None):
        super(Release, self).__init__(release, session)
        self._api = release.get('url')
        #: List of :class:`Asset <Asset>` objects for this release
        self.assets = [Asset(i, self) for i in release.get('assets', [])]
        #: URL for uploaded assets
        self.assets_url = release.get('assets_url')
        #: Body of the release (the description)
        self.body = release.get('body')
        #: Date the release was created
        self.created_at = self._strptime(release.get('created_at'))
        #: Boolean whether value is True or False
        self.draft = release.get('draft')
        #: HTML URL of the release
        self.html_url = release.get('html_url')
        #: GitHub id
        self.id = release.get('id')
        #: Name given to the release
        self.name = release.get('name')
        #; Boolean whether release is a prerelease
        self.prerelease = release.get('prerelease')
        #: Date the release was published
        self.published_at = self._strptime(release.get('published_at'))
        #: Name of the tag
        self.tag_name = release.get('tag_name')
        #: "Commit" that this release targets
        self.target_commitish = release.get('target_commitish')
        upload_url = release.get('upload_url')
        #: URITemplate to upload an asset with
        self.upload_urlt = URITemplate(upload_url) if upload_url else None

    def _repr(self):
        return '<Release [{0}]>'.format(self.name)

    @requires_auth
    def delete(self):
        """Users with push access to the repository can delete a release.

        :returns: True if successful; False if not successful
        """
        url = self._api
        return self._boolean(
            self._delete(url, headers=Release.CUSTOM_HEADERS),
            204,
            404
        )

    @requires_auth
    def edit(self, tag_name=None, target_commitish=None, name=None, body=None,
             draft=None, prerelease=None):
        """Users with push access to the repository can edit a release.

        If the edit is successful, this object will update itself.

        :param str tag_name: (optional), Name of the tag to use
        :param str target_commitish: (optional), The "commitish" value that
            determines where the Git tag is created from. Defaults to the
            repository's default branch.
        :param str name: (optional), Name of the release
        :param str body: (optional), Description of the release
        :param boolean draft: (optional), True => Release is a draft
        :param boolean prerelease: (optional), True => Release is a prerelease
        :returns: True if successful; False if not successful
        """
        url = self._api
        data = {
            'tag_name': tag_name,
            'target_commitish': target_commitish,
            'name': name,
            'body': body,
            'draft': draft,
            'prerelease': prerelease,
        }
        self._remove_none(data)

        r = self._session.patch(
            url, data=json.dumps(data), headers=Release.CUSTOM_HEADERS
        )

        successful = self._boolean(r, 200, 404)
        if successful:
            # If the edit was successful, let's update the object.
            self.__init__(r.json(), self)

        return successful

    def iter_assets(self, number=-1, etag=None):
        """Iterate over the assets available for this release.

        :param int number: (optional), Number of assets to return
        :param str etag: (optional), last ETag header sent
        :returns: generator of :class:`Asset <Asset>` objects
        """
        url = self._build_url('assets', base_url=self._api)
        return self._iter(number, url, Asset, etag=etag)

    @requires_auth
    def upload_asset(self, content_type, name, asset):
        """Upload an asset to this release.

        All parameters are required.

        :param str content_type: The content type of the asset. Wikipedia has
            a list of common media types
        :param str name: The name of the file
        :param asset: The file or bytes object to upload.
        :returns: :class:`Asset <Asset>`
        """
        headers = Release.CUSTOM_HEADERS.copy()
        headers.update({'Content-Type': content_type})
        url = self.upload_urlt.expand({'name': name})
        r = self._post(url, data=asset, json=False, headers=headers,
                       verify=False)
        if r.status_code in (201, 202):
            return Asset(r.json(), self)
        raise GitHubError(r)


class Asset(GitHubCore):
    def __init__(self, asset, session=None):
        super(Asset, self).__init__(asset, session)
        self._api = asset.get('url')
        #: Content-Type provided when the asset was created
        self.content_type = asset.get('content_type')
        #: Date the asset was created
        self.created_at = self._strptime(asset.get('created_at'))
        #: Number of times the asset was downloaded
        self.download_count = asset.get('download_count')
        #: URL to download the asset.
        #: Request headers must include ``Accept: application/octet-stream``.
        self.download_url = self._api
        #: GitHub id of the asset
        self.id = asset.get('id')
        #: Short description of the asset
        self.label = asset.get('label')
        #: Name of the asset
        self.name = asset.get('name')
        #: Size of the asset
        self.size = asset.get('size')
        #: State of the asset, e.g., "uploaded"
        self.state = asset.get('state')
        #: Date the asset was updated
        self.updated_at = self._strptime(asset.get('updated_at'))

    def _repr(self):
        return '<Asset [{0}]>'.format(self.name)

    def download(self, path=''):
        """Download the data for this asset.

        :param path: (optional), path where the file should be saved
            to, default is the filename provided in the headers and will be
            written in the current directory.
            it can take a file-like object as well
        :type path: str, file
        :returns: bool -- True if successful, False otherwise
        """
        headers = {
            'Accept': 'application/octet-stream'
            }
        resp = self._get(self._api, allow_redirects=False, stream=True,
                         headers=headers)
        if resp.status_code == 302:
            # Amazon S3 will reject the redirected request unless we omit
            # certain request headers
            headers.update({
                'Authorization': None,
                'Content-Type': None,
                })
            resp = self._get(resp.headers['location'], stream=True,
                             headers=headers)

        if self._boolean(resp, 200, 404):
            stream_response_to_file(resp, path)
            return True
        return False

    def edit(self, name, label=None):
        """Edit this asset.

        :param str name: (required), The file name of the asset
        :param str label: (optional), An alternate description of the asset
        :returns: boolean
        """
        if not name:
            return False
        edit_data = {'name': name, 'label': label}
        self._remove_none(edit_data)
        r = self._patch(
            self._api,
            data=json.dumps(edit_data),
            headers=Release.CUSTOM_HEADERS
        )
        successful = self._boolean(r, 200, 404)
        if successful:
            self.__init__(r.json(), self)

        return successful

########NEW FILE########
__FILENAME__ = repo
# -*- coding: utf-8 -*-
"""
github3.repos.repo
==================

This module contains the Repository object which is used to access the various
parts of GitHub's Repository API.

"""
from __future__ import unicode_literals

from json import dumps
from base64 import b64encode
from github3.decorators import requires_auth
from github3.events import Event
from github3.git import Blob, Commit, Reference, Tag, Tree
from github3.issues import issue_params, Issue
from github3.issues.event import IssueEvent
from github3.issues.label import Label
from github3.issues.milestone import Milestone
from github3.models import GitHubCore
from github3.notifications import Subscription, Thread
from github3.pulls import PullRequest
from github3.repos.branch import Branch
from github3.repos.comment import RepoComment
from github3.repos.commit import RepoCommit
from github3.repos.comparison import Comparison
from github3.repos.contents import Contents, validate_commmitter
from github3.repos.deployment import Deployment
from github3.repos.hook import Hook
from github3.repos.pages import PagesBuild, PagesInfo
from github3.repos.status import Status
from github3.repos.stats import ContributorStats
from github3.repos.release import Release, Asset
from github3.repos.tag import RepoTag
from github3.users import User, Key
from github3.utils import stream_response_to_file, timestamp_parameter
from uritemplate import URITemplate


class Repository(GitHubCore):

    """The :class:`Repository <Repository>` object. It represents how GitHub
    sends information about repositories.

    Two repository instances can be checked like so::

        r1 == r2
        r1 != r2

    And is equivalent to::

        r1.id == r2.id
        r1.id != r2.id

    See also: http://developer.github.com/v3/repos/

    """

    def __init__(self, repo, session=None):
        super(Repository, self).__init__(repo, session)
        #: URL used to clone via HTTPS.
        self.clone_url = repo.get('clone_url', '')
        #: ``datetime`` object representing when the Repository was created.
        self.created_at = self._strptime(repo.get('created_at'))
        #: Description of the repository.
        self.description = repo.get('description', '')

        # The number of forks
        #: The number of forks made of this repository. DEPRECATED
        self.forks = repo.get('forks', 0)

        #: The number of forks of this repository.
        self.fork_count = repo.get('fork_count')

        #: Is this repository a fork?
        self.fork = repo.get('fork')

        #: Full name as login/name
        self.full_name = repo.get('full_name', '')

        # Clone url using git, e.g. git://github.com/sigmavirus24/github3.py
        #: Plain git url for an anonymous clone.
        self.git_url = repo.get('git_url', '')
        #: Whether or not this repository has downloads enabled
        self.has_downloads = repo.get('has_downloads')
        #: Whether or not this repository has an issue tracker
        self.has_issues = repo.get('has_issues')
        #: Whether or not this repository has the wiki enabled
        self.has_wiki = repo.get('has_wiki')

        # e.g. https://sigmavirus24.github.com/github3.py
        #: URL of the home page for the project.
        self.homepage = repo.get('homepage', '')

        # e.g. https://github.com/sigmavirus24/github3.py
        #: URL of the project at GitHub.
        self.html_url = repo.get('html_url', '')
        #: Unique id of the repository.
        self.id = repo.get('id', 0)
        #: Language property.
        self.language = repo.get('language', '')
        #: Mirror property.
        self.mirror_url = repo.get('mirror_url', '')

        # Repository name, e.g. github3.py
        #: Name of the repository.
        self.name = repo.get('name', '')

        #: Number of open issues on the repository. DEPRECATED
        self.open_issues = repo.get('open_issues', 0)

        #: Number of open issues on the repository
        self.open_issues_count = repo.get('open_issues_count')

        # Repository owner's name
        #: :class:`User <github3.users.User>` object representing the
        #: repository owner.
        self.owner = User(repo.get('owner', {}), self._session)

        #: Is this repository private?
        self.private = repo.get('private')
        #: ``datetime`` object representing the last time commits were pushed
        #: to the repository.
        self.pushed_at = self._strptime(repo.get('pushed_at'))
        #: Size of the repository.
        self.size = repo.get('size', 0)

        # The number of stargazers
        #: Number of users who starred the repository
        self.stargazers = repo.get('stargazers_count', 0)

        # SSH url e.g. git@github.com/sigmavirus24/github3.py
        #: URL to clone the repository via SSH.
        self.ssh_url = repo.get('ssh_url', '')
        #: If it exists, url to clone the repository via SVN.
        self.svn_url = repo.get('svn_url', '')
        #: ``datetime`` object representing the last time the repository was
        #: updated.
        self.updated_at = self._strptime(repo.get('updated_at'))
        self._api = repo.get('url', '')

        # The number of watchers
        #: Number of users watching the repository.
        self.watchers = repo.get('watchers', 0)

        #: Parent of this fork, if it exists :class:`Repository`
        self.source = repo.get('source')
        if self.source:
            self.source = Repository(self.source, self)

        #: Parent of this fork, if it exists :class:`Repository`
        self.parent = repo.get('parent')
        if self.parent:
            self.parent = Repository(self.parent, self)

        #: default branch for the repository
        self.default_branch = repo.get('default_branch', '')

        #: master (default) branch for the repository
        self.master_branch = repo.get('master_branch', '')

        #: Teams url (not a template)
        self.teams_url = repo.get('teams_url', '')

        #: Hooks url (not a template)
        self.hooks_url = repo.get('hooks_url', '')

        #: Events url (not a template)
        self.events_url = repo.get('events_url', '')

        #: Tags url (not a template)
        self.tags_url = repo.get('tags_url', '')

        #: Languages url (not a template)
        self.languages_url = repo.get('languages_url', '')

        #: Stargazers url (not a template)
        self.stargazers_url = repo.get('stargazers_url', '')

        #: Contributors url (not a template)
        self.contributors_url = repo.get('contributors_url', '')

        #: Subscribers url (not a template)
        self.subscribers_url = repo.get('subscribers_url', '')

        #: Subscription url (not a template)
        self.subscription_url = repo.get('subscription_url', '')

        #: Merges url (not a template)
        self.merges_url = repo.get('merges_url', '')

        #: Downloads url (not a template)
        self.download_url = repo.get('downloads_url', '')

        ## Template URLS
        ie_url_t = repo.get('issue_events_url')
        #: Issue events URL Template. Expand with ``number``
        self.issue_events_urlt = URITemplate(ie_url_t) if ie_url_t else None

        assignees = repo.get('assignees_url')
        #: Assignees URL Template. Expand with ``user``
        self.assignees_urlt = URITemplate(assignees) if assignees else None

        branches = repo.get('branches_url')
        #: Branches URL Template. Expand with ``branch``
        self.branches_urlt = URITemplate(branches) if branches else None

        blobs = repo.get('blobs_url')
        #: Blobs URL Template. Expand with ``sha``
        self.blobs_urlt = URITemplate(blobs) if blobs else None

        git_tags = repo.get('git_tags_url')
        #: Git tags URL Template. Expand with ``sha``
        self.git_tags_urlt = URITemplate(git_tags) if git_tags else None

        git_refs = repo.get('git_refs_url')
        #: Git refs URL Template. Expand with ``sha``
        self.git_refs_urlt = URITemplate(git_refs) if git_refs else None

        trees = repo.get('trees_url')
        #: Trres URL Template. Expand with ``sha``
        self.trees_urlt = URITemplate(trees) if trees else None

        statuses = repo.get('statuses_url')
        #: Statuses URL Template. Expand with ``sha``
        self.statuses_urlt = URITemplate(statuses) if statuses else None

        commits = repo.get('commits_url')
        #: Commits URL Template. Expand with ``sha``
        self.commits_urlt = URITemplate(commits) if commits else None

        commits = repo.get('git_commits_url')
        #: Git commits URL Template. Expand with ``sha``
        self.git_commits_urlt = URITemplate(commits) if commits else None

        comments = repo.get('comments_url')
        #: Comments URL Template. Expand with ``number``
        self.comments_urlt = URITemplate(comments) if comments else None

        comments = repo.get('issue_comment_url')
        #: Issue comment URL Template. Expand with ``number``
        self.issue_comment_urlt = URITemplate(comments) if comments else None

        contents = repo.get('contents_url')
        #: Contents URL Template. Expand with ``path``
        self.contents_urlt = URITemplate(contents) if contents else None

        compare = repo.get('compare_url')
        #: Comparison URL Template. Expand with ``base`` and ``head``
        self.compare_urlt = URITemplate(compare) if compare else None

        archive = repo.get('archive_url')
        #: Archive URL Template. Expand with ``archive_format`` and ``ref``
        self.archive_urlt = URITemplate(archive) if archive else None

        issues = repo.get('issues_url')
        #: Issues URL Template. Expand with ``number``
        self.issues_urlt = URITemplate(issues) if issues else None

        pulls = repo.get('pulls_url')
        #: Pull Requests URL Template. Expand with ``number``
        self.pulls_urlt = URITemplate(pulls) if issues else None

        miles = repo.get('milestones_url')
        #: Milestones URL Template. Expand with ``number``
        self.milestones_urlt = URITemplate(miles) if miles else None

        notif = repo.get('notifications_url')
        #: Notifications URL Template. Expand with ``since``, ``all``,
        #: ``participating``
        self.notifications_urlt = URITemplate(notif) if notif else None

        labels = repo.get('labels_url')
        #: Labels URL Template. Expand with ``name``
        self.labels_urlt = URITemplate(labels) if labels else None

    def _repr(self):
        return '<Repository [{0}]>'.format(self)

    def __str__(self):
        return self.full_name

    def _update_(self, repo):
        self.__init__(repo, self._session)

    def _create_pull(self, data):
        self._remove_none(data)
        json = None
        if data:
            url = self._build_url('pulls', base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return PullRequest(json, self._session) if json else None

    @requires_auth
    def add_collaborator(self, login):
        """Add ``login`` as a collaborator to a repository.

        :param str login: (required), login of the user
        :returns: bool -- True if successful, False otherwise
        """
        resp = False
        if login:
            url = self._build_url('collaborators', login, base_url=self._api)
            resp = self._boolean(self._put(url), 204, 404)
        return resp

    def archive(self, format, path='', ref='master'):
        """Get the tarball or zipball archive for this repo at ref.

        See: http://developer.github.com/v3/repos/contents/#get-archive-link

        :param str format: (required), accepted values: ('tarball',
            'zipball')
        :param path: (optional), path where the file should be saved
            to, default is the filename provided in the headers and will be
            written in the current directory.
            it can take a file-like object as well
        :type path: str, file
        :param str ref: (optional)
        :returns: bool -- True if successful, False otherwise

        """
        resp = None
        if format in ('tarball', 'zipball'):
            url = self._build_url(format, ref, base_url=self._api)
            resp = self._get(url, allow_redirects=True, stream=True)

        if resp and self._boolean(resp, 200, 404):
            stream_response_to_file(resp, path)
            return True
        return False

    def asset(self, id):
        """Returns a single Asset.

        :param int id: (required), id of the asset
        :returns: :class:`Asset <github3.repos.release.Asset>`
        """
        data = None
        if int(id) > 0:
            url = self._build_url('releases', 'assets', str(id),
                                  base_url=self._api)
            data = self._json(self._get(url, headers=Release.CUSTOM_HEADERS),
                              200)
        return Asset(data, self) if data else None

    def blob(self, sha):
        """Get the blob indicated by ``sha``.

        :param str sha: (required), sha of the blob
        :returns: :class:`Blob <github3.git.Blob>` if successful, otherwise
            None
        """
        url = self._build_url('git', 'blobs', sha, base_url=self._api)
        json = self._json(self._get(url), 200)
        return Blob(json) if json else None

    def branch(self, name):
        """Get the branch ``name`` of this repository.

        :param str name: (required), branch name
        :type name: str
        :returns: :class:`Branch <github3.repos.branch.Branch>`
        """
        json = None
        if name:
            url = self._build_url('branches', name, base_url=self._api)
            json = self._json(self._get(url), 200)
        return Branch(json, self) if json else None

    def commit(self, sha):
        """Get a single (repo) commit. See :func:`git_commit` for the Git Data
        Commit.

        :param str sha: (required), sha of the commit
        :returns: :class:`RepoCommit <github3.repos.commit.RepoCommit>` if
            successful, otherwise None
        """
        url = self._build_url('commits', sha, base_url=self._api)
        json = self._json(self._get(url), 200)
        return RepoCommit(json, self) if json else None

    def commit_comment(self, comment_id):
        """Get a single commit comment.

        :param int comment_id: (required), id of the comment used by GitHub
        :returns: :class:`RepoComment <github3.repos.comment.RepoComment>` if
            successful, otherwise None
        """
        url = self._build_url('comments', str(comment_id), base_url=self._api)
        json = self._json(self._get(url), 200)
        return RepoComment(json, self) if json else None

    def compare_commits(self, base, head):
        """Compare two commits.

        :param str base: (required), base for the comparison
        :param str head: (required), compare this against base
        :returns: :class:`Comparison <github3.repos.comparison.Comparison>` if
            successful, else None
        """
        url = self._build_url('compare', base + '...' + head,
                              base_url=self._api)
        json = self._json(self._get(url), 200)
        return Comparison(json) if json else None

    def contents(self, path, ref=None):
        """Get the contents of the file pointed to by ``path``.

        If the path provided is actually a directory, you will receive a
        dictionary back of the form::

            {
                'filename.md': Contents(),  # Where Contents an instance
                'github.py': Contents(),
            }

        :param str path: (required), path to file, e.g.
            github3/repo.py
        :param str ref: (optional), the string name of a commit/branch/tag.
            Default: master
        :returns: :class:`Contents <github3.repos.contents.Contents>` or dict
            if successful, else None
        """
        url = self._build_url('contents', path, base_url=self._api)
        json = self._json(self._get(url, params={'ref': ref}), 200)
        if isinstance(json, dict):
            return Contents(json, self)
        elif isinstance(json, list):
            return dict((j.get('name'), Contents(j, self)) for j in json)
        return None

    @requires_auth
    def create_blob(self, content, encoding):
        """Create a blob with ``content``.

        :param str content: (required), content of the blob
        :param str encoding: (required), ('base64', 'utf-8')
        :returns: string of the SHA returned
        """
        sha = ''
        if encoding in ('base64', 'utf-8'):
            url = self._build_url('git', 'blobs', base_url=self._api)
            data = {'content': content, 'encoding': encoding}
            json = self._json(self._post(url, data=data), 201)
            if json:
                sha = json.get('sha')
        return sha

    @requires_auth
    def create_comment(self, body, sha, path=None, position=None, line=1):
        """Create a comment on a commit.

        :param str body: (required), body of the message
        :param str sha: (required), commit id
        :param str path: (optional), relative path of the file to comment
            on
        :param str position: (optional), line index in the diff to comment on
        :param int line: (optional), line number of the file to comment on,
            default: 1
        :returns: :class:`RepoComment <github3.repos.comment.RepoComment>` if
            successful, otherwise None

        """
        json = None
        if body and sha and (line and int(line) > 0):
            data = {'body': body, 'line': line, 'path': path,
                    'position': position}
            self._remove_none(data)
            url = self._build_url('commits', sha, 'comments',
                                  base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return RepoComment(json, self) if json else None

    @requires_auth
    def create_commit(self, message, tree, parents, author={}, committer={}):
        """Create a commit on this repository.

        :param str message: (required), commit message
        :param str tree: (required), SHA of the tree object this
            commit points to
        :param list parents: (required), SHAs of the commits that were parents
            of this commit. If empty, the commit will be written as the root
            commit.  Even if there is only one parent, this should be an
            array.
        :param dict author: (optional), if omitted, GitHub will
            use the authenticated user's credentials and the current
            time. Format: {'name': 'Committer Name', 'email':
            'name@example.com', 'date': 'YYYY-MM-DDTHH:MM:SS+HH:00'}
        :param dict committer: (optional), if ommitted, GitHub will use the
            author parameters. Should be the same format as the author
            parameter.
        :returns: :class:`Commit <github3.git.Commit>` if successful, else
            None
        """
        json = None
        if message and tree and isinstance(parents, list):
            url = self._build_url('git', 'commits', base_url=self._api)
            data = {'message': message, 'tree': tree, 'parents': parents,
                    'author': author, 'committer': committer}
            json = self._json(self._post(url, data=data), 201)
        return Commit(json, self) if json else None

    @requires_auth
    def create_deployment(self, ref, force=False, payload='',
                          auto_merge=False, description='', environment=None):
        """Create a deployment.

        :param str ref: (required), The ref to deploy. This can be a branch,
            tag, or sha.
        :param bool force: Optional parameter to bypass any ahead/behind
            checks or commit status checks. Default: False
        :param str payload: Optional JSON payload with extra information about
            the deployment. Default: ""
        :param bool auto_merge: Optional parameter to merge the default branch
            into the requested deployment branch if necessary. Default: False
        :param str description: Optional short description. Default: ""
        :param str environment: Optional name for the target deployment
            environment (e.g., production, staging, qa). Default: "production"
        :returns: :class:`Deployment <github3.repos.deployment.Deployment>`
        """
        json = None
        if ref:
            url = self._build_url('deployments', base_url=self._api)
            data = {'ref': ref, 'force': force, 'payload': payload,
                    'auto_merge': auto_merge, 'description': description,
                    'environment': environment}
            self._remove_none(data)
            headers = Deployment.CUSTOM_HEADERS
            json = self._json(self._post(url, data=data, headers=headers),
                              201)
        return Deployment(json, self) if json else None

    @requires_auth
    def create_file(self, path, message, content, branch=None,
                    committer=None, author=None):
        """Create a file in this repository.

        See also: http://developer.github.com/v3/repos/contents/#create-a-file

        :param str path: (required), path of the file in the repository
        :param str message: (required), commit message
        :param bytes content: (required), the actual data in the file
        :param str branch: (optional), branch to create the commit on.
            Defaults to the default branch of the repository
        :param dict committer: (optional), if no information is given the
            authenticated user's information will be used. You must specify
            both a name and email.
        :param dict author: (optional), if omitted this will be filled in with
            committer information. If passed, you must specify both a name and
            email.
        :returns: {
            'content': :class:`Contents <github3.repos.contents.Contents>`:,
            'commit': :class:`Commit <github3.git.Commit>`}

        """
        if content and not isinstance(content, bytes):
            raise ValueError(  # (No coverage)
                'content must be a bytes object')  # (No coverage)

        json = None
        if path and message and content:
            url = self._build_url('contents', path, base_url=self._api)
            content = b64encode(content).decode('utf-8')
            data = {'message': message, 'content': content, 'branch': branch,
                    'committer': validate_commmitter(committer),
                    'author': validate_commmitter(author)}
            self._remove_none(data)
            json = self._json(self._put(url, data=dumps(data)), 201)
            if 'content' in json and 'commit' in json:
                json['content'] = Contents(json['content'], self)
                json['commit'] = Commit(json['commit'], self)
        return json

    @requires_auth
    def create_fork(self, organization=None):
        """Create a fork of this repository.

        :param str organization: (required), login for organization to create
            the fork under
        :returns: :class:`Repository <Repository>` if successful, else None
        """
        url = self._build_url('forks', base_url=self._api)
        if organization:
            resp = self._post(url, data={'organization': organization})
        else:
            resp = self._post(url)
        json = self._json(resp, 202)

        return Repository(json, self) if json else None

    @requires_auth
    def create_hook(self, name, config, events=['push'], active=True):
        """Create a hook on this repository.

        :param str name: (required), name of the hook
        :param dict config: (required), key-value pairs which act as settings
            for this hook
        :param list events: (optional), events the hook is triggered for
        :param bool active: (optional), whether the hook is actually
            triggered
        :returns: :class:`Hook <github3.repos.hook.Hook>` if successful,
            otherwise None
        """
        json = None
        if name and config and isinstance(config, dict):
            url = self._build_url('hooks', base_url=self._api)
            data = {'name': name, 'config': config, 'events': events,
                    'active': active}
            json = self._json(self._post(url, data=data), 201)
        return Hook(json, self) if json else None

    @requires_auth
    def create_issue(self,
                     title,
                     body=None,
                     assignee=None,
                     milestone=None,
                     labels=None):
        """Creates an issue on this repository.

        :param str title: (required), title of the issue
        :param str body: (optional), body of the issue
        :param str assignee: (optional), login of the user to assign the
            issue to
        :param int milestone: (optional), id number of the milestone to
            attribute this issue to (e.g. ``m`` is a :class:`Milestone
            <github3.issues.milestone.Milestone>` object, ``m.number`` is
            what you pass here.)
        :param labels: (optional), labels to apply to this
            issue
        :type labels: list of strings
        :returns: :class:`Issue <github3.issues.issue.Issue>` if successful,
            otherwise None
        """
        issue = {'title': title, 'body': body, 'assignee': assignee,
                 'milestone': milestone, 'labels': labels}
        self._remove_none(issue)
        json = None

        if issue:
            url = self._build_url('issues', base_url=self._api)
            json = self._json(self._post(url, data=issue), 201)

        return Issue(json, self) if json else None

    @requires_auth
    def create_key(self, title, key):
        """Create a deploy key.

        :param str title: (required), title of key
        :param str key: (required), key text
        :returns: :class:`Key <github3.users.Key>` if successful, else None
        """
        json = None
        if title and key:
            data = {'title': title, 'key': key}
            url = self._build_url('keys', base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return Key(json, self) if json else None

    @requires_auth
    def create_label(self, name, color):
        """Create a label for this repository.

        :param str name: (required), name to give to the label
        :param str color: (required), value of the color to assign to the
            label, e.g., '#fafafa' or 'fafafa' (the latter is what is sent)
        :returns: :class:`Label <github3.issues.label.Label>` if successful,
            else None
        """
        json = None
        if name and color:
            data = {'name': name, 'color': color.strip('#')}
            url = self._build_url('labels', base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return Label(json, self) if json else None

    @requires_auth
    def create_milestone(self, title, state=None, description=None,
                         due_on=None):
        """Create a milestone for this repository.

        :param str title: (required), title of the milestone
        :param str state: (optional), state of the milestone, accepted
            values: ('open', 'closed'), default: 'open'
        :param str description: (optional), description of the milestone
        :param str due_on: (optional), ISO 8601 formatted due date
        :returns: :class:`Milestone <github3.issues.milestone.Milestone>` if
            successful, otherwise None
        """
        url = self._build_url('milestones', base_url=self._api)
        if state not in ('open', 'closed'):
            state = None
        data = {'title': title, 'state': state,
                'description': description, 'due_on': due_on}
        self._remove_none(data)
        json = None
        if data:
            json = self._json(self._post(url, data=data), 201)
        return Milestone(json, self) if json else None

    @requires_auth
    def create_pull(self, title, base, head, body=None):
        """Create a pull request using commits from ``head`` and comparing
        against ``base``.

        :param str title: (required)
        :param str base: (required), e.g., 'username:branch', or a sha
        :param str head: (required), e.g., 'master', or a sha
        :param str body: (optional), markdown formatted description
        :returns: :class:`PullRequest <github3.pulls.PullRequest>` if
            successful, else None
        """
        data = {'title': title, 'body': body, 'base': base,
                'head': head}
        return self._create_pull(data)

    @requires_auth
    def create_pull_from_issue(self, issue, base, head):
        """Create a pull request from issue #``issue``.

        :param int issue: (required), issue number
        :param str base: (required), e.g., 'username:branch', or a sha
        :param str head: (required), e.g., 'master', or a sha
        :returns: :class:`PullRequest <github3.pulls.PullRequest>` if
            successful, else None
        """
        if int(issue) > 0:
            data = {'issue': issue, 'base': base, 'head': head}
            return self._create_pull(data)
        return None

    @requires_auth
    def create_ref(self, ref, sha):
        """Create a reference in this repository.

        :param str ref: (required), fully qualified name of the reference,
            e.g. ``refs/heads/master``. If it doesn't start with ``refs`` and
            contain at least two slashes, GitHub's API will reject it.
        :param str sha: (required), SHA1 value to set the reference to
        :returns: :class:`Reference <github3.git.Reference>` if successful
            else None
        """
        json = None
        if ref and ref.count('/') >= 2 and sha:
            data = {'ref': ref, 'sha': sha}
            url = self._build_url('git', 'refs', base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return Reference(json, self) if json else None

    @requires_auth
    def create_release(self, tag_name, target_commitish=None, name=None,
                       body=None, draft=False, prerelease=False):
        """Create a release for this repository.

        :param str tag_name: (required), name to give to the tag
        :param str target_commitish: (optional), vague concept of a target,
            either a SHA or a branch name.
        :param str name: (optional), name of the release
        :param str body: (optional), description of the release
        :param bool draft: (optional), whether this release is a draft or not
        :param bool prerelease: (optional), whether this is a prerelease or
            not
        :returns: :class:`Release <github3.repos.release.Release>`
        """
        data = {'tag_name': str(tag_name),
                'target_commitish': target_commitish,
                'name': name,
                'body': body,
                'draft': draft,
                'prerelease': prerelease
                }
        self._remove_none(data)

        url = self._build_url('releases', base_url=self._api)
        json = self._json(self._post(
            url, data=data, headers=Release.CUSTOM_HEADERS
            ), 201)
        return Release(json, self)

    @requires_auth
    def create_status(self, sha, state, target_url='', description=''):
        """Create a status object on a commit.

        :param str sha: (required), SHA of the commit to create the status on
        :param str state: (required), state of the test; only the following
            are accepted: 'pending', 'success', 'error', 'failure'
        :param str target_url: (optional), URL to associate with this status.
        :param str description: (optional), short description of the status
        """
        json = {}
        if sha and state:
            data = {'state': state, 'target_url': target_url,
                    'description': description}
            url = self._build_url('statuses', sha, base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return Status(json) if json else None

    @requires_auth
    def create_tag(self, tag, message, sha, obj_type, tagger,
                   lightweight=False):
        """Create a tag in this repository.

        :param str tag: (required), name of the tag
        :param str message: (required), tag message
        :param str sha: (required), SHA of the git object this is tagging
        :param str obj_type: (required), type of object being tagged, e.g.,
            'commit', 'tree', 'blob'
        :param dict tagger: (required), containing the name, email of the
            tagger and the date it was tagged
        :param bool lightweight: (optional), if False, create an annotated
            tag, otherwise create a lightweight tag (a Reference).
        :returns: If lightweight == False: :class:`Tag <github3.git.Tag>` if
            successful, else None. If lightweight == True: :class:`Reference
            <github3.git.Reference>`
        """
        if lightweight and tag and sha:
            return self.create_ref('refs/tags/' + tag, sha)

        json = None
        if tag and message and sha and obj_type and len(tagger) == 3:
            data = {'tag': tag, 'message': message, 'object': sha,
                    'type': obj_type, 'tagger': tagger}
            url = self._build_url('git', 'tags', base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
            if json:
                self.create_ref('refs/tags/' + tag, sha)
        return Tag(json) if json else None

    @requires_auth
    def create_tree(self, tree, base_tree=''):
        """Create a tree on this repository.

        :param list tree: (required), specifies the tree structure.
            Format: [{'path': 'path/file', 'mode':
            'filemode', 'type': 'blob or tree', 'sha': '44bfc6d...'}]
        :param str base_tree: (optional), SHA1 of the tree you want
            to update with new data
        :returns: :class:`Tree <github3.git.Tree>` if successful, else None
        """
        json = None
        if tree and isinstance(tree, list):
            data = {'tree': tree, 'base_tree': base_tree}
            url = self._build_url('git', 'trees', base_url=self._api)
            json = self._json(self._post(url, data=data), 201)
        return Tree(json) if json else None

    @requires_auth
    def delete(self):
        """Delete this repository.

        :returns: bool -- True if successful, False otherwise
        """
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def delete_file(self, path, message, sha, branch=None, committer=None,
                    author=None):
        """Delete the file located at ``path``.

        This is part of the Contents CrUD (Create Update Delete) API. See
        http://developer.github.com/v3/repos/contents/#delete-a-file for more
        information.

        :param str path: (required), path to the file being removed
        :param str message: (required), commit message for the deletion
        :param str sha: (required), blob sha of the file being removed
        :param str branch: (optional), if not provided, uses the repository's
            default branch
        :param dict committer: (optional), if no information is given the
            authenticated user's information will be used. You must specify
            both a name and email.
        :param dict author: (optional), if omitted this will be filled in with
            committer information. If passed, you must specify both a name and
            email.
        :returns: :class:`Commit <github3.git.Commit>` if successful

        """
        json = None
        if path and message and sha:
            url = self._build_url('contents', path, base_url=self._api)
            data = {'message': message, 'sha': sha, 'branch': branch,
                    'committer': validate_commmitter(committer),
                    'author': validate_commmitter(author)}
            self._remove_none(data)
            json = self._json(self._delete(url, data=dumps(data)), 200)
            if json and 'commit' in json:
                json = Commit(json['commit'])
        return json

    @requires_auth
    def delete_key(self, key_id):
        """Delete the key with the specified id from your deploy keys list.

        :returns: bool -- True if successful, False otherwise
        """
        if int(key_id) <= 0:
            return False
        url = self._build_url('keys', str(key_id), base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

    @requires_auth
    def delete_subscription(self):
        """Delete the user's subscription to this repository.

        :returns: bool
        """
        url = self._build_url('subscription', base_url=self._api)
        return self._boolean(self._delete(url), 204, 404)

    @requires_auth
    def edit(self,
             name,
             description=None,
             homepage=None,
             private=None,
             has_issues=None,
             has_wiki=None,
             has_downloads=None,
             default_branch=None):
        """Edit this repository.

        :param str name: (required), name of the repository
        :param str description: (optional), If not ``None``, change the
            description for this repository. API default: ``None`` - leave
            value unchanged.
        :param str homepage: (optional), If not ``None``, change the homepage
            for this repository. API default: ``None`` - leave value unchanged.
        :param bool private: (optional), If ``True``, make the repository
            private. If ``False``, make the repository public. API default:
            ``None`` - leave value unchanged.
        :param bool has_issues: (optional), If ``True``, enable issues for
            this repository. If ``False``, disable issues for this repository.
            API default: ``None`` - leave value unchanged.
        :param bool has_wiki: (optional), If ``True``, enable the wiki for
            this repository. If ``False``, disable the wiki for this
            repository. API default: ``None`` - leave value unchanged.
        :param bool has_downloads: (optional), If ``True``, enable downloads
            for this repository. If ``False``, disable downloads for this
            repository. API default: ``None`` - leave value unchanged.
        :param str default_branch: (optional), If not ``None``, change the
            default branch for this repository. API default: ``None`` - leave
            value unchanged.
        :returns: bool -- True if successful, False otherwise
        """
        edit = {'name': name, 'description': description, 'homepage': homepage,
                'private': private, 'has_issues': has_issues,
                'has_wiki': has_wiki, 'has_downloads': has_downloads,
                'default_branch': default_branch}
        self._remove_none(edit)
        json = None
        if edit:
            json = self._json(self._patch(self._api, data=dumps(edit)), 200)
            self._update_(json)
            return True
        return False

    def is_collaborator(self, login):
        """Check to see if ``login`` is a collaborator on this repository.

        :param str login: (required), login for the user
        :returns: bool -- True if successful, False otherwise
        """
        if login:
            url = self._build_url('collaborators', login, base_url=self._api)
            return self._boolean(self._get(url), 204, 404)
        return False

    def git_commit(self, sha):
        """Get a single (git) commit.

        :param str sha: (required), sha of the commit
        :returns: :class:`Commit <github3.git.Commit>` if successful,
            otherwise None
        """
        json = {}
        if sha:
            url = self._build_url('git', 'commits', sha, base_url=self._api)
            json = self._json(self._get(url), 200)
        return Commit(json, self) if json else None

    @requires_auth
    def hook(self, id_num):
        """Get a single hook.

        :param int id_num: (required), id of the hook
        :returns: :class:`Hook <github3.repos.hook.Hook>` if successful,
            otherwise None
        """
        json = None
        if int(id_num) > 0:
            url = self._build_url('hooks', str(id_num), base_url=self._api)
            json = self._json(self._get(url), 200)
        return Hook(json, self) if json else None

    def is_assignee(self, login):
        """Check if the user is a possible assignee for an issue on this
        repository.

        :returns: :class:`bool`
        """
        if not login:
            return False
        url = self._build_url('assignees', login, base_url=self._api)
        return self._boolean(self._get(url), 204, 404)

    def issue(self, number):
        """Get the issue specified by ``number``.

        :param int number: (required), number of the issue on this repository
        :returns: :class:`Issue <github3.issues.issue.Issue>` if successful,
            otherwise None
        """
        json = None
        if int(number) > 0:
            url = self._build_url('issues', str(number), base_url=self._api)
            json = self._json(self._get(url), 200)
        return Issue(json, self) if json else None

    @requires_auth
    def key(self, id_num):
        """Get the specified deploy key.

        :param int id_num: (required), id of the key
        :returns: :class:`Key <github3.users.Key>` if successful, else None
        """
        json = None
        if int(id_num) > 0:
            url = self._build_url('keys', str(id_num), base_url=self._api)
            json = self._json(self._get(url), 200)
        return Key(json, self) if json else None

    def label(self, name):
        """Get the label specified by ``name``

        :param str name: (required), name of the label
        :returns: :class:`Label <github3.issues.label.Label>` if successful,
            else None
        """
        json = None
        if name:
            url = self._build_url('labels', name, base_url=self._api)
            json = self._json(self._get(url), 200)
        return Label(json, self) if json else None

    @requires_auth
    def latest_pages_build(self):
        """Get the build information for the most recent Pages build.

        :returns: :class:`PagesBuild <github3.repos.pages.PagesBuild>`
        """
        url = self._build_url('pages', 'builds', 'latest', base_url=self._api)
        json = self._json(self._get(url), 200)
        return PagesBuild(json) if json else None

    def iter_assignees(self, number=-1, etag=None):
        """Iterate over all available assignees to which an issue may be
        assigned.

        :param int number: (optional), number of assignees to return. Default:
            -1 returns all available assignees
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('assignees', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_branches(self, number=-1, etag=None):
        """Iterate over the branches in this repository.

        :param int number: (optional), number of branches to return. Default:
            -1 returns all branches
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`Branch <github3.repos.branch.Branch>`\ es
        """
        url = self._build_url('branches', base_url=self._api)
        return self._iter(int(number), url, Branch, etag=etag)

    def iter_code_frequency(self, number=-1, etag=None):
        """Iterate over the code frequency per week.

        Returns a weekly aggregate of the number of additions and deletions
        pushed to this repository.

        :param int number: (optional), number of weeks to return. Default: -1
            returns all weeks
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of lists ``[seconds_from_epoch, additions,
            deletions]``

        .. note:: All statistics methods may return a 202. On those occasions,
                  you will not receive any objects. You should store your
                  iterator and check the new ``last_status`` attribute. If it
                  is a 202 you should wait before re-requesting.

        .. versionadded:: 0.7

        """
        url = self._build_url('stats', 'code_frequency', base_url=self._api)
        return self._iter(int(number), url, list, etag=etag)

    def iter_collaborators(self, number=-1, etag=None):
        """Iterate over the collaborators of this repository.

        :param int number: (optional), number of collaborators to return.
            Default: -1 returns all comments
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('collaborators', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_comments(self, number=-1, etag=None):
        """Iterate over comments on all commits in the repository.

        :param int number: (optional), number of comments to return. Default:
            -1 returns all comments
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`RepoComment <github3.repos.comment.RepoComment>`\ s
        """
        url = self._build_url('comments', base_url=self._api)
        return self._iter(int(number), url, RepoComment, etag=etag)

    def iter_comments_on_commit(self, sha, number=1, etag=None):
        """Iterate over comments for a single commit.

        :param sha: (required), sha of the commit to list comments on
        :type sha: str
        :param int number: (optional), number of comments to return. Default:
            -1 returns all comments
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`RepoComment <github3.repos.comment.RepoComment>`\ s
        """
        url = self._build_url('commits', sha, 'comments', base_url=self._api)
        return self._iter(int(number), url, RepoComment, etag=etag)

    def iter_commit_activity(self, number=-1, etag=None):
        """Iterate over last year of commit activity by week.

        See: http://developer.github.com/v3/repos/statistics/

        :param int number: (optional), number of weeks to return. Default -1
            will return all of the weeks.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of dictionaries

        .. note:: All statistics methods may return a 202. On those occasions,
                  you will not receive any objects. You should store your
                  iterator and check the new ``last_status`` attribute. If it
                  is a 202 you should wait before re-requesting.

        .. versionadded:: 0.7

        """
        url = self._build_url('stats', 'commit_activity', base_url=self._api)
        return self._iter(int(number), url, dict, etag=etag)

    def iter_commits(self, sha=None, path=None, author=None, number=-1,
                     etag=None, since=None, until=None):
        """Iterate over commits in this repository.

        :param str sha: (optional), sha or branch to start listing commits
            from
        :param str path: (optional), commits containing this path will be
            listed
        :param str author: (optional), GitHub login, real name, or email to
            filter commits by (using commit author)
        :param int number: (optional), number of comments to return. Default:
            -1 returns all comments
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :param since: (optional), Only commits after this date will
            be returned. This can be a `datetime` or an `ISO8601` formatted
            date string.
        :type since: datetime or string
        :param until: (optional), Only commits before this date will
            be returned. This can be a `datetime` or an `ISO8601` formatted
            date string.
        :type until: datetime or string

        :returns: generator of
            :class:`RepoCommit <github3.repos.commit.RepoCommit>`\ s
        """
        params = {'sha': sha, 'path': path, 'author': author,
                  'since': timestamp_parameter(since),
                  'until': timestamp_parameter(until)}

        self._remove_none(params)
        url = self._build_url('commits', base_url=self._api)
        return self._iter(int(number), url, RepoCommit, params, etag)

    def iter_contributors(self, anon=False, number=-1, etag=None):
        """Iterate over the contributors to this repository.

        :param bool anon: (optional), True lists anonymous contributors as
            well
        :param int number: (optional), number of contributors to return.
            Default: -1 returns all contributors
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('contributors', base_url=self._api)
        params = {}
        if anon:
            params = {'anon': True}
        return self._iter(int(number), url, User, params, etag)

    def iter_contributor_statistics(self, number=-1, etag=None):
        """Iterate over the contributors list.

        See also: http://developer.github.com/v3/repos/statistics/

        :param int number: (optional), number of weeks to return. Default -1
            will return all of the weeks.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`ContributorStats <github3.repos.stats.ContributorStats>`

        .. note:: All statistics methods may return a 202. On those occasions,
                  you will not receive any objects. You should store your
                  iterator and check the new ``last_status`` attribute. If it
                  is a 202 you should wait before re-requesting.

        .. versionadded:: 0.7

        """
        url = self._build_url('stats', 'contributors', base_url=self._api)
        return self._iter(int(number), url, ContributorStats, etag=etag)

    def iter_deployments(self, number=-1, etag=None):
        """Iterate over deployments for this repository.

        :param int number: (optional), number of deployments to return.
            Default: -1, returns all available deployments
        :param str etag: (optional), ETag from a previous request for all
            deployments
        :returns: generator of
            :class:`Deployment <github3.repos.deployment.Deployment>`\ s
        """
        url = self._build_url('deployments', base_url=self._api)
        i = self._iter(int(number), url, Deployment, etag=etag)
        i.headers.update(Deployment.CUSTOM_HEADERS)
        return i

    def iter_events(self, number=-1, etag=None):
        """Iterate over events on this repository.

        :param int number: (optional), number of events to return. Default: -1
            returns all available events
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Event <github3.events.Event>`\ s
        """
        url = self._build_url('events', base_url=self._api)
        return self._iter(int(number), url, Event, etag=etag)

    def iter_forks(self, sort='', number=-1, etag=None):
        """Iterate over forks of this repository.

        :param str sort: (optional), accepted values:
            ('newest', 'oldest', 'watchers'), API default: 'newest'
        :param int number: (optional), number of forks to return. Default: -1
            returns all forks
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <Repository>`
        """
        url = self._build_url('forks', base_url=self._api)
        params = {}
        if sort in ('newest', 'oldest', 'watchers'):
            params = {'sort': sort}
        return self._iter(int(number), url, Repository, params, etag)

    @requires_auth
    def iter_hooks(self, number=-1, etag=None):
        """Iterate over hooks registered on this repository.

        :param int number: (optional), number of hoks to return. Default: -1
            returns all hooks
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Hook <github3.repos.hook.Hook>`\ s
        """
        url = self._build_url('hooks', base_url=self._api)
        return self._iter(int(number), url, Hook, etag=etag)

    def iter_issues(self,
                    milestone=None,
                    state=None,
                    assignee=None,
                    mentioned=None,
                    labels=None,
                    sort=None,
                    direction=None,
                    since=None,
                    number=-1,
                    etag=None):
        """Iterate over issues on this repo based upon parameters passed.

        .. versionchanged:: 0.9.0

            The ``state`` parameter now accepts 'all' in addition to 'open'
            and 'closed'.

        :param int milestone: (optional), 'none', or '*'
        :param str state: (optional), accepted values: ('all', 'open',
            'closed')
        :param str assignee: (optional), 'none', '*', or login name
        :param str mentioned: (optional), user's login name
        :param str labels: (optional), comma-separated list of labels, e.g.
            'bug,ui,@high'
        :param sort: (optional), accepted values:
            ('created', 'updated', 'comments', 'created')
        :param str direction: (optional), accepted values: ('asc', 'desc')
        :param since: (optional), Only issues after this date will
            be returned. This can be a `datetime` or an `ISO8601` formatted
            date string, e.g., 2012-05-20T23:10:27Z
        :type since: datetime or string
        :param int number: (optional), Number of issues to return.
            By default all issues are returned
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Issue <github3.issues.issue.Issue>`\ s
        """
        url = self._build_url('issues', base_url=self._api)

        params = {'assignee': assignee, 'mentioned': mentioned}
        if milestone in ('*', 'none') or isinstance(milestone, int):
            params['milestone'] = milestone
        self._remove_none(params)
        params.update(
            issue_params(None, state, labels, sort, direction,
                         since)
        )

        return self._iter(int(number), url, Issue, params, etag)

    def iter_issue_events(self, number=-1, etag=None):
        """Iterates over issue events on this repository.

        :param int number: (optional), number of events to return. Default: -1
            returns all available events
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`IssueEvent <github3.issues.event.IssueEvent>`\ s
        """
        url = self._build_url('issues', 'events', base_url=self._api)
        return self._iter(int(number), url, IssueEvent, etag=etag)

    @requires_auth
    def iter_keys(self, number=-1, etag=None):
        """Iterates over deploy keys on this repository.

        :param int number: (optional), number of keys to return. Default: -1
            returns all available keys
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Key <github3.users.Key>`\ s
        """
        url = self._build_url('keys', base_url=self._api)
        return self._iter(int(number), url, Key, etag=etag)

    def iter_labels(self, number=-1, etag=None):
        """Iterates over labels on this repository.

        :param int number: (optional), number of labels to return. Default: -1
            returns all available labels
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Label <github3.issues.label.Label>`\ s
        """
        url = self._build_url('labels', base_url=self._api)
        return self._iter(int(number), url, Label, etag=etag)

    def iter_languages(self, number=-1, etag=None):
        """Iterate over the programming languages used in the repository.

        :param int number: (optional), number of languages to return. Default:
            -1 returns all used languages
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of tuples
        """
        url = self._build_url('languages', base_url=self._api)
        return self._iter(int(number), url, tuple, etag=etag)

    def iter_milestones(self, state=None, sort=None, direction=None,
                        number=-1, etag=None):
        """Iterates over the milestones on this repository.

        :param str state: (optional), state of the milestones, accepted
            values: ('open', 'closed')
        :param str sort: (optional), how to sort the milestones, accepted
            values: ('due_date', 'completeness')
        :param str direction: (optional), direction to sort the milestones,
            accepted values: ('asc', 'desc')
        :param int number: (optional), number of milestones to return.
            Default: -1 returns all milestones
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`Milestone <github3.issues.milestone.Milestone>`\ s
        """
        url = self._build_url('milestones', base_url=self._api)
        accepted = {'state': ('open', 'closed'),
                    'sort': ('due_date', 'completeness'),
                    'direction': ('asc', 'desc')}
        params = {'state': state, 'sort': sort, 'direction': direction}
        for (k, v) in list(params.items()):
            if not (v and (v in accepted[k])):  # e.g., '' or None
                del params[k]
        if not params:
            params = None
        return self._iter(int(number), url, Milestone, params, etag)

    def iter_network_events(self, number=-1, etag=None):
        """Iterates over events on a network of repositories.

        :param int number: (optional), number of events to return. Default: -1
            returns all available events
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Event <github3.events.Event>`\ s
        """
        base = self._api.replace('repos', 'networks', 1)
        url = self._build_url('events', base_url=base)
        return self._iter(int(number), url, Event, etag)

    @requires_auth
    def iter_notifications(self, all=False, participating=False, since=None,
                           number=-1, etag=None):
        """Iterates over the notifications for this repository.

        :param bool all: (optional), show all notifications, including ones
            marked as read
        :param bool participating: (optional), show only the notifications the
            user is participating in directly
        :param since: (optional), filters out any notifications updated
            before the given time. This can be a `datetime` or an `ISO8601`
            formatted date string, e.g., 2012-05-20T23:10:27Z
        :type since: datetime or string
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Thread <github3.notifications.Thread>`
        """
        url = self._build_url('notifications', base_url=self._api)
        params = {
            'all': all,
            'participating': participating,
            'since': timestamp_parameter(since)
        }
        for (k, v) in list(params.items()):
            if not v:
                del params[k]
        return self._iter(int(number), url, Thread, params, etag)

    @requires_auth
    def iter_pages_builds(self, number=-1, etag=None):
        """Iterate over pages builds of this repository.

        :returns: generator of :class:`PagesBuild
            <github3.repos.pages.PagesBuild>`
        """
        url = self._build_url('pages', 'builds', base_url=self._api)
        return self._iter(int(number), url, PagesBuild, etag=etag)

    def iter_pulls(self, state=None, head=None, base=None, sort='created',
                   direction='desc', number=-1, etag=None):
        """List pull requests on repository.

        .. versionchanged:: 0.9.0

            - The ``state`` parameter now accepts 'all' in addition to 'open'
              and 'closed'.

            - The ``sort`` parameter was added.

            - The ``direction`` parameter was added.

        :param str state: (optional), accepted values: ('all', 'open',
            'closed')
        :param str head: (optional), filters pulls by head user and branch
            name in the format ``user:ref-name``, e.g., ``seveas:debian``
        :param str base: (optional), filter pulls by base branch name.
            Example: ``develop``.
        :param str sort: (optional), Sort pull requests by ``created``,
            ``updated``, ``popularity``, ``long-running``. Default: 'created'
        :param str direction: (optional), Choose the direction to list pull
            requests. Accepted values: ('desc', 'asc'). Default: 'desc'
        :param int number: (optional), number of pulls to return. Default: -1
            returns all available pull requests
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`PullRequest <github3.pulls.PullRequest>`\ s
        """
        url = self._build_url('pulls', base_url=self._api)
        params = {}
        if state and state.lower() in ('all', 'open', 'closed'):
            params['state'] = state.lower()
        params.update(head=head, base=base, sort=sort, direction=direction)
        self._remove_none(params)
        return self._iter(int(number), url, PullRequest, params, etag)

    def iter_refs(self, subspace='', number=-1, etag=None):
        """Iterates over references for this repository.

        :param str subspace: (optional), e.g. 'tags', 'stashes', 'notes'
        :param int number: (optional), number of refs to return. Default: -1
            returns all available refs
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Reference <github3.git.Reference>`\ s
        """
        if subspace:
            args = ('git', 'refs', subspace)
        else:
            args = ('git', 'refs')
        url = self._build_url(*args, base_url=self._api)
        return self._iter(int(number), url, Reference, etag=etag)

    def iter_releases(self, number=-1, etag=None):
        """Iterates over releases for this repository.

        :param int number: (optional), number of refs to return. Default: -1
            returns all available refs
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of
            :class:`Release <github3.repos.release.Release>`\ s
        """
        url = self._build_url('releases', base_url=self._api)
        iterator = self._iter(int(number), url, Release, etag=etag)
        iterator.headers.update(Release.CUSTOM_HEADERS)
        return iterator

    def iter_stargazers(self, number=-1, etag=None):
        """List users who have starred this repository.

        :param int number: (optional), number of stargazers to return.
            Default: -1 returns all subscribers available
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`\ s
        """
        url = self._build_url('stargazers', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_subscribers(self, number=-1, etag=None):
        """Iterates over users subscribed to this repository.

        :param int number: (optional), number of subscribers to return.
            Default: -1 returns all subscribers available
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <github3.users.User>`
        """
        url = self._build_url('subscribers', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_statuses(self, sha, number=-1, etag=None):
        """Iterates over the statuses for a specific SHA.

        :param str sha: SHA of the commit to list the statuses of
        :param int number: (optional), return up to number statuses. Default:
            -1 returns all available statuses.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Status <github3.repos.status.Status>`
        """
        url = ''
        if sha:
            url = self._build_url('statuses', sha, base_url=self._api)
        return self._iter(int(number), url, Status, etag=etag)

    def iter_tags(self, number=-1, etag=None):
        """Iterates over tags on this repository.

        :param int number: (optional), return up to at most number tags.
            Default: -1 returns all available tags.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`RepoTag <github3.repos.tag.RepoTag>`\ s
        """
        url = self._build_url('tags', base_url=self._api)
        return self._iter(int(number), url, RepoTag, etag=etag)

    @requires_auth
    def iter_teams(self, number=-1, etag=None):
        """Iterates over teams with access to this repository.

        :param int number: (optional), return up to number Teams. Default: -1
            returns all Teams.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Team <github3.orgs.Team>`\ s
        """
        from github3.orgs import Team
        url = self._build_url('teams', base_url=self._api)
        return self._iter(int(number), url, Team, etag=etag)

    @requires_auth
    def mark_notifications(self, last_read=''):
        """Mark all notifications in this repository as read.

        :param str last_read: (optional), Describes the last point that
            notifications were checked. Anything updated since this time will
            not be updated. Default: Now. Expected in ISO 8601 format:
            ``YYYY-MM-DDTHH:MM:SSZ``. Example: "2012-10-09T23:39:01Z".
        :returns: bool
        """
        url = self._build_url('notifications', base_url=self._api)
        mark = {'read': True}
        if last_read:
            mark['last_read_at'] = last_read
        return self._boolean(self._put(url, data=dumps(mark)),
                             205, 404)

    @requires_auth
    def merge(self, base, head, message=''):
        """Perform a merge from ``head`` into ``base``.

        :param str base: (required), where you're merging into
        :param str head: (required), where you're merging from
        :param str message: (optional), message to be used for the commit
        :returns: :class:`RepoCommit <github3.repos.commit.RepoCommit>`
        """
        url = self._build_url('merges', base_url=self._api)
        data = {'base': base, 'head': head}
        if message:
            data['commit_message'] = message
        json = self._json(self._post(url, data=data), 201)
        return RepoCommit(json, self) if json else None

    def milestone(self, number):
        """Get the milestone indicated by ``number``.

        :param int number: (required), unique id number of the milestone
        :returns: :class:`Milestone <github3.issues.milestone.Milestone>`
        """
        json = None
        if int(number) > 0:
            url = self._build_url('milestones', str(number),
                                  base_url=self._api)
            json = self._json(self._get(url), 200)
        return Milestone(json, self) if json else None

    @requires_auth
    def pages(self):
        """Get information about this repository's pages site.

        :returns: :class:`PagesInfo <github3.repos.pages.PagesInfo>`
        """
        url = self._build_url('pages', base_url=self._api)
        json = self._json(self._get(url), 200)
        return PagesInfo(json) if json else None

    def pull_request(self, number):
        """Get the pull request indicated by ``number``.

        :param int number: (required), number of the pull request.
        :returns: :class:`PullRequest <github3.pulls.PullRequest>`
        """
        json = None
        if int(number) > 0:
            url = self._build_url('pulls', str(number), base_url=self._api)
            json = self._json(self._get(url), 200)
        return PullRequest(json, self) if json else None

    def readme(self):
        """Get the README for this repository.

        :returns: :class:`Contents <github3.repos.contents.Contents>`
        """
        url = self._build_url('readme', base_url=self._api)
        json = self._json(self._get(url), 200)
        return Contents(json, self) if json else None

    def ref(self, ref):
        """Get a reference pointed to by ``ref``.

        The most common will be branches and tags. For a branch, you must
        specify 'heads/branchname' and for a tag, 'tags/tagname'. Essentially,
        the system should return any reference you provide it in the namespace,
        including notes and stashes (provided they exist on the server).

        :param str ref: (required)
        :returns: :class:`Reference <github3.git.Reference>`
        """
        json = None
        if ref:
            url = self._build_url('git', 'refs', ref, base_url=self._api)
            json = self._json(self._get(url), 200)
        return Reference(json, self) if json else None

    def release(self, id):
        """Get a single release.

        :param int id: (required), id of release
        :returns: :class:`Release <github3.repos.release.Release>`
        """
        json = None
        if int(id) > 0:
            url = self._build_url('releases', str(id), base_url=self._api)
            json = self._json(self._get(url), 200)
        return Release(json, self) if json else None

    @requires_auth
    def remove_collaborator(self, login):
        """Remove collaborator ``login`` from the repository.

        :param str login: (required), login name of the collaborator
        :returns: bool
        """
        resp = False
        if login:
            url = self._build_url('collaborators', login, base_url=self._api)
            resp = self._boolean(self._delete(url), 204, 404)
        return resp

    @requires_auth
    def set_subscription(self, subscribed, ignored):
        """Set the user's subscription for this repository

        :param bool subscribed: (required), determines if notifications should
            be received from this repository.
        :param bool ignored: (required), determines if notifications should be
            ignored from this repository.
        :returns: :class:`Subscription <github3.notifications.Subscription>`
        """
        sub = {'subscribed': subscribed, 'ignored': ignored}
        url = self._build_url('subscription', base_url=self._api)
        json = self._json(self._put(url, data=dumps(sub)), 200)
        return Subscription(json, self) if json else None

    @requires_auth
    def subscription(self):
        """Return subscription for this Repository.

        :returns: :class:`Subscription <github3.notifications.Subscription>`
        """
        url = self._build_url('subscription', base_url=self._api)
        json = self._json(self._get(url), 200)
        return Subscription(json, self) if json else None

    def tag(self, sha):
        """Get an annotated tag.

        http://learn.github.com/p/tagging.html

        :param str sha: (required), sha of the object for this tag
        :returns: :class:`Tag <github3.git.Tag>`
        """
        json = None
        if sha:
            url = self._build_url('git', 'tags', sha, base_url=self._api)
            json = self._json(self._get(url), 200)
        return Tag(json) if json else None

    def tree(self, sha):
        """Get a tree.

        :param str sha: (required), sha of the object for this tree
        :returns: :class:`Tree <github3.git.Tree>`
        """
        json = None
        if sha:
            url = self._build_url('git', 'trees', sha, base_url=self._api)
            json = self._json(self._get(url), 200)
        return Tree(json, self) if json else None

    @requires_auth
    def update_file(self, path, message, content, sha, branch=None,
                    author=None, committer=None):
        """Update the file ``path`` with ``content``.

        This is part of the Contents CrUD (Create Update Delete) API. See
        http://developer.github.com/v3/repos/contents/#update-a-file for more
        information.

        :param str path: (required), path to the file being updated
        :param str message: (required), commit message
        :param str content: (required), updated contents of the file
        :param str sha: (required), blob sha of the file being updated
        :param str branch: (optional), uses the default branch on the
            repository if not provided.
        :param dict author: (optional), if omitted this will be filled in with
            committer information. If passed, you must specify both a name and
            email.
        :returns: {'commit': :class:`Commit <github3.git.Commit>`,
            'content': :class:`Contents <github3.repos.contents.Contents>`}

        """
        if content and not isinstance(content, bytes):
            raise ValueError(  # (No coverage)
                'content must be a bytes object')  # (No coverage)

        json = None
        if path and message and content and sha:
            url = self._build_url('contents', path, base_url=self._api)
            content = b64encode(content).decode('utf-8')
            data = {'message': message, 'content': content, 'sha': sha,
                    'committer': validate_commmitter(committer),
                    'author': validate_commmitter(author),
                    'branch': branch}
            self._remove_none(data)
            json = self._json(self._put(url, data=dumps(data)), 200)
            if 'content' in json and 'commit' in json:
                json['content'] = Contents(json['content'], self)
                json['commit'] = Commit(json['commit'], self)
        return json

    @requires_auth
    def update_label(self, name, color, new_name=''):
        """Update the label ``name``.

        :param str name: (required), name of the label
        :param str color: (required), color code
        :param str new_name: (optional), new name of the label
        :returns: bool
        """
        label = self.label(name)
        resp = False
        if label:
            upd = label.update
            resp = upd(new_name, color) if new_name else upd(name, color)
        return resp

    def weekly_commit_count(self):
        """Returns the total commit counts.

        The dictionary returned has two entries: ``all`` and ``owner``. Each
        has a fifty-two element long list of commit counts. (Note: ``all``
        includes the owner.) ``d['all'][0]`` will be the oldest week,
        ``d['all'][51]`` will be the most recent.

        :returns: dict

        .. note:: All statistics methods may return a 202. If github3.py
            receives a 202 in this case, it will return an emtpy dictionary.
            You should give the API a moment to compose the data and then re
            -request it via this method.

        ..versionadded:: 0.7

        """
        url = self._build_url('stats', 'participation', base_url=self._api)
        resp = self._get(url)
        if resp.status_code == 202:
            return {}
        json = self._json(resp, 200)
        if json.get('ETag'):
            del json['ETag']
        if json.get('Last-Modified'):
            del json['Last-Modified']
        return json

########NEW FILE########
__FILENAME__ = stats
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from datetime import datetime
from github3.models import GitHubCore
from github3.users import User


def alternate_week(week):
    return {
        'start of week': datetime.fromtimestamp(int(week['w'])),
        'additions': week['a'],
        'deletions': week['d'],
        'commits': week['c'],
    }


class ContributorStats(GitHubCore):

    """This object provides easy access to information returned by the
    statistics section of the API.

    See http://developer.github.com/v3/repos/statistics/ for specifics.

    """

    def __init__(self, stats_object, session=None):
        super(ContributorStats, self).__init__(stats_object, session)
        #: Contributor in particular that this relates to
        self.author = User(stats_object.get('author', {}), session)
        #: Total number of commits authored by ``author``.
        self.total = stats_object.get('total')
        #: List of weekly dictionaries.
        self.weeks = stats_object.get('weeks', [])
        #: Alternative collection of weekly dictionaries
        #: This provides a datetime object and easy to remember keys for each
        #: element in the list. 'w' -> 'start of week', 'a' -> 'Number of additions',
        #: 'd' -> 'Number of deletions', 'c' -> 'Number of commits'
        self.alt_weeks = [alternate_week(w) for w in self.weeks]

    def _repr(self):
        return '<Contributor Statistics [{0}]>'.format(self.author)

########NEW FILE########
__FILENAME__ = status
# -*- coding: utf-8 -*-
"""
github3.repos.status
====================

This module contains the Status object for GitHub's commit status API

"""
from __future__ import unicode_literals

from github3.models import GitHubObject
from github3.users import User


class Status(GitHubObject):
    """The :class:`Status <Status>` object. This represents information from
    the Repo Status API.

    See also: http://developer.github.com/v3/repos/statuses/
    """
    def __init__(self, status):
        super(Status, self).__init__(status)
        #: datetime object representing the creation of the status object
        self.created_at = self._strptime(status.get('created_at'))
        #: :class:`User <github3.users.User>` who created the object
        self.creator = User(status.get('creator'))
        #: Short description of the Status
        self.description = status.get('description')
        #: GitHub ID for the status object
        self.id = status.get('id')
        #: State of the status, e.g., 'success', 'pending', 'failed', 'error'
        self.state = status.get('state')
        #: URL to view more information about the status
        self.target_url = status.get('target_url')
        #: datetime object representing the last time the status was updated
        self.updated_at = self._strptime(status.get('updated_at'))

    def _repr(self):
        return '<Status [{s.id}:{s.state}]>'.format(s=self)

########NEW FILE########
__FILENAME__ = tag
# -*- coding: utf-8 -*-
"""
github3.repos.tag
=================

This module contains the RepoTag object for GitHub's tag API.

"""
from __future__ import unicode_literals

from github3.models import GitHubObject


class RepoTag(GitHubObject):
    """The :class:`RepoTag <RepoTag>` object. This stores the information
    representing a tag that was created on a repository.

    See also: http://developer.github.com/v3/repos/#list-tags
    """
    def __init__(self, tag):
        super(RepoTag, self).__init__(tag)
        #: Name of the tag.
        self.name = tag.get('name')
        #: URL for the GitHub generated zipball associated with the tag.
        self.zipball_url = tag.get('zipball_url')
        #: URL for the GitHub generated tarball associated with the tag.
        self.tarball_url = tag.get('tarball_url')
        #: Dictionary containing the SHA and URL of the commit.
        self.commit = tag.get('commit', {})

    def _repr(self):
        return '<Repository Tag [{0}]>'.format(self)

    def __str__(self):
        return self.name

########NEW FILE########
__FILENAME__ = code
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.repos import Repository


class CodeSearchResult(GitHubCore):
    def __init__(self, data, session=None):
        super(CodeSearchResult, self).__init__(data, session)
        self._api = data.get('url')
        #: Filename the match occurs in
        self.name = data.get('name')
        #: Path in the repository to the file
        self.path = data.get('path')
        #: SHA in which the code can be found
        self.sha = data.get('sha')
        #: URL to the Git blob endpoint
        self.git_url = data.get('git_url')
        #: URL to the HTML view of the blob
        self.html_url = data.get('html_url')
        #: Repository the code snippet belongs to
        self.repository = Repository(data.get('repository', {}), self)
        #: Score of the result
        self.score = data.get('score')
        #: Text matches
        self.text_matches = data.get('text_matches', [])

    def _repr(self):
        return '<CodeSearchResult [{0}]>'.format(self.path)

########NEW FILE########
__FILENAME__ = issue
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.issues import Issue


class IssueSearchResult(GitHubCore):
    def __init__(self, data, session=None):
        super(IssueSearchResult, self).__init__(data, session)
        result = data.copy()
        #: Score of the result
        self.score = result.pop('score')
        #: Text matches
        self.text_matches = result.pop('text_matches', [])
        #: Issue object
        self.issue = Issue(result, self)

    def _repr(self):
        return '<IssueSearchResult [{0}]>'.format(self.issue)

########NEW FILE########
__FILENAME__ = repository
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.repos import Repository


class RepositorySearchResult(GitHubCore):
    def __init__(self, data, session=None):
        super(RepositorySearchResult, self).__init__(data, session)
        result = data.copy()
        #: Score of the result
        self.score = result.pop('score')
        #: Text matches
        self.text_matches = result.pop('text_matches', [])
        #: Repository object
        self.repository = Repository(result, self)

    def _repr(self):
        return '<RepositorySearchResult [{0}]>'.format(self.repository)

########NEW FILE########
__FILENAME__ = user
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from github3.models import GitHubCore
from github3.users import User


class UserSearchResult(GitHubCore):
    def __init__(self, data, session=None):
        super(UserSearchResult, self).__init__(data, session)
        result = data.copy()
        #: Score of this search result
        self.score = result.pop('score')
        #: Text matches
        self.text_matches = result.pop('text_matches', [])
        #: User object matching the search
        self.user = User(result, self)

    def _repr(self):
        return '<UserSearchResult [{0}]>'.format(self.user)

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-
import requests

from collections import Callable
from github3 import __version__
from logging import getLogger
from contextlib import contextmanager

__url_cache__ = {}
__logs__ = getLogger(__package__)


def requires_2fa(response):
    if (response.status_code == 401 and 'X-GitHub-OTP' in response.headers
            and 'required' in response.headers['X-GitHub-OTP']):
        return True
    return False


class GitHubSession(requests.Session):
    def __init__(self):
        super(GitHubSession, self).__init__()
        self.headers.update({
            # Only accept JSON responses
            'Accept': 'application/vnd.github.v3.full+json',
            # Only accept UTF-8 encoded data
            'Accept-Charset': 'utf-8',
            # Always sending JSON
            'Content-Type': "application/json",
            # Set our own custom User-Agent string
            'User-Agent': 'github3.py/{0}'.format(__version__),
            })
        self.base_url = 'https://api.github.com'
        self.two_factor_auth_cb = None

    def basic_auth(self, username, password):
        """Set the Basic Auth credentials on this Session.

        :param str username: Your GitHub username
        :param str password: Your GitHub password
        """
        if not (username and password):
            return

        self.auth = (username, password)

        # Disable token authentication
        self.headers.pop('Authorization', None)

    def build_url(self, *args, **kwargs):
        """Builds a new API url from scratch."""
        parts = [kwargs.get('base_url') or self.base_url]
        parts.extend(args)
        parts = [str(p) for p in parts]
        key = tuple(parts)
        __logs__.info('Building a url from %s', key)
        if not key in __url_cache__:
            __logs__.info('Missed the cache building the url')
            __url_cache__[key] = '/'.join(parts)
        return __url_cache__[key]

    def handle_two_factor_auth(self, args, kwargs):
        headers = kwargs.pop('headers', {})
        headers.update({
            'X-GitHub-OTP': str(self.two_factor_auth_cb())
            })
        kwargs.update(headers=headers)
        return super(GitHubSession, self).request(*args, **kwargs)

    def oauth2_auth(self, client_id, client_secret):
        """Use OAuth2 for authentication.

        It is suggested you install requests-oauthlib to use this.

        :param str client_id: Client ID retrieved from GitHub
        :param str client_secret: Client secret retrieved from GitHub
        """
        raise NotImplementedError('These features are not implemented yet')

    def request(self, *args, **kwargs):
        response = super(GitHubSession, self).request(*args, **kwargs)
        if requires_2fa(response) and self.two_factor_auth_cb:
            # No need to flatten and re-collect the args in
            # handle_two_factor_auth
            new_response = self.handle_two_factor_auth(args, kwargs)
            new_response.history.append(response)
            response = new_response
        return response

    def retrieve_client_credentials(self):
        """Return the client credentials.

        :returns: tuple(client_id, client_secret)
        """
        client_id = self.params.get('client_id')
        client_secret = self.params.get('client_secret')
        return (client_id, client_secret)

    def two_factor_auth_callback(self, callback):
        if not callback:
            return

        if not isinstance(callback, Callable):
            raise ValueError('Your callback should be callable')

        self.two_factor_auth_cb = callback

    def token_auth(self, token):
        """Use an application token for authentication.

        :param str token: Application token retrieved from GitHub's
            /authorizations endpoint
        """
        if not token:
            return

        self.headers.update({
            'Authorization': 'token {0}'.format(token)
            })
        # Unset username/password so we stop sending them
        self.auth = None

    @contextmanager
    def temporary_basic_auth(self, *auth):
        old_basic_auth = self.auth
        old_token_auth = self.headers.get('Authorization')

        self.basic_auth(*auth)
        yield

        self.auth = old_basic_auth
        if old_token_auth:
            self.headers['Authorization'] = old_token_auth

########NEW FILE########
__FILENAME__ = structs
# -*- coding: utf-8 -*-
from collections import Iterator
from github3.models import GitHubCore
from requests.compat import urlparse, urlencode


class GitHubIterator(GitHubCore, Iterator):
    """The :class:`GitHubIterator` class powers all of the iter_* methods."""
    def __init__(self, count, url, cls, session, params=None, etag=None,
                 headers=None):
        GitHubCore.__init__(self, {}, session)
        #: Original number of items requested
        self.original = count
        #: Number of items left in the iterator
        self.count = count
        #: URL the class used to make it's first GET
        self.url = url
        #: Last URL that was requested
        self.last_url = None
        self._api = self.url
        #: Class for constructing an item to return
        self.cls = cls
        #: Parameters of the query string
        self.params = params or {}
        self._remove_none(self.params)
        # We do not set this from the parameter sent. We want this to
        # represent the ETag header returned by GitHub no matter what.
        # If this is not None, then it won't be set from the response and
        # that's not what we want.
        #: The ETag Header value returned by GitHub
        self.etag = None
        #: Headers generated for the GET request
        self.headers = headers or {}
        #: The last response seen
        self.last_response = None
        #: Last status code received
        self.last_status = 0

        if etag:
            self.headers.update({'If-None-Match': etag})

        self.path = urlparse(self.url).path

    def _repr(self):
        return '<GitHubIterator [{0}, {1}]>'.format(self.count, self.path)

    def __iter__(self):
        self.last_url, params, cls = self.url, self.params, self.cls
        headers = self.headers

        if 0 < self.count <= 100 and self.count != -1:
            params['per_page'] = self.count

        if 'per_page' not in params and self.count == -1:
            params['per_page'] = 100

        while (self.count == -1 or self.count > 0) and self.last_url:
            response = self._get(self.last_url, params=params,
                                 headers=headers)
            self.last_response = response
            self.last_status = response.status_code
            if params:
                params = None  # rel_next already has the params

            if not self.etag and response.headers.get('ETag'):
                self.etag = response.headers.get('ETag')

            json = self._get_json(response)

            if json is None:
                break

            # languages returns a single dict. We want the items.
            if isinstance(json, dict):
                if json.get('ETag'):
                    del json['ETag']
                if json.get('Last-Modified'):
                    del json['Last-Modified']
                json = json.items()

            for i in json:
                yield cls(i, self) if issubclass(cls, GitHubCore) else cls(i)
                self.count -= 1 if self.count > 0 else 0
                if self.count == 0:
                    break

            rel_next = response.links.get('next', {})
            self.last_url = rel_next.get('url', '')

    def __next__(self):
        if not hasattr(self, '__i__'):
            self.__i__ = self.__iter__()
        return next(self.__i__)

    def _get_json(self, response):
        return self._json(response, 200)

    def refresh(self, conditional=False):
        self.count = self.original
        if conditional:
            self.headers['If-None-Match'] = self.etag
        self.etag = None
        self.__i__ = self.__iter__()
        return self

    def next(self):
        return self.__next__()


class SearchIterator(GitHubIterator):

    """This is a special-cased class for returning iterable search results.

    It inherits from :class:`GitHubIterator <github3.structs.GitHubIterator>`.
    All members and methods documented here are unique to instances of this
    class. For other members and methods, check its parent class.

    """

    def __init__(self, count, url, cls, session, params=None, etag=None,
                 headers=None):
        super(SearchIterator, self).__init__(count, url, cls, session, params,
                                             etag, headers)
        #: Total count returned by GitHub
        self.total_count = 0
        #: Items array returned in the last request
        self.items = []

    def _repr(self):
        return '<SearchIterator [{0}, {1}?{2}]>'.format(self.count, self.path,
                                                        urlencode(self.params))

    def _get_json(self, response):
        json = self._json(response, 200)
        # I'm not sure if another page will retain the total_count attribute,
        # so if it's not in the response, just set it back to what it used to
        # be
        self.total_count = json.get('total_count', self.total_count)
        self.items = json.get('items', [])
        # If we return None then it will short-circuit the while loop.
        return json.get('items')

########NEW FILE########
__FILENAME__ = users
# -*- coding: utf-8 -*-
"""
github3.users
=============

This module contains everything relating to Users.

"""
from __future__ import unicode_literals

from json import dumps
from uritemplate import URITemplate
from github3.events import Event
from github3.models import GitHubObject, GitHubCore, BaseAccount
from github3.decorators import requires_auth


class Key(GitHubCore):
    """The :class:`Key <Key>` object. Please see GitHub's `Key Documentation
    <http://developer.github.com/v3/users/keys/>`_ for more information.

    Two key instances can be checked like so::

        k1 == k2
        k1 != k2

    And is equivalent to::

        k1.id == k2.id
        k1.id != k2.id
    """
    def __init__(self, key, session=None):
        super(Key, self).__init__(key, session)
        self._api = key.get('url', '')
        #: The text of the actual key
        self.key = key.get('key')
        #: The unique id of the key at GitHub
        self.id = key.get('id')
        #: The title the user gave to the key
        self.title = key.get('title')

    def _repr(self):
        return '<User Key [{0}]>'.format(self.title)

    def __str__(self):
        return self.key

    def _update_(self, key):
        self.__init__(key, self._session)

    @requires_auth
    def delete(self):
        """Delete this Key"""
        return self._boolean(self._delete(self._api), 204, 404)

    @requires_auth
    def update(self, title, key):
        """Update this key.

        :param str title: (required), title of the key
        :param str key: (required), text of the key file
        :returns: bool
        """
        json = None
        if title and key:
            data = {'title': title, 'key': key}
            json = self._json(self._patch(self._api, data=dumps(data)), 200)
        if json:
            self._update_(json)
            return True
        return False


class Plan(GitHubObject):
    """The :class:`Plan <Plan>` object. This makes interacting with the plan
    information about a user easier. Please see GitHub's `Authenticated User
    <http://developer.github.com/v3/users/#get-the-authenticated-user>`_
    documentation for more specifics.
    """
    def __init__(self, plan):
        super(Plan, self).__init__(plan)
        #: Number of collaborators
        self.collaborators = plan.get('collaborators')
        #: Name of the plan
        self.name = plan.get('name')
        #: Number of private repos
        self.private_repos = plan.get('private_repos')
        #: Space allowed
        self.space = plan.get('space')

    def _repr(self):
        return '<Plan [{0}]>'.format(self.name)  # (No coverage)

    def __str__(self):
        return self.name

    def is_free(self):
        """Checks if this is a free plan.

        :returns: bool
        """
        return self.name == 'free'  # (No coverage)


class User(BaseAccount):

    """The :class:`User <User>` object. This handles and structures information
    in the `User section <http://developer.github.com/v3/users/>`_.

    Two user instances can be checked like so::

        u1 == u2
        u1 != u2

    And is equivalent to::

        u1.id == u2.id
        u1.id != u2.id

    """

    def __init__(self, user, session=None):
        super(User, self).__init__(user, session)
        if not self.type:
            self.type = 'User'

        #: ID of the user's image on Gravatar
        self.gravatar_id = user.get('gravatar_id', '')
        #: True -- for hire, False -- not for hire
        self.hireable = user.get('hireable', False)

        ## The number of public_gists
        #: Number of public gists
        self.public_gists = user.get('public_gists', 0)

        # Private information
        #: How much disk consumed by the user
        self.disk_usage = user.get('disk_usage', 0)

        #: Number of private repos owned by this user
        self.owned_private_repos = user.get('owned_private_repos', 0)
        #: Number of private gists owned by this user
        self.total_private_gists = user.get('total_private_gists', 0)
        #: Total number of private repos
        self.total_private_repos = user.get('total_private_repos', 0)

        #: Which plan this user is on
        self.plan = Plan(user.get('plan', {}))

        events_url = user.get('events_url', '')
        #: Events URL Template. Expands with ``privacy``
        self.events_urlt = URITemplate(events_url) if events_url else None

        #: Followers URL (not a template)
        self.followers_url = user.get('followers_url', '')

        furl = user.get('following_url', '')
        #: Following URL Template. Expands with ``other_user``
        self.following_urlt = URITemplate(furl) if furl else None

        gists_url = user.get('gists_url', '')
        #: Gists URL Template. Expands with ``gist_id``
        self.gists_urlt = URITemplate(gists_url) if gists_url else None

        #: Organizations URL (not a template)
        self.organizations_url = user.get('organizations_url', '')

        #: Received Events URL (not a template)
        self.received_events_url = user.get('received_events_url', '')

        #: Repostories URL (not a template)
        self.repos_url = user.get('repos_url', '')

        starred_url = user.get('starred_url', '')
        #: Starred URL Template. Expands with ``owner`` and ``repo``
        self.starred_urlt = URITemplate(starred_url) if starred_url else None

        #: Subscriptions URL (not a template)
        self.subscriptions_url = user.get('subscriptions_url', '')

        self._uniq = user.get('id', None)

    def __str__(self):
        return self.login

    def _update_(self, user):
        self.__init__(user, self._session)

    @requires_auth
    def add_email_address(self, address):
        """Add the single email address to the authenticated user's
        account.

        :param str address: (required), email address to add
        :returns: list of email addresses
        """
        return self.add_email_addresses([address])

    @requires_auth
    def add_email_addresses(self, addresses=[]):
        """Add the email addresses in ``addresses`` to the authenticated
        user's account.

        :param list addresses: (optional), email addresses to be added
        :returns: list of email addresses
        """
        json = []
        if addresses:
            url = self._build_url('user', 'emails')
            json = self._json(self._post(url, data=addresses), 201)
        return json

    @requires_auth
    def delete_email_address(self, address):
        """Delete the email address from the user's account.

        :param str address: (required), email address to delete
        :returns: bool
        """
        return self.delete_email_addresses([address])

    @requires_auth
    def delete_email_addresses(self, addresses=[]):
        """Delete the email addresses in ``addresses`` from the
        authenticated user's account.

        :param list addresses: (optional), email addresses to be removed
        :returns: bool
        """
        url = self._build_url('user', 'emails')
        return self._boolean(self._delete(url, data=dumps(addresses)),
                             204, 404)

    def is_assignee_on(self, login, repository):
        """Checks if this user can be assigned to issues on login/repository.

        :returns: :class:`bool`
        """
        url = self._build_url('repos', login, repository, 'assignees',
                              self.login)
        return self._boolean(self._get(url), 204, 404)

    def is_following(self, login):
        """Checks if this user is following ``login``.

        :param str login: (required)
        :returns: bool

        """
        url = self.following_urlt.expand(other_user=login)
        return self._boolean(self._get(url), 204, 404)

    def iter_events(self, public=False, number=-1, etag=None):
        """Iterate over events performed by this user.

        :param bool public: (optional), only list public events for the
            authenticated user
        :param int number: (optional), number of events to return. Default: -1
            returns all available events.
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: list of :class:`Event <github3.events.Event>`\ s
        """
        path = ['events']
        if public:
            path.append('public')
        url = self._build_url(*path, base_url=self._api)
        return self._iter(int(number), url, Event, etag=etag)

    def iter_followers(self, number=-1, etag=None):
        """Iterate over the followers of this user.

        :param int number: (optional), number of followers to return. Default:
            -1 returns all available
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <User>`\ s
        """
        url = self._build_url('followers', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_following(self, number=-1, etag=None):
        """Iterate over the users being followed by this user.

        :param int number: (optional), number of users to return. Default: -1
            returns all available users
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`User <User>`\ s
        """
        url = self._build_url('following', base_url=self._api)
        return self._iter(int(number), url, User, etag=etag)

    def iter_keys(self, number=-1, etag=None):
        """Iterate over the public keys of this user.

        .. versionadded:: 0.5

        :param int number: (optional), number of keys to return. Default: -1
            returns all available keys
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Key <Key>`\ s
        """
        url = self._build_url('keys', base_url=self._api)
        return self._iter(int(number), url, Key, etag=etag)

    def iter_org_events(self, org, number=-1, etag=None):
        """Iterate over events as they appear on the user's organization
        dashboard. You must be authenticated to view this.

        :param str org: (required), name of the organization
        :param int number: (optional), number of events to return. Default: -1
            returns all available events
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: list of :class:`Event <github3.events.Event>`\ s
        """
        url = ''
        if org:
            url = self._build_url('events', 'orgs', org, base_url=self._api)
        return self._iter(int(number), url, Event, etag=etag)

    def iter_received_events(self, public=False, number=-1, etag=None):
        """Iterate over events that the user has received. If the user is the
        authenticated user, you will see private and public events, otherwise
        you will only see public events.

        :param bool public: (optional), determines if the authenticated user
            sees both private and public or just public
        :param int number: (optional), number of events to return. Default: -1
            returns all events available
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Event <github3.events.Event>`\ s
        """
        path = ['received_events']
        if public:
            path.append('public')
        url = self._build_url(*path, base_url=self._api)
        return self._iter(int(number), url, Event, etag=etag)

    def iter_orgs(self, number=-1, etag=None):
        """Iterate over organizations the user is member of

        :param int number: (optional), number of organizations to return.
            Default: -1 returns all available organization
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: list of :class:`Event <github3.orgs.Organization>`\ s
        """
        # Import here, because a toplevel import causes an import loop
        from github3.orgs import Organization
        url = self._build_url('orgs', base_url=self._api)
        return self._iter(int(number), url, Organization, etag=etag)

    def iter_starred(self, sort=None, direction=None, number=-1, etag=None):
        """Iterate over repositories starred by this user.

        .. versionchanged:: 0.5
           Added sort and direction parameters (optional) as per the change in
           GitHub's API.

        :param int number: (optional), number of starred repos to return.
            Default: -1, returns all available repos
        :param str sort: (optional), either 'created' (when the star was
            created) or 'updated' (when the repository was last pushed to)
        :param str direction: (optional), either 'asc' or 'desc'. Default:
            'desc'
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
        """
        from github3.repos import Repository

        params = {'sort': sort, 'direction': direction}
        self._remove_none(params)
        url = self.starred_urlt.expand(owner=None, repo=None)
        return self._iter(int(number), url, Repository, params, etag)

    def iter_subscriptions(self, number=-1, etag=None):
        """Iterate over repositories subscribed to by this user.

        :param int number: (optional), number of subscriptions to return.
            Default: -1, returns all available
        :param str etag: (optional), ETag from a previous request to the same
            endpoint
        :returns: generator of :class:`Repository <github3.repos.Repository>`
        """
        from github3.repos import Repository
        url = self._build_url('subscriptions', base_url=self._api)
        return self._iter(int(number), url, Repository, etag=etag)

    @requires_auth
    def update(self, name=None, email=None, blog=None, company=None,
               location=None, hireable=False, bio=None):
        """If authenticated as this user, update the information with
        the information provided in the parameters.

        :param str name: e.g., 'John Smith', not login name
        :param str email: e.g., 'john.smith@example.com'
        :param str blog: e.g., 'http://www.example.com/jsmith/blog'
        :param str company:
        :param str location:
        :param bool hireable: defaults to False
        :param str bio: GitHub flavored markdown
        :returns: bool
        """
        user = {'name': name, 'email': email, 'blog': blog,
                'company': company, 'location': location,
                'hireable': hireable, 'bio': bio}
        self._remove_none(user)
        url = self._build_url('user')
        json = self._json(self._patch(url, data=dumps(user)), 200)
        if json:
            self._update_(json)
            return True
        return False

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from collections import Callable
from datetime import datetime, timedelta, tzinfo
from requests.compat import basestring
import re

# with thanks to https://code.google.com/p/jquery-localtime/issues/detail?id=4
ISO_8601 = re.compile("^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[0-1]|0"
                      "[1-9]|[1-2][0-9])(T(2[0-3]|[0-1][0-9]):([0-5][0-9]):([0"
                      "-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[0-1][0-9]):[0-5]["
                      "0-9])?)?$")


def timestamp_parameter(timestamp, allow_none=True):

    if timestamp is None:
        if allow_none:
            return None
        raise ValueError("Timestamp value cannot be None")

    if isinstance(timestamp, datetime):
        return timestamp.isoformat()

    if isinstance(timestamp, basestring):
        if not ISO_8601.match(timestamp):
            raise ValueError(("Invalid timestamp: %s is not a valid ISO-8601"
                              " formatted date") % timestamp)
        return timestamp

    raise ValueError("Cannot accept type %s for timestamp" % type(timestamp))


class UTC(tzinfo):
    """Yet another UTC reimplementation, to avoid a dependency on pytz or
    dateutil."""

    ZERO = timedelta(0)

    def __repr__(self):
        return 'UTC()'

    def dst(self, dt):
        return self.ZERO

    def tzname(self, dt):
        return 'UTC'

    def utcoffset(self, dt):
        return self.ZERO


def stream_response_to_file(response, path=None):
    pre_opened = False
    fd = None
    if path:
        if isinstance(getattr(path, 'write', None), Callable):
            pre_opened = True
            fd = path
        else:
            fd = open(path, 'wb')
    else:
        header = response.headers['content-disposition']
        i = header.find('filename=') + len('filename=')
        fd = open(header[i:], 'wb')

    for chunk in response.iter_content(chunk_size=512):
        fd.write(chunk)

    if not pre_opened:
        fd.close()

########NEW FILE########
__FILENAME__ = report_issue
#!/usr/bin/env python
import sys
import os
from github3 import login
from getpass import getpass

try:
    import readline
    readline.parse_and_bind('tab: complete')
except ImportError:
    pass

if hasattr(__builtins__, 'raw_input'):
    prompt = raw_input
else:
    prompt = input


def prompt_user(prompt_str):
    val = ''
    while not val:
        val = prompt(prompt_str)
    return val

if len(sys.argv) > 1 and sys.argv[1] in ('-h', '--help', '-?'):
    print("Usage: {0} [-h|-?|--help]".format(sys.argv[0]))
    print("Simple issue reporting script for github3.py\n")
    print("If you're reporting a bug, please save a traceback to a file")
    print("and supply the filename when filing the bug report. Please be")
    print("as descriptive as possible.\n\n")
    print("  -h, -?, --help  Print this message and exit")
    sys.exit(0)

username = ''
password = ''

username = prompt_user('Enter GitHub username: ')

while not password:
    password = getpass('Password for {0}: '.format(username))

g = login(username, password)
repo = g.repository('sigmavirus24', 'github3.py')

title = prompt_user('Title/summary: ')
issue_type = prompt_user('Bug or feature request? ')

traceback = None
if issue_type.lower() == 'bug':
    tb_file = prompt_user('Filename with traceback: ')
    if os.path.isfile(tb_file):
        traceback = open(tb_file).read()

description = prompt_user('Description: ')

body = """**Issue type**: {0}

------

**Traceback**:
```
{1}
```

------

**Description**:
{2}

------

*Generated with github3.py using the report_issue script*
""".format(issue_type, traceback, description)

i = repo.create_issue(title, body)

print(i.html_url)

########NEW FILE########
__FILENAME__ = conftest
import base64
import betamax
import os

credentials = [os.environ.get('GH_USER', 'foo').encode(),
               os.environ.get('GH_PASSWORD', 'bar').encode()]

with betamax.Betamax.configure() as config:
    config.cassette_library_dir = 'tests/cassettes'

    record_mode = 'never' if os.environ.get('TRAVIS_GH3') else 'once'

    config.default_cassette_options['record_mode'] = record_mode

    config.define_cassette_placeholder(
        '<AUTH_TOKEN>',
        os.environ.get('GH_AUTH', 'x' * 20)
        )

    config.define_cassette_placeholder(
        '<BASIC_AUTH>',
        base64.b64encode(b':'.join(credentials)).decode()
        )

########NEW FILE########
__FILENAME__ = fixtures
from io import BytesIO
import os
import sys


def path(name, mode='r'):
    return open('tests/json/{0}'.format(name), mode)


def content(path_name):
    content = path(path_name).read().strip()
    iterable = '[{0}]'.format(content)
    if sys.version_info > (3, 0):
        content = content.encode()
        iterable = iterable.encode()
    return BytesIO(content), BytesIO(iterable)


default = {}
iterable = {}
for file in os.listdir('tests/json/'):
    default[file], iterable[file] = content(file)

########NEW FILE########
__FILENAME__ = helper
import copy
import betamax
import github3
import os
import unittest


class IntegrationHelper(unittest.TestCase):
    def setUp(self):
        self.user = os.environ.get('GH_USER', 'foo')
        self.password = os.environ.get('GH_PASSWORD', 'bar')
        self.token = os.environ.get('GH_AUTH', 'x' * 20)
        self.gh = self.get_client()
        self.session = self.gh._session
        self.recorder = betamax.Betamax(self.session)

    def get_client(self):
        return github3.GitHub()

    def token_login(self):
        self.gh.login(token=self.token)

    def basic_login(self):
        self.gh.login(self.user, self.password)

    def cassette_name(self, method, cls=None):
        class_name = cls or self.described_class
        return '_'.join([class_name, method])

    @property
    def described_class(self):
        class_name = self.__class__.__name__
        return class_name[4:]


class CustomHeadersMatcher(betamax.BaseMatcher):
    name = 'gh3-headers'

    def on_init(self):
        self.headers_matcher = betamax.matchers.HeadersMatcher()

    def match(self, request, recorded_request):
        request = request.copy()
        recorded_request = copy.deepcopy(recorded_request)
        request.headers.pop('User-Agent', None)
        recorded_request['headers'].pop('User-Agent', None)
        request.headers.pop('Accept-Encoding', None)
        recorded_request['headers'].pop('Accept-Encoding', None)
        return self.headers_matcher.match(request, recorded_request)


betamax.Betamax.register_request_matcher(CustomHeadersMatcher)

########NEW FILE########
__FILENAME__ = test_api
import github3

from .helper import IntegrationHelper


class TestAPI(IntegrationHelper):
    def get_client(self):
        return github3.gh

    def test_emojis(self):
        """Test the ability to use the /emojis endpoint"""
        cassette_name = self.cassette_name('emojis', cls='GitHub')
        with self.recorder.use_cassette(cassette_name):
            emojis = self.gh.emojis()

        assert emojis['+1'] is not None

    def test_search_code(self):
        """Test the ability to use the code search endpoint"""
        cassette_name = self.cassette_name('search_code',
                                           cls='GitHub')
        with self.recorder.use_cassette(cassette_name):
            repos = self.gh.search_code(
                'HTTPAdapter in:file language:python'
                ' repo:kennethreitz/requests'
                )
            assert isinstance(next(repos),
                              github3.search.CodeSearchResult)

    def test_search_users(self):
        """Test the ability to use the user search endpoint"""
        cassette_name = self.cassette_name('search_users', cls='GitHub')
        with self.recorder.use_cassette(cassette_name):
            users = self.gh.search_users('tom followers:>1000')
            assert isinstance(next(users),
                              github3.search.UserSearchResult)

    def test_search_issues(self):
        """Test the ability to use the issues search endpoint"""
        cassette_name = self.cassette_name('search_issues',
                                           cls='GitHub')
        with self.recorder.use_cassette(cassette_name):
            issues = self.gh.search_issues('github3 labels:bugs')
            assert isinstance(next(issues),
                              github3.search.IssueSearchResult)

    def test_search_repositories(self):
        """Test the ability to use the repository search endpoint"""
        cassette_name = self.cassette_name('search_repositories',
                                           cls='GitHub')
        with self.recorder.use_cassette(cassette_name):
            repos = self.gh.search_repositories('github3 language:python')
            assert isinstance(next(repos),
                              github3.search.RepositorySearchResult)

########NEW FILE########
__FILENAME__ = test_gists
from .helper import IntegrationHelper

import github3


class TestGist(IntegrationHelper):
    def test_iter_commits(self):
        cassette_name = self.cassette_name('commits')
        with self.recorder.use_cassette(cassette_name,
                                        preserve_exact_body_bytes=True):
            gist = self.gh.gist(1834570)
            assert gist is not None
            for commit in gist.iter_commits():
                assert isinstance(commit, github3.gists.history.GistHistory)

    def test_iter_forks(self):
        cassette_name = self.cassette_name('forks')
        with self.recorder.use_cassette(cassette_name,
                                        preserve_exact_body_bytes=True):
            gist = self.gh.gist(1834570)
            assert gist is not None
            for commit in gist.iter_forks():
                assert isinstance(commit, github3.gists.gist.Gist)

########NEW FILE########
__FILENAME__ = test_github
import github3
import uritemplate

from .helper import IntegrationHelper


SSH_KEY = (
    # Generated for this alone then deleted
    'ssh-rsa '
    'AAAAB3NzaC1yc2EAAAADAQABAAABAQCl4l154T4deeLsMHge0TpwDVd5rlDYVyFFr3PP3ZfW+'
    'RZJAHs2QdwbpfoEWUaJmuYvepo/L8JrglKg1LGm99iR/qRg3Nbr8kVCNK+Tb5bUBO5JarnYIT'
    'hwzhRxamZeyZxbmpYFHW3WozPJDD+FU6qg6ZQf1coSqXcnA3U29FBB3CfHu89hkfVvKvMGJnZ'
    'lFHeAkTuDrirWgzFkm+CXT65W7UhJKZD2IBB+JmY0Wkxbv6ayePoydCKfP+pOZRxSTsAMHRSj'
    'RfERbT59VefKa2tAJd2wMJg04Wclgz/q1rx/T9hVCa1O5K8meJBLUDxP6sapMlMr4RYdi0DRr'
    'qncY0b1'
)


class TestGitHub(IntegrationHelper):
    match_on = ['method', 'uri', 'gh3-headers']

    def test_create_gist(self):
        """Test the ability of a GitHub instance to create a new gist"""
        self.token_login()
        cassette_name = self.cassette_name('create_gist')
        with self.recorder.use_cassette(cassette_name):
            g = self.gh.create_gist(
                'Gist Title', {'filename.py': {'content': '#content'}}
                )

        assert isinstance(g, github3.gists.Gist)
        assert g.files == 1
        assert g.is_public() is True

    def test_create_issue(self):
        """Test the ability of a GitHub instance to create a new issue"""
        self.token_login()
        cassette_name = self.cassette_name('create_issue')
        with self.recorder.use_cassette(cassette_name):
            i = self.gh.create_issue(
                'github3py', 'fork_this', 'Test issue creation',
                "Let's see how well this works with Betamax"
                )

        assert isinstance(i, github3.issues.Issue)
        assert i.title == 'Test issue creation'
        assert i.body == "Let's see how well this works with Betamax"

    def test_create_key(self):
        """Test the ability to create a key and delete it."""
        self.basic_login()
        cassette_name = self.cassette_name('create_delete_key')
        with self.recorder.use_cassette(cassette_name):
            k = self.gh.create_key('Key name', SSH_KEY)
            k.delete()

        assert isinstance(k, github3.users.Key)
        assert k.title == 'Key name'
        assert k.key == SSH_KEY

    def test_emojis(self):
        """Test the ability to retrieve from /emojis"""
        cassette_name = self.cassette_name('emojis')
        with self.recorder.use_cassette(cassette_name):
            emojis = self.gh.emojis()

        assert isinstance(emojis, dict)
        # Asserts that it's a string and looks ilke the URLs we expect to see
        assert emojis['+1'].startswith('https://github')

    def test_feeds(self):
        """Test the ability to retrieve a user's timelime URLs"""
        self.basic_login()
        cassette_name = self.cassette_name('feeds')
        with self.recorder.use_cassette(cassette_name):
            feeds = self.gh.feeds()

        for v in feeds['_links'].values():
            assert isinstance(v['href'], uritemplate.URITemplate)

        # The processing on _links has been tested. Get rid of it.
        del feeds['_links']

        # Test the rest of the response
        for v in feeds.values():
            assert isinstance(v, uritemplate.URITemplate)

    def test_gist(self):
        """Test the ability to retrieve a single gist"""
        cassette_name = self.cassette_name('gist')
        with self.recorder.use_cassette(cassette_name):
            g = self.gh.gist(7160899)

        assert isinstance(g, github3.gists.Gist)

    def test_gitignore_template(self):
        """Test the ability to retrieve a single gitignore template"""
        cassette_name = self.cassette_name('gitignore_template')
        with self.recorder.use_cassette(cassette_name):
            t = self.gh.gitignore_template('Python')

        assert t is not None
        assert t != ''

    def test_non_existent_gitignore_template(self):
        """Test the ability to retrieve a single gitignore template"""
        cassette_name = self.cassette_name('non_existent_gitignore_template')
        with self.recorder.use_cassette(cassette_name):
            t = self.gh.gitignore_template('i_donut_exist')

        assert t is not None
        assert t == ''

    def test_gitignore_templates(self):
        """Test the ability to retrieve a list of gitignore templates"""
        cassette_name = self.cassette_name('gitignore_templates')
        with self.recorder.use_cassette(cassette_name):
            l = self.gh.gitignore_templates()

        assert l != []
        assert isinstance(l, list)

    def test_issue(self):
        """Test the ability to retrieve a single issue"""
        cassette_name = self.cassette_name('issue')
        with self.recorder.use_cassette(cassette_name):
            i = self.gh.issue('sigmavirus24', 'github3.py', 1)

        assert isinstance(i, github3.issues.Issue)

    def test_iter_all_repos(self):
        """Test the ability to iterate over all of the repositories"""
        cassette_name = self.cassette_name('iter_all_repos')
        with self.recorder.use_cassette(cassette_name):
            for r in self.gh.iter_all_repos(number=25):
                assert isinstance(r, github3.repos.repo.Repository)

    def test_iter_all_users(self):
        """Test the ability to iterate over all of the users"""
        cassette_name = self.cassette_name('iter_all_users')
        with self.recorder.use_cassette(cassette_name):
            for u in self.gh.iter_all_users(number=25):
                assert isinstance(u, github3.users.User)

    def test_iter_events(self):
        """Test the ability to iterate over all public events"""
        cassette_name = self.cassette_name('iter_events')
        with self.recorder.use_cassette(cassette_name):
            for e in self.gh.iter_events(number=25):
                assert isinstance(e, github3.events.Event)

    def test_iter_followers(self):
        """Test the ability to iterate over a user's followers"""
        cassette_name = self.cassette_name('iter_followers')
        with self.recorder.use_cassette(cassette_name):
            for u in self.gh.iter_followers('sigmavirus24', number=25):
                assert isinstance(u, github3.users.User)

    def test_iter_user_teams(self):
        """Test the ability to iterate over a user's teams"""
        self.basic_login()
        cassette_name = self.cassette_name('iter_user_teams')
        with self.recorder.use_cassette(cassette_name):
            for t in self.gh.iter_user_teams():
                assert isinstance(t, github3.orgs.Team)

    def test_meta(self):
        """Test the ability to get the CIDR formatted addresses"""
        cassette_name = self.cassette_name('meta')
        with self.recorder.use_cassette(cassette_name):
            m = self.gh.meta()
            assert isinstance(m, dict)

    def test_octocat(self):
        """Test the ability to use the octocat endpoint"""
        cassette_name = self.cassette_name('octocat')
        say = 'github3.py is awesome'
        with self.recorder.use_cassette(cassette_name):
            o = self.gh.octocat()
            assert o is not None
            assert o is not ''
            o = self.gh.octocat(say)
            assert say in o.decode()

    def test_organization(self):
        """Test the ability to retrieve an Organization"""
        cassette_name = self.cassette_name('organization')
        with self.recorder.use_cassette(cassette_name):
            o = self.gh.organization('github3py')

        assert isinstance(o, github3.orgs.Organization)

    def test_pull_request(self):
        """Test the ability to retrieve a Pull Request"""
        cassette_name = self.cassette_name('pull_request')
        with self.recorder.use_cassette(cassette_name):
            p = self.gh.pull_request('sigmavirus24', 'github3.py', 119)

        assert isinstance(p, github3.pulls.PullRequest)

    def test_rate_limit(self):
        cassette_name = self.cassette_name('rate_limit')
        with self.recorder.use_cassette(cassette_name):
            r = self.gh.rate_limit()

        assert isinstance(r, dict)
        assert 'resources' in r

    def test_repository(self):
        """Test the ability to retrieve a Repository"""
        cassette_name = self.cassette_name('repository')
        with self.recorder.use_cassette(cassette_name):
            r = self.gh.repository('sigmavirus24', 'github3.py')

        assert isinstance(r, github3.repos.repo.Repository)

    def test_search_code(self):
        """Test the ability to use the code search endpoint"""
        cassette_name = self.cassette_name('search_code')
        with self.recorder.use_cassette(cassette_name):
            result_iterator = self.gh.search_code(
                'HTTPAdapter in:file language:python'
                ' repo:kennethreitz/requests'
                )
            code_result = next(result_iterator)

        assert isinstance(code_result, github3.search.CodeSearchResult)

    def test_search_code_with_text_match(self):
        """Test the ability to use the code search endpoint"""
        cassette_name = self.cassette_name('search_code_with_text_match')
        with self.recorder.use_cassette(cassette_name,
                                        match_requests_on=self.match_on):
            result_iterator = self.gh.search_code(
                ('HTTPAdapter in:file language:python'
                 ' repo:kennethreitz/requests'),
                text_match=True
                )
            code_result = next(result_iterator)

        assert isinstance(code_result, github3.search.CodeSearchResult)
        assert len(code_result.text_matches) > 0

    def test_search_users(self):
        """Test the ability to use the user search endpoint"""
        cassette_name = self.cassette_name('search_users')
        with self.recorder.use_cassette(cassette_name):
            users = self.gh.search_users('tom followers:>1000')
            assert isinstance(next(users),
                              github3.search.UserSearchResult)

        assert isinstance(users, github3.structs.SearchIterator)

    def test_search_users_with_text_match(self):
        """Test the ability to use the user search endpoint"""
        cassette_name = self.cassette_name('search_users_with_text_match')
        with self.recorder.use_cassette(cassette_name,
                                        match_requests_on=self.match_on):
            users = self.gh.search_users('tom followers:>1000',
                                         text_match=True)
            user_result = next(users)
            assert isinstance(user_result,
                              github3.search.UserSearchResult)

        assert isinstance(users, github3.structs.SearchIterator)
        assert len(user_result.text_matches) > 0

    def test_search_issues(self):
        """Test the ability to use the issues search endpoint"""
        cassette_name = self.cassette_name('search_issues')
        with self.recorder.use_cassette(cassette_name):
            issues = self.gh.search_issues('github3 labels:bugs')
            assert isinstance(next(issues), github3.search.IssueSearchResult)

        assert isinstance(issues, github3.structs.SearchIterator)

    def test_search_repositories(self):
        """Test the ability to use the repository search endpoint"""
        cassette_name = self.cassette_name('search_repositories')
        with self.recorder.use_cassette(cassette_name):
            repos = self.gh.search_repositories('github3 language:python')
            assert isinstance(next(repos),
                              github3.search.RepositorySearchResult)

        assert isinstance(repos, github3.structs.SearchIterator)

    def test_search_repositories_with_text_match(self):
        """Test the ability to use the repository search endpoint"""
        self.token_login()
        cassette_name = self.cassette_name('search_repositories_text_match')
        with self.recorder.use_cassette(cassette_name,
                                        match_requests_on=self.match_on):
            repos = self.gh.search_repositories('github3 language:python',
                                                text_match=True)
            repo_result = next(repos)
            assert isinstance(repo_result,
                              github3.search.RepositorySearchResult)

        assert isinstance(repos, github3.structs.SearchIterator)
        assert len(repo_result.text_matches) > 0

    def test_user(self):
        """Test the ability to retrieve a User"""
        self.token_login()
        cassette_name = self.cassette_name('user')
        with self.recorder.use_cassette(cassette_name):
            s = self.gh.user('sigmavirus24')
            self.basic_login()
            u = self.gh.user()

        assert isinstance(s, github3.users.User)
        assert isinstance(u, github3.users.User)

    def test_zen(self):
        """Test the ability to retrieve tidbits of Zen"""
        cassette_name = self.cassette_name('zen')
        with self.recorder.use_cassette(cassette_name):
            z = self.gh.zen()

        assert z is not None
        assert z != ''

########NEW FILE########
__FILENAME__ = test_github_core
from .helper import IntegrationHelper


class TestGitHubCore(IntegrationHelper):
    def test_ratelimit_remaining(self):
        cassette_name = self.cassette_name('ratelimit_remaining')
        with self.recorder.use_cassette(cassette_name):
            assert self.gh.ratelimit_remaining > 0

########NEW FILE########
__FILENAME__ = test_issue
import github3

from .helper import IntegrationHelper


class TestIssue(IntegrationHelper):
    def test_iter_events(self):
        """Test the ability to iterate over issue events."""
        self.token_login()
        cassette_name = self.cassette_name('iter_events')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            issue = repository.issue(218)
            for event in issue.iter_events():
                assert isinstance(event, github3.issues.event.IssueEvent)
                assert event.issue is None
                assert isinstance(event.actor, github3.users.User)

    def test_iter_labels(self):
        """Test the ability to iterate over issue labels."""
        cassette_name = self.cassette_name('iter_labels')
        with self.recorder.use_cassette(cassette_name):
            issue = self.gh.issue('sigmavirus24', 'github3.py', 187)
            assert issue is not None
            for label in issue.iter_labels():
                assert isinstance(label, github3.issues.label.Label)

########NEW FILE########
__FILENAME__ = test_issues_milestone
import github3

from .helper import IntegrationHelper


class TestMilestone(IntegrationHelper):
    def test_iter_labels(self):
        """Test the ability to iterate over milestone labels."""
        cassette_name = self.cassette_name('iter_labels')
        with self.recorder.use_cassette(cassette_name):
            issue = self.gh.issue('sigmavirus24', 'github3.py', 206)
            milestone = issue.milestone
            assert milestone is not None
            for label in milestone.iter_labels():
                assert isinstance(label, github3.issues.label.Label)

########NEW FILE########
__FILENAME__ = test_repos_deployment
import github3

from .helper import IntegrationHelper


def find(func, iterable):
    return next(iter(filter(func, iterable)))


class TestDeployment(IntegrationHelper):
    def test_create_status(self):
        """
        Test that using a Deployment instance, a user can create a status.
        """
        self.basic_login()
        cassette_name = self.cassette_name('create_status')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            deployment = find(lambda d: d.id == 801,
                              repository.iter_deployments())
            assert deployment is not None
            status = deployment.create_status('success')

        assert isinstance(status, github3.repos.deployment.DeploymentStatus)

    def test_iter_statuses(self):
        """
        Test that using a Deployment instance, a user can retrieve statuses.
        """
        cassette_name = self.cassette_name('statuses')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            deployment = find(lambda d: d.id == 801,
                              repository.iter_deployments())
            assert deployment is not None
            statuses = list(deployment.iter_statuses(5))

        for status in statuses:
            assert isinstance(status,
                              github3.repos.deployment.DeploymentStatus)

########NEW FILE########
__FILENAME__ = test_repos_pages
import github3

from .helper import IntegrationHelper


class TestRepositoryPages(IntegrationHelper):
    def test_latest_pages_build(self):
        """Test the ability to retrieve the latest pages build for a repo."""
        self.basic_login()
        cassette_name = self.cassette_name('latest_pages_build')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            latest_build = repository.latest_pages_build()

        assert isinstance(latest_build, github3.repos.pages.PagesBuild)

    def test_pages(self):
        """
        Test the ability to retrieve information about a repository's pages.
        """
        self.basic_login()
        cassette_name = self.cassette_name('pages')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            pages_info = repository.pages()

        assert isinstance(pages_info, github3.repos.pages.PagesInfo)

    def test_iter_pages_builds(self):
        """Test the ability to list the pages builds."""
        self.basic_login()
        cassette_name = self.cassette_name('pages_builds')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            for build in repository.iter_pages_builds():
                assert isinstance(build, github3.repos.pages.PagesBuild)

########NEW FILE########
__FILENAME__ = test_repos_release
import github3
import os
import tempfile

from .helper import IntegrationHelper


class TestRelease(IntegrationHelper):
    def test_delete(self):
        """Test the ability to delete a release."""
        self.token_login()
        cassette_name = self.cassette_name('delete')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('github3py', 'github3.py')
            release = repository.create_release(
                '0.8.0.pre', 'develop', '0.8.0 fake release',
                'To be deleted'
                )
            assert release is not None
            assert release.delete() is True

    def test_edit(self):
        """Test the ability to edit a release on a repository."""
        self.token_login()
        cassette_name = self.cassette_name('edit')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'charade')
            release = repository.release(85783)
            assert release.edit(body='Test editing a release') is True
            assert release.body == 'Test editing a release'

    def test_iter_assets(self):
        """Test the ability to iterate over the assets of a release."""
        cassette_name = self.cassette_name('iter_assets')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            release = repository.release(76677)
            for asset in release.iter_assets():
                assert isinstance(asset, github3.repos.release.Asset)
            assert asset is not None

    def test_upload_asset(self):
        """Test the ability to upload an asset to a release."""
        self.token_login()
        cassette_name = self.cassette_name('upload_asset')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('github3py', 'github3.py')
            release = repository.create_release(
                '0.8.0.pre', 'develop', '0.8.0 fake release with upload',
                'To be deleted'
                )
            with open(__file__) as fd:
                asset = release.upload_asset(
                    'text/plain', 'test_repos_release.py', fd.read()
                    )
            assert isinstance(asset, github3.repos.release.Asset)
            release.delete()


class TestAsset(IntegrationHelper):
    def test_download(self):
        """Test the ability to download an asset."""
        cassette_name = self.cassette_name('download')
        with self.recorder.use_cassette(cassette_name,
                                        preserve_exact_body_bytes=True):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            release = repository.release(76677)
            asset = next(release.iter_assets())
            _, filename = tempfile.mkstemp()
            asset.download(filename)

        with open(filename, 'rb') as fd:
            assert len(fd.read(1024)) > 0

        os.unlink(filename)

    def test_edit(self):
        """Test the ability to edit an existing asset."""
        self.basic_login()
        cassette_name = self.cassette_name('edit')
        with self.recorder.use_cassette(cassette_name,
                                        preserve_exact_body_bytes=True):
            repository = self.gh.repository('github3py', 'github3.py')
            release = repository.create_release(
                '0.8.0.pre', 'develop', '0.8.0 fake release with upload',
                'To be deleted'
                )
            with open(__file__) as fd:
                asset = release.upload_asset(
                    'text/plain', 'test_repos_release.py', fd.read()
                    )
            assert isinstance(asset, github3.repos.release.Asset)
            assert asset.edit('A new name for this asset') is True
            release.delete()

########NEW FILE########
__FILENAME__ = test_repos_repo
import github3

from .helper import IntegrationHelper


class TestRepository(IntegrationHelper):
    def test_create_empty_blob(self):
        """Test the ability to create an empty blob on a repository."""
        self.basic_login()
        cassette_name = self.cassette_name('create_empty_blob')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('github3py', 'fork_this')
            assert repository is not None
            blob_sha = repository.create_blob('', 'utf-8')

        assert blob_sha is not None
        assert blob_sha != ''

    def test_create_deployment(self):
        """Test the ability to create a deployment for a repository."""
        self.basic_login()
        cassette_name = self.cassette_name('create_deployment')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            deployment = repository.create_deployment('0.8.2')

        assert isinstance(deployment, github3.repos.deployment.Deployment)

    def test_create_release(self):
        """Test the ability to create a release on a repository."""
        self.token_login()
        cassette_name = self.cassette_name('create_release')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'charade')
            assert repository is not None
            release = repository.create_release(
                '1.0.3.test', 'f1d4e150be7070adfbbdca164328d69723e096ec',
                'Test release'
                )

        assert isinstance(release, github3.repos.release.Release)

    def test_iter_deployments(self):
        """Test that a repository's deployments may be retrieved."""
        cassette_name = self.cassette_name('iter_deployments')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            for d in repository.iter_deployments():
                assert isinstance(d, github3.repos.deployment.Deployment)

    def test_iter_issues_accepts_state_all(self):
        """Test that the state parameter accets 'all'."""
        cassette_name = self.cassette_name('issues_state_all')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'betamax')
            assert repository is not None
            for issue in repository.iter_issues(state='all'):
                assert issue.state in ('open', 'closed')

    def test_iter_languages(self):
        """Test that a repository's languages can be retrieved."""
        cassette_name = self.cassette_name('iter_languages')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            for l in repository.iter_languages():
                assert 'ETag' not in l
                assert 'Last-Modified' not in l
                assert isinstance(l, tuple)

    def test_iter_pulls_accepts_sort_and_direction(self):
        """Test that iter_pulls now takes a sort parameter."""
        cassette_name = self.cassette_name('pull_requests_accept_sort')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'betamax')
            assert repository is not None
            last_pr = None
            for pr in repository.iter_pulls(sort='updated', direction='asc'):
                assert pr
                if last_pr:
                    assert last_pr.updated_at < pr.updated_at
                last_pr = pr

    def test_iter_releases(self):
        """Test the ability to iterate over releases on a repository."""
        cassette_name = self.cassette_name('iter_releases')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            for release in repository.iter_releases():
                assert isinstance(release, github3.repos.release.Release)

    def test_milestone(self):
        """
        Test the ability to retrieve a specific milestone on a repository.
        """
        cassette_name = self.cassette_name('milestone')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            milestone = repository.milestone(7)
        assert isinstance(milestone, github3.issues.milestone.Milestone)

    def test_release(self):
        """Test the ability to retrieve a single release."""
        cassette_name = self.cassette_name('release')
        with self.recorder.use_cassette(cassette_name):
            repository = self.gh.repository('sigmavirus24', 'github3.py')
            assert repository is not None
            release = repository.release(76677)

        assert isinstance(release, github3.repos.release.Release)

########NEW FILE########
__FILENAME__ = test_session
import github3

from .helper import IntegrationHelper


class TestGitHubSession(IntegrationHelper):
    def test_two_factor_authentication_works(self):
        two_factor_auth = lambda: '862478'
        self.basic_login()
        self.gh.login(two_factor_callback=two_factor_auth)

        cassette_name = self.cassette_name('two_factor_authentication')
        assert isinstance(self.session, github3.session.GitHubSession)

        match = ['method', 'uri', 'gh3-headers']
        with self.recorder.use_cassette(cassette_name,
                                        match_requests_on=match):
            r = self.session.get('https://api.github.com/users/sigmavirus24')
            assert r.status_code == 200

########NEW FILE########
__FILENAME__ = test_structs
from .helper import IntegrationHelper


class TestGitHubIterator(IntegrationHelper):
    def test_resets_etag(self):
        cassette_name = self.cassette_name('resets_etag')
        with self.recorder.use_cassette(cassette_name):
            users_iter = self.gh.iter_all_users(number=10)
            assert users_iter.etag is None
            next(users_iter)  # Make the request
            assert users_iter.etag is not None
            users_iter.refresh()
            assert users_iter.etag is None

########NEW FILE########
__FILENAME__ = test_users
import github3

from .helper import IntegrationHelper


class TestUser(IntegrationHelper):
    def test_iter_orgs(self):
        cassette_name = self.cassette_name('iter_orgs')
        with self.recorder.use_cassette(cassette_name):
            u = self.gh.user('sigmavirus24')
            for o in u.iter_orgs(number=25):
                assert isinstance(o, github3.orgs.Organization)

########NEW FILE########
__FILENAME__ = refresh_fixtures
#!/usr/bin/env python

import os
import json
import getpass
import requests

IGNORE = (
    'archive',
    'authorization',
    'branch',
    'code_frequency',
    'commit',
    'commit_activity',
    'contributor_statistics',
    'create_content',
    'emails',
    'event',
    'language',
    'legacy_email',
    'legacy_issue',
    'legacy_repo',
    'legacy_user',
    'merge',
    'meta',
    'pull_file',
    'ratelimit',
    'tag',
    'template',
    'templates',
    'weekly_commit_count',
)

try:
    prompt = raw_input
except NameError:
    # python3
    prompt = input


def handle(file_name, json_data):
    if file_name == 'status' and isinstance(json_data, list):
        json_data = json_data[0]

    with open(file_name, 'wb') as f:
        json.dump(json_data, f)


def get_auth():
    user = ''
    while not user:
        user = prompt('Username: ').strip()

    passwd = ''
    while not passwd:
        passwd = getpass.getpass('Password: ')

    return user, passwd


def main():
    auth = get_auth()
    s = requests.Session()
    s.auth = auth

    for file_name in sorted(os.listdir('.')):
        if file_name in IGNORE or file_name.endswith('.py'):
            continue

        json_data = {}
        with open(file_name, 'rb') as f:
            try:
                json_data = json.load(f)
            except ValueError:
                print("Couldn't process: {0}".format(file_name))

        url = json_data.get('url')

        print("{0}: {1}".format(file_name, url))

        if not url:
            print("Skipping {0}".format(file_name))
            continue

        response = s.get(url)
        if response.status_code == 200:
            handle(file_name, response.json())

########NEW FILE########
__FILENAME__ = test_api
import github3
from unittest import TestCase
#from .utils.mock import patch, NonCallableMock
from .utils import mock


class TestAPI(TestCase):
    def setUp(self):
        self.mock = mock.patch('github3.api.gh', autospec=github3.GitHub)
        self.gh = self.mock.start()

    def tearDown(self):
        self.mock.stop()

    def test_authorize(self):
        args = ('login', 'password', ['scope1'], 'note', 'note_url.com', '',
                '')
        with mock.patch.object(github3.api.GitHub, 'authorize') as authorize:
            github3.authorize(*args)
            authorize.assert_called_once_with(*args)

    def test_login(self):
        args = ('login', 'password', None, None)
        with mock.patch.object(github3.api.GitHub, 'login') as login:
            g = github3.login(*args)
            assert isinstance(g, github3.github.GitHub)
            assert not isinstance(g, github3.github.GitHubEnterprise)
            login.assert_called_with(*args)

    def test_enterprise_login(self):
        args = ('login', 'password', None, 'http://ghe.invalid/', None)
        with mock.patch.object(github3.api.GitHubEnterprise, 'login') as login:
            g = github3.login(*args)
            assert isinstance(g, github3.github.GitHubEnterprise)
            login.assert_called_with('login', 'password', None, None)

    def test_gist(self):
        args = (123,)
        github3.gist(*args)
        self.gh.gist.assert_called_with(*args)

    def test_gitignore_template(self):
        args = ('Python',)
        github3.gitignore_template(*args)
        self.gh.gitignore_template.assert_called_with(*args)

    def test_gitignore_templates(self):
        github3.gitignore_templates()
        assert self.gh.gitignore_templates.called is True

    def test_iter_all_repos(self):
        github3.iter_all_repos()
        self.gh.iter_all_repos.assert_called_with(-1, None)

    def test_iter_all_users(self):
        github3.iter_all_users()
        self.gh.iter_all_users.assert_called_with(-1, None)

    def test_iter_events(self):
        github3.iter_events()
        self.gh.iter_events.assert_called_with(-1, None)

    def test_iter_followers(self):
        github3.iter_followers('login')
        self.gh.iter_followers.assert_called_with('login', -1, None)

    def test_iter_following(self):
        github3.iter_following('login')
        self.gh.iter_following.assert_called_with('login', -1, None)

    def test_iter_gists(self):
        github3.iter_gists()
        self.gh.iter_gists.assert_called_with(None, -1, None)

    def test_iter_repo_issues(self):
        args = ('owner', 'repository', None, None, None, None, None, None,
                None, None, -1, None)
        github3.iter_repo_issues(*args)
        self.gh.iter_repo_issues.assert_called_with(*args)

        github3.iter_repo_issues(None, None)

    def test_iter_orgs(self):
        args = ('login', -1, None)
        github3.iter_orgs(*args)
        self.gh.iter_orgs.assert_called_with(*args)

    def test_iter_user_repos(self):
        args = ('login', None, None, None, -1, None)
        github3.iter_user_repos('login')
        self.gh.iter_user_repos.assert_called_with(*args)

        github3.iter_user_repos(None)

    def test_iter_starred(self):
        github3.iter_starred('login')
        self.gh.iter_starred.assert_called_with('login', -1, None)

    def test_iter_subcriptions(self):
        github3.iter_subscriptions('login')
        self.gh.iter_subscriptions.assert_called_with('login', -1, None)

    def test_create_gist(self):
        args = ('description', {'files': ['files']})
        github3.create_gist(*args)
        self.gh.create_gist.assert_called_with(*args)

    def test_issue(self):
        args = ('owner', 'repo', 1)
        github3.issue(*args)
        self.gh.issue.assert_called_with(*args)

    def test_markdown(self):
        args = ('text', '', '', False)
        github3.markdown(*args)
        self.gh.markdown.assert_called_with(*args)

    def test_octocat(self):
        github3.octocat()
        assert self.gh.octocat.called is True

    def test_organization(self):
        github3.organization('login')
        self.gh.organization.assert_called_with('login')

    def test_pull_request(self):
        args = ('owner', 'repo', 1)
        github3.pull_request(*args)
        self.gh.pull_request.assert_called_with(*args)

    def test_repository(self):
        args = ('owner', 'repo')
        github3.repository(*args)
        self.gh.repository.assert_called_with(*args)

    def test_user(self):
        github3.user('login')
        self.gh.user.assert_called_with('login')

    def test_rate_limit(self):
        github3.rate_limit()
        self.gh.rate_limit.assert_called_once_with()

    def test_ratelimit_remaining(self):
        # This prevents a regression in the API
        # See 81c800658db43f86419b9c0764fc16aad3d60007
        self.gh.ratelimit_remaining = mock.NonCallableMock()
        github3.ratelimit_remaining()

    def test_zen(self):
        github3.zen()
        assert self.gh.zen.called is True

########NEW FILE########
__FILENAME__ = test_auths
import github3
from tests.utils import (BaseCase, load)


class TestAuthorization(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestAuthorization, self).__init__(methodName)
        self.auth = github3.auths.Authorization(load('authorization'))
        self.api = "https://api.github.com/authorizations/10"

    def setUp(self):
        super(TestAuthorization, self).setUp()
        self.auth = github3.auths.Authorization(self.auth.to_json(), self.g)

    def test_equality(self):
        a = github3.auths.Authorization(load('authorization'))
        assert self.auth == a
        a._uniq = 1
        assert self.auth != a

    def test_repr(self):
        assert repr(self.auth).startswith('<Authorization')

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.auth.delete)
        self.not_called()

        self.login()
        assert self.auth.delete()
        self.mock_assertions()

    def test_update(self):
        self.response('authorization', 200)
        self.post(self.api)
        data = {
            'scopes': ['user']
        }
        self.conf = {'data': data}

        self.assertRaises(github3.GitHubError, self.auth.update)

        def sub_test():
            assert self.auth.update(**data)
            self.mock_assertions()

        self.login()
        assert self.auth.update() is False
        self.not_called()

        sub_test()

        del(data['scopes'])
        data['add_scopes'] = ['repo']
        sub_test()

        del(data['add_scopes'])
        data['rm_scopes'] = ['user']
        self.conf['data'] = {'remove_scopes': ['user']}
        sub_test()
        self.conf['data'] = data

        del(data['rm_scopes'])
        data['note'] = 'GitHub API'
        data['note_url'] = 'http://example.com'
        sub_test()

########NEW FILE########
__FILENAME__ = test_events
import github3
from tests.utils import BaseCase, load
from unittest import TestCase


class TestEvent(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestEvent, self).__init__(methodName)
        self.ev = github3.events.Event(load('event'))
        self.o = load('org')

    def setUp(self):
        super(TestEvent, self).setUp()
        self.ev = github3.events.Event(self.ev.to_json())

    def test_equality(self):
        e = github3.events.Event(load('event'))
        assert self.ev == e
        e._uniq = 1
        assert self.ev != e

    def test_org(self):
        json = self.ev.to_json().copy()
        json['org'] = self.o
        ev = github3.events.Event(json)
        assert isinstance(ev.org, github3.orgs.Organization)

    def test_repr(self):
        assert repr(self.ev).startswith('<Event')

    def test_list_types(self):
        Event, handlers = (github3.events.Event,
                           github3.events._payload_handlers)
        assert Event.list_types() == sorted(handlers.keys())

    def test_is_public(self):
        assert self.ev.is_public() == self.ev.public


class TestPayloadHandlers(TestCase):
    def test_commitcomment(self):
        comment = {'comment': load('repo_comment')}
        comment = github3.events._commitcomment(comment)
        assert isinstance(comment['comment'],
                          github3.repos.comment.RepoComment)

    def test_follow(self):
        f = {'target': load('user')}
        github3.events._follow(f)
        assert isinstance(f['target'], github3.users.User)

    def test_forkev(self):
        f = {'forkee': load('repo')}
        github3.events._forkev(f)
        assert isinstance(f['forkee'], github3.repos.Repository)

    def test_gist(self):
        g = {'gist': load('gist')}
        github3.events._gist(g)
        assert isinstance(g['gist'], github3.gists.Gist)

    def test_issuecomm(self):
        c = {'issue': load('issue'), 'comment': load('issue_comment')}
        github3.events._issuecomm(c)
        assert isinstance(c['issue'], github3.issues.Issue)
        assert isinstance(c['comment'], github3.issues.comment.IssueComment)

    def test_issueevent(self):
        c = {'issue': load('issue')}
        github3.events._issueevent(c)
        assert isinstance(c['issue'], github3.issues.Issue)

    def test_member(self):
        m = {'member': load('user')}
        github3.events._member(m)
        assert isinstance(m['member'], github3.users.User)

    def test_pullreqev(self):
        p = {'pull_request': load('pull')}
        github3.events._pullreqev(p)
        assert isinstance(p['pull_request'], github3.pulls.PullRequest)

    def test_pullreqcomm(self):
        p = {'comment': load('review_comment')}
        github3.events._pullreqcomm(p)
        assert isinstance(p['comment'], github3.pulls.ReviewComment)

    def test_team(payload):
        t = {'team': load('team'), 'repo': load('repo'), 'user': load('user')}
        github3.events._team(t)
        assert isinstance(t['team'], github3.orgs.Team)
        assert isinstance(t['repo'], github3.repos.Repository)
        assert isinstance(t['user'], github3.users.User)

########NEW FILE########
__FILENAME__ = test_gists
import github3
from github3 import gists
from tests.utils import (BaseCase, load)


class TestGist(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestGist, self).__init__(methodName)
        self.gist = gists.Gist(load('gist'))
        self.api = 'https://api.github.com/gists/3813862'

    def setUp(self):
        super(TestGist, self).setUp()
        self.gist = gists.Gist(self.gist.to_json(), self.g)

    def test_str(self):
        assert str(self.gist) == str(self.gist.id)

    def test_repr(self):
        assert repr(self.gist) == '<Gist [{0}]>'.format(self.gist)

    def test_create_comment(self):
        self.response('gist_comment', 201)
        self.post(self.api + '/comments')
        self.conf = {'data': {'body': 'bar'}}

        self.assertRaises(github3.GitHubError, self.gist.create_comment)
        self.login()

        assert self.gist.create_comment(None) is None
        assert self.gist.create_comment('') is None
        self.not_called()
        assert isinstance(self.gist.create_comment('bar'),
                          gists.comment.GistComment)
        self.mock_assertions()

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.gist.delete)

        self.not_called()
        self.login()
        assert self.gist.delete()
        self.mock_assertions()

    def test_edit(self):
        self.response('gist', 200)
        self.patch(self.api)
        self.conf = {
            'data': {
                'description': 'desc',
                'files': {'file1': {'content': 'foo bar'}}
            }
        }

        self.assertRaises(github3.GitHubError, self.gist.edit)

        self.login()
        assert self.gist.edit() is False
        self.not_called()

        assert self.gist.edit(**self.conf['data'])
        self.mock_assertions()

    def test_fork(self):
        self.response('gist', 201)
        self.post(self.api + '/forks')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.gist.fork)

        self.not_called()
        self.login()
        assert isinstance(self.gist.fork(), gists.Gist)
        self.mock_assertions()

    def test_is_public(self):
        assert self.gist.is_public() == self.gist.public

    def test_is_starred(self):
        self.response('', 204)
        self.get(self.api + '/star')

        self.assertRaises(github3.GitHubError, self.gist.is_starred)

        self.not_called()
        self.login()
        assert self.gist.is_starred()
        self.mock_assertions()

    def test_iter_comments(self):
        self.response('gist_comment', _iter=True)
        self.get(self.api + '/comments')
        self.conf = {'params': {'per_page': 100}}

        c = next(self.gist.iter_comments())

        assert isinstance(c, gists.comment.GistComment)
        self.mock_assertions()

    def test_iter_commits(self):
        self.response('gist_history', _iter=True)
        self.get(self.api + '/commits')
        self.conf = {'params': {'per_page': 100}}

        h = next(self.gist.iter_commits())
        assert isinstance(h, gists.history.GistHistory)
        self.mock_assertions()

    def test_iter_files(self):
        gist_file = next(self.gist.iter_files())
        assert gist_file == self.gist._files[0]
        assert isinstance(gist_file, gists.file.GistFile)
        assert repr(gist_file).startswith('<Gist File')

    def test_refresh(self):
        self.response('gist', 200)
        self.get(self.api)

        assert self.gist.refresh() is self.gist
        self.mock_assertions()

    def test_star(self):
        self.response('', 204)
        self.put(self.api + '/star')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.gist.star)

        self.not_called()
        self.login()
        assert self.gist.star()
        self.mock_assertions()

    def test_unstar(self):
        self.response('', 204)
        self.delete(self.api + '/star')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.gist.unstar)

        self.not_called()
        self.login()
        assert self.gist.unstar()
        self.mock_assertions()

    # As opposed to creating an all new class for this
    def test_history(self):
        hist = self.gist.history[0]
        self.response('gist', 200)
        self.get(hist._api)

        assert isinstance(hist, gists.history.GistHistory)
        assert isinstance(hist.get_gist(), gists.Gist)
        self.mock_assertions()

        assert repr(hist).startswith('<Gist History')

    def test_equality(self):
        g = gists.Gist(load('gist'))
        assert self.gist == g
        g._uniq = 1
        assert self.gist != g


class TestGistComment(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestGistComment, self).__init__(methodName)
        self.comment = gists.comment.GistComment(load('gist_comment'))
        self.api = "https://api.github.com/gists/4321394/comments/655725"

    def setUp(self):
        super(TestGistComment, self).setUp()
        self.comment = gists.comment.GistComment(self.comment.to_json(),
                                                 self.g)

    def test_equality(self):
        c = gists.comment.GistComment(load('gist_comment'))
        assert self.comment == c
        c._uniq = 1
        assert self.comment != c

    def test_repr(self):
        assert repr(self.comment) != ''

    def test_edit(self):
        self.response('gist_comment', 200)
        self.patch(self.api)
        self.conf = {'data': {'body': 'body'}}

        self.assertRaises(github3.GitHubError, self.comment.edit)

        self.login()
        assert self.comment.edit(None) is False
        self.not_called()

        assert self.comment.edit('body')
        self.mock_assertions()


class TestGistHistory(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestGistHistory, self).__init__(methodName)
        self.hist = gists.history.GistHistory(load('gist_history'))

    def test_equality(self):
        h = gists.history.GistHistory(load('gist_history'))
        assert self.hist == h
        h._uniq = 'foo'
        assert self.hist != h

########NEW FILE########
__FILENAME__ = test_git
import github3
from tests.utils import (BaseCase, load)


class TestCommit(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestCommit, self).__init__(methodName)
        self.commit = github3.git.Commit(load('commit'))

    def test_repr(self):
        assert repr(self.commit).startswith('<Commit')

    def test_author_as_User(self):
        u = self.commit.author_as_User()
        assert isinstance(u, github3.users.User)

    def test_committer_as_User(self):
        u = self.commit.committer_as_User()
        assert isinstance(u, github3.users.User)


class TestReference(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestReference, self).__init__(methodName)
        self.ref = github3.git.Reference(load('ref'))
        self.api = ('https://api.github.com/repos/sigmavirus24/github3.py/'
                    'git/refs/heads/master')

    def setUp(self):
        super(TestReference, self).setUp()
        self.ref = github3.git.Reference(self.ref.to_json(), self.g)

    def test_repr(self):
        assert repr(self.ref).startswith('<Reference')
        assert repr(self.ref.object).startswith('<Git Object')

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.ref.delete)

        self.not_called()
        self.login()
        assert self.ref.delete()
        self.mock_assertions()

    def test_update(self):
        self.response('ref', 200)
        self.patch(self.api)
        self.conf = {
            'data': {
                'sha': 'fakesha',
                'force': True,
            }
        }

        self.assertRaises(github3.GitHubError, self.ref.update, 'fake')

        self.not_called()
        self.login()
        assert self.ref.update('fakesha', True)
        self.mock_assertions()

        self.response('', 404)
        assert self.ref.update('fakesha', True) is False
        self.mock_assertions()


class TestTree(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestTree, self).__init__(methodName)
        self.tree = github3.git.Tree(load('tree'))
        self.api = ('https://api.github.com/repos/sigmavirus24/github3.py/git/'
                    'trees/75b347329e3fc87ac78895ca1be58daff78872a1')

    def setUp(self):
        super(TestTree, self).setUp()
        self.tree = github3.git.Tree(self.tree.to_json(), self.g)

    def test_recurse(self):
        self.response('tree', 200)
        self.get(self.api)
        self.conf = {'params': {'recursive': '1'}}

        t = self.tree.recurse()
        assert isinstance(t, github3.git.Tree)
        assert repr(t).startswith('<Tree')
        self.mock_assertions()

        assert isinstance(t.tree[0], github3.git.Hash)
        assert repr(t.tree[0]).startswith('<Hash')

########NEW FILE########
__FILENAME__ = test_github
import github3

from tests.utils import (BaseCase, load, mock)


def merge(first, second=None, **kwargs):
    copy = first.copy()
    copy.update(second or {})
    copy.update(kwargs)
    return copy


class TestGitHub(BaseCase):
    def test_init(self):
        g = github3.GitHub('foo', 'bar')
        assert repr(g).endswith('[foo]>')

        g = github3.GitHub(token='foo')
        assert repr(g).endswith('{0:x}>'.format(id(g)))

    def test_context_manager(self):
        with github3.GitHub() as gh:
            gh.__exit__ = mock.Mock()
            assert isinstance(gh, github3.GitHub)

        gh.__exit__.assert_called()

    def test_authorization(self):
        self.response('authorization')
        self.get('https://api.github.com/authorizations/10')
        self.assertRaises(github3.GitHubError, self.g.authorization, 10)
        assert self.request.called is False

        self.login()
        a = self.g.authorization(10)
        assert isinstance(a, github3.auths.Authorization)
        self.mock_assertions()

    def test_authorize(self):
        self.response('authorization', 201)
        scopes = ['scope1', 'scope2']

        self.g.authorize(None, None, scopes)
        self.not_called()

        a = self.g.authorize('user', 'password', scopes)
        assert isinstance(a, github3.auths.Authorization)
        assert self.request.called is True

        self.request.reset_mock()

        self.login()
        a = self.g.authorize(None, None, scopes=scopes)

    def test_check_authorization(self):
        self.response('', 200)
        self.get('https://api.github.com/applications/fake_id/tokens/'
                 'access_token')
        self.conf = {
            'params': {'client_id': None, 'client_secret': None},
            'auth': ('fake_id', 'fake_secret'),
        }

        assert self.g.check_authorization(None) is False
        self.not_called()

        self.g.set_client_id('fake_id', 'fake_secret')
        assert self.g.check_authorization('access_token')
        self.mock_assertions()

    def test_create_gist(self):
        self.response('gist', 201)

        g = self.g.create_gist('description', 'files')
        assert isinstance(g, github3.gists.Gist)
        assert self.request.called is True
        #with Betamax(self.session).use_cassette('GitHub_create_gist'):
        #    self.g.create_gist(
        #        'description of test_gist', {
        #            'filename': 'contents'
        #        })

    def test_create_issue(self):
        self.response('issue', 201)

        self.login()
        i = self.g.create_issue(None, None, None)
        assert i is None
        assert self.request.called is False

        i = self.g.create_issue('user', 'repo', '')
        assert i is None
        assert self.request.called is False

        with mock.patch.object(github3.GitHub, 'repository') as repo:
            repo.return_value = github3.repos.Repository(
                load('repo'), self.g)
            i = self.g.create_issue('user', 'repo', 'Title')

        assert isinstance(i, github3.issues.Issue)
        assert self.request.called is True

    def test_create_key(self):
        self.response('key', 201)

        self.assertRaises(github3.GitHubError, self.g.create_key, None, None)
#            k = self.g.create_key(None, None)
#            assert k is None
        assert self.request.called is False

        self.login()
        k = self.g.create_key('Name', 'Key')

        assert isinstance(k, github3.users.Key)
        assert self.request.called is True

    def test_create_repo(self):
        self.response('repo', 201)
        self.login()
        r = self.g.create_repo('Repository')
        assert isinstance(r, github3.repos.Repository)
        assert self.request.called is True

    def test_delete_key(self):
        self.response(None, 204)

        self.login()
        with mock.patch.object(github3.github.GitHub, 'key') as key:
            key.return_value = github3.users.Key(load('key'), self.g)
            assert self.g.delete_key(10) is True
            key.return_value = None
            assert self.g.delete_key(10) is False

        assert self.request.called is True

    def test_follow(self):
        self.response(None, 204)
        self.put('https://api.github.com/user/following/sigmavirus24')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.g.follow, 'sigmavirus24')

        self.login()
        assert self.g.follow(None) is False
        assert self.g.follow('sigmavirus24') is True
        self.mock_assertions()

    def test_gist(self):
        self.response('gist', 200)
        self.get('https://api.github.com/gists/10')

        assert isinstance(self.g.gist(10), github3.gists.Gist)
        self.mock_assertions()

    def test_gitignore_template(self):
        self.response('template')
        self.get('https://api.github.com/gitignore/templates/Python')

        template = self.g.gitignore_template('Python')

        assert template.startswith('*.py[cod]')
        self.mock_assertions()

    def test_gitignore_templates(self):
        self.response('templates')
        self.get('https://api.github.com/gitignore/templates')

        assert isinstance(self.g.gitignore_templates(), list)
        self.mock_assertions()

    def test_is_following(self):
        self.response(None, 204)
        self.get('https://api.github.com/user/following/login')

        self.assertRaises(github3.GitHubError, self.g.is_following, 'login')

        self.login()
        assert self.g.is_following(None) is False
        assert self.request.called is False

        assert self.g.is_following('login')
        self.mock_assertions()

    def test_is_starred(self):
        self.response(None, 204)
        self.get('https://api.github.com/user/starred/user/repo')

        self.assertRaises(github3.GitHubError, self.g.is_starred,
                          'user', 'repo')

        self.login()

        assert self.g.is_starred(None, None) is False
        assert self.request.called is False

        assert self.g.is_starred('user', 'repo') is True
        self.mock_assertions()

    def test_is_subscribed(self):
        self.response(None, 204)
        self.get('https://api.github.com/user/subscriptions/user/repo')

        self.assertRaises(github3.GitHubError, self.g.is_subscribed,
                          'user', 'repo')

        self.login()
        assert self.g.is_subscribed(None, None) is False
        assert self.request.called is False

        assert self.g.is_subscribed('user', 'repo')
        self.mock_assertions()

    def test_issue(self):
        self.response('issue', 200)
        self.get('https://api.github.com/repos/sigmavirus24/github3.py/'
                 'issues/1')

        assert self.g.issue(None, None, 0) is None
        with mock.patch.object(github3.github.GitHub, 'repository') as repo:
            repo.return_value = github3.repos.Repository(load('repo'))
            i = self.g.issue('user', 'repo', 1)

        assert isinstance(i, github3.issues.Issue)
        self.mock_assertions()

    def test_key(self):
        self.response('key')
        self.get('https://api.github.com/user/keys/10')

        self.assertRaises(github3.GitHubError, self.g.key, 10)
        assert self.request.called is False

        self.login()
        assert self.g.key(-1) is None
        assert self.request.called is False

        assert isinstance(self.g.key(10), github3.users.Key)
        self.mock_assertions()

    def test_iter_all_repos(self):
        self.response('repo', _iter=True)
        self.get('https://api.github.com/repositories')
        self.conf.update(params={'per_page': 100})

        repo = next(self.g.iter_all_repos())
        assert isinstance(repo, github3.repos.Repository)
        self.mock_assertions()

        self.response('repo', _iter=True)
        self.get('https://api.github.com/repositories')
        self.conf.update(params={'since': 100000, 'per_page': 100})
        repo = next(self.g.iter_all_repos(since=100000))
        assert isinstance(repo, github3.repos.Repository)
        assert(repo.id > 100000)
        self.mock_assertions()

        repo = next(self.g.iter_all_repos(per_page=100))
        self.conf.update(params={'per_page': 100})
        assert isinstance(repo, github3.repos.Repository)
        self.mock_assertions()

    def test_iter_all_users(self):
        self.response('user', _iter=True)
        self.get('https://api.github.com/users')
        self.conf.update(params={'per_page': 100})

        repo = next(self.g.iter_all_users())
        assert isinstance(repo, github3.users.User)
        self.mock_assertions()

        repo = next(self.g.iter_all_users(per_page=100))
        self.conf.update(params={'per_page': 100})
        assert isinstance(repo, github3.users.User)
        self.mock_assertions()

    def test_iter_authorizations(self):
        self.response('authorization', _iter=True)
        self.get('https://api.github.com/authorizations')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_authorizations)
        assert self.request.called is False

        self.login()
        auth = next(self.g.iter_authorizations())
        assert isinstance(auth, github3.auths.Authorization)
        self.mock_assertions()

    def test_iter_emails(self):
        self.response('emails', _iter=True)
        self.get('https://api.github.com/user/emails')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_emails)
        assert self.request.called is False

        self.login()
        email = next(self.g.iter_emails())
        assert email['email'] == 'graffatcolmingov@gmail.com'
        self.mock_assertions()

    def test_iter_events(self):
        self.response('event', _iter=True)
        self.get('https://api.github.com/events')
        self.conf.update(params={'per_page': 100})

        event = next(self.g.iter_events())
        assert isinstance(event, github3.events.Event)
        self.mock_assertions()

    def test_iter_followers(self):
        self.response('user', _iter=True)
        self.get('https://api.github.com/users/sigmavirus24/followers')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_followers)

        with mock.patch.object(github3.github.GitHub, 'user') as ghuser:
            ghuser.return_value = github3.users.User(load('user'))
            u = next(self.g.iter_followers('sigmavirus24'))
            assert isinstance(u, github3.users.User)
            assert self.request.called is True
            self.mock_assertions()

            self.login()
            v = next(self.g.iter_followers())
            assert isinstance(v, github3.users.User)
            self.get('https://api.github.com/user/followers')
            assert self.request.called is True
            self.mock_assertions()

    def test_iter_following(self):
        self.response('user', _iter=True)
        self.get('https://api.github.com/users/sigmavirus24/following')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_following)
        assert self.request.called is False

        with mock.patch.object(github3.github.GitHub, 'user') as ghuser:
            ghuser.return_value = github3.users.User(load('user'))
            u = next(self.g.iter_following('sigmavirus24'))
            assert isinstance(u, github3.users.User)
            self.mock_assertions()

            self.login()
            v = next(self.g.iter_following())
            assert isinstance(v, github3.users.User)
            self.get('https://api.github.com/user/following')
            self.mock_assertions()

    def test_iter_gists(self):
        self.response('gist', _iter=True)
        self.get('https://api.github.com/users/sigmavirus24/gists')
        self.conf.update(params={'per_page': 100})

        g = next(self.g.iter_gists('sigmavirus24'))
        assert isinstance(g, github3.gists.Gist)
        self.mock_assertions()

        self.login()
        h = next(self.g.iter_gists())
        assert isinstance(h, github3.gists.Gist)
        self.get('https://api.github.com/gists')
        self.mock_assertions()

    def test_iter_notifications(self):
        self.response('notification', _iter=True)
        self.get('https://api.github.com/notifications')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_notifications)

        self.not_called()
        self.login()
        thread = next(self.g.iter_notifications())
        assert isinstance(thread, github3.notifications.Thread)
        self.mock_assertions()

        self.conf.update(params={'all': True, 'per_page': 100})
        next(self.g.iter_notifications(True))
        self.mock_assertions()

        self.conf.update(params={'participating': True, 'per_page': 100})
        next(self.g.iter_notifications(participating=True))
        self.mock_assertions()

    def test_iter_org_issues(self):
        self.response('issue', _iter=True)
        self.get('https://api.github.com/orgs/github3py/issues')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_org_issues,
                          'github3py')

        self.login()
        i = next(self.g.iter_org_issues('github3py'))
        assert isinstance(i, github3.issues.Issue)
        self.mock_assertions()

        params = {'filter': 'assigned', 'state': 'closed', 'labels': 'bug',
                  'sort': 'created', 'direction': 'asc',
                  'since': '2012-05-20T23:10:27Z'}
        request_params = merge(params, per_page=100)
        self.conf.update(params=request_params)
        j = next(self.g.iter_org_issues('github3py', **params))
        assert isinstance(j, github3.issues.Issue)
        self.mock_assertions()

    def test_iter_issues(self):
        self.response('issue', _iter=True)
        self.get('https://api.github.com/issues')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_issues)

        self.login()
        assert isinstance(next(self.g.iter_issues()), github3.issues.Issue)
        self.mock_assertions()

        params = {'filter': 'assigned', 'state': 'closed', 'labels': 'bug',
                  'sort': 'created', 'direction': 'asc',
                  'since': '2012-05-20T23:10:27Z'}
        request_params = merge(params, per_page=100)
        self.conf.update(params=request_params)
        assert isinstance(next(self.g.iter_issues(**params)),
                          github3.issues.Issue)
        self.mock_assertions()

    def test_iter_user_issues(self):
        self.response('issue', _iter=True)
        self.get('https://api.github.com/user/issues')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_user_issues)

        self.login()
        assert isinstance(next(self.g.iter_user_issues()),
                          github3.issues.Issue)
        self.mock_assertions()

        params = {'filter': 'assigned', 'state': 'closed', 'labels': 'bug',
                  'sort': 'created', 'direction': 'asc',
                  'since': '2012-05-20T23:10:27Z'}
        request_params = merge(params, per_page=100)
        self.conf.update(params=request_params)
        assert isinstance(next(self.g.iter_user_issues(**params)),
                          github3.issues.Issue)
        self.mock_assertions()

    def test_iter_repo_issues(self):
        self.response('issue', _iter=True)
        self.get('https://api.github.com/repos/sigmavirus24/github3.py/'
                 'issues')

        with mock.patch.object(github3.GitHub, 'repository') as repo:
            repo.return_value = github3.repos.Repository(load('repo'),
                                                         self.g)
            i = next(self.g.iter_repo_issues('sigmavirus24', 'github3.py'))

        assert isinstance(i, github3.issues.Issue)
        self.mock_assertions()

        with self.assertRaises(StopIteration):
            next(self.g.iter_repo_issues(None, None))

    def test_iter_keys(self):
        self.response('key', _iter=True)
        self.get('https://api.github.com/user/keys')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_keys)

        self.login()
        assert isinstance(next(self.g.iter_keys()), github3.users.Key)
        self.mock_assertions()

    def test_iter_orgs(self):
        self.response('org', _iter=True)
        self.get('https://api.github.com/users/login/orgs')

        assert isinstance(next(self.g.iter_orgs('login')),
                          github3.orgs.Organization)
        self.mock_assertions()

        self.get('https://api.github.com/user/orgs')
        self.login()
        assert isinstance(next(self.g.iter_orgs()), github3.orgs.Organization)
        self.mock_assertions()

    def test_iter_repos(self):
        self.response('repo', _iter=True)
        self.get('https://api.github.com/user/repos')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.g.iter_repos)

        self.login()
        assert isinstance(next(self.g.iter_repos()), github3.repos.Repository)
        self.mock_assertions()

        assert isinstance(next(self.g.iter_repos('sigmavirus24')),
                          github3.repos.Repository)
        self.mock_assertions()

        self.conf.update(params={'type': 'all', 'direction': 'desc',
                                 'per_page': 100})

        next(self.g.iter_repos('all', direction='desc'))
        self.mock_assertions()

    def test_iter_user_repos(self):
        self.response('repo', _iter=True)
        self.get('https://api.github.com/users/sigmavirus24/repos')
        self.conf.update(params={'type': 'all', 'direction': 'desc',
                                 'per_page': 100})

        next(self.g.iter_user_repos('sigmavirus24', 'all', direction='desc'))
        self.mock_assertions()

        self.conf.update(params={'sort': 'created', 'per_page': 100})
        self.get('https://api.github.com/users/sigmavirus24/repos')

        assert isinstance(next(self.g.iter_user_repos('sigmavirus24',
                                                      sort="created")),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_iter_repos_sort(self):
        self.response('repo', _iter=True)
        self.conf.update(params={'sort': 'created', 'per_page': 100})

        self.login()
        self.get('https://api.github.com/user/repos')
        assert isinstance(next(self.g.iter_repos(sort="created")),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_iter_starred(self):
        self.response('repo', _iter=True)
        self.get('https://api.github.com/user/starred')
        self.conf.update(params={'per_page': 100})

        self.login()
        assert isinstance(next(self.g.iter_starred()),
                          github3.repos.Repository)
        self.mock_assertions()

        with mock.patch.object(github3.github.GitHub, 'user') as user:
            user.return_value = github3.users.User(load('user'))
            self.get('https://api.github.com/users/sigmavirus24/starred')
            assert isinstance(next(self.g.iter_starred('sigmavirus24')),
                              github3.repos.Repository)
            self.mock_assertions()

    def test_iter_subscriptions(self):
        self.response('repo', _iter=True)
        self.get('https://api.github.com/user/subscriptions')
        self.conf.update(params={'per_page': 100})

        self.login()
        assert isinstance(next(self.g.iter_subscriptions()),
                          github3.repos.Repository)
        self.mock_assertions()

        with mock.patch.object(github3.github.GitHub, 'user') as user:
            user.return_value = github3.users.User(load('user'))
            self.get('https://api.github.com/users/sigmavirus24/'
                     'subscriptions')
            assert isinstance(next(self.g.iter_subscriptions('sigmavirus24')),
                              github3.repos.Repository)
            self.mock_assertions()

    def test_login(self):
        self.g.login('user', 'password')
        assert self.g._session.auth == ('user', 'password')

        self.g.login(token='FakeOAuthToken')
        auth = self.g._session.headers.get('Authorization')
        assert auth == 'token FakeOAuthToken'

    # Unwritten test, not entirely sure how to mock this
    def test_markdown(self):
        self.response('archive')
        self.post('https://api.github.com/markdown')
        self.conf = dict(
            data={
                'text': 'Foo', 'mode': 'gfm', 'context': 'sigmavirus24/cfg'
            }
        )

        assert self.g.markdown(
            'Foo', 'gfm', 'sigmavirus24/cfg'
        ).startswith(b'archive_data')
        self.mock_assertions()

        self.post('https://api.github.com/markdown/raw')
        self.conf['data'] = 'Foo'
        self.g.markdown('Foo', raw=True)
        self.mock_assertions()

        assert self.g.markdown(None) == ''
        self.not_called()

    def test_meta(self):
        self.response('meta')
        self.get('https://api.github.com/meta')
        meta = self.g.meta()
        assert isinstance(meta, dict)
        self.mock_assertions()

    def test_octocat(self):
        self.response('archive')
        self.get('https://api.github.com/octocat')
        assert self.g.octocat().startswith(b'archive_data')
        self.mock_assertions()

    def test_organization(self):
        self.response('org')
        self.get('https://api.github.com/orgs/github3py')
        org = self.g.organization('github3py')
        assert isinstance(org, github3.orgs.Organization)
        self.mock_assertions()

    def test_pubsubhubbub(self):
        self.response('', 204)
        self.post('https://api.github.com/hub')
        body = [('hub.mode', 'subscribe'),
                ('hub.topic', 'https://github.com/foo/bar/events/push'),
                ('hub.callback', 'https://localhost/post')]
        self.conf = {}

        pubsubhubbub = self.g.pubsubhubbub

        self.assertRaises(github3.GitHubError, pubsubhubbub, '', '', '')

        self.login()
        assert pubsubhubbub('', '', '') is False
        self.not_called()

        assert pubsubhubbub('foo', 'https://example.com', 'foo') is False
        self.not_called()

        d = dict([(k[4:], v) for k, v in body])
        assert pubsubhubbub(**d) is True
        _, kwargs = self.request.call_args

        assert 'data' in kwargs
        assert body == kwargs['data']
        self.mock_assertions()

        d['secret'] = 'secret'
        body.append(('hub.secret', 'secret'))
        assert pubsubhubbub(**d)
        _, kwargs = self.request.call_args
        assert 'data' in kwargs
        assert body == kwargs['data']
        self.mock_assertions()

    def test_pull_request(self):
        self.response('pull')
        self.get('https://api.github.com/repos/sigmavirus24/'
                 'github3.py/pulls/18')
        pr = None

        with mock.patch.object(github3.github.GitHub, 'repository') as repo:
            repo.return_value = github3.repos.Repository(load('repo'))
            pr = self.g.pull_request('sigmavirus24', 'github3.py', 18)

        assert isinstance(pr, github3.pulls.PullRequest)

        self.mock_assertions()

    def test_repository(self):
        self.response('repo')
        repo = self.g.repository(None, None)
        assert repo is None
        self.not_called()

        self.get('https://api.github.com/repos/sigmavirus24/github3.py')
        repo = self.g.repository('sigmavirus24', 'github3.py')
        assert isinstance(repo, github3.repos.Repository)
        self.mock_assertions()

    def test_set_client_id(self):
        auth = ('idXXXXXXXXXXXX', 'secretXXXXXXXXXXXXXXXX')
        self.g.set_client_id(*auth)
        assert self.g._session.params['client_id'] == auth[0]
        assert self.g._session.params['client_secret'] == auth[1]

    def test_set_user_agent(self):
        ua = 'Fake User Agents'
        self.g.set_user_agent(ua)
        assert self.g._session.headers['User-Agent'] == ua

        self.g.set_user_agent(None)
        assert self.g._session.headers['User-Agent'] == ua

    def test_star(self):
        self.response('', 204)
        self.put('https://api.github.com/user/starred/sigmavirus24/github3.py')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.g.star, 'foo', 'bar')

        self.login()
        assert self.g.star(None, None) is False
        assert self.g.star('sigmavirus24', 'github3.py')
        self.mock_assertions()

    def test_subscribe(self):
        self.response('', 204)
        self.put('https://api.github.com/user/subscriptions/'
                 'sigmavirus24/github3.py')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.g.subscribe, 'foo', 'bar')

        self.login()
        assert self.g.subscribe(None, None) is False
        assert self.g.subscribe('sigmavirus24', 'github3.py')
        self.mock_assertions()

    def test_unfollow(self):
        self.response('', 204)
        self.delete('https://api.github.com/user/following/'
                    'sigmavirus24')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.g.unfollow, 'foo')

        self.login()
        assert self.g.unfollow(None) is False
        assert self.g.unfollow('sigmavirus24')
        self.mock_assertions()

    def test_unstar(self):
        self.response('', 204)
        self.delete('https://api.github.com/user/starred/'
                    'sigmavirus24/github3.py')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.g.unstar, 'foo', 'bar')

        self.login()
        assert self.g.unstar(None, None) is False
        assert self.g.unstar('sigmavirus24', 'github3.py')
        self.mock_assertions()

    def test_unsubscribe(self):
        self.response('', 204)
        self.delete('https://api.github.com/user/subscriptions/'
                    'sigmavirus24/github3.py')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.g.unsubscribe,
                          'foo', 'bar')

        self.login()
        assert self.g.unsubscribe(None, None) is False
        assert self.g.unsubscribe('sigmavirus24', 'github3.py')
        self.mock_assertions()

    def test_update_user(self):
        self.login()
        args = ('Ian Cordasco', 'example@mail.com', 'www.blog.com', 'company',
                'loc', True, 'bio')

        with mock.patch.object(github3.github.GitHub, 'user') as user:
            with mock.patch.object(github3.users.User, 'update') as upd:
                user.return_value = github3.users.User(load('user'), self.g)
                upd.return_value = True
                assert self.g.update_user(*args)
                assert user.called
                assert upd.called
                upd.assert_called_with(*args)

    def test_user(self):
        self.response('user')
        self.get('https://api.github.com/users/sigmavirus24')

        assert isinstance(self.g.user('sigmavirus24'), github3.users.User)
        self.mock_assertions()

        self.get('https://api.github.com/user')
        self.login()
        assert isinstance(self.g.user(), github3.users.User)
        self.mock_assertions()

    def test_utf8_user(self):
        self.response('utf8_user')
        self.get('https://api.github.com/users/alejandrogomez')

        u = self.g.user('alejandrogomez')

        try:
            repr(u)
        except UnicodeEncodeError:
            self.fail('Regression caught. See PR #52. Names must be utf-8'
                      ' encoded')

    def test_zen(self):
        self.response('archive')
        self.get('https://api.github.com/zen')

        assert self.g.zen().startswith(b'archive_data')
        self.mock_assertions()


class TestGitHubEnterprise(BaseCase):
    def setUp(self):
        super(TestGitHubEnterprise, self).setUp()
        self.g = github3.GitHubEnterprise('https://github.example.com:8080/')

    def test_admin_stats(self):
        self.response('user')
        self.get('https://github.example.com:8080/api/v3/enterprise/stats/all')

        self.assertRaises(github3.GitHubError, self.g.admin_stats, None)

        self.not_called()
        self.login()
        assert isinstance(self.g.admin_stats('all'), dict)
        self.mock_assertions()

    def test_repr(self):
        assert repr(self.g).startswith('<GitHub Enterprise')

    def test_pubsubhubbub(self):
        self.response('', 204)
        self.post('https://github.example.com:8080/api/v3/hub')
        body = [('hub.mode', 'subscribe'),
                ('hub.topic',
                 'https://github.example.com:8080/foo/bar/events/push'),
                ('hub.callback', 'https://localhost/post')]
        self.conf = {}

        self.login()

        d = dict([(k[4:], v) for k, v in body])
        assert self.g.pubsubhubbub(**d)
        _, kwargs = self.request.call_args
        assert 'data' in kwargs
        assert body == kwargs['data']
        self.mock_assertions()

        d['secret'] = 'secret'
        body.append(('hub.secret', 'secret'))
        assert self.g.pubsubhubbub(**d)
        _, kwargs = self.request.call_args
        assert 'data' in kwargs
        assert body == kwargs['data']
        self.mock_assertions()


class TestUnsecureGitHubEnterprise(BaseCase):
    def setUp(self):
        super(TestUnsecureGitHubEnterprise, self).setUp()
        self.g = github3.GitHubEnterprise('https://github.example.com:8080/', verify=False)
    
    def test_skip_ssl_validation(self):
        self.response('pull_enterprise')
        self.g.pull_request('sigmavirus24', 'github3.py', 19)
        
        assert False == self.g._session.verify
        assert self.request.called


class TestGitHubStatus(BaseCase):
    def setUp(self):
        super(TestGitHubStatus, self).setUp()
        self.g = github3.GitHubStatus()
        self.api = 'https://status.github.com/'

    def test_repr(self):
        assert repr(self.g) == '<GitHub Status>'

    def test_api(self):
        self.response('user')
        self.get(self.api + 'api.json')
        assert isinstance(self.g.api(), dict)
        self.mock_assertions()

    def test_status(self):
        self.response('user')
        self.get(self.api + 'api/status.json')
        assert isinstance(self.g.status(), dict)
        self.mock_assertions()

    def test_last_message(self):
        self.response('user')
        self.get(self.api + 'api/last-message.json')
        assert isinstance(self.g.last_message(), dict)
        self.mock_assertions()

    def test_messages(self):
        self.response('user')
        self.get(self.api + 'api/messages.json')
        assert isinstance(self.g.messages(), dict)
        self.mock_assertions()

########NEW FILE########
__FILENAME__ = test_issues
import github3
from github3.issues.comment import IssueComment
from github3.issues.event import IssueEvent
from github3.issues.label import Label
from github3.issues.milestone import Milestone
from github3.issues import Issue
import datetime
from tests.utils import BaseCase, load, mock


class TestLabel(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestLabel, self).__init__(methodName)
        self.l = Label(load('label'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "labels/Bug")

    def setUp(self):
        super(TestLabel, self).setUp()
        self.l = Label(self.l.to_json(), self.g)

    def test_equality(self):
        l = Label(load('label'))
        assert self.l == l
        l._uniq = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                   "labels/wontfix")
        assert self.l != l

    def test_repr(self):
        assert repr(self.l) == '<Label [{0}]>'.format(self.l.name)

    def test_str(self):
        assert str(self.l) == self.l.name

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.l.delete)

        self.not_called()
        self.login()
        assert self.l.delete()

    def test_update(self):
        self.response('label', 200)
        self.patch(self.api)
        self.conf = {'data': {'name': 'newname', 'color': 'afafaf'}}

        self.assertRaises(github3.GitHubError, self.l.update, None, None)

        self.login()
        assert self.l.update(None, None) is False
        self.not_called()

        assert self.l.update('newname', 'afafaf')
        self.mock_assertions()

        assert self.l.update('newname', '#afafaf')
        self.mock_assertions()


class TestMilestone(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestMilestone, self).__init__(methodName)
        self.m = Milestone(load('milestone'))
        self.api = ("https://api.github.com/repos/kennethreitz/requests/"
                    "milestones/18")

    def setUp(self):
        super(TestMilestone, self).setUp()
        self.m = Milestone(self.m.to_json(), self.g)

    def test_repr(self):
        assert repr(self.m) == '<Milestone [v1.0.0]>'

    def test_str(self):
        assert str(self.m) == 'v1.0.0'

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.m.delete)

        self.not_called()
        self.login()
        assert self.m.delete()
        self.mock_assertions()

    def test_due_on(self):
        json = self.m.to_json().copy()
        json['due_on'] = '2012-12-31T23:59:59Z'
        m = Milestone(json)
        assert isinstance(m.due_on, datetime.datetime)

    def test_iter_labels(self):
        self.response('label', _iter=True)
        self.get(self.api + '/labels')

        i = self.m.iter_labels()
        assert isinstance(i, github3.structs.GitHubIterator)
        assert isinstance((next(i)), Label)
        self.mock_assertions()

    def test_update(self):
        self.response('milestone', 200)
        self.patch(self.api)
        self.conf = {
            'data': {
                'title': 'foo',
                'state': 'closed',
                'description': ':sparkles:',
                'due_on': '2013-12-31T23:59:59Z'
            }
        }

        self.assertRaises(github3.GitHubError, self.m.update, None)

        self.login()
        assert self.m.update(None) is False
        self.not_called()

        assert self.m.update(state='closed')

        assert self.m.update('foo', 'closed', ':sparkles:',
                             '2013-12-31T23:59:59Z')
        self.mock_assertions()


class TestIssue(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestIssue, self).__init__(methodName)
        self.i = Issue(load('issue'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "issues/1")

    def setUp(self):
        super(TestIssue, self).setUp()
        self.i = Issue(self.i.to_json(), self.g)

    def test_equality(self):
        i = Issue(load('issue'))
        assert self.i == i
        i._uniq = 1
        assert self.i != i

    def test_repr(self):
        assert repr(self.i) == '<Issue [sigmavirus24/github3.py #1]>'

    def test_add_labels(self):
        self.response('label', 200, _iter=True)
        self.post(self.api + '/labels')
        self.conf = {'data': '["enhancement"]'}

        self.assertRaises(github3.GitHubError, self.i.add_labels, 'foo')

        self.not_called()
        self.login()
        labels = self.i.add_labels('enhancement')
        assert labels != []
        assert isinstance(labels[0], Label)
        self.mock_assertions()

    def test_assign(self):
        self.assertRaises(github3.GitHubError, self.i.assign, 'foo')

        self.login()

        with mock.patch.object(Issue, 'edit') as ed:
            ed.return_value = True
            assert self.i.assign(None) is False
            self.not_called()
            assert self.i.assign('sigmavirus24')
            n = self.i.milestone.number if self.i.milestone else None
            labels = [str(l) for l in self.i.labels]
            ed.assert_called_once_with(
                self.i.title, self.i.body, 'sigmavirus24', self.i.state, n,
                labels
            )

    def test_close(self):
        self.assertRaises(github3.GitHubError, self.i.close)

        self.not_called()
        self.login()

        with mock.patch.object(Issue, 'edit') as ed:
            ed.return_value = True
            assert self.i.close()
            u = self.i.assignee.login if self.i.assignee else ''
            n = self.i.milestone.number if self.i.milestone else None
            l = [str(label) for label in self.i.labels]
            ed.assert_called_once_with(
                self.i.title, self.i.body, u, self.i.state, n, l
            )

    def test_comment(self):
        self.response('issue_comment')
        self.get(self.api[:-1] + 'comments/476476')

        c = self.i.comment('476476')
        assert isinstance(c, IssueComment)
        assert repr(c).startswith('<Issue Comment')
        self.mock_assertions()

    def test_create_comment(self):
        self.response('issue_comment', 201)
        self.post(self.api + '/comments')
        self.conf = {'data': {'body': 'comment body'}}

        self.assertRaises(github3.GitHubError, self.i.create_comment, '')

        self.login()
        assert self.i.create_comment(None) is None
        self.not_called()

        assert isinstance(self.i.create_comment('comment body'), IssueComment)
        self.mock_assertions()

    def test_edit(self):
        self.response('issue', 200)
        self.patch(self.api)
        self.conf = {'data': {'title': 'new title', 'milestone': None}}

        self.assertRaises(github3.GitHubError, self.i.edit)

        self.login()
        assert self.i.edit() is False
        self.not_called()

        assert self.i.edit('new title', milestone=0)
        self.mock_assertions()

    def test_is_closed(self):
        assert self.i.is_closed()

        self.i.closed_at = None
        assert self.i.is_closed()

        self.i.state = 'open'
        assert self.i.is_closed() is False

    def test_iter_comments(self):
        self.response('issue_comment', _iter=True)
        self.get(self.api + '/comments')

        assert isinstance((next(self.i.iter_comments())), IssueComment)
        self.mock_assertions()

    def test_iter_events(self):
        self.response('issue_event', _iter=True)
        self.get(self.api + '/events')

        e = next(self.i.iter_events())
        assert isinstance(e, IssueEvent)
        assert repr(e).startswith('<Issue Event')
        self.mock_assertions()

    def test_remove_label(self):
        self.response('', 204)
        self.delete(self.api + '/labels/name')

        self.assertRaises(github3.GitHubError, self.i.remove_label, 'name')

        self.not_called()
        self.login()
        assert self.i.remove_label('name')
        self.mock_assertions()

    def test_remove_all_labels(self):
        self.assertRaises(github3.GitHubError, self.i.remove_all_labels)

        self.login()

        with mock.patch.object(Issue, 'replace_labels') as rl:
            rl.return_value = []
            assert self.i.remove_all_labels() == []
            rl.assert_called_once_with([])

    def test_replace_labels(self):
        self.response('label', _iter=True)
        self.put(self.api + '/labels')
        self.conf = {'data': '["foo", "bar"]'}

        self.assertRaises(github3.GitHubError, self.i.replace_labels, [])

        self.not_called()
        self.login()

        labels = self.i.replace_labels(['foo', 'bar'])
        assert labels != []
        assert isinstance(labels[0], Label)

    def test_reopen(self):
        self.assertRaises(github3.GitHubError, self.i.reopen)

        self.login()
        n = self.i.milestone.number if self.i.milestone else None
        u = self.i.assignee.login if self.i.assignee else None

        with mock.patch.object(Issue, 'edit') as ed:
            ed.return_value = True
            assert self.i.reopen()
            labels = [str(l) for l in self.i.labels]
            ed.assert_called_once_with(
                self.i.title, self.i.body, u, 'open', n, labels
            )

    def test_enterprise(self):
        Issue(load('issue_enterprise'))

    def test_issue_137(self):
        """
        GitHub sometimes returns `pull` as part of of the `html_url` for Issue
        requests.
        """
        i = Issue(load('issue_137'))
        self.assertEqual(
            i.html_url,
            "https://github.com/sigmavirus24/github3.py/pull/1")
        self.assertEqual(i.repository, ("sigmavirus24", "github3.py"))


class TestIssueEvent(BaseCase):
    def setUp(self):
        super(TestIssueEvent, self).setUp()
        self.ev = IssueEvent(load('issue_event'))

    def test_repr(self):
        assert repr(self.ev) == '<Issue Event [{0} by {1}]>'.format(
            'closed', 'sigmavirus24'
        )

    def test_equality(self):
        e = IssueEvent(load('issue_event'))
        assert self.ev == e
        e._uniq = 'fake'
        assert self.ev != e

########NEW FILE########
__FILENAME__ = test_issue_authorize_optional_scope
import github3
from tests.utils import BaseCase

"""
http://github3py.readthedocs.org/en/0.7.0/github.html#github3.github.GitHub
says scopes are required to create an authorization.

http://developer.github.com/v3/oauth/#create-a-new-authorization (at time of
writing - 2013-09-06) disagrees
"""


class TestOptionalScope(BaseCase):
    def test_authorize_with_scope(self):
        """ Copypasted from TestGitHub """

        self.response('authorization', 201)
        scopes = ['scope1', 'scope2']

        self.g.authorize(None, None, scopes)
        self.not_called()

        a = self.g.authorize('user', 'password', scopes)
        assert isinstance(a, github3.auths.Authorization)
        assert self.request.called is True

        self.request.reset_mock()

        self.login()
        a = self.g.authorize(None, None, scopes=scopes)

    def test_authorize_without_scope(self):
        self.response('authorization', 201)

        self.g.authorize(None, None)
        self.not_called()

        a = self.g.authorize('user', 'password')
        assert isinstance(a, github3.auths.Authorization)
        assert self.request.called is True

        self.request.reset_mock()

        self.login()
        a = self.g.authorize(None, None)

########NEW FILE########
__FILENAME__ = test_models
from datetime import timedelta
import github3
import requests
from tests.utils import BaseCase, TestCase, RequestsBytesIO, is_py3


class TestGitHubObject(TestCase):
    def test_from_json(self):
        o = github3.models.GitHubObject.from_json({})
        assert isinstance(o, github3.models.GitHubObject)


class TestGitHubCore(BaseCase):
    def setUp(self):
        super(TestGitHubCore, self).setUp()
        self.g = github3.models.GitHubCore({})

    def test_repr(self):
        g = self.g
        assert repr(g) == '<github3-core at 0x{0:x}>'.format(id(g))

    def test_json(self):
        r = requests.Response()
        r.headers['Last-Modified'] = 'foo'
        r.headers['ETag'] = 'bar'
        r.raw = RequestsBytesIO('{}'.encode() if is_py3 else '{}')
        r.status_code = 200

        json = self.g._json(r, 200)
        assert json['Last-Modified'] == 'foo'
        assert json['ETag'] == 'bar'

    def test_boolean(self):
        r = requests.Response()
        r.status_code = 512
        r.raw = RequestsBytesIO('{}'.encode() if is_py3 else '{}')

        self.assertRaises(github3.GitHubError, self.g._boolean, r, 200, 404)

    def test_strptime(self):
        dt = self.g._strptime('2013-06-18T19:53:04Z')
        assert dt.tzname() == 'UTC'
        assert dt.dst() == timedelta(0)
        assert dt.utcoffset() == timedelta(0)


class TestGitHubError(TestCase):
    def __init__(self, methodName='runTest'):
        super(TestGitHubError, self).__init__(methodName)
        self.r = requests.Response()
        self.r.status_code = 400
        message = '{"message": "m", "errors": ["e"]}'
        self.r.raw = RequestsBytesIO(message.encode() if is_py3 else message)
        self.error = github3.models.GitHubError(self.r)

    def test_repr(self):
        assert repr(self.error) == '<GitHubError [m]>'

    def test_str(self):
        assert str(self.error) == '400 m'

    def test_message(self):
        assert self.error.message == self.error.msg

    def test_amazon(self):
        r = requests.Response()
        r.status_code = 400
        r.raw = RequestsBytesIO()
        e = github3.models.GitHubError(r)
        assert e.message == '[No message]'

########NEW FILE########
__FILENAME__ = test_notifications
import github3
import datetime
from tests.utils import BaseCase, load


class TestThread(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestThread, self).__init__(methodName)
        self.thread = github3.notifications.Thread(load('notification'))
        self.api = ("https://api.github.com/notifications/threads/6169361")

    def test_equality(self):
        t = github3.notifications.Thread(load('notification'))
        assert self.thread == t
        t._uniq = 1
        assert self.thread != t

    def test_last_read_at(self):
        json = self.thread.to_json().copy()
        json['last_read_at'] = '2013-12-31T23:59:59Z'
        t = github3.notifications.Thread(json)
        assert isinstance(t.last_read_at, datetime.datetime)

    def test_repr(self):
        assert repr(self.thread) == '<Thread [{0}]>'.format(
            self.thread.subject.get('title'))

    def test_delete_subscription(self):
        self.response('', 204)
        self.delete(self.api + '/subscription')

        assert self.thread.delete_subscription()
        self.mock_assertions()

    def test_is_unread(self):
        assert self.thread.is_unread() == self.thread.unread

    def test_mark(self):
        self.response('', 205)
        self.patch(self.api)
        self.conf = {}

        assert self.thread.mark()
        self.mock_assertions()

    def test_set_subscription(self):
        self.response('subscription')
        self.put(self.api + '/subscription')
        self.conf = {'data': {'subscribed': True, 'ignored': False}}

        assert isinstance(self.thread.set_subscription(True, False),
                          github3.notifications.Subscription)
        self.mock_assertions()

    def test_subscription(self):
        self.response('subscription')
        self.get(self.api + '/subscription')

        assert isinstance(self.thread.subscription(),
                          github3.notifications.Subscription)
        self.mock_assertions()


class TestSubscription(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestSubscription, self).__init__(methodName)
        self.subscription = github3.notifications.Subscription(
            load('subscription'))
        self.api = ("https://api.github.com/notifications/threads/5864188/"
                    "subscription")

    def test_repr(self):
        assert isinstance(repr(self.subscription), str)

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        assert self.subscription.delete()
        self.mock_assertions()

    def test_is_ignored(self):
        assert self.subscription.is_ignored() == self.subscription.ignored

    def test_is_subscription(self):
        subbed = self.subscription.is_subscribed()
        assert subbed == self.subscription.subscribed

    def test_set(self):
        self.response('subscription')
        self.put(self.api)
        self.conf = {'data': {'subscribed': True, 'ignored': False}}

        assert self.subscription.set(True, False) is None
        self.mock_assertions()

########NEW FILE########
__FILENAME__ = test_orgs
import github3
from tests.utils import BaseCase, load, mock


class TestTeam(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestTeam, self).__init__(methodName)
        self.team = github3.orgs.Team(load('team'))
        self.api = "https://api.github.com/teams/190009"

    def setUp(self):
        super(TestTeam, self).setUp()
        self.team = github3.orgs.Team(self.team.to_json(), self.g)

    def test_repr(self):
        assert repr(self.team).startswith('<Team')

    def test_equality(self):
        t = github3.orgs.Team(load('team'))
        assert self.team == t
        t._uniq = 'foo'
        assert self.team != t

    def test_add_member(self):
        self.response('', 204)
        self.put(self.api + '/members/foo')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.team.add_member, 'foo')

        self.not_called()
        self.login()
        assert self.team.add_member('foo')
        self.mock_assertions()

    def test_add_repo(self):
        self.response('', 204)
        self.put(self.api + '/repos/repo')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.team.add_repo, 'repo')

        self.not_called()
        self.login()
        assert self.team.add_repo('repo')
        self.mock_assertions()

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.team.delete)

        self.not_called()
        self.login()
        assert self.team.delete()
        self.mock_assertions()

    def test_edit(self):
        self.response('team', 200)
        self.patch(self.api)
        self.conf = {'data': {'name': 'Collab', 'permission': 'admin'}}

        self.assertRaises(github3.GitHubError, self.team.edit, None)

        self.login()
        assert self.team.edit(None) is False
        self.not_called()

        assert self.team.edit('Collab', 'admin')
        self.mock_assertions()

    def test_has_repo(self):
        self.response('', 204)
        self.get(self.api + '/repos/repo')

        assert self.team.has_repo('repo')
        self.mock_assertions()

    def test_is_member(self):
        self.response('', 404)
        self.get(self.api + '/members/user')

        assert self.team.is_member('user') is False
        self.mock_assertions()

    def test_iter_members(self):
        self.response('user', _iter=True)
        self.get(self.api + '/members')

        assert isinstance(next(self.team.iter_members()), github3.users.User)
        self.mock_assertions()

    def test_iter_repos(self):
        self.response('repo', _iter=True)
        self.get(self.api + '/repos')

        assert isinstance(next(self.team.iter_repos()),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_remove_member(self):
        self.response('', 204)
        self.delete(self.api + '/members/user')

        self.assertRaises(github3.GitHubError, self.team.remove_member, None)

        self.not_called()
        self.login()
        assert self.team.remove_member('user')
        self.mock_assertions()

    def test_remove_repo(self):
        self.response('', 204)
        self.delete(self.api + '/repos/repo')

        self.assertRaises(github3.GitHubError, self.team.remove_repo, None)

        self.not_called()
        self.login()
        assert self.team.remove_repo('repo')
        self.mock_assertions()


class TestOrganization(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestOrganization, self).__init__(methodName)
        self.org = github3.orgs.Organization(load('org'))
        self.api = "https://api.github.com/orgs/github3py"

    def setUp(self):
        super(TestOrganization, self).setUp()
        self.org = github3.orgs.Organization(self.org.to_json(), self.g)

    def test_repr(self):
        assert repr(self.org).startswith('<Organization ')

    def test_set_type(self):
        json = self.org.to_json().copy()
        del json['type']
        o = github3.orgs.Organization(json)
        assert o.type == 'Organization'

    def test_add_member(self):
        self.assertRaises(github3.GitHubError, self.org.add_member, None, None)

        self.login()
        with mock.patch.object(github3.orgs.Organization, 'iter_teams') as it:
            it.return_value = iter([])
            assert self.org.add_member('foo', 'bar') is False
            team = mock.Mock()
            team.name = 'bar'
            team.add_member.return_value = True
            it.return_value = iter([team])
            assert self.org.add_member('foo', 'bar')
            team.add_member.assert_called_once_with('foo')

    def test_add_repo(self):
        self.assertRaises(github3.GitHubError, self.org.add_repo, None, None)

        self.login()
        with mock.patch.object(github3.orgs.Organization, 'iter_teams') as it:
            it.return_value = iter([])
            assert self.org.add_repo('foo', 'bar') is False
            team = mock.Mock()
            team.name = 'bar'
            team.add_repo.return_value = True
            it.return_value = iter([team])
            assert self.org.add_repo('foo', 'bar')
            team.add_repo.assert_called_once_with('foo')

    def test_create_repo(self):
        self.response('repo', 201)
        self.post(self.api + '/repos')
        self.conf = {
            'data': {
                'name': 'repo',
                'description': 'desc',
                'homepage': '',
                'private': False,
                'has_issues': True,
                'has_wiki': True,
                'has_downloads': True,
                'auto_init': False,
                'team_id': 1,
                'gitignore_template': '',
            }
        }

        self.assertRaises(github3.GitHubError, self.org.create_repo, None)

        self.not_called()
        self.login()
        assert isinstance(self.org.create_repo('repo', 'desc', team_id=1),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_conceal_member(self):
        self.response('', 204)
        self.delete(self.api + '/public_members/user')

        self.assertRaises(github3.GitHubError, self.org.conceal_member, None)

        self.not_called()
        self.login()
        assert self.org.conceal_member('user')
        self.mock_assertions()

    def test_create_team(self):
        self.response('team', 201)
        self.post(self.api + '/teams')
        self.conf = {
            'data': {
                'name': 'team',
                'repo_names': [],
                'permission': 'push'
            }
        }

        self.assertRaises(github3.GitHubError, self.org.create_team, None)

        self.not_called()
        self.login()
        assert isinstance(self.org.create_team('team', permission='push'),
                          github3.orgs.Team)
        self.mock_assertions()

    def test_edit(self):
        self.response('org', 200)
        self.patch(self.api)
        self.conf = {
            'data': {
                'billing_email': 'foo',
                'company': 'foo',
                'email': 'foo',
                'location': 'foo',
                'name': 'foo',
            }
        }

        self.assertRaises(github3.GitHubError, self.org.edit)

        self.login()
        assert self.org.edit() is False
        self.not_called()

        assert self.org.edit('foo', 'foo', 'foo', 'foo', 'foo')
        self.mock_assertions()

    def test_is_member(self):
        self.response('', 404)
        self.get(self.api + '/members/user')

        assert self.org.is_member('user') is False
        self.mock_assertions()

    def test_is_public_member(self):
        self.response('', 204)
        self.get(self.api + '/public_members/user')

        assert self.org.is_public_member('user') is True
        self.mock_assertions()

    def test_iter_events(self):
        self.response('event', _iter=True)
        self.get(self.api + '/events')

        assert isinstance(next(self.org.iter_events()), github3.events.Event)
        self.mock_assertions()

    def test_iter_members(self):
        self.response('user', _iter=True)
        self.get(self.api + '/members')

        assert isinstance(next(self.org.iter_members()), github3.users.User)
        self.mock_assertions()

    def test_iter_public_members(self):
        self.response('user', _iter=True)
        self.get(self.api + '/public_members')

        assert isinstance(next(self.org.iter_public_members()),
                          github3.users.User)
        self.mock_assertions()

    def test_iter_repos(self):
        self.response('repo', _iter=True)
        self.get(self.api + '/repos')
        self.conf = {'params': {'per_page': 100}}

        assert isinstance(next(self.org.iter_repos()),
                          github3.repos.Repository)
        self.mock_assertions()

        assert isinstance(next(self.org.iter_repos('foo')),
                          github3.repos.Repository)
        self.mock_assertions()

        self.conf['params'] = {'type': 'all', 'per_page': 100}
        assert isinstance(next(self.org.iter_repos('all')),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_iter_teams(self):
        self.response('team', _iter=True)
        self.get(self.api + '/teams')

        self.assertRaises(github3.GitHubError, self.org.iter_teams)

        self.not_called()
        self.login()
        assert isinstance(next(self.org.iter_teams()), github3.orgs.Team)
        self.mock_assertions()

    def test_publicize_member(self):
        self.response('', 204)
        self.put(self.api + '/public_members/user')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.org.publicize_member, None)

        self.login()
        assert self.org.publicize_member('user')
        self.mock_assertions()

    def test_remove_member(self):
        self.response('', 404)
        self.delete(self.api + '/members/user')

        self.assertRaises(github3.GitHubError, self.org.remove_member, None)

        self.not_called()
        self.login()
        assert self.org.remove_member('user') is False
        self.mock_assertions()

    def test_remove_repo(self):
        self.assertRaises(github3.GitHubError, self.org.remove_repo,
                          None, None)

        self.login()
        with mock.patch.object(github3.orgs.Organization, 'iter_teams') as it:
            it.return_value = iter([])
            assert self.org.remove_repo('foo', 'bar') is False
            team = mock.Mock()
            team.name = 'bar'
            team.remove_repo.return_value = True
            it.return_value = iter([team])
            assert self.org.remove_repo('foo', 'bar') is True
            team.remove_repo.assert_called_once_with('foo')

    def test_team(self):
        self.response('team')
        self.get(self.github_url + 'teams/1')

        self.assertRaises(github3.GitHubError, self.org.team, 0)

        self.login()
        assert self.org.team(-1) is None
        self.not_called()

        assert isinstance(self.org.team(1), github3.orgs.Team)
        self.mock_assertions()

    def test_equality(self):
        assert self.org == github3.orgs.Organization(load('org'))

########NEW FILE########
__FILENAME__ = test_pulls
import github3
from tests.utils import BaseCase, load, mock


class TestPullRequest(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestPullRequest, self).__init__(methodName)
        self.pull = github3.pulls.PullRequest(load('pull'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "pulls/18")

    def setUp(self):
        super(TestPullRequest, self).setUp()
        self.pull = github3.pulls.PullRequest(self.pull.to_json(), self.g)

    def test_equality(self):
        p = github3.pulls.PullRequest(load('pull'))
        assert self.pull == p
        p._uniq = 'foo'
        assert self.pull != p

    def test_hashing(self):
        p = github3.pulls.PullRequest(load('pull'))
        s = set()
        s.add(p)
        s.add(p)
        assert len(s) == 1

    def test_dest(self):
        assert repr(self.pull.base).startswith('<Base')

    def test_repr(self):
        assert repr(self.pull).startswith('<Pull Request')

    def test_close(self):
        self.assertRaises(github3.GitHubError, self.pull.close)

        self.login()

        with mock.patch.object(github3.pulls.PullRequest, 'update') as up:
            up.return_value = True
            assert self.pull.close()
            up.assert_called_once_with(
                self.pull.title, self.pull.body, 'closed')

    def test_diff(self):
        self.response('archive')
        self.get(self.api)
        self.conf = {
            'headers': {
                'Accept': 'application/vnd.github.diff'
            }
        }

        assert self.pull.diff() != ''
        self.mock_assertions()

    def test_is_merged(self):
        self.response('', 204)
        self.get(self.api + '/merge')

        assert self.pull.is_merged()
        self.mock_assertions()

        self.response('', 404)
        assert self.pull.is_merged() is False
        self.mock_assertions()

    def test_iter_comments(self):
        self.response('review_comment', _iter=True)
        self.get(self.api + '/comments')

        c = next(self.pull.iter_comments())
        assert isinstance(c, github3.pulls.ReviewComment)
        self.mock_assertions()

        assert repr(c).startswith('<Review Comment')

    def test_iter_issue_comments(self):
        pull = github3.pulls.PullRequest(load('pull19'))
        self.response('pull19_comment', _iter=True)
        self.get(pull.links['comments'])

        c = next(pull.iter_issue_comments())
        assert isinstance(c, github3.issues.comment.IssueComment)
        self.mock_assertions()

        assert repr(c).startswith('<Issue Comment')

    def test_iter_comits(self):
        self.response('commit', _iter=True)
        self.get(self.api + '/commits')

        assert isinstance(next(self.pull.iter_commits()), github3.git.Commit)
        self.mock_assertions()

    def test_iter_files(self):
        self.response('pull_file', _iter=True)
        self.get(self.api + '/files')

        f = next(self.pull.iter_files())
        assert isinstance(f, github3.pulls.PullFile)
        self.mock_assertions()

        assert repr(f).startswith('<Pull Request File')

    def test_merge(self):
        self.response('merge', 200)
        self.put(self.api + '/merge')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.pull.merge)

        self.not_called()
        self.login()
        assert self.pull.merge()
        self.mock_assertions()

        self.conf['data'] = {'commit_message': 'Merged'}
        assert self.pull.merge('Merged')
        self.mock_assertions()

    def test_patch(self):
        self.response('archive', 200)
        self.get(self.api)
        self.conf = {'headers': {'Accept': 'application/vnd.github.patch'}}

        assert self.pull.patch() != ''
        self.mock_assertions()

    def test_reopen(self):
        self.assertRaises(github3.GitHubError, self.pull.reopen)

        self.login()
        with mock.patch.object(github3.pulls.PullRequest, 'update') as up:
            self.pull.reopen()
            up.assert_called_once_with(
                self.pull.title, self.pull.body, 'open')

    def test_update(self):
        self.response('pull', 200)
        self.patch(self.api)
        self.conf = {'data': {'title': 't', 'body': 'b', 'state': 'open'}}

        self.assertRaises(github3.GitHubError, self.pull.update)

        self.login()
        assert self.pull.update() is False
        self.not_called()

        assert self.pull.update('t', 'b', 'open')
        self.mock_assertions()

    def test_enterprise(self):
        github3.pulls.PullRequest(load('pull_enterprise'))

    def test_pull_request_issues(self):
        pr = github3.pulls.PullRequest(load('pull_request'))
        self.assertEqual(pr.issue_url,
                         'https://github.com/sigmavirus24/github3.py/pull/135')

########NEW FILE########
__FILENAME__ = test_repos
import os
import github3
from github3 import repos
from datetime import datetime
from tests.utils import (BaseCase, load, mock)


class TestRepository(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestRepository, self).__init__(methodName)
        self.repo = repos.Repository(load('repo'))

    def setUp(self):
        super(TestRepository, self).setUp()
        self.repo = repos.Repository(self.repo.to_json(), self.g)
        self.api = 'https://api.github.com/repos/sigmavirus24/github3.py/'

    def test_add_collaborator(self):
        self.response('', 204)
        self.put(self.api + 'collaborators/sigmavirus24')
        self.conf = {'data': None}

        self.assertRaises(github3.GitHubError, self.repo.add_collaborator,
                          'foo')

        self.login()
        assert self.repo.add_collaborator(None) is False
        assert self.repo.add_collaborator('sigmavirus24')
        self.mock_assertions()

    def test_archive(self):
        headers = {'content-disposition': 'filename=foo'}
        self.response('archive', 200, **headers)
        self.get(self.api + 'tarball/master')
        self.conf.update({'stream': True})

        assert self.repo.archive(None) is False

        assert os.path.isfile('foo') is False
        assert self.repo.archive('tarball')
        assert os.path.isfile('foo')
        os.unlink('foo')
        self.mock_assertions()

        self.request.return_value.raw.seek(0)
        self.request.return_value._content_consumed = False

        assert os.path.isfile('path_to_file') is False
        assert self.repo.archive('tarball', 'path_to_file')
        assert os.path.isfile('path_to_file')
        os.unlink('path_to_file')

        self.request.return_value.raw.seek(0)
        self.request.return_value._content_consumed = False

        self.get(self.api + 'zipball/randomref')
        assert self.repo.archive('zipball', ref='randomref')
        os.unlink('foo')

        self.request.return_value.raw.seek(0)
        self.request.return_value._content_consumed = False

        o = mock.mock_open()
        with mock.patch('{0}.open'.format(__name__), o, create=True):
            with open('archive', 'wb+') as fd:
                self.repo.archive('tarball', fd)

        o.assert_called_once_with('archive', 'wb+')
        fd = o()
        fd.write.assert_called_once_with(b'archive_data')

    def test_blob(self):
        self.response('blob')
        sha = '3ceb856e2f14e9669fed6384e58c9a1590a2314f'
        self.get(self.api + 'git/blobs/' + sha)

        blob = self.repo.blob(sha)
        assert isinstance(blob, github3.git.Blob)
        assert repr(blob).startswith('<Blob')
        self.mock_assertions()

    def test_branch(self):
        self.response('branch')
        self.get(self.api + 'branches/master')

        b = self.repo.branch('master')
        assert isinstance(b, repos.branch.Branch)
        self.mock_assertions()

        assert repr(b) == '<Repository Branch [master]>'

    def test_commit(self):
        self.response('commit')
        sha = '76dcc6cb4b9860034be81b7e58adc286a115aa97'
        self.get(self.api + 'commits/' + sha)

        assert isinstance(self.repo.commit(sha), repos.commit.RepoCommit)
        self.mock_assertions()

    def test_commit_comment(self):
        self.response('commit_comment')
        comment_id = 1380832
        self.get(self.api + 'comments/{0}'.format(comment_id))

        assert isinstance(self.repo.commit_comment(comment_id),
                          repos.comment.RepoComment)
        self.mock_assertions()

    def test_compare_commits(self):
        self.response('comparison')
        base = 'a811e1a270f65eecb65755eca38d888cbefcb0a7'
        head = '76dcc6cb4b9860034be81b7e58adc286a115aa97'
        self.get(self.api + 'compare/{0}...{1}'.format(base, head))

        assert isinstance(self.repo.compare_commits(base, head),
                          repos.comparison.Comparison)
        self.mock_assertions()

    def test_contents(self):
        self.response('contents')
        filename = 'setup.py'
        self.get(self.api + 'contents/' + filename)

        assert isinstance(self.repo.contents(filename),
                          repos.contents.Contents)
        self.mock_assertions()

        self.response('', 404)
        assert self.repo.contents(filename) is None

        self.response('contents', _iter=True)
        files = self.repo.contents(filename)
        assert isinstance(files, dict)

        self.mock_assertions()

    def test_contents_ref(self):
        self.response('contents')
        filename = 'setup.py'
        self.get(self.api + 'contents/' + filename)
        self.conf = {'params': {'ref': 'foo'}}

        assert isinstance(self.repo.contents(filename, ref='foo'),
                          repos.contents.Contents)
        self.mock_assertions()

    def test_create_blob(self):
        self.response('blob', 201)
        content = 'VGVzdCBibG9i\n'
        encoding = 'base64'
        sha = '30f2c645388832f70d37ab2b47eb9ea527e5ae7c'
        self.post(self.api + 'git/blobs')
        self.conf = {'data': {'content': content, 'encoding': encoding}}

        self.assertRaises(github3.GitHubError, self.repo.create_blob,
                          content, encoding)

        self.login()
        assert self.repo.create_blob(None, None) == ''
        assert self.repo.create_blob(content, encoding) == sha
        self.mock_assertions()

    def test_create_comment(self):
        self.response('commit_comment', 201)
        body = ('Late night commits are never a good idea. I refactored a '
                'bit. `User` objects and `Organization` objects share a lot '
                'of common attributes. I turned those common attributes into '
                'one `BaseAccount` class to make things simpler. ')
        sha = 'd41566090114a752eb3a87dbcf2473eb427ef0f3'
        self.post(self.api + 'commits/{0}/comments'.format(sha))
        self.conf = {'data': {'body': body, 'line': 1}}

        self.assertRaises(github3.GitHubError, self.repo.create_comment,
                          body, sha)

        self.login()
        assert self.repo.create_comment(None, None) is None
        assert self.repo.create_comment(body, sha, line=0) is None
        assert isinstance(self.repo.create_comment(body, sha),
                          repos.comment.RepoComment)
        self.mock_assertions()

    def test_create_commit(self):
        self.response('commit', 201)
        data = {'message': 'My commit message',
                'author': {
                    'name': 'Ian Cordasco',
                    'email': 'foo@example.com',
                    'date': '2008-07-09T16:13:30+12:00',
                },
                'committer': {},
                'parents': [
                    '7d1b31e74ee336d15cbd21741bc88a537ed063a0'
                ],
                'tree': '827efc6d56897b048c772eb4087f854f46256132',
                }
        self.conf = {'data': data}
        self.post(self.api + 'git/commits')

        self.assertRaises(github3.GitHubError, self.repo.create_commit, **data)

        self.login()
        assert self.repo.create_commit(None, None, None) is None
        assert isinstance(self.repo.create_commit(**data), github3.git.Commit)
        self.mock_assertions()

    def test_create_fork(self):
        self.response('repo', 202)
        self.conf = {'data': None}
        self.post(self.api + 'forks')

        self.assertRaises(github3.GitHubError, self.repo.create_fork)

        self.login()
        assert isinstance(self.repo.create_fork(), repos.Repository)
        self.mock_assertions()

        self.conf['data'] = {'organization': 'github3py'}
        assert isinstance(self.repo.create_fork('github3py'), repos.Repository)
        self.mock_assertions()

    def test_create_hook(self):
        self.response('hook', 201)
        self.post(self.api + 'hooks')
        self.conf = {
            'data': {
                'name': 'Hookname',
                'config': {
                    'foo': 'bar'
                }
            }
        }

        self.assertRaises(github3.GitHubError, self.repo.create_hook,
                          None, None)

        self.login()
        assert self.repo.create_hook(None, {'foo': 'bar'}) is None
        assert self.repo.create_hook('name', None) is None
        assert self.repo.create_hook('name', 'bar') is None
        self.not_called()

        h = self.repo.create_hook(**self.conf['data'])
        assert isinstance(h, repos.hook.Hook)
        self.mock_assertions()

    def test_create_issue(self):
        self.response('issue', 201)
        title = 'Construct _api attribute on our own'
        self.post(self.api + 'issues')
        self.conf = {'data': {'title': title}}

        self.assertRaises(github3.GitHubError, self.repo.create_issue, title)

        self.login()
        assert self.repo.create_issue(None) is None
        assert isinstance(self.repo.create_issue(title), github3.issues.Issue)
        self.mock_assertions()

        body = 'Fake body'
        #self.conf['data'].update(body=body)
        assert isinstance(self.repo.create_issue(title, body),
                          github3.issues.Issue)
        self.mock_assertions()

        assignee, mile, labels = 'sigmavirus24', 1, ['bug', 'enhancement']
        #self.conf['data'].update({'assignee': assignee, 'milestone': mile,
        #                          'labels': labels})
        issue = self.repo.create_issue(title, body, assignee, mile, labels)
        assert isinstance(issue, github3.issues.Issue)
        self.mock_assertions()

    def test_create_key(self):
        self.response('key', 201)
        self.post(self.api + 'keys')
        self.conf = {'data': {'key': 'ssh-rsa foobarbogus',
                              'title': 'Fake key'}}

        self.assertRaises(github3.GitHubError, self.repo.create_key,
                          **self.conf['data'])

        self.login()
        assert self.repo.create_key(None, None) is None
        self.not_called()
        assert isinstance(self.repo.create_key(**self.conf['data']),
                          github3.users.Key)
        self.mock_assertions()

    def test_create_label(self):
        self.response('label', 201)
        self.post(self.api + 'labels')
        self.conf = {'data': {'name': 'foo', 'color': 'f00f00'}}

        self.assertRaises(github3.GitHubError, self.repo.create_label,
                          **self.conf['data'])

        self.login()
        assert self.repo.create_label(None, None) is None
        self.not_called()
        assert isinstance(self.repo.create_label(**self.conf['data']),
                          github3.issues.label.Label)
        self.mock_assertions()

    def test_create_milestone(self):
        self.response('milestone', 201)
        self.post(self.api + 'milestones')
        self.conf = {'data': {'title': 'foo'}}

        self.assertRaises(github3.GitHubError, self.repo.create_milestone,
                          **self.conf['data'])

        self.login()
        assert self.repo.create_milestone(None) is None
        self.not_called()
        assert isinstance(self.repo.create_milestone('foo'),
                          github3.issues.milestone.Milestone)
        self.mock_assertions()

    def test_create_pull(self):
        self.response('pull', 201)
        self.post(self.api + 'pulls')
        self.conf = {'data': {'title': 'Fake title', 'base': 'master',
                              'head': 'feature_branch'}}

        self.assertRaises(github3.GitHubError, self.repo.create_pull,
                          **self.conf['data'])

        self.login()
        assert self.repo.create_pull(None, None, None) is None
        self.not_called()
        assert isinstance(self.repo.create_pull(**self.conf['data']),
                          github3.pulls.PullRequest)
        self.mock_assertions()

    def test_create_pull_from_issue(self):
        self.response('pull', 201)
        self.post(self.api + 'pulls')
        self.conf = {'data': {'issue': 1, 'base': 'master',
                              'head': 'feature_branch'}}

        self.assertRaises(github3.GitHubError,
                          self.repo.create_pull_from_issue,
                          **self.conf['data'])

        self.login()
        assert self.repo.create_pull_from_issue(0, 'foo', 'bar') is None
        self.not_called()
        pull = self.repo.create_pull_from_issue(**self.conf['data'])
        assert isinstance(pull, github3.pulls.PullRequest)
        self.mock_assertions()

    def test_create_ref(self):
        self.response('ref', 201)
        self.post(self.api + 'git/refs')
        self.conf = {'data': {'ref': 'refs/heads/master', 'sha': 'fakesha'}}

        self.assertRaises(github3.GitHubError, self.repo.create_ref,
                          'foo', 'bar')

        self.login()
        assert self.repo.create_ref('foo/bar', None) is None
        assert isinstance(self.repo.create_ref(**self.conf['data']),
                          github3.git.Reference)
        self.mock_assertions()

    def test_create_status(self):
        self.response('status', 201)
        self.post(self.api + 'statuses/fakesha')
        self.conf = {'data': {'state': 'success'}}

        self.assertRaises(github3.GitHubError, self.repo.create_status,
                          'fakesha', 'success')

        self.login()
        assert self.repo.create_status(None, None) is None
        s = self.repo.create_status('fakesha', 'success')
        assert isinstance(s, repos.status.Status)
        assert repr(s) > ''
        self.mock_assertions()

    def test_create_tag(self):
        self.response('tag', 201)
        self.post(self.api + 'git/tags')
        data = {
            'tag': '0.3', 'message': 'Fake message', 'object': 'fakesha',
            'type': 'commit', 'tagger': {
                'name': 'Ian Cordasco', 'date': 'Not a UTC date',
                'email': 'graffatcolmingov@gmail.com'
            }
        }
        self.conf = {'data': data.copy()}
        data['obj_type'] = data['type']
        data['sha'] = data['object']
        del(data['type'], data['object'])

        self.assertRaises(github3.GitHubError, self.repo.create_tag,
                          None, None, None, None, None)

        self.login()
        with mock.patch.object(repos.Repository, 'create_ref'):
            assert self.repo.create_tag(None, None, None, None,
                                        None) is None
            tag = self.repo.create_tag(**data)
            assert isinstance(tag, github3.git.Tag)
            assert repr(tag).startswith('<Tag')
        self.mock_assertions()

        with mock.patch.object(repos.Repository, 'create_ref') as cr:
            self.repo.create_tag('tag', '', 'fakesha', '', '',
                                 lightweight=True)
            cr.assert_called_once_with('refs/tags/tag', 'fakesha')

    def test_create_tree(self):
        self.response('tree', 201)
        self.post(self.api + 'git/trees')
        data = {'tree': [{'path': 'file1', 'mode': '100755',
                          'type': 'tree',
                          'sha': '75b347329e3fc87ac78895ca1be58daff78872a1'}],
                'base_tree': ''}
        self.conf = {'data': data}

        self.assertRaises(github3.GitHubError, self.repo.create_tree, **data)

        self.login()
        assert self.repo.create_tree(None) is None
        assert self.repo.create_tree({'foo': 'bar'}) is None
        self.not_called()
        assert isinstance(self.repo.create_tree(**data), github3.git.Tree)
        self.mock_assertions()

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api[:-1])
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.repo.delete)

        self.login()
        assert self.repo.delete()
        self.mock_assertions()

    def test_delete_key(self):
        self.response('', 204)
        self.delete(self.api + 'keys/2')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.repo.delete_key, 2)

        self.login()
        assert self.repo.delete_key(-2) is False
        self.not_called()
        assert self.repo.delete_key(2)
        self.mock_assertions()

    def test_delete_subscription(self):
        self.response('', 204)
        self.delete(self.api + 'subscription')

        self.assertRaises(github3.GitHubError, self.repo.delete_subscription)
        self.not_called()

        self.login()
        assert self.repo.delete_subscription()
        self.mock_assertions()

    def test_edit(self):
        self.response('repo')
        self.patch(self.api[:-1])
        self.conf = {'data': {'name': 'foo'}}

        self.assertRaises(github3.GitHubError, self.repo.edit, 'Foo')

        self.login()
        assert self.repo.edit(None) is False
        self.not_called()
        assert self.repo.edit('foo')
        self.mock_assertions()

        self.conf['data']['description'] = 'bar'
        assert self.repo.edit(**self.conf['data'])
        self.mock_assertions()

    def test_is_collaborator(self):
        self.response('', 204)
        self.get(self.api + 'collaborators/user')

        assert self.repo.is_collaborator(None) is False
        self.not_called()
        assert self.repo.is_collaborator('user')
        self.mock_assertions()

    def test_git_commit(self):
        self.response('git_commit')
        self.get(self.api + 'git/commits/fakesha')

        assert self.repo.git_commit(None) is None
        self.not_called()
        assert isinstance(self.repo.git_commit('fakesha'), github3.git.Commit)
        self.mock_assertions()

    def test_hook(self):
        self.response('hook')
        self.get(self.api + 'hooks/2')

        self.assertRaises(github3.GitHubError, self.repo.hook, 2)

        self.login()
        assert self.repo.hook(-2) is None
        self.not_called()
        assert isinstance(self.repo.hook(2), repos.hook.Hook)
        self.mock_assertions()

    def test_is_assignee(self):
        self.response('', 204)
        self.get(self.api + 'assignees/login')

        assert self.repo.is_assignee(None) is False
        self.not_called()
        assert self.repo.is_assignee('login')
        self.mock_assertions()

    def test_issue(self):
        self.response('issue')
        self.get(self.api + 'issues/2')

        assert self.repo.issue(-2) is None
        self.not_called()
        assert isinstance(self.repo.issue(2), github3.issues.Issue)
        self.mock_assertions()

    def test_key(self):
        self.response('key')
        self.get(self.api + 'keys/2')

        self.assertRaises(github3.GitHubError, self.repo.key, 2)

        self.login()
        assert self.repo.key(-2) is None
        self.not_called()
        assert isinstance(self.repo.key(2), github3.users.Key)
        self.mock_assertions()

    def test_label(self):
        self.response('label')
        self.get(self.api + 'labels/name')

        assert self.repo.label(None) is None
        self.not_called()
        assert isinstance(self.repo.label('name'), github3.issues.label.Label)
        self.mock_assertions()

    def test_iter_assignees(self):
        self.response('user', _iter=True)
        self.get(self.api + 'assignees')
        self.conf = {'params': {'per_page': 100}}

        u = next(self.repo.iter_assignees())
        assert isinstance(u, github3.users.User)
        self.mock_assertions()

    def test_iter_branches(self):
        self.response('branch', _iter=True)
        self.get(self.api + 'branches')
        self.conf = {'params': {'per_page': 100}}

        b = next(self.repo.iter_branches())
        assert isinstance(b, repos.branch.Branch)
        self.mock_assertions()

    def test_iter_collaborators(self):
        self.response('user', _iter=True)
        self.get(self.api + 'collaborators')
        self.conf = {'params': {'per_page': 100}}

        u = next(self.repo.iter_collaborators())
        assert isinstance(u, github3.users.User)
        self.mock_assertions()

    def test_iter_comments(self):
        self.response('repo_comment', _iter=True)
        self.get(self.api + 'comments')
        self.conf = {'params': {'per_page': 100}}

        c = next(self.repo.iter_comments())
        assert isinstance(c, repos.comment.RepoComment)
        self.mock_assertions()

    def test_iter_comments_on_commit(self):
        self.response('repo_comment', _iter=True)
        self.get(self.api + 'commits/fakesha/comments')
        self.conf = {'params': {'per_page': 1}}

        c = next(self.repo.iter_comments_on_commit('fakesha'))
        assert isinstance(c, repos.comment.RepoComment)
        self.mock_assertions()

    def test_iter_commits(self):
        self.response('commit', _iter=True)
        self.get(self.api + 'commits')
        self.conf = {'params': {'per_page': 100}}

        c = next(self.repo.iter_commits())
        assert isinstance(c, repos.commit.RepoCommit)
        self.mock_assertions()

        self.conf = {'params': {'sha': 'fakesha', 'path': '/',
                                'per_page': 100}}
        c = next(self.repo.iter_commits('fakesha', '/'))
        self.mock_assertions()

        since = datetime(2013, 6, 1, 0, 0, 0)
        until = datetime(2013, 6, 2, 0, 0, 0)
        self.conf = {'params': {'since': '2013-06-01T00:00:00',
                                'until': '2013-06-02T00:00:00',
                                'per_page': 100}}
        c = next(self.repo.iter_commits(since=since, until=until))
        self.mock_assertions()

        since = '2013-06-01T00:00:00'
        until = '2013-06-02T00:00:00'
        self.conf = {'params': {'since': '2013-06-01T00:00:00',
                                'until': '2013-06-02T00:00:00',
                                'per_page': 100}}
        c = next(self.repo.iter_commits(since=since, until=until))
        self.mock_assertions()

    def test_iter_contributors(self):
        self.response('user', _iter=True)
        self.get(self.api + 'contributors')
        self.conf = {'params': {'per_page': 100}}

        u = next(self.repo.iter_contributors())
        assert isinstance(u, github3.users.User)
        self.mock_assertions()

        self.conf = {'params': {'anon': True, 'per_page': 100}}
        next(self.repo.iter_contributors(True))
        self.mock_assertions()

        next(self.repo.iter_contributors('true value'))
        self.mock_assertions()

    def test_iter_events(self):
        self.response('event', _iter=True)
        self.get(self.api + 'events')
        self.conf = {'params': {'per_page': 100}}

        e = next(self.repo.iter_events())
        assert isinstance(e, github3.events.Event)
        self.mock_assertions()

    def test_iter_forks(self):
        self.response('repo', _iter=True)
        self.get(self.api + 'forks')
        self.conf = {'params': {'per_page': 100}}

        r = next(self.repo.iter_forks())
        assert isinstance(r, repos.Repository)
        self.mock_assertions()

        self.conf['params']['sort'] = 'newest'
        forks_params = self.conf['params'].copy()
        forks_params.pop('per_page')
        next(self.repo.iter_forks(**forks_params))
        self.mock_assertions()

    def test_iter_hooks(self):
        self.response('hook', _iter=True)
        self.get(self.api + 'hooks')
        self.conf = {'params': {'per_page': 100}}

        self.assertRaises(github3.GitHubError, self.repo.iter_hooks)

        self.login()
        h = next(self.repo.iter_hooks())
        assert isinstance(h, repos.hook.Hook)
        self.mock_assertions()

    def test_iter_issues(self):
        self.response('issue', _iter=True)
        self.get(self.api + 'issues')
        params = {'per_page': 100}
        self.conf = {'params': params}

        i = next(self.repo.iter_issues())
        assert isinstance(i, github3.issues.Issue)
        self.mock_assertions()

        params['milestone'] = 'none'
        next(self.repo.iter_issues('none'))
        self.mock_assertions()

        params['state'] = 'open'

        request_params = params.copy()
        request_params.pop('per_page')
        next(self.repo.iter_issues(**request_params))
        self.mock_assertions()

    def test_iter_issue_events(self):
        self.response('issue_event', _iter=True)
        self.get(self.api + 'issues/events')
        self.conf = {'params': {'per_page': 100}}

        e = next(self.repo.iter_issue_events())
        assert isinstance(e, github3.issues.event.IssueEvent)
        self.mock_assertions()

    def test_iter_keys(self):
        self.response('key', _iter=True)
        self.get(self.api + 'keys')

        self.assertRaises(github3.GitHubError, self.repo.iter_keys)

        self.login()
        k = next(self.repo.iter_keys())
        assert isinstance(k, github3.users.Key)
        self.mock_assertions()

    def test_iter_labels(self):
        self.response('label', _iter=True)
        self.get(self.api + 'labels')

        l = next(self.repo.iter_labels())
        assert isinstance(l, github3.issues.label.Label)
        self.mock_assertions()

    def test_iter_languages(self):
        #: repos/:login/:repo/languages is just a dictionary, so _iter=False
        self.response('language')
        self.get(self.api + 'languages')

        l = next(self.repo.iter_languages())
        assert isinstance(l, tuple)
        self.assertNotIn('ETag', l)
        self.assertNotIn('Last-Modified', l)
        self.mock_assertions()

    def test_iter_milestones(self):
        self.response('milestone', _iter=True)
        self.get(self.api + 'milestones')

        m = next(self.repo.iter_milestones())
        assert isinstance(m, github3.issues.milestone.Milestone)
        self.mock_assertions()

    def test_iter_network_events(self):
        self.response('event', _iter=True)
        self.get(self.api.replace('repos', 'networks', 1) + 'events')

        e = next(self.repo.iter_network_events())
        assert isinstance(e, github3.events.Event)
        self.mock_assertions()

    def test_iter_notifications(self):
        self.response('notification', _iter=True)
        self.get(self.api + 'notifications')
        self.conf.update(params={'per_page': 100})

        self.assertRaises(github3.GitHubError, self.repo.iter_notifications)

        self.login()
        n = next(self.repo.iter_notifications())
        assert isinstance(n, github3.notifications.Thread)
        self.mock_assertions()

    def test_iter_pulls(self):
        self.response('pull', _iter=True)
        self.get(self.api + 'pulls')
        base_params = {'per_page': 100, 'sort': 'created', 'direction': 'desc'}
        self.conf.update(params=base_params)

        p = next(self.repo.iter_pulls())
        assert isinstance(p, github3.pulls.PullRequest)
        self.mock_assertions()

        next(self.repo.iter_pulls('foo'))
        self.mock_assertions()

        params = {'state': 'open'}
        params.update(base_params)
        self.conf.update(params=params)
        next(self.repo.iter_pulls('Open'))
        self.mock_assertions()

        params = {'head': 'user:branch'}
        params.update(base_params)
        self.conf.update(params=params)
        next(self.repo.iter_pulls(head='user:branch'))
        self.mock_assertions()

        params = {'base': 'branch'}
        params.update(base_params)
        self.conf.update(params=params)
        next(self.repo.iter_pulls(base='branch'))
        self.mock_assertions()

    def test_iter_refs(self):
        self.response('ref', _iter=True)
        self.get(self.api + 'git/refs')

        r = next(self.repo.iter_refs())
        assert isinstance(r, github3.git.Reference)
        self.mock_assertions()

        self.get(self.api + 'git/refs/subspace')
        r = next(self.repo.iter_refs('subspace'))
        assert isinstance(r, github3.git.Reference)
        self.mock_assertions()

    def test_iter_stargazers(self):
        self.response('user', _iter=True)
        self.get(self.api + 'stargazers')

        u = next(self.repo.iter_stargazers())
        assert isinstance(u, github3.users.User)
        self.mock_assertions()

    def test_iter_subscribers(self):
        self.response('user', _iter=True)
        self.get(self.api + 'subscribers')

        u = next(self.repo.iter_subscribers())
        assert isinstance(u, github3.users.User)
        self.mock_assertions()

    def test_iter_statuses(self):
        self.response('status', _iter=True)
        self.get(self.api + 'statuses/fakesha')

        with self.assertRaises(StopIteration):
            next(self.repo.iter_statuses(None))
        self.not_called()

        s = next(self.repo.iter_statuses('fakesha'))
        assert isinstance(s, repos.status.Status)
        self.mock_assertions()

    def test_iter_tags(self):
        self.response('tag', _iter=True)
        self.get(self.api + 'tags')

        t = next(self.repo.iter_tags())
        assert isinstance(t, repos.tag.RepoTag)
        self.mock_assertions()

        assert repr(t).startswith('<Repository Tag')
        assert str(t) > ''

    def test_iter_teams(self):
        self.response('team', _iter=True)
        self.get(self.api + 'teams')

        self.assertRaises(github3.GitHubError, self.repo.iter_teams)
        self.not_called()

        self.login()
        t = next(self.repo.iter_teams())
        assert isinstance(t, github3.orgs.Team)
        self.mock_assertions()

    def test_mark_notifications(self):
        self.response('', 205)
        self.put(self.api + 'notifications')
        self.conf = {'data': {'read': True}}

        self.assertRaises(github3.GitHubError, self.repo.mark_notifications)
        self.not_called()

        self.login()
        assert self.repo.mark_notifications()
        self.mock_assertions()

        assert self.repo.mark_notifications('2013-01-18T19:53:04Z')
        self.conf['data']['last_read_at'] = '2013-01-18T19:53:04Z'
        self.mock_assertions()

    def test_merge(self):
        self.response('commit', 201)
        self.post(self.api + 'merges')
        self.conf = {'data': {'base': 'master', 'head': 'sigma/feature'}}

        self.assertRaises(github3.GitHubError, self.repo.merge, 'foo', 'bar')
        self.not_called()

        self.login()
        assert isinstance(self.repo.merge('master', 'sigma/feature'),
                          repos.commit.RepoCommit)
        self.mock_assertions()

        self.conf['data']['commit_message'] = 'Commit message'
        self.repo.merge('master', 'sigma/feature', 'Commit message')
        self.mock_assertions()

    def test_milestone(self):
        self.response('milestone', 200)
        self.get(self.api + 'milestones/2')

        assert self.repo.milestone(0) is None
        self.not_called()

        assert isinstance(self.repo.milestone(2),
                          github3.issues.milestone.Milestone)
        self.mock_assertions()

    def test_parent(self):
        json = self.repo.to_json().copy()
        json['parent'] = json.copy()
        r = repos.Repository(json)
        assert isinstance(r.parent, repos.Repository)

    def test_pull_request(self):
        self.response('pull', 200)
        self.get(self.api + 'pulls/2')

        assert self.repo.pull_request(0) is None
        self.not_called()

        assert isinstance(self.repo.pull_request(2), github3.pulls.PullRequest)
        self.mock_assertions()

    def test_readme(self):
        self.response('readme', 200)
        self.get(self.api + 'readme')

        assert isinstance(self.repo.readme(), repos.contents.Contents)
        self.mock_assertions()

    def test_ref(self):
        self.response('ref', 200)
        self.get(self.api + 'git/refs/fakesha')

        assert self.repo.ref(None) is None
        self.not_called()

        assert isinstance(self.repo.ref('fakesha'), github3.git.Reference)
        self.mock_assertions()

    def test_remove_collaborator(self):
        self.response('', 204)
        self.delete(self.api + 'collaborators/login')

        self.assertRaises(github3.GitHubError, self.repo.remove_collaborator,
                          None)
        self.not_called()

        self.login()
        assert self.repo.remove_collaborator(None) is False
        self.not_called()

        assert self.repo.remove_collaborator('login')
        self.mock_assertions()

    def test_repr(self):
        assert repr(self.repo) == '<Repository [sigmavirus24/github3.py]>'

    def test_source(self):
        json = self.repo.to_json().copy()
        json['source'] = json.copy()
        r = repos.Repository(json)
        assert isinstance(r.source, repos.Repository)

    def test_set_subscription(self):
        self.response('subscription')
        self.put(self.api + 'subscription')
        self.conf = {'data': {'subscribed': True, 'ignored': False}}

        self.assertRaises(github3.GitHubError, self.repo.set_subscription,
                          True, False)
        self.not_called()

        self.login()
        s = self.repo.set_subscription(True, False)
        assert isinstance(s, github3.notifications.Subscription)
        self.mock_assertions()

    def test_subscription(self):
        self.response('subscription')
        self.get(self.api + 'subscription')

        self.assertRaises(github3.GitHubError, self.repo.subscription)
        self.not_called()

        self.login()
        s = self.repo.subscription()
        assert isinstance(s, github3.notifications.Subscription)
        self.mock_assertions()

    def test_tag(self):
        self.response('tag')
        self.get(self.api + 'git/tags/fakesha')

        assert self.repo.tag(None) is None
        self.not_called()

        assert isinstance(self.repo.tag('fakesha'), github3.git.Tag)
        self.mock_assertions()

    def test_tree(self):
        self.response('tree')
        self.get(self.api + 'git/trees/fakesha')

        assert self.repo.tree(None) is None
        self.not_called()

        assert isinstance(self.repo.tree('fakesha'), github3.git.Tree)
        self.mock_assertions()

    def test_update_label(self):
        self.response('label')
        self.patch(self.api + 'labels/Bug')
        self.conf = {'data': {'name': 'big_bug', 'color': 'fafafa'}}

        self.assertRaises(github3.GitHubError, self.repo.update_label,
                          'foo', 'bar')
        self.not_called()

        self.login()
        with mock.patch.object(repos.Repository, 'label') as l:
            l.return_value = None
            assert self.repo.update_label('foo', 'bar') is False
            self.not_called()

        with mock.patch.object(repos.Repository, 'label') as l:
            l.return_value = github3.issues.label.Label(load('label'), self.g)
            assert self.repo.update_label('big_bug', 'fafafa')

        self.mock_assertions()

    def test_equality(self):
        assert self.repo == repos.Repository(load('repo'))

    def test_create_file(self):
        self.response('create_content', 201)
        self.put(self.api + 'contents/setup.py')
        self.conf = {'data': {'message': 'Foo bar',
                              'content': 'Zm9vIGJhciBib2d1cw==',
                              'branch': 'develop',
                              'author': {'name': 'Ian', 'email': 'foo'},
                              'committer': {'name': 'Ian', 'email': 'foo'}}}

        self.assertRaises(github3.GitHubError, self.repo.create_file,
                          None, None, None)

        self.not_called()
        self.login()

        ret = self.repo.create_file('setup.py', 'Foo bar', b'foo bar bogus',
                                    'develop',
                                    {'name': 'Ian', 'email': 'foo'},
                                    {'name': 'Ian', 'email': 'foo'})
        assert isinstance(ret, dict)
        assert isinstance(ret['commit'], github3.git.Commit)
        assert isinstance(ret['content'], repos.contents.Contents)
        self.mock_assertions()

    def test_update_file(self):
        self.response('create_content', 200)
        self.put(self.api + 'contents/setup.py')
        self.conf = {
            'data': {
                'message': 'foo',
                'content': 'Zm9vIGJhciBib2d1cw==',
                'sha': 'ae02db',
            }
        }

        self.assertRaises(github3.GitHubError, self.repo.update_file,
                          None, None, None, None)

        self.not_called()
        self.login()

        ret = self.repo.update_file('setup.py', 'foo', b'foo bar bogus',
                                    'ae02db')
        assert isinstance(ret, dict)
        assert isinstance(ret['commit'], github3.git.Commit)
        assert isinstance(ret['content'], repos.contents.Contents)
        self.mock_assertions()

    def test_delete_file(self):
        self.response('create_content', 200)
        self.delete(self.api + 'contents/setup.py')
        self.conf = {'data': {'message': 'foo', 'sha': 'ae02db'}}

        self.assertRaises(github3.GitHubError, self.repo.delete_file,
                          'setup.py', None, None)

        self.not_called()
        self.login()
        ret = self.repo.delete_file('setup.py', 'foo', 'ae02db')
        assert isinstance(ret, github3.git.Commit)
        self.mock_assertions()

    def test_weekly_commit_count(self):
        self.response('weekly_commit_count', ETag='"foobarbogus"')
        self.request.return_value.headers['Last-Modified'] = 'foo'
        self.get(self.api + 'stats/participation')

        w = self.repo.weekly_commit_count()
        self.assertTrue(w.get('owner') is not None)
        self.assertTrue(w.get('all') is not None)

        self.mock_assertions()

        self.response('', 202)
        w = self.repo.weekly_commit_count()
        self.assertEqual(w, {})
        self.mock_assertions()

    def test_iter_commit_activity(self):
        self.response('commit_activity', _iter=True)
        self.get(self.api + 'stats/commit_activity')

        w = next(self.repo.iter_commit_activity())
        assert isinstance(w, dict)

        self.mock_assertions()

    def test_iter_contributor_statistics(self):
        self.response('contributor_statistics', _iter=True)
        self.get(self.api + 'stats/contributors')

        s = next(self.repo.iter_contributor_statistics())
        assert isinstance(s, repos.stats.ContributorStats)

        self.mock_assertions()

    def test_iter_code_frequency(self):
        self.response('code_frequency', _iter=True)
        self.get(self.api + 'stats/code_frequency')

        s = next(self.repo.iter_code_frequency())
        assert isinstance(s, list)

        self.mock_assertions()


class TestContents(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestContents, self).__init__(methodName)
        self.contents = repos.contents.Contents(load('readme'))
        self.api = self.contents._api

    def setUp(self):
        super(TestContents, self).setUp()
        self.contents = repos.contents.Contents(self.contents.to_json(),
                                                self.g)

    def test_equality(self):
        contents = repos.contents.Contents(load('readme'))
        assert self.contents == contents
        contents.sha = 'fakesha'
        assert self.contents != contents

    def test_git_url(self):
        assert self.contents.links['git'] == self.contents.git_url

    def test_html_url(self):
        assert self.contents.links['html'] == self.contents.html_url

    def test_repr(self):
        assert repr(self.contents) == '<Content [{0}]>'.format('README.rst')

    def test_delete(self):
        self.response('create_content', 200)
        self.delete(self.api)
        self.conf = {
            'data': {
                'message': 'foo',
                'sha': self.contents.sha,
            }
        }

        self.assertRaises(github3.GitHubError, self.contents.delete, None)

        self.not_called()
        self.login()

        c = self.contents.delete('foo')
        assert isinstance(c, github3.git.Commit)
        self.mock_assertions()

    def test_update(self):
        self.response('create_content', 200)
        self.put(self.api)
        self.conf = {
            'data': {
                'message': 'foo',
                'content': 'Zm9vIGJhciBib2d1cw==',
                'sha': self.contents.sha,
            }
        }

        self.assertRaises(github3.GitHubError, self.contents.update,
                          None, None)

        self.not_called()
        self.login()

        ret = self.contents.update('foo', b'foo bar bogus')
        assert isinstance(ret, github3.git.Commit)
        self.mock_assertions()


class TestHook(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestHook, self).__init__(methodName)
        self.hook = repos.hook.Hook(load('hook'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "hooks/292492")

    def setUp(self):
        super(TestHook, self).setUp()
        self.hook = repos.hook.Hook(self.hook.to_json(), self.g)

    def test_equality(self):
        h = repos.hook.Hook(load('hook'))
        assert self.hook == h
        h._uniq = 1
        assert self.hook != h

    def test_repr(self):
        assert repr(self.hook) == '<Hook [readthedocs]>'

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.hook.delete)
        self.not_called()

        self.login()
        assert self.hook.delete()
        self.mock_assertions()

    def test_edit(self):
        self.response('hook', 200)
        self.patch(self.api)
        data = {
            'config': {'push': 'http://example.com'},
            'events': ['push'],
            'add_events': ['fake_ev'],
            'rm_events': ['fake_ev'],
            'active': True,
        }
        self.conf = {'data': data.copy()}
        self.conf['data']['remove_events'] = data['rm_events']
        del(self.conf['data']['rm_events'])

        self.assertRaises(github3.GitHubError, self.hook.edit, **data)

        self.login()
        self.not_called()

        assert self.hook.edit(**data)
        self.mock_assertions()

    def test_edit_failed(self):
        self.response('', 404)
        self.patch(self.api)
        self.conf = {}

        self.login()
        assert self.hook.edit() is False
        self.mock_assertions()

    def test_test(self):
        # Funny name, no?
        self.response('', 204)
        self.post(self.api + '/tests')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.hook.test)
        self.not_called()

        self.login()
        assert self.hook.test()
        self.mock_assertions()

    def test_ping(self):
        # Funny name, no?
        self.response('', 204)
        self.post(self.api + '/pings')
        self.conf = {}

        self.assertRaises(github3.GitHubError, self.hook.ping)
        self.not_called()

        self.login()
        assert self.hook.ping()
        self.mock_assertions()


class TestRepoComment(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestRepoComment, self).__init__(methodName)
        self.comment = repos.comment.RepoComment(load('repo_comment'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "comments/1380832")

    def setUp(self):
        super(TestRepoComment, self).setUp()
        self.comment = repos.comment.RepoComment(self.comment.to_json(),
                                                 self.g)

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.comment.delete)

        self.not_called()
        self.login()

        assert self.comment.delete()
        self.mock_assertions()

    def test_repr(self):
        assert repr(self.comment).startswith('<Repository Comment')

    def test_update(self):
        self.post(self.api)
        self.response('repo_comment', 200)
        self.conf = {'data': {'body': 'This is a comment body'}}

        self.assertRaises(github3.GitHubError, self.comment.update, 'foo')

        self.login()
        assert self.comment.update(None) is False
        self.not_called()

        assert self.comment.update('This is a comment body')
        self.mock_assertions()


class TestRepoCommit(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestRepoCommit, self).__init__(methodName)
        self.commit = repos.commit.RepoCommit(load('commit'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "commits/76dcc6cb4b9860034be81b7e58adc286a115aa97")

    def test_equality(self):
        c = repos.commit.RepoCommit(load('commit'))
        assert self.commit == c
        c._uniq = 'fake'
        assert self.commit != c

    def test_repr(self):
        assert repr(self.commit).startswith('<Repository Commit')

    def test_diff(self):
        self.response('archive', 200)
        self.get(self.api)
        self.conf.update(headers={'Accept': 'application/vnd.github.diff'})

        assert self.commit.diff().startswith(b'archive_data')
        self.mock_assertions()

    def test_patch(self):
        self.response('archive', 200)
        self.get(self.api)
        self.conf.update(headers={'Accept': 'application/vnd.github.patch'})

        assert self.commit.patch().startswith(b'archive_data')
        self.mock_assertions()


class TestComparison(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestComparison, self).__init__(methodName)
        self.comp = repos.comparison.Comparison(load('comparison'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "compare/a811e1a270f65eecb65755eca38d888cbefcb0a7..."
                    "76dcc6cb4b9860034be81b7e58adc286a115aa97")

    def test_repr(self):
        assert repr(self.comp).startswith('<Comparison ')

    def test_equality(self):
        comp = repos.comparison.Comparison(load('comparison'))
        assert self.comp == comp
        comp.commits.pop(0)
        assert self.comp != comp

    def test_diff(self):
        self.response('archive', 200)
        self.get(self.api)
        self.conf.update(headers={'Accept': 'application/vnd.github.diff'})

        assert self.comp.diff().startswith(b'archive_data')
        self.mock_assertions()

    def test_patch(self):
        self.response('archive', 200)
        self.get(self.api)
        self.conf.update(headers={'Accept': 'application/vnd.github.patch'})

        assert self.comp.patch().startswith(b'archive_data')
        self.mock_assertions()


class TestAsset(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestAsset, self).__init__(methodName)
        self.asset = repos.release.Asset(load('asset'))
        self.api = ("https://api.github.com/repos/sigmavirus24/github3.py/"
                    "releases/assets/37945")

    def test_repr(self):
        assert repr(self.asset) == '<Asset [github3.py-0.7.1.tar.gz]>'

    def test_download(self):
        headers = {'content-disposition': 'filename=foo'}
        self.response('archive', 200, **headers)
        self.get(self.api)
        self.conf.update({
            'stream': True,
            'allow_redirects': False,
            'headers': {'Accept': 'application/octet-stream'}
            })

        # 200, to default location
        assert os.path.isfile('foo') is False
        assert self.asset.download()
        assert os.path.isfile('foo')
        os.unlink('foo')
        self.mock_assertions()

        self.request.return_value.raw.seek(0)
        self.request.return_value._content_consumed = False

        # 200, to path
        assert os.path.isfile('path_to_file') is False
        assert self.asset.download('path_to_file')
        assert os.path.isfile('path_to_file')
        os.unlink('path_to_file')
        self.mock_assertions()

        self.request.return_value.raw.seek(0)
        self.request.return_value._content_consumed = False

        # 200, to file-like object
        o = mock.mock_open()
        with mock.patch('{0}.open'.format(__name__), o, create=True):
            with open('download', 'wb+') as fd:
                self.asset.download(fd)
        o.assert_called_once_with('download', 'wb+')
        fd = o()
        fd.write.assert_called_once_with(b'archive_data')
        self.mock_assertions()

        self.request.return_value.raw.seek(0)
        self.request.return_value._content_consumed = False

        # 302, to file-like object
        r = self.request.return_value
        target = 'http://github.s3.example.com/foo'
        self.response('', 302, location=target)
        self.get(target)
        self.request.side_effect = [self.request.return_value, r]
        self.conf['headers'].update({
            'Authorization': None,
            'Content-Type': None,
            })
        del self.conf['allow_redirects']
        o = mock.mock_open()
        with mock.patch('{0}.open'.format(__name__), o, create=True):
            with open('download', 'wb+') as fd:
                self.asset.download(fd)
        o.assert_called_once_with('download', 'wb+')
        fd = o()
        fd.write.assert_called_once_with(b'archive_data')
        self.mock_assertions()

        # 404
        self.response('', 404)
        self.request.side_effect = None
        assert self.asset.download() is False

########NEW FILE########
__FILENAME__ = test_structs
import github3
from github3.structs import GitHubIterator
from tests.utils import BaseCase, mock


class TestGitHubIterator(BaseCase):
    def setUp(self):
        super(TestGitHubIterator, self).setUp()
        self.api_url = 'https://api.github.com/users'
        self.num = 10
        self.i = GitHubIterator(self.num, self.api_url, github3.users.User,
                                self.g)

    def test_headers(self):
        i = GitHubIterator(self.i.count, self.i.url, self.i.cls, self.g,
                           etag='"foobarbogus"')
        assert i.headers.get('If-None-Match') == '"foobarbogus"'

    def test_repr(self):
        assert repr(self.i) == '<GitHubIterator [{0}, /users]>'.format(
            self.num)

    def test_nexts(self):
        self.response('user', _iter=True)
        self.get(self.api_url)
        self.conf = {'params': {'per_page': 10}, 'headers': {}}
        self.j = GitHubIterator(self.num, self.api_url, github3.users.User,
                                self.g)
        assert self.j.next().login == next(self.i).login
        self.mock_assertions()

    def test_catch_etags(self):
        self.response('user', _iter=True, etag='"foobarbogus"')
        self.get(self.api_url)
        self.conf = {'params': {'per_page': 10}, 'headers': {}}

        assert isinstance(next(self.i), github3.users.User)
        assert self.i.etag == '"foobarbogus"'
        self.mock_assertions()

    def test_catch_None(self):
        self.response('', 200)
        self.get(self.api_url)
        self.conf = {'params': {'per_page': 10}, 'headers': {}}

        self.assertRaises(StopIteration, next, self.i)

        self.mock_assertions()

    def test_entire_while_loop(self):
        self.response('user', _iter=True)
        self.get(self.api_url)
        self.conf = {'params': {'per_page': 10}, 'headers': {}}

        assert isinstance(next(self.i), github3.users.User)

        self.assertRaises(StopIteration, next, self.i)

        self.mock_assertions()

    def test_count_reaches_0(self):
        self.response('user', _iter=True)
        self.get(self.api_url)
        self.conf = {'params': {'per_page': 1}, 'headers': {}}
        self.i = GitHubIterator(1, self.api_url, github3.users.User, self.g)

        assert isinstance(next(self.i), github3.users.User)
        self.assertRaises(StopIteration, next, self.i)

        self.mock_assertions()

    def test_refresh(self):
        with mock.patch.object(GitHubIterator, '__iter__') as i:
            self.i.refresh()
            i.__iter__.assert_called()

            i.reset_mock()
            self.i.refresh(True)
            i.__iter__.assert_called()

########NEW FILE########
__FILENAME__ = test_users
import github3
try:
   from unittest.mock import patch
except ImportError:
   from mock import patch
from tests.utils import (BaseCase, load)
from datetime import datetime


class TestKey(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestKey, self).__init__(methodName)
        self.key = github3.users.Key(load('key'))
        self.api = "https://api.github.com/user/keys/10"

    def setUp(self):
        super(TestKey, self).setUp()
        self.key = github3.users.Key(self.key.to_json(), self.g)

    def test_equality(self):
        k = github3.users.Key(self.key.to_json())
        assert self.key == k
        k._uniq += "cruft"
        assert self.key != k

    def test_str(self):
        assert str(self.key) == self.key.key
        assert repr(self.key).startswith('<User Key')

    def test_delete(self):
        self.response('', 204)
        self.delete(self.api)

        self.assertRaises(github3.GitHubError, self.key.delete)

        self.not_called()
        self.login()
        assert self.key.delete()
        self.mock_assertions()

    def test_update(self):
        self.response('key', 200)
        self.patch(self.api)
        self.conf = {
            'data': {
                'key': 'fakekey',
                'title': 'New title',
            }
        }

        self.assertRaises(github3.GitHubError, self.key.update, None, None)

        self.login()

        assert self.key.update(None, None) is False
        self.not_called()
        assert self.key.update(**self.conf['data'])
        self.mock_assertions()


class TestPlan(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestPlan, self).__init__(methodName)
        self.plan = github3.users.Plan({
            'name': 'free',
            'space': 400,
            'collaborators': 10,
            'private_repos': 20,
        })

    def test_str(self):
        assert str(self.plan) == self.plan.name
        assert repr(self.plan) == '<Plan [free]>'
        assert self.plan.is_free()


class TestUser(BaseCase):
    def __init__(self, methodName='runTest'):
        super(TestUser, self).__init__(methodName)
        self.user = github3.users.User(load('user'))
        self.api = "https://api.github.com/users/sigmavirus24"

    def setUp(self):
        super(TestUser, self).setUp()
        self.user = github3.users.User(self.user.to_json(), self.g)
        if hasattr(self.user.name, 'decode'):
            self.user.name = self.user.name.decode('utf-8')

    def test_refresh(self):
        """This sort of tests all instances of refresh for good measure."""
        self.response('', 304)
        self.get(self.api)
        self.user.last_modified = last_modified = datetime.now().strftime(
            '%a, %d %b %Y %H:%M:%S GMT'
        )
        self.user.etag = etag = '644b5b0155e6404a9cc4bd9d8b1ae730'

        expected_headers = {
            'If-Modified-Since': last_modified,
        }

        self.user.refresh(True)
        self.request.assert_called_with('GET', self.api,
                                        headers=expected_headers,
                                        allow_redirects=True)

        self.user.last_modified = None
        expected_headers = {
            'If-None-Match': etag
        }

        self.user.refresh(True)
        self.request.assert_called_with('GET', self.api,
                                        headers=expected_headers,
                                        allow_redirects=True)

        self.response('user', 200)
        self.user.refresh()
        self.mock_assertions()

    def test_str(self):
        assert str(self.user) == 'sigmavirus24'
        assert repr(self.user) == '<User [sigmavirus24:Ian Cordasco]>'

    def test_add_email_address(self):
        self.assertRaises(github3.GitHubError, self.user.add_email_address,
                          'foo')

        self.not_called()
        self.login()
        with patch.object(github3.users.User, 'add_email_addresses') as p:
            self.user.add_email_address('foo')
            p.assert_called_once_with(['foo'])

    def test_add_email_addresses(self):
        self.response('emails', 201, _iter=True)
        self.post(self.github_url + 'user/emails')
        self.conf = {
            'data': '["foo@bar.com"]',
        }

        self.assertRaises(github3.GitHubError, self.user.add_email_addresses,
                          [])

        self.not_called()
        self.login()

        self.user.add_email_addresses(['foo@bar.com'])
        self.mock_assertions()

    def test_delete_email_address(self):
        self.assertRaises(github3.GitHubError, self.user.delete_email_address,
                          'foo')

        self.not_called()
        self.login()
        with patch.object(github3.users.User, 'delete_email_addresses') as p:
            self.user.delete_email_address('foo')
            p.assert_called_once_with(['foo'])

    def test_delete_email_addresses(self):
        self.response('', 204)
        self.delete(self.github_url + 'user/emails')
        self.conf = {
            'data': '["foo@bar.com"]'
        }

        self.assertRaises(github3.GitHubError,
                          self.user.delete_email_addresses,
                          [])

        self.not_called()
        self.login()
        assert self.user.delete_email_addresses(['foo@bar.com'])
        self.mock_assertions()

    def test_is_assignee_on(self):
        self.response('', 404)
        self.get(self.github_url + 'repos/abc/def/assignees/sigmavirus24')

        assert self.user.is_assignee_on('abc', 'def') is False
        self.mock_assertions()

    def test_is_following(self):
        self.response('', 204)
        self.get(self.api + '/following/kennethreitz')

        assert self.user.is_following('kennethreitz')
        self.mock_assertions()

    def test_iter_events(self):
        self.response('event', 200, _iter=True)
        self.get(self.api + '/events')

        assert isinstance(next(self.user.iter_events()), github3.events.Event)
        self.mock_assertions()

        self.get(self.api + '/events/public')
        next(self.user.iter_events(public=True))
        self.mock_assertions()

    def test_iter_followers(self):
        self.response('user', 200, _iter=True)
        self.get(self.api + '/followers')

        assert isinstance(next(self.user.iter_followers()), github3.users.User)
        self.mock_assertions()

    def test_iter_following(self):
        self.response('user', 200, _iter=True)
        self.get(self.api + '/following')

        assert isinstance(next(self.user.iter_following()), github3.users.User)
        self.mock_assertions()

    def test_iter_org_events(self):
        self.response('event', 200, _iter=True)
        self.get(self.api + '/events/orgs/foo')

        with self.assertRaises(StopIteration):
            next(self.user.iter_org_events(None))

        self.not_called()
        assert isinstance(next(self.user.iter_org_events('foo')),
                          github3.events.Event)
        self.mock_assertions()

    def test_iter_received_events(self):
        self.response('event', 200, _iter=True)
        self.get(self.api + '/received_events')

        assert isinstance(next(self.user.iter_received_events()),
                          github3.events.Event)
        self.mock_assertions()

        self.get(self.api + '/received_events/public')
        next(self.user.iter_received_events(public=True))
        self.mock_assertions()

    def test_iter_starred(self):
        self.response('repo', 200, _iter=True)
        self.get(self.api + '/starred')

        assert isinstance(next(self.user.iter_starred()),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_iter_subscriptions(self):
        self.response('repo', 200, _iter=True)
        self.get(self.api + '/subscriptions')

        assert isinstance(next(self.user.iter_subscriptions()),
                          github3.repos.Repository)
        self.mock_assertions()

    def test_iter_keys(self):
        self.response('key', 200, _iter=True)
        self.get(self.api + '/keys')

        assert isinstance(next(self.user.iter_keys()), github3.users.Key)
        self.mock_assertions()

    def test_update(self):
        self.response('user', 200)
        self.patch('https://api.github.com/user')
        self.conf = {
            'data': {
                'name': 'Ian Cordasco',
                'email': 'ian@cor.da.sc.o',
                'blog': 'http://example.com/blog',
                'hireable': True,
            }
        }

        self.assertRaises(github3.GitHubError, self.user.update)

        self.not_called()
        self.login()
        assert self.user.update(**self.conf['data'])
        self.mock_assertions()

        self.response('', 404)
        assert self.user.update(**self.conf['data']) is False

    def test_equality(self):
        u = github3.users.User(load('user'))
        assert self.user == u
        u._uniq += 1
        assert self.user != u

########NEW FILE########
__FILENAME__ = helper
try:
    from unittest import mock
except ImportError:
    import mock
import github3
import unittest


def build_url(self, *args, **kwargs):
    # We want to assert what is happening with the actual calls to the
    # Internet. We can proxy this.
    return github3.session.GitHubSession().build_url(*args, **kwargs)


class UnitHelper(unittest.TestCase):
    # Sub-classes must assign the class to this during definition
    described_class = None
    # Sub-classes must also assign a dictionary to this during definition
    example_data = {}

    def create_mocked_session(self):
        MockedSession = mock.create_autospec(github3.session.GitHubSession)
        return MockedSession()

    def create_session_mock(self, *args):
        session = self.create_mocked_session()
        base_attrs = ['headers', 'auth']
        attrs = dict(
            (key, mock.Mock()) for key in set(args).union(base_attrs)
        )
        session.configure_mock(**attrs)
        session.delete.return_value = None
        session.get.return_value = None
        session.patch.return_value = None
        session.post.return_value = None
        session.put.return_value = None
        return session

    def create_instance_of_described_class(self):
        if self.example_data:
            instance = self.described_class(self.example_data,
                                            self.session)
        else:
            instance = self.described_class()
            instance._session = self.session

        return instance

    def setUp(self):
        self.session = self.create_session_mock()
        self.instance = self.create_instance_of_described_class()
        # Proxy the build_url method to the class so it can build the URL and
        # we can assert things about the call that will be attempted to the
        # internet
        self.described_class._build_url = build_url

########NEW FILE########
__FILENAME__ = test_github
from github3.github import GitHub

from .helper import UnitHelper


class TestGitHub(UnitHelper):
    described_class = GitHub
    example_data = None

    def test_two_factor_login(self):
        self.instance.login('username', 'password',
                            two_factor_callback=lambda *args: 'foo')

    def test_can_login_without_two_factor_callback(self):
        self.instance.login('username', 'password')
        self.instance.login(token='token')


class TestGitHubAuthorizations(UnitHelper):
    described_class = GitHub
    example_data = None

    def create_session_mock(self, *args):
        session = super(TestGitHubAuthorizations,
                        self).create_session_mock(*args)
        session.retrieve_client_credentials.return_value = ('id', 'secret')
        return session

    def test_revoke_authorization(self):
        """Test that GitHub#revoke_authorization calls the expected methods.

        It should use the session's delete and temporary_basic_auth methods.
        """
        self.instance.revoke_authorization('access_token')
        self.session.delete.assert_called_once_with(
            'https://api.github.com/applications/id/tokens/access_token',
            params={'client_id': None, 'client_secret': None}
        )
        self.session.temporary_basic_auth.assert_called_once_with(
            'id', 'secret'
        )

    def test_revoke_authorizations(self):
        """Test that GitHub#revoke_authorizations calls the expected methods.

        It should use the session's delete and temporary_basic_auth methods.
        """
        self.instance.revoke_authorizations()
        self.session.delete.assert_called_once_with(
            'https://api.github.com/applications/id/tokens',
            params={'client_id': None, 'client_secret': None}
        )
        self.session.temporary_basic_auth.assert_called_once_with(
            'id', 'secret'
        )

########NEW FILE########
__FILENAME__ = test_github_session
import pytest

import requests

from github3 import session
from .helper import mock


class TestGitHubSession:
    def build_session(self, base_url=None):
        s = session.GitHubSession()
        if base_url:
            s.base_url = base_url
        return s

    def test_has_default_headers(self):
        """Assert the default headers are there upon initialization"""
        s = self.build_session()
        assert 'Accept' in s.headers
        assert s.headers['Accept'] == 'application/vnd.github.v3.full+json'
        assert 'Accept-Charset' in s.headers
        assert s.headers['Accept-Charset'] == 'utf-8'
        assert 'Content-Type' in s.headers
        assert s.headers['Content-Type'] == 'application/json'
        assert 'User-Agent' in s.headers
        assert s.headers['User-Agent'].startswith('github3.py/')

    def test_build_url(self):
        """Test that GitHubSessions build basic URLs"""
        s = self.build_session()
        url = s.build_url('gists', '123456', 'history')
        assert url == 'https://api.github.com/gists/123456/history'

    def test_build_url_caches_built_urls(self):
        """Test that building a URL caches it"""
        s = self.build_session()
        url = s.build_url('gists', '123456', 'history')
        url_parts = ('https://api.github.com', 'gists', '123456', 'history')
        assert url_parts in session.__url_cache__
        assert url in session.__url_cache__.values()

    def test_build_url_uses_a_different_base(self):
        """Test that you can pass in a different base URL to build_url"""
        s = self.build_session()
        url = s.build_url('gists', '123456', 'history',
                          base_url='https://status.github.com')
        assert url == 'https://status.github.com/gists/123456/history'

    def test_build_url_respects_the_session_base_url(self):
        """Test that build_url uses the session's base_url"""
        s = self.build_session('https://enterprise.customer.com')
        url = s.build_url('gists')
        assert url == 'https://enterprise.customer.com/gists'

    def test_basic_login_does_not_use_falsey_values(self):
        """Test that basic auth will not authenticate with falsey values"""
        bad_auths = [
            (None, 'password'),
            ('username', None),
            ('', 'password'),
            ('username', ''),
            ]
        for auth in bad_auths:
            # Make sure we have a clean session to test with
            s = self.build_session()
            s.basic_auth(*auth)
            assert s.auth != auth

    def test_basic_login(self):
        """Test that basic auth will work with a valid combination"""
        s = self.build_session()
        s.basic_auth('username', 'password')
        assert s.auth == ('username', 'password')

    def test_basic_login_disables_token_auth(self):
        """Test that basic auth will remove the Authorization header.

        Token and basic authentication will conflict so remove the token
        authentication.
        """
        s = self.build_session()
        s.token_auth('token goes here')
        assert 'Authorization' in s.headers
        s.basic_auth('username', 'password')
        assert 'Authorization' not in s.headers

    @mock.patch.object(requests.Session, 'request')
    def test_handle_two_factor_auth(self, request_mock):
        """Test the method that handles getting the 2fa code"""
        s = self.build_session()
        s.two_factor_auth_callback(lambda: 'fake')
        args = ('GET', 'http://example.com')
        s.handle_two_factor_auth(args, {})
        request_mock.assert_called_once_with(
            *args,
            headers={'X-GitHub-OTP': 'fake'}
            )

    @mock.patch.object(requests.Session, 'request')
    def test_request_ignores_responses_that_do_not_require_2fa(self,
                                                               request_mock):
        """Test that request does not try to handle 2fa when it should not"""
        response = mock.Mock()
        response.configure_mock(status_code=200, headers={})
        request_mock.return_value = response
        s = self.build_session()
        s.two_factor_auth_callback(lambda: 'fake')
        r = s.get('http://example.com')
        assert r is response
        request_mock.assert_called_once_with(
            'GET', 'http://example.com', allow_redirects=True
            )

    @mock.patch.object(requests.Session, 'request')
    def test_creates_history_while_handling_2fa(self, request_mock):
        """Test that the overridden request method will create history"""
        response = mock.Mock()
        response.configure_mock(
            status_code=401,
            headers={'X-GitHub-OTP': 'required;2fa'},
            history=[]
            )
        request_mock.return_value = response
        s = self.build_session()
        s.two_factor_auth_callback(lambda: 'fake')
        r = s.get('http://example.com')
        assert len(r.history) != 0
        assert request_mock.call_count == 2

    def test_token_auth(self):
        """Test that token auth will work with a valid token"""
        s = self.build_session()
        s.token_auth('token goes here')
        assert s.headers['Authorization'] == 'token token goes here'

    def test_token_auth_disables_basic_auth(self):
        """Test that using token auth removes the value of the auth attribute.

        If `GitHubSession.auth` is set then it conflicts with the token value.
        """
        s = self.build_session()
        s.auth = ('foo', 'bar')
        s.token_auth('token goes here')
        assert s.auth is None

    def test_token_auth_does_not_use_falsey_values(self):
        """Test that token auth will not authenticate with falsey values"""
        bad_tokens = [None, '']
        for token in bad_tokens:
            s = self.build_session()
            s.token_auth(token)
            assert 'Authorization' not in s.headers

    def test_two_factor_auth_callback_handles_None(self):
        s = self.build_session()
        assert s.two_factor_auth_cb is None
        s.two_factor_auth_callback(None)
        assert s.two_factor_auth_cb is None

    def test_two_factor_auth_callback_checks_for_Callable(self):
        s = self.build_session()
        assert s.two_factor_auth_cb is None
        with pytest.raises(ValueError):
            s.two_factor_auth_callback(1)

    def test_two_factor_auth_callback_accepts_a_Callable(self):
        s = self.build_session()
        assert s.two_factor_auth_cb is None
        # You have to have a sense of humor ;)
        not_so_anonymous = lambda *args: 'foo'
        s.two_factor_auth_callback(not_so_anonymous)
        assert s.two_factor_auth_cb is not_so_anonymous

    def test_oauth2_auth(self):
        """Test that oauth2 authentication works

        For now though, it doesn't because it isn't implemented.
        """
        s = self.build_session()
        with pytest.raises(NotImplementedError):
            s.oauth2_auth('Foo', 'bar')

    def test_issubclass_of_requests_Session(self):
        """Test that GitHubSession is a subclass of requests.Session"""
        assert issubclass(session.GitHubSession,
                          requests.Session)

    def test_can_use_temporary_basic_auth(self):
        """Test that temporary_basic_auth resets old auth."""
        s = self.build_session()
        s.basic_auth('foo', 'bar')
        with s.temporary_basic_auth('temp', 'pass'):
            assert s.auth != ('foo', 'bar')

        assert s.auth == ('foo', 'bar')

    def test_temporary_basic_auth_replaces_auth(self):
        """Test that temporary_basic_auth sets the proper credentials."""
        s = self.build_session()
        s.basic_auth('foo', 'bar')
        with s.temporary_basic_auth('temp', 'pass'):
            assert s.auth == ('temp', 'pass')

    def test_retrieve_client_credentials_when_set(self):
        """Test that retrieve_client_credentials will return the credentials.

        We must assert that when set, this function will return them.
        """
        s = self.build_session()
        s.params = {'client_id': 'id', 'client_secret': 'secret'}
        assert s.retrieve_client_credentials() == ('id', 'secret')

    def test_retrieve_client_credentials_returns_none(self):
        """Test that retrieve_client_credentials will return (None, None).

        Namely, then the necessary parameters are set, it will not raise an
        error.
        """
        s = self.build_session()
        assert s.retrieve_client_credentials() == (None, None)

########NEW FILE########
__FILENAME__ = test_repos_release
from github3.repos.release import Release, Asset

from .helper import UnitHelper

import json


def releases_url(path=''):
    url = "https://api.github.com/repos/octocat/Hello-World/releases"
    return url + path


class TestRelease(UnitHelper):
    described_class = Release
    example_data = {
        "url": releases_url("/1"),
        "html_url": "https://github.com/octocat/Hello-World/releases/v1.0.0",
        "assets": [{
            "url": releases_url("/assets/1"),
            "id": 1,
            "name": "example.zip",
            "label": "short description",
            "state": "uploaded",
            "content_type": "application/zip",
            "size": 1024,
            "download_count": 42,
            "created_at": "2013-02-27T19:35:32Z",
            "updated_at": "2013-02-27T19:35:32Z"
            }],
        "assets_url": releases_url("/1/assets"),
        "upload_url": releases_url("/1/assets{?name}"),
        "id": 1,
        "tag_name": "v1.0.0",
        "target_commitish": "master",
        "name": "v1.0.0",
        "body": "Description of the release",
        "draft": False,
        "prerelease": False,
        "created_at": "2013-02-27T19:35:32Z",
        "published_at": "2013-02-27T19:35:32Z"
        }

    # Attribute tests
    def test_assets(self):
        assert self.instance.assets is not None
        assert isinstance(self.instance.assets[0], Asset)

    def test_has_upload_urlt(self):
        assert self.instance.upload_urlt is not None

    # Method tests
    def test_delete(self):
        self.instance.delete()
        self.session.delete.assert_called_once_with(
            self.example_data['url'],
            headers={'Accept': 'application/vnd.github.manifold-preview'}
        )


class TestAsset(UnitHelper):
    described_class = Asset
    example_data = {
        "url": releases_url("/assets/1"),
        "id": 1,
        "name": "example.zip",
        "label": "short description",
        "state": "uploaded",
        "content_type": "application/zip",
        "size": 1024,
        "download_count": 42,
        "created_at": "2013-02-27T19:35:32Z",
        "updated_at": "2013-02-27T19:35:32Z"
        }

    def test_edit_without_label(self):
        self.instance.edit('new name')
        self.session.patch.assert_called_once_with(
            self.example_data['url'],
            data='{"name": "new name"}',
            headers={'Accept': 'application/vnd.github.manifold-preview'}
        )

    def test_edit_with_label(self):
        self.instance.edit('new name', 'label')
        headers = {'Accept': 'application/vnd.github.manifold-preview'}
        _, args, kwargs = list(self.session.patch.mock_calls[0])
        assert self.example_data['url'] in args
        assert kwargs['headers'] == headers
        assert json.loads(kwargs['data']) == {
            'name': 'new name', 'label': 'label'
            }

########NEW FILE########
__FILENAME__ = test_repos_repo
from github3.repos.repo import Repository

from .helper import UnitHelper


class TestRepository(UnitHelper):
    described_class = Repository
    example_data = {
        "id": 1296269,
        "owner": {
            "login": "octocat",
            "id": 1,
            "avatar_url": "https://github.com/images/error/octocat_happy.gif",
            "gravatar_id": "somehexcode",
            "url": "https://api.github.com/users/octocat"
            },
        "name": "Hello-World",
        "full_name": "octocat/Hello-World",
        "description": "This your first repo!",
        "private": False,
        "fork": False,
        "url": "https://api.github.com/repos/octocat/Hello-World",
        "html_url": "https://github.com/octocat/Hello-World",
        "clone_url": "https://github.com/octocat/Hello-World.git",
        "git_url": "git://github.com/octocat/Hello-World.git",
        "ssh_url": "git@github.com:octocat/Hello-World.git",
        "svn_url": "https://svn.github.com/octocat/Hello-World",
        "mirror_url": "git://git.example.com/octocat/Hello-World",
        "homepage": "https://github.com",
        "language": None,
        "forks": 9,
        "forks_count": 9,
        "watchers": 80,
        "watchers_count": 80,
        "size": 108,
        "master_branch": "master",
        "open_issues": 0,
        "open_issues_count": 0,
        "pushed_at": "2011-01-26T19:06:43Z",
        "created_at": "2011-01-26T19:01:12Z",
        "updated_at": "2011-01-26T19:14:43Z",
        "organization": {
            "login": "octocat",
            "id": 1,
            "avatar_url": "https://github.com/images/error/octocat_happy.gif",
            "gravatar_id": "somehexcode",
            "url": "https://api.github.com/users/octocat",
            "type": "Organization"
            },
        "parent": {
            "id": 1296269,
            "owner": {
                "login": "octocat",
                "id": 1,
                "avatar_url": "https://github.com/images/error/octocat.gif",
                "gravatar_id": "somehexcode",
                "url": "https://api.github.com/users/octocat"
                },
            "name": "Hello-World",
            "full_name": "octocat/Hello-World",
            "description": "This your first repo!",
            "private": False,
            "fork": True,
            "url": "https://api.github.com/repos/octocat/Hello-World",
            "html_url": "https://github.com/octocat/Hello-World",
            "clone_url": "https://github.com/octocat/Hello-World.git",
            "git_url": "git://github.com/octocat/Hello-World.git",
            "ssh_url": "git@github.com:octocat/Hello-World.git",
            "svn_url": "https://svn.github.com/octocat/Hello-World",
            "mirror_url": "git://git.example.com/octocat/Hello-World",
            "homepage": "https://github.com",
            "language": None,
            "forks": 9,
            "forks_count": 9,
            "watchers": 80,
            "watchers_count": 80,
            "size": 108,
            "master_branch": "master",
            "open_issues": 0,
            "open_issues_count": 0,
            "pushed_at": "2011-01-26T19:06:43Z",
            "created_at": "2011-01-26T19:01:12Z",
            "updated_at": "2011-01-26T19:14:43Z"
            },
        "source": {
            "id": 1296269,
            "owner": {
                "login": "octocat",
                "id": 1,
                "avatar_url": "https://github.com/images/error/octocat.gif",
                "gravatar_id": "somehexcode",
                "url": "https://api.github.com/users/octocat"
                },
            "name": "Hello-World",
            "full_name": "octocat/Hello-World",
            "description": "This your first repo!",
            "private": False,
            "fork": True,
            "url": "https://api.github.com/repos/octocat/Hello-World",
            "html_url": "https://github.com/octocat/Hello-World",
            "clone_url": "https://github.com/octocat/Hello-World.git",
            "git_url": "git://github.com/octocat/Hello-World.git",
            "ssh_url": "git@github.com:octocat/Hello-World.git",
            "svn_url": "https://svn.github.com/octocat/Hello-World",
            "mirror_url": "git://git.example.com/octocat/Hello-World",
            "homepage": "https://github.com",
            "language": None,
            "forks": 9,
            "forks_count": 9,
            "watchers": 80,
            "watchers_count": 80,
            "size": 108,
            "master_branch": "master",
            "open_issues": 0,
            "open_issues_count": 0,
            "pushed_at": "2011-01-26T19:06:43Z",
            "created_at": "2011-01-26T19:01:12Z",
            "updated_at": "2011-01-26T19:14:43Z"
            },
        "has_issues": True,
        "has_wiki": True,
        "has_downloads": True
    }

    def test_asset(self):
        """Test retrieving an asset uses the right headers

        The Releases section of the API is still in Beta and uses custom
        headers
        """
        assert self.instance.asset(0) is None
        assert self.session.get.call_count == 0

        self.instance.asset(1)
        url = self.example_data['url'] + '/releases/assets/1'
        self.session.get.assert_called_once_with(
            url, headers={'Accept': 'application/vnd.github.manifold-preview'}
        )

    def test_latest_pages_build(self):
        """Test retrieving the most recent pages build."""
        url = self.example_data['url'] + '/pages/builds/latest'
        self.instance.latest_pages_build()
        self.session.get.assert_called_once_with(url)

    def test_pages(self):
        """Test retrieving information about a repository's page."""
        url = self.example_data['url'] + '/pages'
        self.instance.pages()
        self.session.get.assert_called_once_with(url)

########NEW FILE########
__FILENAME__ = test_structs
from .helper import UnitHelper, mock
from github3.structs import GitHubIterator


class TestGitHubIterator(UnitHelper):
    described_class = GitHubIterator

    def setUp(self):
        super(TestGitHubIterator, self).setUp()
        self.count = -1
        self.cls = object

    def create_instance_of_described_class(self):
        self.url = 'https://api.github.com/users'
        klass = lambda *args: args
        instance = self.described_class(count=-1, url=self.url, cls=klass,
                                        session=self.session)
        return instance

    def test_sets_per_page_to_100(self):
        """Test that the Iterator defaults the per_page parameter to 100"""
        self.session.get.return_value = mock.Mock(status_code=200,
                                                  json=lambda: [],
                                                  links={})

        for i in self.instance:
            break

        self.session.get.assert_called_once_with(
            self.url, params={'per_page': 100}, headers={}
            )

    def test_stores_headers_properly(self):
        headers = {'Accept': 'foo'}
        session, url, count, cls = self.session, self.url, self.count, self.cls
        i = GitHubIterator(count, url, cls, session, headers=headers)
        assert i.headers != {}
        assert i.headers.get('Accept') == 'foo'

########NEW FILE########
__FILENAME__ = test_utils
from datetime import datetime
from github3.utils import stream_response_to_file, timestamp_parameter

import io
import mock
import pytest
import requests


class TestTimestampConverter:
    def test_datetimes(self):
        timestamp = datetime(2010, 6, 1, 12, 15, 30)
        assert '2010-06-01T12:15:30' == timestamp_parameter(timestamp)

    def test_valid_datestring(self):
        testvals = (
            '2010-06-01',
            '2010-06-01T12:15:30',
            '2010-06-01T12:14:30.12321+02:00',
            '2010-06-01T12:14:30.12321-02:00',
            '2010-06-01T12:14:30.2115Z',
        )
        for timestamp in testvals:
            assert timestamp == timestamp_parameter(timestamp)

    def test_invalid_datestring(self):
        testvals = (
            '2012-16-04',
            '2012-06-01v!',
            'fish',
            '2010-06-01T12:14:30.12321+02',
            '2010-06-01T12:70:30.12321+02',
        )
        for timestamp in testvals:
            pytest.raises(ValueError, timestamp_parameter, timestamp)

    def test_none_handling(self):
        assert timestamp_parameter(None, allow_none=True) is None
        pytest.raises(ValueError, timestamp_parameter, None,
                      allow_none=False)

    def test_invalid_type_handling(self):
        pytest.raises(ValueError, timestamp_parameter, 1)


@pytest.fixture
def mocked_open():
    return mock.mock_open()


@pytest.fixture
def response():
    r = requests.Response()
    r.raw = io.BytesIO(b'fake data')
    r.headers.update({'content-disposition': 'filename=a_file_name'})
    return r


class OpenFile:
    def __init__(self):
        self.data = b''
        self.written_to = False

    def write(self, data):
        self.written_to = True
        self.data += data


class TestStreamingDownloads:
    def test_opens_a_new_file(self, mocked_open, response):
        with mock.patch('github3.utils.open', mocked_open, create=True):
            stream_response_to_file(response, 'some_file')

        mocked_open.assert_called_once_with('some_file', 'wb')
        mocked_open().write.assert_called_once_with(b'fake data')
        mocked_open().close.assert_called_once_with()

    def test_uses_existing_file(self, response):
        fd = OpenFile()
        stream_response_to_file(response, fd)
        assert fd.written_to is True
        assert fd.data == b'fake data'

    def test_finds_filename_in_headers(self, mocked_open, response):
        with mock.patch('github3.utils.open', mocked_open, create=True):
            stream_response_to_file(response)

        mocked_open.assert_called_once_with('a_file_name', 'wb')
        mocked_open().write.assert_called_once_with(b'fake data')
        mocked_open().close.assert_called_once_with()

########NEW FILE########
__FILENAME__ = utils
import json
import os
import sys

if sys.version_info < (3, 0):
    from unittest2 import TestCase
else:
    from unittest import TestCase

import requests
import github3

try:
    from unittest import mock
except ImportError:
    import mock

from io import BytesIO
from requests.structures import CaseInsensitiveDict

is_py3 = sys.version_info > (3, 0)


def load(name):
    with path(name) as f:
        j = json.load(f)
    return j


def path(name, mode='r'):
    return open('tests/json/{0}'.format(name), mode)


class BaseCase(TestCase):
    github_url = 'https://api.github.com/'

    def setUp(self):
        self.g = github3.GitHub()
        self.session = self.g._session
        if os.environ.get('GH_AUTH'):
            self.g.login(token=os.environ['GH_AUTH'])
        self.args = ()
        self.conf = {'allow_redirects': True}
        self.mock = mock.patch.object(requests.sessions.Session, 'request')
        self.request = self.mock.start()

    def tearDown(self):
        self.mock.stop()

    def login(self):
        self.g.login('user', 'password')

    def mock_assertions(self):
        assert self.request.called is True
        conf = self.conf.copy()
        args, kwargs = self.request.call_args

        assert self.args == args

        if 'data' in self.conf:
            if isinstance(self.conf['data'], dict):
                for k, v in list(self.conf['data'].items()):
                    s = json.dumps({k: v})[1:-1]
                    assert s in kwargs['data']
            else:
                assert self.conf['data'] == kwargs['data']

            del self.conf['data']

        for k in self.conf:
            assert k in kwargs
            assert self.conf[k] == kwargs[k]

        self.request.reset_mock()
        self.conf = conf

    def response(self, path_name, status_code=200, enc='utf-8',
                 _iter=False, **headers):
        r = requests.Response()
        r.status_code = status_code
        r.encoding = enc

        if path_name:
            with path(path_name) as f:
                content = f.read().strip()

            if _iter:
                content = '[{0}]'.format(content)
                r.raw = RequestsBytesIO(content.encode())
            elif is_py3:
                r.raw = RequestsBytesIO(content.encode())
            else:
                r.raw = RequestsBytesIO(content)
        else:
            r.raw = RequestsBytesIO()

        if headers:
            r.headers = CaseInsensitiveDict(headers)

        self.request.return_value = r

    def delete(self, url):
        self.args = ('DELETE', url)
        self.conf = {}

    def get(self, url):
        self.args = ('GET', url)

    def patch(self, url):
        self.args = ('PATCH', url)

    def post(self, url):
        self.args = ('POST', url)

    def put(self, url):
        self.args = ('PUT', url)

    def not_called(self):
        assert self.request.called is False

    def assertGitHubErrorRaised(self, func, *args, **kwargs):
        return self.assertRaises(github3.GitHubError, func(*args, **kwargs))


class RequestsBytesIO(BytesIO):
    def read(self, chunk_size, *args, **kwargs):
        return super(RequestsBytesIO, self).read(chunk_size)

########NEW FILE########
