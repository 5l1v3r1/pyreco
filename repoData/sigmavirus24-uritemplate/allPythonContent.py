__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Requests documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 13 23:54:25 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# This environment variable makes decorators not decorate functions, so their
# signatures in the generated documentation are still correct
os.environ['GENERATING_DOCUMENTATION'] = "uritemplate"

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
import uritemplate

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'uritemplate'
copyright = u'2013 - Ian Cordasco'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = uritemplate.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
# pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None


# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'uritemplate_doc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'uritemplate.tex', u'uritemplate Documentation',
     u'Ian Cordasco', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'uritemplate', u'uritemplate Documentation',
     [u'Ian Cordasco'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False

# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'uritemplate', u'uritemplate Documentation', u'Ian Cordasco',
   'uritemplate', 'Library to expand RFC6570 templated URIs',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
texinfo_appendices = []

########NEW FILE########
__FILENAME__ = test_uritemplate
from unittest import TestCase, main
from uritemplate import URITemplate, expand, partial
from uritemplate import variable


def merge_dicts(*args):
    d = {}
    for arg in args:
        d.update(arg)
    return d


class RFCTemplateExamples(type):
    var = {'var': 'value'}
    hello = {'hello': 'Hello World!'}
    path = {'path': '/foo/bar'}
    x = {'x': '1024'}
    y = {'y': '768'}
    empty = {'empty': ''}
    merged_x_y = merge_dicts(x, y)
    list_ex = {'list': ['red', 'green', 'blue']}
    keys = {'keys': [('semi', ';'), ('dot', '.'), ('comma', ',')]}

    ## Level 1
    # Simple string expansion
    level1_examples = {
        '{var}': {
            'expansion': var,
            'expected': 'value',
        },
        '{hello}': {
            'expansion': hello,
            'expected': 'Hello%20World%21',
        },
    }

    ## Level 2
    # Reserved string expansion
    level2_reserved_examples = {
        '{+var}': {
            'expansion': var,
            'expected': 'value',
        },
        '{+hello}': {
            'expansion': hello,
            'expected': 'Hello%20World!',
        },
        '{+path}/here': {
            'expansion': path,
            'expected': '/foo/bar/here',
        },
        'here?ref={+path}': {
            'expansion': path,
            'expected': 'here?ref=/foo/bar',
        },
    }

    # Fragment expansion, crosshatch-prefixed
    level2_fragment_examples = {
        'X{#var}': {
            'expansion': var,
            'expected': 'X#value',
        },
        'X{#hello}': {
            'expansion': hello,
            'expected': 'X#Hello%20World!'
        },
    }

    ## Level 3
    # String expansion with multiple variables
    level3_multiple_variable_examples = {
        'map?{x,y}': {
            'expansion': merged_x_y,
            'expected': 'map?1024,768',
        },
        '{x,hello,y}': {
            'expansion': merge_dicts(x, y, hello),
            'expected': '1024,Hello%20World%21,768',
        },
    }

    # Reserved expansion with multiple variables
    level3_reserved_examples = {
        '{+x,hello,y}': {
            'expansion': merge_dicts(x, y, hello),
            'expected': '1024,Hello%20World!,768',
        },
        '{+path,x}/here': {
            'expansion': merge_dicts(path, x),
            'expected': '/foo/bar,1024/here',
        },
    }

    # Fragment expansion with multiple variables
    level3_fragment_examples = {
        '{#x,hello,y}': {
            'expansion': merge_dicts(x, y, hello),
            'expected': '#1024,Hello%20World!,768',
        },
        '{#path,x}/here': {
            'expansion': merge_dicts(path, x),
            'expected': '#/foo/bar,1024/here'
        },
    }

    # Label expansion, dot-prefixed
    level3_label_examples = {
        'X{.var}': {
            'expansion': var,
            'expected': 'X.value',
        },
        'X{.x,y}': {
            'expansion': merged_x_y,
            'expected': 'X.1024.768',
        }
    }

    # Path segments, slash-prefixed
    level3_path_segment_examples = {
        '{/var}': {
            'expansion': var,
            'expected': '/value',
        },
        '{/var,x}/here': {
            'expansion': merge_dicts(var, x),
            'expected': '/value/1024/here',
        },
    }

    # Path-style parameters, semicolon-prefixed
    level3_path_semi_examples = {
        '{;x,y}': {
            'expansion': merged_x_y,
            'expected': ';x=1024;y=768',
        },
        '{;x,y,empty}': {
            'expansion': merge_dicts(x, y, empty),
            'expected': ';x=1024;y=768;empty',
        },
    }

    # Form-style query, ampersand-separated
    level3_form_amp_examples = {
        '{?x,y}': {
            'expansion': merged_x_y,
            'expected': '?x=1024&y=768',
        },
        '{?x,y,empty}': {
            'expansion': merge_dicts(x, y, empty),
            'expected': '?x=1024&y=768&empty=',
        },
    }

    # Form-style query continuation
    level3_form_cont_examples = {
        '?fixed=yes{&x}': {
            'expansion': x,
            'expected': '?fixed=yes&x=1024',
        },
        '{&x,y,empty}': {
            'expansion': merge_dicts(x, y, empty),
            'expected': '&x=1024&y=768&empty=',
        }
    }

    ## Level 4
    # String expansion with value modifiers
    level4_value_modifier_examples = {
        '{var:3}': {
            'expansion': var,
            'expected': 'val',
        },
        '{var:30}': {
            'expansion': var,
            'expected': 'value',
        },
        '{list}': {
            'expansion': list_ex,
            'expected': 'red,green,blue',
        },
        '{list*}': {
            'expansion': list_ex,
            'expected': 'red,green,blue',
        },
        '{keys}': {
            'expansion': keys,
            'expected': 'semi,%3B,dot,.,comma,%2C',
        },
        '{keys*}': {
            'expansion': keys,
            'expected': 'semi=%3B,dot=.,comma=%2C',
        },
    }

    # Reserved expansion with value modifiers
    level4_reserved_examples = {
        '{+path:6}/here': {
            'expansion': path,
            'expected': '/foo/b/here',
        },
        '{+list}': {
            'expansion': list_ex,
            'expected': 'red,green,blue',
        },
        '{+list*}': {
            'expansion': list_ex,
            'expected': 'red,green,blue',
        },
        '{+keys}': {
            'expansion': keys,
            'expected': 'semi,;,dot,.,comma,,',
        },
        '{+keys*}': {
            'expansion': keys,
            'expected': 'semi=;,dot=.,comma=,',
        },
    }

    # Fragment expansion with value modifiers
    level4_fragment_examples = {
        '{#path:6}/here': {
            'expansion': path,
            'expected': '#/foo/b/here',
        },
        '{#list}': {
            'expansion': list_ex,
            'expected': '#red,green,blue',
        },
        '{#list*}': {
            'expansion': list_ex,
            'expected': '#red,green,blue',
        },
        '{#keys}': {
            'expansion': keys,
            'expected': '#semi,;,dot,.,comma,,'
        },
        '{#keys*}': {
            'expansion': keys,
            'expected': '#semi=;,dot=.,comma=,'
        },
    }

    # Label expansion, dot-prefixed
    level4_label_examples = {
        'X{.var:3}': {
            'expansion': var,
            'expected': 'X.val',
        },
        'X{.list}': {
            'expansion': list_ex,
            'expected': 'X.red,green,blue',
        },
        'X{.list*}': {
            'expansion': list_ex,
            'expected': 'X.red.green.blue',
        },
        'X{.keys}': {
            'expansion': keys,
            'expected': 'X.semi,%3B,dot,.,comma,%2C',
        },
        'X{.keys*}': {
            'expansion': keys,
            'expected': 'X.semi=%3B.dot=..comma=%2C',
        },
    }

    # Path segments, slash-prefixed
    level4_path_slash_examples = {
        '{/var:1,var}': {
            'expansion': var,
            'expected': '/v/value',
        },
        '{/list}': {
            'expansion': list_ex,
            'expected': '/red,green,blue',
        },
        '{/list*}': {
            'expansion': list_ex,
            'expected': '/red/green/blue',
        },
        '{/list*,path:4}': {
            'expansion': merge_dicts(list_ex, path),
            'expected': '/red/green/blue/%2Ffoo',
        },
        '{/keys}': {
            'expansion': keys,
            'expected': '/semi,%3B,dot,.,comma,%2C',
        },
        '{/keys*}': {
            'expansion': keys,
            'expected': '/semi=%3B/dot=./comma=%2C',
        },
    }

    # Path-style parameters, semicolon-prefixed
    level4_path_semi_examples = {
        '{;hello:5}': {
            'expansion': hello,
            'expected': ';hello=Hello',
        },
        '{;list}': {
            'expansion': list_ex,
            'expected': ';list=red,green,blue',
        },
        '{;list*}': {
            'expansion': list_ex,
            'expected': ';list=red;list=green;list=blue',
        },
        '{;keys}': {
            'expansion': keys,
            'expected': ';keys=semi,%3B,dot,.,comma,%2C',
        },
        '{;keys*}': {
            'expansion': keys,
            'expected': ';semi=%3B;dot=.;comma=%2C',
        },
    }

    # Form-style query, ampersand-separated
    level4_form_amp_examples = {
        '{?var:3}': {
            'expansion': var,
            'expected': '?var=val',
        },
        '{?list}': {
            'expansion': list_ex,
            'expected': '?list=red,green,blue',
        },
        '{?list*}': {
            'expansion': list_ex,
            'expected': '?list=red&list=green&list=blue',
        },
        '{?keys}': {
            'expansion': keys,
            'expected': '?keys=semi,%3B,dot,.,comma,%2C',
        },
        '{?keys*}': {
            'expansion': keys,
            'expected': '?semi=%3B&dot=.&comma=%2C',
        },
    }

    # Form-style query continuation
    level4_form_query_examples = {
        '{&var:3}': {
            'expansion': var,
            'expected': '&var=val',
        },
        '{&list}': {
            'expansion': list_ex,
            'expected': '&list=red,green,blue',
        },
        '{&list*}': {
            'expansion': list_ex,
            'expected': '&list=red&list=green&list=blue',
        },
        '{&keys}': {
            'expansion': keys,
            'expected': '&keys=semi,%3B,dot,.,comma,%2C',
        },
        '{&keys*}': {
            'expansion': keys,
            'expected': '&semi=%3B&dot=.&comma=%2C',
        },
    }

    def __new__(cls, name, bases, attrs):
        def make_test(d):
            def _test_(self):
                for k, v in d.items():
                    t = URITemplate(k)
                    self.assertEqual(t.expand(v['expansion']), v['expected'])
            return _test_

        examples = [
            (
                n, getattr(RFCTemplateExamples, n)
            ) for n in dir(RFCTemplateExamples) if n.startswith('level')
        ]

        for name, value in examples:
            testname = 'test_%s' % name
            attrs[testname] = make_test(value)

        return type.__new__(cls, name, bases, attrs)


class TestURITemplate(RFCTemplateExamples('RFCMeta', (TestCase,), {})):
    def test_no_variables_in_uri(self):
        """
        This test ensures that if there are no variables present, the
        template evaluates to itself.
        """
        uri = 'https://api.github.com/users'
        t = URITemplate(uri)
        self.assertEqual(t.expand(), uri)
        self.assertEqual(t.expand(users='foo'), uri)

    def test_all_variables_parsed(self):
        """
        This test ensures that all variables are parsed.
        """
        uris = [
            'https://api.github.com',
            'https://api.github.com/users{/user}',
            'https://api.github.com/repos{/user}{/repo}',
            'https://api.github.com/repos{/user}{/repo}/issues{/issue}'
        ]

        for i, uri in enumerate(uris):
            t = URITemplate(uri)
            self.assertEqual(len(t.variables), i)

    def test_expand(self):
        """
        This test ensures that expansion works as expected.
        """
        # Single
        t = URITemplate('https://api.github.com/users{/user}')
        expanded = 'https://api.github.com/users/sigmavirus24'
        self.assertEqual(t.expand(user='sigmavirus24'), expanded)
        v = t.variables[0]
        self.assertEqual(v.expand({'user': None}), {'/user': ''})

        # Multiple
        t = URITemplate('https://api.github.com/users{/user}{/repo}')
        expanded = 'https://api.github.com/users/sigmavirus24/github3.py'
        self.assertEqual(
            t.expand({'repo': 'github3.py'}, user='sigmavirus24'),
            expanded
        )

    def test_str_repr(self):
        uri = 'https://api.github.com{/endpoint}'
        t = URITemplate(uri)
        self.assertEqual(str(t), uri)
        self.assertEqual(str(t.variables[0]), '/endpoint')
        self.assertEqual(repr(t), 'URITemplate("%s")' % uri)
        self.assertEqual(repr(t.variables[0]), 'URIVariable(/endpoint)')

    def test_hash(self):
        uri = 'https://api.github.com{/endpoint}'
        self.assertEqual(hash(URITemplate(uri)), hash(uri))

    def test_default_value(self):
        uri = 'https://api.github.com/user{/user=sigmavirus24}'
        t = URITemplate(uri)
        self.assertEqual(t.expand(),
                         'https://api.github.com/user/sigmavirus24')
        self.assertEqual(t.expand(user='lukasa'),
                         'https://api.github.com/user/lukasa')

    def test_query_expansion(self):
        t = URITemplate('{foo}')
        self.assertEqual(
            t.variables[0]._query_expansion('foo', None, False, False), None
        )

    def test_label_path_expansion(self):
        t = URITemplate('{foo}')
        self.assertEqual(
            t.variables[0]._label_path_expansion('foo', None, False, False),
            None
        )

    def test_semi_path_expansion(self):
        t = URITemplate('{foo}')
        v = t.variables[0]
        self.assertEqual(
            v._semi_path_expansion('foo', None, False, False),
            None
        )
        t.variables[0].operator = '?'
        self.assertEqual(
            v._semi_path_expansion('foo', ['bar', 'bogus'], True, False),
            'foo=bar&foo=bogus'
        )

    def test_string_expansion(self):
        t = URITemplate('{foo}')
        self.assertEqual(
            t.variables[0]._string_expansion('foo', None, False, False),
            None
        )

    def test_hashability(self):
        t = URITemplate('{foo}')
        u = URITemplate('{foo}')
        d = {t: 1}
        d[u] += 1
        self.assertEqual(d, {t: 2})


class TestURIVariable(TestCase):
    def setUp(self):
        self.v = variable.URIVariable('{foo}')

    def test_post_parse(self):
        v = self.v
        self.assertEqual(v.join_str, ',')
        self.assertEqual(v.operator, '')
        self.assertEqual(v.safe, '')
        self.assertEqual(v.start, '')

    def test_post_parse_plus(self):
        v = self.v
        v.operator = '+'
        v.post_parse()
        self.assertEqual(v.join_str, ',')
        self.assertEqual(v.safe, variable.URIVariable.reserved)
        self.assertEqual(v.start, '')

    def test_post_parse_octothorpe(self):
        v = self.v
        v.operator = '#'
        v.post_parse()
        self.assertEqual(v.join_str, ',')
        self.assertEqual(v.safe, variable.URIVariable.reserved)
        self.assertEqual(v.start, '#')

    def test_post_parse_question(self):
        v = self.v
        v.operator = '?'
        v.post_parse()
        self.assertEqual(v.join_str, '&')
        self.assertEqual(v.safe, '')
        self.assertEqual(v.start, '?')

    def test_post_parse_ampersand(self):
        v = self.v
        v.operator = '&'
        v.post_parse()
        self.assertEqual(v.join_str, '&')
        self.assertEqual(v.safe, '')
        self.assertEqual(v.start, '&')


class TestVariableModule(TestCase):
    def test_is_list_of_tuples(self):
        l = [(1, 2), (3, 4)]
        self.assertEqual(variable.is_list_of_tuples(l), (True, l))

        l = [1, 2, 3, 4]
        self.assertEqual(variable.is_list_of_tuples(l), (False, None))

    def test_list_test(self):
        l = [1, 2, 3, 4]
        self.assertEqual(variable.list_test(l), True)

        l = str([1, 2, 3, 4])
        self.assertEqual(variable.list_test(l), False)

    def test_list_of_tuples_test(self):
        l = [(1, 2), (3, 4)]
        self.assertEqual(variable.dict_test(l), False)

        d = dict(l)
        self.assertEqual(variable.dict_test(d), True)


class TestAPI(TestCase):
    uri = 'https://api.github.com{/endpoint}'

    def test_expand(self):
        self.assertEqual(expand(self.uri, {'endpoint': 'users'}),
                         'https://api.github.com/users')

    def test_partial(self):
        self.assertEqual(partial(self.uri), URITemplate(self.uri))
        uri = self.uri + '/sigmavirus24{/other}'
        self.assertEqual(
            partial(uri, endpoint='users'),
            URITemplate('https://api.github.com/users/sigmavirus24{/other}')
            )


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = api
"""

uritemplate.api
===============

This module contains the very simple API provided by uritemplate.

"""
from uritemplate.template import URITemplate


def expand(uri, var_dict=None, **kwargs):
    """Expand the template with the given parameters.

    :param str uri: The templated URI to expand
    :param dict var_dict: Optional dictionary with variables and values
    :param kwargs: Alternative way to pass arguments
    :returns: str

    Example::

        expand('https://api.github.com{/end}', {'end': 'users'})
        expand('https://api.github.com{/end}', end='gists')

    .. note:: Passing values by both parts, may override values in
              ``var_dict``. For example::

                  expand('https://{var}', {'var': 'val1'}, var='val2')

              ``val2`` will be used instead of ``val1``.

    """
    return URITemplate(uri).expand(var_dict, **kwargs)


def partial(uri, var_dict=None, **kwargs):
    """Partially expand the template with the given parameters.

    If all of the parameters for the template are not given, return a
    partially expanded template.

    :param dict var_dict: Optional dictionary with variables and values
    :param kwargs: Alternative way to pass arguments
    :returns: :class:`URITemplate`

    Example::

        t = URITemplate('https://api.github.com{/end}')
        t.partial()  # => URITemplate('https://api.github.com{/end}')

    """
    return URITemplate(uri).partial(var_dict, **kwargs)

########NEW FILE########
__FILENAME__ = template
"""

uritemplate.template
====================

This module contains the essential inner workings of uritemplate.

What treasures await you:

- URITemplate class

You see a treasure chest of knowledge in front of you.
What do you do?
>

"""

import re
from uritemplate.variable import URIVariable

template_re = re.compile('{([^\}]+)}')


class URITemplate(object):

    """This parses the template and will be used to expand it.

    This is the most important object as the center of the API.

    Example::

        from uritemplate import URITemplate
        import requests


        t = URITemplate(
            'https://api.github.com/users/sigmavirus24/gists{/gist_id}'
        )
        uri = t.expand(gist_id=123456)
        resp = requests.get(uri)
        for gist in resp.json():
            print(gist['html_url'])

    Please note::

        str(t)
        # 'https://api.github.com/users/sigmavirus24/gists{/gistid}'
        repr(t)  # is equivalent to
        # URITemplate(str(t))
        # Where str(t) is interpreted as the URI string.

    Also, ``URITemplates`` are hashable so they can be used as keys in
    dictionaries.

    """

    def __init__(self, uri):
        #: The original URI to be parsed.
        self.uri = uri
        #: A list of the variables in the URI. They are stored as
        #: :class:`URIVariable`\ s
        self.variables = [
            URIVariable(m.groups()[0]) for m in template_re.finditer(self.uri)
        ]
        #: A set of variable names in the URI.
        self.variable_names = set()
        for variable in self.variables:
            self.variable_names.update(variable.variable_names)

    def __repr__(self):
        return 'URITemplate("%s")' % self

    def __str__(self):
        return self.uri

    def __eq__(self, other):
        return self.uri == other.uri

    def __hash__(self):
        return hash(self.uri)

    def _expand(self, var_dict, replace):
        if not self.variables:
            return self.uri

        expansion = var_dict
        expanded = {}
        for v in self.variables:
            expanded.update(v.expand(expansion))

        def replace_all(match):
            return expanded.get(match.groups()[0], '')

        def replace_partial(match):
            match = match.groups()[0]
            var = '{%s}' % match
            return expanded.get(match) or var

        replace = replace_partial if replace else replace_all

        return template_re.sub(replace, self.uri)

    def expand(self, var_dict=None, **kwargs):
        """Expand the template with the given parameters.

        :param dict var_dict: Optional dictionary with variables and values
        :param kwargs: Alternative way to pass arguments
        :returns: str

        Example::

            t = URITemplate('https://api.github.com{/end}')
            t.expand({'end': 'users'})
            t.expand(end='gists')

        .. note:: Passing values by both parts, may override values in
                  ``var_dict``. For example::

                      expand('https://{var}', {'var': 'val1'}, var='val2')

                  ``val2`` will be used instead of ``val1``.

        """
        var_dict = var_dict or {}
        var_dict.update(kwargs)

        return self._expand(var_dict, False)

    def partial(self, var_dict=None, **kwargs):
        """Partially expand the template with the given parameters.

        If all of the parameters for the template are not given, return a
        partially expanded template.

        :param dict var_dict: Optional dictionary with variables and values
        :param kwargs: Alternative way to pass arguments
        :returns: :class:`URITemplate`

        Example::

            t = URITemplate('https://api.github.com{/end}')
            t.partial()  # => URITemplate('https://api.github.com{/end}')

        """
        var_dict = var_dict or {}
        var_dict.update(kwargs)

        return URITemplate(self._expand(var_dict, True))

########NEW FILE########
__FILENAME__ = variable
"""

uritemplate.variable
====================

This module contains the URIVariable class which powers the URITemplate class.

What treasures await you:

- URIVariable class

You see a hammer in front of you.
What do you do?
>

"""

try:
    from urllib import quote
except ImportError:
    # python 3
    from urllib.parse import quote
import collections


class URIVariable(object):

    """This object validates everything inside the URITemplate object.

    It validates template expansions and will truncate length as decided by
    the template.

    Please note that just like the :class:`URITemplate <URITemplate>`, this
    object's ``__str__`` and ``__repr__`` methods do not return the same
    information. Calling ``str(var)`` will return the original variable.

    This object does the majority of the heavy lifting. The ``URITemplate``
    object finds the variables in the URI and then creates ``URIVariable``
    objects.  Expansions of the URI are handled by each ``URIVariable``
    object. ``URIVariable.expand()`` returns a dictionary of the original
    variable and the expanded value. Check that method's documentation for
    more information.

    """

    operators = ('+', '#', '.', '/', ';', '?', '&', '|', '!', '@')
    reserved = ":/?#[]@!$&'()*+,;="

    def __init__(self, var):
        #: The original string that comes through with the variable
        self.original = var
        #: The operator for the variable
        self.operator = ''
        #: List of safe characters when quoting the string
        self.safe = ''
        #: List of variables in this variable
        self.variables = []
        #: List of variable names
        self.variable_names = []
        #: List of defaults passed in
        self.defaults = {}
        # Parse the variable itself.
        self.parse()
        self.post_parse()

    def __repr__(self):
        return 'URIVariable(%s)' % self

    def __str__(self):
        return self.original

    def parse(self):
        """Parse the variable.

        This finds the:
            - operator,
            - set of safe characters,
            - variables, and
            - defaults.

        """
        var_list = self.original
        if self.original[0] in URIVariable.operators:
            self.operator = self.original[0]
            var_list = self.original[1:]

        if self.operator in URIVariable.operators[:2]:
            self.safe = URIVariable.reserved

        var_list = var_list.split(',')

        for var in var_list:
            default_val = None
            name = var
            if '=' in var:
                name, default_val = tuple(var.split('=', 1))

            explode = False
            if name.endswith('*'):
                explode = True
                name = name[:-1]

            prefix = None
            if ':' in name:
                name, prefix = tuple(name.split(':', 1))
                prefix = int(prefix)

            if default_val:
                self.defaults[name] = default_val

            self.variables.append(
                (name, {'explode': explode, 'prefix': prefix})
            )

        self.variable_names = [name for (name, _) in self.variables]

    def post_parse(self):
        """Set ``start``, ``join_str`` and ``safe`` attributes.

        After parsing the variable, we need to set up these attributes and it
        only makes sense to do it in a more easily testable way.
        """
        self.safe = ''
        self.start = self.join_str = self.operator
        if self.operator == '+':
            self.start = ''
        if self.operator in ('+', '#', ''):
            self.join_str = ','
        if self.operator == '#':
            self.start = '#'
        if self.operator == '?':
            self.start = '?'
            self.join_str = '&'

        if self.operator in ('+', '#'):
            self.safe = URIVariable.reserved

    def _query_expansion(self, name, value, explode, prefix):
        """Expansion method for the '?' and '&' operators."""
        if value is None or (len(value) == 0 and value != ""):
            return None

        tuples, items = is_list_of_tuples(value)

        safe = self.safe
        if list_test(value) and not tuples:
            if explode:
                return self.join_str.join(
                    '%s=%s' % (name, quote(v, safe)) for v in value
                )
            else:
                value = ','.join(quote(v, safe) for v in value)
                return '%s=%s' % (name, value)

        if dict_test(value) or tuples:
            items = items or sorted(value.items())
            if explode:
                return self.join_str.join(
                    '%s=%s' % (
                        quote(k, safe), quote(v, safe)
                    ) for k, v in items
                )
            else:
                value = ','.join(
                    '%s,%s' % (
                        quote(k, safe), quote(v, safe)
                    ) for k, v in items
                )
                return '%s=%s' % (name, value)

        if value:
            value = value[:prefix] if prefix else value
            return '%s=%s' % (name, quote(value, safe))
        return name + '='

    def _label_path_expansion(self, name, value, explode, prefix):
        """Label and path expansion method.

        Expands for operators: '/', '.'

        """
        join_str = self.join_str
        safe = self.safe

        if value is None or (len(value) == 0 and value != ''):
            return None

        tuples, items = is_list_of_tuples(value)

        if list_test(value) and not tuples:
            if not explode:
                join_str = ','

            expanded = join_str.join(
                quote(v, safe) for v in value if value is not None
            )
            return expanded if expanded else None

        if dict_test(value) or tuples:
            items = items or sorted(value.items())
            format_str = '%s=%s'
            if not explode:
                format_str = '%s,%s'
                join_str = ','

            expanded = join_str.join(
                format_str % (
                    quote(k, safe), quote(v, safe)
                ) for k, v in items if v is not None
            )
            return expanded if expanded else None

        value = value[:prefix] if prefix else value
        return quote(value, safe)

    def _semi_path_expansion(self, name, value, explode, prefix):
        """Expansion method for ';' operator."""
        join_str = self.join_str
        safe = self.safe

        if value is None:
            return None

        if self.operator == '?':
            join_str = '&'

        tuples, items = is_list_of_tuples(value)

        if list_test(value) and not tuples:
            if explode:
                expanded = join_str.join(
                    '%s=%s' % (
                        name, quote(v, safe)
                    ) for v in value if v is not None
                )
                return expanded if expanded else None
            else:
                value = ','.join(quote(v, safe) for v in value)
                return '%s=%s' % (name, value)

        if dict_test(value) or tuples:
            items = items or sorted(value.items())

            if explode:
                return join_str.join(
                    '%s=%s' % (
                        quote(k, safe), quote(v, safe)
                    ) for k, v in items if v is not None
                )
            else:
                expanded = ','.join(
                    '%s,%s' % (
                        quote(k, safe), quote(v, safe)
                    ) for k, v in items if v is not None
                )
                return '%s=%s' % (name, expanded)

        value = value[:prefix] if prefix else value
        if value:
            return '%s=%s' % (name, quote(value, safe))

        return name

    def _string_expansion(self, name, value, explode, prefix):
        if value is None:
            return None

        tuples, items = is_list_of_tuples(value)

        if list_test(value) and not tuples:
            return ','.join(quote(v, self.safe) for v in value)

        if dict_test(value) or tuples:
            items = items or sorted(value.items())
            format_str = '%s=%s' if explode else '%s,%s'

            return ','.join(
                format_str % (
                    quote(k, self.safe), quote(v, self.safe)
                ) for k, v in items
            )

        value = value[:prefix] if prefix else value
        return quote(value, self.safe)

    def expand(self, var_dict=None):
        """Expand the variable in question.

        Using ``var_dict`` and the previously parsed defaults, expand this
        variable and subvariables.

        :param dict var_dict: dictionary of key-value pairs to be used during
            expansion
        :returns: dict(variable=value)

        Examples::

            # (1)
            v = URIVariable('/var')
            expansion = v.expand({'var': 'value'})
            print(expansion)
            # => {'/var': '/value'}

            # (2)
            v = URIVariable('?var,hello,x,y')
            expansion = v.expand({'var': 'value', 'hello': 'Hello World!',
                                  'x': '1024', 'y': '768'})
            print(expansion)
            # => {'?var,hello,x,y':
            #     '?var=value&hello=Hello%20World%21&x=1024&y=768'}

        """
        return_values = []

        for name, opts in self.variables:
            value = var_dict.get(name, None)
            if not value and value != '' and name in self.defaults:
                value = self.defaults[name]

            if value is None:
                continue

            expanded = None
            if self.operator in ('/', '.'):
                expansion = self._label_path_expansion
            elif self.operator in ('?', '&'):
                expansion = self._query_expansion
            elif self.operator == ';':
                expansion = self._semi_path_expansion
            else:
                expansion = self._string_expansion

            expanded = expansion(name, value, opts['explode'], opts['prefix'])

            if expanded is not None:
                return_values.append(expanded)

        if return_values:
            return {
                self.original: self.start + self.join_str.join(return_values)
            }

        return {self.original: ''}


def is_list_of_tuples(value):
    if not isinstance(value, (list, tuple)):
        return False, None

    try:
        dict(value)
    except:
        return False, None
    else:
        return True, value


def list_test(value):
    return isinstance(value, (list, tuple))


def dict_test(value):
    return isinstance(value, (dict, collections.MutableMapping))

########NEW FILE########
