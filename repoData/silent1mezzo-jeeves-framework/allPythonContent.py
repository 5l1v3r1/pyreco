__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Jeeves Framework documentation build configuration file, created by
# sphinx-quickstart on Fri Apr 13 14:22:22 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
import jeeves
from jeeves import __version__

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Jeeves Framework'
copyright = u'2012, A <a href="http://procrastinatingdev.com">Adam McKerlie</a>'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'JeevesFrameworkdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'JeevesFramework.tex', u'Jeeves Framework Documentation',
   u'Adam McKerlie', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'jeevesframework', u'Jeeves Framework Documentation',
     [u'Adam McKerlie'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'JeevesFramework', u'Jeeves Framework Documentation',
   u'Adam McKerlie', 'JeevesFramework', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = jeeves-admin
#!/usr/bin/env python
import sys
from jeeves.core import management

if __name__ == "__main__":
    management.execute_from_command_line(sys.argv[1:])

########NEW FILE########
__FILENAME__ = base_settings
####################
# Default Settings #
####################
HOST = 'irc.freenode.net'
PORT = 6667
PASSWORD = None
SSL = False
SERVER_PASSWORD = None
NICKNAME = ''
REALNAME = ''
CHANNEL = ''

###########
# Plugins #
###########
PLUGINS = ()

#############
# Shortener #
#############
SHORTENER_BACKEND = 'google'
SHORTENER_LOGIN = None
SHORTENER_API_KEY = None

###########
#  Cache  #
###########
CACHE_BACKEND = None
CACHE_LOCATION = None
CACHE_DEFAULT_TIMEOUT = 300

#############
# TicketBot #
#############
TICKETBOT_TICKET_URL = None
TICKETBOT_CHANGESET_URL = None

########NEW FILE########
__FILENAME__ = bot
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("JEEVES_SETTINGS_MODULE", "settings")

    from jeeves.core.management import execute_from_command_line

    execute_from_command_line(sys.argv[1:])

########NEW FILE########
__FILENAME__ = example
from jeeves.core.plugin import CommandPlugin, GenericPlugin

class ExampleGenericPlugin(GenericPlugin):
    name = 'Example Generic Plugin'
    help_text = 'This is the help text for a generic plugin.'

    def __init__(self, *args, **kwargs):
        super(ExampleGenericPlugin, self).__init__(self.name, *args, **kwargs)

    def handle_message(self, channel, nickname, message):
        self.say(channel, "I am a Generic Plugin")

class ExampleCommandPlugin(CommandPlugin):
    name = 'Example Command Plugin'
    help_text = 'This is the help text for a command plugin.'
    command = ['example', ]

    def __init__(self, *args, **kwargs):
        super(ExampleCommandPlugin, self).__init__(self.name, self.command, *args, **kwargs)

    def handle_message(self, channel, nickname, message, command):
        self.say(channel, "I am a Command Plugin")

########NEW FILE########
__FILENAME__ = settings
# Jeeves settings


HOST = 'irc.freenode.net'
PORT = 6667  # 6697 for SSL
SSL = False
SERVER_PASSWORD = None
PASSWORD = None
NICKNAME = 'Jeeves'
REALNAME = 'Jeeves Bot: A Framework for creating IRC Bots'

CHANNEL = '#jeeves'

PLUGINS = (
    #It is strongly recommended that you don't remove these (jeeves.core.plugins.*) plugins
    'jeeves.core.plugins.admin.HelpPlugin',

    #Optional Jeeves Plugins. Uncomment any you'd like to use.
    #'jeeves.contrib.plugins.ticketbot.TicketBotPlugin',
    #'jeeves.contrib.plugins.shortener.ShortenPlugin',

    #Here you can add any of the plugins that you create.
    #'plugins.example.ExampleGenericPlugin',
    #'plugins.example.ExampleCommandPlugin',
)

"""
###########################
# Shorten Plugin Settings #
###########################
# Backend shortening service. Defaults to google
SHORTENER_BACKEND = 'google'
# Login account. Defaults to None
SHORTENER_LOGIN = None
# API Key. Defaults to None
SHORTENER_API_KEY = None
"""

"""
#############################
# TicketBot Plugin Settings #
#############################
TICKETBOT_TICKET_URL = None  # Example: 'https://github.com/silent1mezzo/jeeves-framework/issues/%s'
TICKETBOT_CHANGESET_URL = None  # Example: 'https://github.com/silent1mezzo/jeeves-framework/commit/%s'
"""

########NEW FILE########
__FILENAME__ = shortener
from jeeves.conf import settings
from jeeves.core.plugin import CommandPlugin
from jeeves.core import exceptions
import unicodedata

try:
    import json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        raise ImportError("You need to have a json parser, easy_install simplejson")

import requests

VALID_BACKENDS = [
    'google',
    'bitly',
    'isgd',
]

"""
    Shorten Plugin.
    A basic Jeeves plugin that displays help messages for the user. T
"""
class ShortenPlugin(CommandPlugin):
    name = 'Shorten Plugin'
    command = ['shorten', '-s']

    def __init__(self, *args, **kwargs):
        backend = getattr(settings, 'SHORTENER_BACKEND', None)
        if not backend:
            raise exceptions.ImproperlyConfigured(
                "You need to specify SHORTENER_BACKEND in settings.py. Valid backends include: %s" % ', '.join(VALID_BACKENDS)
            )
        elif backend not in VALID_BACKENDS:
            raise exceptions.ImproperlyConfigured(
                "You must specify a valid backend. Valid backends include: %s" % ', '.join(VALID_BACKENDS)
            )
        else:
            self.backend = backend

        if backend == 'bitly' and not getattr(settings, 'SHORTENER_LOGIN', None) and not getattr(settings, 'SHORTENER_API_KEY', None):
            raise exceptions.ImproperlyConfigured(
                "You need to specify SHORTENER_LOGIN and SHORTENER_API_KEY when using bit.ly"
            )

        super(ShortenPlugin, self).__init__(self.name, self.command, *args, **kwargs)

    def handle_message(self, channel, nickname, message, command):
        tokenized_msg = message.split()
        if len(tokenized_msg) != 1:
            self.say(nickname, "%s: %s" % (nickname, self.help_text))
        else:
            short_url = None
            if self.backend == 'google':
                # Grab shortened URL from Google.
                short_url = shorten_google(tokenized_msg[0])
            elif self.backend == 'bitly':
                short_url = shorten_bitly(tokenized_msg[0])
            elif self.backend == 'isgd':
                short_url = shorten_isgd(tokenized_msg[0])

            if short_url:
                self.say(nickname, "%s" % short_url)
            else:
                self.say(nickname, "There was an error shortening your link")

    @property
    def help_text(self):
        help_text = [
            "usage: %s: [shorten|-s] <link>" % settings.NICKNAME,
        ]

        return help_text

def normalize_unicode(text):
    return unicodedata.normalize('NFKD', text).encode('ascii','ignore')

def shorten_bitly(url):
    long_url = "https://api-ssl.bitly.com/v3/shorten"
    login = getattr(settings, 'SHORTENER_LOGIN', None)
    api_key = getattr(settings, 'SHORTENER_API_KEY', None)
    data = {'login': login, 'apiKey': api_key, 'longUrl': url, 'format': 'json'}

    results = requests.post(long_url, data=data)
    results = json.loads(results.text)

    short_url = results.get('data', None)
    if short_url:
        return normalize_unicode(short_url.get('url'))
    else:
        return None

def shorten_isgd(url):
    long_url = "http://is.gd/create.php"

    data = {'format': 'json', 'url': url}
    results = requests.post(long_url, data=data)

    results = json.loads(results.text)
    short_url = results.get('shorturl', None)
    if short_url:
        return normalize_unicode(short_url)
    else:
        return None

def shorten_google(url):
    long_url = "https://www.googleapis.com/urlshortener/v1/url"

    headers = {'content-type': 'application/json'}
    results = requests.post(long_url, json.dumps(dict(longUrl=url)), headers=headers)

    results = json.loads(results.text)
    short_url = results.get('id', None)
    if short_url:
        return normalize_unicode(short_url)
    else:
        return None

########NEW FILE########
__FILENAME__ = ticketbot
"""
The following code has been modified from https://github.com/idangazit/django-ticketbot/.
"""

"""
Copyright (c) 2011 Idan Gazit and Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyrigh
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of this project nor the names of its contributors may
       be used to endorse or promote products derived from this software without
       specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

from jeeves.conf import settings
from jeeves.core.plugin import GenericPlugin
from jeeves.core import exceptions

import re

ticket_re = re.compile(r'(?<!build)(?:^|\s)#(\d+)')

changeset_re = re.compile(r'\br(\d+)\b')
changeset_re2 = re.compile(r'(?:^|\s)\[(\d+)\]')

changeset_regit = re.compile(r'\b[0-9a-f]{7,40}\b')

class TicketBotPlugin(GenericPlugin):
    name = 'TicketBot Plugin'
    help_text = 'This is the help text for a generic plugin.'

    def __init__(self, *args, **kwargs):
        self.ticket_url = getattr(settings, 'TICKETBOT_TICKET_URL', None)
        if not self.ticket_url:
            raise exceptions.ImproperlyConfigured(
                "You need to specify TICKETBOT_TICKET_URL in settings.py."
            )

        self.changeset_url = getattr(settings, 'TICKETBOT_CHANGESET_URL', None)
        if not self.changeset_url:
            raise exceptions.ImproperlyConfigured(
                "You need to specify TICKETBOT_CHANGESET_URL in settings.py."
            )

        super(TicketBotPlugin, self).__init__(self.name, *args, **kwargs)

    def handle_message(self, channel, nickname, message):
        """This will get called when the bot receives a message."""
        tickets = ticket_re.findall(message)
        changesets = changeset_re.findall(message)
        changesets.extend(changeset_re2.findall(message))
        changesets.extend(changeset_regit.findall(message))

        # Check to see if they're sending me a private message
        if channel == nickname:
            target = nickname
        else:
            target = channel

        if message.startswith(settings.NICKNAME) and not tickets and not changesets:
            self.say(nickname, "Hi, I'm Django's ticketbot. I know how to linkify tickets like \"#12345\", and changesets like \"r12345\" or \"[12345]\".")
            return

        for ticket in set(tickets):
            self.say(target, self.ticket_url % ticket)
        for changeset in set(changesets):
            self.say(target, self.changeset_url % changeset)
        return

########NEW FILE########
__FILENAME__ = bot
from jeeves import __version__ as jeeves_version
from jeeves.conf import settings
from jeeves.core.handlers import base

from twisted.words.protocols import irc
from twisted.internet import protocol

class Bot(irc.IRCClient):
    plugins = {}

    def __init__(self):
        self.handler = base.BaseHandler(self)
        self.password = settings.SERVER_PASSWORD
        print "Jeeves version %s" % jeeves_version

    def signedOn(self):
        #Initialize Plugins
        self.handler.load_plugins()

        #Run any plugins on signon
        self.join(self.factory.channel, self.factory.password)

        #Another use already exists with the same username. Update the stored nickname to what IRC gave us
        if self.nickname != settings.NICKNAME:
            settings.NICKNAME = self.nickname
        print "Signed on as %s." % self.nickname

    def joined(self, channel):
        print "Joined %s." % channel

    def privmsg(self, user, channel, msg):
        self.handler.message(user, channel, msg)

    def irc_ERR_PASSWDMISMATCH(self, prefix, params):
        print 'wrong password'

    @property
    def nickname(self):
        return self.factory.nickname

    @property
    def channel(self):
        return self.factory.channel

class BotFactory(protocol.ClientFactory):
    protocol = Bot

    def __init__(self, channel, nickname, password):
        self.channel = channel
        self.nickname = nickname
        self.password = password

    def clientConnectionLost(self, connector, reason):
        print "Lost connection (%s), reconnecting." % (reason,)
        connector.connect()

    def clientConnectionFailed(self, connector, reason):
        print "Could not connect: %s" % (reason,)

########NEW FILE########
__FILENAME__ = base
from jeeves.utils.encoding import smart_str

class BaseCache(object):
    def __init__(self, params):
        timeout = params.get('timeout', params.get('TIMEOUT', 300))
        try:
            timeout = int(timeout)
        except (ValueError, TypeError):
            timeout = 300

        self.default_timeout = timeout

    def make_key(self, key):
        return smart_str(key)

    def set(self, key, value):
        """Sets a value in the cache for the given key."""
        raise NotImplementedError

    def get(self, key, default=None):
        """
        Fetch a given key from the cache. If the key does not exist, return
        default, which itself defaults to None.
        """
        raise NotImplementedError

    def incr(self, key, delta=1):
        """
        Add delta to value in the cache. If the key does not exist, raise a
        ValueError exception.
        """
        raise NotImplementedError

    def decr(self, key, delta=1):
        """
        Subtract delta from value in the cache. If the key does not exist, raise
        a ValueError exception.
        """
        return self.incr(key, -delta)

    def delete(self, key):
        """Remove a given key from the cache."""
        raise NotImplementedError

    def clear(self):
        """Remove *all* values from the cache at once."""
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = localmem
from jeeves.core.cache.backends.base import BaseCache
try:
    import cPickle as pickle
except ImportError:
    import pickle

_cache = {}

class LocalMemCache(BaseCache):
    def __init__(self, name, params):
        BaseCache.__init__(self, params)
        global _cache
        self._cache = _cache

    def set(self, key, value):
        key = self.make_key(key)
        pickled = pickle.dumps(value, pickle.HIGHEST_PROTOCOL)
        self._cache[key] = pickled

    def get(self, key, default=None):
        key = self.make_key(key)
        try:
            pickled = self._cache[key]
            return pickle.loads(pickled)
        except (pickle.PickleError, KeyError):
            return default

    def incr(self, key, delta=1):
        key = self.make_key(key)
        value = self.get(key)

        if value is None:
            raise ValueError("Key '%s' not found" % key)

        new_value = value + delta
        self.set(key, new_value)

        return new_value

    def delete(self, key):
        key = self.make_key(key)
        try:
            del self._cache[key]
        except KeyError:
            pass

    def clear(self):
        self._cache.clear()

########NEW FILE########
__FILENAME__ = memcached
from jeeves.core.cache.backends.base import BaseCache

class MemCache(BaseCache):
    import memcache

    def __init__(self, server, params):
        BaseCache.__init__(self, params)
        global _cache
        self._cache = self.memcache.Client([server])

    def set(self, key, value):
        key = self.make_key(key)

        self._cache.set(key, value)

    def get(self, key, default=None):
        key = self.make_key(key)

        value = self._cache.get(key)

        if value == None:
            value = default

        return value

    def incr(self, key, delta=1):
        key = self.make_key(key)

        try:
            value = self._cache.incr(key, delta)
        except self.pylibmc.NotFound:
            value = None

        if value == None:
            raise ValueError("Key '%s' not found" % key)

        return value

    def decr(self, key, delta=1):
        key = self.make_key(key)

        try:
            value = self._cache.decr(key, delta)
        except Exception:
            value = None

        if value == None:
            raise ValueError("Key '%s' not found" % key)

        return value

    def delete(self, key):
        key = self.make_key(key)
        self._cache.delete(key)

    def clear(self):
        self._cache.flush_all()


########NEW FILE########
__FILENAME__ = exceptions
class JeevesException(Exception):
    pass

class NotImplemented(JeevesException, NotImplementedError):
    pass

class InvalidCommand(JeevesException):
    pass

class ImproperlyConfigured(JeevesException):
    pass

class InvalidPlugin(JeevesException):
    pass

########NEW FILE########
__FILENAME__ = base
from jeeves.conf import settings
from jeeves.core import exceptions
from jeeves.utils import importlib, utils

class BaseHandler(object):
    def __init__(self, protocol=None):
        self.protocol = protocol

        self._command_plugins = {}
        self._generic_plugins = []

    def load_plugins(self):
        """
        Populate plugin lists from settings.PLUGINS.

        """

        for plugin_path in settings.PLUGINS:
            try:
                try:
                    pg_module, pg_classname = plugin_path.rsplit('.', 1)
                except ValueError, e:
                    raise exceptions.ImproperlyConfigured('%s isn\'t a plugin module' % plugin_path)

                try:
                    mod = importlib.import_module(pg_module)
                except ImportError, e:
                    raise exceptions.ImproperlyConfigured('Error importing plugin %s: "%s"' % (pg_module, e))

                try:
                    pg_class = getattr(mod, pg_classname)
                except AttributeError, e:
                    raise exceptions.ImproperlyConfigured('Plugins module "%s" does not define a "%s" class' % (pg_module, pg_classname))

                try:
                    pg_instance = pg_class(handler=self, protocol=self.protocol)
                except TypeError, e:
                    raise exceptions.InvalidPlugin('Plugins class "%s" does not provide a command: %s' % (pg_class, e))

                if hasattr(pg_instance, 'command'):
                    if isinstance(pg_instance.command, str):
                        self._command_plugins[pg_instance.command] = pg_instance
                    else:
                        for command in pg_instance.command:
                            self._command_plugins[command] = pg_instance
                else:
                    self._generic_plugins.append(pg_instance)
            except exceptions.JeevesException, e:
                if pg_classname:
                    print "%s: %s" % (pg_classname, e)
                else:
                    print e

    def message(self, user, channel, msg):
        user = user.split('!', 1)[0]

        nick, command, message = utils.parse_message(msg, self._command_plugins.keys())

        for plugin in self._generic_plugins:
            plugin.handle_message(channel=channel, nickname=user, message=message)

        if (nick or channel == settings.NICKNAME) and command:
            self._command_plugins[command].handle_message(channel=channel, nickname=user, message=message, command=command)

########NEW FILE########
__FILENAME__ = plugin
from jeeves.core import exceptions

class Plugin(object):
    help_text = ''

    def __init__(self, **kwargs):
        self.protocol = kwargs['protocol']
        self.handler = kwargs['handler']

    def handle_message(self, channel=None, nickname=None, command=None, msg=None):
        raise exceptions.NotImplemented('Plugin %s must implement handle_message()' % self.__class__)

    def say(self, channel, msg):
        self.protocol.msg(channel, msg)

    @property
    def help_text(self):
        return self.help_text

    @property
    def name(self):
        return self.name

    @property
    def command(self):
        return self.command

'''
    Generic Plugin

    Runs on every message sent to a channel.
    e.g. A plugin that logs every message, A plugin that is triggered off specific sayings
'''
class GenericPlugin(Plugin):
    def __init__(self, name, **kwargs):
        super(GenericPlugin, self).__init__(**kwargs)

'''
    Command Plugin

    Runs only when mesages are directed to the bot (either private or not).
    e.g. you: <botname> define "pedantic" would return the definition for the word pedantic
'''
class CommandPlugin(Plugin):
    def __init__(self, name, command, **kwargs):
        super(CommandPlugin, self).__init__(**kwargs)

########NEW FILE########
__FILENAME__ = admin
from jeeves.core.plugin import CommandPlugin
from jeeves.conf import settings
"""
    Help Plugin.
    A basic Jeeves plugin that displays help messages for the user. T
"""
class HelpPlugin(CommandPlugin):
    name = 'Help Plugin'
    command = ['help', '-h']

    def __init__(self, *args, **kwargs):
        super(HelpPlugin, self).__init__(self.name, self.command, *args, **kwargs)

    def handle_message(self, channel, nickname, message, command):
        tokenized_msg = message.split()

        if tokenized_msg and tokenized_msg[0] == "list_commands":
            self.say(nickname, "Here's a list of all of the available commands:")
            for key in self.handler._command_plugins.keys():
                self.say(nickname, "Jeeves: %s" % key)
        elif tokenized_msg and tokenized_msg[0] in self.handler._command_plugins.keys():
            for text in self.handler._command_plugins[tokenized_msg[0]].help_text:
                self.say(nickname, text)
        else:
            for text in self.help_text:
                self.say(nickname, text)

    @property
    def help_text(self):
        help_text = [
            "usage: %s: [help|-h] [list_commands] [command_name]" % settings.NICKNAME,
            "To list available plugins `%s: help list_commands`" % settings.NICKNAME,
            "To get specific help for a plugin `%s: help [command_name]`" % settings.NICKNAME,
        ]

        return help_text

########NEW FILE########
__FILENAME__ = encoding
import types


def smart_str(s, encoding='utf-8', strings_only=False, errors='strict'):
    """
    Returns a bytestring version of 's', encoded as specified in 'encoding'.

    If strings_only is True, don't convert (some) non-string-like objects.
    """
    if strings_only and isinstance(s, (types.NoneType, int)):
        return s

    if not isinstance(s, basestring):
        try:
            return str(s)
        except UnicodeEncodeError:
            if isinstance(s, Exception):
                # An Exception subclass containing non-ASCII data that doesn't
                # know how to print itself properly. We shouldn't raise a
                # further exception.
                return ' '.join([smart_str(arg, encoding, strings_only,
                        errors) for arg in s])
            return unicode(s).encode(encoding, errors)
    elif isinstance(s, unicode):
        return s.encode(encoding, errors)
    elif s and encoding != 'utf-8':
        return s.decode('utf-8', errors).encode(encoding, errors)
    else:
        return s

########NEW FILE########
__FILENAME__ = importlib
"""
Copyright (c) Django Software Foundation and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, 
       this list of conditions and the following disclaimer.
    
    2. Redistributions in binary form must reproduce the above copyright 
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of Django nor the names of its contributors may be used
       to endorse or promote products derived from this software without
       specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# Taken from Python 2.7 with permission from/by the original author.
import sys

def _resolve_name(name, package, level):
    """Return the absolute name of the module to be imported."""
    if not hasattr(package, 'rindex'):
        raise ValueError("'package' not set to a string")
    dot = len(package)
    for x in xrange(level, 1, -1):
        try:
            dot = package.rindex('.', 0, dot)
        except ValueError:
            raise ValueError("attempted relative import beyond top-level "
                              "package")
    return "%s.%s" % (package[:dot], name)


def import_module(name, package=None):
    """Import a module.

    The 'package' argument is required when performing a relative import. It
    specifies the package to use as the anchor point from which to resolve the
    relative import to an absolute import.

    """
    if name.startswith('.'):
        if not package:
            raise TypeError("relative imports require the 'package' argument")
        level = 0
        for character in name:
            if character != '.':
                break
            level += 1
        name = _resolve_name(name[level:], package, level)

    __import__(name)
    return sys.modules[name]

########NEW FILE########
__FILENAME__ = utils
from jeeves.conf import settings

def pop_message(lst, item):
    index = lst.index(item)
    lst.pop(index)
    return lst
'''
    Parses a given message directed at the bot.

    e.g. you: botname <command> query (In a public channel)
    e.g. you: <command> query (In a private channel with the bot)

    Returns:
        Nickame (Optional) - Bots nickname (not needed in private channel)
        Command - Command used for a given plugin
        Query - Passed to the plugin
'''
def parse_message(message, commands):
    nick = settings.NICKNAME.lower()
    plugin_command = None
    tokenized_msg = message.lower().split()

    if nick == tokenized_msg[0] or '%s:' % nick == tokenized_msg[0]:
        nickname = nick
        try:
            tokenized_msg = pop_message(tokenized_msg, nick)
        except ValueError:
            # Happens when users calls bot with `BotName: msg`
            tokenized_msg = pop_message(tokenized_msg, '%s:' % nick)
    else:
        nickname = None

    for command in commands:
        if tokenized_msg:
            if command.lower() == tokenized_msg[0]:
                plugin_command = command
                tokenized_msg = pop_message(tokenized_msg, command.lower())

    message = ' '.join(tokenized_msg)
    return (nickname, plugin_command, message)

########NEW FILE########
__FILENAME__ = plugin_test
"""
    Example Plugins used for Testing
"""

from jeeves.core.plugin import CommandPlugin, GenericPlugin

class ExampleGenericPlugin(GenericPlugin):
    name = 'Example Generic Plugin'
    help_text = 'This is the help text for a generic plugin.'

    def __init__(self, *args, **kwargs):
        super(ExampleGenericPlugin, self).__init__(self.name, *args, **kwargs)

    def handle_message(self, channel, message):
        self.say(channel, "I am a Generic Plugin")

class ExampleCommandPlugin(CommandPlugin):
    name = 'Example Command Plugin'
    help_text = 'This is the help text for a command plugin.'
    command = 'example'

    def __init__(self, *args, **kwargs):
        super(ExampleCommandPlugin, self).__init__(self.name, self.command, *args, **kwargs)

    def handle_message(self, channel, message):
        self.say(channel, "I am a Command Plugin")

class ExampleNoNamePlugin(GenericPlugin):
    help_text = 'This is the help text for a generic plugin.'

    def __init__(self, *args, **kwargs):
        super(ExampleNoNamePlugin, self).__init__(*args, **kwargs)

    def handle_message(self, channel, message):
        self.say(channel, "I am a Generic Plugin")

class ExampleNoCommandPlugin(CommandPlugin):
    name = 'Example Command Plugin'
    help_text = 'This is the help text for a command plugin.'

    def __init__(self, *args, **kwargs):
        super(ExampleCommandPlugin, self).__init__(self.name, *args, **kwargs)

    def handle_message(self, channel, message):
        self.say(channel, "I am a Command Plugin")

########NEW FILE########
__FILENAME__ = test_jeeves
# -*- coding: utf-8 -*-

import os
import unittest

os.environ.setdefault("JEEVES_SETTINGS_MODULE", "jeeves.conf.project_template.settings")
from jeeves.conf import settings
from jeeves.core.bot import BotFactory
from jeeves.core.cache import get_cache

CHANNEL = "#test"
USERNAME = "tester"

"""
    Test Suite for Jeeves bot
"""
class JeevesTestSuite(unittest.TestCase):

    def setUp(self):
        super(JeevesTestSuite, self).setUp()
        factory = BotFactory(settings)
        self.bot = factory.buildProtocol(None)


"""
    Test Suite for Jeeves Plugins
"""
class PluginsTestSuite(unittest.TestCase):
    def setUp(self):
        super(PluginsTestSuite, self).setUp()
        factory = BotFactory(CHANNEL, USERNAME, None)
        self.bot = factory.buildProtocol(None)

    def test_load(self):
        settings.PLUGINS = [
            'tests.plugin_test.ExampleGenericPlugin',
            'tests.plugin_test.ExampleCommandPlugin',
        ]

        self.bot.handler.load_plugins()
        self.assertEqual(1, len(self.bot.handler._command_plugins))
        self.assertEqual(1, len(self.bot.handler._generic_plugins))

    def test_help(self):
        settings.PLUGINS = [
            'jeeves.core.plugins.admin.HelpPlugin',
        ]

        self.bot.handler.load_plugins()
        self.assertEqual(2, len(self.bot.handler._command_plugins))

    def test_shortener(self):
        settings.PLUGINS = [
            'jeeves.contrib.plugins.shortener.ShortenPlugin',
        ]
        self.bot.handler.load_plugins()
        self.assertEqual(2, len(self.bot.handler._command_plugins))

"""
    A common set of tests that should apply to all Cache Backends
"""
class BaseCacheTestSuite(object):

    def test_simple(self):
        self.cache.set('test', 'value')
        self.assertEquals(self.cache.get('test'), 'value')

    def test_non_existent(self):
        self.assertEquals(self.cache.get('non_existent'), None)
        self.assertEquals(self.cache.get('non_existent', 'hello!'), 'hello!')

    def test_delete(self):
        self.cache.set('key1', 'value1')
        self.cache.set('key2', 'value2')
        self.assertEquals(self.cache.get('key1'), 'value1')
        self.cache.delete('key1')
        self.assertEquals(self.cache.get('key1'), None)
        self.assertEquals(self.cache.get('key2'), 'value2')

    def test_unicode(self):
        stuff = {
            u'ascii': u'ascii_value',
            u'unicode_ascii': u'Iñtërnâtiônàlizætiøn1',
            u'Iñtërnâtiônàlizætiøn': u'Iñtërnâtiônàlizætiøn2',
            u'ascii2': {u'x': 1}
            }

        for (key, value) in stuff.items():
            self.cache.set(key, value)
            self.assertEquals(self.cache.get(key), value)

        for key in stuff:
            self.cache.delete(key)
            self.assertEquals(self.cache.get(key), None)

    def test_increment(self):
        self.cache.set('incr', 1)
        self.cache.incr('incr')
        self.assertEquals(self.cache.get('incr'), 2)
        self.cache.incr('incr', 10)
        self.assertEquals(self.cache.get('incr'), 12)
        self.assertRaises(ValueError, self.cache.incr, 'non_existent_key')

    def test_decrement(self):
        self.cache.set('decr', 43)
        self.cache.decr('decr')
        self.assertEquals(self.cache.get('decr'), 42)
        self.cache.decr('decr', 10)
        self.assertEquals(self.cache.get('decr'), 32)

    def tearDown(self):
        self.cache.clear()

class LocalMemCacheTestSuite(BaseCacheTestSuite, unittest.TestCase):

    def setUp(self):
        self.cache = get_cache('jeeves.core.cache.backends.localmem.LocalMemCache')

class MemCacheTestSuite(BaseCacheTestSuite, unittest.TestCase):

    def setUp(self):
        settings.CACHE_LOCATION = '127.0.0.1:11211'
        self.cache = get_cache('jeeves.core.cache.backends.memcached.MemCache')

    def test_invalid_keys(self):
        # Memcached can't have whitespace in keys
        self.assertRaises(Exception, self.cache.set, 'a key with whitespace', 'value')
        self.assertRaises(Exception, self.cache.set, 'a' * 251, 'value')

"""
    Test Suite for Jeeves.conf.settings
"""
class SettingsTestSuite(unittest.TestCase):
    def setUp(self):
        pass

    def test_override(self):
        settings.TEST = 'test'
        self.assertEqual('test', settings.TEST)
        del settings.TEST

    def test_settings_delete(self):
        settings.TEST = 'test'
        self.assertEqual('test', settings.TEST)
        del settings.TEST
        self.assertRaises(AttributeError, getattr, settings, 'TEST')

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
