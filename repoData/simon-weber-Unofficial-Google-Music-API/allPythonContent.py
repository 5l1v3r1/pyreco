__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Unofficial Google Music Api documentation build configuration file, created by
# sphinx-quickstart on Sat Feb 25 00:36:45 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), os.pardir, os.pardir))

from gmusicapi import __version__

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ["sphinx.ext.autodoc"]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'gmusicapi'
copyright = u'2014 Simon Weber'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'UnofficialGoogleMusicApidoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'UnofficialGoogleMusicApi.tex', u'Unofficial Google Music Api Documentation',
   u'Simon Weber', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'unofficialgooglemusicapi', u'Unofficial Google Music Api Documentation',
     [u'Simon Weber'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'UnofficialGoogleMusicApi', u'Unofficial Google Music Api Documentation',
   u'Simon Weber', 'UnofficialGoogleMusicApi', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = example
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from getpass import getpass

from gmusicapi import Mobileclient


def ask_for_credentials():
    """Make an instance of the api and attempts to login with it.
    Return the authenticated api.
    """

    # We're not going to upload anything, so the Mobileclient is what we want.
    api = Mobileclient()

    logged_in = False
    attempts = 0

    while not logged_in and attempts < 3:
        email = raw_input('Email: ')
        password = getpass()

        logged_in = api.login(email, password)
        attempts += 1

    return api


def demonstrate():
    """Demonstrate some api features."""

    api = ask_for_credentials()

    if not api.is_authenticated():
        print "Sorry, those credentials weren't accepted."
        return

    print 'Successfully logged in.'
    print

    # Get all of the users songs.
    # library is a big list of dictionaries, each of which contains a single song.
    print 'Loading library...',
    library = api.get_all_songs()
    print 'done.'

    print len(library), 'tracks detected.'
    print

    # Show some info about a song. There is no guaranteed order;
    # this is essentially a random song.
    first_song = library[0]
    print "The first song I see is '{}' by '{}'.".format(
        first_song['title'].encode('utf-8'),
        first_song['artist'].encode('utf-8'))

    # We're going to create a new playlist and add a song to it.
    # Songs are uniquely identified by 'song ids', so let's get the id:
    song_id = first_song['id']

    print "I'm going to make a new playlist and add that song to it."
    print "I'll delete it when we're finished."
    print
    playlist_name = raw_input('Enter a name for the playlist: ')

    # Like songs, playlists have unique ids.
    # Google Music allows more than one playlist of the same name;
    # these ids are necessary.
    playlist_id = api.create_playlist(playlist_name)
    print 'Made the playlist.'
    print

    # Now let's add the song to the playlist, using their ids:
    api.add_songs_to_playlist(playlist_id, song_id)
    print 'Added the song to the playlist.'
    print

    # We're all done! The user can now go and see that the playlist is there.
    # The web client syncs our changes in real time.
    raw_input('You can now check on Google Music that the playlist exists.\n'
              'When done, press enter to delete the playlist:')
    api.delete_playlist(playlist_id)
    print 'Deleted the playlist.'

    # It's good practice to logout when finished.
    api.logout()
    print 'All done!'

if __name__ == '__main__':
    demonstrate()

########NEW FILE########
__FILENAME__ = mobileclient
import datetime
from operator import itemgetter
import re

from gmusicapi import session
from gmusicapi.clients.shared import _Base
from gmusicapi.protocol import mobileclient
from gmusicapi.utils import utils


class Mobileclient(_Base):
    """Allows library management and streaming by posing as the
    googleapis.com mobile clients.

    Uploading is not supported by this client (use the :class:`Musicmanager`
    to upload).
    """

    _session_class = session.Mobileclient

    def __init__(self, debug_logging=True, validate=True, verify_ssl=True):
        super(Mobileclient, self).__init__(self.__class__.__name__,
                                           debug_logging,
                                           validate,
                                           verify_ssl)

    def login(self, email, password):
        """Authenticates the Mobileclient.
        Returns ``True`` on success, ``False`` on failure.

        :param email: eg ``'test@gmail.com'`` or just ``'test'``.
        :param password: password or app-specific password for 2-factor users.
          This is not stored locally, and is sent securely over SSL.

        Users of two-factor authentication will need to set an application-specific password
        to log in.
        """

        if not self.session.login(email, password):
            self.logger.info("failed to authenticate")
            return False

        self.logger.info("authenticated")

        return True

    #TODO expose max/page-results, updated_after, etc for list operations

    def get_all_songs(self, incremental=False, include_deleted=False):
        """Returns a list of dictionaries that each represent a song.

        :param incremental: if True, return a generator that yields lists
          of at most 1000 tracks
          as they are retrieved from the server. This can be useful for
          presenting a loading bar to a user.

        :param include_deleted: if True, include tracks that have been deleted
          in the past.

        Here is an example song dictionary::

            {
               'comment':'',
               'rating':'0',
               'albumArtRef':[
                 {
                   'url': 'http://lh6.ggpht.com/...'
                 }
               ],
               'artistId':[
                 'Aod62yyj3u3xsjtooghh2glwsdi'
               ],
               'composer':'',
               'year':2011,
               'creationTimestamp':'1330879409467830',
               'id':'5924d75a-931c-30ed-8790-f7fce8943c85',
               'album':'Heritage ',
               'totalDiscCount':0,
               'title':'Haxprocess',
               'recentTimestamp':'1372040508935000',
               'albumArtist':'',
               'trackNumber':6,
               'discNumber':0,
               'deleted':False,
               'storeId':'Txsffypukmmeg3iwl3w5a5s3vzy',
               'nid':'Txsffypukmmeg3iwl3w5a5s3vzy',
               'totalTrackCount':10,
               'estimatedSize':'17229205',
               'albumId':'Bdkf6ywxmrhflvtasnayxlkgpcm',
               'beatsPerMinute':0,
               'genre':'Progressive Metal',
               'playCount':7,
               'artistArtRef':[
                 {
                   'url': 'http://lh3.ggpht.com/...'
                 }
               ],
               'kind':'sj#track',
               'artist':'Opeth',
               'lastModifiedTimestamp':'1330881158830924',
               'clientId':'+eGFGTbiyMktbPuvB5MfsA',
               'durationMillis':'418000'
             }

        """

        tracks = self._get_all_items(mobileclient.ListTracks, incremental, include_deleted)

        return tracks

    @utils.accept_singleton(dict)
    @utils.empty_arg_shortcircuit
    def change_song_metadata(self, songs):
        """Changes the metadata of tracks.
        Returns a list of the song ids changed.

        :param songs: a list of song dictionaries
          or a single song dictionary.

        Currently, only the ``rating`` key can be changed.
        Set it to ``'0'`` (no thumb), ``'1'`` (down thumb), or ``'5'`` (up thumb)
        unless you're using the 5-star ratings lab.

        You can also use this to rate All Access tracks
        that aren't in your library, eg::

            song = mc.get_track_info('<some store track id>')
            song['rating'] = '5'
            mc.change_song_metadata(song)

        """

        mutate_call = mobileclient.BatchMutateTracks
        mutations = [{'update': s} for s in songs]
        self._make_call(mutate_call, mutations)

        #TODO
        # store tracks don't send back their id, so we're
        # forced to spoof this
        return [utils.id_or_nid(d) for d in songs]

    def increment_song_playcount(self, song_id, plays=1, playtime=None):
        """Increments a song's playcount and returns its song id.

        :params song_id: a song id. Providing the id of an AA track
          that has been added to the library will *not* increment the
          corresponding library song's playcount. To do this, use the
          'id' field (which looks like a uuid and doesn't begin with 'T'),
          not the 'nid' field.
        :params plays: (optional) positive number of plays to increment by.
          The default is 1.
        :params playtime: (optional) a datetime.datetime of the
          time the song was played.
          It will default to the time of the call.
         """

        if playtime is None:
            playtime = datetime.datetime.now()

        self._make_call(mobileclient.IncrementPlayCount, song_id, plays, playtime)

        return song_id

    @utils.enforce_id_param
    def add_aa_track(self, aa_song_id):
        """Adds an All Access track to the library,
        returning the library track id.

        :param aa_song_id: All Access song id
        """
        #TODO is there a way to do this on multiple tracks at once?
        # problem is with gathering aa track info

        aa_track_info = self.get_track_info(aa_song_id)

        mutate_call = mobileclient.BatchMutateTracks
        add_mutation = mutate_call.build_track_add(aa_track_info)
        res = self._make_call(mutate_call, [add_mutation])

        return res['mutate_response'][0]['id']

    @utils.accept_singleton(basestring)
    @utils.enforce_ids_param
    @utils.empty_arg_shortcircuit
    def delete_songs(self, library_song_ids):
        """Deletes songs from the library.
        Returns a list of deleted song ids.

        :param song_ids: a list of song ids, or a single song id.
        """

        mutate_call = mobileclient.BatchMutateTracks
        del_mutations = mutate_call.build_track_deletes(library_song_ids)
        res = self._make_call(mutate_call, del_mutations)

        return [d['id'] for d in res['mutate_response']]

    @utils.enforce_id_param
    def get_stream_url(self, song_id, device_id):
        """Returns a url that will point to an mp3 file.

        :param song_id: a single song id
        :param device_id: a mobile device id as a string.
          Android device ids are 16 characters, while iOS ids
          are uuids with 'ios:' prepended.

          If you have already used Google Music on a mobile device,
          :func:`Webclient.get_registered_devices
          <gmusicapi.clients.Webclient.get_registered_devices>` will provide
          at least one working id. Omit ``'0x'`` from the start of the string if present.

          Registered computer ids (a MAC address) will not be accepted and will 403.

          Providing an unregistered mobile device id will register it to your account,
          subject to Google's `device limits
          <http://support.google.com/googleplay/bin/answer.py?hl=en&answer=1230356>`__.
          **Registering a device id that you do not own is likely a violation of the TOS.**


        When handling the resulting url, keep in mind that:
            * you will likely need to handle redirects
            * the url expires after a minute
            * only one IP can be streaming music at once.
              This can result in an http 403 with
              ``X-Rejected-Reason: ANOTHER_STREAM_BEING_PLAYED``.

        The file will not contain metadata.
        Use :func:`Webclient.get_song_download_info
        <gmusicapi.clients.Webclient.get_song_download_info>`
        or :func:`Musicmanager.download_song
        <gmusicapi.clients.Musicmanager.download_song>`
        to download files with metadata.
        """

        if len(device_id) == 16 and re.match('^[a-z0-9]*$', device_id):
            # android device ids are now sent in base 10
            device_id = str(int(device_id, 16))

        return self._make_call(mobileclient.GetStreamUrl, song_id, device_id)

    def get_all_playlists(self, incremental=False, include_deleted=False):
        """Returns a list of dictionaries that each represent a playlist.

        :param incremental: if True, return a generator that yields lists
          of at most 1000 playlists
          as they are retrieved from the server. This can be useful for
          presenting a loading bar to a user.
        :param include_deleted: if True, include playlists that have been deleted
          in the past.

        Here is an example playlist dictionary::

            {
                 # can also be SHARED (public/subscribed to), MAGIC or omitted
                'type': 'USER_GENERATED',

                'kind': 'sj#playlist',
                'name': 'Something Mix',
                'deleted': False,
                'lastModifiedTimestamp': '1325458766483033',
                'recentTimestamp': '1325458766479000',
                'shareToken': '<long string>',
                'ownerProfilePhotoUrl': 'http://lh3.googleusercontent.com/...',
                'ownerName': 'Simon Weber',
                'accessControlled': False,  # has to do with shared playlists
                'creationTimestamp': '1325285553626172',
                'id': '3d72c9b5-baad-4ff7-815d-cdef717e5d61'
            }
        """

        playlists = self._get_all_items(mobileclient.ListPlaylists, incremental, include_deleted)

        return playlists

    # these could trivially support multiple creation/deletion, but
    # I chose to match the old webclient interface (at least for now).
    def create_playlist(self, name, public=False):
        """Creates a new empty playlist and returns its id.

        :param name: the desired title.
          Creating multiple playlists with the same name is allowed.
        :param public: if True, create a public All Access playlist.
        """

        mutate_call = mobileclient.BatchMutatePlaylists
        add_mutations = mutate_call.build_playlist_adds([{'name': name,
                                                          'public': public}])
        res = self._make_call(mutate_call, add_mutations)

        return res['mutate_response'][0]['id']

    @utils.enforce_id_param
    def change_playlist_name(self, playlist_id, new_name):
        """Changes the name of a playlist and returns its id.

        :param playlist_id: the id of the playlist
        :param new_name: desired title
        """

        mutate_call = mobileclient.BatchMutatePlaylists
        update_mutations = mutate_call.build_playlist_updates([(playlist_id, new_name)])
        res = self._make_call(mutate_call, update_mutations)

        return res['mutate_response'][0]['id']

    @utils.enforce_id_param
    def delete_playlist(self, playlist_id):
        """Deletes a playlist and returns its id.

        :param playlist_id: the id to delete.
        """
        #TODO accept multiple?

        mutate_call = mobileclient.BatchMutatePlaylists
        del_mutations = mutate_call.build_playlist_deletes([playlist_id])
        res = self._make_call(mutate_call, del_mutations)

        return res['mutate_response'][0]['id']

    def get_all_user_playlist_contents(self):
        """
        Retrieves the contents of *all* user-created playlists
        -- the Mobileclient does not support retrieving
        only the contents of one
        playlist.

        This will not return results for public playlists
        that the user is subscribed to; use :func:`get_shared_playlist_contents`
        instead.

        The same structure as :func:`get_all_playlists`
        will be returned, but
        with the addition of a ``'tracks'`` key in each dict
        set to a list of properly-ordered playlist entry dicts.

        Here is an example playlist entry::

          {
              'kind': 'sj#playlistEntry',
              'deleted': False,
              'trackId': '2bb0ab1c-ce1a-3c0f-9217-a06da207b7a7',
              'lastModifiedTimestamp': '1325285553655027',
              'playlistId': '3d72c9b5-baad-4ff7-815d-cdef717e5d61',
              'absolutePosition': '01729382256910287871',  # denotes playlist ordering
              'source': '1',  # ??
              'creationTimestamp': '1325285553655027',
              'id': 'c9f1aff5-f93d-4b98-b13a-429cc7972fea'
          }
        """

        user_playlists = [p for p in self.get_all_playlists()
                          if (p.get('type') == 'USER_GENERATED' or
                              p.get('type') != 'SHARED' or
                              'type' not in p)]

        all_entries = self._get_all_items(mobileclient.ListPlaylistEntries,
                                          incremental=False, include_deleted=False,
                                          updated_after=None)

        for playlist in user_playlists:
            #TODO could use a dict to make this faster
            entries = [e for e in all_entries
                       if e['playlistId'] == playlist['id']]
            entries.sort(key=itemgetter('absolutePosition'))

            playlist['tracks'] = entries

        return user_playlists

    def get_shared_playlist_contents(self, share_token):
        """
        Retrieves the contents of a public All Access playlist.

        :param share_token: from ``playlist['shareToken']``, or a playlist share
          url (``https://play.google.com/music/playlist/<token>``).

          Note that tokens from urls will need to be url-decoded,
          eg ``AM...%3D%3D`` becomes ``AM...==``.

        For example, to retrieve the contents of a playlist that the user is
        subscribed to::

            subscribed_to = [p for p in mc.get_all_playlists() if p.get('type') == 'SHARED']
            share_tok = subscribed_to[0]['shareToken']
            tracks = mc.get_shared_playlist_contents(share_tok)

        The user need not be subscribed to a playlist to list its tracks.

        Returns a list of playlist entries
        with structure the same as those
        returned by :func:`get_all_user_playlist_contents`,
        but without the ``'clientId'`` or ``'playlistId'`` keys.
        """

        res = self._make_call(mobileclient.ListSharedPlaylistEntries,
                              updated_after=None, share_token=share_token)

        entries = res['entries'][0]['playlistEntry']
        entries.sort(key=itemgetter('absolutePosition'))

        return entries

    @utils.accept_singleton(basestring, 2)
    @utils.enforce_id_param
    @utils.enforce_ids_param(position=2)
    @utils.empty_arg_shortcircuit(position=2)
    def add_songs_to_playlist(self, playlist_id, song_ids):
        """Appends songs to the end of a playlist.
        Returns a list of playlist entry ids that were added.

        :param playlist_id: the id of the playlist to add to.
        :param song_ids: a list of song ids, or a single song id.

        Playlists have a maximum size of 1000 songs.
        Calls may fail before that point (presumably) due to
        an error on Google's end (see `#239
        <https://github.com/simon-weber/Unofficial-Google-Music-API/issues/239>`__).
        """
        mutate_call = mobileclient.BatchMutatePlaylistEntries
        add_mutations = mutate_call.build_plentry_adds(playlist_id, song_ids)
        res = self._make_call(mutate_call, add_mutations)

        return [e['id'] for e in res['mutate_response']]

    @utils.accept_singleton(basestring, 1)
    @utils.enforce_ids_param(position=1)
    @utils.empty_arg_shortcircuit(position=1)
    def remove_entries_from_playlist(self, entry_ids):
        """Removes specific entries from a playlist.
        Returns a list of entry ids that were removed.

        :param entry_ids: a list of entry ids, or a single entry id.
        """
        mutate_call = mobileclient.BatchMutatePlaylistEntries
        del_mutations = mutate_call.build_plentry_deletes(entry_ids)
        res = self._make_call(mutate_call, del_mutations)

        return [e['id'] for e in res['mutate_response']]

    def reorder_playlist_entry(self, entry, to_follow_entry=None, to_precede_entry=None):
        """Reorders a single entry in a playlist and returns its id.

        Read ``reorder_playlist_entry(foo, bar, gaz)`` as
        "reorder playlist entry *foo* to follow entry *bar*
        and precede entry *gaz*."

        :param entry: the playlist entry to move.
        :param to_follow_entry: the playlist entry
          that will come before *entry* in the resulting playlist,
          or None if *entry* is to be the first entry in the playlist.
        :param to_precede_entry: the playlist entry
          that will come after *entry* in the resulting playlist
          or None if *entry* is to be the last entry in the playlist.

        ``reorder_playlist_entry(foo)`` is invalid and will raise ValueError;
        provide at least one of *to_follow_entry* or *to_precede_entry*.

        Leaving *to_follow_entry* or *to_precede_entry* as None when
        *entry* is not to be the first or last entry in the playlist
        is undefined.

        All params are dicts returned by
        :func:`get_all_user_playlist_contents` or
        :func:`get_shared_playlist_contents`.

        """

        if to_follow_entry is None and to_precede_entry is None:
            raise ValueError('either to_follow_entry or to_precede_entry must be provided')

        mutate_call = mobileclient.BatchMutatePlaylistEntries
        before = to_follow_entry['clientId'] if to_follow_entry else None
        after = to_precede_entry['clientId'] if to_precede_entry else None

        reorder_mutation = mutate_call.build_plentry_reorder(entry, before, after)
        res = self._make_call(mutate_call, [reorder_mutation])

        return [e['id'] for e in res['mutate_response']]

    # WIP, see issue #179
    #def reorder_playlist(self, reordered_playlist, orig_playlist=None):
    #    """TODO"""

    #    if not reordered_playlist['tracks']:
    #        #TODO what to return?
    #        return

    #    if orig_playlist is None:
    #        #TODO get pl from server
    #        pass

    #    if len(reordered_playlist['tracks']) != len(orig_playlist['tracks']):
    #        raise ValueError('the original playlist does not have the same number of'
    #                         ' tracks as the reordered playlist')

    #    # find the minimum number of mutations to match the orig playlist

    #    orig_tracks = orig_playlist['tracks']
    #    orig_tracks_id_to_idx = dict([(t['id'], i) for (i, t) in enumerate(orig_tracks)])

    #    re_tracks = reordered_playlist['tracks']
    #    re_tracks_id_to_idx = dict([(t['id'], i) for (i, t) in enumerate(re_tracks)])

    #    translated_re_tracks = [orig_tracks_id_to_idx[t['id']] for t in re_tracks]

    #    lis = utils.longest_increasing_subseq(translated_re_tracks)

    #    idx_to_move = set(range(len(orig_tracks))) - set(lis)

    #    idx_pos_pairs = [(i, re_tracks_id_to_idx[orig_tracks[i]['id']])
    #                     for i in idx_to_move]

    #    #TODO build out mutations

    #    return idx_pos_pairs

    #@staticmethod
    #def _create_ple_reorder_mutations(tracks, from_to_idx_pairs):
    #    """
    #    Return a list of mutations.

    #    :param tracks: orig_playlist['tracks']
    #    :param from_to_idx_pairs: [(from_index, to_index)]
    #    """
    #    for from_idx, to_idx in sorted(key=itemgetter(1)
    #    playlist_len = len(self.plentry_ids)
    #    for from_pos, to_pos in [pair for pair in
    #                             itertools.product(range(playlist_len), repeat=2)
    #                             if pair[0] < pair[1]]:
    #        pl = self.mc_get_playlist_songs(self.playlist_id)

    #        from_e = pl[from_pos]

    #        e_before_new_pos, e_after_new_pos = None, None

    #        if to_pos - 1 >= 0:
    #            e_before_new_pos = pl[to_pos]

    #        if to_pos + 1 < playlist_len:
    #            e_after_new_pos = pl[to_pos + 1]

    #        self.mc.reorder_playlist_entry(from_e,
    #                                       to_follow_entry=e_before_new_pos,
    #                                       to_precede_entry=e_after_new_pos)
    #        self._mc_assert_ple_position(from_e, to_pos)

    #        if e_before_new_pos:
    #            self._mc_assert_ple_position(e_before_new_pos, to_pos - 1)

    #        if e_after_new_pos:
    #            self._mc_assert_ple_position(e_after_new_pos, to_pos + 1)

    def create_station(self, name,
                       track_id=None, artist_id=None, album_id=None,
                       genre_id=None):
        """Creates an All Access radio station and returns its id.

        :param name: the name of the station to create
        :param \*_id: the id of an item to seed the station from.
          Exactly one of these params must be provided, or ValueError
          will be raised.
        """
        #TODO could expose include_tracks

        seed = {}
        if track_id is not None:
            if track_id[0] == 'T':
                seed['trackId'] = track_id
            else:
                seed['trackLockerId'] = track_id

        if artist_id is not None:
            seed['artistId'] = artist_id
        if album_id is not None:
            seed['albumId'] = album_id
        if genre_id is not None:
            seed['genreId'] = genre_id

        if len(seed) != 1:
            raise ValueError('exactly one {track,artist,album,genre}_id must be provided')

        mutate_call = mobileclient.BatchMutateStations
        add_mutation = mutate_call.build_add(name, seed, include_tracks=False, num_tracks=0)
        res = self._make_call(mutate_call, [add_mutation])

        return res['mutate_response'][0]['id']

    @utils.accept_singleton(basestring)
    @utils.enforce_ids_param
    @utils.empty_arg_shortcircuit
    def delete_stations(self, station_ids):
        """Deletes All Access radio stations and returns their ids.

        :param station_ids: a single id, or a list of ids to delete
        """

        mutate_call = mobileclient.BatchMutateStations
        delete_mutations = mutate_call.build_deletes(station_ids)
        res = self._make_call(mutate_call, delete_mutations)

        return [s['id'] for s in res['mutate_response']]

    def get_all_stations(self, incremental=False, include_deleted=False, updated_after=None):
        """Returns a list of dictionaries that each represent a radio station.

        :param incremental: if True, return a generator that yields lists
          of at most 1000 stations
          as they are retrieved from the server. This can be useful for
          presenting a loading bar to a user.
        :param include_deleted: if True, include stations that have been deleted
          in the past.
        :param updated_after: a datetime.datetime; defaults to unix epoch

        Here is an example station dictionary::

            {
                'imageUrl': 'http://lh6.ggpht.com/...',
                'kind': 'sj#radioStation',
                'name': 'station',
                'deleted': False,
                'lastModifiedTimestamp': '1370796487455005',
                'recentTimestamp': '1370796487454000',
                'clientId': 'c2639bf4-af24-4e4f-ab37-855fc89d15a1',
                'seed':
                {
                    'kind': 'sj#radioSeed',
                    'trackLockerId': '7df3aadd-9a18-3dc1-b92e-a7cf7619da7e'
                    # possible keys:
                    #  albumId, artistId, genreId, trackId, trackLockerId
                },
                'id': '69f1bfce-308a-313e-9ed2-e50abe33a25d'
            },
        """
        return self._get_all_items(mobileclient.ListStations, incremental, include_deleted,
                                   updated_after=updated_after)

    @utils.enforce_id_param
    def get_station_tracks(self, station_id, num_tracks=25):
        """Returns a list of dictionaries that each represent a track.

        Each call performs a separate sampling (with replacement?)
        from all possible tracks for the station.

        :param station_id: the id of a radio station to retrieve tracks from
        :param num_tracks: the number of tracks to retrieve

        See :func:`get_all_songs` for the format of a track dictionary.
        """

        #TODO recently played?

        res = self._make_call(mobileclient.ListStationTracks,
                              station_id, num_tracks, recently_played=[])

        stations = res.get('data', {}).get('stations')
        if not stations:
            return []

        return stations[0].get('tracks', [])

    def search_all_access(self, query, max_results=50):
        """Queries the server for All Access songs and albums.

        Using this method without an All Access subscription will always result in
        CallFailure being raised.

        :param query: a string keyword to search with. Capitalization and punctuation are ignored.
        :param max_results: Maximum number of items to be retrieved

        The results are returned in a dictionary, arranged by how they were found.
        Here are example results for a search on ``'Amorphis'``::

            {
               'album_hits':[
                  {
                     'album':{
                        'albumArtRef':'http://lh6.ggpht.com/...',
                        'albumId':'Bfr2onjv7g7tm4rzosewnnwxxyy',
                        'artist':'Amorphis',
                        'artistId':[
                           'Apoecs6off3y6k4h5nvqqos4b5e'
                        ],
                        'kind':'sj#album',
                        'name':'Circle',
                        'year':2013
                     },
                     'best_result':True,
                     'score':385.55609130859375,
                     'type':'3'
                  },
                  {
                     'album':{
                        'albumArtRef':'http://lh3.ggpht.com/...',
                        'albumArtist':'Amorphis',
                        'albumId':'Bqzxfykbqcqmjjtdom7ukegaf2u',
                        'artist':'Amorphis',
                        'artistId':[
                           'Apoecs6off3y6k4h5nvqqos4b5e'
                        ],
                        'kind':'sj#album',
                        'name':'Elegy',
                        'year':1996
                     },
                     'score':236.33485412597656,
                     'type':'3'
                  },
               ],
               'artist_hits':[
                  {
                     'artist':{
                        'artistArtRef':'http://lh6.ggpht.com/...',
                        'artistId':'Apoecs6off3y6k4h5nvqqos4b5e',
                        'kind':'sj#artist',
                        'name':'Amorphis'
                     },
                     'score':237.86375427246094,
                     'type':'2'
                  }
               ],
               'song_hits':[
                  {
                     'score':105.23198699951172,
                     'track':{
                        'album':'Skyforger',
                        'albumArtRef':[
                           {
                              'url':'http://lh4.ggpht.com/...'
                           }
                        ],
                        'albumArtist':'Amorphis',
                        'albumAvailableForPurchase':True,
                        'albumId':'B5nc22xlcmdwi3zn5htkohstg44',
                        'artist':'Amorphis',
                        'artistId':[
                           'Apoecs6off3y6k4h5nvqqos4b5e'
                        ],
                        'discNumber':1,
                        'durationMillis':'253000',
                        'estimatedSize':'10137633',
                        'kind':'sj#track',
                        'nid':'Tn2ugrgkeinrrb2a4ji7khungoy',
                        'playCount':1,
                        'storeId':'Tn2ugrgkeinrrb2a4ji7khungoy',
                        'title':'Silver Bride',
                        'trackAvailableForPurchase':True,
                        'trackNumber':2,
                        'trackType':'7'
                     },
                     'type':'1'
                  },
                  {
                     'score':96.23717498779297,
                     'track':{
                        'album':'Magic And Mayhem - Tales From The Early Years',
                        'albumArtRef':[
                           {
                              'url':'http://lh4.ggpht.com/...'
                           }
                        ],
                        'albumArtist':'Amorphis',
                        'albumAvailableForPurchase':True,
                        'albumId':'B7dplgr5h2jzzkcyrwhifgwl2v4',
                        'artist':'Amorphis',
                        'artistId':[
                           'Apoecs6off3y6k4h5nvqqos4b5e'
                        ],
                        'discNumber':1,
                        'durationMillis':'235000',
                        'estimatedSize':'9405159',
                        'kind':'sj#track',
                        'nid':'T4j5jxodzredqklxxhncsua5oba',
                        'storeId':'T4j5jxodzredqklxxhncsua5oba',
                        'title':'Black Winter Day',
                        'trackAvailableForPurchase':True,
                        'trackNumber':4,
                        'trackType':'7',
                        'year':2010
                     },
                     'type':'1'
                  },
               ]
            }
        """
        res = self._make_call(mobileclient.Search, query, max_results)

        hits = res.get('entries', [])

        return {'album_hits': [hit for hit in hits if hit['type'] == '3'],
                'artist_hits': [hit for hit in hits if hit['type'] == '2'],
                'song_hits': [hit for hit in hits if hit['type'] == '1']}

    @utils.enforce_id_param
    def get_artist_info(self, artist_id, include_albums=True, max_top_tracks=5, max_rel_artist=5):
        """Retrieves details on an artist.

        :param artist_id: an All Access artist id (hint: they always start with 'A')
        :param include_albums: when True, create the ``'albums'`` substructure
        :param max_top_tracks: maximum number of top tracks to retrieve
        :param max_rel_artist: maximum number of related artists to retrieve

        Using this method without an All Access subscription will always result in
        CallFailure being raised.

        Returns a dict, eg::

            {
              'albums':[  # only if include_albums is True
                {
                  'albumArtRef':'http://lh6.ggpht.com/...',
                  'albumArtist':'Amorphis',
                  'albumId':'Bfr2onjv7g7tm4rzosewnnwxxyy',
                  'artist':'Amorphis',
                  'artistId':[
                    'Apoecs6off3y6k4h5nvqqos4b5e'
                  ],
                  'kind':'sj#album',
                  'name':'Circle',
                  'year':2013
                },
              ],
              'artistArtRef':  'http://lh6.ggpht.com/...',
              'artistId':'Apoecs6off3y6k4h5nvqqos4b5e',
              'kind':'sj#artist',
              'name':'Amorphis',
              'related_artists':[  # only if max_rel_artists > 0
                {
                  'artistArtRef':      'http://lh5.ggpht.com/...',
                  'artistId':'Aheqc7kveljtq7rptd7cy5gvk2q',
                  'kind':'sj#artist',
                  'name':'Dark Tranquillity'
                }
              ],
              'topTracks':[  # only if max_top_tracks > 0
                {
                  'album':'Skyforger',
                  'albumArtRef':[
                    {
                      'url':          'http://lh4.ggpht.com/...'
                    }
                  ],
                  'albumArtist':'Amorphis',
                  'albumAvailableForPurchase':True,
                  'albumId':'B5nc22xlcmdwi3zn5htkohstg44',
                  'artist':'Amorphis',
                  'artistId':[
                    'Apoecs6off3y6k4h5nvqqos4b5e'
                  ],
                  'discNumber':1,
                  'durationMillis':'253000',
                  'estimatedSize':'10137633',
                  'kind':'sj#track',
                  'nid':'Tn2ugrgkeinrrb2a4ji7khungoy',
                  'playCount':1,
                  'storeId':'Tn2ugrgkeinrrb2a4ji7khungoy',
                  'title':'Silver Bride',
                  'trackAvailableForPurchase':True,
                  'trackNumber':2,
                  'trackType':'7'
                }
              ],
              'total_albums':21
            }
        """

        res = self._make_call(mobileclient.GetArtist,
                              artist_id, include_albums, max_top_tracks, max_rel_artist)
        return res

    def _get_all_items(self, call, incremental, include_deleted, **kwargs):
        """
        :param call: protocol.McCall
        :param incremental: bool
        :param include_deleted: bool

        kwargs are passed to the call.
        """
        if not incremental:
            # slight optimization: get more items in a page
            kwargs.setdefault('max_results', 20000)

        generator = self._get_all_items_incremental(call, include_deleted, **kwargs)
        if incremental:
            return generator

        return [s for chunk in generator for s in chunk]

    def _get_all_items_incremental(self, call, include_deleted, **kwargs):
        """Return a generator of lists of tracks.

        kwargs are passed to the call."""

        get_next_chunk = True
        lib_chunk = {'nextPageToken': None}

        while get_next_chunk:
            lib_chunk = self._make_call(call,
                                        start_token=lib_chunk['nextPageToken'],
                                        **kwargs)

            items = lib_chunk['data']['items']

            if not include_deleted:
                items = [item for item in items if not item['deleted']]

            yield items

            get_next_chunk = 'nextPageToken' in lib_chunk

    @utils.enforce_id_param
    def get_album_info(self, album_id, include_tracks=True):
        """Retrieves details on an album.

        :param album_id: an All Access album id (hint: they always start with 'B')
        :param include_tracks: when True, create the ``'tracks'`` substructure

        Using this method without an All Access subscription will always result in
        CallFailure being raised.

        Returns a dict, eg::

            {
                'kind': 'sj#album',
                'name': 'Circle',
                'artist': 'Amorphis',
                'albumArtRef': 'http://lh6.ggpht.com/...',
                'tracks': [  # if `include_tracks` is True
                {
                    'album': 'Circle',
                    'kind': 'sj#track',
                    'storeId': 'T5zb7luo2vkroozmj57g2nljdsy',  # can be used as a song id
                    'artist': 'Amorphis',
                    'albumArtRef': [
                    {
                        'url': 'http://lh6.ggpht.com/...'
                    }],
                    'title': 'Shades of Grey',
                    'nid': 'T5zb7luo2vkroozmj57g2nljdsy',
                    'estimatedSize': '13115591',
                    'albumId': 'Bfr2onjv7g7tm4rzosewnnwxxyy',
                    'artistId': ['Apoecs6off3y6k4h5nvqqos4b5e'],
                    'albumArtist': 'Amorphis',
                    'durationMillis': '327000',
                    'composer': '',
                    'genre': 'Metal',
                    'trackNumber': 1,
                    'discNumber': 1,
                    'trackAvailableForPurchase': True,
                    'trackType': '7',
                    'albumAvailableForPurchase': True
                }, # ...
                ],
                'albumId': 'Bfr2onjv7g7tm4rzosewnnwxxyy',
                'artistId': ['Apoecs6off3y6k4h5nvqqos4b5e'],
                'albumArtist': 'Amorphis',
                'year': 2013
            }

        """

        return self._make_call(mobileclient.GetAlbum, album_id, include_tracks)

    @utils.enforce_id_param
    def get_track_info(self, store_track_id):
        """Retrieves information about a store track.

        :param store_track_id: an All Access track id (hint: they always start with 'T')

        Using this method without an All Access subscription will always result in
        CallFailure being raised.

        Returns a dict, eg::

            {
                'album': 'Best Of',
                'kind': 'sj#track',
                'storeId': 'Te2qokfjmhqxw4bnkswbfphzs4m',
                'artist': 'Amorphis',
                'albumArtRef': [
                {
                    'url': 'http://lh5.ggpht.com/...'
                }],
                'title': 'Hopeless Days',
                'nid': 'Te2qokfjmhqxw4bnkswbfphzs4m',
                'estimatedSize': '12325643',
                'albumId': 'Bsbjjc24a5xutbutvbvg3h4y2k4',
                'artistId': ['Apoecs6off3y6k4h5nvqqos4b5e'],
                'albumArtist': 'Amorphis',
                'durationMillis': '308000',
                'composer': '',
                'genre': 'Metal',
                'trackNumber': 2,
                'discNumber': 1,
                'trackAvailableForPurchase': True,
                'trackType': '7',
                'albumAvailableForPurchase': True
            }

        """

        return self._make_call(mobileclient.GetStoreTrack, store_track_id)

    def get_genres(self):
        """Retrieves information on Google Music genres.

        Using this method without an All Access subscription will always result in
        CallFailure being raised.

        Returns a list of dicts of the form, eg::

            {
                'name': 'Alternative/Indie',
                'id': 'ALTERNATIVE_INDIE'
                'kind': 'sj#musicGenre',
                'children': [             # this key may not be present
                    'ALTERNATIVE_80S',    # these are ids
                    'ALT_COUNTRY',
                    # ...
                    ],
                'images': [
                    {
                        # these are album covers representative of the genre
                        'url': 'http://lh6.ggpht.com/...'
                    },
                    # ...
                ],
            }

        Note that the id can be used with :func:`create_station`
        to seed an All Access radio station.
        """

        return self._make_call(mobileclient.GetGenres)

########NEW FILE########
__FILENAME__ = musicmanager
import os
from socket import gethostname
import time
import urllib
from uuid import getnode as getmac
import webbrowser

import httplib2  # included with oauth2client
from oauth2client.client import OAuth2WebServerFlow, TokenRevokeError
import oauth2client.file

import gmusicapi
from gmusicapi.clients.shared import _Base
from gmusicapi.compat import my_appdirs
from gmusicapi.exceptions import CallFailure, NotLoggedIn
from gmusicapi.protocol import musicmanager, upload_pb2, locker_pb2
from gmusicapi.utils import utils
from gmusicapi import session

OAUTH_FILEPATH = os.path.join(my_appdirs.user_data_dir, 'oauth.cred')


class Musicmanager(_Base):
    """Allows uploading by posing as Google's Music Manager.

    Musicmanager uses OAuth, so a plaintext email and password are not required
    when logging in.

    For most authors and users of gmusicapi scripts,
    :func:`perform_oauth` should be run once per machine to
    store credentials to disk.
    Future calls to :func:`login` can use
    use the stored credentials by default.

    Some authors may want more control over the OAuth flow.
    In this case, credentials can be directly provided to :func:`login`.
    """

    _session_class = session.Musicmanager

    @staticmethod
    def perform_oauth(storage_filepath=OAUTH_FILEPATH, open_browser=False):
        """Provides a series of prompts for a user to follow to authenticate.
        Returns ``oauth2client.client.OAuth2Credentials`` when successful.

        In most cases, this should only be run once per machine to store
        credentials to disk, then never be needed again.

        If the user refuses to give access,
        ``oauth2client.client.FlowExchangeError`` is raised.

        :param storage_filepath: a filepath to write the credentials to,
          or ``None``
          to not write the credentials to disk (which is not recommended).

          `Appdirs <https://pypi.python.org/pypi/appdirs/1.2.0>`__
          ``user_data_dir`` is used by default. Users can run::

              import gmusicapi.clients
              print gmusicapi.clients.OAUTH_FILEPATH

          to see the exact location on their system.

        :param open_browser: if True, attempt to open the auth url
          in the system default web browser. The url will be printed
          regardless of this param's setting.

        This flow is intentionally very simple.
        For complete control over the OAuth flow, pass an
        ``oauth2client.client.OAuth2Credentials``
        to :func:`login` instead.
        """

        flow = OAuth2WebServerFlow(*musicmanager.oauth)

        auth_uri = flow.step1_get_authorize_url()
        print
        print "Visit the following url:\n %s" % auth_uri

        if open_browser:
            print
            print 'Opening your browser to it now...',
            webbrowser.open(auth_uri)
            print 'done.'
            print "If you don't see your browser, you can just copy and paste the url."
            print

        code = raw_input("Follow the prompts,"
                         " then paste the auth code here and hit enter: ")

        credentials = flow.step2_exchange(code)

        if storage_filepath is not None:
            if storage_filepath == OAUTH_FILEPATH:
                utils.make_sure_path_exists(os.path.dirname(OAUTH_FILEPATH), 0o700)
            storage = oauth2client.file.Storage(storage_filepath)
            storage.put(credentials)

        return credentials

    def __init__(self, debug_logging=True, validate=True, verify_ssl=True):
        super(Musicmanager, self).__init__(self.__class__.__name__,
                                           debug_logging,
                                           validate,
                                           verify_ssl)

    def login(self, oauth_credentials=OAUTH_FILEPATH,
              uploader_id=None, uploader_name=None):
        """Authenticates the Music Manager using OAuth.
        Returns ``True`` on success, ``False`` on failure.

        Unlike the :class:`Webclient`, OAuth allows authentication without
        providing plaintext credentials to the application.

        In most cases, the default parameters should be acceptable. Users on
        virtual machines will want to provide `uploader_id`.

        :param oauth_credentials: ``oauth2client.client.OAuth2Credentials`` or the path to a
          ``oauth2client.file.Storage`` file. By default, the same default path used by
          :func:`perform_oauth` is used.

          Endusers will likely call :func:`perform_oauth` once to write
          credentials to disk and then ignore this parameter.

          This param
          is mostly intended to allow flexibility for developers of a
          3rd party service who intend to perform their own OAuth flow
          (eg on their website).

        :param uploader_id: a unique id as a MAC address, eg ``'00:11:22:33:AA:BB'``.
          This should only be provided in cases where the default
          (host MAC address incremented by 1) will not work.

          Upload behavior is undefined if a Music Manager uses the same id, especially when
          reporting bad matches.

          ``ValueError`` will be raised if this is provided but not in the proper form.

          ``OSError`` will be raised if this is not provided and a real MAC could not be
          determined (most common when running on a VPS).

          If provided, use the same id on all future runs for this machine,
          because of the upload device limit explained below.

        :param uploader_name: human-readable non-unique id; default is
          ``"<hostname> (gmusicapi-{version})"``.

          This doesn't appear to be a part of authentication at all.
          Registering with (id, name = X, Y) and logging in with
          (id, name = X, Z) works, and does not change the server-stored
          uploader_name.

        There are hard limits on how many upload devices can be registered; refer to `Google's
        docs <http://support.google.com/googleplay/bin/answer.py?hl=en&answer=1230356>`__. There
        have been limits on deauthorizing devices in the past, so it's smart not to register
        more devices than necessary.
        """

        return (self._oauth_login(oauth_credentials) and
                self._perform_upauth(uploader_id, uploader_name))

    def _oauth_login(self, oauth_credentials):
        """Auth ourselves to the MM oauth endpoint.

        Return True on success; see :py:func:`login` for params.
        """

        if isinstance(oauth_credentials, basestring):
            oauth_file = oauth_credentials
            if oauth_file == OAUTH_FILEPATH:
                utils.make_sure_path_exists(os.path.dirname(OAUTH_FILEPATH), 0o700)
            storage = oauth2client.file.Storage(oauth_file)

            oauth_credentials = storage.get()
            if oauth_credentials is None:
                self.logger.warning("could not retrieve oauth credentials from '%s'", oauth_file)
                return False

        if not self.session.login(oauth_credentials):
            self.logger.warning("failed to authenticate")
            return False

        self.logger.info("oauth successful")

        return True

    def _perform_upauth(self, uploader_id, uploader_name):
        """Auth or register ourselves as an upload client.

        Return True on success; see :py:func:`login` for params.
        """

        if uploader_id is None:
            mac_int = getmac()
            if (mac_int >> 40) % 2:
                raise OSError('a valid MAC could not be determined.'
                              ' Provide uploader_id (and be'
                              ' sure to provide the same one on future runs).')

            else:
                #distinguish us from a Music Manager on this machine
                mac_int = (mac_int + 1) % (1 << 48)

            uploader_id = utils.create_mac_string(mac_int)

        if not utils.is_valid_mac(uploader_id):
            raise ValueError('uploader_id is not in a valid form.'
                             '\nProvide 6 pairs of hex digits'
                             ' with capital letters',
                             ' (eg "00:11:22:33:AA:BB")')

        if uploader_name is None:
            uploader_name = gethostname() + u" (gmusicapi-%s)" % gmusicapi.__version__

        try:
            # this is a MM-specific step that might register a new device.
            self._make_call(musicmanager.AuthenticateUploader,
                            uploader_id,
                            uploader_name)
            self.logger.info("successful upauth")
            self.uploader_id = uploader_id
            self.uploader_name = uploader_name

        except CallFailure:
            self.logger.exception("upauth failure")
            self.session.logout()
            return False

        return True

    def logout(self, revoke_oauth=False):
        """Forgets local authentication in this Client instance.

        :param revoke_oauth: if True, oauth credentials will be permanently
          revoked. If credentials came from a file, it will be deleted.

        Returns ``True`` on success."""

        # TODO the login/logout stuff is all over the place

        success = True

        if revoke_oauth:
            try:
                # this automatically deletes a Storage file, if present
                self.session._oauth_creds.revoke(httplib2.Http())
            except TokenRevokeError:
                self.logger.exception("could not revoke oauth credentials")
                success = False

        self.uploader_id = None
        self.uploader_name = None

        return success and super(Musicmanager, self).logout()

    # mostly copy-paste from Webclient.get_all_songs.
    # not worried about overlap in this case; the logic of either could change.
    def get_uploaded_songs(self, incremental=False):
        """Returns a list of dictionaries, each with the following keys:
        ``('id', 'title', 'album', 'album_artist', 'artist', 'track_number',
        'track_size')``.

        All Access tracks that were added to the library will not be included,
        only tracks uploaded/matched by the user.

        :param incremental: if True, return a generator that yields lists
          of at most 1000 dictionaries
          as they are retrieved from the server. This can be useful for
          presenting a loading bar to a user.
        """

        to_return = self._get_all_songs()

        if not incremental:
            to_return = [song for chunk in to_return for song in chunk]

        return to_return

    @staticmethod
    def _track_info_to_dict(track_info):
        """Given a download_pb2.DownloadTrackInfo, return a dictionary."""
        # figure it's better to hardcode keys here than use introspection
        # and risk returning a new field all of a sudden.

        return dict((field, getattr(track_info, field)) for field in
                    ('id', 'title', 'album', 'album_artist', 'artist',
                     'track_number', 'track_size'))

    def _get_all_songs(self):
        """Return a generator of song chunks."""

        get_next_chunk = True

        # need to spoof .continuation_token access, and
        # can't add attrs to object(). Can with functions.

        lib_chunk = lambda: 0
        lib_chunk.continuation_token = None

        while get_next_chunk:
            lib_chunk = self._make_call(musicmanager.ListTracks,
                                        self.uploader_id,
                                        lib_chunk.continuation_token)

            yield [self._track_info_to_dict(info)
                   for info in lib_chunk.download_track_info]

            get_next_chunk = lib_chunk.HasField('continuation_token')

    @utils.enforce_id_param
    def download_song(self, song_id):
        """Returns a tuple ``(u'suggested_filename', 'audio_bytestring')``.
        The filename
        will be what the Music Manager would save the file as,
        presented as a unicode string with the proper file extension.
        You don't have to use it if you don't want.


        :param song_id: a single song id.

        To write the song to disk, use something like::

            filename, audio = mm.download_song(an_id)

            # if open() throws a UnicodeEncodeError, either use
            #   filename.encode('utf-8')
            # or change your default encoding to something sane =)
            with open(filename, 'wb') as f:
                f.write(audio)

        Unlike with :py:func:`Webclient.get_song_download_info
        <gmusicapi.clients.Webclient.get_song_download_info>`,
        there is no download limit when using this interface.

        Also unlike the Webclient, downloading a track requires authentication.
        Returning a url does not suffice, since retrieving a track without auth
        will produce an http 500.
        """

        url = self._make_call(musicmanager.GetDownloadLink,
                              song_id,
                              self.uploader_id)['url']

        response = self._make_call(musicmanager.DownloadTrack, url)

        cd_header = response.headers['content-disposition']

        filename = urllib.unquote(cd_header.split("filename*=UTF-8''")[-1])
        filename = filename.decode('utf-8')

        return (filename, response.content)

    # def get_quota(self):
    #     """Returns a tuple of (allowed number of tracks, total tracks, available tracks)."""
    #     quota = self._mm_pb_call("client_state").quota
    #     #protocol incorrect here...
    #     return (quota.maximumTracks, quota.totalTracks, quota.availableTracks)

    @utils.accept_singleton(basestring)
    @utils.empty_arg_shortcircuit(return_code='{}')
    def upload(self, filepaths, transcode_quality='320k', enable_matching=False):
        """Uploads the given filepaths.

        All non-mp3 files will be transcoded before being uploaded.
        This is a limitation of Google's backend.

        An available installation of avconv is required in most cases:
        see `the installation page
        <https://unofficial-google-music-api.readthedocs.org/en
        /latest/usage.html?#installation>`__ for details.

        Returns a 3-tuple ``(uploaded, matched, not_uploaded)`` of dictionaries, eg::

            (
                {'<filepath>': '<new server id>'},               # uploaded
                {'<filepath>': '<new server id>'},               # matched
                {'<filepath>': '<reason, eg ALREADY_EXISTS>'}    # not uploaded
            )

        :param filepaths: a list of filepaths, or a single filepath.
        :param transcode_quality: if int, pass to ffmpeg/avconv ``-q:a`` for libmp3lame
          (`lower-better int,
          <http://trac.ffmpeg.org/wiki/Encoding%20VBR%20(Variable%20Bit%20Rate)%20mp3%20audio>`__).
          If string, pass to avconv ``-b:a`` (eg ``'128k'`` for an average bitrate of 128k). The
          default is 320kbps cbr (the highest possible quality).

        :param enable_matching: if ``True``, attempt to use `scan and match
          <http://support.google.com/googleplay/bin/answer.py?hl=en&answer=2920799&topic=2450455>`__
          to avoid uploading every song.
          This requires avconv.
          **WARNING**: currently, mismatched songs can *not* be fixed with the 'Fix Incorrect Match'
          button nor :py:func:`report_incorrect_match
          <gmusicapi.clients.Webclient.report_incorrect_match>`.
          They would have to be deleted and reuploaded with matching disabled
          (or with the Music Manager).
          Fixing matches from gmusicapi may be supported in a future release; see issue `#89
          <https://github.com/simon-weber/Unofficial-Google-Music-API/issues/89>`__.

        All Google-supported filetypes are supported; see `Google's documentation
        <http://support.google.com/googleplay/bin/answer.py?hl=en&answer=1100462>`__.

        Unlike Google's Music Manager, this function will currently allow the same song to
        be uploaded more than once if its tags are changed. This is subject to change in the future.

        If ``PERMANENT_ERROR`` is given as a not_uploaded reason, attempts to reupload will never
        succeed. The file will need to be changed before the server will reconsider it; the easiest
        way is to change metadata tags (it's not important that the tag be uploaded, just that the
        contents of the file change somehow).
        """

        if self.uploader_id is None or self.uploader_name is None:
            raise NotLoggedIn("Not authenticated as an upload device;"
                              " run Api.login(...perform_upload_auth=True...)"
                              " first.")

        #TODO there is way too much code in this function.

        #To return.
        uploaded = {}
        matched = {}
        not_uploaded = {}

        #Gather local information on the files.
        local_info = {}  # {clientid: (path, Track)}
        for path in filepaths:
            try:
                track = musicmanager.UploadMetadata.fill_track_info(path)
            except BaseException as e:
                self.logger.exception("problem gathering local info of '%r'", path)

                user_err_msg = str(e)

                if 'Non-ASCII strings must be converted to unicode' in str(e):
                    #This is a protobuf-specific error; they require either ascii or unicode.
                    #To keep behavior consistent, make no effort to guess - require users
                    # to decode first.
                    user_err_msg = ("nonascii bytestrings must be decoded to unicode"
                                    " (error: '%s')" % user_err_msg)

                not_uploaded[path] = user_err_msg
            else:
                local_info[track.client_id] = (path, track)

        if not local_info:
            return uploaded, matched, not_uploaded

        #TODO allow metadata faking

        #Upload metadata; the server tells us what to do next.
        res = self._make_call(musicmanager.UploadMetadata,
                              [track for (path, track) in local_info.values()],
                              self.uploader_id)

        #TODO checking for proper contents should be handled in verification
        md_res = res.metadata_response

        responses = [r for r in md_res.track_sample_response]
        sample_requests = [req for req in md_res.signed_challenge_info]

        #Send scan and match samples if requested.
        for sample_request in sample_requests:
            path, track = local_info[sample_request.challenge_info.client_track_id]

            bogus_sample = None
            if not enable_matching:
                bogus_sample = ''  # just send empty bytes

            try:
                res = self._make_call(musicmanager.ProvideSample,
                                      path, sample_request, track,
                                      self.uploader_id, bogus_sample)

            except (IOError, ValueError) as e:
                self.logger.warning("couldn't create scan and match sample for '%s': %s",
                                    path, str(e))
                not_uploaded[path] = str(e)
            else:
                responses.extend(res.sample_response.track_sample_response)

        #Read sample responses and prep upload requests.
        to_upload = {}  # {serverid: (path, Track, do_not_rematch?)}
        for sample_res in responses:
            path, track = local_info[sample_res.client_track_id]

            if sample_res.response_code == upload_pb2.TrackSampleResponse.MATCHED:
                self.logger.info("matched '%s' to sid %s", path, sample_res.server_track_id)

                if enable_matching:
                    matched[path] = sample_res.server_track_id
                else:
                    self.logger.exception("'%s' was matched without matching enabled", path)

            elif sample_res.response_code == upload_pb2.TrackSampleResponse.UPLOAD_REQUESTED:
                to_upload[sample_res.server_track_id] = (path, track, False)

            else:
                # there was a problem
                # report the symbolic name of the response code enum for debugging
                enum_desc = upload_pb2._TRACKSAMPLERESPONSE.enum_types[0]
                res_name = enum_desc.values_by_number[sample_res.response_code].name

                err_msg = "TrackSampleResponse code %s: %s" % (sample_res.response_code, res_name)

                if res_name == 'ALREADY_EXISTS':
                    # include the sid, too
                    # this shouldn't be relied on externally, but I use it in
                    # tests - being surrounded by parens is how it's matched
                    err_msg += "(%s)" % sample_res.server_track_id

                self.logger.warning("upload of '%s' rejected: %s", path, err_msg)
                not_uploaded[path] = err_msg

        #Send upload requests.
        if to_upload:
            #TODO reordering requests could avoid wasting time waiting for reup sync
            self._make_call(musicmanager.UpdateUploadState, 'start', self.uploader_id)

            for server_id, (path, track, do_not_rematch) in to_upload.items():
                #It can take a few tries to get an session.
                should_retry = True
                attempts = 0

                while should_retry and attempts < 10:
                    session = self._make_call(musicmanager.GetUploadSession,
                                              self.uploader_id, len(uploaded),
                                              track, path, server_id, do_not_rematch)
                    attempts += 1

                    got_session, error_details = \
                        musicmanager.GetUploadSession.process_session(session)

                    if got_session:
                        self.logger.info("got an upload session for '%s'", path)
                        break

                    should_retry, reason, error_code = error_details
                    self.logger.debug("problem getting upload session: %s\ncode=%s retrying=%s",
                                      reason, error_code, should_retry)

                    if error_code == 200 and do_not_rematch:
                        #reupload requests need to wait on a server sync
                        #200 == already uploaded, so force a retry in this case
                        should_retry = True

                    time.sleep(6)  # wait before retrying
                else:
                    err_msg = "GetUploadSession error %s: %s" % (error_code, reason)

                    self.logger.warning("giving up on upload session for '%s': %s", path, err_msg)
                    not_uploaded[path] = err_msg

                    continue  # to next upload

                #got a session, do the upload
                #this terribly inconsistent naming isn't my fault: Google--
                session = session['sessionStatus']
                external = session['externalFieldTransfers'][0]

                session_url = external['putInfo']['url']
                content_type = external.get('content_type', 'audio/mpeg')

                if track.original_content_type != locker_pb2.Track.MP3:
                    try:
                        self.logger.info("transcoding '%s' to mp3", path)
                        contents = utils.transcode_to_mp3(path, quality=transcode_quality)
                    except (IOError, ValueError) as e:
                        self.logger.warning("error transcoding %s: %s", path, e)
                        not_uploaded[path] = "transcoding error: %s" % e
                        continue
                else:
                    with open(path, 'rb') as f:
                        contents = f.read()

                upload_response = self._make_call(musicmanager.UploadFile,
                                                  session_url, content_type, contents)

                success = upload_response.get('sessionStatus', {}).get('state')
                if success:
                    uploaded[path] = server_id
                else:
                    #404 == already uploaded? serverside check on clientid?
                    self.logger.debug("could not finalize upload of '%s'. response: %s",
                                      path, upload_response)
                    not_uploaded[path] = 'could not finalize upload; details in log'

            self._make_call(musicmanager.UpdateUploadState, 'stopped', self.uploader_id)

        return uploaded, matched, not_uploaded

########NEW FILE########
__FILENAME__ = shared
import logging

from gmusicapi.utils import utils


class _Base(object):
    """Factors out common client setup."""

    __metaclass__ = utils.DocstringInheritMeta
    _session_class = utils.NotImplementedField

    num_clients = 0  # used to disambiguate loggers

    def __init__(self, logger_basename, debug_logging, validate, verify_ssl):
        """

        :param debug_logging: each Client has a ``logger`` member.
          The logger is named ``gmusicapi.<client class><client number>`` and
          will propogate to the ``gmusicapi`` root logger.

          If this param is ``True``, handlers will be configured to send
          this client's debug log output to disk,
          with warnings and above printed to stderr.
          `Appdirs <https://pypi.python.org/pypi/appdirs/1.2.0>`__
          ``user_log_dir`` is used by default. Users can run::

              from gmusicapi.utils import utils
              print utils.log_filepath

          to see the exact location on their system.

          If ``False``, no handlers will be configured;
          users must create their own handlers.

          Completely ignoring logging is dangerous and not recommended.
          The Google Music protocol can change at any time; if
          something were to go wrong, the logs would be necessary for
          recovery.

        :param validate: if False, do not validate server responses against
          known schemas. This helps to catch protocol changes, but requires
          significant cpu work.

          This arg is stored as ``self.validate`` and can be safely
          modified at runtime.

        :param verify_ssl: if False, exceptions will not be raised if there
          are problems verifying SSL certificates.
          Be wary of using this option; it's almost always better to
          fix the machine's SSL configuration than to ignore errors.
        """
        # this isn't correct if init is called more than once, so we log the
        # client name below to avoid confusion for people reading logs
        _Base.num_clients += 1

        logger_name = "gmusicapi.%s%s" % (logger_basename,
                                          _Base.num_clients)
        self.logger = logging.getLogger(logger_name)
        self.validate = validate
        self._verify_ssl = verify_ssl

        def setup_session(s):
            s.verify = self._verify_ssl

        self.session = self._session_class(rsession_setup=setup_session)

        if debug_logging:
            utils.configure_debug_log_handlers(self.logger)

        self.logger.info("initialized")
        self.logout()

    def _make_call(self, protocol, *args, **kwargs):
        """Returns the response of a protocol.Call.

        args/kwargs are passed to protocol.perform.

        CallFailure may be raised."""

        return protocol.perform(self.session, self.validate, *args, **kwargs)

    def is_authenticated(self):
        """Returns ``True`` if the Api can make an authenticated request."""
        return self.session.is_authenticated

    def logout(self):
        """Forgets local authentication in this Api instance.
        Returns ``True`` on success."""

        # note to clients: this will be called during __init__.

        self.session.logout()
        self.logger.info("logged out")
        return True

########NEW FILE########
__FILENAME__ = webclient
# -*- coding: utf-8 -*-

from urlparse import urlparse, parse_qsl

import gmusicapi
from gmusicapi.clients.shared import _Base
from gmusicapi.protocol import webclient
from gmusicapi.utils import utils
import gmusicapi.session


class Webclient(_Base):
    """Allows library management and streaming by posing as the
    music.google.com webclient.

    Uploading is not supported by this client (use the :class:`Musicmanager`
    to upload).

    Any methods in this class that are duplicated by
    the :class:`Mobileclient` are deprecated, and will generate a
    warning at runtime.

    The following methods are *not* deprecated:

        * :func:`create_playlist`
        * :func:`get_registered_devices`
        * :func:`get_song_download_info`
        * :func:`get_stream_urls`
        * :func:`get_stream_audio`
        * :func:`report_incorrect_match`
        * :func:`upload_album_art`
    """

    _session_class = gmusicapi.session.Webclient

    def __init__(self, debug_logging=True, validate=True, verify_ssl=True):
        super(Webclient, self).__init__(self.__class__.__name__,
                                        debug_logging,
                                        validate,
                                        verify_ssl)

    def login(self, email, password):
        """Authenticates the webclient.
        Returns ``True`` on success, ``False`` on failure.

        :param email: eg ``'test@gmail.com'`` or just ``'test'``.
        :param password: password or app-specific password for 2-factor users.
          This is not stored locally, and is sent securely over SSL.

        Users of two-factor authentication will need to set an application-specific password
        to log in.
        """

        if not self.session.login(email, password):
            self.logger.info("failed to authenticate")
            return False

        self.logger.info("authenticated")

        return True

    def logout(self):
        return super(Webclient, self).logout()

    def create_playlist(self, name, description, public=False):
        """
        Creates a playlist and returns its id.

        :param name: the name of the playlist.
        :param description: the description of the playlist.
        :param public: if True and the user has All Access, create a shared playlist.
        """
        res = self._make_call(webclient.CreatePlaylist, name, description, public)

        return res[1][0]

    def get_registered_devices(self):
        """
        Returns a list of dictionaries representing devices associated with the account.

        Performing the :class:`Musicmanager` OAuth flow will register a device
        of type ``'DESKTOP_APP'``.

        Installing the Android Google Music app and logging into it will
        register a device of type ``'PHONE'``, which is required for streaming with
        the :class:`Mobileclient`.

        Here is an example response::

            [
              {
                u'date': 1367470393588,           # utc-millisecond
                u'id':   u'AA:BB:CC:11:22:33',
                u'lastUsedMs': 1394138679694,
                u'name': u'my-hostname',
                u'type': u'DESKTOP_APP'
              },
              {
                u'carrier':      u'Google',
                u'date':         1344808742774,
                u'id':           u'0x00112233aabbccdd',  # remove 0x when streaming
                u'manufacturer': u'Asus',
                u'model':        u'Nexus 7',
                u'name':         u'',
                u'type':         u'PHONE'
              },
              {
                u'date': 1394133624308,
                u'id': u'ios:01234567-0123-0123-0123-0123456789AB',
                u'lastUsedMs': 1394138679694,
                u'type': u'IOS'
              }
            ]

        """

        #TODO sessionid stuff
        res = self._make_call(webclient.GetSettings, '')
        return res['settings']['devices']

    @utils.enforce_id_param
    def get_song_download_info(self, song_id):
        """Returns a tuple: ``('<url>', <download count>)``.

        :param song_id: a single song id.

        ``url`` will be ``None`` if the download limit is exceeded.

        GM allows 2 downloads per song. The download count may not always be accurate,
        and the 2 download limit seems to be loosely enforced.

        This call alone does not count towards a download -
        the count is incremented when ``url`` is retrieved.
        """

        #TODO the protocol expects a list of songs - could extend with accept_singleton
        info = self._make_call(webclient.GetDownloadInfo, [song_id])
        url = info.get('url')

        return (url, info["downloadCounts"][song_id])

    @utils.enforce_id_param
    def get_stream_urls(self, song_id):
        """Returns a list of urls that point to a streamable version of this song.

        If you just need the audio and are ok with gmusicapi doing the download,
        consider using :func:`get_stream_audio` instead.
        This abstracts away the differences between different kinds of tracks:

            * normal tracks return a single url
            * All Access tracks return multiple urls, which must be combined

        :param song_id: a single song id.

        While acquiring the urls requires authentication, retreiving the
        contents does not.

        However, there are limitations on how the stream urls can be used:

            * the urls expire after a minute
            * only one IP can be streaming music at once.
              Other attempts will get an http 403 with
              ``X-Rejected-Reason: ANOTHER_STREAM_BEING_PLAYED``.

        *This is only intended for streaming*. The streamed audio does not contain metadata.
        Use :func:`get_song_download_info` or :func:`Musicmanager.download_song
        <gmusicapi.clients.Musicmanager.download_song>`
        to download files with metadata.
        """

        res = self._make_call(webclient.GetStreamUrl, song_id)

        try:
            return [res['url']]
        except KeyError:
            return res['urls']

    @utils.enforce_id_param
    def get_stream_audio(self, song_id, use_range_header=None):
        """Returns a bytestring containing mp3 audio for this song.

        :param song_id: a single song id
        :param use_range_header: in some cases, an HTTP range header can be
          used to save some bandwidth.
          However, there's no guarantee that the server will respect it,
          meaning that the client may get back an unexpected response when
          using it.

          There are three possible values for this argument:
              * None: (default) send header; fix response locally on problems
              * True: send header; raise IOError on problems
              * False: do not send header
        """

        urls = self.get_stream_urls(song_id)

        #TODO shouldn't session.send be used throughout?

        if len(urls) == 1:
            return self.session._rsession.get(urls[0]).content

        # AA tracks are separated into multiple files.
        # the url contains the range of each file to be used.

        range_pairs = [[int(s) for s in val.split('-')]
                       for url in urls
                       for key, val in parse_qsl(urlparse(url)[4])
                       if key == 'range']

        stream_pieces = []
        prev_end = 0
        headers = None

        for url, (start, end) in zip(urls, range_pairs):
            if use_range_header or use_range_header is None:
                headers = {'Range': 'bytes=' + str(prev_end - start) + '-'}

            audio = self.session._rsession.get(url, headers=headers).content

            if end - prev_end != len(audio) - 1:
                #content length is not in the right range

                if use_range_header:
                    # the user didn't want automatic response fixup
                    raise IOError('use_range_header is True but the response'
                                  ' was not the correct content length.'
                                  ' This might be caused by a (poorly-written) http proxy.')

                # trim to the proper range
                audio = audio[prev_end - start:]

            stream_pieces.append(audio)

            prev_end = end + 1

        return ''.join(stream_pieces)

    @utils.accept_singleton(basestring)
    @utils.enforce_ids_param
    @utils.empty_arg_shortcircuit
    def report_incorrect_match(self, song_ids):
        """Equivalent to the 'Fix Incorrect Match' button, this requests re-uploading of songs.
        Returns the song_ids provided.

        :param song_ids: a list of song ids to report, or a single song id.

        Note that if you uploaded a song through gmusicapi, it won't be reuploaded
        automatically - this currently only works for songs uploaded with the Music Manager.
        See issue `#89 <https://github.com/simon-weber/Unofficial-Google-Music-API/issues/89>`__.

        This should only be used on matched tracks (``song['type'] == 6``).
        """

        self._make_call(webclient.ReportBadSongMatch, song_ids)

        return song_ids

    @utils.accept_singleton(basestring)
    @utils.enforce_ids_param
    @utils.empty_arg_shortcircuit
    def upload_album_art(self, song_ids, image_filepath):
        """Uploads an image and sets it as the album art for songs.
        Returns a url to the image on Google's servers.

        :param song_ids: a list of song ids, or a single song id.
        :param image_filepath: filepath of the art to use. jpg and png are known to work.

        This function will *always* upload the provided image, even if it's already uploaded.
        If the art is already uploaded and set for another song, copy over the
        value of the ``'albumArtUrl'`` key using :func:`Mobileclient.change_song_metadata` instead.
        """

        res = self._make_call(webclient.UploadImage, image_filepath)
        url = res['imageUrl']

        song_dicts = [dict((('id', id), ('albumArtUrl', url))) for id in song_ids]

        self._make_call(webclient.ChangeSongMetadata, song_dicts)

        return url

    # deprecated methods follow:

    @utils.accept_singleton(basestring)
    @utils.enforce_ids_param
    @utils.empty_arg_shortcircuit
    @utils.deprecated('prefer Mobileclient.delete_songs')
    def delete_songs(self, song_ids):
        """**Deprecated**: prefer :func:`Mobileclient.delete_songs`.

        Deletes songs from the entire library. Returns a list of deleted song ids.

        :param song_ids: a list of song ids, or a single song id.
        """

        res = self._make_call(webclient.DeleteSongs, song_ids)

        return res['deleteIds']

    @utils.accept_singleton(basestring, 2)
    @utils.enforce_ids_param(2)
    @utils.enforce_id_param
    @utils.empty_arg_shortcircuit(position=2)
    @utils.deprecated('prefer Mobileclient.add_songs_to_playlist')
    def add_songs_to_playlist(self, playlist_id, song_ids):
        """**Deprecated**: prefer :func:`Mobileclient.add_songs_to_playlist`.

        Appends songs to a playlist.
        Returns a list of (song id, playlistEntryId) tuples that were added.

        :param playlist_id: id of the playlist to add to.
        :param song_ids: a list of song ids, or a single song id.

        Playlists have a maximum size of 1000 songs.
        """

        res = self._make_call(webclient.AddToPlaylist, playlist_id, song_ids)
        new_entries = res['songIds']

        return [(e['songId'], e['playlistEntryId']) for e in new_entries]

    @utils.accept_singleton(basestring, 2)
    @utils.enforce_ids_param(2)
    @utils.enforce_id_param
    @utils.empty_arg_shortcircuit(position=2)
    @utils.deprecated('prefer Mobileclient.remove_entries_from_playlist')
    def remove_songs_from_playlist(self, playlist_id, sids_to_match):
        """**Deprecated**: prefer :func:`Mobileclient.remove_entries_from_playlist`.

        Removes all copies of the given song ids from a playlist.
        Returns a list of removed (sid, eid) pairs.

        :param playlist_id: id of the playlist to remove songs from.
        :param sids_to_match: a list of song ids to match, or a single song id.

        This does *not always* the inverse of a call to :func:`add_songs_to_playlist`,
        since multiple copies of the same song are removed.
        """

        playlist_tracks = self.get_playlist_songs(playlist_id)
        sid_set = set(sids_to_match)

        matching_eids = [t["playlistEntryId"]
                         for t in playlist_tracks
                         if t["id"] in sid_set]

        if matching_eids:
            #Call returns "sid_eid" strings.
            sid_eids = self._remove_entries_from_playlist(playlist_id,
                                                          matching_eids)
            return [s.split("_") for s in sid_eids]
        else:
            return []

    @utils.accept_singleton(basestring, 2)
    @utils.empty_arg_shortcircuit(position=2)
    def _remove_entries_from_playlist(self, playlist_id, entry_ids_to_remove):
        """Removes entries from a playlist. Returns a list of removed "sid_eid" strings.

        :param playlist_id: the playlist to be modified.
        :param entry_ids: a list of entry ids, or a single entry id.
        """

        #GM requires the song ids in the call as well; find them.
        playlist_tracks = self.get_playlist_songs(playlist_id)
        remove_eid_set = set(entry_ids_to_remove)

        e_s_id_pairs = [(t["id"], t["playlistEntryId"])
                        for t in playlist_tracks
                        if t["playlistEntryId"] in remove_eid_set]

        num_not_found = len(entry_ids_to_remove) - len(e_s_id_pairs)
        if num_not_found > 0:
            self.logger.warning("when removing, %d entry ids could not be found in playlist id %s",
                                num_not_found, playlist_id)

        #Unzip the pairs.
        sids, eids = zip(*e_s_id_pairs)

        res = self._make_call(webclient.DeleteSongs, sids, playlist_id, eids)

        return res['deleteIds']

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-

"""
Single interface for code that varies across Python environments.
"""

import sys

_ver = sys.version_info
is_py26 = (_ver[:2] == (2, 6))

if is_py26:
    from gmusicapi.utils.counter import Counter
    import unittest2 as unittest
    import simplejson as json
else:  # 2.7
    from collections import Counter  # noqa
    import unittest  # noqa
    import json  # noqa

try:
    from appdirs import AppDirs
    my_appdirs = AppDirs('gmusicapi', 'Simon Weber')
except ImportError:
    print 'warning: could not import appdirs; will use current directory'

    class FakeAppDirs(object):
        to_spoof = set([base + '_dir' for base in
                        ('user_data', 'site_data', 'user_config',
                         'site_config', 'user_cache', 'user_log')])

        def __getattr__(self, name):
            if name in self.to_spoof:
                return '.'  # current dir
            else:
                raise AttributeError

    my_appdirs = FakeAppDirs()

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-

"""Custom exceptions used across the project."""


class CallFailure(Exception):
    """Exception raised when a Google Music server responds that a call failed.

    Attributes:
        callname -- name of the protocol.Call that failed
    """
    def __init__(self, message, callname):
        Exception.__init__(self, message)

        self.callname = callname

    def __str__(self):
        return "%s: %s" % (self.callname, Exception.__str__(self))


class ParseException(Exception):
    """Thrown by Call.parse_response on errors."""
    pass


class ValidationException(Exception):
    """Thrown by Transaction.verify_res_schema on errors."""
    pass


class AlreadyLoggedIn(Exception):
    pass


class NotLoggedIn(Exception):
    pass


class GmusicapiWarning(UserWarning):
    pass

########NEW FILE########
__FILENAME__ = tools
# -*- coding: utf-8 -*-

"""Tools for manipulating client-received Google Music data."""

import operator
import re
import collections

from gmusicapi.compat import Counter


def get_id_pairs(track_list):
    """Create a list of (sid, eid) tuples from a list of tracks. Tracks without an eid will have an eid of None."""

    return [(t["id"], t.get("playlistEntryId")) for t in track_list]

def find_playlist_changes(orig_tracks, modified_tracks):
    """Finds the changes between two playlists.

    Returns a tuple of (deletions, additions, staying). Deletions and additions are both Counters of (sid, eid) tuples; staying is a set of (sid, eid) tuples.

    :param old: the original playlist.
    :param modified: the modified playlist."""

    s_pairs = get_id_pairs(orig_tracks)

    #Three cases for desired pairs:
    # 1: (sid, eid from this playlist): either no action or add (if someone adds a dupe from the same playlist)
    # 2: (sid, eid not from this playlist): add
    # 3: (sid, None): add
    d_pairs = get_id_pairs(modified_tracks)

    #Counters are multisets.
    s_count = Counter(s_pairs)
    d_count = Counter(d_pairs)

    to_del = s_count - d_count
    to_add = d_count - s_count
    to_keep = set(s_count & d_count) #guaranteed to be counts of 1

    return (to_del, to_add, to_keep)

def filter_song_md(song, md_list=['id'], no_singletons=True):
    """Returns a list of desired metadata from a song.
    Does not modify the given song.

    :param song: Dictionary representing a GM song.
    :param md_list: (optional) the ordered list of metadata to select.
    :param no_singletons: (optional) if md_list is of length 1, return the data, not a singleton list.
    """

    filtered = [song[md_type] for md_type in md_list]

    if len(md_list) == 1 and no_singletons:
        return filtered[0]
    else:
        return filtered


def build_song_rep(song, md_list=['title', 'artist', 'album'], divider=" - "):
    """Returns a string of the requested metadata types.
    The order of md_list determines order in the string.

    :param song: Dictionary representing a GM song.
    :param md_list: (optional) list of valid GM metadata types.
    :param divider: (optional) string to join the metadata.
    """

    filtered = filter_song_md(song, md_list, no_singletons=False)

    return divider.join(filtered)


def reorder_to(l, order):
    """Returns a list, reordered to a specific ordering.

    :param l: the list to reorder. It is not modified.
    :param order: a list containing the new ordering,
                  eg [2,1,0] to reverse a list of length 3
    """

    #Zip on ordering, sort by it, then remove ordering.
    return map(lambda el: el[1],
               sorted(zip(order, l), key = lambda el: el[0]))


def build_queries_from(f, regex, cap_types, cap_pr, encoding='ascii'):
    """Returns a list of queries from the given file.
    Queries have the form [(<query>, <metadata type>), ...]

    :param f: opened file, ready to read.
    :param regex: a compiled regex to capture query info from file lines.
    :param cap_types: the GM metadata types of the regex captures.
    :param cap_pr: the priority of the captures.
    :param encoding: (optional) encoding of the file.
    """

    queries = []

    for line in f:
            matches = regex.match(line)

            if matches:
                #Zip captures to their types and order by priority to build a query.
                query = reorder_to(
                    zip(matches.groups(), cap_types),
                    cap_pr)

                queries.append(query)

    return queries


def build_query_rep(query, divider=" - "):
    """Build a string representation of a query, without metadata types"""

    return divider.join(map(lambda el:el[0], query))


#Not mine. From: http://en.wikipedia.org/wiki/Function_composition_(computer_science)
def compose(*funcs, **kfuncs):
    """Compose a group of functions (f(g(h(..)))) into (fogoh...)(...)"""
    return reduce(lambda f, g: lambda *args, **kaargs: f(g(*args, **kaargs)), funcs)


class SongMatcher(object):
    """Matches GM songs to user-provided metadata."""

    def __init__(self, songs, log_metadata=['title', 'artist', 'album']):
        """Prepares songs for matching and determines logging options.

        :param songs: list of GM songs to match against.
        :param log_metadata: list of valid GM metadata types to show in the log.
                             order given will be order outputted.
        """

        #If match times are a problem, could
        #read to an indexed format here.
        self.library = songs

        #Lines of a log of how matching went.
        self.log_lines = []

        self.log_metadata = log_metadata

    def build_log(self):
        """Returns a string built from the current log lines."""

        encoded_lines = [line.encode('utf-8') for line in self.log_lines]
        return "\n".join(encoded_lines)

    def build_song_for_log(self, song):
        """Returns a string built from a song using log options.

        :param song:
        """

        return build_song_rep(song, self.log_metadata)

    class SearchModifier(object):
        """Controls how to query the library.
        Implementations define a comparator, and 2 functions
        (transformers) to modify the query and song data on the fly.

        Sometimes it makes sense to chain implementations.
        In this case, transformers are composed and the most
        outward comparator is used.
        """

        def __init__(self, q_t, s_t, comp):
            #Comparator - defines how to compare query and song data.
            # f(song data, query) -> truthy value
            self.comp = comp

            #Query and song transformers -
            # manipulate query, song before comparison.
            # f(unicode) -> unicode
            self.q_t = q_t

            self.s_t = s_t

    #Some modifiers that are useful in my library:
    #Ignore capitalization:
    ignore_caps = SearchModifier(
        #Change query and song to lowercase,
        #before comparing with ==.
        unicode.lower,
        unicode.lower,
        operator.eq
    )

    #Wildcard punctuation (also non ascii chars):
    ignore_punc = SearchModifier(
        #Replace query with a regex, where punc matches any (or no) characters.
        lambda q : re.sub(r"[^a-zA-Z0-9\s]", ".*", q),
        #Don't change the song.
        lambda s: s,
        #The comparator becomes regex matching.
        lambda sd, q: re.search(q, sd)
    )

    implemented_modifiers = (ignore_caps, ignore_punc)

    #The modifiers and order to be used in auto query mode.
    auto_modifiers = implemented_modifiers



    #Tiebreakers are used when there are multiple results from a query.
    @staticmethod
    def manual_tiebreak(query, results):
        """Prompts a user to choose a result from multiple.
        For use with query_library as a tiebreaker.
        Returns a singleton list or None.

        :param query: the original query.
        :param results: list of results.
        """

        print
        print "Manual tiebreak for query:"
        print build_query_rep(query).encode('utf-8')
        print
        print "Enter the number next to your choice:"
        print
        print "0: None of these."

        menu_lines = []
        key = 1

        for song in results:
            menu_lines.append(
                str(key)
                + ": "
                + build_song_rep(song).encode('utf-8'))

            key += 1

        print "\n".join(menu_lines)

        choice = -1

        while not (0 <= choice <= len(results)):
            try:
                choice = int(raw_input("Choice: "))
            except:
                pass

        return None if choice == 0 else [results[choice - 1]]

    #Tiebreaker which does nothing with results.
    @staticmethod
    def no_tiebreak(query, results):
        return results


    #Exception thrown when a tie is broken.
    class TieBroken(Exception):
        def __init__(self, results):
            self.results = results


    #A named tuple to hold the frozen args when querying recursively.
    QueryState = collections.namedtuple('QueryState', 'orig t_breaker mods auto')

    def query_library(self, query, tie_breaker=no_tiebreak, modifiers=None, auto=False):
        """Queries the library for songs.
        returns a list of matches, or None.
        """

        if not modifiers:
            modifiers = []

        try:
            if not auto:
                return self.query_library_rec(query, self.library, self.QueryState(query, tie_breaker, modifiers, auto))
            else:
                #Auto mode attempts a search with the current modifiers.
                #If we get 1 result, we return it.
                #If we get no results, we add the next mod from auto_modifers and try again.
                #If we get many results, we branch and try with another modifier.
                # On no results, we tiebreak our old results. Otherwise, we return the branched results.

                current_mods = modifiers[:]
                #Be ready to use any mods from the auto list which we aren't using already.
                future_mods = (m for m in self.auto_modifiers if m not in modifiers)

                while True: #broken when future_mods runs out

                    #will not break ties in auto mode
                    results = self.query_library_rec(query, self.library, self.QueryState(query, tie_breaker, current_mods, auto))

                    if not results:
                        try:
                            current_mods.append(future_mods.next())
                        except StopIteration:
                            return results

                    elif len(results) == 1:
                        return results

                    else:
                        #Received many results from our current search.
                        #Branch; try more modifers to try and improve.
                        #If results, use them; otherwise tiebreak ours.
                        try:
                            current_mods.append(future_mods.next())
                        except StopIteration:
                            raise self.TieBroken(tie_breaker(query, results))

                        next_results = self.query_library(query, tie_breaker, current_mods, auto)

                        if not next_results:
                            raise self.TieBroken(tie_breaker(query, results))
                        else:
                            return next_results
        except self.TieBroken as tie:
            return tie.results


    def query_library_rec(self, query, library, state):
        """Returns a list of matches, or None.
        Recursive querying routine for query_library.
        """

        if len(query) == 0:
            return None

        #Composing applies right to left; currently mods are left to right.
        #Reverse then append the default modifier for proper compose order.
        mods_to_apply = [sm for sm in reversed(state.mods)]
        mods_to_apply.append(self.SearchModifier(
                lambda q: q,
                lambda sd : sd,
                operator.eq))

        #Create the transformers by composing all of them.
        q_t = compose(*map((lambda sm : sm.q_t), mods_to_apply))
        s_t = compose(*map((lambda sm : sm.s_t), mods_to_apply))

        #Use the most outward comparator.
        comp = mods_to_apply[0].comp


        q, md_type = query[0]

        #No need to repeatedly transform q.
        q_transformed = q_t(q)

        #GM limits libraries to 20k songs; this isn't a big performance hit.
        results = [s for s in library if comp(s_t(s[md_type]), q_transformed)]

        #Check for immediate return conditions.
        if not results:
            return None

        if len(results) == 1:
            return [results[0]]

        #Try to refine results by querying them with the next metadata in the query.
        next_query = query[1:]

        next_results = self.query_library_rec(next_query, results, state)

        if not next_results:
            #Don't break ties in auto mode; it's handled a level up.
            if not state.auto:
                raise self.TieBroken(state.t_breaker(state.orig, results))
            else:
                return results


        #Now we have multiple for both our query and the next.
        #Always prefer the next query to ours.
        return next_results

    def match(self, queries, tie_breaker=manual_tiebreak, auto=True):
        """Runs queries against the library; returns a list of songs.
        Match success is logged.

        :param query: list of (query, metadata type) in order of precedence.
                      eg [('The Car Song', 'title'), ('The Cat Empire', 'artist')]
        :param tie_breaker: (optional) tie breaker to use.
        :param modifiers: (optional) An ordered collection of SearchModifers to apply during the query, left to right.
        :param auto: (optional) When True, automagically manage modifiers to find results.
        """

        matches = []

        self.log_lines.append("### Starting match of " + str(len(queries)) + " queries ###")

        for query in queries:
            res = self.query_library(query, tie_breaker, auto=auto)
            matches += res

            #Log the results.

            #The alert precedes the information for a quick view of what happened.
            alert = None
            if res == None:
                alert = "!!"
            elif len(res) == 1:
                alert = "=="
            else:
                alert = "??"

            #Each query shows the alert and the query.
            self.log_lines.append(alert + " " +  build_query_rep(query))

            #Displayed on the line below the alert (might be useful later).
            extra_info = None

            if res:
                for song in res:
                    self.log_lines.append(
                        (extra_info if extra_info else (' ' * len(alert)))
                        + " "
                        + self.build_song_for_log(song))

            elif extra_info:
                self.log_lines.append(extra_info)


        return matches

########NEW FILE########
__FILENAME__ = download_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!

from google.protobuf import descriptor
from google.protobuf import message
from google.protobuf import reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)



DESCRIPTOR = descriptor.FileDescriptor(
  name='download.proto',
  package='',
  serialized_pb='\n\x0e\x64ownload.proto\"\xdf\x01\n\x18GetTracksToExportRequest\x12\x11\n\tclient_id\x18\x02 \x02(\t\x12\x1a\n\x12\x63ontinuation_token\x18\x03 \x01(\t\x12\x41\n\x0b\x65xport_type\x18\x04 \x01(\x0e\x32,.GetTracksToExportRequest.TracksToExportType\x12\x13\n\x0bupdated_min\x18\x05 \x01(\x03\"<\n\x12TracksToExportType\x12\x07\n\x03\x41LL\x10\x01\x12\x1d\n\x19PURCHASED_AND_PROMOTIONAL\x10\x02\"\x8d\x01\n\x11\x44ownloadTrackInfo\x12\n\n\x02id\x18\x01 \x01(\t\x12\r\n\x05title\x18\x02 \x01(\t\x12\r\n\x05\x61lbum\x18\x03 \x01(\t\x12\x14\n\x0c\x61lbum_artist\x18\x04 \x01(\t\x12\x0e\n\x06\x61rtist\x18\x05 \x01(\t\x12\x14\n\x0ctrack_number\x18\x06 \x01(\x05\x12\x12\n\ntrack_size\x18\x07 \x01(\x03\"\xd3\x02\n\x19GetTracksToExportResponse\x12?\n\x06status\x18\x01 \x02(\x0e\x32/.GetTracksToExportResponse.TracksToExportStatus\x12/\n\x13\x64ownload_track_info\x18\x02 \x03(\x0b\x32\x12.DownloadTrackInfo\x12\x1a\n\x12\x63ontinuation_token\x18\x03 \x01(\t\x12\x13\n\x0bupdated_min\x18\x04 \x01(\x03\"\x92\x01\n\x14TracksToExportStatus\x12\x06\n\x02OK\x10\x01\x12\x13\n\x0fTRANSIENT_ERROR\x10\x02\x12\x1b\n\x17MAX_NUM_CLIENTS_REACHED\x10\x03\x12!\n\x1dUNABLE_TO_AUTHENTICATE_CLIENT\x10\x04\x12\x1d\n\x19UNABLE_TO_REGISTER_CLIENT\x10\x05')



_GETTRACKSTOEXPORTREQUEST_TRACKSTOEXPORTTYPE = descriptor.EnumDescriptor(
  name='TracksToExportType',
  full_name='GetTracksToExportRequest.TracksToExportType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='ALL', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PURCHASED_AND_PROMOTIONAL', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=182,
  serialized_end=242,
)

_GETTRACKSTOEXPORTRESPONSE_TRACKSTOEXPORTSTATUS = descriptor.EnumDescriptor(
  name='TracksToExportStatus',
  full_name='GetTracksToExportResponse.TracksToExportStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TRANSIENT_ERROR', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MAX_NUM_CLIENTS_REACHED', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UNABLE_TO_AUTHENTICATE_CLIENT', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UNABLE_TO_REGISTER_CLIENT', index=4, number=5,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=582,
  serialized_end=728,
)


_GETTRACKSTOEXPORTREQUEST = descriptor.Descriptor(
  name='GetTracksToExportRequest',
  full_name='GetTracksToExportRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='client_id', full_name='GetTracksToExportRequest.client_id', index=0,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetTracksToExportRequest.continuation_token', index=1,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='export_type', full_name='GetTracksToExportRequest.export_type', index=2,
      number=4, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='updated_min', full_name='GetTracksToExportRequest.updated_min', index=3,
      number=5, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETTRACKSTOEXPORTREQUEST_TRACKSTOEXPORTTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=19,
  serialized_end=242,
)


_DOWNLOADTRACKINFO = descriptor.Descriptor(
  name='DownloadTrackInfo',
  full_name='DownloadTrackInfo',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='id', full_name='DownloadTrackInfo.id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='title', full_name='DownloadTrackInfo.title', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album', full_name='DownloadTrackInfo.album', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_artist', full_name='DownloadTrackInfo.album_artist', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='artist', full_name='DownloadTrackInfo.artist', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_number', full_name='DownloadTrackInfo.track_number', index=5,
      number=6, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_size', full_name='DownloadTrackInfo.track_size', index=6,
      number=7, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=245,
  serialized_end=386,
)


_GETTRACKSTOEXPORTRESPONSE = descriptor.Descriptor(
  name='GetTracksToExportResponse',
  full_name='GetTracksToExportResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='status', full_name='GetTracksToExportResponse.status', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='download_track_info', full_name='GetTracksToExportResponse.download_track_info', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetTracksToExportResponse.continuation_token', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='updated_min', full_name='GetTracksToExportResponse.updated_min', index=3,
      number=4, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETTRACKSTOEXPORTRESPONSE_TRACKSTOEXPORTSTATUS,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=389,
  serialized_end=728,
)

_GETTRACKSTOEXPORTREQUEST.fields_by_name['export_type'].enum_type = _GETTRACKSTOEXPORTREQUEST_TRACKSTOEXPORTTYPE
_GETTRACKSTOEXPORTREQUEST_TRACKSTOEXPORTTYPE.containing_type = _GETTRACKSTOEXPORTREQUEST;
_GETTRACKSTOEXPORTRESPONSE.fields_by_name['status'].enum_type = _GETTRACKSTOEXPORTRESPONSE_TRACKSTOEXPORTSTATUS
_GETTRACKSTOEXPORTRESPONSE.fields_by_name['download_track_info'].message_type = _DOWNLOADTRACKINFO
_GETTRACKSTOEXPORTRESPONSE_TRACKSTOEXPORTSTATUS.containing_type = _GETTRACKSTOEXPORTRESPONSE;
DESCRIPTOR.message_types_by_name['GetTracksToExportRequest'] = _GETTRACKSTOEXPORTREQUEST
DESCRIPTOR.message_types_by_name['DownloadTrackInfo'] = _DOWNLOADTRACKINFO
DESCRIPTOR.message_types_by_name['GetTracksToExportResponse'] = _GETTRACKSTOEXPORTRESPONSE

class GetTracksToExportRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETTRACKSTOEXPORTREQUEST
  
  # @@protoc_insertion_point(class_scope:GetTracksToExportRequest)

class DownloadTrackInfo(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _DOWNLOADTRACKINFO
  
  # @@protoc_insertion_point(class_scope:DownloadTrackInfo)

class GetTracksToExportResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETTRACKSTOEXPORTRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetTracksToExportResponse)

# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = locker_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!

from google.protobuf import descriptor
from google.protobuf import message
from google.protobuf import reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)


import uits_pb2

DESCRIPTOR = descriptor.FileDescriptor(
  name='locker.proto',
  package='',
  serialized_pb='\n\x0clocker.proto\x1a\nuits.proto\"\xf8\x01\n\x08\x41udioRef\x12\x1e\n\x05store\x18\x01 \x02(\x0e\x32\x0f.AudioRef.Store\x12\x0b\n\x03ref\x18\x02 \x02(\x0c\x12\x0b\n\x03url\x18\x04 \x01(\t\x12\x10\n\x08\x62it_rate\x18\x05 \x01(\x05\x12\x13\n\x0bsample_rate\x18\x06 \x01(\x05\x12\x14\n\x0c\x64ownloadable\x18\x07 \x01(\x08\x12\x17\n\x0f\x64uration_millis\x18\x08 \x01(\x03\x12\x19\n\x11rematch_timestamp\x18\t \x01(\x03\x12\x1e\n\x16invalid_due_to_wipeout\x18\n \x01(\x08\"!\n\x05Store\x12\r\n\tBLOBSTORE\x10\x01\x12\t\n\x05SM_V2\x10\x02\"\xd1\x01\n\x08ImageRef\x12\x1e\n\x05store\x18\x01 \x01(\x0e\x32\x0f.ImageRef.Store\x12\r\n\x05width\x18\x02 \x01(\r\x12\x0e\n\x06height\x18\x03 \x01(\r\x12\x0b\n\x03url\x18\x06 \x01(\t\x12\x1e\n\x16invalid_due_to_wipeout\x18\x07 \x01(\x08\x12 \n\x06origin\x18\x08 \x01(\x0e\x32\x10.ImageRef.Origin\"\x14\n\x05Store\x12\x0b\n\x07SHOEBOX\x10\x03\"!\n\x06Origin\x12\x0c\n\x08PERSONAL\x10\x01\x12\t\n\x05STORE\x10\x02\"1\n\x12UploadedUitsId3Tag\x12\r\n\x05owner\x18\x01 \x01(\t\x12\x0c\n\x04\x64\x61ta\x18\x02 \x01(\x0c\"\x8c\x10\n\x05Track\x12\n\n\x02id\x18\x01 \x01(\t\x12\x11\n\tclient_id\x18\x02 \x01(\t\x12\x1a\n\x12\x63reation_timestamp\x18\x03 \x01(\x03\x12\x1f\n\x17last_modified_timestamp\x18\x04 \x01(\x03\x12\x16\n\x07\x64\x65leted\x18\x05 \x01(\x08:\x05\x66\x61lse\x12\r\n\x05title\x18\x06 \x01(\t\x12\x0e\n\x06\x61rtist\x18\x07 \x01(\t\x12\x13\n\x0b\x61rtist_hash\x18. \x01(\x03\x12\x10\n\x08\x63omposer\x18\x08 \x01(\t\x12\r\n\x05\x61lbum\x18\t \x01(\t\x12\x14\n\x0c\x61lbum_artist\x18\n \x01(\t\x12\x17\n\x0f\x63\x61nonical_album\x18\x38 \x01(\t\x12\x18\n\x10\x63\x61nonical_artist\x18\x39 \x01(\t\x12\x1d\n\x15\x63\x61nonical_genre_album\x18: \x01(\t\x12\x0c\n\x04year\x18\x0b \x01(\x05\x12\x0f\n\x07\x63omment\x18\x0c \x01(\t\x12\x14\n\x0ctrack_number\x18\r \x01(\x05\x12\r\n\x05genre\x18\x0e \x01(\t\x12\x17\n\x0f\x64uration_millis\x18\x0f \x01(\x03\x12\x18\n\x10\x62\x65\x61ts_per_minute\x18\x10 \x01(\x05\x12\x19\n\x11original_bit_rate\x18, \x01(\x05\x12\x1c\n\taudio_ref\x18\x11 \x03(\x0b\x32\t.AudioRef\x12 \n\ralbum_art_ref\x18\x12 \x03(\x0b\x32\t.ImageRef\x12\x36\n\x13\x61vailability_status\x18\x13 \x01(\x0e\x32\x19.Track.AvailabilityStatus\x12\x12\n\nplay_count\x18\x14 \x01(\x05\x12(\n\x0c\x63ontent_type\x18\x19 \x01(\x0e\x32\x12.Track.ContentType\x12\x19\n\x11total_track_count\x18\x1a \x01(\x05\x12\x13\n\x0b\x64isc_number\x18\x1b \x01(\x05\x12\x18\n\x10total_disc_count\x18\x1c \x01(\x05\x12!\n\x08\x63hannels\x18\x1d \x01(\x0e\x32\x0f.Track.Channels\x12$\n\ntrack_type\x18\x1e \x01(\x0e\x32\x10.Track.TrackType\x12\x1e\n\x16use_single_server_copy\x18; \x01(\x08\x12\x1d\n\x06rating\x18\x1f \x01(\x0e\x32\r.Track.Rating\x12\x16\n\x0e\x65stimated_size\x18  \x01(\x03\x12\x10\n\x08store_id\x18! \x01(\t\x12\x12\n\nmetajam_id\x18\" \x01(\t\x12 \n\x15metajam_id_confidence\x18+ \x01(\x01:\x01\x30\x12\x0c\n\x04uits\x18# \x01(\t\x12$\n\ruits_metadata\x18( \x01(\x0b\x32\r.UitsMetadata\x12\x13\n\x0b\x63ompilation\x18$ \x01(\x08\x12\x19\n\x11\x63lient_date_added\x18% \x01(\x03\x12\x18\n\x10recent_timestamp\x18& \x01(\x03\x12\x1d\n\x0e\x64o_not_rematch\x18\' \x01(\x08:\x05\x66\x61lse\x12\x1b\n\x13\x66rom_album_purchase\x18) \x01(\x08\x12\x18\n\x10\x61lbum_metajam_id\x18* \x01(\t\x12\x16\n\x0etransaction_id\x18- \x01(\t\x12\x13\n\x0b\x64\x65\x62ug_track\x18/ \x01(\x08\x12\x18\n\x10normalized_title\x18\x30 \x01(\t\x12\x19\n\x11normalized_artist\x18\x31 \x01(\t\x12\x18\n\x10normalized_album\x18\x32 \x01(\t\x12\x1f\n\x17normalized_album_artist\x18\x33 \x01(\t\x12\"\n\x1anormalized_canonical_album\x18\x36 \x01(\t\x12#\n\x1bnormalized_canonical_artist\x18\x37 \x01(\t\x12\x13\n\x0buploader_id\x18\x34 \x01(\t\x12\x17\n\x0f\x63lient_album_id\x18\x35 \x01(\t\x12\x18\n\x10label_owner_code\x18< \x01(\t\x12\x31\n\x15original_content_type\x18= \x01(\x0e\x32\x12.Track.ContentType\x12*\n\ruploaded_uits\x18G \x03(\x0b\x32\x13.UploadedUitsId3Tag\"\x86\x01\n\x12\x41vailabilityStatus\x12\x0b\n\x07PENDING\x10\x01\x12\x0b\n\x07MATCHED\x10\x02\x12\x14\n\x10UPLOAD_REQUESTED\x10\x03\x12\r\n\tAVAILABLE\x10\x04\x12\x12\n\x0e\x46ORCE_REUPLOAD\x10\x05\x12\x1d\n\x19UPLOAD_PERMANENTLY_FAILED\x10\x06\"W\n\x0b\x43ontentType\x12\x07\n\x03MP3\x10\x01\x12\x07\n\x03M4A\x10\x02\x12\x07\n\x03\x41\x41\x43\x10\x03\x12\x08\n\x04\x46LAC\x10\x04\x12\x07\n\x03OGG\x10\x05\x12\x07\n\x03WMA\x10\x06\x12\x07\n\x03M4P\x10\x07\x12\x08\n\x04\x41LAC\x10\x08\" \n\x08\x43hannels\x12\x08\n\x04MONO\x10\x01\x12\n\n\x06STEREO\x10\x02\"\x8b\x01\n\tTrackType\x12\x11\n\rMATCHED_TRACK\x10\x01\x12\x13\n\x0fUNMATCHED_TRACK\x10\x02\x12\x0f\n\x0bLOCAL_TRACK\x10\x03\x12\x13\n\x0fPURCHASED_TRACK\x10\x04\x12\x1f\n\x1bMETADATA_ONLY_MATCHED_TRACK\x10\x05\x12\x0f\n\x0bPROMO_TRACK\x10\x06\"e\n\x06Rating\x12\r\n\tNOT_RATED\x10\x01\x12\x0c\n\x08ONE_STAR\x10\x02\x12\r\n\tTWO_STARS\x10\x03\x12\x0f\n\x0bTHREE_STARS\x10\x04\x12\x0e\n\nFOUR_STARS\x10\x05\x12\x0e\n\nFIVE_STARS\x10\x06\"\x1f\n\x06Tracks\x12\x15\n\x05track\x18\x01 \x03(\x0b\x32\x06.Track\"\xb4\x02\n\x08Playlist\x12\n\n\x02id\x18\x01 \x01(\t\x12\x11\n\tclient_id\x18\x02 \x01(\t\x12\x1a\n\x12\x63reation_timestamp\x18\x03 \x01(\x03\x12\x1f\n\x17last_modified_timestamp\x18\x04 \x01(\x03\x12\x16\n\x07\x64\x65leted\x18\x05 \x01(\x08:\x05\x66\x61lse\x12\x0c\n\x04name\x18\x06 \x01(\t\x12-\n\rplaylist_type\x18\x07 \x01(\x0e\x32\x16.Playlist.PlaylistType\x12#\n\x10playlist_art_ref\x18\x08 \x01(\x0b\x32\t.ImageRef\x12\x18\n\x10recent_timestamp\x18\t \x01(\x03\"8\n\x0cPlaylistType\x12\x12\n\x0eUSER_GENERATED\x10\x01\x12\t\n\x05MAGIC\x10\x02\x12\t\n\x05PROMO\x10\x03\"\xae\x03\n\rPlaylistEntry\x12\x13\n\x0bplaylist_id\x18\x01 \x01(\t\x12\x19\n\x11\x61\x62solute_position\x18\x02 \x01(\x03\x12\x1c\n\x14place_after_entry_id\x18\x03 \x01(\t\x12\x10\n\x08track_id\x18\x04 \x01(\t\x12\n\n\x02id\x18\x05 \x01(\t\x12\x11\n\tclient_id\x18\x06 \x01(\t\x12\x1a\n\x12\x63reation_timestamp\x18\x07 \x01(\x03\x12\x1f\n\x17last_modified_timestamp\x18\x08 \x01(\x03\x12\x16\n\x07\x64\x65leted\x18\t \x01(\x08:\x05\x66\x61lse\x12H\n\x19relative_position_id_type\x18\n \x01(\x0e\x32%.PlaylistEntry.RelativePositionIdType\x12\x15\n\x05track\x18\x0f \x01(\x0b\x32\x06.Track\x12\x1d\n\x15place_before_entry_id\x18\x10 \x01(\t\x12\x17\n\x0fstring_position\x18\x11 \x01(\t\"0\n\x16RelativePositionIdType\x12\n\n\x06SERVER\x10\x01\x12\n\n\x06\x43LIENT\x10\x02\"\xd0\x03\n\x16TrackSearchRestriction\x12\x39\n\tattribute\x18\x01 \x02(\x0e\x32&.TrackSearchRestriction.TrackAttribute\x12\r\n\x05value\x18\x02 \x02(\t\x12?\n\x0f\x63omparison_type\x18\x03 \x02(\x0e\x32&.TrackSearchRestriction.ComparisonType\"\xa6\x01\n\x0eTrackAttribute\x12\t\n\x05TITLE\x10\x01\x12\n\n\x06\x41RTIST\x10\x02\x12\t\n\x05\x41LBUM\x10\x03\x12\x10\n\x0c\x41LBUM_ARTIST\x10\x04\x12\t\n\x05GENRE\x10\x05\x12\x17\n\x13\x41VAILABILITY_STATUS\x10\x06\x12\x0e\n\nTRACK_TYPE\x10\x07\x12\x08\n\x04YEAR\x10\x08\x12\x0c\n\x08STORE_ID\x10\t\x12\x14\n\x10\x41LBUM_METAJAM_ID\x10\n\"\x81\x01\n\x0e\x43omparisonType\x12\t\n\x05\x45QUAL\x10\x00\x12\r\n\tNOT_EQUAL\x10\x01\x12\x10\n\x0cGREATER_THAN\x10\x02\x12\x11\n\rGREATER_EQUAL\x10\x03\x12\r\n\tLESS_THAN\x10\x04\x12\x0e\n\nLESS_EQUAL\x10\x05\x12\x11\n\rPARTIAL_MATCH\x10\x06\"\xda\x01\n\x19TrackSearchRestrictionSet\x12;\n\x04type\x18\x01 \x01(\x0e\x32-.TrackSearchRestrictionSet.RestrictionSetType\x12,\n\x0brestriction\x18\x02 \x03(\x0b\x32\x17.TrackSearchRestriction\x12+\n\x07sub_set\x18\x03 \x03(\x0b\x32\x1a.TrackSearchRestrictionSet\"%\n\x12RestrictionSetType\x12\x07\n\x03\x41ND\x10\x00\x12\x06\n\x02OR\x10\x01\"\x80\x02\n\x0eTrackSortOrder\x12\x31\n\tattribute\x18\x01 \x01(\x0e\x32\x1e.TrackSortOrder.TrackAttribute\x12\x18\n\ndescending\x18\x02 \x01(\x08:\x04true\"\xa0\x01\n\x0eTrackAttribute\x12\x16\n\x12LAST_MODIFIED_TIME\x10\x01\x12\n\n\x06\x41RTIST\x10\x02\x12\t\n\x05\x41LBUM\x10\x03\x12\t\n\x05TITLE\x10\x04\x12\x10\n\x0cTRACK_NUMBER\x10\x06\x12\x0e\n\nPLAY_COUNT\x10\t\x12\x13\n\x0f\x44URATION_MILLIS\x10\n\x12\n\n\x06RATING\x10\x0b\x12\x11\n\rCREATION_TIME\x10\x0c\"\xfe\x02\n\x10GetTracksRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x13\n\x0bupdated_min\x18\x02 \x01(\x03\x12\x17\n\x0finclude_deleted\x18\x03 \x01(\x08\x12\x13\n\x0bmax_results\x18\x04 \x01(\x05\x12\x1a\n\x12\x63ontinuation_token\x18\x05 \x01(\t\x12\x33\n\x12search_restriction\x18\x06 \x03(\x0b\x32\x17.TrackSearchRestriction\x12#\n\nsort_order\x18\x07 \x03(\x0b\x32\x0f.TrackSortOrder\x12\x33\n\x0frestriction_set\x18\x08 \x01(\x0b\x32\x1a.TrackSearchRestrictionSet\x12;\n\x10track_projection\x18\t \x01(\x0e\x32!.GetTracksRequest.TrackProjection\".\n\x0fTrackProjection\x12\x08\n\x04\x46ULL\x10\x01\x12\x11\n\rFRONTEND_VIEW\x10\x02\"\xd3\x01\n\x11GetTracksResponse\x12\x36\n\rresponse_code\x18\x01 \x02(\x0e\x32\x1f.GetTracksResponse.ResponseCode\x12\x15\n\x05track\x18\x02 \x03(\x0b\x32\x06.Track\x12\x1f\n\x17\x65stimated_total_results\x18\x03 \x01(\x03\x12\x1a\n\x12\x63ontinuation_token\x18\x04 \x01(\t\"2\n\x0cResponseCode\x12\x06\n\x02OK\x10\x01\x12\x10\n\x0cNOT_MODIFIED\x10\x02\x12\x08\n\x04GONE\x10\x03\"\xfc\x01\n\x19GetPlaylistEntriesRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x13\n\x0bupdated_min\x18\x02 \x01(\x03\x12\x17\n\x0finclude_deleted\x18\x03 \x01(\x08\x12\x13\n\x0bmax_results\x18\x04 \x01(\x05\x12\x1a\n\x12\x63ontinuation_token\x18\x05 \x01(\t\x12\x1a\n\x12playlist_id_filter\x18\x06 \x01(\t\x12)\n\x1ainclude_all_track_metadata\x18\x07 \x01(\x08:\x05\x66\x61lse\x12(\n\x1aonly_show_available_tracks\x18\x08 \x01(\x08:\x04true\"\xf6\x01\n\x1aGetPlaylistEntriesResponse\x12?\n\rresponse_code\x18\x01 \x02(\x0e\x32(.GetPlaylistEntriesResponse.ResponseCode\x12&\n\x0eplaylist_entry\x18\x02 \x03(\x0b\x32\x0e.PlaylistEntry\x12\x1f\n\x17\x65stimated_total_results\x18\x03 \x01(\x03\x12\x1a\n\x12\x63ontinuation_token\x18\x04 \x01(\t\"2\n\x0cResponseCode\x12\x06\n\x02OK\x10\x01\x12\x10\n\x0cNOT_MODIFIED\x10\x02\x12\x08\n\x04GONE\x10\x03\"\xc8\x01\n\x11PlaylistSortOrder\x12\x37\n\tattribute\x18\x01 \x01(\x0e\x32$.PlaylistSortOrder.PlaylistAttribute\x12\x19\n\ndescending\x18\x02 \x01(\x08:\x05\x66\x61lse\"_\n\x11PlaylistAttribute\x12\x16\n\x12LAST_MODIFIED_TIME\x10\x01\x12\t\n\x05TITLE\x10\x02\x12\x11\n\rCREATION_TIME\x10\x03\x12\x14\n\x10RECENT_TIMESTAMP\x10\x04\"\xad\x01\n\x13GetPlaylistsRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x13\n\x0bupdated_min\x18\x02 \x01(\x03\x12\x17\n\x0finclude_deleted\x18\x03 \x01(\x08\x12\x13\n\x0bmax_results\x18\x04 \x01(\x05\x12\x1a\n\x12\x63ontinuation_token\x18\x05 \x01(\t\x12&\n\nsort_order\x18\x06 \x01(\x0b\x32\x12.PlaylistSortOrder\"\xdf\x01\n\x14GetPlaylistsResponse\x12\x39\n\rresponse_code\x18\x01 \x02(\x0e\x32\".GetPlaylistsResponse.ResponseCode\x12\x1b\n\x08playlist\x18\x02 \x03(\x0b\x32\t.Playlist\x12\x1f\n\x17\x65stimated_total_results\x18\x03 \x01(\x03\x12\x1a\n\x12\x63ontinuation_token\x18\x04 \x01(\t\"2\n\x0cResponseCode\x12\x06\n\x02OK\x10\x01\x12\x10\n\x0cNOT_MODIFIED\x10\x02\x12\x08\n\x04GONE\x10\x03\"3\n\x12LookupTrackRequest\x12\n\n\x02id\x18\x01 \x01(\t\x12\x11\n\tclient_id\x18\x02 \x01(\t\";\n\x1aLookupPlaylistEntryRequest\x12\n\n\x02id\x18\x01 \x01(\t\x12\x11\n\tclient_id\x18\x02 \x01(\t\"6\n\x15LookupPlaylistRequest\x12\n\n\x02id\x18\x01 \x01(\t\x12\x11\n\tclient_id\x18\x02 \x01(\t\"\xbe\x02\n\x12\x42\x61tchLookupRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\"\n\x05track\x18\x02 \x03(\x0b\x32\x13.LookupTrackRequest\x12(\n\x08playlist\x18\x03 \x03(\x0b\x32\x16.LookupPlaylistRequest\x12\x37\n\rmetadata_type\x18\x04 \x01(\x0e\x32 .BatchLookupRequest.MetadataType\x12\x33\n\x0eplaylist_entry\x18\x05 \x03(\x0b\x32\x1b.LookupPlaylistEntryRequest\x12\x1e\n\x0finclude_deleted\x18\x06 \x01(\x08:\x05\x66\x61lse\";\n\x0cMetadataType\x12\t\n\x05TRACK\x10\x01\x12\x0c\n\x08PLAYLIST\x10\x02\x12\x12\n\x0ePLAYLIST_ENTRY\x10\x03\"q\n\x13\x42\x61tchLookupResponse\x12\x15\n\x05track\x18\x01 \x03(\x0b\x32\x06.Track\x12\x1b\n\x08playlist\x18\x02 \x03(\x0b\x32\t.Playlist\x12&\n\x0eplaylist_entry\x18\x03 \x03(\x0b\x32\x0e.PlaylistEntry\"\xba\x01\n\x12MutateTrackRequest\x12\x1c\n\x0c\x63reate_track\x18\x01 \x01(\x0b\x32\x06.Track\x12\x1c\n\x0cupdate_track\x18\x02 \x01(\x0b\x32\x06.Track\x12\x14\n\x0c\x64\x65lete_track\x18\x03 \x01(\t\x12\x16\n\x0epartial_update\x18\x04 \x01(\x08\x12\"\n\x14update_last_modified\x18\x05 \x01(\x08:\x04true\x12\x16\n\x0eundelete_track\x18\x06 \x01(\t\"\xb6\x03\n\x0eMutateResponse\x12\x39\n\rresponse_code\x18\x01 \x01(\x0e\x32\".MutateResponse.MutateResponseCode\x12\n\n\x02id\x18\x02 \x01(\t\x12\x10\n\x08\x63hild_id\x18\x03 \x03(\t\x12\x11\n\tclient_id\x18\x04 \x01(\t\x12?\n\x13\x61vailability_status\x18\x05 \x01(\x0e\x32\".MutateResponse.AvailabilityStatus\x12\x15\n\rerror_message\x18\x06 \x01(\t\"W\n\x12MutateResponseCode\x12\x06\n\x02OK\x10\x01\x12\x0c\n\x08\x43ONFLICT\x10\x02\x12\x13\n\x0fINVALID_REQUEST\x10\x03\x12\x16\n\x12METADATA_TOO_LARGE\x10\x04\"\x86\x01\n\x12\x41vailabilityStatus\x12\x0b\n\x07PENDING\x10\x01\x12\x0b\n\x07MATCHED\x10\x02\x12\x14\n\x10UPLOAD_REQUESTED\x10\x03\x12\r\n\tAVAILABLE\x10\x04\x12\x12\n\x0e\x46ORCE_REUPLOAD\x10\x05\x12\x1d\n\x19UPLOAD_PERMANENTLY_FAILED\x10\x06\"\xcd\x01\n\x18\x42\x61tchMutateTracksRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12+\n\x0etrack_mutation\x18\x02 \x03(\x0b\x32\x13.MutateTrackRequest\x12\x1f\n\x11send_notification\x18\x03 \x01(\x08:\x04true\x12\'\n\x19\x64\x65tect_timestamp_conflict\x18\x04 \x01(\x08:\x04true\x12)\n\x1bnotify_fine_grained_updates\x18\x05 \x01(\x08:\x04true\"\xcd\x01\n\x19\x42\x61tchMutateTracksResponse\x12O\n\rresponse_code\x18\x01 \x03(\x0e\x32\x38.BatchMutateTracksResponse.BatchMutateTracksResponseCode\x12(\n\x0fmutate_response\x18\x02 \x03(\x0b\x32\x0f.MutateResponse\"5\n\x1d\x42\x61tchMutateTracksResponseCode\x12\x06\n\x02OK\x10\x01\x12\x0c\n\x08\x43ONFLICT\x10\x02\"\xf7\x01\n\x15MutatePlaylistRequest\x12\"\n\x0f\x63reate_playlist\x18\x01 \x01(\x0b\x32\t.Playlist\x12\"\n\x0fupdate_playlist\x18\x02 \x01(\x0b\x32\t.Playlist\x12\x17\n\x0f\x64\x65lete_playlist\x18\x03 \x01(\t\x12\x16\n\x0epartial_update\x18\x04 \x01(\x08\x12&\n\x0eplaylist_entry\x18\x05 \x03(\x0b\x32\x0e.PlaylistEntry\x12\"\n\x14update_last_modified\x18\x06 \x01(\x08:\x04true\x12\x19\n\x11undelete_playlist\x18\x07 \x01(\t\"\xd7\x01\n\x1b\x42\x61tchMutatePlaylistsRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x31\n\x11playlist_mutation\x18\x02 \x03(\x0b\x32\x16.MutatePlaylistRequest\x12\x1f\n\x11send_notification\x18\x03 \x01(\x08:\x04true\x12\'\n\x19\x64\x65tect_timestamp_conflict\x18\x04 \x01(\x08:\x04true\x12*\n\x1bnotify_fine_grained_updates\x18\x05 \x01(\x08:\x05\x66\x61lse\"\xd9\x01\n\x1c\x42\x61tchMutatePlaylistsResponse\x12U\n\rresponse_code\x18\x01 \x03(\x0e\x32>.BatchMutatePlaylistsResponse.BatchMutatePlaylistsResponseCode\x12(\n\x0fmutate_response\x18\x02 \x03(\x0b\x32\x0f.MutateResponse\"8\n BatchMutatePlaylistsResponseCode\x12\x06\n\x02OK\x10\x01\x12\x0c\n\x08\x43ONFLICT\x10\x02\"\xee\x01\n\x1aMutatePlaylistEntryRequest\x12-\n\x15\x63reate_playlist_entry\x18\x01 \x01(\x0b\x32\x0e.PlaylistEntry\x12-\n\x15update_playlist_entry\x18\x02 \x01(\x0b\x32\x0e.PlaylistEntry\x12-\n\x15\x64\x65lete_playlist_entry\x18\x03 \x01(\x0b\x32\x0e.PlaylistEntry\x12\"\n\x14update_last_modified\x18\x04 \x01(\x08:\x04true\x12\x1f\n\x17undelete_playlist_entry\x18\x05 \x01(\t\"\xe8\x01\n!BatchMutatePlaylistEntriesRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12<\n\x17playlist_entry_mutation\x18\x02 \x03(\x0b\x32\x1b.MutatePlaylistEntryRequest\x12\x1f\n\x11send_notification\x18\x03 \x01(\x08:\x04true\x12\'\n\x19\x64\x65tect_timestamp_conflict\x18\x04 \x01(\x08:\x04true\x12*\n\x1bnotify_fine_grained_updates\x18\x05 \x01(\x08:\x05\x66\x61lse\"\xf1\x01\n\"BatchMutatePlaylistEntriesResponse\x12\x61\n\rresponse_code\x18\x01 \x03(\x0e\x32J.BatchMutatePlaylistEntriesResponse.BatchMutatePlaylistEntriesResponseCode\x12(\n\x0fmutate_response\x18\x02 \x03(\x0b\x32\x0f.MutateResponse\">\n&BatchMutatePlaylistEntriesResponseCode\x12\x06\n\x02OK\x10\x01\x12\x0c\n\x08\x43ONFLICT\x10\x02\"\x90\x01\n\x11MagicPlaylistSeed\x12.\n\tseed_type\x18\x01 \x02(\x0e\x32\x1b.MagicPlaylistSeed.SeedType\x12\x0c\n\x04seed\x18\x02 \x02(\t\"=\n\x08SeedType\x12\t\n\x05TRACK\x10\x00\x12\n\n\x06\x41RTIST\x10\x01\x12\t\n\x05\x41LBUM\x10\x02\x12\x0f\n\x0bOPAQUE_SEED\x10\x03\"\xd1\x01\n\x14MagicPlaylistRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x15\n\rplaylist_name\x18\x02 \x01(\t\x12\x13\n\x0bplaylist_id\x18\x03 \x01(\t\x12 \n\x04seed\x18\x04 \x03(\x0b\x32\x12.MagicPlaylistSeed\x12\x1b\n\x13num_recommendations\x18\x05 \x01(\x05\x12)\n\x1ainclude_all_track_metadata\x18\x06 \x01(\x08:\x05\x66\x61lse\x12\x12\n\nmodel_name\x18\x07 \x01(\t\"\\\n\x15MagicPlaylistResponse\x12\x1b\n\x08playlist\x18\x01 \x01(\x0b\x32\t.Playlist\x12&\n\x0eplaylist_entry\x18\x02 \x03(\x0b\x32\x0e.PlaylistEntry\"\xf8\x01\n\x12\x46lushLockerRequest\x12\x0f\n\x07gaia_id\x18\x01 \x01(\x03\x12\x13\n\x0bgaia_cookie\x18\x02 \x01(\t\x12#\n\x15remove_audio_binaries\x18\x03 \x01(\x08:\x04true\x12#\n\x15remove_image_binaries\x18\x04 \x01(\x08:\x04true\x12\x1f\n\x11send_notification\x18\x05 \x01(\x08:\x04true\x12&\n\x17reset_subscription_type\x18\x06 \x01(\x08:\x05\x66\x61lse\x12)\n\x1bnotify_fine_grained_updates\x18\x08 \x01(\x08:\x04true\"\x8a\x01\n\x13\x46lushLockerResponse\x12\x16\n\x0etracks_removed\x18\x01 \x01(\x05\x12\x17\n\x0f\x65ntries_removed\x18\x02 \x01(\x05\x12\x19\n\x11playlists_removed\x18\x03 \x01(\x05\x12\'\n\x1fsuccess_reset_subscription_type\x18\x04 \x01(\x08\"6\n\x12LockerNotification\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x0f\n\x07payload\x18\x02 \x01(\x0c\"\xd6\x01\n\x05\x41lbum\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\x14\n\x0c\x61lbum_artist\x18\x02 \x01(\t\x12\x1c\n\talbum_art\x18\x03 \x01(\x0b\x32\t.ImageRef\x12\x13\n\x0btrack_count\x18\x04 \x01(\x05\x12\x18\n\x10last_time_played\x18\x05 \x01(\x03\x12\x16\n\x0eis_compilation\x18\x06 \x01(\x08\x12\x18\n\x10\x61lbum_metajam_id\x18\x07 \x01(\t\x12\x1a\n\x12\x63reation_timestamp\x18\x08 \x01(\x03\x12\x0e\n\x06\x61rtist\x18\t \x01(\t\"\xa3\x01\n\x0e\x41lbumSortOrder\x12\x31\n\tattribute\x18\x01 \x01(\x0e\x32\x1e.AlbumSortOrder.AlbumAttribute\x12\x19\n\ndescending\x18\x02 \x01(\x08:\x05\x66\x61lse\"C\n\x0e\x41lbumAttribute\x12\x14\n\x10LAST_PLAYED_TIME\x10\x01\x12\x08\n\x04NAME\x10\x02\x12\x11\n\rCREATION_TIME\x10\x03\"]\n\x10GetAlbumsRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12#\n\nsort_order\x18\x02 \x01(\x0b\x32\x0f.AlbumSortOrder\x12\x13\n\x0bmax_results\x18\x03 \x01(\x05\"*\n\x11GetAlbumsResponse\x12\x15\n\x05\x61lbum\x18\x01 \x03(\x0b\x32\x06.Album\"H\n\x06\x41rtist\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\x19\n\x11total_track_count\x18\x02 \x01(\x05\x12\x15\n\x05\x61lbum\x18\x03 \x03(\x0b\x32\x06.Album\",\n\x0f\x41rtistSortOrder\x12\x19\n\ndescending\x18\x02 \x01(\x08:\x05\x66\x61lse\"_\n\x11GetArtistsRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12$\n\nsort_order\x18\x02 \x01(\x0b\x32\x10.ArtistSortOrder\x12\x13\n\x0bmax_results\x18\x03 \x01(\x05\"-\n\x12GetArtistsResponse\x12\x17\n\x06\x61rtist\x18\x01 \x03(\x0b\x32\x07.Artist\"L\n\nMusicGenre\x12\x0c\n\x04name\x18\x01 \x01(\t\x12\x19\n\x11total_track_count\x18\x02 \x01(\x05\x12\x15\n\x05\x61lbum\x18\x03 \x03(\x0b\x32\x06.Album\"+\n\x0eGenreSortOrder\x12\x19\n\ndescending\x18\x02 \x01(\x08:\x05\x66\x61lse\"]\n\x10GetGenresRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12#\n\nsort_order\x18\x02 \x01(\x0b\x32\x0f.GenreSortOrder\x12\x13\n\x0bmax_results\x18\x03 \x01(\x05\"/\n\x11GetGenresResponse\x12\x1a\n\x05genre\x18\x01 \x03(\x0b\x32\x0b.MusicGenre\"\xe6\x02\n GetDynamicPlaylistEntriesRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12[\n\x15playlist_entries_type\x18\x04 \x02(\x0e\x32<.GetDynamicPlaylistEntriesRequest.DynamicPlaylistEntriesType\x12\x13\n\x0bmax_results\x18\x02 \x01(\x05\x12\x1a\n\x12\x63ontinuation_token\x18\x03 \x01(\t\x12)\n\x1ainclude_all_track_metadata\x18\x05 \x01(\x08:\x05\x66\x61lse\"x\n\x1a\x44ynamicPlaylistEntriesType\x12\r\n\tPURCHASED\x10\x01\x12\r\n\tTHUMBS_UP\x10\x02\x12\x12\n\x0eRECENTLY_ADDED\x10\x03\x12\x0c\n\x08PROMOTED\x10\x04\x12\x1a\n\x16PROMOTED_AND_PURCHASED\x10\x05\"\xda\x03\n!GetDynamicPlaylistEntriesResponse\x12\x46\n\rresponse_code\x18\x01 \x02(\x0e\x32/.GetDynamicPlaylistEntriesResponse.ResponseCode\x12&\n\x0eplaylist_entry\x18\x02 \x03(\x0b\x32\x0e.PlaylistEntry\x12\x1f\n\x17\x65stimated_total_results\x18\x03 \x01(\x03\x12\x1a\n\x12\x63ontinuation_token\x18\x04 \x01(\t\x12\\\n\x15playlist_entries_type\x18\x05 \x01(\x0e\x32=.GetDynamicPlaylistEntriesResponse.DynamicPlaylistEntriesType\"\x85\x01\n\x1a\x44ynamicPlaylistEntriesType\x12\r\n\tPURCHASED\x10\x01\x12\r\n\tTHUMBS_UP\x10\x02\x12\x12\n\x0eRECENTLY_ADDED\x10\x03\x12\x0c\n\x08PROMOTED\x10\x04\x12\x0b\n\x07UNKNOWN\x10\x05\x12\x1a\n\x16PROMOTED_AND_PURCHASED\x10\x06\"\"\n\x0cResponseCode\x12\x06\n\x02OK\x10\x01\x12\n\n\x06NOT_OK\x10\x02\"4\n!GetAggregationsByTrackTypeRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\"\xea\x01\n\x12TrackTypeAggregate\x12\x37\n\x10track_type_value\x18\x01 \x01(\x0e\x32\x1d.TrackTypeAggregate.TrackType\x12\r\n\x05\x63ount\x18\x02 \x01(\x05\"\x8b\x01\n\tTrackType\x12\x11\n\rMATCHED_TRACK\x10\x01\x12\x13\n\x0fUNMATCHED_TRACK\x10\x02\x12\x0f\n\x0bLOCAL_TRACK\x10\x03\x12\x13\n\x0fPURCHASED_TRACK\x10\x04\x12\x1f\n\x1bMETADATA_ONLY_MATCHED_TRACK\x10\x05\x12\x0f\n\x0bPROMO_TRACK\x10\x06\"W\n\"GetAggregationsByTrackTypeResponse\x12\x31\n\x14track_type_aggregate\x18\x01 \x03(\x0b\x32\x13.TrackTypeAggregate\"=\n*GetAggregationsByAvailabilityStatusRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\"\x83\x02\n\x1b\x41vailabilityStatusAggregate\x12L\n\x13\x61vailability_status\x18\x01 \x01(\x0e\x32/.AvailabilityStatusAggregate.AvailabilityStatus\x12\r\n\x05\x63ount\x18\x02 \x01(\x05\"\x86\x01\n\x12\x41vailabilityStatus\x12\x0b\n\x07PENDING\x10\x01\x12\x0b\n\x07MATCHED\x10\x02\x12\x14\n\x10UPLOAD_REQUESTED\x10\x03\x12\r\n\tAVAILABLE\x10\x04\x12\x12\n\x0e\x46ORCE_REUPLOAD\x10\x05\x12\x1d\n\x19UPLOAD_PERMANENTLY_FAILED\x10\x06\"r\n+GetAggregationsByAvailabilityStatusResponse\x12\x43\n\x1d\x61vailability_status_aggregate\x18\x01 \x03(\x0b\x32\x1c.AvailabilityStatusAggregate\"7\n\x15\x41\x64\x64PromoTracksRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\r\n\x05genre\x18\x02 \x03(\t\"/\n\x16\x41\x64\x64PromoTracksResponse\x12\x15\n\x05track\x18\x01 \x03(\x0b\x32\x06.Track\"J\n\x1eGetPlaylistAggregationsRequest\x12\x0f\n\x07gaia_id\x18\x01 \x02(\x03\x12\x17\n\x0bmax_results\x18\x02 \x01(\x05:\x02\x31\x34\"\x83\x01\n\x11PlaylistAggregate\x12\x13\n\x0bplaylist_id\x18\x01 \x01(\t\x12\x0c\n\x04name\x18\x02 \x01(\t\x12\x1c\n\talbum_art\x18\x03 \x01(\x0b\x32\t.ImageRef\x12\x13\n\x0btrack_count\x18\x04 \x01(\x03\x12\x18\n\x10last_time_played\x18\x05 \x01(\x03\"Q\n\x1fGetPlaylistAggregationsResponse\x12.\n\x12playlist_aggregate\x18\x01 \x03(\x0b\x32\x12.PlaylistAggregate\"?\n\x1bRemoteControlCommandRequest\x12\x0f\n\x07gaia_id\x18\x01 \x01(\x03\x12\x0f\n\x07\x63ommand\x18\x02 \x01(\t\"\xb3\x01\n\x1cRemoteControlCommandResponse\x12\x41\n\rresponse_code\x18\x01 \x01(\x0e\x32*.RemoteControlCommandResponse.ResponseCode\"P\n\x0cResponseCode\x12\x06\n\x02OK\x10\x01\x12\x10\n\x0cNO_PUBLISHER\x10\x02\x12\x13\n\x0fINVALID_REQUEST\x10\x03\x12\x11\n\rPUBLISH_ERROR\x10\x04')



_AUDIOREF_STORE = descriptor.EnumDescriptor(
  name='Store',
  full_name='AudioRef.Store',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='BLOBSTORE', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='SM_V2', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=244,
  serialized_end=277,
)

_IMAGEREF_STORE = descriptor.EnumDescriptor(
  name='Store',
  full_name='ImageRef.Store',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='SHOEBOX', index=0, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=434,
  serialized_end=454,
)

_IMAGEREF_ORIGIN = descriptor.EnumDescriptor(
  name='Origin',
  full_name='ImageRef.Origin',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='PERSONAL', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='STORE', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=456,
  serialized_end=489,
)

_TRACK_AVAILABILITYSTATUS = descriptor.EnumDescriptor(
  name='AvailabilityStatus',
  full_name='Track.AvailabilityStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='PENDING', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MATCHED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_REQUESTED', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='AVAILABLE', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FORCE_REUPLOAD', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_PERMANENTLY_FAILED', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2101,
  serialized_end=2235,
)

_TRACK_CONTENTTYPE = descriptor.EnumDescriptor(
  name='ContentType',
  full_name='Track.ContentType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='MP3', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='M4A', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='AAC', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FLAC', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='OGG', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WMA', index=5, number=6,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='M4P', index=6, number=7,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALAC', index=7, number=8,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2237,
  serialized_end=2324,
)

_TRACK_CHANNELS = descriptor.EnumDescriptor(
  name='Channels',
  full_name='Track.Channels',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='MONO', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='STEREO', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2326,
  serialized_end=2358,
)

_TRACK_TRACKTYPE = descriptor.EnumDescriptor(
  name='TrackType',
  full_name='Track.TrackType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='MATCHED_TRACK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UNMATCHED_TRACK', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='LOCAL_TRACK', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PURCHASED_TRACK', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='METADATA_ONLY_MATCHED_TRACK', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMO_TRACK', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2361,
  serialized_end=2500,
)

_TRACK_RATING = descriptor.EnumDescriptor(
  name='Rating',
  full_name='Track.Rating',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='NOT_RATED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ONE_STAR', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TWO_STARS', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='THREE_STARS', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FOUR_STARS', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FIVE_STARS', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2502,
  serialized_end=2603,
)

_PLAYLIST_PLAYLISTTYPE = descriptor.EnumDescriptor(
  name='PlaylistType',
  full_name='Playlist.PlaylistType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='USER_GENERATED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MAGIC', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMO', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2891,
  serialized_end=2947,
)

_PLAYLISTENTRY_RELATIVEPOSITIONIDTYPE = descriptor.EnumDescriptor(
  name='RelativePositionIdType',
  full_name='PlaylistEntry.RelativePositionIdType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='SERVER', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CLIENT', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=3332,
  serialized_end=3380,
)

_TRACKSEARCHRESTRICTION_TRACKATTRIBUTE = descriptor.EnumDescriptor(
  name='TrackAttribute',
  full_name='TrackSearchRestriction.TrackAttribute',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='TITLE', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ARTIST', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALBUM', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALBUM_ARTIST', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GENRE', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='AVAILABILITY_STATUS', index=5, number=6,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TRACK_TYPE', index=6, number=7,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='YEAR', index=7, number=8,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='STORE_ID', index=8, number=9,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALBUM_METAJAM_ID', index=9, number=10,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=3549,
  serialized_end=3715,
)

_TRACKSEARCHRESTRICTION_COMPARISONTYPE = descriptor.EnumDescriptor(
  name='ComparisonType',
  full_name='TrackSearchRestriction.ComparisonType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='EQUAL', index=0, number=0,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NOT_EQUAL', index=1, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GREATER_THAN', index=2, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GREATER_EQUAL', index=3, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='LESS_THAN', index=4, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='LESS_EQUAL', index=5, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PARTIAL_MATCH', index=6, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=3718,
  serialized_end=3847,
)

_TRACKSEARCHRESTRICTIONSET_RESTRICTIONSETTYPE = descriptor.EnumDescriptor(
  name='RestrictionSetType',
  full_name='TrackSearchRestrictionSet.RestrictionSetType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='AND', index=0, number=0,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='OR', index=1, number=1,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4031,
  serialized_end=4068,
)

_TRACKSORTORDER_TRACKATTRIBUTE = descriptor.EnumDescriptor(
  name='TrackAttribute',
  full_name='TrackSortOrder.TrackAttribute',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='LAST_MODIFIED_TIME', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ARTIST', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALBUM', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TITLE', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TRACK_NUMBER', index=4, number=6,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PLAY_COUNT', index=5, number=9,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='DURATION_MILLIS', index=6, number=10,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='RATING', index=7, number=11,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CREATION_TIME', index=8, number=12,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4167,
  serialized_end=4327,
)

_GETTRACKSREQUEST_TRACKPROJECTION = descriptor.EnumDescriptor(
  name='TrackProjection',
  full_name='GetTracksRequest.TrackProjection',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='FULL', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FRONTEND_VIEW', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4666,
  serialized_end=4712,
)

_GETTRACKSRESPONSE_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='GetTracksResponse.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NOT_MODIFIED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GONE', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4876,
  serialized_end=4926,
)

_GETPLAYLISTENTRIESRESPONSE_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='GetPlaylistEntriesResponse.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NOT_MODIFIED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GONE', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4876,
  serialized_end=4926,
)

_PLAYLISTSORTORDER_PLAYLISTATTRIBUTE = descriptor.EnumDescriptor(
  name='PlaylistAttribute',
  full_name='PlaylistSortOrder.PlaylistAttribute',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='LAST_MODIFIED_TIME', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TITLE', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CREATION_TIME', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='RECENT_TIMESTAMP', index=3, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=5538,
  serialized_end=5633,
)

_GETPLAYLISTSRESPONSE_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='GetPlaylistsResponse.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NOT_MODIFIED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GONE', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4876,
  serialized_end=4926,
)

_BATCHLOOKUPREQUEST_METADATATYPE = descriptor.EnumDescriptor(
  name='MetadataType',
  full_name='BatchLookupRequest.MetadataType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='TRACK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PLAYLIST', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PLAYLIST_ENTRY', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=6467,
  serialized_end=6526,
)

_MUTATERESPONSE_MUTATERESPONSECODE = descriptor.EnumDescriptor(
  name='MutateResponseCode',
  full_name='MutateResponse.MutateResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CONFLICT', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='INVALID_REQUEST', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='METADATA_TOO_LARGE', index=3, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=7047,
  serialized_end=7134,
)

_MUTATERESPONSE_AVAILABILITYSTATUS = descriptor.EnumDescriptor(
  name='AvailabilityStatus',
  full_name='MutateResponse.AvailabilityStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='PENDING', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MATCHED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_REQUESTED', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='AVAILABLE', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FORCE_REUPLOAD', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_PERMANENTLY_FAILED', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2101,
  serialized_end=2235,
)

_BATCHMUTATETRACKSRESPONSE_BATCHMUTATETRACKSRESPONSECODE = descriptor.EnumDescriptor(
  name='BatchMutateTracksResponseCode',
  full_name='BatchMutateTracksResponse.BatchMutateTracksResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CONFLICT', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=7634,
  serialized_end=7687,
)

_BATCHMUTATEPLAYLISTSRESPONSE_BATCHMUTATEPLAYLISTSRESPONSECODE = descriptor.EnumDescriptor(
  name='BatchMutatePlaylistsResponseCode',
  full_name='BatchMutatePlaylistsResponse.BatchMutatePlaylistsResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CONFLICT', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=8319,
  serialized_end=8375,
)

_BATCHMUTATEPLAYLISTENTRIESRESPONSE_BATCHMUTATEPLAYLISTENTRIESRESPONSECODE = descriptor.EnumDescriptor(
  name='BatchMutatePlaylistEntriesResponseCode',
  full_name='BatchMutatePlaylistEntriesResponse.BatchMutatePlaylistEntriesResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CONFLICT', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=9033,
  serialized_end=9095,
)

_MAGICPLAYLISTSEED_SEEDTYPE = descriptor.EnumDescriptor(
  name='SeedType',
  full_name='MagicPlaylistSeed.SeedType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='TRACK', index=0, number=0,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ARTIST', index=1, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALBUM', index=2, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='OPAQUE_SEED', index=3, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=9181,
  serialized_end=9242,
)

_ALBUMSORTORDER_ALBUMATTRIBUTE = descriptor.EnumDescriptor(
  name='AlbumAttribute',
  full_name='AlbumSortOrder.AlbumAttribute',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='LAST_PLAYED_TIME', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NAME', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CREATION_TIME', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=10312,
  serialized_end=10379,
)

_GETDYNAMICPLAYLISTENTRIESREQUEST_DYNAMICPLAYLISTENTRIESTYPE = descriptor.EnumDescriptor(
  name='DynamicPlaylistEntriesType',
  full_name='GetDynamicPlaylistEntriesRequest.DynamicPlaylistEntriesType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='PURCHASED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='THUMBS_UP', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='RECENTLY_ADDED', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMOTED', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMOTED_AND_PURCHASED', index=4, number=5,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=11290,
  serialized_end=11410,
)

_GETDYNAMICPLAYLISTENTRIESRESPONSE_DYNAMICPLAYLISTENTRIESTYPE = descriptor.EnumDescriptor(
  name='DynamicPlaylistEntriesType',
  full_name='GetDynamicPlaylistEntriesResponse.DynamicPlaylistEntriesType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='PURCHASED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='THUMBS_UP', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='RECENTLY_ADDED', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMOTED', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UNKNOWN', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMOTED_AND_PURCHASED', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=11718,
  serialized_end=11851,
)

_GETDYNAMICPLAYLISTENTRIESRESPONSE_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='GetDynamicPlaylistEntriesResponse.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NOT_OK', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=11853,
  serialized_end=11887,
)

_TRACKTYPEAGGREGATE_TRACKTYPE = descriptor.EnumDescriptor(
  name='TrackType',
  full_name='TrackTypeAggregate.TrackType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='MATCHED_TRACK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UNMATCHED_TRACK', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='LOCAL_TRACK', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PURCHASED_TRACK', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='METADATA_ONLY_MATCHED_TRACK', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PROMO_TRACK', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2361,
  serialized_end=2500,
)

_AVAILABILITYSTATUSAGGREGATE_AVAILABILITYSTATUS = descriptor.EnumDescriptor(
  name='AvailabilityStatus',
  full_name='AvailabilityStatusAggregate.AvailabilityStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='PENDING', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MATCHED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_REQUESTED', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='AVAILABLE', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='FORCE_REUPLOAD', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_PERMANENTLY_FAILED', index=5, number=6,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2101,
  serialized_end=2235,
)

_REMOTECONTROLCOMMANDRESPONSE_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='RemoteControlCommandResponse.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NO_PUBLISHER', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='INVALID_REQUEST', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PUBLISH_ERROR', index=3, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=13274,
  serialized_end=13354,
)


_AUDIOREF = descriptor.Descriptor(
  name='AudioRef',
  full_name='AudioRef',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='store', full_name='AudioRef.store', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='ref', full_name='AudioRef.ref', index=1,
      number=2, type=12, cpp_type=9, label=2,
      has_default_value=False, default_value="",
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='url', full_name='AudioRef.url', index=2,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='bit_rate', full_name='AudioRef.bit_rate', index=3,
      number=5, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sample_rate', full_name='AudioRef.sample_rate', index=4,
      number=6, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='downloadable', full_name='AudioRef.downloadable', index=5,
      number=7, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='duration_millis', full_name='AudioRef.duration_millis', index=6,
      number=8, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='rematch_timestamp', full_name='AudioRef.rematch_timestamp', index=7,
      number=9, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='invalid_due_to_wipeout', full_name='AudioRef.invalid_due_to_wipeout', index=8,
      number=10, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _AUDIOREF_STORE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=29,
  serialized_end=277,
)


_IMAGEREF = descriptor.Descriptor(
  name='ImageRef',
  full_name='ImageRef',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='store', full_name='ImageRef.store', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=3,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='width', full_name='ImageRef.width', index=1,
      number=2, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='height', full_name='ImageRef.height', index=2,
      number=3, type=13, cpp_type=3, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='url', full_name='ImageRef.url', index=3,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='invalid_due_to_wipeout', full_name='ImageRef.invalid_due_to_wipeout', index=4,
      number=7, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='origin', full_name='ImageRef.origin', index=5,
      number=8, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _IMAGEREF_STORE,
    _IMAGEREF_ORIGIN,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=280,
  serialized_end=489,
)


_UPLOADEDUITSID3TAG = descriptor.Descriptor(
  name='UploadedUitsId3Tag',
  full_name='UploadedUitsId3Tag',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='owner', full_name='UploadedUitsId3Tag.owner', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='data', full_name='UploadedUitsId3Tag.data', index=1,
      number=2, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value="",
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=491,
  serialized_end=540,
)


_TRACK = descriptor.Descriptor(
  name='Track',
  full_name='Track',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='id', full_name='Track.id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='Track.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='creation_timestamp', full_name='Track.creation_timestamp', index=2,
      number=3, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='last_modified_timestamp', full_name='Track.last_modified_timestamp', index=3,
      number=4, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='deleted', full_name='Track.deleted', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='title', full_name='Track.title', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='artist', full_name='Track.artist', index=6,
      number=7, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='artist_hash', full_name='Track.artist_hash', index=7,
      number=46, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='composer', full_name='Track.composer', index=8,
      number=8, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album', full_name='Track.album', index=9,
      number=9, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_artist', full_name='Track.album_artist', index=10,
      number=10, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='canonical_album', full_name='Track.canonical_album', index=11,
      number=56, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='canonical_artist', full_name='Track.canonical_artist', index=12,
      number=57, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='canonical_genre_album', full_name='Track.canonical_genre_album', index=13,
      number=58, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='year', full_name='Track.year', index=14,
      number=11, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='comment', full_name='Track.comment', index=15,
      number=12, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_number', full_name='Track.track_number', index=16,
      number=13, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='genre', full_name='Track.genre', index=17,
      number=14, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='duration_millis', full_name='Track.duration_millis', index=18,
      number=15, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='beats_per_minute', full_name='Track.beats_per_minute', index=19,
      number=16, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='original_bit_rate', full_name='Track.original_bit_rate', index=20,
      number=44, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='audio_ref', full_name='Track.audio_ref', index=21,
      number=17, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_art_ref', full_name='Track.album_art_ref', index=22,
      number=18, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='availability_status', full_name='Track.availability_status', index=23,
      number=19, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='play_count', full_name='Track.play_count', index=24,
      number=20, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='content_type', full_name='Track.content_type', index=25,
      number=25, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='total_track_count', full_name='Track.total_track_count', index=26,
      number=26, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='disc_number', full_name='Track.disc_number', index=27,
      number=27, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='total_disc_count', full_name='Track.total_disc_count', index=28,
      number=28, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='channels', full_name='Track.channels', index=29,
      number=29, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_type', full_name='Track.track_type', index=30,
      number=30, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='use_single_server_copy', full_name='Track.use_single_server_copy', index=31,
      number=59, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='rating', full_name='Track.rating', index=32,
      number=31, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='estimated_size', full_name='Track.estimated_size', index=33,
      number=32, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='store_id', full_name='Track.store_id', index=34,
      number=33, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='metajam_id', full_name='Track.metajam_id', index=35,
      number=34, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='metajam_id_confidence', full_name='Track.metajam_id_confidence', index=36,
      number=43, type=1, cpp_type=5, label=1,
      has_default_value=True, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uits', full_name='Track.uits', index=37,
      number=35, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uits_metadata', full_name='Track.uits_metadata', index=38,
      number=40, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='compilation', full_name='Track.compilation', index=39,
      number=36, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_date_added', full_name='Track.client_date_added', index=40,
      number=37, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='recent_timestamp', full_name='Track.recent_timestamp', index=41,
      number=38, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='do_not_rematch', full_name='Track.do_not_rematch', index=42,
      number=39, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='from_album_purchase', full_name='Track.from_album_purchase', index=43,
      number=41, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_metajam_id', full_name='Track.album_metajam_id', index=44,
      number=42, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='transaction_id', full_name='Track.transaction_id', index=45,
      number=45, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='debug_track', full_name='Track.debug_track', index=46,
      number=47, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='normalized_title', full_name='Track.normalized_title', index=47,
      number=48, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='normalized_artist', full_name='Track.normalized_artist', index=48,
      number=49, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='normalized_album', full_name='Track.normalized_album', index=49,
      number=50, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='normalized_album_artist', full_name='Track.normalized_album_artist', index=50,
      number=51, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='normalized_canonical_album', full_name='Track.normalized_canonical_album', index=51,
      number=54, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='normalized_canonical_artist', full_name='Track.normalized_canonical_artist', index=52,
      number=55, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='Track.uploader_id', index=53,
      number=52, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_album_id', full_name='Track.client_album_id', index=54,
      number=53, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='label_owner_code', full_name='Track.label_owner_code', index=55,
      number=60, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='original_content_type', full_name='Track.original_content_type', index=56,
      number=61, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploaded_uits', full_name='Track.uploaded_uits', index=57,
      number=71, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACK_AVAILABILITYSTATUS,
    _TRACK_CONTENTTYPE,
    _TRACK_CHANNELS,
    _TRACK_TRACKTYPE,
    _TRACK_RATING,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=543,
  serialized_end=2603,
)


_TRACKS = descriptor.Descriptor(
  name='Tracks',
  full_name='Tracks',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track', full_name='Tracks.track', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2605,
  serialized_end=2636,
)


_PLAYLIST = descriptor.Descriptor(
  name='Playlist',
  full_name='Playlist',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='id', full_name='Playlist.id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='Playlist.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='creation_timestamp', full_name='Playlist.creation_timestamp', index=2,
      number=3, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='last_modified_timestamp', full_name='Playlist.last_modified_timestamp', index=3,
      number=4, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='deleted', full_name='Playlist.deleted', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='name', full_name='Playlist.name', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_type', full_name='Playlist.playlist_type', index=6,
      number=7, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_art_ref', full_name='Playlist.playlist_art_ref', index=7,
      number=8, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='recent_timestamp', full_name='Playlist.recent_timestamp', index=8,
      number=9, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _PLAYLIST_PLAYLISTTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2639,
  serialized_end=2947,
)


_PLAYLISTENTRY = descriptor.Descriptor(
  name='PlaylistEntry',
  full_name='PlaylistEntry',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='playlist_id', full_name='PlaylistEntry.playlist_id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='absolute_position', full_name='PlaylistEntry.absolute_position', index=1,
      number=2, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='place_after_entry_id', full_name='PlaylistEntry.place_after_entry_id', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_id', full_name='PlaylistEntry.track_id', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='id', full_name='PlaylistEntry.id', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='PlaylistEntry.client_id', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='creation_timestamp', full_name='PlaylistEntry.creation_timestamp', index=6,
      number=7, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='last_modified_timestamp', full_name='PlaylistEntry.last_modified_timestamp', index=7,
      number=8, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='deleted', full_name='PlaylistEntry.deleted', index=8,
      number=9, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='relative_position_id_type', full_name='PlaylistEntry.relative_position_id_type', index=9,
      number=10, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track', full_name='PlaylistEntry.track', index=10,
      number=15, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='place_before_entry_id', full_name='PlaylistEntry.place_before_entry_id', index=11,
      number=16, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='string_position', full_name='PlaylistEntry.string_position', index=12,
      number=17, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _PLAYLISTENTRY_RELATIVEPOSITIONIDTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2950,
  serialized_end=3380,
)


_TRACKSEARCHRESTRICTION = descriptor.Descriptor(
  name='TrackSearchRestriction',
  full_name='TrackSearchRestriction',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='attribute', full_name='TrackSearchRestriction.attribute', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='value', full_name='TrackSearchRestriction.value', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='comparison_type', full_name='TrackSearchRestriction.comparison_type', index=2,
      number=3, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACKSEARCHRESTRICTION_TRACKATTRIBUTE,
    _TRACKSEARCHRESTRICTION_COMPARISONTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3383,
  serialized_end=3847,
)


_TRACKSEARCHRESTRICTIONSET = descriptor.Descriptor(
  name='TrackSearchRestrictionSet',
  full_name='TrackSearchRestrictionSet',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='type', full_name='TrackSearchRestrictionSet.type', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='restriction', full_name='TrackSearchRestrictionSet.restriction', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sub_set', full_name='TrackSearchRestrictionSet.sub_set', index=2,
      number=3, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACKSEARCHRESTRICTIONSET_RESTRICTIONSETTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3850,
  serialized_end=4068,
)


_TRACKSORTORDER = descriptor.Descriptor(
  name='TrackSortOrder',
  full_name='TrackSortOrder',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='attribute', full_name='TrackSortOrder.attribute', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='descending', full_name='TrackSortOrder.descending', index=1,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACKSORTORDER_TRACKATTRIBUTE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4071,
  serialized_end=4327,
)


_GETTRACKSREQUEST = descriptor.Descriptor(
  name='GetTracksRequest',
  full_name='GetTracksRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetTracksRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='updated_min', full_name='GetTracksRequest.updated_min', index=1,
      number=2, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_deleted', full_name='GetTracksRequest.include_deleted', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetTracksRequest.max_results', index=3,
      number=4, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetTracksRequest.continuation_token', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='search_restriction', full_name='GetTracksRequest.search_restriction', index=5,
      number=6, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sort_order', full_name='GetTracksRequest.sort_order', index=6,
      number=7, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='restriction_set', full_name='GetTracksRequest.restriction_set', index=7,
      number=8, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_projection', full_name='GetTracksRequest.track_projection', index=8,
      number=9, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETTRACKSREQUEST_TRACKPROJECTION,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4330,
  serialized_end=4712,
)


_GETTRACKSRESPONSE = descriptor.Descriptor(
  name='GetTracksResponse',
  full_name='GetTracksResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='GetTracksResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track', full_name='GetTracksResponse.track', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='estimated_total_results', full_name='GetTracksResponse.estimated_total_results', index=2,
      number=3, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetTracksResponse.continuation_token', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETTRACKSRESPONSE_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4715,
  serialized_end=4926,
)


_GETPLAYLISTENTRIESREQUEST = descriptor.Descriptor(
  name='GetPlaylistEntriesRequest',
  full_name='GetPlaylistEntriesRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetPlaylistEntriesRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='updated_min', full_name='GetPlaylistEntriesRequest.updated_min', index=1,
      number=2, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_deleted', full_name='GetPlaylistEntriesRequest.include_deleted', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetPlaylistEntriesRequest.max_results', index=3,
      number=4, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetPlaylistEntriesRequest.continuation_token', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_id_filter', full_name='GetPlaylistEntriesRequest.playlist_id_filter', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_all_track_metadata', full_name='GetPlaylistEntriesRequest.include_all_track_metadata', index=6,
      number=7, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='only_show_available_tracks', full_name='GetPlaylistEntriesRequest.only_show_available_tracks', index=7,
      number=8, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4929,
  serialized_end=5181,
)


_GETPLAYLISTENTRIESRESPONSE = descriptor.Descriptor(
  name='GetPlaylistEntriesResponse',
  full_name='GetPlaylistEntriesResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='GetPlaylistEntriesResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='GetPlaylistEntriesResponse.playlist_entry', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='estimated_total_results', full_name='GetPlaylistEntriesResponse.estimated_total_results', index=2,
      number=3, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetPlaylistEntriesResponse.continuation_token', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETPLAYLISTENTRIESRESPONSE_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=5184,
  serialized_end=5430,
)


_PLAYLISTSORTORDER = descriptor.Descriptor(
  name='PlaylistSortOrder',
  full_name='PlaylistSortOrder',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='attribute', full_name='PlaylistSortOrder.attribute', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='descending', full_name='PlaylistSortOrder.descending', index=1,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _PLAYLISTSORTORDER_PLAYLISTATTRIBUTE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=5433,
  serialized_end=5633,
)


_GETPLAYLISTSREQUEST = descriptor.Descriptor(
  name='GetPlaylistsRequest',
  full_name='GetPlaylistsRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetPlaylistsRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='updated_min', full_name='GetPlaylistsRequest.updated_min', index=1,
      number=2, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_deleted', full_name='GetPlaylistsRequest.include_deleted', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetPlaylistsRequest.max_results', index=3,
      number=4, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetPlaylistsRequest.continuation_token', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sort_order', full_name='GetPlaylistsRequest.sort_order', index=5,
      number=6, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=5636,
  serialized_end=5809,
)


_GETPLAYLISTSRESPONSE = descriptor.Descriptor(
  name='GetPlaylistsResponse',
  full_name='GetPlaylistsResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='GetPlaylistsResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist', full_name='GetPlaylistsResponse.playlist', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='estimated_total_results', full_name='GetPlaylistsResponse.estimated_total_results', index=2,
      number=3, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetPlaylistsResponse.continuation_token', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETPLAYLISTSRESPONSE_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=5812,
  serialized_end=6035,
)


_LOOKUPTRACKREQUEST = descriptor.Descriptor(
  name='LookupTrackRequest',
  full_name='LookupTrackRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='id', full_name='LookupTrackRequest.id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='LookupTrackRequest.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6037,
  serialized_end=6088,
)


_LOOKUPPLAYLISTENTRYREQUEST = descriptor.Descriptor(
  name='LookupPlaylistEntryRequest',
  full_name='LookupPlaylistEntryRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='id', full_name='LookupPlaylistEntryRequest.id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='LookupPlaylistEntryRequest.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6090,
  serialized_end=6149,
)


_LOOKUPPLAYLISTREQUEST = descriptor.Descriptor(
  name='LookupPlaylistRequest',
  full_name='LookupPlaylistRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='id', full_name='LookupPlaylistRequest.id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='LookupPlaylistRequest.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6151,
  serialized_end=6205,
)


_BATCHLOOKUPREQUEST = descriptor.Descriptor(
  name='BatchLookupRequest',
  full_name='BatchLookupRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='BatchLookupRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track', full_name='BatchLookupRequest.track', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist', full_name='BatchLookupRequest.playlist', index=2,
      number=3, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='metadata_type', full_name='BatchLookupRequest.metadata_type', index=3,
      number=4, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='BatchLookupRequest.playlist_entry', index=4,
      number=5, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_deleted', full_name='BatchLookupRequest.include_deleted', index=5,
      number=6, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _BATCHLOOKUPREQUEST_METADATATYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6208,
  serialized_end=6526,
)


_BATCHLOOKUPRESPONSE = descriptor.Descriptor(
  name='BatchLookupResponse',
  full_name='BatchLookupResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track', full_name='BatchLookupResponse.track', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist', full_name='BatchLookupResponse.playlist', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='BatchLookupResponse.playlist_entry', index=2,
      number=3, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6528,
  serialized_end=6641,
)


_MUTATETRACKREQUEST = descriptor.Descriptor(
  name='MutateTrackRequest',
  full_name='MutateTrackRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='create_track', full_name='MutateTrackRequest.create_track', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='update_track', full_name='MutateTrackRequest.update_track', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='delete_track', full_name='MutateTrackRequest.delete_track', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='partial_update', full_name='MutateTrackRequest.partial_update', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='update_last_modified', full_name='MutateTrackRequest.update_last_modified', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='undelete_track', full_name='MutateTrackRequest.undelete_track', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6644,
  serialized_end=6830,
)


_MUTATERESPONSE = descriptor.Descriptor(
  name='MutateResponse',
  full_name='MutateResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='MutateResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='id', full_name='MutateResponse.id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='child_id', full_name='MutateResponse.child_id', index=2,
      number=3, type=9, cpp_type=9, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='MutateResponse.client_id', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='availability_status', full_name='MutateResponse.availability_status', index=4,
      number=5, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='error_message', full_name='MutateResponse.error_message', index=5,
      number=6, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _MUTATERESPONSE_MUTATERESPONSECODE,
    _MUTATERESPONSE_AVAILABILITYSTATUS,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=6833,
  serialized_end=7271,
)


_BATCHMUTATETRACKSREQUEST = descriptor.Descriptor(
  name='BatchMutateTracksRequest',
  full_name='BatchMutateTracksRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='BatchMutateTracksRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_mutation', full_name='BatchMutateTracksRequest.track_mutation', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='send_notification', full_name='BatchMutateTracksRequest.send_notification', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='detect_timestamp_conflict', full_name='BatchMutateTracksRequest.detect_timestamp_conflict', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='notify_fine_grained_updates', full_name='BatchMutateTracksRequest.notify_fine_grained_updates', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=7274,
  serialized_end=7479,
)


_BATCHMUTATETRACKSRESPONSE = descriptor.Descriptor(
  name='BatchMutateTracksResponse',
  full_name='BatchMutateTracksResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='BatchMutateTracksResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='mutate_response', full_name='BatchMutateTracksResponse.mutate_response', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _BATCHMUTATETRACKSRESPONSE_BATCHMUTATETRACKSRESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=7482,
  serialized_end=7687,
)


_MUTATEPLAYLISTREQUEST = descriptor.Descriptor(
  name='MutatePlaylistRequest',
  full_name='MutatePlaylistRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='create_playlist', full_name='MutatePlaylistRequest.create_playlist', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='update_playlist', full_name='MutatePlaylistRequest.update_playlist', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='delete_playlist', full_name='MutatePlaylistRequest.delete_playlist', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='partial_update', full_name='MutatePlaylistRequest.partial_update', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='MutatePlaylistRequest.playlist_entry', index=4,
      number=5, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='update_last_modified', full_name='MutatePlaylistRequest.update_last_modified', index=5,
      number=6, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='undelete_playlist', full_name='MutatePlaylistRequest.undelete_playlist', index=6,
      number=7, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=7690,
  serialized_end=7937,
)


_BATCHMUTATEPLAYLISTSREQUEST = descriptor.Descriptor(
  name='BatchMutatePlaylistsRequest',
  full_name='BatchMutatePlaylistsRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='BatchMutatePlaylistsRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_mutation', full_name='BatchMutatePlaylistsRequest.playlist_mutation', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='send_notification', full_name='BatchMutatePlaylistsRequest.send_notification', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='detect_timestamp_conflict', full_name='BatchMutatePlaylistsRequest.detect_timestamp_conflict', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='notify_fine_grained_updates', full_name='BatchMutatePlaylistsRequest.notify_fine_grained_updates', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=7940,
  serialized_end=8155,
)


_BATCHMUTATEPLAYLISTSRESPONSE = descriptor.Descriptor(
  name='BatchMutatePlaylistsResponse',
  full_name='BatchMutatePlaylistsResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='BatchMutatePlaylistsResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='mutate_response', full_name='BatchMutatePlaylistsResponse.mutate_response', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _BATCHMUTATEPLAYLISTSRESPONSE_BATCHMUTATEPLAYLISTSRESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=8158,
  serialized_end=8375,
)


_MUTATEPLAYLISTENTRYREQUEST = descriptor.Descriptor(
  name='MutatePlaylistEntryRequest',
  full_name='MutatePlaylistEntryRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='create_playlist_entry', full_name='MutatePlaylistEntryRequest.create_playlist_entry', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='update_playlist_entry', full_name='MutatePlaylistEntryRequest.update_playlist_entry', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='delete_playlist_entry', full_name='MutatePlaylistEntryRequest.delete_playlist_entry', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='update_last_modified', full_name='MutatePlaylistEntryRequest.update_last_modified', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='undelete_playlist_entry', full_name='MutatePlaylistEntryRequest.undelete_playlist_entry', index=4,
      number=5, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=8378,
  serialized_end=8616,
)


_BATCHMUTATEPLAYLISTENTRIESREQUEST = descriptor.Descriptor(
  name='BatchMutatePlaylistEntriesRequest',
  full_name='BatchMutatePlaylistEntriesRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='BatchMutatePlaylistEntriesRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry_mutation', full_name='BatchMutatePlaylistEntriesRequest.playlist_entry_mutation', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='send_notification', full_name='BatchMutatePlaylistEntriesRequest.send_notification', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='detect_timestamp_conflict', full_name='BatchMutatePlaylistEntriesRequest.detect_timestamp_conflict', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='notify_fine_grained_updates', full_name='BatchMutatePlaylistEntriesRequest.notify_fine_grained_updates', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=8619,
  serialized_end=8851,
)


_BATCHMUTATEPLAYLISTENTRIESRESPONSE = descriptor.Descriptor(
  name='BatchMutatePlaylistEntriesResponse',
  full_name='BatchMutatePlaylistEntriesResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='BatchMutatePlaylistEntriesResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='mutate_response', full_name='BatchMutatePlaylistEntriesResponse.mutate_response', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _BATCHMUTATEPLAYLISTENTRIESRESPONSE_BATCHMUTATEPLAYLISTENTRIESRESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=8854,
  serialized_end=9095,
)


_MAGICPLAYLISTSEED = descriptor.Descriptor(
  name='MagicPlaylistSeed',
  full_name='MagicPlaylistSeed',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='seed_type', full_name='MagicPlaylistSeed.seed_type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='seed', full_name='MagicPlaylistSeed.seed', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _MAGICPLAYLISTSEED_SEEDTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9098,
  serialized_end=9242,
)


_MAGICPLAYLISTREQUEST = descriptor.Descriptor(
  name='MagicPlaylistRequest',
  full_name='MagicPlaylistRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='MagicPlaylistRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_name', full_name='MagicPlaylistRequest.playlist_name', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_id', full_name='MagicPlaylistRequest.playlist_id', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='seed', full_name='MagicPlaylistRequest.seed', index=3,
      number=4, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='num_recommendations', full_name='MagicPlaylistRequest.num_recommendations', index=4,
      number=5, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_all_track_metadata', full_name='MagicPlaylistRequest.include_all_track_metadata', index=5,
      number=6, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='model_name', full_name='MagicPlaylistRequest.model_name', index=6,
      number=7, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9245,
  serialized_end=9454,
)


_MAGICPLAYLISTRESPONSE = descriptor.Descriptor(
  name='MagicPlaylistResponse',
  full_name='MagicPlaylistResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='playlist', full_name='MagicPlaylistResponse.playlist', index=0,
      number=1, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='MagicPlaylistResponse.playlist_entry', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9456,
  serialized_end=9548,
)


_FLUSHLOCKERREQUEST = descriptor.Descriptor(
  name='FlushLockerRequest',
  full_name='FlushLockerRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='FlushLockerRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='gaia_cookie', full_name='FlushLockerRequest.gaia_cookie', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='remove_audio_binaries', full_name='FlushLockerRequest.remove_audio_binaries', index=2,
      number=3, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='remove_image_binaries', full_name='FlushLockerRequest.remove_image_binaries', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='send_notification', full_name='FlushLockerRequest.send_notification', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='reset_subscription_type', full_name='FlushLockerRequest.reset_subscription_type', index=5,
      number=6, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='notify_fine_grained_updates', full_name='FlushLockerRequest.notify_fine_grained_updates', index=6,
      number=8, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=True,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9551,
  serialized_end=9799,
)


_FLUSHLOCKERRESPONSE = descriptor.Descriptor(
  name='FlushLockerResponse',
  full_name='FlushLockerResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='tracks_removed', full_name='FlushLockerResponse.tracks_removed', index=0,
      number=1, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='entries_removed', full_name='FlushLockerResponse.entries_removed', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlists_removed', full_name='FlushLockerResponse.playlists_removed', index=2,
      number=3, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='success_reset_subscription_type', full_name='FlushLockerResponse.success_reset_subscription_type', index=3,
      number=4, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9802,
  serialized_end=9940,
)


_LOCKERNOTIFICATION = descriptor.Descriptor(
  name='LockerNotification',
  full_name='LockerNotification',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='LockerNotification.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='payload', full_name='LockerNotification.payload', index=1,
      number=2, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value="",
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9942,
  serialized_end=9996,
)


_ALBUM = descriptor.Descriptor(
  name='Album',
  full_name='Album',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='name', full_name='Album.name', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_artist', full_name='Album.album_artist', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_art', full_name='Album.album_art', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_count', full_name='Album.track_count', index=3,
      number=4, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='last_time_played', full_name='Album.last_time_played', index=4,
      number=5, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='is_compilation', full_name='Album.is_compilation', index=5,
      number=6, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_metajam_id', full_name='Album.album_metajam_id', index=6,
      number=7, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='creation_timestamp', full_name='Album.creation_timestamp', index=7,
      number=8, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='artist', full_name='Album.artist', index=8,
      number=9, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=9999,
  serialized_end=10213,
)


_ALBUMSORTORDER = descriptor.Descriptor(
  name='AlbumSortOrder',
  full_name='AlbumSortOrder',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='attribute', full_name='AlbumSortOrder.attribute', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='descending', full_name='AlbumSortOrder.descending', index=1,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _ALBUMSORTORDER_ALBUMATTRIBUTE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10216,
  serialized_end=10379,
)


_GETALBUMSREQUEST = descriptor.Descriptor(
  name='GetAlbumsRequest',
  full_name='GetAlbumsRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetAlbumsRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sort_order', full_name='GetAlbumsRequest.sort_order', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetAlbumsRequest.max_results', index=2,
      number=3, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10381,
  serialized_end=10474,
)


_GETALBUMSRESPONSE = descriptor.Descriptor(
  name='GetAlbumsResponse',
  full_name='GetAlbumsResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='album', full_name='GetAlbumsResponse.album', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10476,
  serialized_end=10518,
)


_ARTIST = descriptor.Descriptor(
  name='Artist',
  full_name='Artist',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='name', full_name='Artist.name', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='total_track_count', full_name='Artist.total_track_count', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album', full_name='Artist.album', index=2,
      number=3, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10520,
  serialized_end=10592,
)


_ARTISTSORTORDER = descriptor.Descriptor(
  name='ArtistSortOrder',
  full_name='ArtistSortOrder',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='descending', full_name='ArtistSortOrder.descending', index=0,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10594,
  serialized_end=10638,
)


_GETARTISTSREQUEST = descriptor.Descriptor(
  name='GetArtistsRequest',
  full_name='GetArtistsRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetArtistsRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sort_order', full_name='GetArtistsRequest.sort_order', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetArtistsRequest.max_results', index=2,
      number=3, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10640,
  serialized_end=10735,
)


_GETARTISTSRESPONSE = descriptor.Descriptor(
  name='GetArtistsResponse',
  full_name='GetArtistsResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='artist', full_name='GetArtistsResponse.artist', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10737,
  serialized_end=10782,
)


_MUSICGENRE = descriptor.Descriptor(
  name='MusicGenre',
  full_name='MusicGenre',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='name', full_name='MusicGenre.name', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='total_track_count', full_name='MusicGenre.total_track_count', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album', full_name='MusicGenre.album', index=2,
      number=3, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10784,
  serialized_end=10860,
)


_GENRESORTORDER = descriptor.Descriptor(
  name='GenreSortOrder',
  full_name='GenreSortOrder',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='descending', full_name='GenreSortOrder.descending', index=0,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10862,
  serialized_end=10905,
)


_GETGENRESREQUEST = descriptor.Descriptor(
  name='GetGenresRequest',
  full_name='GetGenresRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetGenresRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sort_order', full_name='GetGenresRequest.sort_order', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetGenresRequest.max_results', index=2,
      number=3, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=10907,
  serialized_end=11000,
)


_GETGENRESRESPONSE = descriptor.Descriptor(
  name='GetGenresResponse',
  full_name='GetGenresResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='genre', full_name='GetGenresResponse.genre', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=11002,
  serialized_end=11049,
)


_GETDYNAMICPLAYLISTENTRIESREQUEST = descriptor.Descriptor(
  name='GetDynamicPlaylistEntriesRequest',
  full_name='GetDynamicPlaylistEntriesRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetDynamicPlaylistEntriesRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entries_type', full_name='GetDynamicPlaylistEntriesRequest.playlist_entries_type', index=1,
      number=4, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetDynamicPlaylistEntriesRequest.max_results', index=2,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetDynamicPlaylistEntriesRequest.continuation_token', index=3,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='include_all_track_metadata', full_name='GetDynamicPlaylistEntriesRequest.include_all_track_metadata', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETDYNAMICPLAYLISTENTRIESREQUEST_DYNAMICPLAYLISTENTRIESTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=11052,
  serialized_end=11410,
)


_GETDYNAMICPLAYLISTENTRIESRESPONSE = descriptor.Descriptor(
  name='GetDynamicPlaylistEntriesResponse',
  full_name='GetDynamicPlaylistEntriesResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='GetDynamicPlaylistEntriesResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='GetDynamicPlaylistEntriesResponse.playlist_entry', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='estimated_total_results', full_name='GetDynamicPlaylistEntriesResponse.estimated_total_results', index=2,
      number=3, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='continuation_token', full_name='GetDynamicPlaylistEntriesResponse.continuation_token', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entries_type', full_name='GetDynamicPlaylistEntriesResponse.playlist_entries_type', index=4,
      number=5, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _GETDYNAMICPLAYLISTENTRIESRESPONSE_DYNAMICPLAYLISTENTRIESTYPE,
    _GETDYNAMICPLAYLISTENTRIESRESPONSE_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=11413,
  serialized_end=11887,
)


_GETAGGREGATIONSBYTRACKTYPEREQUEST = descriptor.Descriptor(
  name='GetAggregationsByTrackTypeRequest',
  full_name='GetAggregationsByTrackTypeRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetAggregationsByTrackTypeRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=11889,
  serialized_end=11941,
)


_TRACKTYPEAGGREGATE = descriptor.Descriptor(
  name='TrackTypeAggregate',
  full_name='TrackTypeAggregate',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track_type_value', full_name='TrackTypeAggregate.track_type_value', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='count', full_name='TrackTypeAggregate.count', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACKTYPEAGGREGATE_TRACKTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=11944,
  serialized_end=12178,
)


_GETAGGREGATIONSBYTRACKTYPERESPONSE = descriptor.Descriptor(
  name='GetAggregationsByTrackTypeResponse',
  full_name='GetAggregationsByTrackTypeResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track_type_aggregate', full_name='GetAggregationsByTrackTypeResponse.track_type_aggregate', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12180,
  serialized_end=12267,
)


_GETAGGREGATIONSBYAVAILABILITYSTATUSREQUEST = descriptor.Descriptor(
  name='GetAggregationsByAvailabilityStatusRequest',
  full_name='GetAggregationsByAvailabilityStatusRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetAggregationsByAvailabilityStatusRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12269,
  serialized_end=12330,
)


_AVAILABILITYSTATUSAGGREGATE = descriptor.Descriptor(
  name='AvailabilityStatusAggregate',
  full_name='AvailabilityStatusAggregate',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='availability_status', full_name='AvailabilityStatusAggregate.availability_status', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='count', full_name='AvailabilityStatusAggregate.count', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _AVAILABILITYSTATUSAGGREGATE_AVAILABILITYSTATUS,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12333,
  serialized_end=12592,
)


_GETAGGREGATIONSBYAVAILABILITYSTATUSRESPONSE = descriptor.Descriptor(
  name='GetAggregationsByAvailabilityStatusResponse',
  full_name='GetAggregationsByAvailabilityStatusResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='availability_status_aggregate', full_name='GetAggregationsByAvailabilityStatusResponse.availability_status_aggregate', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12594,
  serialized_end=12708,
)


_ADDPROMOTRACKSREQUEST = descriptor.Descriptor(
  name='AddPromoTracksRequest',
  full_name='AddPromoTracksRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='AddPromoTracksRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='genre', full_name='AddPromoTracksRequest.genre', index=1,
      number=2, type=9, cpp_type=9, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12710,
  serialized_end=12765,
)


_ADDPROMOTRACKSRESPONSE = descriptor.Descriptor(
  name='AddPromoTracksResponse',
  full_name='AddPromoTracksResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track', full_name='AddPromoTracksResponse.track', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12767,
  serialized_end=12814,
)


_GETPLAYLISTAGGREGATIONSREQUEST = descriptor.Descriptor(
  name='GetPlaylistAggregationsRequest',
  full_name='GetPlaylistAggregationsRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='GetPlaylistAggregationsRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='max_results', full_name='GetPlaylistAggregationsRequest.max_results', index=1,
      number=2, type=5, cpp_type=1, label=1,
      has_default_value=True, default_value=14,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12816,
  serialized_end=12890,
)


_PLAYLISTAGGREGATE = descriptor.Descriptor(
  name='PlaylistAggregate',
  full_name='PlaylistAggregate',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='playlist_id', full_name='PlaylistAggregate.playlist_id', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='name', full_name='PlaylistAggregate.name', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_art', full_name='PlaylistAggregate.album_art', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_count', full_name='PlaylistAggregate.track_count', index=3,
      number=4, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='last_time_played', full_name='PlaylistAggregate.last_time_played', index=4,
      number=5, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=12893,
  serialized_end=13024,
)


_GETPLAYLISTAGGREGATIONSRESPONSE = descriptor.Descriptor(
  name='GetPlaylistAggregationsResponse',
  full_name='GetPlaylistAggregationsResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='playlist_aggregate', full_name='GetPlaylistAggregationsResponse.playlist_aggregate', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=13026,
  serialized_end=13107,
)


_REMOTECONTROLCOMMANDREQUEST = descriptor.Descriptor(
  name='RemoteControlCommandRequest',
  full_name='RemoteControlCommandRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaia_id', full_name='RemoteControlCommandRequest.gaia_id', index=0,
      number=1, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='command', full_name='RemoteControlCommandRequest.command', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=13109,
  serialized_end=13172,
)


_REMOTECONTROLCOMMANDRESPONSE = descriptor.Descriptor(
  name='RemoteControlCommandResponse',
  full_name='RemoteControlCommandResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='RemoteControlCommandResponse.response_code', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _REMOTECONTROLCOMMANDRESPONSE_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=13175,
  serialized_end=13354,
)

_AUDIOREF.fields_by_name['store'].enum_type = _AUDIOREF_STORE
_AUDIOREF_STORE.containing_type = _AUDIOREF;
_IMAGEREF.fields_by_name['store'].enum_type = _IMAGEREF_STORE
_IMAGEREF.fields_by_name['origin'].enum_type = _IMAGEREF_ORIGIN
_IMAGEREF_STORE.containing_type = _IMAGEREF;
_IMAGEREF_ORIGIN.containing_type = _IMAGEREF;
_TRACK.fields_by_name['audio_ref'].message_type = _AUDIOREF
_TRACK.fields_by_name['album_art_ref'].message_type = _IMAGEREF
_TRACK.fields_by_name['availability_status'].enum_type = _TRACK_AVAILABILITYSTATUS
_TRACK.fields_by_name['content_type'].enum_type = _TRACK_CONTENTTYPE
_TRACK.fields_by_name['channels'].enum_type = _TRACK_CHANNELS
_TRACK.fields_by_name['track_type'].enum_type = _TRACK_TRACKTYPE
_TRACK.fields_by_name['rating'].enum_type = _TRACK_RATING
_TRACK.fields_by_name['uits_metadata'].message_type = uits_pb2._UITSMETADATA
_TRACK.fields_by_name['original_content_type'].enum_type = _TRACK_CONTENTTYPE
_TRACK.fields_by_name['uploaded_uits'].message_type = _UPLOADEDUITSID3TAG
_TRACK_AVAILABILITYSTATUS.containing_type = _TRACK;
_TRACK_CONTENTTYPE.containing_type = _TRACK;
_TRACK_CHANNELS.containing_type = _TRACK;
_TRACK_TRACKTYPE.containing_type = _TRACK;
_TRACK_RATING.containing_type = _TRACK;
_TRACKS.fields_by_name['track'].message_type = _TRACK
_PLAYLIST.fields_by_name['playlist_type'].enum_type = _PLAYLIST_PLAYLISTTYPE
_PLAYLIST.fields_by_name['playlist_art_ref'].message_type = _IMAGEREF
_PLAYLIST_PLAYLISTTYPE.containing_type = _PLAYLIST;
_PLAYLISTENTRY.fields_by_name['relative_position_id_type'].enum_type = _PLAYLISTENTRY_RELATIVEPOSITIONIDTYPE
_PLAYLISTENTRY.fields_by_name['track'].message_type = _TRACK
_PLAYLISTENTRY_RELATIVEPOSITIONIDTYPE.containing_type = _PLAYLISTENTRY;
_TRACKSEARCHRESTRICTION.fields_by_name['attribute'].enum_type = _TRACKSEARCHRESTRICTION_TRACKATTRIBUTE
_TRACKSEARCHRESTRICTION.fields_by_name['comparison_type'].enum_type = _TRACKSEARCHRESTRICTION_COMPARISONTYPE
_TRACKSEARCHRESTRICTION_TRACKATTRIBUTE.containing_type = _TRACKSEARCHRESTRICTION;
_TRACKSEARCHRESTRICTION_COMPARISONTYPE.containing_type = _TRACKSEARCHRESTRICTION;
_TRACKSEARCHRESTRICTIONSET.fields_by_name['type'].enum_type = _TRACKSEARCHRESTRICTIONSET_RESTRICTIONSETTYPE
_TRACKSEARCHRESTRICTIONSET.fields_by_name['restriction'].message_type = _TRACKSEARCHRESTRICTION
_TRACKSEARCHRESTRICTIONSET.fields_by_name['sub_set'].message_type = _TRACKSEARCHRESTRICTIONSET
_TRACKSEARCHRESTRICTIONSET_RESTRICTIONSETTYPE.containing_type = _TRACKSEARCHRESTRICTIONSET;
_TRACKSORTORDER.fields_by_name['attribute'].enum_type = _TRACKSORTORDER_TRACKATTRIBUTE
_TRACKSORTORDER_TRACKATTRIBUTE.containing_type = _TRACKSORTORDER;
_GETTRACKSREQUEST.fields_by_name['search_restriction'].message_type = _TRACKSEARCHRESTRICTION
_GETTRACKSREQUEST.fields_by_name['sort_order'].message_type = _TRACKSORTORDER
_GETTRACKSREQUEST.fields_by_name['restriction_set'].message_type = _TRACKSEARCHRESTRICTIONSET
_GETTRACKSREQUEST.fields_by_name['track_projection'].enum_type = _GETTRACKSREQUEST_TRACKPROJECTION
_GETTRACKSREQUEST_TRACKPROJECTION.containing_type = _GETTRACKSREQUEST;
_GETTRACKSRESPONSE.fields_by_name['response_code'].enum_type = _GETTRACKSRESPONSE_RESPONSECODE
_GETTRACKSRESPONSE.fields_by_name['track'].message_type = _TRACK
_GETTRACKSRESPONSE_RESPONSECODE.containing_type = _GETTRACKSRESPONSE;
_GETPLAYLISTENTRIESRESPONSE.fields_by_name['response_code'].enum_type = _GETPLAYLISTENTRIESRESPONSE_RESPONSECODE
_GETPLAYLISTENTRIESRESPONSE.fields_by_name['playlist_entry'].message_type = _PLAYLISTENTRY
_GETPLAYLISTENTRIESRESPONSE_RESPONSECODE.containing_type = _GETPLAYLISTENTRIESRESPONSE;
_PLAYLISTSORTORDER.fields_by_name['attribute'].enum_type = _PLAYLISTSORTORDER_PLAYLISTATTRIBUTE
_PLAYLISTSORTORDER_PLAYLISTATTRIBUTE.containing_type = _PLAYLISTSORTORDER;
_GETPLAYLISTSREQUEST.fields_by_name['sort_order'].message_type = _PLAYLISTSORTORDER
_GETPLAYLISTSRESPONSE.fields_by_name['response_code'].enum_type = _GETPLAYLISTSRESPONSE_RESPONSECODE
_GETPLAYLISTSRESPONSE.fields_by_name['playlist'].message_type = _PLAYLIST
_GETPLAYLISTSRESPONSE_RESPONSECODE.containing_type = _GETPLAYLISTSRESPONSE;
_BATCHLOOKUPREQUEST.fields_by_name['track'].message_type = _LOOKUPTRACKREQUEST
_BATCHLOOKUPREQUEST.fields_by_name['playlist'].message_type = _LOOKUPPLAYLISTREQUEST
_BATCHLOOKUPREQUEST.fields_by_name['metadata_type'].enum_type = _BATCHLOOKUPREQUEST_METADATATYPE
_BATCHLOOKUPREQUEST.fields_by_name['playlist_entry'].message_type = _LOOKUPPLAYLISTENTRYREQUEST
_BATCHLOOKUPREQUEST_METADATATYPE.containing_type = _BATCHLOOKUPREQUEST;
_BATCHLOOKUPRESPONSE.fields_by_name['track'].message_type = _TRACK
_BATCHLOOKUPRESPONSE.fields_by_name['playlist'].message_type = _PLAYLIST
_BATCHLOOKUPRESPONSE.fields_by_name['playlist_entry'].message_type = _PLAYLISTENTRY
_MUTATETRACKREQUEST.fields_by_name['create_track'].message_type = _TRACK
_MUTATETRACKREQUEST.fields_by_name['update_track'].message_type = _TRACK
_MUTATERESPONSE.fields_by_name['response_code'].enum_type = _MUTATERESPONSE_MUTATERESPONSECODE
_MUTATERESPONSE.fields_by_name['availability_status'].enum_type = _MUTATERESPONSE_AVAILABILITYSTATUS
_MUTATERESPONSE_MUTATERESPONSECODE.containing_type = _MUTATERESPONSE;
_MUTATERESPONSE_AVAILABILITYSTATUS.containing_type = _MUTATERESPONSE;
_BATCHMUTATETRACKSREQUEST.fields_by_name['track_mutation'].message_type = _MUTATETRACKREQUEST
_BATCHMUTATETRACKSRESPONSE.fields_by_name['response_code'].enum_type = _BATCHMUTATETRACKSRESPONSE_BATCHMUTATETRACKSRESPONSECODE
_BATCHMUTATETRACKSRESPONSE.fields_by_name['mutate_response'].message_type = _MUTATERESPONSE
_BATCHMUTATETRACKSRESPONSE_BATCHMUTATETRACKSRESPONSECODE.containing_type = _BATCHMUTATETRACKSRESPONSE;
_MUTATEPLAYLISTREQUEST.fields_by_name['create_playlist'].message_type = _PLAYLIST
_MUTATEPLAYLISTREQUEST.fields_by_name['update_playlist'].message_type = _PLAYLIST
_MUTATEPLAYLISTREQUEST.fields_by_name['playlist_entry'].message_type = _PLAYLISTENTRY
_BATCHMUTATEPLAYLISTSREQUEST.fields_by_name['playlist_mutation'].message_type = _MUTATEPLAYLISTREQUEST
_BATCHMUTATEPLAYLISTSRESPONSE.fields_by_name['response_code'].enum_type = _BATCHMUTATEPLAYLISTSRESPONSE_BATCHMUTATEPLAYLISTSRESPONSECODE
_BATCHMUTATEPLAYLISTSRESPONSE.fields_by_name['mutate_response'].message_type = _MUTATERESPONSE
_BATCHMUTATEPLAYLISTSRESPONSE_BATCHMUTATEPLAYLISTSRESPONSECODE.containing_type = _BATCHMUTATEPLAYLISTSRESPONSE;
_MUTATEPLAYLISTENTRYREQUEST.fields_by_name['create_playlist_entry'].message_type = _PLAYLISTENTRY
_MUTATEPLAYLISTENTRYREQUEST.fields_by_name['update_playlist_entry'].message_type = _PLAYLISTENTRY
_MUTATEPLAYLISTENTRYREQUEST.fields_by_name['delete_playlist_entry'].message_type = _PLAYLISTENTRY
_BATCHMUTATEPLAYLISTENTRIESREQUEST.fields_by_name['playlist_entry_mutation'].message_type = _MUTATEPLAYLISTENTRYREQUEST
_BATCHMUTATEPLAYLISTENTRIESRESPONSE.fields_by_name['response_code'].enum_type = _BATCHMUTATEPLAYLISTENTRIESRESPONSE_BATCHMUTATEPLAYLISTENTRIESRESPONSECODE
_BATCHMUTATEPLAYLISTENTRIESRESPONSE.fields_by_name['mutate_response'].message_type = _MUTATERESPONSE
_BATCHMUTATEPLAYLISTENTRIESRESPONSE_BATCHMUTATEPLAYLISTENTRIESRESPONSECODE.containing_type = _BATCHMUTATEPLAYLISTENTRIESRESPONSE;
_MAGICPLAYLISTSEED.fields_by_name['seed_type'].enum_type = _MAGICPLAYLISTSEED_SEEDTYPE
_MAGICPLAYLISTSEED_SEEDTYPE.containing_type = _MAGICPLAYLISTSEED;
_MAGICPLAYLISTREQUEST.fields_by_name['seed'].message_type = _MAGICPLAYLISTSEED
_MAGICPLAYLISTRESPONSE.fields_by_name['playlist'].message_type = _PLAYLIST
_MAGICPLAYLISTRESPONSE.fields_by_name['playlist_entry'].message_type = _PLAYLISTENTRY
_ALBUM.fields_by_name['album_art'].message_type = _IMAGEREF
_ALBUMSORTORDER.fields_by_name['attribute'].enum_type = _ALBUMSORTORDER_ALBUMATTRIBUTE
_ALBUMSORTORDER_ALBUMATTRIBUTE.containing_type = _ALBUMSORTORDER;
_GETALBUMSREQUEST.fields_by_name['sort_order'].message_type = _ALBUMSORTORDER
_GETALBUMSRESPONSE.fields_by_name['album'].message_type = _ALBUM
_ARTIST.fields_by_name['album'].message_type = _ALBUM
_GETARTISTSREQUEST.fields_by_name['sort_order'].message_type = _ARTISTSORTORDER
_GETARTISTSRESPONSE.fields_by_name['artist'].message_type = _ARTIST
_MUSICGENRE.fields_by_name['album'].message_type = _ALBUM
_GETGENRESREQUEST.fields_by_name['sort_order'].message_type = _GENRESORTORDER
_GETGENRESRESPONSE.fields_by_name['genre'].message_type = _MUSICGENRE
_GETDYNAMICPLAYLISTENTRIESREQUEST.fields_by_name['playlist_entries_type'].enum_type = _GETDYNAMICPLAYLISTENTRIESREQUEST_DYNAMICPLAYLISTENTRIESTYPE
_GETDYNAMICPLAYLISTENTRIESREQUEST_DYNAMICPLAYLISTENTRIESTYPE.containing_type = _GETDYNAMICPLAYLISTENTRIESREQUEST;
_GETDYNAMICPLAYLISTENTRIESRESPONSE.fields_by_name['response_code'].enum_type = _GETDYNAMICPLAYLISTENTRIESRESPONSE_RESPONSECODE
_GETDYNAMICPLAYLISTENTRIESRESPONSE.fields_by_name['playlist_entry'].message_type = _PLAYLISTENTRY
_GETDYNAMICPLAYLISTENTRIESRESPONSE.fields_by_name['playlist_entries_type'].enum_type = _GETDYNAMICPLAYLISTENTRIESRESPONSE_DYNAMICPLAYLISTENTRIESTYPE
_GETDYNAMICPLAYLISTENTRIESRESPONSE_DYNAMICPLAYLISTENTRIESTYPE.containing_type = _GETDYNAMICPLAYLISTENTRIESRESPONSE;
_GETDYNAMICPLAYLISTENTRIESRESPONSE_RESPONSECODE.containing_type = _GETDYNAMICPLAYLISTENTRIESRESPONSE;
_TRACKTYPEAGGREGATE.fields_by_name['track_type_value'].enum_type = _TRACKTYPEAGGREGATE_TRACKTYPE
_TRACKTYPEAGGREGATE_TRACKTYPE.containing_type = _TRACKTYPEAGGREGATE;
_GETAGGREGATIONSBYTRACKTYPERESPONSE.fields_by_name['track_type_aggregate'].message_type = _TRACKTYPEAGGREGATE
_AVAILABILITYSTATUSAGGREGATE.fields_by_name['availability_status'].enum_type = _AVAILABILITYSTATUSAGGREGATE_AVAILABILITYSTATUS
_AVAILABILITYSTATUSAGGREGATE_AVAILABILITYSTATUS.containing_type = _AVAILABILITYSTATUSAGGREGATE;
_GETAGGREGATIONSBYAVAILABILITYSTATUSRESPONSE.fields_by_name['availability_status_aggregate'].message_type = _AVAILABILITYSTATUSAGGREGATE
_ADDPROMOTRACKSRESPONSE.fields_by_name['track'].message_type = _TRACK
_PLAYLISTAGGREGATE.fields_by_name['album_art'].message_type = _IMAGEREF
_GETPLAYLISTAGGREGATIONSRESPONSE.fields_by_name['playlist_aggregate'].message_type = _PLAYLISTAGGREGATE
_REMOTECONTROLCOMMANDRESPONSE.fields_by_name['response_code'].enum_type = _REMOTECONTROLCOMMANDRESPONSE_RESPONSECODE
_REMOTECONTROLCOMMANDRESPONSE_RESPONSECODE.containing_type = _REMOTECONTROLCOMMANDRESPONSE;
DESCRIPTOR.message_types_by_name['AudioRef'] = _AUDIOREF
DESCRIPTOR.message_types_by_name['ImageRef'] = _IMAGEREF
DESCRIPTOR.message_types_by_name['UploadedUitsId3Tag'] = _UPLOADEDUITSID3TAG
DESCRIPTOR.message_types_by_name['Track'] = _TRACK
DESCRIPTOR.message_types_by_name['Tracks'] = _TRACKS
DESCRIPTOR.message_types_by_name['Playlist'] = _PLAYLIST
DESCRIPTOR.message_types_by_name['PlaylistEntry'] = _PLAYLISTENTRY
DESCRIPTOR.message_types_by_name['TrackSearchRestriction'] = _TRACKSEARCHRESTRICTION
DESCRIPTOR.message_types_by_name['TrackSearchRestrictionSet'] = _TRACKSEARCHRESTRICTIONSET
DESCRIPTOR.message_types_by_name['TrackSortOrder'] = _TRACKSORTORDER
DESCRIPTOR.message_types_by_name['GetTracksRequest'] = _GETTRACKSREQUEST
DESCRIPTOR.message_types_by_name['GetTracksResponse'] = _GETTRACKSRESPONSE
DESCRIPTOR.message_types_by_name['GetPlaylistEntriesRequest'] = _GETPLAYLISTENTRIESREQUEST
DESCRIPTOR.message_types_by_name['GetPlaylistEntriesResponse'] = _GETPLAYLISTENTRIESRESPONSE
DESCRIPTOR.message_types_by_name['PlaylistSortOrder'] = _PLAYLISTSORTORDER
DESCRIPTOR.message_types_by_name['GetPlaylistsRequest'] = _GETPLAYLISTSREQUEST
DESCRIPTOR.message_types_by_name['GetPlaylistsResponse'] = _GETPLAYLISTSRESPONSE
DESCRIPTOR.message_types_by_name['LookupTrackRequest'] = _LOOKUPTRACKREQUEST
DESCRIPTOR.message_types_by_name['LookupPlaylistEntryRequest'] = _LOOKUPPLAYLISTENTRYREQUEST
DESCRIPTOR.message_types_by_name['LookupPlaylistRequest'] = _LOOKUPPLAYLISTREQUEST
DESCRIPTOR.message_types_by_name['BatchLookupRequest'] = _BATCHLOOKUPREQUEST
DESCRIPTOR.message_types_by_name['BatchLookupResponse'] = _BATCHLOOKUPRESPONSE
DESCRIPTOR.message_types_by_name['MutateTrackRequest'] = _MUTATETRACKREQUEST
DESCRIPTOR.message_types_by_name['MutateResponse'] = _MUTATERESPONSE
DESCRIPTOR.message_types_by_name['BatchMutateTracksRequest'] = _BATCHMUTATETRACKSREQUEST
DESCRIPTOR.message_types_by_name['BatchMutateTracksResponse'] = _BATCHMUTATETRACKSRESPONSE
DESCRIPTOR.message_types_by_name['MutatePlaylistRequest'] = _MUTATEPLAYLISTREQUEST
DESCRIPTOR.message_types_by_name['BatchMutatePlaylistsRequest'] = _BATCHMUTATEPLAYLISTSREQUEST
DESCRIPTOR.message_types_by_name['BatchMutatePlaylistsResponse'] = _BATCHMUTATEPLAYLISTSRESPONSE
DESCRIPTOR.message_types_by_name['MutatePlaylistEntryRequest'] = _MUTATEPLAYLISTENTRYREQUEST
DESCRIPTOR.message_types_by_name['BatchMutatePlaylistEntriesRequest'] = _BATCHMUTATEPLAYLISTENTRIESREQUEST
DESCRIPTOR.message_types_by_name['BatchMutatePlaylistEntriesResponse'] = _BATCHMUTATEPLAYLISTENTRIESRESPONSE
DESCRIPTOR.message_types_by_name['MagicPlaylistSeed'] = _MAGICPLAYLISTSEED
DESCRIPTOR.message_types_by_name['MagicPlaylistRequest'] = _MAGICPLAYLISTREQUEST
DESCRIPTOR.message_types_by_name['MagicPlaylistResponse'] = _MAGICPLAYLISTRESPONSE
DESCRIPTOR.message_types_by_name['FlushLockerRequest'] = _FLUSHLOCKERREQUEST
DESCRIPTOR.message_types_by_name['FlushLockerResponse'] = _FLUSHLOCKERRESPONSE
DESCRIPTOR.message_types_by_name['LockerNotification'] = _LOCKERNOTIFICATION
DESCRIPTOR.message_types_by_name['Album'] = _ALBUM
DESCRIPTOR.message_types_by_name['AlbumSortOrder'] = _ALBUMSORTORDER
DESCRIPTOR.message_types_by_name['GetAlbumsRequest'] = _GETALBUMSREQUEST
DESCRIPTOR.message_types_by_name['GetAlbumsResponse'] = _GETALBUMSRESPONSE
DESCRIPTOR.message_types_by_name['Artist'] = _ARTIST
DESCRIPTOR.message_types_by_name['ArtistSortOrder'] = _ARTISTSORTORDER
DESCRIPTOR.message_types_by_name['GetArtistsRequest'] = _GETARTISTSREQUEST
DESCRIPTOR.message_types_by_name['GetArtistsResponse'] = _GETARTISTSRESPONSE
DESCRIPTOR.message_types_by_name['MusicGenre'] = _MUSICGENRE
DESCRIPTOR.message_types_by_name['GenreSortOrder'] = _GENRESORTORDER
DESCRIPTOR.message_types_by_name['GetGenresRequest'] = _GETGENRESREQUEST
DESCRIPTOR.message_types_by_name['GetGenresResponse'] = _GETGENRESRESPONSE
DESCRIPTOR.message_types_by_name['GetDynamicPlaylistEntriesRequest'] = _GETDYNAMICPLAYLISTENTRIESREQUEST
DESCRIPTOR.message_types_by_name['GetDynamicPlaylistEntriesResponse'] = _GETDYNAMICPLAYLISTENTRIESRESPONSE
DESCRIPTOR.message_types_by_name['GetAggregationsByTrackTypeRequest'] = _GETAGGREGATIONSBYTRACKTYPEREQUEST
DESCRIPTOR.message_types_by_name['TrackTypeAggregate'] = _TRACKTYPEAGGREGATE
DESCRIPTOR.message_types_by_name['GetAggregationsByTrackTypeResponse'] = _GETAGGREGATIONSBYTRACKTYPERESPONSE
DESCRIPTOR.message_types_by_name['GetAggregationsByAvailabilityStatusRequest'] = _GETAGGREGATIONSBYAVAILABILITYSTATUSREQUEST
DESCRIPTOR.message_types_by_name['AvailabilityStatusAggregate'] = _AVAILABILITYSTATUSAGGREGATE
DESCRIPTOR.message_types_by_name['GetAggregationsByAvailabilityStatusResponse'] = _GETAGGREGATIONSBYAVAILABILITYSTATUSRESPONSE
DESCRIPTOR.message_types_by_name['AddPromoTracksRequest'] = _ADDPROMOTRACKSREQUEST
DESCRIPTOR.message_types_by_name['AddPromoTracksResponse'] = _ADDPROMOTRACKSRESPONSE
DESCRIPTOR.message_types_by_name['GetPlaylistAggregationsRequest'] = _GETPLAYLISTAGGREGATIONSREQUEST
DESCRIPTOR.message_types_by_name['PlaylistAggregate'] = _PLAYLISTAGGREGATE
DESCRIPTOR.message_types_by_name['GetPlaylistAggregationsResponse'] = _GETPLAYLISTAGGREGATIONSRESPONSE
DESCRIPTOR.message_types_by_name['RemoteControlCommandRequest'] = _REMOTECONTROLCOMMANDREQUEST
DESCRIPTOR.message_types_by_name['RemoteControlCommandResponse'] = _REMOTECONTROLCOMMANDRESPONSE

class AudioRef(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _AUDIOREF
  
  # @@protoc_insertion_point(class_scope:AudioRef)

class ImageRef(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _IMAGEREF
  
  # @@protoc_insertion_point(class_scope:ImageRef)

class UploadedUitsId3Tag(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADEDUITSID3TAG
  
  # @@protoc_insertion_point(class_scope:UploadedUitsId3Tag)

class Track(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACK
  
  # @@protoc_insertion_point(class_scope:Track)

class Tracks(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKS
  
  # @@protoc_insertion_point(class_scope:Tracks)

class Playlist(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PLAYLIST
  
  # @@protoc_insertion_point(class_scope:Playlist)

class PlaylistEntry(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PLAYLISTENTRY
  
  # @@protoc_insertion_point(class_scope:PlaylistEntry)

class TrackSearchRestriction(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKSEARCHRESTRICTION
  
  # @@protoc_insertion_point(class_scope:TrackSearchRestriction)

class TrackSearchRestrictionSet(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKSEARCHRESTRICTIONSET
  
  # @@protoc_insertion_point(class_scope:TrackSearchRestrictionSet)

class TrackSortOrder(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKSORTORDER
  
  # @@protoc_insertion_point(class_scope:TrackSortOrder)

class GetTracksRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETTRACKSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetTracksRequest)

class GetTracksResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETTRACKSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetTracksResponse)

class GetPlaylistEntriesRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETPLAYLISTENTRIESREQUEST
  
  # @@protoc_insertion_point(class_scope:GetPlaylistEntriesRequest)

class GetPlaylistEntriesResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETPLAYLISTENTRIESRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetPlaylistEntriesResponse)

class PlaylistSortOrder(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PLAYLISTSORTORDER
  
  # @@protoc_insertion_point(class_scope:PlaylistSortOrder)

class GetPlaylistsRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETPLAYLISTSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetPlaylistsRequest)

class GetPlaylistsResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETPLAYLISTSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetPlaylistsResponse)

class LookupTrackRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _LOOKUPTRACKREQUEST
  
  # @@protoc_insertion_point(class_scope:LookupTrackRequest)

class LookupPlaylistEntryRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _LOOKUPPLAYLISTENTRYREQUEST
  
  # @@protoc_insertion_point(class_scope:LookupPlaylistEntryRequest)

class LookupPlaylistRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _LOOKUPPLAYLISTREQUEST
  
  # @@protoc_insertion_point(class_scope:LookupPlaylistRequest)

class BatchLookupRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHLOOKUPREQUEST
  
  # @@protoc_insertion_point(class_scope:BatchLookupRequest)

class BatchLookupResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHLOOKUPRESPONSE
  
  # @@protoc_insertion_point(class_scope:BatchLookupResponse)

class MutateTrackRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MUTATETRACKREQUEST
  
  # @@protoc_insertion_point(class_scope:MutateTrackRequest)

class MutateResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MUTATERESPONSE
  
  # @@protoc_insertion_point(class_scope:MutateResponse)

class BatchMutateTracksRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHMUTATETRACKSREQUEST
  
  # @@protoc_insertion_point(class_scope:BatchMutateTracksRequest)

class BatchMutateTracksResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHMUTATETRACKSRESPONSE
  
  # @@protoc_insertion_point(class_scope:BatchMutateTracksResponse)

class MutatePlaylistRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MUTATEPLAYLISTREQUEST
  
  # @@protoc_insertion_point(class_scope:MutatePlaylistRequest)

class BatchMutatePlaylistsRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHMUTATEPLAYLISTSREQUEST
  
  # @@protoc_insertion_point(class_scope:BatchMutatePlaylistsRequest)

class BatchMutatePlaylistsResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHMUTATEPLAYLISTSRESPONSE
  
  # @@protoc_insertion_point(class_scope:BatchMutatePlaylistsResponse)

class MutatePlaylistEntryRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MUTATEPLAYLISTENTRYREQUEST
  
  # @@protoc_insertion_point(class_scope:MutatePlaylistEntryRequest)

class BatchMutatePlaylistEntriesRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHMUTATEPLAYLISTENTRIESREQUEST
  
  # @@protoc_insertion_point(class_scope:BatchMutatePlaylistEntriesRequest)

class BatchMutatePlaylistEntriesResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _BATCHMUTATEPLAYLISTENTRIESRESPONSE
  
  # @@protoc_insertion_point(class_scope:BatchMutatePlaylistEntriesResponse)

class MagicPlaylistSeed(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MAGICPLAYLISTSEED
  
  # @@protoc_insertion_point(class_scope:MagicPlaylistSeed)

class MagicPlaylistRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MAGICPLAYLISTREQUEST
  
  # @@protoc_insertion_point(class_scope:MagicPlaylistRequest)

class MagicPlaylistResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MAGICPLAYLISTRESPONSE
  
  # @@protoc_insertion_point(class_scope:MagicPlaylistResponse)

class FlushLockerRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _FLUSHLOCKERREQUEST
  
  # @@protoc_insertion_point(class_scope:FlushLockerRequest)

class FlushLockerResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _FLUSHLOCKERRESPONSE
  
  # @@protoc_insertion_point(class_scope:FlushLockerResponse)

class LockerNotification(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _LOCKERNOTIFICATION
  
  # @@protoc_insertion_point(class_scope:LockerNotification)

class Album(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ALBUM
  
  # @@protoc_insertion_point(class_scope:Album)

class AlbumSortOrder(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ALBUMSORTORDER
  
  # @@protoc_insertion_point(class_scope:AlbumSortOrder)

class GetAlbumsRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETALBUMSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetAlbumsRequest)

class GetAlbumsResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETALBUMSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetAlbumsResponse)

class Artist(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ARTIST
  
  # @@protoc_insertion_point(class_scope:Artist)

class ArtistSortOrder(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ARTISTSORTORDER
  
  # @@protoc_insertion_point(class_scope:ArtistSortOrder)

class GetArtistsRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETARTISTSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetArtistsRequest)

class GetArtistsResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETARTISTSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetArtistsResponse)

class MusicGenre(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MUSICGENRE
  
  # @@protoc_insertion_point(class_scope:MusicGenre)

class GenreSortOrder(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GENRESORTORDER
  
  # @@protoc_insertion_point(class_scope:GenreSortOrder)

class GetGenresRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETGENRESREQUEST
  
  # @@protoc_insertion_point(class_scope:GetGenresRequest)

class GetGenresResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETGENRESRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetGenresResponse)

class GetDynamicPlaylistEntriesRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETDYNAMICPLAYLISTENTRIESREQUEST
  
  # @@protoc_insertion_point(class_scope:GetDynamicPlaylistEntriesRequest)

class GetDynamicPlaylistEntriesResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETDYNAMICPLAYLISTENTRIESRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetDynamicPlaylistEntriesResponse)

class GetAggregationsByTrackTypeRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETAGGREGATIONSBYTRACKTYPEREQUEST
  
  # @@protoc_insertion_point(class_scope:GetAggregationsByTrackTypeRequest)

class TrackTypeAggregate(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKTYPEAGGREGATE
  
  # @@protoc_insertion_point(class_scope:TrackTypeAggregate)

class GetAggregationsByTrackTypeResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETAGGREGATIONSBYTRACKTYPERESPONSE
  
  # @@protoc_insertion_point(class_scope:GetAggregationsByTrackTypeResponse)

class GetAggregationsByAvailabilityStatusRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETAGGREGATIONSBYAVAILABILITYSTATUSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetAggregationsByAvailabilityStatusRequest)

class AvailabilityStatusAggregate(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _AVAILABILITYSTATUSAGGREGATE
  
  # @@protoc_insertion_point(class_scope:AvailabilityStatusAggregate)

class GetAggregationsByAvailabilityStatusResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETAGGREGATIONSBYAVAILABILITYSTATUSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetAggregationsByAvailabilityStatusResponse)

class AddPromoTracksRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ADDPROMOTRACKSREQUEST
  
  # @@protoc_insertion_point(class_scope:AddPromoTracksRequest)

class AddPromoTracksResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ADDPROMOTRACKSRESPONSE
  
  # @@protoc_insertion_point(class_scope:AddPromoTracksResponse)

class GetPlaylistAggregationsRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETPLAYLISTAGGREGATIONSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetPlaylistAggregationsRequest)

class PlaylistAggregate(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PLAYLISTAGGREGATE
  
  # @@protoc_insertion_point(class_scope:PlaylistAggregate)

class GetPlaylistAggregationsResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETPLAYLISTAGGREGATIONSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetPlaylistAggregationsResponse)

class RemoteControlCommandRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _REMOTECONTROLCOMMANDREQUEST
  
  # @@protoc_insertion_point(class_scope:RemoteControlCommandRequest)

class RemoteControlCommandResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _REMOTECONTROLCOMMANDRESPONSE
  
  # @@protoc_insertion_point(class_scope:RemoteControlCommandResponse)

# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = metadata
# -*- coding: utf-8 -*-

"""
All known information on metadata is exposed in ``gmusicapi.protocol.metadata.md_expectations``.

This holds a mapping of *name* to *Expectation*, where *Expectation* has
the following fields:

*name*
  key name in the song dictionary (equal to the *name* keying ``md_expectations``).

*type*:
    a string holding a `validictory <https://github.com/sunlightlabs/validictory>`__ type.

    Possible values:
      :'string':
          str and unicode objects
      :'integer':
          ints, longs
      :'number':
          ints, longs and floats
      :'boolean':
          bools
      :'object':
          dicts
      :'array':
          lists and tuples
      :'null':
          ``None``
      :'any':
          any type is possible

*mutable*:
  ``True`` if client can change the value.

*optional*:
  ``True`` if the key is not guaranteed to be present.

*volatile*:
  ``True`` if the key's value can change between observations without client mutation.

*depends_on*:
  the name of the key we transform to take our value from, or ``None``.

  These fields can never be changed: they are automatically set to
  a modified form of some other field's value.
  See *dependent_transformation* for more information.

*dependent_transformation*:
  ``None``, or a function ``lambda dependent_value: our_value``.

  For example, the ``artistNorm`` field is automatically set to the lowercase
  of the ``artist`` field.
  So, ``artistNorm.depends_on == 'artist'``, and the *dependent_transformation* for
  ``artistNorm`` can be written as ``lambda artist: artist.lower()``.

*allowed_values*:
  sequence of allowed values.

*explanation*:
  an explanatory string, typically empty for obvious fields.

The above information is used to generate the documentation below.
If you find an example to clarify these expectations, please `submit an issue
<https://github.com/simon-weber/Unofficial-Google-Music-API/issues>`__.
"""

from collections import defaultdict, namedtuple


_Expectation = namedtuple(
    '_Expectation',
    [
        'name', 'type', 'mutable', 'optional', 'volatile',
        'depends_on', 'dependent_transformation',
        'allowed_values', 'explanation'
    ]
)


class Expectation(_Expectation):
    """Instantiated to represent information about a single metadata key."""
    #This class just wraps the namedtuple to provide easy construction and some methods.

    def __new__(cls, name, type, mutable, optional, volatile=False,
                depends_on=None, dependent_transformation=None,
                allowed_values=None, explanation=''):
        return cls.__bases__[0].__new__(
            cls,
            name, type, mutable, optional, volatile,
            depends_on, dependent_transformation,
            allowed_values, explanation
        )

    def get_schema(self):
        """Return a validictory schema for this key."""
        schema = {}
        schema["type"] = self.type
        if self.type == "string":
            schema["blank"] = True  # allow blank strings
        if self.optional:
            schema["required"] = False

        return schema

#: All the expectations.
_all_expts = [
    Expectation(name, 'string', mutable=True, optional=False) for name in
    (
        'composer', 'album', 'albumArtist', 'genre', 'name', 'artist', 'comment',
    )
] + [
    Expectation(name, 'integer', mutable=True, optional=True) for name in
    (
        'disc', 'year', 'track', 'totalTracks', 'totalDiscs', 'explicitType',
    )
] + [
    Expectation(name, type_str, mutable=False, optional=False, explanation=explain)
    for (name, type_str, explain) in
    (
        ('durationMillis', 'integer',
         'length of a song in milliseconds.'),

        ('id', 'string',
         'a per-user unique id for this song; sometimes referred to as *server id* or *song id*.'),

        ('creationDate', 'integer', ''),
        ('type', 'integer',
         'An enum: 1: free/purchased, 2: uploaded/not matched, 6: uploaded/matched'),

        ('beatsPerMinute', 'integer',
         "the server does not calculate this - it's just what was in track metadata"),

        ('subjectToCuration', 'boolean', 'meaning unknown.'),
        ('curatedByUser', 'boolean', 'meaning unknown'),
        ('curationSuggested', 'boolean', 'meaning unknown'),
    )
] + [
    Expectation(name, type_str, mutable=False, optional=True, explanation=explain)
    for (name, type_str, explain) in
    (
        ('storeId', 'string', 'an id of a matching track in the Play Store.'),
        ('reuploading', 'boolean', 'scan-and-match reupload in progress.'),
        ('albumMatchedId', 'string', 'id of matching album in the Play Store?'),
        ('pending', 'boolean', 'unsure; server processing (eg for store match) pending?'),
        ('url', 'string', 'meaning unknown.'),
        ('bitrate', 'integer', "bitrate in kilobytes/second (eg 320)."),
        ('playlistEntryId', 'string', 'identifies position in the context of a playlist.'),
        ('albumArtUrl', 'string', "if present, the url of an image for this song's album art."),
        ('artistMatchedId', 'string', 'id of a matching artist in the Play Store?'),
        ('albumPlaybackTimestamp', 'integer', 'UTC/microsecond timestamp: the last time this album was played?'),   # noqa
        ('origin', 'array', '???'),
        ('artistImageBaseUrl', 'string', 'like albumArtUrl, but for the artist. May be blank.'),
        ('recentTimestamp', 'integer', 'UTC/microsecond timestamp: meaning unknown.'),
        ('deleted', 'boolean', ''),
        ('matchedId', 'string', 'meaning unknown; related to scan and match?'),
        ('previewToken', 'string', 'meaning unknown'),
        ('lastPlaybackTimestamp', 'integer', 'UTC/microseconds: last time the track was played'),
        ('lastRatingChangeTimestamp', 'integer', 'UTC/microseconds: last time the track was rated'),
    )
] + [
    Expectation(name + 'Norm', 'string', mutable=False, optional=False,
                depends_on=name,
                dependent_transformation=lambda x: x.lower(),
                explanation="automatically set to lowercase of *%s*." % name)
    for name in
    (
        'artist', 'albumArtist', 'album'
    )
] + [
    # 0, 1, 5: no, down, up thumbs
    Expectation('rating', 'integer', mutable=True,
                optional=False, allowed_values=tuple(range(6)),
                explanation='0 == no thumb, 1 == down thumb, 5 == up thumb.'),

    Expectation('lastPlayed', 'integer', mutable=False, optional=True, volatile=True,
                explanation='UTC/microsecond timestamp'),

    Expectation('playCount', 'integer', mutable=True, optional=False),

    Expectation('title', 'string', mutable=False, optional=False,
                depends_on='name', dependent_transformation=lambda x: x,
                explanation='misleading! automatically set to *name*.'),

    Expectation('titleNorm', 'string', mutable=False, optional=False,
                depends_on='name', dependent_transformation=lambda x: x.lower(),
                explanation='misleading! automatically set to lowercase of *name*.'),
]

#Create the dict for client code. If they look up something we don't know about,
# give them a flexible immutable key.
_immutable_key = lambda: Expectation('unknown', 'any', mutable=False, optional=True)
md_expectations = defaultdict(_immutable_key)
for expt in _all_expts:
    md_expectations[expt.name] = expt


#This code is a super-hack. KnownMetadataFields exists _purely_ for documentation.

#We want dynamic documentation based on _all_expts, but __doc__ isn't a writable field
#for non-{function, class, module} objects. So, we create a dummy class and dynamically
#create its docstring to be arbitrary reST that documents our expectations.

def detail_line(e):
    """Given an expectation, return a readable one-line explanation of it."""
    fields = [fname for fname in ('mutable', 'optional', 'volatile')
              if getattr(e, fname, None)]

    if e.depends_on:
        fields.append("depends_on=%s" % e.depends_on)

    line = ', '.join(fields)
    if line:
        line = "*(%s)*" % line

    return line

#Note the hackiness of this class.
dynamic_docs = """
**This class exists only for documentation; do not try to import it.**

Instead, client code should use ``gmusicapi.protocol.metadata.md_expectations``.

See `the code <https://github.com/simon-weber/Unofficial-Google-Music-API/blob
/develop/gmusicapi/protocol/metadata.py>`__ for an explanation of this hack.
Ideas to clean this up are welcomed.

"""

#Create a reST definition list dynamically.
dynamic_docs += '\n\n'.join(
    ("*{name}*\n"
     "  {type} {details}\n\n"
     "  {explanation}").format(
         name=e.name,
         type=e.type,
         details=detail_line(e),
         explanation=e.explanation,
     ) for e in sorted(_all_expts, key=lambda e: e.name)
)


KnownMetadataFields = type('KnownMetadataFields', (defaultdict,), {'__doc__': dynamic_docs})

########NEW FILE########
__FILENAME__ = mobileclient
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Calls made by the mobile client."""

import base64
import copy
from datetime import datetime
from hashlib import sha1
import hmac
import sys
import time
from uuid import uuid1

import validictory

from gmusicapi.compat import json
from gmusicapi.exceptions import ValidationException, CallFailure
from gmusicapi.protocol.shared import Call, authtypes
from gmusicapi.utils import utils

# URL for sj service
sj_url = 'https://www.googleapis.com/sj/v1.5/'

# shared schemas
sj_track = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'kind': {'type': 'string'},
        'title': {'type': 'string'},
        'artist': {'type': 'string'},
        'album': {'type': 'string'},
        'albumArtist': {'type': 'string'},
        'trackNumber': {'type': 'integer'},
        'durationMillis': {'type': 'string'},
        'albumArtRef': {'type': 'array',
                        'items': {'type': 'object', 'properties': {'url': {'type': 'string'}}},
                        'required': False},
        'artistArtRef': {'type': 'array',
                         'items': {'type': 'object', 'properties': {'url': {'type': 'string'}}},
                         'required': False,
                       },
        'discNumber': {'type': 'integer'},
        'estimatedSize': {'type': 'string'},
        'trackType': {'type': 'string'},
        'storeId': {'type': 'string'},
        'albumId': {'type': 'string'},
        'artistId': {'type': 'array',
                     'items': {'type': 'string', 'blank': True}, 'required': False},
        'nid': {'type': 'string'},
        'trackAvailableForPurchase': {'type': 'boolean'},
        'albumAvailableForPurchase': {'type': 'boolean'},
        'composer': {'type': 'string', 'blank': True},
        'playCount': {'type': 'integer', 'required': False},
        'year': {'type': 'integer', 'required': False},
        'rating': {'type': 'string', 'required': False},
        'genre': {'type': 'string', 'required': False},
        'trackAvailableForSubscription': {'type': 'boolean'},
        'contentType': {'type': 'string'},
    }
}

sj_playlist = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'kind': {'type': 'string'},
        'name': {'type': 'string'},
        'deleted': {'type': 'boolean'},
        'type': {'type': 'string',
                 'pattern': r'MAGIC|SHARED|USER_GENERATED',
                 'required': False,
                 },
        'lastModifiedTimestamp': {'type': 'string'},
        'recentTimestamp': {'type': 'string'},
        'shareToken': {'type': 'string'},
        'ownerProfilePhotoUrl': {'type': 'string'},
        'ownerName': {'type': 'string'},
        'accessControlled': {'type': 'boolean'},
        'creationTimestamp': {'type': 'string'},
        'id': {'type': 'string'},
        'albumArtRef': {'type': 'array',
                        'items': {'type': 'object', 'properties': {'url': {'type': 'string'}}},
                        'required': False,
                       },
    }
}

sj_plentry = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'kind': {'type': 'string'},
        'id': {'type': 'string'},
        'clientId': {'type': 'string'},
        'playlistId': {'type': 'string'},
        'absolutePosition': {'type': 'string'},
        'trackId': {'type': 'string'},
        'creationTimestamp': {'type': 'string'},
        'lastModifiedTimestamp': {'type': 'string'},
        'deleted': {'type': 'boolean'},
        'source': {'type': 'string'},
        'track': sj_track.copy()
    },
}

sj_plentry['properties']['track']['required'] = False


sj_album = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'kind': {'type': 'string'},
        'name': {'type': 'string'},
        'albumArtist': {'type': 'string'},
        'albumArtRef': {'type': 'string'},
        'albumId': {'type': 'string'},
        'artist': {'type': 'string'},
        'artistId': {'type': 'array', 'items': {'type': 'string', 'blank': True}},
        'year': {'type': 'integer', 'required': False},
        'tracks': {'type': 'array', 'items': sj_track, 'required': False},
        'description': {'type': 'string', 'required': False},
    }
}

sj_artist = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'kind': {'type': 'string'},
        'name': {'type': 'string'},
        'artistArtRef': {'type': 'string', 'required': False},
        'artistBio': {'type': 'string', 'required': False},
        'artistId': {'type': 'string', 'blank': True},
        'albums': {'type': 'array', 'items': sj_album, 'required': False},
        'topTracks': {'type': 'array', 'items': sj_track, 'required': False},
        'total_albums': {'type': 'integer', 'required': False},
        'artistBio': {'type': 'string', 'required': False},
    }
}

sj_artist['properties']['related_artists'] = {
    'type': 'array',
    'items': sj_artist,  # note the recursion
    'required': False
}

sj_result = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'score': {'type': 'number'},
        'type': {'type': 'string'},
        'best_result': {'type': 'boolean', 'required': False},
        'navigational_result': {'type': 'boolean', 'required': False},
        'navigational_confidence': {'type': 'number', 'required': False},
        'artist': sj_artist.copy(),
        'album': sj_album.copy(),
        'track': sj_track.copy(),
    }
}

sj_result['properties']['artist']['required'] = False
sj_result['properties']['album']['required'] = False
sj_result['properties']['track']['required'] = False

sj_station_seed = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'kind': {'type': 'string'},
        # one of these will be present
        'albumId': {'type': 'string', 'required': False},
        'artistId': {'type': 'string', 'required': False},
        'genreId': {'type': 'string', 'required': False},
        'trackId': {'type': 'string', 'required': False},
        'trackLockerId': {'type': 'string', 'required': False},
    }
}

sj_station = {
    'type': 'object',
    'additionalProperties': False,
    'properties': {
        'imageUrl': {'type': 'string'},
        'kind': {'type': 'string'},
        'name': {'type': 'string'},
        'deleted': {'type': 'boolean'},
        'lastModifiedTimestamp': {'type': 'string'},
        'recentTimestamp': {'type': 'string'},
        'clientId': {'type': 'string'},
        'seed': sj_station_seed,
        'id': {'type': 'string'},
        'description': {'type': 'string', 'required': False},
        'tracks': {'type': 'array', 'required': False, 'items': sj_track},
    }
}


class McCall(Call):
    """Abstract base for mobile client calls."""

    required_auth = authtypes(xt=False, sso=True)

    #validictory schema for the response
    _res_schema = utils.NotImplementedField

    @classmethod
    def validate(cls, response, msg):
        """Use validictory and a static schema (stored in cls._res_schema)."""
        try:
            return validictory.validate(msg, cls._res_schema)
        except ValueError as e:
            trace = sys.exc_info()[2]
            raise ValidationException(str(e)), None, trace

    @classmethod
    def check_success(cls, response, msg):
        #TODO not sure if this is still valid for mc
        pass

        #if 'success' in msg and not msg['success']:
        #    raise CallFailure(
        #        "the server reported failure. This is usually"
        #        " caused by bad arguments, but can also happen if requests"
        #        " are made too quickly (eg creating a playlist then"
        #        " modifying it before the server has created it)",
        #        cls.__name__)

    @classmethod
    def parse_response(cls, response):
        return cls._parse_json(response.text)


class McListCall(McCall):
    """Abc for calls that list a resource."""
    # concrete classes provide:
    item_schema = utils.NotImplementedField
    filter_text = utils.NotImplementedField

    static_headers = {'Content-Type': 'application/json'}
    static_params = {'alt': 'json', 'include-tracks': 'true'}

    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'kind': {'type': 'string'},
            'nextPageToken': {'type': 'string', 'required': False},
            'data': {'type': 'object',
                     'items': {'type': 'array', 'items': item_schema},
                     'required': False,
                    },
        },
    }

    @classmethod
    def dynamic_params(cls, updated_after=None, start_token=None, max_results=None):
        """
        :param updated_after: datetime.datetime; defaults to epoch
        """

        if updated_after is None:
            microseconds = 0
        else:
            microseconds = utils.datetime_to_microseconds(updated_after)

        return {'updated-min': microseconds}

    @classmethod
    def dynamic_data(cls, updated_after=None, start_token=None, max_results=None):
        """
        :param updated_after: ignored
        :param start_token: nextPageToken from a previous response
        :param max_results: a positive int; if not provided, server defaults to 1000
        """
        data = {}

        if start_token is not None:
            data['start-token'] = start_token

        if max_results is not None:
            data['max-results'] = str(max_results)

        return json.dumps(data)

    @classmethod
    def parse_response(cls, response):
        # empty results don't include the data key
        # make sure it's always there
        res = cls._parse_json(response.text)
        if 'data' not in res:
            res['data'] = {'items': []}

        return res

    @classmethod
    def filter_response(cls, msg):
        filtered = copy.deepcopy(msg)
        filtered['data']['items'] = ["<%s %s>" % (len(filtered['data']['items']),
                                                  cls.filter_text)]
        return filtered


class McBatchMutateCall(McCall):
    """Abc for batch mutation calls."""

    static_headers = {'Content-Type': 'application/json'}
    static_params = {'alt': 'json'}

    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'mutate_response': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'id': {'type': 'string', 'required': False},
                        'client_id': {'type': 'string', 'blank': True,
                                      'required': False},
                        'response_code': {'type': 'string'},
                    },
                },
            }
        },
    }

    @staticmethod
    def dynamic_data(mutations):
        """
        :param mutations: list of mutation dictionaries
        """

        return json.dumps({'mutations': mutations})

    @classmethod
    def check_success(cls, response, msg):
        if ('error' in msg or
            not all([d.get('response_code', None) in ('OK', 'CONFLICT')
                     for d in msg.get('mutate_response', [])])):
            raise CallFailure('The server reported failure while'
                              ' changing the requested resource.'
                              " If this wasn't caused by invalid arguments"
                              ' or server flakiness,'
                              ' please open an issue.',
                              cls.__name__)


class Search(McCall):
    """Search for All Access tracks."""
    static_method = 'GET'
    static_url = sj_url + 'query'

    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'kind': {'type': 'string'},
            'entries': {'type': 'array',
                        'items': sj_result,
                        'required': False}
        },
    }

    @staticmethod
    def dynamic_params(query, max_results):
        return {'q': query, 'max-results': max_results}


class ListTracks(McListCall):
    item_schema = sj_track
    filter_text = 'tracks'

    static_method = 'POST'
    static_url = sj_url + 'trackfeed'


class GetStreamUrl(McCall):
    static_method = 'GET'
    static_url = 'https://android.clients.google.com/music/mplay'
    static_verify = False

    # this call will redirect to the mp3
    static_allow_redirects = False

    _s1 = base64.b64decode('VzeC4H4h+T2f0VI180nVX8x+Mb5HiTtGnKgH52Otj8ZCGDz9jRW'
                           'yHb6QXK0JskSiOgzQfwTY5xgLLSdUSreaLVMsVVWfxfa8Rw==')
    _s2 = base64.b64decode('ZAPnhUkYwQ6y5DdQxWThbvhJHN8msQ1rqJw0ggKdufQjelrKuiG'
                           'GJI30aswkgCWTDyHkTGK9ynlqTkJ5L4CiGGUabGeo8M6JTQ==')

    # bitwise and of _s1 and _s2 ascii, converted to string
    _key = ''.join([chr(ord(c1) ^ ord(c2)) for (c1, c2) in zip(_s1, _s2)])

    @classmethod
    def get_signature(cls, song_id, salt=None):
        """Return a (sig, salt) pair for url signing."""

        if salt is None:
            salt = str(int(time.time() * 1000))

        mac = hmac.new(cls._key, song_id, sha1)
        mac.update(salt)
        sig = base64.urlsafe_b64encode(mac.digest())[:-1]

        return sig, salt

    @staticmethod
    def dynamic_headers(song_id, device_id):
        return {'X-Device-ID': device_id}

    @classmethod
    def dynamic_params(cls, song_id, device_id):
        sig, salt = cls.get_signature(song_id)

        #TODO which of these should get exposed?
        params = {'opt': 'hi',
                  'net': 'wifi',
                  'pt': 'e',
                  'slt': salt,
                  'sig': sig,
                 }
        if song_id[0] == 'T':
            # all access
            params['mjck'] = song_id
        else:
            params['songid'] = song_id

        return params

    @staticmethod
    def parse_response(response):
        return response.headers['location']  # ie where we were redirected

    @classmethod
    def validate(cls, response, msg):
        pass


class ListPlaylists(McListCall):
    item_schema = sj_playlist
    filter_text = 'playlists'

    static_method = 'POST'
    static_url = sj_url + 'playlistfeed'


class ListPlaylistEntries(McListCall):
    item_schema = sj_plentry
    filter_text = 'plentries'

    static_method = 'POST'
    static_url = sj_url + 'plentryfeed'


class ListSharedPlaylistEntries(McListCall):
    shared_plentry = sj_plentry.copy()
    del shared_plentry['properties']['playlistId']
    del shared_plentry['properties']['clientId']

    item_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'shareToken': {'type': 'string'},
            'responseCode': {'type': 'string'},
            'playlistEntry': {
                'type': 'array',
                'items': shared_plentry,
                'required': False,
            }
        }
    }
    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'kind': {'type': 'string'},
            'entries': {'type': 'array',
                        'items': item_schema,
                       },
        },
    }
    filter_text = 'shared plentries'

    static_method = 'POST'
    static_url = sj_url + 'plentries/shared'

    # odd: this request has an additional level of nesting compared to others,
    # and changes the data/entry schema to entries/playlistEntry.
    # Those horrible naming choices make this even harder to understand.

    @classmethod
    def dynamic_params(cls, share_token, updated_after=None, start_token=None, max_results=None):
        return super(ListSharedPlaylistEntries, cls).dynamic_params(
            updated_after, start_token, max_results)

    @classmethod
    def dynamic_data(cls, share_token, updated_after=None, start_token=None, max_results=None):
        """
        :param share_token: from a shared playlist
        :param updated_after: ignored
        :param start_token: nextPageToken from a previous response
        :param max_results: a positive int; if not provided, server defaults to 1000
        """
        data = {}

        data['shareToken'] = share_token

        if start_token is not None:
            data['start-token'] = start_token

        if max_results is not None:
            data['max-results'] = str(max_results)

        return json.dumps({'entries': [data]})

    @classmethod
    def parse_response(cls, response):
        res = cls._parse_json(response.text)
        if 'playlistEntry' not in res['entries'][0]:
            res['entries'][0]['playlistEntry'] = []

        return res

    @classmethod
    def filter_response(cls, msg):
        filtered = copy.deepcopy(msg)
        filtered['entries'][0]['playlistEntry'] = ["<%s %s>" %
                                                   (len(filtered['entries'][0]['playlistEntry']),
                                                    cls.filter_text)]
        return filtered


class BatchMutatePlaylists(McBatchMutateCall):
    static_method = 'POST'
    static_url = sj_url + 'playlistbatch'

    @staticmethod
    def build_playlist_deletes(playlist_ids):
        #TODO can probably pull this up one
        """
        :param playlist_ids
        """
        return [{'delete': id} for id in playlist_ids]

    @staticmethod
    def build_playlist_updates(pl_id_name_pairs):
        """
        :param pl_id_name_pairs: [(playlist_id, new_name)]
        """
        return [{'update': {'id': pl_id, 'name': new_name}} for
                (pl_id, new_name) in pl_id_name_pairs]

    @staticmethod
    def build_playlist_adds(pl_descriptions):
        """
        :param pl_descriptions: [{'name': '', 'public': <bool>}]
        """

        return [{'create': {
            'creationTimestamp': '-1',
            'deleted': False,
            'lastModifiedTimestamp': '0',
            'name': pl_desc['name'],
            'type': 'USER_GENERATED',
            'accessControlled': pl_desc['public'],
        }} for pl_desc in pl_descriptions]


class BatchMutatePlaylistEntries(McBatchMutateCall):
    filter_text = 'plentries'
    item_schema = sj_plentry

    static_method = 'POST'
    static_url = sj_url + 'plentriesbatch'

    @staticmethod
    def build_plentry_deletes(entry_ids):
        """
        :param entry_ids
        """
        return [{'delete': id} for id in entry_ids]

    @staticmethod
    def build_plentry_reorder(plentry, preceding_cid, following_cid):
        """
        :param plentry: plentry that is moving
        :param preceding_cid: clientid of entry that will be before the moved entry
        :param following_cid: "" that will be after the moved entry
        """

        mutation = copy.deepcopy(plentry)
        keys_to_keep = set(['clientId', 'creationTimestamp', 'deleted', 'id',
                            'lastModifiedTimestamp', 'playlistId',
                            'source', 'trackId'])

        for key in mutation.keys():
            if key not in keys_to_keep:
                del mutation[key]

        # horribly misleading key names; these are _clientids_
        # using entryids works sometimes, but with seemingly random results
        if preceding_cid:
            mutation['precedingEntryId'] = preceding_cid

        if following_cid:
            mutation['followingEntryId'] = following_cid

        return {'update': mutation}

    @staticmethod
    def build_plentry_adds(playlist_id, song_ids):
        """
        :param playlist_id
        :param song_ids
        """

        mutations = []

        prev_id, cur_id, next_id = None, str(uuid1()), str(uuid1())

        for i, song_id in enumerate(song_ids):
            m_details = {
                'clientId': cur_id,
                'creationTimestamp': '-1',
                'deleted': False,
                'lastModifiedTimestamp': '0',
                'playlistId': playlist_id,
                'source': 1,
                'trackId': song_id,
            }

            if song_id.startswith('T'):
                m_details['source'] = 2  # AA track

            if i > 0:
                m_details['precedingEntryId'] = prev_id
            if i < len(song_ids) - 1:
                m_details['followingEntryId'] = next_id

            mutations.append({'create': m_details})
            prev_id, cur_id, next_id = cur_id, next_id, str(uuid1())

        return mutations


class ListStations(McListCall):
    item_schema = sj_station
    filter_text = 'stations'

    static_method = 'POST'
    static_url = sj_url + 'radio/station'


class ListStationTracks(McCall):
    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'kind': {'type': 'string'},
            'data': {'type': 'object',
                     'stations': {'type': 'array', 'items': sj_station},
                     'required': False,
                    },
        },
    }

    static_headers = {'Content-Type': 'application/json'}
    static_params = {'alt': 'json', 'include-tracks': 'true'}
    static_method = 'POST'
    static_url = sj_url + 'radio/stationfeed'

    @staticmethod
    def dynamic_data(station_id, num_entries, recently_played):
        """
        :param station_id
        :param num_entries: maximum number of tracks to return
        :param recently_played: a list of...song ids? never seen an example
        """
        #TODO
        # clearly, this supports more than one at a time,
        # but then that might introduce paging?
        # I'll leave it for someone else

        return json.dumps({'contentFilter': 1,
                           'stations': [
                               {
                                   'numEntries': num_entries,
                                   'radioId': station_id,
                                   'recentlyPlayed': recently_played
                               }
                           ]})

    @staticmethod
    def filter_response(msg):
        filtered = copy.deepcopy(msg)
        if 'stations' in filtered['data']:
            filtered['data']['stations'] = \
                    ["<%s stations>" % len(filtered['data']['stations'])]
        return filtered


class BatchMutateStations(McBatchMutateCall):
    static_method = 'POST'
    static_url = sj_url + 'radio/editstation'

    @staticmethod
    def build_deletes(station_ids):
        """
        :param station_ids
        """
        return [{'delete': id, 'includeFeed': False, 'numEntries': 0}
                for id in station_ids]

    @staticmethod
    def build_add(name, seed, include_tracks, num_tracks, recent_datetime=None):
        """
        :param name: the title
        :param seed: a dict with a single pair, {'itemId': id}
        :param include_tracks: if True, return `num_tracks` tracks in the response
        :param num_tracks:
        :param recent_datetime: purpose unknown. defaults to now.
        """

        if recent_datetime is None:
            recent_datetime = datetime.now()

        recent_timestamp = utils.datetime_to_microseconds(recent_datetime)

        return {
            "create": {
                "clientId": str(uuid1()),
                "deleted": False,
                "imageType": 1,
                "lastModifiedTimestamp": "-1",
                "name": name,
                "recentTimestamp": str(recent_timestamp),
                "seed": seed,
                "tracks": []
            },
            "includeFeed": include_tracks,
            "numEntries": num_tracks,
            "params":
            {
                "contentFilter": 1
            }
        }


class BatchMutateTracks(McBatchMutateCall):
    static_method = 'POST'
    static_url = sj_url + 'trackbatch'

    # utility functions to build the mutation dicts
    @staticmethod
    def build_track_deletes(track_ids):
        """
        :param track_ids
        """
        return [{'delete': id} for id in track_ids]

    @staticmethod
    def build_track_add(store_track_info):
        """
        :param store_track_info: sj_track
        """
        track_dict = copy.deepcopy(store_track_info)
        for key in ('kind', 'trackAvailableForPurchase',
                    'albumAvailableForPurchase', 'albumArtRef',
                    'artistId',
                   ):
            del track_dict[key]

        for key, default in {
            'playCount': 0,
            'rating': '0',
            'genre': '',
            'lastModifiedTimestamp': '0',
            'deleted': False,
            'beatsPerMinute': -1,
            'composer': '',
            'creationTimestamp': '-1',
            'totalDiscCount': 0,
        }.items():
            track_dict.setdefault(key, default)

        # TODO unsure about this
        track_dict['trackType'] = 8

        return {'create': track_dict}


class GetStoreTrack(McCall):
    #TODO does this accept library ids, too?
    static_method = 'GET'
    static_url = sj_url + 'fetchtrack'
    static_headers = {'Content-Type': 'application/json'}
    static_params = {'alt': 'json'}

    _res_schema = sj_track

    @staticmethod
    def dynamic_params(track_id):
        return {'nid': track_id}


class GetGenres(McCall):
    static_method = 'GET'
    static_url = sj_url + 'explore/genres'
    static_params = {'alt': 'json'}

    genre_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'name': {'type': 'string'},
            'id': {'type': 'string'},
            'kind': {'type': 'string'},
            'images': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'additionalProperties': False,
                    'properties': {
                        'url': {'type': 'string'}
                    },
                }
            },
            'children': {
                'type': 'array',
                'items': {'type': 'string'},
                'required': False,
            }
        }
    }

    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'kind': {'type': 'string'},
            'genres': {
                'type': 'array',
                'items': genre_schema,
            }
        }
    }


class GetArtist(McCall):
    static_method = 'GET'
    static_url = sj_url + 'fetchartist'
    static_params = {'alt': 'json'}

    _res_schema = sj_artist

    @staticmethod
    def dynamic_params(artist_id, include_albums, num_top_tracks, num_rel_artist):
        """
        :param include_albums: bool
        :param num_top_tracks: int
        :param num_rel_artist: int
        """

        return {'nid': artist_id,
                'include-albums': include_albums,
                'num-top-tracks': num_top_tracks,
                'num-related-artists': num_rel_artist,
               }


class GetAlbum(McCall):
    static_method = 'GET'
    static_url = sj_url + 'fetchalbum'
    static_params = {'alt': 'json'}

    _res_schema = sj_album

    @staticmethod
    def dynamic_params(album_id, tracks):
        return {'nid': album_id, 'include-tracks': tracks}


class IncrementPlayCount(McCall):
    static_method = 'POST'
    static_url = sj_url + 'trackstats'
    static_params = {'alt': 'json'}
    static_headers = {'Content-Type': 'application/json'}

    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'responses': {
                'type': 'array',
                'items': {
                    'type': 'object',
                    'additionalProperties': False,
                    'properties': {
                        'id': {'type': 'string',
                               'required': False},  # not provided for AA tracks?
                        'response_code': {'type': 'string'},
                    }
                }
            }
        }
    }

    @staticmethod
    def dynamic_data(sid, plays, playtime):
        #TODO this can support multiple
        return json.dumps({'track_stats': [{
            'id': sid,
            'incremental_plays': plays,
            'last_play_time_millis': str(utils.datetime_to_microseconds(playtime)),
            'type': 2 if sid.startswith('T') else 1,
            'track_events': [],
        }]})

########NEW FILE########
__FILENAME__ = musicmanager
# -*- coding: utf-8 -*-

"""Calls made by the Music Manager (related to uploading)."""

import base64
from collections import namedtuple
import hashlib
import os
import sys

import dateutil.parser
from decorator import decorator
from google.protobuf.message import DecodeError
import mutagen
from oauth2client.client import OAuth2Credentials

from gmusicapi.compat import json
from gmusicapi.exceptions import CallFailure
from gmusicapi.protocol import upload_pb2, locker_pb2, download_pb2
from gmusicapi.protocol.shared import Call, ParseException, authtypes
from gmusicapi.utils import utils

log = utils.DynamicClientLogger(__name__)


#This url has SSL issues, hence the static_verify=False.
_android_url = 'https://android.clients.google.com/upsj/'

OAuthInfo = namedtuple('OAuthInfo', 'client_id client_secret scope redirect')
oauth = OAuthInfo(
    '652850857958.apps.googleusercontent.com',
    'ji1rklciNp2bfsFJnEH_i6al',
    'https://www.googleapis.com/auth/musicmanager',
    'urn:ietf:wg:oauth:2.0:oob'
)


def credentials_from_refresh_token(token):
    # why doesn't Google provide this!?

    cred_json = {"_module": "oauth2client.client",
                 "token_expiry": "2000-01-01T00:13:37Z",  # to refresh now
                 "access_token": 'bogus',
                 "token_uri": "https://accounts.google.com/o/oauth2/token",
                 "invalid": False,
                 "token_response": {
                     "access_token": 'bogus',
                     "token_type": "Bearer",
                     "expires_in": 3600,
                     "refresh_token": token},
                 "client_id": oauth.client_id,
                 "id_token": None,
                 "client_secret": oauth.client_secret,
                 "revoke_uri": "https://accounts.google.com/o/oauth2/revoke",
                 "_class": "OAuth2Credentials",
                 "refresh_token": token,
                 "user_agent": None}

    return OAuth2Credentials.new_from_json(json.dumps(cred_json))


@decorator
def pb(f, *args, **kwargs):
    """Decorator to serialize a protobuf message."""
    msg = f(*args, **kwargs)
    return msg.SerializeToString()


class MmCall(Call):
    """Abstract base for Music Manager calls."""

    static_method = 'POST'
    # remember that setting this in a subclass overrides, not merges
    # static + dynamic does merge, though
    static_headers = {'User-agent': 'Music Manager (1, 0, 55, 7425 HTTPS - Windows)'}

    required_auth = authtypes(oauth=True)

    # this is a shared union class that has all specific upload types
    # nearly all of the proto calls return a message of this form
    res_msg_type = upload_pb2.UploadResponse

    @classmethod
    def parse_response(cls, response):
        """Parse the cls.res_msg_type proto msg."""
        res_msg = cls.res_msg_type()
        try:
            res_msg.ParseFromString(response.content)
        except DecodeError as e:
            trace = sys.exc_info()[2]
            raise ParseException(str(e)), None, trace
            pass

        return res_msg

    @classmethod
    def filter_response(cls, msg):
        return Call._filter_proto(msg)


class AuthenticateUploader(MmCall):
    """Sent to auth, reauth, or register our upload client."""

    static_url = _android_url + 'upauth'
    static_verify = False

    @classmethod
    def check_success(cls, response, msg):
        if msg.HasField('auth_status') and msg.auth_status != upload_pb2.UploadResponse.OK:
            enum_desc = upload_pb2._UPLOADRESPONSE.enum_types[1]
            res_name = enum_desc.values_by_number[msg.auth_status].name

            raise CallFailure(
                "Upload auth error code %s: %s."
                " See http://goo.gl/O6xe7 for more information. " % (
                    msg.auth_status, res_name
                ), cls.__name__
            )

    @classmethod
    @pb
    def dynamic_data(cls, uploader_id, uploader_friendly_name):
        """
        :param uploader_id: MM uses host MAC address
        :param uploader_friendly_name: MM uses hostname
        """
        req_msg = upload_pb2.UpAuthRequest()

        req_msg.uploader_id = uploader_id
        req_msg.friendly_name = uploader_friendly_name

        return req_msg


class UploadMetadata(MmCall):
    static_url = _android_url + 'metadata'
    static_verify = False

    static_params = {'version': 1}

    @staticmethod
    def get_track_clientid(filepath):
        #The id is a 22 char hash of the file. It is found by:
        # stripping tags
        # getting an md5 sum
        # converting sum to base64
        # removing trailing ===

        #My implementation is _not_ the same hash the music manager will send;
        # they strip tags first. But files are differentiated across accounts,
        # so this shouldn't cause problems.

        #This will attempt to reupload files if their tags change.

        m = hashlib.md5()
        with open(filepath, 'rb') as f:
            m.update(f.read())

        return base64.encodestring(m.digest())[:-3]

    #these collections define how locker_pb2.Track fields align to mutagen's.
    shared_fields = ('album', 'artist', 'composer', 'genre')
    field_map = {  # mutagen: Track
        'albumartist': 'album_artist',
        'bpm': 'beats_per_minute',
    }
    count_fields = {  # mutagen: (part, total)
        'discnumber': ('disc_number', 'total_disc_count'),
        'tracknumber': ('track_number', 'total_track_count'),
    }

    @classmethod
    def fill_track_info(cls, filepath):
        """Given the path and contents of a track, return a filled locker_pb2.Track.
        On problems, raise ValueError."""
        track = locker_pb2.Track()

        track.client_id = cls.get_track_clientid(filepath)

        extension = os.path.splitext(filepath)[1].upper()
        if extension:
            #Trim leading period if it exists (ie extension not empty).
            extension = extension[1:]

        if extension.upper() == 'M4B':
            #M4B are supported by the music manager, and transcoded like normal.
            extension = 'M4A'

        if not hasattr(locker_pb2.Track, extension):
            raise ValueError("unsupported filetype")

        track.original_content_type = getattr(locker_pb2.Track, extension)

        track.estimated_size = os.path.getsize(filepath)
        track.last_modified_timestamp = int(os.path.getmtime(filepath))

        #These are typically zeroed in my examples.
        track.play_count = 0
        track.client_date_added = 0
        track.recent_timestamp = 0
        track.rating = locker_pb2.Track.NOT_RATED  # star rating

        #Populate information about the encoding.
        audio = mutagen.File(filepath, easy=True)
        if audio is None:
            raise ValueError("could not open to read metadata")
        elif isinstance(audio, mutagen.asf.ASF):
            #WMA entries store more info than just the value.
            #Monkeypatch in a dict {key: value} to keep interface the same for all filetypes.
            asf_dict = dict((k, [ve.value for ve in v]) for (k, v) in audio.tags.as_dict().items())
            audio.tags = asf_dict

        track.duration_millis = int(audio.info.length * 1000)

        try:
            bitrate = int(audio.info.bitrate / 1000)
        except AttributeError:
            #mutagen doesn't provide bitrate for some lossless formats (eg FLAC), so
            # provide an estimation instead. This shouldn't matter too much;
            # the bitrate will always be > 320, which is the highest scan and match quality.
            bitrate = (track.estimated_size * 8) / track.duration_millis

        track.original_bit_rate = bitrate

        #Populate metadata.

        def track_set(field_name, val, msg=track):
            """Returns result of utils.pb_set and logs on failures.
            Should be used when setting directly from metadata."""
            success = utils.pb_set(msg, field_name, val)

            if not success:
                log.info("could not pb_set track.%s = %r for '%s'", field_name, val, filepath)

            return success

        #Title is required.
        #If it's not in the metadata, the filename will be used.
        if "title" in audio:
            title = audio['title'][0]
            if isinstance(title, mutagen.asf.ASFUnicodeAttribute):
                title = title.value

            track_set('title', title)
        else:
            #Assume ascii or unicode.
            track.title = os.path.basename(filepath)

        if "date" in audio:
            date_val = str(audio['date'][0])
            try:
                datetime = dateutil.parser.parse(date_val, fuzzy=True)
            except (ValueError, TypeError) as e:
                # TypeError provides compatibility with:
                #  https://bugs.launchpad.net/dateutil/+bug/1247643
                log.warning("could not parse date md for '%s': (%s)", filepath, e)
            else:
                track_set('year', datetime.year)

        for null_field in ['artist', 'album']:
            # If these fields aren't provided, they'll render as "undefined" in the web interface;
            # see https://github.com/simon-weber/Unofficial-Google-Music-API/issues/236.
            # Defaulting them to an empty string fixes this.
            if null_field not in audio:
                track_set(null_field, '')

        #Mass-populate the rest of the simple fields.
        #Merge shared and unshared fields into {mutagen: Track}.
        fields = dict(
            dict((shared, shared) for shared in cls.shared_fields).items() +
            cls.field_map.items()
        )

        for mutagen_f, track_f in fields.items():
            if mutagen_f in audio:
                track_set(track_f, audio[mutagen_f][0])

        for mutagen_f, (track_f, track_total_f) in cls.count_fields.items():
            if mutagen_f in audio:
                numstrs = str(audio[mutagen_f][0]).split("/")
                track_set(track_f, numstrs[0])

                if len(numstrs) == 2 and numstrs[1]:
                    track_set(track_total_f, numstrs[1])

        return track

    @classmethod
    @pb
    def dynamic_data(cls, tracks, uploader_id, do_not_rematch=False):
        """
        :param tracks: list of filled locker_pb2.Track
        :param uploader_id:
        :param do_not_rematch: seems to be ignored
        """

        req_msg = upload_pb2.UploadMetadataRequest()

        req_msg.track.extend(tracks)

        for track in req_msg.track:
            track.do_not_rematch = do_not_rematch

        req_msg.uploader_id = uploader_id

        return req_msg


class GetUploadJobs(MmCall):
    #TODO
    static_url = _android_url + 'getjobs'
    static_verify = False

    static_params = {'version': 1}

    @classmethod
    def check_success(cls, response, msg):
        if msg.HasField('getjobs_response') and not msg.getjobs_response.get_tracks_success:
            raise CallFailure('get_tracks_success == False', cls.__name__)

    @classmethod
    @pb
    def dynamic_data(cls, uploader_id):
        """
        :param uploader_id: MM uses host MAC address
        """
        req_msg = upload_pb2.GetJobsRequest()

        req_msg.uploader_id = uploader_id

        return req_msg


class GetUploadSession(MmCall):
    """Called when we want to upload; the server returns the url to use.
    This is a json call, and doesn't share much with the other calls."""

    static_method = 'POST'
    static_url = 'https://uploadsj.clients.google.com/uploadsj/rupio'

    @classmethod
    def parse_response(cls, response):
        return cls._parse_json(response.text)

    @staticmethod
    def filter_response(res):
        return res

    @staticmethod
    def dynamic_data(uploader_id, num_already_uploaded,
                     track, filepath, server_id, do_not_rematch=False):
        """track is a locker_pb2.Track, and the server_id is from a metadata upload."""
        #small info goes inline, big things get their own external PUT.
        #still not sure as to thresholds - I've seen big album art go inline.
        inlined = {
            "title": "jumper-uploader-title-42",
            "ClientId": track.client_id,
            "ClientTotalSongCount": "1",  # TODO think this is ie "how many will you upload"
            "CurrentTotalUploadedCount": str(num_already_uploaded),
            "CurrentUploadingTrack": track.title,
            "ServerId": server_id,
            "SyncNow": "true",
            "TrackBitRate": track.original_bit_rate,
            "TrackDoNotRematch": str(do_not_rematch).lower(),
            "UploaderId": uploader_id,
        }

        message = {
            "clientId": "Jumper Uploader",
            "createSessionRequest": {
                "fields": [
                    {
                        "external": {
                            "filename": os.path.basename(filepath),
                            "name": os.path.abspath(filepath),
                            "put": {},
                            #used to use this; don't see it in examples
                            #"size": track.estimated_size,
                        }
                    }
                ]
            },
            "protocolVersion": "0.8"
        }

        #Insert the inline info.
        for key in inlined:
            payload = inlined[key]
            if not isinstance(payload, basestring):
                payload = str(payload)

            message['createSessionRequest']['fields'].append(
                {
                    "inlined": {
                        "content": payload,
                        "name": key
                    }
                }
            )

        return json.dumps(message)

    @staticmethod
    def process_session(res):
        """Return (got_session, error_details).
        error_details is (should_retry, reason, error_code) or None if got_session."""

        if 'sessionStatus' in res:
            return (True, None)

        if 'errorMessage' in res:
            #This terribly nested structure is Google's doing.
            error_code = (res['errorMessage']['additionalInfo']
                          ['uploader_service.GoogleRupioAdditionalInfo']
                          ['completionInfo']['customerSpecificInfo']['ResponseCode'])

            got_session = False

            if error_code == 503:
                should_retry = True
                reason = 'upload servers still syncing'

            #TODO unsure about these codes
            elif error_code == 200:
                should_retry = False
                reason = 'this song is already uploaded'

            elif error_code == 404:
                should_retry = False
                reason = 'the request was rejected'

            else:
                should_retry = True
                reason = 'the server reported an unknown error'

            return (got_session, (should_retry, reason, error_code))

        return (False, (True, "the server's response could not be understood", None))


class UploadFile(MmCall):
    """Called after getting a session to actually upload a file."""
    #TODO recent protocols use multipart encoding

    static_method = 'PUT'

    @classmethod
    def parse_response(cls, response):
        return cls._parse_json(response.text)

    @staticmethod
    def filter_response(res):
        return res

    @staticmethod
    def dynamic_headers(session_url, content_type, audio):
        return {'CONTENT-TYPE': content_type}

    @staticmethod
    def dynamic_url(session_url, content_type, audio):
        #this actually includes params, but easier to pass them straight through
        return session_url

    @staticmethod
    def dynamic_data(session_url, content_type, audio):
        return audio


class ProvideSample(MmCall):
    """Give the server a scan and match sample.
    The sample is a 128k mp3 slice of the file, usually 15 seconds long."""

    static_method = 'POST'
    static_params = {'version': 1}
    static_url = _android_url + 'sample'
    static_verify = False

    @staticmethod
    @pb
    def dynamic_data(filepath, server_challenge, track, uploader_id, mock_sample=None):
        """Raise IOError on transcoding problems, or ValueError for invalid input.

        :param mock_sample: if provided, will be sent in place of a proper sample

        """
        msg = upload_pb2.UploadSampleRequest()

        msg.uploader_id = uploader_id

        sample_msg = upload_pb2.TrackSample()
        sample_msg.track.CopyFrom(track)
        sample_msg.signed_challenge_info.CopyFrom(server_challenge)

        sample_spec = server_challenge.challenge_info  # convenience

        if mock_sample is None:
            #The sample is simply a small (usually 15 second) clip of the song,
            # transcoded into 128kbs mp3. The server dictates where the cut should be made.
            sample_msg.sample = utils.transcode_to_mp3(
                filepath, quality='128k',
                slice_start=sample_spec.start_millis / 1000,
                slice_duration=sample_spec.duration_millis / 1000
            )
        else:
            sample_msg.sample = mock_sample

        #You can provide multiple samples; I just provide one at a time.
        msg.track_sample.extend([sample_msg])

        return msg


class UpdateUploadState(MmCall):
    """Notify the server that we will be starting/stopping/pausing our upload.

    I believe this is used for the webclient 'currently uploading' widget, but that might also be
    the current_uploading information.
    """

    static_method = 'POST'
    static_params = {'version': 1}
    static_url = _android_url + 'sample'
    static_verify = False

    @staticmethod
    @pb
    def dynamic_data(to_state, uploader_id):
        """Raise ValueError on problems.

        :param to_state: one of 'start', 'paused', or 'stopped'
        """

        msg = upload_pb2.UpdateUploadStateRequest()
        msg.uploader_id = uploader_id

        try:
            state = getattr(upload_pb2.UpdateUploadStateRequest, to_state.upper())
        except AttributeError as e:
            raise ValueError(str(e))

        msg.state = state

        return msg


class CancelUploadJobs(MmCall):
    """This call will cancel any outstanding upload jobs (ie from GetJobs).
    The Music Manager only calls it when the user changes the location of their local collection.

    It doesn't actually return anything useful."""

    static_method = 'POST'
    static_url = _android_url + 'deleteuploadrequested'
    static_verify = False

    @staticmethod
    @pb
    def dynamic_data(uploader_id):
        """
        :param uploader_id: id
        """

        msg = upload_pb2.DeleteUploadRequestedRequest()  # what a mouthful!
        msg.uploader_id = uploader_id

        return msg


class ListTracks(MmCall):
    """List all tracks. Returns a subset of all available metadata.
    Can optionally filter for only free/purchased tracks."""

    res_msg_type = download_pb2.GetTracksToExportResponse

    static_method = 'POST'
    static_url = 'https://music.google.com/music/exportids'

    # example response:
    # download_track_info {
    #   id: "970d9e51-b392-3857-897a-170e456cba60"
    #   title: "Temporary Trip"
    #   album: "Pay Attention"
    #   album_artist: "The Mighty Mighty Bosstones"
    #   artist: "The Mighty Mighty Bosstones"
    #   track_number: 14
    #   track_size: 3577382
    # }

    @staticmethod
    def dynamic_headers(client_id, *args, **kwargs):
        return {'X-Device-ID': client_id}

    @staticmethod
    @pb
    def dynamic_data(client_id, cont_token=None, export_type=1, updated_min=0):
        """Works similarly to the webclient method.
        Chunks are up to 1000 tracks.


        :param client_id: an authorized uploader_id
        :param cont_token: (optional) token to get the next library chunk.
        :param export_type: 1='ALL', 2='PURCHASED_AND_PROMOTIONAL'
        :param updated_min: likely a timestamp; never seen an example of this != 0
        """

        msg = download_pb2.GetTracksToExportRequest()
        msg.client_id = client_id
        msg.export_type = export_type

        if cont_token is not None:
            msg.continuation_token = cont_token

        msg.updated_min = updated_min

        return msg

    @classmethod
    def check_success(cls, response, msg):
        if msg.status != download_pb2.GetTracksToExportResponse.OK:
            enum_desc = download_pb2._GETTRACKSTOEXPORTRESPONSE.enum_types[0]
            res_name = enum_desc.values_by_number[msg.status].name

            raise CallFailure(
                "Track export (list) error code %s: %s." % (
                    msg.status, res_name
                ), cls.__name__
            )

    #TODO
    @staticmethod
    def filter_response(msg):
        """Only log a summary."""

        cont_token = None
        if msg.HasField('continuation_token'):
            cont_token = msg.continuation_token

        updated_min = None
        if msg.HasField('updated_min'):
            updated_min = msg.updated_min

        return "<%s songs>, updated_min: %r, continuation_token: %r" % (
            len(msg.download_track_info),
            updated_min,
            cont_token)


class GetDownloadLink(MmCall):
    """Get a url where a track can be downloaded.

    Auth is not needed to retrieve the resulting url."""

    static_method = 'GET'
    static_headers = {}
    static_params = {'version': 2}
    static_url = 'https://music.google.com/music/export'

    @staticmethod
    def dynamic_headers(sid, client_id):
        return {'X-Device-ID': client_id}

    @staticmethod
    def dynamic_params(sid, client_id):
        return {'songid': sid}

    @classmethod
    def parse_response(cls, response):
        return cls._parse_json(response.text)

    @staticmethod
    def filter_response(res):
        return res


class DownloadTrack(MmCall):
    """Given a url, retrieve a track. Unlike the Webclient, this
    requires authentication.

    The entire Requests.Response is returned."""

    static_method = 'GET'

    @staticmethod
    def dynamic_url(url):
        """
        :param url: result of a call to GetDownloadLink
        """
        return url

    @classmethod
    def parse_response(cls, response):
        return response

    @staticmethod
    def filter_response(res):
        return "code: %s; size: %s bytes; disposition: %r" % (
            res.status_code,
            res.headers['Content-Length'],
            res.headers['Content-Disposition'])

########NEW FILE########
__FILENAME__ = shared
# -*- coding: utf-8 -*-

"""Definitions shared by multiple clients."""

from collections import namedtuple
import sys

from google.protobuf.descriptor import FieldDescriptor

import gmusicapi
from gmusicapi.compat import json
from gmusicapi.exceptions import (
    CallFailure, ParseException, ValidationException,
)
from gmusicapi.utils import utils

import requests

log = utils.DynamicClientLogger(__name__)

_auth_names = ('xt', 'sso', 'oauth')

"""
  AuthTypes has fields for each type of auth, each of which store a bool:
    xt: webclient xsrf param/cookie
    sso: webclient Authorization header
    oauth: musicmanager oauth header
"""
AuthTypes = namedtuple('AuthTypes', _auth_names)


def authtypes(**kwargs):
    """Convinience factory for AuthTypes that defaults authtypes to False."""
    for name in _auth_names:
        if name not in kwargs:
            kwargs[name] = False

    return AuthTypes(**kwargs)


class BuildRequestMeta(type):
    """Metaclass to create build_request from static/dynamic config."""

    def __new__(cls, name, bases, dct):
        #To not mess with mro and inheritance, build the class first.
        new_cls = super(BuildRequestMeta, cls).__new__(cls, name, bases, dct)

        merge_keys = ('headers', 'params')
        all_keys = ('method', 'url', 'files', 'data', 'verify', 'allow_redirects') + merge_keys

        config = {}  # stores key: val for static or f(*args, **kwargs) -> val for dyn
        dyn = lambda key: 'dynamic_' + key
        stat = lambda key: 'static_' + key
        has_key = lambda key: hasattr(new_cls, key)
        get_key = lambda key: getattr(new_cls, key)

        for key in all_keys:
            if not has_key(dyn(key)) and not has_key(stat(key)):
                continue  # this key will be ignored; requests will default it

            if has_key(dyn(key)):
                config[key] = get_key(dyn(key))
            else:
                config[key] = get_key(stat(key))

        for key in merge_keys:
            #merge case: dyn took precedence above, but stat also exists
            if has_key(dyn(key)) and has_key(stat(key)):
                def key_closure(stat_val=get_key(stat(key)), dyn_func=get_key(dyn(key))):
                    def build_key(*args, **kwargs):
                        dyn_val = dyn_func(*args, **kwargs)

                        stat_val.update(dyn_val)
                        return stat_val
                    return build_key
                config[key] = key_closure()

        #To explain some of the funkiness wrt closures, see:
        # http://stackoverflow.com/questions/233673/lexical-closures-in-python

        #create the actual build_request method
        def req_closure(config=config):
            def build_request(cls, *args, **kwargs):
                req_kwargs = {}
                for key, val in config.items():
                    if hasattr(val, '__call__'):
                        val = val(*args, **kwargs)

                    req_kwargs[key] = val

                return req_kwargs
            return build_request

        new_cls.build_request = classmethod(req_closure())

        return new_cls


class Call(object):
    """
    Clients should use Call.perform().

    Calls define how to build their requests through static and dynamic data.
    For example, a request might always send some user-agent: this is static.
    Or, it might need the name of a song to modify: this is dynamic.

    Specially named fields define the data, and correspond with requests.Request kwargs:
        method: eg 'GET' or 'POST'
        url: string
        files: dictionary of {filename: fileobject} files to multipart upload.
        data: the body of the request
                If a dictionary is provided, form-encoding will take place.
                A string will be sent as-is.
        verify: if True, verify SSL certs
        params (m): dictionary of URL parameters to append to the URL.
        headers (m): dictionary

    Static data shold prepends static_ to a field:
        class SomeCall(Call):
            static_url = 'http://foo.com/thiscall'

    And dynamic data prepends dynamic_ to a method:
        class SomeCall(Call):
            #*args, **kwargs are passed from SomeCall.build_request (and Call.perform)
            def dynamic_url(endpoint):
                return 'http://foo.com/' + endpoint

    Dynamic data takes precedence over static if both exist,
     except for attributes marked with (m) above. These get merged, with dynamic overriding
     on key conflicts (though all this really shouldn't be relied on).

    Here's a contrived example that merges static and dynamic headers:
        class SomeCall(Call):
            static_headers = {'user-agent': "I'm totally a Google client!"}

            @classmethod
            def dynamic_headers(cls, keep_alive=False):
                return {'Connection': keep_alive}

    If neither a static nor dynamic member is defined,
    the param is not used to create the requests.Request.

    Calls declare the kind of auth they require with an AuthTypes object named required_auth.

    Calls must define parse_response.
    Calls can also define filter_response, validate and check_success.

    Calls are organized semantically, so one endpoint might have multiple calls.
    """

    __metaclass__ = BuildRequestMeta

    gets_logged = True

    required_auth = authtypes()  # all false by default

    @classmethod
    def parse_response(cls, response):
        """Parses a requests.Response to data."""
        raise NotImplementedError

    @classmethod
    def validate(cls, response, msg):
        """Raise ValidationException on problems.

        :param response: a requests.Response
        :param msg: the result of parse_response on response
        """
        pass

    @classmethod
    def check_success(cls, response, msg):
        """Raise CallFailure on problems.

        :param response: a requests.Response
        :param msg: the result of parse_response on response
        """
        pass

    @classmethod
    def filter_response(cls, msg):
        """Return a version of a parsed response appropriate for logging."""
        return msg  # default to identity

    @classmethod
    def perform(cls, session, validate, *args, **kwargs):
        """Send, parse, validate and check success of this call.
        *args and **kwargs are passed to protocol.build_transaction.

        :param session: a PlaySession used to send this request.
        :param validate: if False, do not validate
        """
        #TODO link up these docs

        call_name = cls.__name__

        if cls.gets_logged:
            log.debug("%s(args=%s, kwargs=%s)",
                      call_name,
                      [utils.truncate(a) for a in args],
                      dict((k, utils.truncate(v)) for (k, v) in kwargs.items())
                      )
        else:
            log.debug("%s(<omitted>)", call_name)

        req_kwargs = cls.build_request(*args, **kwargs)

        response = session.send(req_kwargs, cls.required_auth)
        #TODO trim the logged response if it's huge?

        safe_req_kwargs = req_kwargs.copy()
        if safe_req_kwargs.get('headers', {}).get('Authorization', None) is not None:
            safe_req_kwargs['headers']['Authorization'] = '<omitted>'

        # check response code
        try:
            response.raise_for_status()
        except requests.HTTPError as e:
            err_msg = str(e)

            if cls.gets_logged:
                err_msg += "\n(requests kwargs: %r)" % (safe_req_kwargs)
                err_msg += "\n(response was: %r)" % response.content

            raise CallFailure(err_msg, call_name)

        try:
            parsed_response = cls.parse_response(response)
        except ParseException:
            err_msg = ("the server's response could not be understood."
                       " The call may still have succeeded, but it's unlikely.")
            if cls.gets_logged:
                err_msg += "\n(requests kwargs: %r)" % (safe_req_kwargs)
                err_msg += "\n(response was: %r)" % response.content
                log.exception("could not parse %s response: %r", call_name, response.content)
            else:
                log.exception("could not parse %s response: (omitted)", call_name)

            raise CallFailure(err_msg, call_name)

        if cls.gets_logged:
            log.debug(cls.filter_response(parsed_response))

        try:
            #order is important; validate only has a schema for a successful response
            cls.check_success(response, parsed_response)
            if validate:
                cls.validate(response, parsed_response)
        except CallFailure as e:
            if not cls.gets_logged:
                raise

            # otherwise, reraise a new exception with our req/res context
            trace = sys.exc_info()[2]
            err_msg = ("{e_message}\n"
                       "(requests kwargs: {req_kwargs!r})\n"
                       "(response was: {content!r})").format(
                           e_message=e.message,
                           req_kwargs=safe_req_kwargs,
                           content=response.content)
            raise CallFailure(err_msg, e.callname), None, trace

        except ValidationException as e:
            #TODO shouldn't be using formatting
            err_msg = "the response format for %s was not recognized." % call_name
            err_msg += "\n\n%s\n" % e

            if cls.gets_logged:
                raw_response = response.content

                if len(raw_response) > 1000:
                    raw_response = raw_response[:1000] + '...'

                err_msg += ("\nFirst, try the develop branch."
                            " If you can recreate this error with the most recent code"
                            " please [create an issue](http://goo.gl/qbAW8) that includes"
                            " the above ValidationException"
                            " and the following request/response:\n%r\n\n%r\n"
                            "\nA traceback follows:\n") % (safe_req_kwargs, raw_response)

            log.exception(err_msg)

        return parsed_response

    @staticmethod
    def _parse_json(text):
        try:
            return json.loads(text)
        except ValueError as e:
            trace = sys.exc_info()[2]
            raise ParseException(str(e)), None, trace

    @staticmethod
    def _filter_proto(msg, make_copy=True):
        """Filter all byte fields in the message and submessages."""
        filtered = msg
        if make_copy:
            filtered = msg.__class__()
            filtered.CopyFrom(msg)

        fields = filtered.ListFields()

        #eg of filtering a specific field
        #if any(fd.name == 'field_name' for fd, val in fields):
        #    filtered.field_name = '<name>'

        #Filter all byte fields.
        for field_name, val in ((fd.name, val) for fd, val in fields
                                if fd.type == FieldDescriptor.TYPE_BYTES):
            setattr(filtered, field_name, "<%s bytes>" % len(val))

        #Filter submessages.
        for field in (val for fd, val in fields
                      if fd.type == FieldDescriptor.TYPE_MESSAGE):

            #protobuf repeated api is bad for reflection
            is_repeated = hasattr(field, '__len__')

            if not is_repeated:
                Call._filter_proto(field, make_copy=False)

            else:
                for i in range(len(field)):
                    #repeatedComposite does not allow setting
                    old_fields = [f for f in field]
                    del field[:]

                    field.extend([Call._filter_proto(f, make_copy=False)
                                  for f in old_fields])

        return filtered


class ClientLogin(Call):
    """Performs `Google ClientLogin
    <https://developers.google.com/accounts/docs/AuthForInstalledApps#ClientLogin>`__."""

    gets_logged = False

    static_method = 'POST'
    #static_headers = {'User-agent': 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1'}
    static_url = 'https://www.google.com/accounts/ClientLogin'

    @classmethod
    def dynamic_data(cls, Email, Passwd, accountType='HOSTED_OR_GOOGLE',
                     service='sj', source=None,
                     logintoken=None, logincaptcha=None):
        """Params align with those in the actual request.

        If *source* is ``None``, ``'gmusicapi-<version>'`` is used.

        Captcha requests are not yet implemented.
        """
        if logintoken is not None or logincaptcha is not None:
            raise ValueError('ClientLogin captcha handling is not yet implemented.')

        if source is None:
            source = 'gmusicapi-' + gmusicapi.__version__

        return dict(
            (name, val) for (name, val) in locals().items()
            if name in set(('Email', 'Passwd', 'accountType', 'service', 'source',
                            'logintoken', 'logincaptcha'))
        )

    @classmethod
    def parse_response(cls, response):
        """Return a dictionary of response key/vals.

        A successful login will have SID, LSID, and Auth keys.
        """

        # responses are formatted as, eg:
        #    SID=DQAAAGgA...7Zg8CTN
        #    LSID=DQAAAGsA...lk8BBbG
        #    Auth=DQAAAGgA...dk3fA5N
        # or:
        #    Url=http://www.google.com/login/captcha
        #    Error=CaptchaRequired
        #    CaptchaToken=DQAAAGgA...dkI1LK9
        #    CaptchaUrl=Captcha?ctoken=HiteT...

        ret = {}
        for line in response.text.split('\n'):
            if '=' in line:
                var, val = line.split('=', 1)
                ret[var] = val

        return ret

    @classmethod
    def check_succes(cls, response, msg):
        if response.status_code == 200:
            raise CallFailure("status code %s != 200" % response.status_code, cls.__name__)

########NEW FILE########
__FILENAME__ = uits_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!

from google.protobuf import descriptor
from google.protobuf import message
from google.protobuf import reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)



DESCRIPTOR = descriptor.FileDescriptor(
  name='uits.proto',
  package='',
  serialized_pb='\n\nuits.proto\"k\n\tProductId\x12\x1d\n\x04type\x18\x01 \x02(\x0e\x32\x0f.ProductId.Type\x12\x18\n\tcompleted\x18\x02 \x01(\x08:\x05\x66\x61lse\x12\n\n\x02id\x18\x03 \x02(\t\"\x19\n\x04Type\x12\x07\n\x03UPC\x10\x01\x12\x08\n\x04GRID\x10\x02\"D\n\x07\x41ssetId\x12\x1b\n\x04type\x18\x01 \x02(\x0e\x32\r.AssetId.Type\x12\n\n\x02id\x18\x02 \x02(\t\"\x10\n\x04Type\x12\x08\n\x04ISRC\x10\x01\"/\n\rTransactionId\x12\x12\n\x07version\x18\x01 \x02(\t:\x01\x31\x12\n\n\x02id\x18\x02 \x02(\t\"d\n\x07MediaId\x12.\n\x0e\x61lgorithm_type\x18\x01 \x02(\x0e\x32\x16.MediaId.AlgorithmType\x12\x0c\n\x04hash\x18\x02 \x02(\t\"\x1b\n\rAlgorithmType\x12\n\n\x06SHA256\x10\x01\"\x8b\x01\n\x07UrlInfo\x12\x1b\n\x04type\x18\x01 \x02(\x0e\x32\r.UrlInfo.Type\x12\x0b\n\x03url\x18\x02 \x02(\t\"V\n\x04Type\x12\x08\n\x04WCOM\x10\x01\x12\x08\n\x04WCOP\x10\x02\x12\x08\n\x04WOAF\x10\x03\x12\x08\n\x04WOAR\x10\x04\x12\x08\n\x04WOAS\x10\x05\x12\x08\n\x04WORS\x10\x06\x12\x08\n\x04WPAY\x10\x07\x12\x08\n\x04WPUB\x10\x08\"\x94\x01\n\x0f\x43opyrightStatus\x12#\n\x04type\x18\x01 \x02(\x0e\x32\x15.CopyrightStatus.Type\x12\x11\n\tcopyright\x18\x02 \x01(\t\"I\n\x04Type\x12\x0f\n\x0bUNSPECIFIED\x10\x01\x12\x15\n\x11\x41LLRIGHTSRESERVED\x10\x02\x12\x0e\n\nPRERELEASE\x10\x03\x12\t\n\x05OTHER\x10\x04\"$\n\x05\x45xtra\x12\x0c\n\x04type\x18\x01 \x02(\t\x12\r\n\x05value\x18\x02 \x02(\t\"\xb5\x03\n\x0cUitsMetadata\x12\r\n\x05nonce\x18\x01 \x02(\t\x12\x16\n\x0e\x64istributor_id\x18\x02 \x02(\t\x12\x18\n\x10transaction_date\x18\x03 \x02(\t\x12\x1e\n\nproduct_id\x18\x04 \x02(\x0b\x32\n.ProductId\x12\x1a\n\x08\x61sset_id\x18\x05 \x02(\x0b\x32\x08.AssetId\x12&\n\x0etransaction_id\x18\x06 \x02(\x0b\x32\x0e.TransactionId\x12\x1a\n\x08media_id\x18\x07 \x02(\x0b\x32\x08.MediaId\x12\x1a\n\x08url_info\x18\x08 \x01(\x0b\x32\x08.UrlInfo\x12\x42\n\x16parental_advisory_type\x18\t \x01(\x0e\x32\".UitsMetadata.ParentalAdvisoryType\x12*\n\x10\x63opyright_status\x18\n \x01(\x0b\x32\x10.CopyrightStatus\x12\x15\n\x05\x65xtra\x18\x0b \x03(\x0b\x32\x06.Extra\"A\n\x14ParentalAdvisoryType\x12\x0f\n\x0bUNSPECIFIED\x10\x01\x12\x0c\n\x08\x45XPLICIT\x10\x02\x12\n\n\x06\x45\x44ITED\x10\x03\"\xf5\x01\n\rUitsSignature\x12\x34\n\x0e\x61lgorithm_type\x18\x01 \x02(\x0e\x32\x1c.UitsSignature.AlgorithmType\x12\x42\n\x15\x63\x61nonicalization_type\x18\x02 \x02(\x0e\x32#.UitsSignature.CanonicalizationType\x12\x0e\n\x06key_id\x18\x03 \x02(\t\x12\r\n\x05value\x18\x04 \x02(\t\")\n\rAlgorithmType\x12\x0b\n\x07RSA2048\x10\x01\x12\x0b\n\x07\x44SA2048\x10\x02\" \n\x14\x43\x61nonicalizationType\x12\x08\n\x04NONE\x10\x01\"J\n\x04Uits\x12\x1f\n\x08metadata\x18\x01 \x02(\x0b\x32\r.UitsMetadata\x12!\n\tsignature\x18\x02 \x02(\x0b\x32\x0e.UitsSignature')



_PRODUCTID_TYPE = descriptor.EnumDescriptor(
  name='Type',
  full_name='ProductId.Type',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='UPC', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GRID', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=96,
  serialized_end=121,
)

_ASSETID_TYPE = descriptor.EnumDescriptor(
  name='Type',
  full_name='AssetId.Type',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='ISRC', index=0, number=1,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=175,
  serialized_end=191,
)

_MEDIAID_ALGORITHMTYPE = descriptor.EnumDescriptor(
  name='AlgorithmType',
  full_name='MediaId.AlgorithmType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='SHA256', index=0, number=1,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=315,
  serialized_end=342,
)

_URLINFO_TYPE = descriptor.EnumDescriptor(
  name='Type',
  full_name='UrlInfo.Type',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='WCOM', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WCOP', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WOAF', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WOAR', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WOAS', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WORS', index=5, number=6,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WPAY', index=6, number=7,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='WPUB', index=7, number=8,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=398,
  serialized_end=484,
)

_COPYRIGHTSTATUS_TYPE = descriptor.EnumDescriptor(
  name='Type',
  full_name='CopyrightStatus.Type',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='UNSPECIFIED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALLRIGHTSRESERVED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PRERELEASE', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='OTHER', index=3, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=562,
  serialized_end=635,
)

_UITSMETADATA_PARENTALADVISORYTYPE = descriptor.EnumDescriptor(
  name='ParentalAdvisoryType',
  full_name='UitsMetadata.ParentalAdvisoryType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='UNSPECIFIED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='EXPLICIT', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='EDITED', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=1048,
  serialized_end=1113,
)

_UITSSIGNATURE_ALGORITHMTYPE = descriptor.EnumDescriptor(
  name='AlgorithmType',
  full_name='UitsSignature.AlgorithmType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='RSA2048', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='DSA2048', index=1, number=2,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=1286,
  serialized_end=1327,
)

_UITSSIGNATURE_CANONICALIZATIONTYPE = descriptor.EnumDescriptor(
  name='CanonicalizationType',
  full_name='UitsSignature.CanonicalizationType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='NONE', index=0, number=1,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=1329,
  serialized_end=1361,
)


_PRODUCTID = descriptor.Descriptor(
  name='ProductId',
  full_name='ProductId',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='type', full_name='ProductId.type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='completed', full_name='ProductId.completed', index=1,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=True, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='id', full_name='ProductId.id', index=2,
      number=3, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _PRODUCTID_TYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=14,
  serialized_end=121,
)


_ASSETID = descriptor.Descriptor(
  name='AssetId',
  full_name='AssetId',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='type', full_name='AssetId.type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='id', full_name='AssetId.id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _ASSETID_TYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=123,
  serialized_end=191,
)


_TRANSACTIONID = descriptor.Descriptor(
  name='TransactionId',
  full_name='TransactionId',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='version', full_name='TransactionId.version', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=True, default_value=unicode("1", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='id', full_name='TransactionId.id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=193,
  serialized_end=240,
)


_MEDIAID = descriptor.Descriptor(
  name='MediaId',
  full_name='MediaId',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='algorithm_type', full_name='MediaId.algorithm_type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='hash', full_name='MediaId.hash', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _MEDIAID_ALGORITHMTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=242,
  serialized_end=342,
)


_URLINFO = descriptor.Descriptor(
  name='UrlInfo',
  full_name='UrlInfo',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='type', full_name='UrlInfo.type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='url', full_name='UrlInfo.url', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _URLINFO_TYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=345,
  serialized_end=484,
)


_COPYRIGHTSTATUS = descriptor.Descriptor(
  name='CopyrightStatus',
  full_name='CopyrightStatus',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='type', full_name='CopyrightStatus.type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='copyright', full_name='CopyrightStatus.copyright', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _COPYRIGHTSTATUS_TYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=487,
  serialized_end=635,
)


_EXTRA = descriptor.Descriptor(
  name='Extra',
  full_name='Extra',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='type', full_name='Extra.type', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='value', full_name='Extra.value', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=637,
  serialized_end=673,
)


_UITSMETADATA = descriptor.Descriptor(
  name='UitsMetadata',
  full_name='UitsMetadata',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='nonce', full_name='UitsMetadata.nonce', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='distributor_id', full_name='UitsMetadata.distributor_id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='transaction_date', full_name='UitsMetadata.transaction_date', index=2,
      number=3, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='product_id', full_name='UitsMetadata.product_id', index=3,
      number=4, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='asset_id', full_name='UitsMetadata.asset_id', index=4,
      number=5, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='transaction_id', full_name='UitsMetadata.transaction_id', index=5,
      number=6, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='media_id', full_name='UitsMetadata.media_id', index=6,
      number=7, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='url_info', full_name='UitsMetadata.url_info', index=7,
      number=8, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='parental_advisory_type', full_name='UitsMetadata.parental_advisory_type', index=8,
      number=9, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='copyright_status', full_name='UitsMetadata.copyright_status', index=9,
      number=10, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='extra', full_name='UitsMetadata.extra', index=10,
      number=11, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _UITSMETADATA_PARENTALADVISORYTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=676,
  serialized_end=1113,
)


_UITSSIGNATURE = descriptor.Descriptor(
  name='UitsSignature',
  full_name='UitsSignature',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='algorithm_type', full_name='UitsSignature.algorithm_type', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='canonicalization_type', full_name='UitsSignature.canonicalization_type', index=1,
      number=2, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='key_id', full_name='UitsSignature.key_id', index=2,
      number=3, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='value', full_name='UitsSignature.value', index=3,
      number=4, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _UITSSIGNATURE_ALGORITHMTYPE,
    _UITSSIGNATURE_CANONICALIZATIONTYPE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1116,
  serialized_end=1361,
)


_UITS = descriptor.Descriptor(
  name='Uits',
  full_name='Uits',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='metadata', full_name='Uits.metadata', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='signature', full_name='Uits.signature', index=1,
      number=2, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1363,
  serialized_end=1437,
)

_PRODUCTID.fields_by_name['type'].enum_type = _PRODUCTID_TYPE
_PRODUCTID_TYPE.containing_type = _PRODUCTID;
_ASSETID.fields_by_name['type'].enum_type = _ASSETID_TYPE
_ASSETID_TYPE.containing_type = _ASSETID;
_MEDIAID.fields_by_name['algorithm_type'].enum_type = _MEDIAID_ALGORITHMTYPE
_MEDIAID_ALGORITHMTYPE.containing_type = _MEDIAID;
_URLINFO.fields_by_name['type'].enum_type = _URLINFO_TYPE
_URLINFO_TYPE.containing_type = _URLINFO;
_COPYRIGHTSTATUS.fields_by_name['type'].enum_type = _COPYRIGHTSTATUS_TYPE
_COPYRIGHTSTATUS_TYPE.containing_type = _COPYRIGHTSTATUS;
_UITSMETADATA.fields_by_name['product_id'].message_type = _PRODUCTID
_UITSMETADATA.fields_by_name['asset_id'].message_type = _ASSETID
_UITSMETADATA.fields_by_name['transaction_id'].message_type = _TRANSACTIONID
_UITSMETADATA.fields_by_name['media_id'].message_type = _MEDIAID
_UITSMETADATA.fields_by_name['url_info'].message_type = _URLINFO
_UITSMETADATA.fields_by_name['parental_advisory_type'].enum_type = _UITSMETADATA_PARENTALADVISORYTYPE
_UITSMETADATA.fields_by_name['copyright_status'].message_type = _COPYRIGHTSTATUS
_UITSMETADATA.fields_by_name['extra'].message_type = _EXTRA
_UITSMETADATA_PARENTALADVISORYTYPE.containing_type = _UITSMETADATA;
_UITSSIGNATURE.fields_by_name['algorithm_type'].enum_type = _UITSSIGNATURE_ALGORITHMTYPE
_UITSSIGNATURE.fields_by_name['canonicalization_type'].enum_type = _UITSSIGNATURE_CANONICALIZATIONTYPE
_UITSSIGNATURE_ALGORITHMTYPE.containing_type = _UITSSIGNATURE;
_UITSSIGNATURE_CANONICALIZATIONTYPE.containing_type = _UITSSIGNATURE;
_UITS.fields_by_name['metadata'].message_type = _UITSMETADATA
_UITS.fields_by_name['signature'].message_type = _UITSSIGNATURE
DESCRIPTOR.message_types_by_name['ProductId'] = _PRODUCTID
DESCRIPTOR.message_types_by_name['AssetId'] = _ASSETID
DESCRIPTOR.message_types_by_name['TransactionId'] = _TRANSACTIONID
DESCRIPTOR.message_types_by_name['MediaId'] = _MEDIAID
DESCRIPTOR.message_types_by_name['UrlInfo'] = _URLINFO
DESCRIPTOR.message_types_by_name['CopyrightStatus'] = _COPYRIGHTSTATUS
DESCRIPTOR.message_types_by_name['Extra'] = _EXTRA
DESCRIPTOR.message_types_by_name['UitsMetadata'] = _UITSMETADATA
DESCRIPTOR.message_types_by_name['UitsSignature'] = _UITSSIGNATURE
DESCRIPTOR.message_types_by_name['Uits'] = _UITS

class ProductId(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PRODUCTID
  
  # @@protoc_insertion_point(class_scope:ProductId)

class AssetId(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ASSETID
  
  # @@protoc_insertion_point(class_scope:AssetId)

class TransactionId(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRANSACTIONID
  
  # @@protoc_insertion_point(class_scope:TransactionId)

class MediaId(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _MEDIAID
  
  # @@protoc_insertion_point(class_scope:MediaId)

class UrlInfo(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _URLINFO
  
  # @@protoc_insertion_point(class_scope:UrlInfo)

class CopyrightStatus(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _COPYRIGHTSTATUS
  
  # @@protoc_insertion_point(class_scope:CopyrightStatus)

class Extra(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _EXTRA
  
  # @@protoc_insertion_point(class_scope:Extra)

class UitsMetadata(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UITSMETADATA
  
  # @@protoc_insertion_point(class_scope:UitsMetadata)

class UitsSignature(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UITSSIGNATURE
  
  # @@protoc_insertion_point(class_scope:UitsSignature)

class Uits(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UITS
  
  # @@protoc_insertion_point(class_scope:Uits)

# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = upload_pb2
# Generated by the protocol buffer compiler.  DO NOT EDIT!

from google.protobuf import descriptor
from google.protobuf import message
from google.protobuf import reflection
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)


import locker_pb2

DESCRIPTOR = descriptor.FileDescriptor(
  name='upload.proto',
  package='',
  serialized_pb='\n\x0cupload.proto\x1a\x0clocker.proto\"\x99\x01\n\x0eResponseStatus\x12\x33\n\rresponse_code\x18\x01 \x02(\x0e\x32\x1c.ResponseStatus.ResponseCode\"R\n\x0cResponseCode\x12\x06\n\x02OK\x10\x01\x12\x12\n\x0e\x41LREADY_EXISTS\x10\x02\x12\x0e\n\nSOFT_ERROR\x10\x03\x12\x16\n\x12METADATA_TOO_LARGE\x10\x04\"\x8f\x01\n\x0fUploadOperation\x12-\n\toperation\x18\x01 \x02(\x0e\x32\x1a.UploadOperation.Operation\"M\n\tOperation\x12\x14\n\x10OPERATION_CREATE\x10\x01\x12\x14\n\x10OPERATION_MODIFY\x10\x02\x12\x14\n\x10OPERATION_DELETE\x10\x03\"\xa5\x01\n\rChallengeInfo\x12\x17\n\x0f\x63lient_track_id\x18\x01 \x02(\t\x12\x14\n\x0cstart_millis\x18\x02 \x02(\x05\x12\x17\n\x0f\x64uration_millis\x18\x03 \x02(\x05\x12\x19\n\x11\x63hallenge_user_id\x18\x04 \x01(\t\x12\x1b\n\x13\x63hallenge_timestamp\x18\x05 \x01(\x03\x12\x14\n\x0c\x65xpect_match\x18\x06 \x01(\x08\"P\n\x13SignedChallengeInfo\x12&\n\x0e\x63hallenge_info\x18\x01 \x02(\x0b\x32\x0e.ChallengeInfo\x12\x11\n\tsignature\x18\x02 \x02(\x0c\"\xb9\x01\n\x0bTrackSample\x12\x15\n\x05track\x18\x01 \x02(\x0b\x32\x06.Track\x12\x33\n\x15signed_challenge_info\x18\x02 \x02(\x0b\x32\x14.SignedChallengeInfo\x12\x0e\n\x06sample\x18\x03 \x02(\x0c\x12)\n\rsample_format\x18\x04 \x01(\x0e\x32\x12.Track.ContentType\x12#\n\x0euser_album_art\x18\x05 \x01(\x0b\x32\x0b.ImageUnion\"u\n\x15UploadPlaylistRequest\x12*\n\x10upload_operation\x18\x01 \x02(\x0b\x32\x10.UploadOperation\x12\x1b\n\x08playlist\x18\x02 \x03(\x0b\x32\t.Playlist\x12\x13\n\x0buploader_id\x18\x03 \x02(\t\"b\n\x10PlaylistResponse\x12(\n\x0fresponse_status\x18\x01 \x02(\x0b\x32\x0f.ResponseStatus\x12\x11\n\tclient_id\x18\x02 \x01(\t\x12\x11\n\tserver_id\x18\x03 \x01(\t\"F\n\x16UploadPlaylistResponse\x12,\n\x11playlist_response\x18\x01 \x03(\x0b\x32\x11.PlaylistResponse\"\x85\x01\n\x1aUploadPlaylistEntryRequest\x12*\n\x10upload_operation\x18\x01 \x02(\x0b\x32\x10.UploadOperation\x12&\n\x0eplaylist_entry\x18\x02 \x03(\x0b\x32\x0e.PlaylistEntry\x12\x13\n\x0buploader_id\x18\x03 \x02(\t\"g\n\x15PlaylistEntryResponse\x12(\n\x0fresponse_status\x18\x01 \x02(\x0b\x32\x0f.ResponseStatus\x12\x11\n\tclient_id\x18\x02 \x01(\t\x12\x11\n\tserver_id\x18\x03 \x01(\t\"V\n\x1bUploadPlaylistEntryResponse\x12\x37\n\x17playlist_entry_response\x18\x01 \x03(\x0b\x32\x16.PlaylistEntryResponse\"C\n\x15UploadMetadataRequest\x12\x15\n\x05track\x18\x01 \x03(\x0b\x32\x06.Track\x12\x13\n\x0buploader_id\x18\x02 \x02(\t\"\x98\x01\n\x18UpdateUploadStateRequest\x12\x34\n\x05state\x18\x01 \x02(\x0e\x32%.UpdateUploadStateRequest.UploadState\x12\x13\n\x0buploader_id\x18\x02 \x02(\t\"1\n\x0bUploadState\x12\t\n\x05START\x10\x01\x12\n\n\x06PAUSED\x10\x02\x12\x0b\n\x07STOPPED\x10\x03\"M\n\x12\x43lientStateRequest\x12\x13\n\x0buploader_id\x18\x01 \x02(\t\x12\"\n\x1aget_purchased_tracks_since\x18\x02 \x01(\x03\"\xaf\x01\n\x13\x43lientStateResponse\x12\x1a\n\x12locker_track_limit\x18\x01 \x01(\x03\x12\x1c\n\x14user_songs_in_locker\x18\x02 \x01(\x03\x12\x1e\n\x16track_size_limit_in_mb\x18\x03 \x01(\x05\x12#\n\x1buser_purchased_tracks_since\x18\x04 \x01(\x03\x12\x19\n\x11total_track_count\x18\x05 \x01(\x03\"\x95\x01\n\x16UploadMetadataResponse\x12\x33\n\x15signed_challenge_info\x18\x01 \x03(\x0b\x32\x14.SignedChallengeInfo\x12\x11\n\tupload_id\x18\x02 \x03(\t\x12\x33\n\x15track_sample_response\x18\x03 \x03(\x0b\x32\x14.TrackSampleResponse\"\xa5\x03\n\x13TrackSampleResponse\x12\x17\n\x0f\x63lient_track_id\x18\x01 \x02(\t\x12\x38\n\rresponse_code\x18\x02 \x02(\x0e\x32!.TrackSampleResponse.ResponseCode\x12\x17\n\x0fserver_track_id\x18\x03 \x01(\t\x12\x15\n\ralbum_art_url\x18\x04 \x01(\t\x12\x14\n\x0c\x65xpect_match\x18\x05 \x01(\x08\"\xf4\x01\n\x0cResponseCode\x12\x0b\n\x07MATCHED\x10\x01\x12\x14\n\x10UPLOAD_REQUESTED\x10\x02\x12\x15\n\x11INVALID_SIGNATURE\x10\x03\x12\x12\n\x0e\x41LREADY_EXISTS\x10\x04\x12\x13\n\x0fTRANSIENT_ERROR\x10\x05\x12\x13\n\x0fPERMANENT_ERROR\x10\x06\x12\x1d\n\x19TRACK_COUNT_LIMIT_REACHED\x10\x07\x12\x16\n\x12REJECT_STORE_TRACK\x10\x08\x12\x1f\n\x1bREJECT_STORE_TRACK_BY_LABEL\x10\t\x12\x14\n\x10REJECT_DRM_TRACK\x10\n\"N\n\x13UploadSampleRequest\x12\"\n\x0ctrack_sample\x18\x01 \x03(\x0b\x32\x0c.TrackSample\x12\x13\n\x0buploader_id\x18\x02 \x02(\t\"K\n\x14UploadSampleResponse\x12\x33\n\x15track_sample_response\x18\x01 \x03(\x0b\x32\x14.TrackSampleResponse\";\n\nImageUnion\x12\x16\n\x0euser_album_art\x18\x01 \x01(\x0c\x12\x15\n\ralbum_art_url\x18\x02 \x01(\t\"\xaf\x07\n\x0eUploadResponse\x12\x33\n\rresponse_type\x18\x01 \x01(\x0e\x32\x1c.UploadResponse.ResponseType\x12\x32\n\x11metadata_response\x18\x02 \x01(\x0b\x32\x17.UploadMetadataResponse\x12\x32\n\x11playlist_response\x18\x03 \x01(\x0b\x32\x17.UploadPlaylistResponse\x12=\n\x17playlist_entry_response\x18\x04 \x01(\x0b\x32\x1c.UploadPlaylistEntryResponse\x12.\n\x0fsample_response\x18\x05 \x01(\x0b\x32\x15.UploadSampleResponse\x12*\n\x10getjobs_response\x18\x07 \x01(\x0b\x32\x10.GetJobsResponse\x12\x32\n\x14\x63lientstate_response\x18\x08 \x01(\x0b\x32\x14.ClientStateResponse\x12\x1d\n\x06policy\x18\x06 \x01(\x0b\x32\r.ClientPolicy\x12/\n\x0b\x61uth_status\x18\x0b \x01(\x0e\x32\x1a.UploadResponse.AuthStatus\x12\x12\n\nauth_error\x18\x0c \x01(\x08\"\xfa\x01\n\x0cResponseType\x12\x15\n\x11METADATA_RESPONSE\x10\x01\x12\x15\n\x11PLAYLIST_RESPONSE\x10\x02\x12\x1b\n\x17PLAYLIST_ENTRY_RESPONSE\x10\x03\x12\x13\n\x0fSAMPLE_RESPONSE\x10\x04\x12\x14\n\x10GETJOBS_RESPONSE\x10\x05\x12\x11\n\rAUTH_RESPONSE\x10\x06\x12\x19\n\x15\x43LIENT_STATE_RESPONSE\x10\x07\x12 \n\x1cUPDATE_UPLOAD_STATE_RESPONSE\x10\x08\x12$\n DELETE_UPLOAD_REQUESTED_RESPONSE\x10\t\"\xcf\x01\n\nAuthStatus\x12\x06\n\x02OK\x10\x08\x12\x15\n\x11MAX_LIMIT_REACHED\x10\t\x12!\n\x1d\x43LIENT_BOUND_TO_OTHER_ACCOUNT\x10\n\x12\x19\n\x15\x43LIENT_NOT_AUTHORIZED\x10\x0b\x12\"\n\x1eMAX_PER_MACHINE_USERS_EXCEEDED\x10\x0c\x12\x17\n\x13\x43LIENT_PLEASE_RETRY\x10\r\x12\x12\n\x0eNOT_SUBSCRIBED\x10\x0e\x12\x13\n\x0fINVALID_REQUEST\x10\x0f\"\x9c\x01\n\x0eTracksToUpload\x12\x11\n\tclient_id\x18\x01 \x02(\t\x12\x11\n\tserver_id\x18\x02 \x02(\t\x12+\n\x06status\x18\x05 \x02(\x0e\x32\x1b.TracksToUpload.TrackStatus\"7\n\x0bTrackStatus\x12\x12\n\x0e\x46ORCE_REUPLOAD\x10\x03\x12\x14\n\x10UPLOAD_REQUESTED\x10\x04\"%\n\x0eGetJobsRequest\x12\x13\n\x0buploader_id\x18\x01 \x02(\t\"X\n\x0fGetJobsResponse\x12)\n\x10tracks_to_upload\x18\x01 \x03(\x0b\x32\x0f.TracksToUpload\x12\x1a\n\x12get_tracks_success\x18\x02 \x02(\x08\";\n\rUpAuthRequest\x12\x13\n\x0buploader_id\x18\x01 \x02(\t\x12\x15\n\rfriendly_name\x18\x02 \x01(\t\"3\n\x1c\x44\x65leteUploadRequestedRequest\x12\x13\n\x0buploader_id\x18\x01 \x02(\t\"\x83\x02\n\x0c\x43lientPolicy\x12\x15\n\rpause_uploads\x18\x01 \x01(\x08\x12\r\n\x05\x61\x62ort\x18\x02 \x01(\x08\x12\x18\n\x10retry_in_minutes\x18\x03 \x01(\x05\x12\x1a\n\x12\x62\x61ndwidth_cap_kbps\x18\x04 \x01(\x05\x12\x17\n\x0fpause_downloads\x18\x05 \x01(\x08\x12#\n\x1b\x64ownload_bandwidth_cap_kbps\x18\x06 \x01(\x05\x12\x16\n\x0esend_analytics\x18\x07 \x01(\x08\x12\x15\n\ranalytics_url\x18\x08 \x01(\t\x12\x16\n\x0e\x65nable_gapless\x18\t \x01(\x08\x12\x12\n\nenable_m4p\x18\n \x01(\x08\"X\n\x1dUploadMetadataInternalRequest\x12\x0e\n\x06gaiaid\x18\x01 \x02(\x04\x12\'\n\x07request\x18\x02 \x02(\x0b\x32\x16.UploadMetadataRequest\"\xc3\x02\n\x13OverrideConfigValue\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t\x12\x37\n\x08priority\x18\x03 \x01(\x0e\x32%.OverrideConfigValue.OverridePriority\"\xd6\x01\n\x10OverridePriority\x12\x1d\n\x10\x44\x45\x46\x41ULT_PRIORITY\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x13\n\x0fLOWEST_PRIORITY\x10\x64\x12\x11\n\x0cLOW_PRIORITY\x10\xc8\x01\x12\x14\n\x0fMEDIUM_PRIORITY\x10\xac\x02\x12\x12\n\rHIGH_PRIORITY\x10\x90\x03\x12\x15\n\x10HIGHEST_PRIORITY\x10\xf4\x03\x12\x1c\n\x17\x44\x45\x46\x41ULT_SERVER_PRIORITY\x10\xac\x02\x12\x1c\n\x17\x44\x45\x46\x41ULT_CLIENT_PRIORITY\x10\x90\x03\"D\n\x1dOverrideConfigValueCollection\x12#\n\x05value\x18\x01 \x03(\x0b\x32\x14.OverrideConfigValue')



_RESPONSESTATUS_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='ResponseStatus.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALREADY_EXISTS', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='SOFT_ERROR', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='METADATA_TOO_LARGE', index=3, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=102,
  serialized_end=184,
)

_UPLOADOPERATION_OPERATION = descriptor.EnumDescriptor(
  name='Operation',
  full_name='UploadOperation.Operation',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OPERATION_CREATE', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='OPERATION_MODIFY', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='OPERATION_DELETE', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=253,
  serialized_end=330,
)

_UPDATEUPLOADSTATEREQUEST_UPLOADSTATE = descriptor.EnumDescriptor(
  name='UploadState',
  full_name='UpdateUploadStateRequest.UploadState',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='START', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PAUSED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='STOPPED', index=2, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=1563,
  serialized_end=1612,
)

_TRACKSAMPLERESPONSE_RESPONSECODE = descriptor.EnumDescriptor(
  name='ResponseCode',
  full_name='TrackSampleResponse.ResponseCode',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='MATCHED', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_REQUESTED', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='INVALID_SIGNATURE', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='ALREADY_EXISTS', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TRANSIENT_ERROR', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PERMANENT_ERROR', index=5, number=6,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='TRACK_COUNT_LIMIT_REACHED', index=6, number=7,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='REJECT_STORE_TRACK', index=7, number=8,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='REJECT_STORE_TRACK_BY_LABEL', index=8, number=9,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='REJECT_DRM_TRACK', index=9, number=10,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=2201,
  serialized_end=2445,
)

_UPLOADRESPONSE_RESPONSETYPE = descriptor.EnumDescriptor(
  name='ResponseType',
  full_name='UploadResponse.ResponseType',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='METADATA_RESPONSE', index=0, number=1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PLAYLIST_RESPONSE', index=1, number=2,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='PLAYLIST_ENTRY_RESPONSE', index=2, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='SAMPLE_RESPONSE', index=3, number=4,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='GETJOBS_RESPONSE', index=4, number=5,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='AUTH_RESPONSE', index=5, number=6,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CLIENT_STATE_RESPONSE', index=6, number=7,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPDATE_UPLOAD_STATE_RESPONSE', index=7, number=8,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='DELETE_UPLOAD_REQUESTED_RESPONSE', index=8, number=9,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=3149,
  serialized_end=3399,
)

_UPLOADRESPONSE_AUTHSTATUS = descriptor.EnumDescriptor(
  name='AuthStatus',
  full_name='UploadResponse.AuthStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='OK', index=0, number=8,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MAX_LIMIT_REACHED', index=1, number=9,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CLIENT_BOUND_TO_OTHER_ACCOUNT', index=2, number=10,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CLIENT_NOT_AUTHORIZED', index=3, number=11,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MAX_PER_MACHINE_USERS_EXCEEDED', index=4, number=12,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='CLIENT_PLEASE_RETRY', index=5, number=13,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='NOT_SUBSCRIBED', index=6, number=14,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='INVALID_REQUEST', index=7, number=15,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=3402,
  serialized_end=3609,
)

_TRACKSTOUPLOAD_TRACKSTATUS = descriptor.EnumDescriptor(
  name='TrackStatus',
  full_name='TracksToUpload.TrackStatus',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='FORCE_REUPLOAD', index=0, number=3,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='UPLOAD_REQUESTED', index=1, number=4,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=3713,
  serialized_end=3768,
)

_OVERRIDECONFIGVALUE_OVERRIDEPRIORITY = descriptor.EnumDescriptor(
  name='OverridePriority',
  full_name='OverrideConfigValue.OverridePriority',
  filename=None,
  file=DESCRIPTOR,
  values=[
    descriptor.EnumValueDescriptor(
      name='DEFAULT_PRIORITY', index=0, number=-1,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='LOWEST_PRIORITY', index=1, number=100,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='LOW_PRIORITY', index=2, number=200,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='MEDIUM_PRIORITY', index=3, number=300,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='HIGH_PRIORITY', index=4, number=400,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='HIGHEST_PRIORITY', index=5, number=500,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='DEFAULT_SERVER_PRIORITY', index=6, number=300,
      options=None,
      type=None),
    descriptor.EnumValueDescriptor(
      name='DEFAULT_CLIENT_PRIORITY', index=7, number=400,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=4475,
  serialized_end=4689,
)


_RESPONSESTATUS = descriptor.Descriptor(
  name='ResponseStatus',
  full_name='ResponseStatus',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_code', full_name='ResponseStatus.response_code', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _RESPONSESTATUS_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=31,
  serialized_end=184,
)


_UPLOADOPERATION = descriptor.Descriptor(
  name='UploadOperation',
  full_name='UploadOperation',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='operation', full_name='UploadOperation.operation', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _UPLOADOPERATION_OPERATION,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=187,
  serialized_end=330,
)


_CHALLENGEINFO = descriptor.Descriptor(
  name='ChallengeInfo',
  full_name='ChallengeInfo',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='client_track_id', full_name='ChallengeInfo.client_track_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='start_millis', full_name='ChallengeInfo.start_millis', index=1,
      number=2, type=5, cpp_type=1, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='duration_millis', full_name='ChallengeInfo.duration_millis', index=2,
      number=3, type=5, cpp_type=1, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='challenge_user_id', full_name='ChallengeInfo.challenge_user_id', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='challenge_timestamp', full_name='ChallengeInfo.challenge_timestamp', index=4,
      number=5, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='expect_match', full_name='ChallengeInfo.expect_match', index=5,
      number=6, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=333,
  serialized_end=498,
)


_SIGNEDCHALLENGEINFO = descriptor.Descriptor(
  name='SignedChallengeInfo',
  full_name='SignedChallengeInfo',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='challenge_info', full_name='SignedChallengeInfo.challenge_info', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='signature', full_name='SignedChallengeInfo.signature', index=1,
      number=2, type=12, cpp_type=9, label=2,
      has_default_value=False, default_value="",
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=500,
  serialized_end=580,
)


_TRACKSAMPLE = descriptor.Descriptor(
  name='TrackSample',
  full_name='TrackSample',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track', full_name='TrackSample.track', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='signed_challenge_info', full_name='TrackSample.signed_challenge_info', index=1,
      number=2, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sample', full_name='TrackSample.sample', index=2,
      number=3, type=12, cpp_type=9, label=2,
      has_default_value=False, default_value="",
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sample_format', full_name='TrackSample.sample_format', index=3,
      number=4, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='user_album_art', full_name='TrackSample.user_album_art', index=4,
      number=5, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=583,
  serialized_end=768,
)


_UPLOADPLAYLISTREQUEST = descriptor.Descriptor(
  name='UploadPlaylistRequest',
  full_name='UploadPlaylistRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='upload_operation', full_name='UploadPlaylistRequest.upload_operation', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist', full_name='UploadPlaylistRequest.playlist', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='UploadPlaylistRequest.uploader_id', index=2,
      number=3, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=770,
  serialized_end=887,
)


_PLAYLISTRESPONSE = descriptor.Descriptor(
  name='PlaylistResponse',
  full_name='PlaylistResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_status', full_name='PlaylistResponse.response_status', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='PlaylistResponse.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='server_id', full_name='PlaylistResponse.server_id', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=889,
  serialized_end=987,
)


_UPLOADPLAYLISTRESPONSE = descriptor.Descriptor(
  name='UploadPlaylistResponse',
  full_name='UploadPlaylistResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='playlist_response', full_name='UploadPlaylistResponse.playlist_response', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=989,
  serialized_end=1059,
)


_UPLOADPLAYLISTENTRYREQUEST = descriptor.Descriptor(
  name='UploadPlaylistEntryRequest',
  full_name='UploadPlaylistEntryRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='upload_operation', full_name='UploadPlaylistEntryRequest.upload_operation', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry', full_name='UploadPlaylistEntryRequest.playlist_entry', index=1,
      number=2, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='UploadPlaylistEntryRequest.uploader_id', index=2,
      number=3, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1062,
  serialized_end=1195,
)


_PLAYLISTENTRYRESPONSE = descriptor.Descriptor(
  name='PlaylistEntryResponse',
  full_name='PlaylistEntryResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_status', full_name='PlaylistEntryResponse.response_status', index=0,
      number=1, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='client_id', full_name='PlaylistEntryResponse.client_id', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='server_id', full_name='PlaylistEntryResponse.server_id', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1197,
  serialized_end=1300,
)


_UPLOADPLAYLISTENTRYRESPONSE = descriptor.Descriptor(
  name='UploadPlaylistEntryResponse',
  full_name='UploadPlaylistEntryResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='playlist_entry_response', full_name='UploadPlaylistEntryResponse.playlist_entry_response', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1302,
  serialized_end=1388,
)


_UPLOADMETADATAREQUEST = descriptor.Descriptor(
  name='UploadMetadataRequest',
  full_name='UploadMetadataRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track', full_name='UploadMetadataRequest.track', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='UploadMetadataRequest.uploader_id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1390,
  serialized_end=1457,
)


_UPDATEUPLOADSTATEREQUEST = descriptor.Descriptor(
  name='UpdateUploadStateRequest',
  full_name='UpdateUploadStateRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='state', full_name='UpdateUploadStateRequest.state', index=0,
      number=1, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='UpdateUploadStateRequest.uploader_id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _UPDATEUPLOADSTATEREQUEST_UPLOADSTATE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1460,
  serialized_end=1612,
)


_CLIENTSTATEREQUEST = descriptor.Descriptor(
  name='ClientStateRequest',
  full_name='ClientStateRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='ClientStateRequest.uploader_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='get_purchased_tracks_since', full_name='ClientStateRequest.get_purchased_tracks_since', index=1,
      number=2, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1614,
  serialized_end=1691,
)


_CLIENTSTATERESPONSE = descriptor.Descriptor(
  name='ClientStateResponse',
  full_name='ClientStateResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='locker_track_limit', full_name='ClientStateResponse.locker_track_limit', index=0,
      number=1, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='user_songs_in_locker', full_name='ClientStateResponse.user_songs_in_locker', index=1,
      number=2, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_size_limit_in_mb', full_name='ClientStateResponse.track_size_limit_in_mb', index=2,
      number=3, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='user_purchased_tracks_since', full_name='ClientStateResponse.user_purchased_tracks_since', index=3,
      number=4, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='total_track_count', full_name='ClientStateResponse.total_track_count', index=4,
      number=5, type=3, cpp_type=2, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1694,
  serialized_end=1869,
)


_UPLOADMETADATARESPONSE = descriptor.Descriptor(
  name='UploadMetadataResponse',
  full_name='UploadMetadataResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='signed_challenge_info', full_name='UploadMetadataResponse.signed_challenge_info', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='upload_id', full_name='UploadMetadataResponse.upload_id', index=1,
      number=2, type=9, cpp_type=9, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='track_sample_response', full_name='UploadMetadataResponse.track_sample_response', index=2,
      number=3, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=1872,
  serialized_end=2021,
)


_TRACKSAMPLERESPONSE = descriptor.Descriptor(
  name='TrackSampleResponse',
  full_name='TrackSampleResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='client_track_id', full_name='TrackSampleResponse.client_track_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='response_code', full_name='TrackSampleResponse.response_code', index=1,
      number=2, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='server_track_id', full_name='TrackSampleResponse.server_track_id', index=2,
      number=3, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_art_url', full_name='TrackSampleResponse.album_art_url', index=3,
      number=4, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='expect_match', full_name='TrackSampleResponse.expect_match', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACKSAMPLERESPONSE_RESPONSECODE,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2024,
  serialized_end=2445,
)


_UPLOADSAMPLEREQUEST = descriptor.Descriptor(
  name='UploadSampleRequest',
  full_name='UploadSampleRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track_sample', full_name='UploadSampleRequest.track_sample', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='UploadSampleRequest.uploader_id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2447,
  serialized_end=2525,
)


_UPLOADSAMPLERESPONSE = descriptor.Descriptor(
  name='UploadSampleResponse',
  full_name='UploadSampleResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='track_sample_response', full_name='UploadSampleResponse.track_sample_response', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2527,
  serialized_end=2602,
)


_IMAGEUNION = descriptor.Descriptor(
  name='ImageUnion',
  full_name='ImageUnion',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='user_album_art', full_name='ImageUnion.user_album_art', index=0,
      number=1, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value="",
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='album_art_url', full_name='ImageUnion.album_art_url', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2604,
  serialized_end=2663,
)


_UPLOADRESPONSE = descriptor.Descriptor(
  name='UploadResponse',
  full_name='UploadResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='response_type', full_name='UploadResponse.response_type', index=0,
      number=1, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='metadata_response', full_name='UploadResponse.metadata_response', index=1,
      number=2, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_response', full_name='UploadResponse.playlist_response', index=2,
      number=3, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='playlist_entry_response', full_name='UploadResponse.playlist_entry_response', index=3,
      number=4, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='sample_response', full_name='UploadResponse.sample_response', index=4,
      number=5, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='getjobs_response', full_name='UploadResponse.getjobs_response', index=5,
      number=7, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='clientstate_response', full_name='UploadResponse.clientstate_response', index=6,
      number=8, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='policy', full_name='UploadResponse.policy', index=7,
      number=6, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='auth_status', full_name='UploadResponse.auth_status', index=8,
      number=11, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=8,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='auth_error', full_name='UploadResponse.auth_error', index=9,
      number=12, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _UPLOADRESPONSE_RESPONSETYPE,
    _UPLOADRESPONSE_AUTHSTATUS,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=2666,
  serialized_end=3609,
)


_TRACKSTOUPLOAD = descriptor.Descriptor(
  name='TracksToUpload',
  full_name='TracksToUpload',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='client_id', full_name='TracksToUpload.client_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='server_id', full_name='TracksToUpload.server_id', index=1,
      number=2, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='status', full_name='TracksToUpload.status', index=2,
      number=5, type=14, cpp_type=8, label=2,
      has_default_value=False, default_value=3,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _TRACKSTOUPLOAD_TRACKSTATUS,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3612,
  serialized_end=3768,
)


_GETJOBSREQUEST = descriptor.Descriptor(
  name='GetJobsRequest',
  full_name='GetJobsRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='GetJobsRequest.uploader_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3770,
  serialized_end=3807,
)


_GETJOBSRESPONSE = descriptor.Descriptor(
  name='GetJobsResponse',
  full_name='GetJobsResponse',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='tracks_to_upload', full_name='GetJobsResponse.tracks_to_upload', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='get_tracks_success', full_name='GetJobsResponse.get_tracks_success', index=1,
      number=2, type=8, cpp_type=7, label=2,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3809,
  serialized_end=3897,
)


_UPAUTHREQUEST = descriptor.Descriptor(
  name='UpAuthRequest',
  full_name='UpAuthRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='UpAuthRequest.uploader_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='friendly_name', full_name='UpAuthRequest.friendly_name', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3899,
  serialized_end=3958,
)


_DELETEUPLOADREQUESTEDREQUEST = descriptor.Descriptor(
  name='DeleteUploadRequestedRequest',
  full_name='DeleteUploadRequestedRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='uploader_id', full_name='DeleteUploadRequestedRequest.uploader_id', index=0,
      number=1, type=9, cpp_type=9, label=2,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=3960,
  serialized_end=4011,
)


_CLIENTPOLICY = descriptor.Descriptor(
  name='ClientPolicy',
  full_name='ClientPolicy',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='pause_uploads', full_name='ClientPolicy.pause_uploads', index=0,
      number=1, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='abort', full_name='ClientPolicy.abort', index=1,
      number=2, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='retry_in_minutes', full_name='ClientPolicy.retry_in_minutes', index=2,
      number=3, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='bandwidth_cap_kbps', full_name='ClientPolicy.bandwidth_cap_kbps', index=3,
      number=4, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='pause_downloads', full_name='ClientPolicy.pause_downloads', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='download_bandwidth_cap_kbps', full_name='ClientPolicy.download_bandwidth_cap_kbps', index=5,
      number=6, type=5, cpp_type=1, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='send_analytics', full_name='ClientPolicy.send_analytics', index=6,
      number=7, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='analytics_url', full_name='ClientPolicy.analytics_url', index=7,
      number=8, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='enable_gapless', full_name='ClientPolicy.enable_gapless', index=8,
      number=9, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='enable_m4p', full_name='ClientPolicy.enable_m4p', index=9,
      number=10, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4014,
  serialized_end=4273,
)


_UPLOADMETADATAINTERNALREQUEST = descriptor.Descriptor(
  name='UploadMetadataInternalRequest',
  full_name='UploadMetadataInternalRequest',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='gaiaid', full_name='UploadMetadataInternalRequest.gaiaid', index=0,
      number=1, type=4, cpp_type=4, label=2,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='request', full_name='UploadMetadataInternalRequest.request', index=1,
      number=2, type=11, cpp_type=10, label=2,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4275,
  serialized_end=4363,
)


_OVERRIDECONFIGVALUE = descriptor.Descriptor(
  name='OverrideConfigValue',
  full_name='OverrideConfigValue',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='key', full_name='OverrideConfigValue.key', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='value', full_name='OverrideConfigValue.value', index=1,
      number=2, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=unicode("", "utf-8"),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    descriptor.FieldDescriptor(
      name='priority', full_name='OverrideConfigValue.priority', index=2,
      number=3, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=-1,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _OVERRIDECONFIGVALUE_OVERRIDEPRIORITY,
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4366,
  serialized_end=4689,
)


_OVERRIDECONFIGVALUECOLLECTION = descriptor.Descriptor(
  name='OverrideConfigValueCollection',
  full_name='OverrideConfigValueCollection',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    descriptor.FieldDescriptor(
      name='value', full_name='OverrideConfigValueCollection.value', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  extension_ranges=[],
  serialized_start=4691,
  serialized_end=4759,
)

_RESPONSESTATUS.fields_by_name['response_code'].enum_type = _RESPONSESTATUS_RESPONSECODE
_RESPONSESTATUS_RESPONSECODE.containing_type = _RESPONSESTATUS;
_UPLOADOPERATION.fields_by_name['operation'].enum_type = _UPLOADOPERATION_OPERATION
_UPLOADOPERATION_OPERATION.containing_type = _UPLOADOPERATION;
_SIGNEDCHALLENGEINFO.fields_by_name['challenge_info'].message_type = _CHALLENGEINFO
_TRACKSAMPLE.fields_by_name['track'].message_type = locker_pb2._TRACK
_TRACKSAMPLE.fields_by_name['signed_challenge_info'].message_type = _SIGNEDCHALLENGEINFO
_TRACKSAMPLE.fields_by_name['sample_format'].enum_type = locker_pb2._TRACK_CONTENTTYPE
_TRACKSAMPLE.fields_by_name['user_album_art'].message_type = _IMAGEUNION
_UPLOADPLAYLISTREQUEST.fields_by_name['upload_operation'].message_type = _UPLOADOPERATION
_UPLOADPLAYLISTREQUEST.fields_by_name['playlist'].message_type = locker_pb2._PLAYLIST
_PLAYLISTRESPONSE.fields_by_name['response_status'].message_type = _RESPONSESTATUS
_UPLOADPLAYLISTRESPONSE.fields_by_name['playlist_response'].message_type = _PLAYLISTRESPONSE
_UPLOADPLAYLISTENTRYREQUEST.fields_by_name['upload_operation'].message_type = _UPLOADOPERATION
_UPLOADPLAYLISTENTRYREQUEST.fields_by_name['playlist_entry'].message_type = locker_pb2._PLAYLISTENTRY
_PLAYLISTENTRYRESPONSE.fields_by_name['response_status'].message_type = _RESPONSESTATUS
_UPLOADPLAYLISTENTRYRESPONSE.fields_by_name['playlist_entry_response'].message_type = _PLAYLISTENTRYRESPONSE
_UPLOADMETADATAREQUEST.fields_by_name['track'].message_type = locker_pb2._TRACK
_UPDATEUPLOADSTATEREQUEST.fields_by_name['state'].enum_type = _UPDATEUPLOADSTATEREQUEST_UPLOADSTATE
_UPDATEUPLOADSTATEREQUEST_UPLOADSTATE.containing_type = _UPDATEUPLOADSTATEREQUEST;
_UPLOADMETADATARESPONSE.fields_by_name['signed_challenge_info'].message_type = _SIGNEDCHALLENGEINFO
_UPLOADMETADATARESPONSE.fields_by_name['track_sample_response'].message_type = _TRACKSAMPLERESPONSE
_TRACKSAMPLERESPONSE.fields_by_name['response_code'].enum_type = _TRACKSAMPLERESPONSE_RESPONSECODE
_TRACKSAMPLERESPONSE_RESPONSECODE.containing_type = _TRACKSAMPLERESPONSE;
_UPLOADSAMPLEREQUEST.fields_by_name['track_sample'].message_type = _TRACKSAMPLE
_UPLOADSAMPLERESPONSE.fields_by_name['track_sample_response'].message_type = _TRACKSAMPLERESPONSE
_UPLOADRESPONSE.fields_by_name['response_type'].enum_type = _UPLOADRESPONSE_RESPONSETYPE
_UPLOADRESPONSE.fields_by_name['metadata_response'].message_type = _UPLOADMETADATARESPONSE
_UPLOADRESPONSE.fields_by_name['playlist_response'].message_type = _UPLOADPLAYLISTRESPONSE
_UPLOADRESPONSE.fields_by_name['playlist_entry_response'].message_type = _UPLOADPLAYLISTENTRYRESPONSE
_UPLOADRESPONSE.fields_by_name['sample_response'].message_type = _UPLOADSAMPLERESPONSE
_UPLOADRESPONSE.fields_by_name['getjobs_response'].message_type = _GETJOBSRESPONSE
_UPLOADRESPONSE.fields_by_name['clientstate_response'].message_type = _CLIENTSTATERESPONSE
_UPLOADRESPONSE.fields_by_name['policy'].message_type = _CLIENTPOLICY
_UPLOADRESPONSE.fields_by_name['auth_status'].enum_type = _UPLOADRESPONSE_AUTHSTATUS
_UPLOADRESPONSE_RESPONSETYPE.containing_type = _UPLOADRESPONSE;
_UPLOADRESPONSE_AUTHSTATUS.containing_type = _UPLOADRESPONSE;
_TRACKSTOUPLOAD.fields_by_name['status'].enum_type = _TRACKSTOUPLOAD_TRACKSTATUS
_TRACKSTOUPLOAD_TRACKSTATUS.containing_type = _TRACKSTOUPLOAD;
_GETJOBSRESPONSE.fields_by_name['tracks_to_upload'].message_type = _TRACKSTOUPLOAD
_UPLOADMETADATAINTERNALREQUEST.fields_by_name['request'].message_type = _UPLOADMETADATAREQUEST
_OVERRIDECONFIGVALUE.fields_by_name['priority'].enum_type = _OVERRIDECONFIGVALUE_OVERRIDEPRIORITY
_OVERRIDECONFIGVALUE_OVERRIDEPRIORITY.containing_type = _OVERRIDECONFIGVALUE;
_OVERRIDECONFIGVALUECOLLECTION.fields_by_name['value'].message_type = _OVERRIDECONFIGVALUE
DESCRIPTOR.message_types_by_name['ResponseStatus'] = _RESPONSESTATUS
DESCRIPTOR.message_types_by_name['UploadOperation'] = _UPLOADOPERATION
DESCRIPTOR.message_types_by_name['ChallengeInfo'] = _CHALLENGEINFO
DESCRIPTOR.message_types_by_name['SignedChallengeInfo'] = _SIGNEDCHALLENGEINFO
DESCRIPTOR.message_types_by_name['TrackSample'] = _TRACKSAMPLE
DESCRIPTOR.message_types_by_name['UploadPlaylistRequest'] = _UPLOADPLAYLISTREQUEST
DESCRIPTOR.message_types_by_name['PlaylistResponse'] = _PLAYLISTRESPONSE
DESCRIPTOR.message_types_by_name['UploadPlaylistResponse'] = _UPLOADPLAYLISTRESPONSE
DESCRIPTOR.message_types_by_name['UploadPlaylistEntryRequest'] = _UPLOADPLAYLISTENTRYREQUEST
DESCRIPTOR.message_types_by_name['PlaylistEntryResponse'] = _PLAYLISTENTRYRESPONSE
DESCRIPTOR.message_types_by_name['UploadPlaylistEntryResponse'] = _UPLOADPLAYLISTENTRYRESPONSE
DESCRIPTOR.message_types_by_name['UploadMetadataRequest'] = _UPLOADMETADATAREQUEST
DESCRIPTOR.message_types_by_name['UpdateUploadStateRequest'] = _UPDATEUPLOADSTATEREQUEST
DESCRIPTOR.message_types_by_name['ClientStateRequest'] = _CLIENTSTATEREQUEST
DESCRIPTOR.message_types_by_name['ClientStateResponse'] = _CLIENTSTATERESPONSE
DESCRIPTOR.message_types_by_name['UploadMetadataResponse'] = _UPLOADMETADATARESPONSE
DESCRIPTOR.message_types_by_name['TrackSampleResponse'] = _TRACKSAMPLERESPONSE
DESCRIPTOR.message_types_by_name['UploadSampleRequest'] = _UPLOADSAMPLEREQUEST
DESCRIPTOR.message_types_by_name['UploadSampleResponse'] = _UPLOADSAMPLERESPONSE
DESCRIPTOR.message_types_by_name['ImageUnion'] = _IMAGEUNION
DESCRIPTOR.message_types_by_name['UploadResponse'] = _UPLOADRESPONSE
DESCRIPTOR.message_types_by_name['TracksToUpload'] = _TRACKSTOUPLOAD
DESCRIPTOR.message_types_by_name['GetJobsRequest'] = _GETJOBSREQUEST
DESCRIPTOR.message_types_by_name['GetJobsResponse'] = _GETJOBSRESPONSE
DESCRIPTOR.message_types_by_name['UpAuthRequest'] = _UPAUTHREQUEST
DESCRIPTOR.message_types_by_name['DeleteUploadRequestedRequest'] = _DELETEUPLOADREQUESTEDREQUEST
DESCRIPTOR.message_types_by_name['ClientPolicy'] = _CLIENTPOLICY
DESCRIPTOR.message_types_by_name['UploadMetadataInternalRequest'] = _UPLOADMETADATAINTERNALREQUEST
DESCRIPTOR.message_types_by_name['OverrideConfigValue'] = _OVERRIDECONFIGVALUE
DESCRIPTOR.message_types_by_name['OverrideConfigValueCollection'] = _OVERRIDECONFIGVALUECOLLECTION

class ResponseStatus(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _RESPONSESTATUS
  
  # @@protoc_insertion_point(class_scope:ResponseStatus)

class UploadOperation(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADOPERATION
  
  # @@protoc_insertion_point(class_scope:UploadOperation)

class ChallengeInfo(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _CHALLENGEINFO
  
  # @@protoc_insertion_point(class_scope:ChallengeInfo)

class SignedChallengeInfo(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _SIGNEDCHALLENGEINFO
  
  # @@protoc_insertion_point(class_scope:SignedChallengeInfo)

class TrackSample(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKSAMPLE
  
  # @@protoc_insertion_point(class_scope:TrackSample)

class UploadPlaylistRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADPLAYLISTREQUEST
  
  # @@protoc_insertion_point(class_scope:UploadPlaylistRequest)

class PlaylistResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PLAYLISTRESPONSE
  
  # @@protoc_insertion_point(class_scope:PlaylistResponse)

class UploadPlaylistResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADPLAYLISTRESPONSE
  
  # @@protoc_insertion_point(class_scope:UploadPlaylistResponse)

class UploadPlaylistEntryRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADPLAYLISTENTRYREQUEST
  
  # @@protoc_insertion_point(class_scope:UploadPlaylistEntryRequest)

class PlaylistEntryResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _PLAYLISTENTRYRESPONSE
  
  # @@protoc_insertion_point(class_scope:PlaylistEntryResponse)

class UploadPlaylistEntryResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADPLAYLISTENTRYRESPONSE
  
  # @@protoc_insertion_point(class_scope:UploadPlaylistEntryResponse)

class UploadMetadataRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADMETADATAREQUEST
  
  # @@protoc_insertion_point(class_scope:UploadMetadataRequest)

class UpdateUploadStateRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPDATEUPLOADSTATEREQUEST
  
  # @@protoc_insertion_point(class_scope:UpdateUploadStateRequest)

class ClientStateRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _CLIENTSTATEREQUEST
  
  # @@protoc_insertion_point(class_scope:ClientStateRequest)

class ClientStateResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _CLIENTSTATERESPONSE
  
  # @@protoc_insertion_point(class_scope:ClientStateResponse)

class UploadMetadataResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADMETADATARESPONSE
  
  # @@protoc_insertion_point(class_scope:UploadMetadataResponse)

class TrackSampleResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKSAMPLERESPONSE
  
  # @@protoc_insertion_point(class_scope:TrackSampleResponse)

class UploadSampleRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADSAMPLEREQUEST
  
  # @@protoc_insertion_point(class_scope:UploadSampleRequest)

class UploadSampleResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADSAMPLERESPONSE
  
  # @@protoc_insertion_point(class_scope:UploadSampleResponse)

class ImageUnion(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _IMAGEUNION
  
  # @@protoc_insertion_point(class_scope:ImageUnion)

class UploadResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADRESPONSE
  
  # @@protoc_insertion_point(class_scope:UploadResponse)

class TracksToUpload(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _TRACKSTOUPLOAD
  
  # @@protoc_insertion_point(class_scope:TracksToUpload)

class GetJobsRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETJOBSREQUEST
  
  # @@protoc_insertion_point(class_scope:GetJobsRequest)

class GetJobsResponse(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _GETJOBSRESPONSE
  
  # @@protoc_insertion_point(class_scope:GetJobsResponse)

class UpAuthRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPAUTHREQUEST
  
  # @@protoc_insertion_point(class_scope:UpAuthRequest)

class DeleteUploadRequestedRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _DELETEUPLOADREQUESTEDREQUEST
  
  # @@protoc_insertion_point(class_scope:DeleteUploadRequestedRequest)

class ClientPolicy(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _CLIENTPOLICY
  
  # @@protoc_insertion_point(class_scope:ClientPolicy)

class UploadMetadataInternalRequest(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _UPLOADMETADATAINTERNALREQUEST
  
  # @@protoc_insertion_point(class_scope:UploadMetadataInternalRequest)

class OverrideConfigValue(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _OVERRIDECONFIGVALUE
  
  # @@protoc_insertion_point(class_scope:OverrideConfigValue)

class OverrideConfigValueCollection(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _OVERRIDECONFIGVALUECOLLECTION
  
  # @@protoc_insertion_point(class_scope:OverrideConfigValueCollection)

# @@protoc_insertion_point(module_scope)

########NEW FILE########
__FILENAME__ = webclient
# -*- coding: utf-8 -*-

"""Calls made by the web client."""

import base64
import copy
import hmac
import random
import string
import sys
from hashlib import sha1

import validictory

from gmusicapi.compat import json
from gmusicapi.exceptions import CallFailure, ValidationException
from gmusicapi.protocol.metadata import md_expectations
from gmusicapi.protocol.shared import Call, authtypes
from gmusicapi.utils import utils

base_url = 'https://play.google.com/music/'
service_url = base_url + 'services/'

#Shared response schemas, built to include metadata expectations.
song_schema = {
    "type": "object",
    "properties": dict(
        (name, expt.get_schema()) for
        name, expt in md_expectations.items()
    ),
    #don't allow metadata not in expectations
    "additionalProperties": False
}

song_array = {
    "type": "array",
    "items": song_schema
}

pl_schema = {
    "type": "object",
    "properties": {
        "continuation": {"type": "boolean"},
        "playlist": song_array,
        "playlistId": {"type": "string"},
        "unavailableTrackCount": {"type": "integer"},
        # unsure what this field does. sometimes it's not there.
        "token": {"type": "string", "required": False},
        #only appears when loading multiple playlists
        "title": {"type": "string", "required": False},
        "continuationToken": {"type": "string", "required": False},
    },
    "additionalProperties": False
}

pl_array = {
    "type": "array",
    "items": pl_schema
}


class Init(Call):
    """Called one time per session, immediately after login.

    This performs one-time setup:
    it gathers the cookies we need (specifically `xt`), and Google uses it
    to create the webclient DOM.

    Note the use of the HEAD verb. Google uses GET, but we don't need
    the large response containing Google's webui.
    """

    static_method = 'HEAD'
    static_url = base_url + 'listen'

    required_auth = authtypes(sso=True)

    #This call doesn't actually request/return anything useful aside from cookies.
    @staticmethod
    def parse_response(response):
        return response.text

    @classmethod
    def check_success(cls, response, msg):
        if response.status_code != 200:
            raise CallFailure(('status code %s != 200' % response.status_code), cls.__name__)
        if 'xt' not in response.cookies:
            raise CallFailure('did not receieve xt cookies', cls.__name__)


class WcCall(Call):
    """Abstract base for web client calls."""

    required_auth = authtypes(xt=True, sso=True)

    #validictory schema for the response
    _res_schema = utils.NotImplementedField

    @classmethod
    def validate(cls, response, msg):
        """Use validictory and a static schema (stored in cls._res_schema)."""
        try:
            return validictory.validate(msg, cls._res_schema)
        except ValueError as e:
            trace = sys.exc_info()[2]
            raise ValidationException(str(e)), None, trace

    @classmethod
    def check_success(cls, response, msg):
        #Failed responses always have a success=False key.
        #Some successful responses do not have a success=True key, however.
        #TODO remove utils.call_succeeded

        if 'success' in msg and not msg['success']:
            raise CallFailure(
                "the server reported failure. This is usually"
                " caused by bad arguments, but can also happen if requests"
                " are made too quickly (eg creating a playlist then"
                " modifying it before the server has created it)",
                cls.__name__)

    @classmethod
    def parse_response(cls, response):
        return cls._parse_json(response.text)


class CreatePlaylist(WcCall):
    """Adds songs to a playlist."""
    static_method = 'POST'
    static_url = service_url + 'createplaylist'
    static_params = {'format': 'jsarray'}

    _res_schema = {
        "type": "array",
        # eg:
        # [[0,2]
        # ,["id","sharetoken",[]
        #  ,<millis>]]
    }

    @staticmethod
    def dynamic_data(name, description, public, session_id=""):
        return json.dumps([[session_id, 1], [public, name, description, []]])


class AddToPlaylist(WcCall):
    """Adds songs to a playlist."""
    static_method = 'POST'
    static_url = service_url + 'addtoplaylist'

    _res_schema = {
        "type": "object",
        "properties": {
            "playlistId": {"type": "string"},
            "songIds": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "songId": {"type": "string"},
                        "playlistEntryId": {"type": "string"}
                    }
                }
            }
        },
        "additionalProperties": False
    }

    @staticmethod
    def dynamic_data(playlist_id, song_ids):
        """
        :param playlist_id: id of the playlist to add to.
        :param song_ids: a list of song ids
        """
        #TODO unsure what type means here. Likely involves uploaded vs store/free.
        song_refs = [{'id': sid, 'type': 1} for sid in song_ids]

        return {
            'json': json.dumps(
                {"playlistId": playlist_id, "songRefs": song_refs}
            )
        }

    @staticmethod
    def filter_response(msg):
        filtered = copy.copy(msg)
        filtered['songIds'] = ["<%s songs>" % len(filtered.get('songIds', []))]
        return filtered


class ChangePlaylistOrder(WcCall):
    """Reorder existing tracks in a playlist."""

    static_method = 'POST'
    static_url = service_url + 'changeplaylistorder'

    _res_schema = {
        "type": "object",
        "properties": {
            "afterEntryId": {"type": "string", "blank": True},
            "playlistId": {"type": "string"},
            "movedSongIds": {
                "type": "array",
                "items": {"type": "string"}
            }
        },
        "additionalProperties": False
    }

    @staticmethod
    def dynamic_data(playlist_id, song_ids_moving, entry_ids_moving,
                     after_entry_id=None, before_entry_id=None):
        """
        :param playlist_id: id of the playlist getting reordered.
        :param song_ids_moving: a list of consecutive song ids. Matches entry_ids_moving.
        :param entry_ids_moving: a list of consecutive entry ids to move. Matches song_ids_moving.
        :param after_entry_id: the entry id to place these songs after. Default first position.
        :param before_entry_id: the entry id to place these songs before. Default last position.
        """

        # empty string means first/last position
        if after_entry_id is None:
            after_entry_id = ""
        if before_entry_id is None:
            before_entry_id = ""

        return {
            'json': json.dumps(
                {
                    "playlistId": playlist_id,
                    "movedSongIds": song_ids_moving,
                    "movedEntryIds": entry_ids_moving,
                    "afterEntryId": after_entry_id,
                    "beforeEntryId": before_entry_id
                }
            )
        }

    @staticmethod
    def filter_response(msg):
        filtered = copy.copy(msg)
        filtered['movedSongIds'] = ["<%s songs>" % len(filtered.get('movedSongIds', []))]
        return filtered


class DeletePlaylist(WcCall):
    """Delete a playlist."""

    static_method = 'POST'
    static_url = service_url + 'deleteplaylist'

    _res_schema = {
        "type": "object",
        "properties": {
            "deleteId": {"type": "string"}
        },
        "additionalProperties": False
    }

    @staticmethod
    def dynamic_data(playlist_id):
        """
        :param playlist_id: id of the playlist to delete.
        """
        return {
            'json': json.dumps(
                {"id": playlist_id}
            )
        }


class DeleteSongs(WcCall):
    """Delete a song from the entire library or a single playlist."""

    static_method = 'POST'
    static_url = service_url + 'deletesong'

    _res_schema = {
        "type": "object",
        "properties": {
            "listId": {"type": "string"},
            "deleteIds":
            {
                "type": "array",
                "items": {"type": "string"}
            }
        },
        "additionalProperties": False
    }

    @staticmethod
    def dynamic_data(song_ids, playlist_id='all', entry_ids=None):
        """
        :param song_ids: a list of song ids.
        :param playlist_id: playlist id to delete from, or 'all' for deleting from library.
        :param entry_ids: when deleting from playlists, corresponding list of entry ids.
        """

        if entry_ids is None:
            #this is strange, but apparently correct
            entry_ids = [''] * len(song_ids)

        return {
            'json': json.dumps(
                {"songIds": song_ids, "entryIds": entry_ids, "listId": playlist_id}
            )
        }

    @staticmethod
    def filter_response(msg):
        filtered = copy.copy(msg)
        filtered['deleteIds'] = ["<%s songs>" % len(filtered.get('deleteIds', []))]
        return filtered


class ChangeSongMetadata(WcCall):
    """Edit the metadata of songs."""

    static_method = 'POST'
    static_url = service_url + 'modifytracks'
    static_params = {'format': 'jsarray'}

    _res_schema = {
        "type": "array",
        # eg [[0,1],[1393706382978]]
    }

    @staticmethod
    def dynamic_data(songs, session_id=""):
        """
        :param songs: a list of dicts ``{'id': '...', 'albumArtUrl': '...'}``
        """
        if any([s for s in songs if set(s.keys()) != set(['id', 'albumArtUrl'])]):
            raise ValueError("ChangeSongMetadata only supports the 'id' and 'albumArtUrl' keys."
                             " All other keys must be removed.")

        # jsarray is just wonderful
        jsarray = [[session_id, 1]]
        song_arrays = [[s['id'], None, s['albumArtUrl']] + [None] * 36 + [[]] for s in songs]
        jsarray.append([song_arrays])

        return json.dumps(jsarray)


class GetDownloadInfo(WcCall):
    """Get download links and counts for songs."""

    static_method = 'POST'
    static_url = service_url + 'multidownload'

    _res_schema = {
        "type": "object",
        "properties": {
            "downloadCounts": {
                "type": "object",
                "items": {
                    "type": "object",
                    "properties": {
                        "id": {"type": "integer"}
                    }
                }
            },
            "url": {"type": "string"}
        },
        "additionalProperties": False
    }

    @staticmethod
    def dynamic_data(song_ids):
        """
        :param: (list) song_ids
        """
        return {'json': json.dumps({'songIds': song_ids})}


class GetStreamUrl(WcCall):
    """Used to request a streaming link of a track."""

    static_method = 'GET'
    static_url = base_url + 'play'  # note use of base_url, not service_url

    required_auth = authtypes(sso=True)  # no xt required

    _res_schema = {
        "type": "object",
        "properties": {
            "url": {"type": "string", "required": False},
            "urls": {"type": "array", "required": False},
            'now': {'type': 'integer', 'required': False},
            'tier': {'type': 'integer', 'required': False},
        },
        "additionalProperties": False
    }

    @staticmethod
    def dynamic_params(song_id):

        # https://github.com/simon-weber/Unofficial-Google-Music-API/issues/137
        # there are three cases when streaming:
        #   | track type              | guid songid? | slt/sig needed? |
        #    user-uploaded              yes            no
        #    AA track in library        yes            yes
        #    AA track not in library    no             yes

        # without the track['type'] field we can't tell between 1 and 2, but
        # include slt/sig anyway; the server ignores the extra params.
        key = '27f7313e-f75d-445a-ac99-56386a5fe879'
        salt = ''.join(random.choice(string.ascii_lowercase + string.digits) for x in range(12))
        sig = base64.urlsafe_b64encode(hmac.new(key, (song_id + salt), sha1).digest())[:-1]

        params = {
            'u': 0,
            'pt': 'e',
            'slt': salt,
            'sig': sig
        }

        # TODO match guid instead, should be more robust
        if song_id[0] == 'T':
            # all access
            params['mjck'] = song_id
        else:
            params['songid'] = song_id
        return params


class ReportBadSongMatch(WcCall):
    """Request to signal the uploader to reupload a matched track."""

    static_method = 'POST'
    static_url = service_url + 'fixsongmatch'
    static_params = {'format': 'jsarray'}

    #This no longer holds.
    expected_response = [[0], []]

    @classmethod
    def validate(cls, response, msg):
        pass
        #if msg != cls.expected_response:
        #    raise ValidationException("response != %r" % cls.expected_response)

    @staticmethod
    def dynamic_data(song_ids):
        return json.dumps([["", 1], [song_ids]])


class UploadImage(WcCall):
    """Upload an image for use as album art."""

    static_method = 'POST'
    static_url = service_url + 'imageupload'
    static_params = {'zx': '',  # ??
                     'u': 0}

    _res_schema = {
        'type': 'object',
        'properties': {
            'imageUrl': {'type': 'string', 'blank': False},
            'imageDisplayUrl': {'type': 'string', 'blank': False},
        },
        'additionalProperties': False
    }

    @staticmethod
    def dynamic_files(image_filepath):
        """
        :param image_filepath: path to an image
        """
        with open(image_filepath, 'rb') as f:
            contents = f.read()

        return {'albumArt': (image_filepath, contents)}


class GetSettings(WcCall):
    """Get data that populates the settings tab: labs and devices."""

    static_method = 'POST'
    static_url = service_url + 'loadsettings'

    _device_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'date': {'type': 'integer',
                     'format': 'utc-millisec'},
            'id': {'type': 'string'},
            'name': {'type': 'string', 'blank': True},
            'type': {'type': 'string'},
            'lastUsedMs': {'type': 'integer'},

            # only for type == PHONE:
            'model': {'type': 'string', 'blank': True, 'required': False},
            'manufacturer': {'type': 'string', 'blank': True, 'required': False},

            'carrier': {'type': 'string', 'blank': True, 'required': False},
        },
    }

    _lab_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'description': {'type': 'string'},
            'enabled': {'type': 'boolean'},
            'name': {'type': 'string'},
            'title': {'type': 'string'},
        },
    }

    _res_schema = {
        'type': 'object',
        'additionalProperties': False,
        'properties': {
            'settings': {
                'type': 'object',
                'additionalProperties': False,
                'properties': {
                    'devices': {'type': 'array', 'items': _device_schema},
                    'labs': {'type': 'array', 'items': _lab_schema},
                    'maxTracks': {'type': 'integer'},
                    'expirationMillis': {
                        'type': 'integer',
                        'format': 'utc-millisec',
                        'required': False,
                    },
                    'isSubscription': {'type': 'boolean', 'required': False},
                    'isTrial': {'type': 'boolean', 'required': False},
                    'hasFreeTrial': {'type': 'boolean', 'required': False},
                    'subscriptionNewsletter': {'type': 'boolean'},
                    'isCanceled': {'type': 'boolean', 'required': False},
                },
            },
        },
    }

    @staticmethod
    def dynamic_data(session_id):
        """
        :param: session_id
        """
        return {'json': json.dumps({'sessionId': session_id})}


class DeauthDevice(WcCall):
    """Deauthorize a device from GetSettings."""
    static_method = 'POST'
    static_url = service_url + 'modifysettings'

    @staticmethod
    def dynamic_data(device_id, session_id):
        return {'json': json.dumps({'deauth': device_id, 'sessionId': session_id})}

    @classmethod
    def validate(cls, response, msg):
        if msg.text != '{}':
            raise ValidationException("expected an empty object; received %r" % msg.text)

########NEW FILE########
__FILENAME__ = session
# -*- coding: utf-8 -*-

"""
Sessions handle the details of authentication and transporting requests.
"""
from contextlib import closing
import cookielib

import oauth2client
import httplib2  # included with oauth2client
import requests

from gmusicapi.exceptions import (
    AlreadyLoggedIn, NotLoggedIn, CallFailure
)
from gmusicapi.protocol.shared import ClientLogin
from gmusicapi.protocol import webclient
from gmusicapi.utils import utils

log = utils.DynamicClientLogger(__name__)


class _Base(object):
    def __init__(self, rsession_setup=None):
        """
        :param rsession_setup: a callable that will be called with
          the backing requests.Session to delegate config to callers.
        """
        self._rsession = requests.Session()

        if rsession_setup is None:
            rsession_setup = lambda x: x
        self._rsession_setup = rsession_setup
        self._rsession_setup(self._rsession)

        self.is_authenticated = False

    def _send_with_auth(self, req_kwargs, desired_auth, rsession):
        raise NotImplementedError

    def _send_without_auth(self, req_kwargs, rsession):
        return rsession.request(**req_kwargs)

    def login(self, *args, **kwargs):
        # subclasses extend / use super()
        if self.is_authenticated:
            raise AlreadyLoggedIn

    def logout(self):
        """
        Reset the session to an unauthenticated, default state.
        """
        self._rsession.close()

        self._rsession = requests.Session()
        self._rsession_setup(self._rsession)

        self.is_authenticated = False

    def send(self, req_kwargs, desired_auth, rsession=None):
        """Send a request from a Call using this session's auth.

        :param req_kwargs: kwargs for requests.Session.request
        :param desired_auth: protocol.shared.AuthTypes to attach
        :param rsession: (optional) a requests.Session to use
          (default ``self._rsession`` - this is exposed for test purposes)
        """
        res = None

        if not any(desired_auth):
            if rsession is None:
                # use a throwaway session to ensure it's clean
                with closing(requests.Session()) as new_session:
                    self._rsession_setup(new_session)
                    res = self._send_without_auth(req_kwargs, new_session)
            else:
                res = self._send_without_auth(req_kwargs, rsession)

        else:
            if not self.is_authenticated:
                raise NotLoggedIn

            if rsession is None:
                rsession = self._rsession

            res = self._send_with_auth(req_kwargs, desired_auth, rsession)

        return res


class Webclient(_Base):
    def __init__(self, *args, **kwargs):
        super(Webclient, self).__init__(*args, **kwargs)
        self._authtoken = None

    def login(self, email, password, *args, **kwargs):
        """
        Perform clientlogin then retrieve webclient cookies.

        :param email:
        :param password:
        """

        super(Webclient, self).login()

        try:
            res = ClientLogin.perform(self, True, email, password)
        except CallFailure:
            self.logout()
            return self.is_authenticated

        if 'SID' not in res or 'Auth' not in res:
            return False

        self._authtoken = res['Auth']

        self.is_authenticated = True

        # Get webclient cookies.
        # They're stored automatically by requests on the webclient session.
        try:
            webclient.Init.perform(self, True)
        except CallFailure:
            # throw away clientlogin credentials
            self.logout()

        return self.is_authenticated

    def _send_with_auth(self, req_kwargs, desired_auth, rsession):
        if desired_auth.sso:
            req_kwargs.setdefault('headers', {})

            # does this ever expire? would we have to perform clientlogin again?
            req_kwargs['headers']['Authorization'] = \
                'GoogleLogin auth=' + self._authtoken

        if desired_auth.xt:
            req_kwargs.setdefault('params', {})

            req_kwargs['params'].update({'u': 0, 'xt': rsession.cookies['xt']})

        return rsession.request(**req_kwargs)


class Mobileclient(Webclient):
    def login(self, email, password, *args, **kwargs):
        success = super(Mobileclient, self).login(email, password, *args, **kwargs)

        # Remove any webclient-specific cookies.
        # As of Feb 2014, sending these will cause a 403 when
        #  getting the stream url of an AA song.
        self._rsession.cookies = cookielib.CookieJar()

        return success


class Musicmanager(_Base):
    def __init__(self, *args, **kwargs):
        super(Musicmanager, self).__init__(*args, **kwargs)
        self._oauth_creds = None

    def login(self, oauth_credentials, *args, **kwargs):
        """Store an already-acquired oauth2client.Credentials."""
        super(Musicmanager, self).login()

        try:
            # refresh the token right away to check auth validity
            oauth_credentials.refresh(httplib2.Http())
        except oauth2client.client.Error:
            log.exception("error when refreshing oauth credentials")

        if oauth_credentials.access_token_expired:
            log.info("could not refresh oauth credentials")
            return False

        self._oauth_creds = oauth_credentials
        self.is_authenticated = True

        return self.is_authenticated

    def _send_with_auth(self, req_kwargs, desired_auth, rsession):
        if desired_auth.oauth:
            if self._oauth_creds.access_token_expired:
                self._oauth_creds.refresh(httplib2.Http())

            req_kwargs['headers'] = req_kwargs.get('headers', {})
            req_kwargs['headers']['Authorization'] = \
                'Bearer ' + self._oauth_creds.access_token

        return rsession.request(**req_kwargs)

########NEW FILE########
__FILENAME__ = local_tests
# -*- coding: utf-8 -*-

"""
Tests that don't hit the Google Music servers.
"""

from collections import namedtuple
import time

from mock import MagicMock as Mock
from proboscis.asserts import (
    assert_raises, assert_true, assert_false, assert_equal,
    assert_is_not, Check
)
from proboscis import test

import gmusicapi.session
from gmusicapi.clients import Webclient, Musicmanager
from gmusicapi.exceptions import AlreadyLoggedIn  # ,NotLoggedIn
from gmusicapi.protocol.shared import authtypes
from gmusicapi.protocol import mobileclient
from gmusicapi.utils import utils


#TODO test gather_local, transcoding

#All tests end up in the local group.
test = test(groups=['local'])


@test
def longest_increasing_sub():
    lisi = utils.longest_increasing_subseq
    assert_equal(lisi([]), [])
    assert_equal(lisi(range(10, 0, -1)), [1])
    assert_equal(lisi(range(10, 20)), range(10, 20))
    assert_equal(lisi([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]),
                 [1, 2, 3, 5, 8, 9])

##
# clients
##
# this feels like a dumb pattern, but I can't think of a better way
names = ('Webclient', 'Musicmanager')
Clients = namedtuple('Clients', [n.lower() for n in names])


def create_clients():
    clients = []
    for name in names:
        cls = getattr(gmusicapi.clients, name)
        c = cls()

        # mock out the underlying session
        c.session = Mock()
        clients.append(c)

    return Clients(*clients)


@test
def no_client_auth_initially():
    wc = Webclient()
    assert_false(wc.is_authenticated())

    mm = Musicmanager()
    assert_false(mm.is_authenticated())


@test
def mm_prevents_bad_mac_format():
    mm = create_clients().musicmanager

    with Check() as check:
        for bad_mac in ['bogus',
                        '11:22:33:44:55:66:',
                        '11:22:33:44:55:ab',
                        '11:22:33:44:55']:
            check.raises(
                ValueError,
                mm._perform_upauth,
                uploader_id=bad_mac,
                uploader_name='valid')


# @test
# def auto_playlists_are_empty():
#     # this doesn't actually hit the server at the moment.
#     # see issue 102
#     api = Api()
#     assert_equal(api.get_all_playlist_ids(auto=True, user=False),
#                  {'auto': {}})

##
# sessions
##
Sessions = namedtuple('Sessions', [n.lower() for n in names])


def create_sessions():
    sessions = []
    for name in names:
        cls = getattr(gmusicapi.session, name)
        s = cls()

        # mock out the underlying requests.session
        s._rsession = Mock()
        sessions.append(s)

    return Sessions(*sessions)


@test
def no_session_auth_initially():
    for s in create_sessions():
        assert_false(s.is_authenticated)


@test
def session_raises_alreadyloggedin():
    for s in create_sessions():
        s.is_authenticated = True

        def login():
            # hackish: login ignores args so we can test them all here;
            # this just ensures we have an acceptable amount of args
            s.login(*([None] * 3))

        assert_raises(AlreadyLoggedIn, login)


@test
def session_logout():
    for s in create_sessions():
        s.is_authenticated = True
        old_session = s._rsession
        s.logout()

        assert_false(s.is_authenticated)
        old_session.close.assert_called_once_with()
        assert_is_not(s._rsession, old_session)


@test
def send_without_auth():
    for s in create_sessions():
        s.is_authenticated = True

        mock_session = Mock()
        mock_req_kwargs = {'fake': 'kwargs'}

        s.send(mock_req_kwargs, authtypes(), mock_session)

        # sending without auth should not use the normal session,
        # since that might have auth cookies automatically attached
        assert_false(s._rsession.called)

        mock_session.request.called_once_with(**mock_req_kwargs)
        mock_session.closed.called_once_with()


##
# protocol
##

@test
def authtypes_factory_defaults():
    auth = authtypes()
    assert_false(auth.oauth)
    assert_false(auth.sso)
    assert_false(auth.xt)


@test
def authtypes_factory_args():
    auth = authtypes(oauth=True)
    assert_true(auth.oauth)
    assert_false(auth.sso)
    assert_false(auth.xt)


@test
def mc_url_signing():
    sig, _ = mobileclient.GetStreamUrl.get_signature("Tdr6kq3xznv5kdsphyojox6dtoq",
                                                     "1373247112519")
    assert_equal(sig, "gua1gInBdaVo7_dSwF9y0kodua0")


##
# utils
##

@test
def retry_failure_propogation():
    @utils.retry(tries=1)
    def raise_exception():
        raise AssertionError

    assert_raises(AssertionError, raise_exception)


@test
def retry_sleep_timing():

    @utils.retry(tries=3, delay=.05, backoff=2)
    def raise_exception():
        raise AssertionError

    pre = time.time()
    assert_raises(AssertionError, raise_exception)
    post = time.time()

    delta = post - pre
    assert_true(.15 < delta < .2, "delta: %s" % delta)


@test
def retry_is_dual_decorator():
    @utils.retry
    def return_arg(arg=None):
        return arg

    assert_equal(return_arg(1), 1)

########NEW FILE########
__FILENAME__ = rewrite_audiotest_tags
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""A script that will rewrite audiotest* metadata to match their filenames."""

from glob import glob
import os

import mutagen

for fname in glob(u'audiotest*'):
    audio = mutagen.File(fname, easy=True)

    if audio is None:
        print 'could not open', fname
        continue

    #clear existing tags
    for key in audio.tags.keys():
        del audio.tags[key]

    #write
    base = os.path.basename(fname)
    audio['title'] = base + ' title'
    audio['artist'] = base + ' artist'
    audio.save()

    #read back to verify
    audio = mutagen.File(fname, easy=True)  # assume it worked; it worked above
    print fname
    print '   ', audio.tags

########NEW FILE########
__FILENAME__ = run_tests
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from collections import namedtuple
from functools import partial, update_wrapper
from getpass import getpass
import logging
import os
import sys
from types import MethodType

from proboscis import TestProgram

from gmusicapi.clients import Webclient, Musicmanager, Mobileclient, OAUTH_FILEPATH
from gmusicapi.protocol.musicmanager import credentials_from_refresh_token
from gmusicapi.test import local_tests, server_tests  # noqa
from gmusicapi.test.utils import NoticeLogging

EnvArg = namedtuple('EnvArg', 'envarg kwarg description')

# these names needed to be compressed to fit everything into the travisci key size.
# there's also:
#    * GM_A: when set (to anything) states that we are testing on an All Access account.
#    * GM_AA_D_ID: a registered device id for use with mc streaming

wc_envargs = (
    EnvArg('GM_U', 'email', 'WC user. If not present, user will be prompted.'),
    EnvArg('GM_P', 'password', 'WC password. If not present, user will be prompted.'),
)

mm_envargs = (
    EnvArg('GM_O', 'oauth_credentials', 'MM refresh token. Defaults to MM.login default.'),
    EnvArg('GM_I', 'uploader_id', 'MM uploader id. Defaults to MM.login default.'),
    EnvArg('GM_N', 'uploader_name', 'MM uploader name. Default to MM.login default.'),
)


def prompt_for_wc_auth():
    """Return a valid (user, pass) tuple by continually
    prompting the user."""

    print ("These tests will never delete or modify your music."
           "\n\n"
           "If the tests fail, you *might* end up with a test"
           " song/playlist in your library, though."
           "\n")

    wclient = Webclient()
    valid_wc_auth = False

    while not valid_wc_auth:
        print
        email = raw_input("Email: ")
        passwd = getpass()

        valid_wc_auth = wclient.login(email, passwd)

    return email, passwd


def retrieve_auth():
    """Searches the env for auth, prompting the user if necessary.

    On success, return (wc_kwargs, mm_kwargs). On failure, raise ValueError."""

    get_kwargs = lambda envargs: dict([(arg.kwarg, os.environ.get(arg.envarg))
                                       for arg in envargs])

    wc_kwargs = get_kwargs(wc_envargs)
    mm_kwargs = get_kwargs(mm_envargs)

    if not all([wc_kwargs[arg] for arg in ('email', 'password')]):
        if os.environ.get('TRAVIS'):
            print 'on Travis but could not read auth from environ; quitting.'
            sys.exit(1)

        wc_kwargs.update(zip(['email', 'password'], prompt_for_wc_auth()))

    if mm_kwargs['oauth_credentials'] is None:
        # ignoring race
        if not os.path.isfile(OAUTH_FILEPATH):
            raise ValueError("You must have oauth credentials stored at the default"
                             " path by Musicmanager.perform_oauth prior to running.")
        del mm_kwargs['oauth_credentials']  # mm default is not None
    else:
        mm_kwargs['oauth_credentials'] = \
            credentials_from_refresh_token(mm_kwargs['oauth_credentials'])

    return (wc_kwargs, mm_kwargs)


def freeze_method_kwargs(klass, method_name, **kwargs):
    method = getattr(klass, method_name)

    setattr(klass, method_name, MethodType(
        update_wrapper(partial(method, **kwargs), method),
        None, klass))


def freeze_login_details(wc_kwargs, mm_kwargs):
    """Set the given kwargs to be the default for client login methods."""
    for cls, kwargs in ((Musicmanager, mm_kwargs),
                        (Webclient, wc_kwargs),
                        (Mobileclient, wc_kwargs),
                       ):
        freeze_method_kwargs(cls, 'login', **kwargs)


def main():
    """Search env for auth envargs and run tests."""

    if '--group=local' not in sys.argv:
        # hack: assume we're just running the proboscis local group
        freeze_login_details(*retrieve_auth())

    if 'GM_AA_D_ID' in os.environ:
        freeze_method_kwargs(
            Mobileclient,
            'get_stream_url',
            device_id=os.environ['GM_AA_D_ID'])

    # warnings typically signal a change in protocol,
    # so fail the build if anything >= warning are sent,
    noticer = NoticeLogging()
    noticer.setLevel(logging.WARNING)
    root_logger = logging.getLogger('gmusicapi')
    root_logger.addHandler(noticer)

    # proboscis does not have an exit=False equivalent,
    # so SystemExit must be caught instead (we need
    # to check the log noticer)
    try:
        TestProgram(module=sys.modules[__name__]).run_and_exit()
    except SystemExit as e:
        print
        if noticer.seen_message:
            print '(failing build due to log warnings)'
            sys.exit(1)

        if e.code is not None:
            sys.exit(e.code)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = server_tests
# -*- coding: utf-8 -*-

"""
These tests all run against an actual Google Music account.

Destructive modifications are not made, but if things go terrible wrong,
an extra test playlist or song may result.
"""

from collections import namedtuple
from hashlib import md5
import itertools
import os
import re
import types
import warnings

from decorator import decorator
from proboscis.asserts import (
    assert_true, assert_equal, assert_is_not_none,
    assert_raises, Check
)
from proboscis import test, before_class, after_class, SkipTest
import requests
from requests.exceptions import SSLError

from gmusicapi import Webclient, Musicmanager, Mobileclient
#from gmusicapi.protocol import mobileclient
from gmusicapi.protocol.shared import authtypes
#from gmusicapi.protocol.metadata import md_expectations
from gmusicapi.utils.utils import retry, id_or_nid
import gmusicapi.test.utils as test_utils

TEST_PLAYLIST_NAME = 'gmusicapi_test_playlist'
TEST_STATION_NAME = 'gmusicapi_test_station'

TEST_AA_GENRE_ID = 'METAL'

# that dumb little intro track on Conspiracy of One,
# picked since it's only a few seconds long
TEST_AA_SONG_ID = 'Tqqufr34tuqojlvkolsrwdwx7pe'

# used for testing streaming.
# differences between clients are presumably from stream quality.
TEST_AA_SONG_WC_HASH = '731fc03139a6aa9e4fa2f970b4d6d64f'
TEST_AA_SONG_MC_HASH = 'c1dcdf2b69fe809f717c0fc1f7303a27'

# Amorphis
TEST_AA_ARTIST_ID = 'Apoecs6off3y6k4h5nvqqos4b5e'

# Holographic Universe
TEST_AA_ALBUM_ID = 'B4cao5ms5jjn36notfgnhjtguwa'

# this is owned by my test account, so it shouldn't disappear
TEST_PLAYLIST_SHARETOKEN = ('AMaBXymHAkflgs5lvFAUyyQLYelqqMZNAB4v7Y_-'
                            'v9vmrctLOeW64GScAScoFHEnrLgOP5DSRpl9FYIH'
                            'b84HRBvyIMsxc7Zlrg==')

# this is a little data class for the songs we upload
TestSong = namedtuple('TestSong', 'sid title artist album full_data')


def sids(test_songs):
    """Given [TestSong], return ['sid']."""
    return [s.sid for s in test_songs]


def test_all_access_features():
    return 'GM_A' in os.environ


@decorator
def all_access(f, *args, **kwargs):
    """Declare a test to only be run if All Access testing is enabled."""
    if test_all_access_features():
        return f(*args, **kwargs)
    else:
        raise SkipTest('All Access testing disabled')


@test(groups=['server-other'])
class SslVerificationTests(object):
    # found on https://onlinessl.netlock.hu/en/test-center/invalid-ssl-certificate.html
    test_url = 'https://tv.eurosport.com/'

    @test
    def site_has_invalid_cert(self):
        assert_raises(SSLError, requests.head, self.test_url)

    def request_invalid_site(self, client):
        req_kwargs = {'url': self.test_url,
                      'method': 'HEAD'}
        no_auth = authtypes()

        client.session.send(req_kwargs, no_auth)

    @test
    def clients_verify_by_default(self):
        for client_cls in (Webclient, Mobileclient, Musicmanager):
            assert_raises(SSLError, self.request_invalid_site, client_cls())

    @test
    def disable_client_verify(self):
        for client_cls in (Webclient, Mobileclient, Musicmanager):
            self.request_invalid_site(client_cls(verify_ssl=False))  # should not raise SSLError


@test(groups=['server'])
class ClientTests(object):
    # set on the instance in login
    wc = None  # webclient
    mm = None  # musicmanager
    mc = None  # mobileclient

    #These are set on the instance in eg create_song.

    # both are [TestSong]
    user_songs = None
    aa_songs = None

    playlist_ids = None
    plentry_ids = None
    station_ids = None

    @property
    def all_songs(self):
        return (self.user_songs or []) + (self.aa_songs or [])

    def mc_get_playlist_songs(self, plid):
        """For convenience, since mc can only get all playlists at once."""
        all_contents = self.mc.get_all_user_playlist_contents()
        found = [p for p in all_contents if p['id'] == plid]

        assert_true(len(found), 1)

        return found[0]['tracks']

    @before_class
    def login(self):
        self.wc = test_utils.new_test_client(Webclient)
        assert_true(self.wc.is_authenticated())

        self.mm = test_utils.new_test_client(Musicmanager)
        assert_true(self.mm.is_authenticated())

        self.mc = test_utils.new_test_client(Mobileclient)
        assert_true(self.mc.is_authenticated())

    @after_class(always_run=True)
    def logout(self):
        if self.wc is None:
            raise SkipTest('did not create wc')
        assert_true(self.wc.logout())

        if self.mm is None:
            raise SkipTest('did not create mm')
        assert_true(self.mm.logout())

        if self.mc is None:
            raise SkipTest('did not create mc')
        assert_true(self.mc.logout())

    # This next section is a bit odd: it orders tests that create
    # required resources.

    # The intuitition: starting from an empty library, you need to create
    #  a song before you can eg add it to a playlist.

    # The dependencies end up with an ordering that might look like:
    #
    # with song
    #   with playlist
    #     with plentry
    #   with station
    #
    #
    # Suggestions to improve any of this are welcome!

    @staticmethod
    @retry
    def assert_songs_state(method, sids, present):
        """
        Assert presence/absence of sids and return a list of
        TestSongs found.

        :param method: eg self.mc.get_all_songs
        :param sids: list of song ids
        :param present: if True verify songs are present; False the opposite
        """

        library = method()

        found = [s for s in library if s['id'] in sids]

        expected_len = len(sids)
        if not present:
            expected_len = 0

        assert_equal(len(found), expected_len)

        return [TestSong(s['id'], s['title'], s['artist'], s['album'], s)
                for s in found]

    @staticmethod
    @retry
    def assert_list_inc_equivalence(method, **kwargs):
        """
        Assert that some listing method returns the same
        contents for incremental=True/False.

        :param method: eg self.mc.get_all_songs, must support `incremental` kwarg
        :param **kwargs: passed to method
        """

        lib_chunk_gen = method(incremental=True, **kwargs)
        assert_true(isinstance(lib_chunk_gen, types.GeneratorType))

        assert_equal([e for chunk in lib_chunk_gen for e in chunk],
                     method(incremental=False, **kwargs))

    @staticmethod
    @retry
    def assert_listing_contains_deleted_items(method):
        """
        Assert that some listing method includes deleted tracks.

        :param method: eg self.mc.get_all_songs
        """
        lib = method(incremental=False, include_deleted=True)

        # how long do deleted tracks get returned for?
        # will this return tracks I've deleted since...ever?

        num_deleted = [t for t in lib if t['deleted']]
        assert_true(num_deleted > 0)

    @test
    def song_create(self):
        # This can create more than one song: one through uploading, one through
        # adding an AA track to the library.

        user_sids = []
        aa_sids = []

        fname = test_utils.small_mp3

        uploaded, matched, not_uploaded = self.mm.upload(fname)

        if len(not_uploaded) == 1 and 'ALREADY_EXISTS' in not_uploaded[fname]:
            # delete the song if it exists already because a previous test failed
            self.mc.delete_songs(re.search(r'\(.*\)', not_uploaded[fname]).group().strip('()'))

            # and retry the upload
            uploaded, matched, not_uploaded = self.mm.upload(fname)

        # Otherwise, it should have been uploaded normally.
        assert_equal(not_uploaded, {})
        assert_equal(matched, {})
        assert_equal(uploaded.keys(), [fname])

        user_sids.append(uploaded[fname])

        if test_all_access_features():
            aa_sids.append(self.mc.add_aa_track(TEST_AA_SONG_ID))

        # we test get_all_songs here so that we can assume the existance
        # of the song for future tests (the servers take time to sync an upload)

        self.user_songs = self.assert_songs_state(self.mc.get_all_songs, user_sids, present=True)
        self.aa_songs = self.assert_songs_state(self.mc.get_all_songs, aa_sids, present=True)

    @test
    def playlist_create(self):
        mc_id = self.mc.create_playlist(TEST_PLAYLIST_NAME)
        wc_id = self.wc.create_playlist(TEST_PLAYLIST_NAME, "", public=True)

        # like song_create, retry until the playlist appears
        @retry
        def assert_playlist_exists(plids):
            found = [p for p in self.mc.get_all_playlists()
                     if p['id'] in plids]

            assert_equal(len(found), 2)

        assert_playlist_exists([mc_id, wc_id])
        self.playlist_ids = [mc_id, wc_id]

    @test(depends_on=[playlist_create, song_create],
          runs_after_groups=['playlist.exists', 'song.exists'])
    def plentry_create(self):

        song_ids = [self.user_songs[0].sid]

        # create 3 entries total
        # 3 songs is the minimum to fully test reordering, and also includes the
        # duplicate song_id case
        double_id = self.user_songs[0].sid
        if test_all_access_features():
            double_id = TEST_AA_SONG_ID

        song_ids += [double_id] * 2

        plentry_ids = self.mc.add_songs_to_playlist(self.playlist_ids[0], song_ids)

        @retry
        def assert_plentries_exist(plid, plentry_ids):
            songs = self.mc_get_playlist_songs(plid)
            found = [e for e in songs
                     if e['id'] in plentry_ids]

            assert_equal(len(found), len(plentry_ids))

        assert_plentries_exist(self.playlist_ids[0], plentry_ids)
        self.plentry_ids = plentry_ids

    @test(groups=['plentry'], depends_on=[plentry_create],
          runs_after_groups=['plentry.exists'],
          always_run=True)
    def plentry_delete(self):
        if self.plentry_ids is None:
            raise SkipTest('did not store self.plentry_ids')

        res = self.mc.remove_entries_from_playlist(self.plentry_ids)
        assert_equal(res, self.plentry_ids)

        @retry
        def assert_plentries_removed(plid, entry_ids):
            found = [e for e in self.mc_get_playlist_songs(plid)
                     if e['id'] in entry_ids]

            assert_equal(len(found), 0)

        assert_plentries_removed(self.playlist_ids[0], self.plentry_ids)
        #self.assert_listing_contains_deleted_items(self.mc_get_playlist_songs)

    @test(groups=['playlist'], depends_on=[playlist_create],
          runs_after=[plentry_delete],
          runs_after_groups=['playlist.exists'],
          always_run=True)
    def playlist_delete(self):
        if self.playlist_ids is None:
            raise SkipTest('did not store self.playlist_ids')

        for plid in self.playlist_ids:
            res = self.mc.delete_playlist(plid)
            assert_equal(res, plid)

        @retry
        def assert_playlist_does_not_exist(plid):
            found = [p for p in self.mc.get_all_playlists(include_deleted=False)
                     if p['id'] == plid]

            assert_equal(len(found), 0)

        for plid in self.playlist_ids:
            assert_playlist_does_not_exist(plid)
            self.assert_listing_contains_deleted_items(self.mc.get_all_playlists)

    @test
    def station_create(self):
        if not test_all_access_features():
            raise SkipTest('AA testing not enabled')

        station_ids = []
        for prefix, kwargs in (('AA song', {'track_id': TEST_AA_SONG_ID}),
                               ('AA-added song', {'track_id': self.aa_songs[0].sid}),
                               ('up song', {'track_id': self.user_songs[0].sid}),
                               ('artist', {'artist_id': TEST_AA_ARTIST_ID}),
                               ('album', {'album_id': TEST_AA_ALBUM_ID}),
                               ('genre', {'genre_id': TEST_AA_GENRE_ID})):
            station_ids.append(
                self.mc.create_station(prefix + ' ' + TEST_STATION_NAME, **kwargs))

        @retry
        def assert_station_exists(station_id):
            stations = self.mc.get_all_stations()

            found = [s for s in stations
                     if s['id'] == station_id]

            assert_equal(len(found), 1)

        for station_id in station_ids:
            assert_station_exists(station_id)

        self.station_ids = station_ids

    @test(groups=['station'], depends_on=[station_create, song_create],
          runs_after_groups=['station.exists', 'song.exists'],
          always_run=True)
    def station_delete(self):
        if self.station_ids is None:
            raise SkipTest('did not store self.station_ids')

        res = self.mc.delete_stations(self.station_ids)
        assert_equal(res, self.station_ids)

        @retry
        def assert_station_deleted(station_id):
            stations = self.mc.get_all_stations()

            found = [s for s in stations
                     if s['id'] == station_id]

            assert_equal(len(found), 0)

        for station_id in self.station_ids:
            assert_station_deleted(station_id)
        self.assert_listing_contains_deleted_items(self.mc.get_all_stations)

    @test(groups=['song'], depends_on=[song_create],
          runs_after=[plentry_delete, station_delete],
          runs_after_groups=["song.exists"],
          always_run=True)
    def song_delete(self):
        # split deletion between wc and mc
        # mc is the only to run if AA testing not enabled
        with Check() as check:
            for i, testsong in enumerate(self.all_songs):
                if i % 2 == 0:
                    res = self.mc.delete_songs(testsong.sid)
                else:
                    with warnings.catch_warnings():
                        warnings.simplefilter("ignore")
                        res = self.wc.delete_songs(testsong.sid)
                check.equal(res, [testsong.sid])

        self.assert_songs_state(self.mc.get_all_songs, sids(self.all_songs), present=False)
        self.assert_listing_contains_deleted_items(self.mc.get_all_songs)

    ## These decorators just prevent setting groups and depends_on over and over.
    ## They won't work right with additional settings; if that's needed this
    ##  pattern should be factored out.

    ##TODO it'd be nice to have per-client test groups
    song_test = test(groups=['song', 'song.exists'], depends_on=[song_create])
    playlist_test = test(groups=['playlist', 'playlist.exists'],
                         depends_on=[playlist_create])
    plentry_test = test(groups=['plentry', 'plentry.exists'],
                        depends_on=[plentry_create])
    station_test = test(groups=['station', 'station.exists'], depends_on=[station_create])

    ## Non-wonky tests resume down here.

    ##---------
    ## MM tests
    ##---------

    @song_test
    def mm_list_new_songs(self):
        # mm only includes user-uploaded songs
        self.assert_songs_state(self.mm.get_uploaded_songs, sids(self.user_songs), present=True)
        self.assert_songs_state(self.mm.get_uploaded_songs, sids(self.aa_songs), present=False)

    @test
    def mm_list_songs_inc_equal(self):
        self.assert_list_inc_equivalence(self.mm.get_uploaded_songs)

    @song_test
    def mm_download_song(self):

        @retry
        def assert_download(sid):
            filename, audio = self.mm.download_song(sid)

            #TODO could use original filename to verify this
            # but, when manually checking, got modified title occasionally
            assert_true(filename.endswith('.mp3'))
            assert_is_not_none(audio)

        assert_download(self.user_songs[0].sid)

    ##---------
    ## WC tests
    ##---------

    @test
    def wc_get_registered_devices(self):
        # no logic; just checking schema
        self.wc.get_registered_devices()

    @test
    @all_access
    def wc_get_aa_stream_urls(self):
        urls = self.wc.get_stream_urls(TEST_AA_SONG_ID)

        assert_true(len(urls) > 1)

    @test
    @all_access
    def wc_stream_aa_track_with_header(self):
        audio = self.wc.get_stream_audio(TEST_AA_SONG_ID, use_range_header=True)

        assert_equal(md5(audio).hexdigest(), TEST_AA_SONG_WC_HASH)

    @test
    @all_access
    def wc_stream_aa_track_without_header(self):
        audio = self.wc.get_stream_audio(TEST_AA_SONG_ID, use_range_header=False)

        assert_equal(md5(audio).hexdigest(), TEST_AA_SONG_WC_HASH)

    @song_test
    def wc_get_download_info(self):
        url, download_count = self.wc.get_song_download_info(self.user_songs[0].sid)

        assert_is_not_none(url)

    @song_test
    def wc_get_uploaded_stream_urls(self):
        urls = self.wc.get_stream_urls(self.user_songs[0].sid)

        assert_equal(len(urls), 1)

        url = urls[0]

        assert_is_not_none(url)
        assert_equal(url.split(':')[0], 'https')

    @song_test
    def wc_upload_album_art(self):
        url = self.wc.upload_album_art(self.user_songs[0].sid, test_utils.image_filename)
        assert_equal(url[:7], 'http://')
        #TODO download the track and verify the metadata changed

    ##---------
    ## MC tests
    ##---------

    @test
    def mc_list_stations_inc_equal(self):
        self.assert_list_inc_equivalence(self.mc.get_all_stations)

    @test
    def mc_list_stations_inc_equal_with_deleted(self):
        self.assert_list_inc_equivalence(self.mc.get_all_stations, include_deleted=True)

    @test
    def mc_list_shared_playlist_entries(self):
        entries = self.mc.get_shared_playlist_contents(TEST_PLAYLIST_SHARETOKEN)
        assert_true(len(entries) > 0)

    @test
    @all_access
    def mc_stream_aa_track(self):
        url = self.mc.get_stream_url(TEST_AA_SONG_ID)  # uses frozen device_id
        audio = self.mc.session._rsession.get(url).content
        assert_equal(md5(audio).hexdigest(), TEST_AA_SONG_MC_HASH)

    @song_test
    def mc_get_uploaded_track_stream_url(self):
        url = self.mc.get_stream_url(self.user_songs[0].sid)

        assert_is_not_none(url)
        assert_equal(url[:7], 'http://')

    @staticmethod
    @retry
    def _assert_song_key_equal_to(method, sid, key, value):
        """
        :param method: eg self.mc.get_all_songs
        :param sid: song id
        :param key: eg 'rating'
        :param value: eg '1'
        """
        songs = method()

        if not isinstance(songs, list):
            # kind of a hack to support get_track_info as well
            songs = [songs]

        found = [s for s in songs if id_or_nid(s) == sid]

        assert_equal(len(found), 1)

        assert_equal(found[0][key], value)
        return found[0]

    # how can I get the rating key to show up for store tracks?
    # it works in Google's clients!

    # @test
    # @all_access
    # def mc_change_store_song_rating(self):
    #     song = self.mc.get_track_info(TEST_AA_SONG_ID)

    #     # increment by one but keep in rating range
    #     song['rating'] = int(song.get('rating', '0')) + 1
    #     song['rating'] = str(song['rating'] % 6)

    #     self.mc.change_song_metadata(song)

    #     self._assert_song_key_equal_to(lambda: self.mc.get_track_info(TEST_AA_SONG_ID),
    #                              id_or_nid(song),
    #                              song['rating'])

    @song_test
    def mc_change_uploaded_song_rating(self):
        song = self._assert_song_key_equal_to(
            self.mc.get_all_songs,
            self.all_songs[0].sid,
            'rating',
            '0')  # initially unrated

        song['rating'] = '1'
        self.mc.change_song_metadata(song)

        self._assert_song_key_equal_to(self.mc.get_all_songs, song['id'], 'rating', '1')

    def _test_increment_playcount(self, sid):
        matching = [t for t in self.mc.get_all_songs()
                    if t['id'] == sid]
        assert_equal(len(matching), 1)

        initial_playcount = matching[0]['playCount']

        self.mc.increment_song_playcount(sid, 2)

        self._assert_song_key_equal_to(
            self.mc.get_all_songs,
            sid,
            'playCount',
            initial_playcount + 2)

    @song_test
    def mc_increment_uploaded_song_playcount(self):
        self._test_increment_playcount(self.all_songs[0].sid)

    @song_test
    @all_access
    def mc_increment_aa_song_playcount(self):
        self._test_increment_playcount(self.all_songs[1].sid)

    @song_test
    def mc_change_uploaded_song_title_fails(self):
        # this used to work, but now only ratings can be changed.
        # this test is here so I can tell if this starts working again.
        song = self.assert_songs_state(self.mc.get_all_songs, [self.all_songs[0].sid],
                                       present=True)[0]

        old_title = song.title
        new_title = old_title + '_mod'
        self.mc.change_song_metadata({'id': song.sid, 'title': new_title})

        self._assert_song_key_equal_to(self.mc.get_all_songs, song.sid, 'title', old_title)

    @song_test
    def mc_list_songs_inc_equal(self):
        self.assert_list_inc_equivalence(self.mc.get_all_songs)

    @song_test
    def mc_list_songs_inc_equal_with_deleted(self):
        self.assert_list_inc_equivalence(self.mc.get_all_songs, include_deleted=True)

    @playlist_test
    def mc_list_playlists_inc_equal(self):
        self.assert_list_inc_equivalence(self.mc.get_all_playlists)

    @playlist_test
    def mc_list_playlists_inc_equal_with_deleted(self):
        self.assert_list_inc_equivalence(self.mc.get_all_playlists, include_deleted=True)

    @playlist_test
    def mc_change_playlist_name(self):
        new_name = TEST_PLAYLIST_NAME + '_mod'
        plid = self.mc.change_playlist_name(self.playlist_ids[0], new_name)
        assert_equal(self.playlist_ids[0], plid)

        @retry  # change takes time to propogate
        def assert_name_equal(plid, name):
            playlists = self.mc.get_all_playlists()

            found = [p for p in playlists if p['id'] == plid]

            assert_equal(len(found), 1)
            assert_equal(found[0]['name'], name)

        assert_name_equal(self.playlist_ids[0], new_name)

        # revert
        self.mc.change_playlist_name(self.playlist_ids[0], TEST_PLAYLIST_NAME)
        assert_name_equal(self.playlist_ids[0], TEST_PLAYLIST_NAME)

    @retry
    def _mc_assert_ple_position(self, entry, pos):
        """
        :param entry: entry dict
        :pos: 0-based position to assert
        """
        pl = self.mc_get_playlist_songs(entry['playlistId'])

        indices = [i for (i, e) in enumerate(pl)
                   if e['id'] == entry['id']]

        assert_equal(len(indices), 1)

        assert_equal(indices[0], pos)

    @plentry_test
    def mc_reorder_ple_forwards(self):
        playlist_len = len(self.plentry_ids)
        for from_pos, to_pos in [pair for pair in
                                 itertools.product(range(playlist_len), repeat=2)
                                 if pair[0] < pair[1]]:
            pl = self.mc_get_playlist_songs(self.playlist_ids[0])

            from_e = pl[from_pos]

            e_before_new_pos, e_after_new_pos = None, None

            if to_pos - 1 >= 0:
                e_before_new_pos = pl[to_pos]

            if to_pos + 1 < playlist_len:
                e_after_new_pos = pl[to_pos + 1]

            self.mc.reorder_playlist_entry(from_e,
                                           to_follow_entry=e_before_new_pos,
                                           to_precede_entry=e_after_new_pos)
            self._mc_assert_ple_position(from_e, to_pos)

            if e_before_new_pos:
                self._mc_assert_ple_position(e_before_new_pos, to_pos - 1)

            if e_after_new_pos:
                self._mc_assert_ple_position(e_after_new_pos, to_pos + 1)

    @plentry_test
    def mc_reorder_ple_backwards(self):
        playlist_len = len(self.plentry_ids)
        for from_pos, to_pos in [pair for pair in
                                 itertools.product(range(playlist_len), repeat=2)
                                 if pair[0] > pair[1]]:
            pl = self.mc_get_playlist_songs(self.playlist_ids[0])

            from_e = pl[from_pos]

            e_before_new_pos, e_after_new_pos = None, None

            if to_pos - 1 >= 0:
                e_before_new_pos = pl[to_pos - 1]

            if to_pos + 1 < playlist_len:
                e_after_new_pos = pl[to_pos]

            self.mc.reorder_playlist_entry(from_e,
                                           to_follow_entry=e_before_new_pos,
                                           to_precede_entry=e_after_new_pos)
            self._mc_assert_ple_position(from_e, to_pos)

            if e_before_new_pos:
                self._mc_assert_ple_position(e_before_new_pos, to_pos - 1)

            if e_after_new_pos:
                self._mc_assert_ple_position(e_after_new_pos, to_pos + 1)

    # This fails, unfortunately, which means n reorderings mean n
    # separate calls in the general case.
    #@plentry_test
    #def mc_reorder_ples_forwards(self):
    #    pl = self.mc_get_playlist_songs(self.playlist_ids[0])
    #    # rot2, eg 0123 -> 2301
    #    pl.append(pl.pop(0))
    #    pl.append(pl.pop(0))

    #    mutate_call = mobileclient.BatchMutatePlaylistEntries
    #    mutations = [
    #        mutate_call.build_plentry_reorder(
    #            pl[-1], pl[-2]['clientId'], None),
    #        mutate_call.build_plentry_reorder(
    #            pl[-2], pl[-3]['clientId'], pl[-1]['clientId'])
    #    ]

    #    self.mc._make_call(mutate_call, [mutations])
    #    self._mc_assert_ple_position(pl[-1], len(pl) - 1)
    #    self._mc_assert_ple_position(pl[-2], len(pl) - 2)

    @station_test
    @all_access
    def mc_list_station_tracks(self):
        for station_id in self.station_ids:
            self.mc.get_station_tracks(station_id, num_tracks=1)
            # used to assert that at least 1 track came back, but
            # our dummy uploaded track won't match anything

    @test
    @all_access
    def mc_search_aa(self):
        res = self.mc.search_all_access('amorphis')
        with Check() as check:
            for hits in res.values():
                check.true(len(hits) > 0)

    @test
    @all_access
    def mc_artist_info(self):
        aid = 'Apoecs6off3y6k4h5nvqqos4b5e'  # amorphis
        optional_keys = set(('albums', 'topTracks', 'related_artists'))

        include_all_res = self.mc.get_artist_info(aid, include_albums=True,
                                                  max_top_tracks=1, max_rel_artist=1)

        no_albums_res = self.mc.get_artist_info(aid, include_albums=False)
        no_rel_res = self.mc.get_artist_info(aid, max_rel_artist=0)
        no_tracks_res = self.mc.get_artist_info(aid, max_top_tracks=0)

        with Check() as check:
            check.true(set(include_all_res.keys()) & optional_keys == optional_keys)

            check.true(set(no_albums_res.keys()) & optional_keys ==
                       optional_keys - set(['albums']))
            check.true(set(no_rel_res.keys()) & optional_keys ==
                       optional_keys - set(['related_artists']))
            check.true(set(no_tracks_res.keys()) & optional_keys ==
                       optional_keys - set(['topTracks']))

    @test
    @retry
    @all_access
    def mc_album_info(self):
        include_tracks = self.mc.get_album_info(TEST_AA_ALBUM_ID, include_tracks=True)
        no_tracks = self.mc.get_album_info(TEST_AA_ALBUM_ID, include_tracks=False)

        with Check() as check:
            check.true('tracks' in include_tracks)
            check.true('tracks' not in no_tracks)

            del include_tracks['tracks']
            check.equal(include_tracks, no_tracks)

    @test
    @all_access
    def mc_track_info(self):
        self.mc.get_track_info(TEST_AA_SONG_ID)  # just for the schema

    @test
    @all_access
    def mc_genres(self):
        self.mc.get_genres()  # just for the schema

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

"""Utilities used in testing."""

import logging
import numbers
import os
import re


#from gmusicapi.api import Api
from gmusicapi.protocol.metadata import md_expectations
from gmusicapi.utils import utils

log = utils.DynamicClientLogger(__name__)


#A regex for the gm id format, eg:
#c293dd5a-9aa9-33c4-8b09-0c865b56ce46
hex_set = "[0-9a-f]"
gm_id_regex = re.compile(("{h}{{8}}-" +
                         ("{h}{{4}}-" * 3) +
                         "{h}{{12}}").format(h=hex_set))

#Get the absolute paths of the test files, which are located in the same
# directory as this file.
cwd = os.getcwd()
test_file_dir = os.path.dirname(os.path.abspath(__file__))

small_mp3 = os.path.join(test_file_dir, u'audiotest_small.mp3')
image_filename = os.path.join(test_file_dir, u'imagetest_10x10_check.png')

# that dumb intro track on conspiracy of one
aa_song_id = 'Tqqufr34tuqojlvkolsrwdwx7pe'


class NoticeLogging(logging.Handler):
    """A log handler that, if asked to emit, will set
    ``self.seen_message`` to True.
    """

    def __init__(self):
        logging.Handler.__init__(self)  # cannot use super in py 2.6; logging is still old-style
        self.seen_message = False

    def emit(self, record):
        self.seen_message = True


def new_test_client(cls, **kwargs):
    """Make an instance of a client, login, and return it.

    kwargs are passed through to cls.login().
    """

    client = cls(debug_logging=True)
    client.login(**kwargs)

    return client


def modify_md(md_name, val):
    """Returns a value of the same type as val that will not equal val."""

    #Check for metadata that must get specific values.
    if md_expectations[md_name].allowed_values is not None:
        #Assume old_val is a possible value, and return
        # the value one modulus index after it.

        possible = md_expectations[md_name].allowed_values
        val_i = 0
        try:
            val_i = possible.index(val)
        except ValueError:
            log.warning("non-allowed metadata value '%s' for key %s", val, md_name)

        return possible[(val_i + 1) % len(possible)]

    #Generic handlers for other data types.
    if isinstance(val, basestring):
        return val + "_mod"

    #Need to check for bool first, bools are instances of Number for some reason.
    elif isinstance(val, bool):
        return not val
    elif isinstance(val, numbers.Number):
        return val + 1
    else:
        raise TypeError("modify expects only strings, numbers, and bools")


def md_entry_same(entry_name, s1, s2):
    """Returns (s1 and s2 have the same value for entry_name?, message)."""

    s1_val = s1[entry_name]
    s2_val = s2[entry_name]

    return (s1_val == s2_val, "(" + entry_name + ") " + repr(s1_val) + ", " + repr(s2_val))


def is_gm_id(s):
    """Returns True if the given string is in Google Music id form."""
    return re.match(gm_id_regex, s) is not None


def is_song(d):
    """Returns True is the given dict is a GM song dict."""
    #Not really precise, but should be good enough.
    return is_gm_id(d["id"])


def is_song_list(lst):
    return all(map(is_song, lst))


def is_id_list(lst):
    """Returns True if the given list is made up of all strings in GM id form."""
    return all(map(is_gm_id, lst))


def is_id_pair_list(lst):
    """Returns True if the given list is made up of all (id, id) pairs."""
    a, b = zip(*lst)
    return is_id_list(a + b)

########NEW FILE########
__FILENAME__ = counter
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from operator import itemgetter
from heapq import nlargest
from itertools import repeat, ifilter

class Counter(dict):
    '''Dict subclass for counting hashable objects.  Sometimes called a bag
    or multiset.  Elements are stored as dictionary keys and their counts
    are stored as dictionary values.

    >>> Counter('zyzygy')
    Counter({'y': 3, 'z': 2, 'g': 1})

    '''

    def __init__(self, iterable=None, **kwds):
        '''Create a new, empty Counter object.  And if given, count elements
        from an input iterable.  Or, initialize the count from another mapping
        of elements to their counts.

        >>> c = Counter()                           # a new, empty counter
        >>> c = Counter('gallahad')                 # a new counter from an iterable
        >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
        >>> c = Counter(a=4, b=2)                   # a new counter from keyword args

        '''
        self.update(iterable, **kwds)

    def __missing__(self, key):
        return 0

    def most_common(self, n=None):
        '''List the n most common elements and their counts from the most
        common to the least.  If n is None, then list all element counts.

        >>> Counter('abracadabra').most_common(3)
        [('a', 5), ('r', 2), ('b', 2)]

        '''
        if n is None:
            return sorted(self.iteritems(), key=itemgetter(1), reverse=True)
        return nlargest(n, self.iteritems(), key=itemgetter(1))

    def elements(self):
        '''Iterator over elements repeating each as many times as its count.

        >>> c = Counter('ABCABC')
        >>> sorted(c.elements())
        ['A', 'A', 'B', 'B', 'C', 'C']

        If an element's count has been set to zero or is a negative number,
        elements() will ignore it.

        '''
        for elem, count in self.iteritems():
            for _ in repeat(None, count):
                yield elem

    # Override dict methods where the meaning changes for Counter objects.

    @classmethod
    def fromkeys(cls, iterable, v=None):
        raise NotImplementedError(
            'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')

    def update(self, iterable=None, **kwds):
        '''Like dict.update() but add counts instead of replacing them.

        Source can be an iterable, a dictionary, or another Counter instance.

        >>> c = Counter('which')
        >>> c.update('witch')           # add elements from another iterable
        >>> d = Counter('watch')
        >>> c.update(d)                 # add elements from another counter
        >>> c['h']                      # four 'h' in which, witch, and watch
        4

        '''
        if iterable is not None:
            if hasattr(iterable, 'iteritems'):
                if self:
                    self_get = self.get
                    for elem, count in iterable.iteritems():
                        self[elem] = self_get(elem, 0) + count
                else:
                    dict.update(self, iterable) # fast path when counter is empty
            else:
                self_get = self.get
                for elem in iterable:
                    self[elem] = self_get(elem, 0) + 1
        if kwds:
            self.update(kwds)

    def copy(self):
        'Like dict.copy() but returns a Counter instance instead of a dict.'
        return Counter(self)

    def __delitem__(self, elem):
        'Like dict.__delitem__() but does not raise KeyError for missing values.'
        if elem in self:
            dict.__delitem__(self, elem)

    def __repr__(self):
        if not self:
            return '%s()' % self.__class__.__name__
        items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
        return '%s({%s})' % (self.__class__.__name__, items)

    # Multiset-style mathematical operations discussed in:
    #       Knuth TAOCP Volume II section 4.6.3 exercise 19
    #       and at http://en.wikipedia.org/wiki/Multiset
    #
    # Outputs guaranteed to only include positive counts.
    #
    # To strip negative and zero counts, add-in an empty counter:
    #       c += Counter()

    def __add__(self, other):
        '''Add counts from two counters.

        >>> Counter('abbb') + Counter('bcc')
        Counter({'b': 4, 'c': 2, 'a': 1})


        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            newcount = self[elem] + other[elem]
            if newcount > 0:
                result[elem] = newcount
        return result

    def __sub__(self, other):
        ''' Subtract count, but keep only results with positive counts.

        >>> Counter('abbbc') - Counter('bccd')
        Counter({'b': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        result = Counter()
        for elem in set(self) | set(other):
            newcount = self[elem] - other[elem]
            if newcount > 0:
                result[elem] = newcount
        return result

    def __or__(self, other):
        '''Union is the maximum of value in either of the input counters.

        >>> Counter('abbb') | Counter('bcc')
        Counter({'b': 3, 'c': 2, 'a': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        _max = max
        result = Counter()
        for elem in set(self) | set(other):
            newcount = _max(self[elem], other[elem])
            if newcount > 0:
                result[elem] = newcount
        return result

    def __and__(self, other):
        ''' Intersection is the minimum of corresponding counts.

        >>> Counter('abbb') & Counter('bcc')
        Counter({'b': 1})

        '''
        if not isinstance(other, Counter):
            return NotImplemented
        _min = min
        result = Counter()
        if len(self) < len(other):
            self, other = other, self
        for elem in ifilter(self.__contains__, other):
            newcount = _min(self[elem], other[elem])
            if newcount > 0:
                result[elem] = newcount
        return result


if __name__ == '__main__':
    import doctest
    print doctest.testmod()

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

"""Utility functions used across api code."""

from bisect import bisect_left
from distutils import spawn
import errno
import functools
import inspect
import logging
import os
import re
import subprocess
import time
import traceback
import warnings

from decorator import decorator
from google.protobuf.descriptor import FieldDescriptor

from gmusicapi import __version__
from gmusicapi.compat import my_appdirs
from gmusicapi.exceptions import CallFailure, GmusicapiWarning

# this controls the crazy logging setup that checks the callstack;
#  it should be monkey-patched to False after importing to disable it.
# when False, static code will simply log in the standard way under the root.
per_client_logging = True

#Map descriptor.CPPTYPE -> python type.
_python_to_cpp_types = {
    long: ('int32', 'int64', 'uint32', 'uint64'),
    float: ('double', 'float'),
    bool: ('bool',),
    str: ('string',),
}

cpp_type_to_python = dict(
    (getattr(FieldDescriptor, 'CPPTYPE_' + cpp.upper()), python)
    for (python, cpplist) in _python_to_cpp_types.items()
    for cpp in cpplist
)

log_filepath = os.path.join(my_appdirs.user_log_dir, 'gmusicapi.log')
printed_log_start_message = False  # global, set in config_debug_logging

# matches a mac address in GM form, eg
#   00:11:22:33:AA:BB
_mac_pattern = re.compile("^({pair}:){{5}}{pair}$".format(pair='[0-9A-F]' * 2))


class DynamicClientLogger(object):
    """Dynamically proxies to the logger of a Client higher in the call stack.

    This is a ridiculous hack needed because
    logging is, in the eyes of a user, per-client.

    So, logging from static code (eg protocol, utils) needs to log using the
    config of the calling client's logger.

    There can be multiple clients, so we can't just use a globally-available
    logger.

    Instead of refactoring every function to receieve a logger, we introspect
    the callstack at runtime to figure out who's calling us, then use their
    logger.

    This probably won't work on non-CPython implementations.
    """

    def __init__(self, caller_name):
        self.caller_name = caller_name

    def __getattr__(self, name):
        # this isn't a totally foolproof way to proxy, but it's fine for
        # the usual logger.debug, etc methods.

        logger = logging.getLogger(self.caller_name)

        if per_client_logging:
            # search upwards for a client instance
            for frame_rec in inspect.getouterframes(inspect.currentframe()):
                frame = frame_rec[0]

                try:
                    if 'self' in frame.f_locals:
                        f_self = frame.f_locals['self']

                        # can't import and check against classes; that causes an import cycle
                        if ((f_self is not None and
                             f_self.__module__.startswith('gmusicapi.clients') and
                             f_self.__class__.__name__ in ('Musicmanager', 'Webclient',
                                                           'Mobileclient'))):
                            logger = f_self.logger
                            break
                finally:
                    del frame  # avoid circular references

            else:
                # log to root logger.
                # should this be stronger? There's no default root logger set up.
                stack = traceback.extract_stack()
                logger.info('could not locate client caller in stack:\n%s',
                            '\n'.join(traceback.format_list(stack)))

        return getattr(logger, name)


log = DynamicClientLogger(__name__)


def deprecated(instructions):
    """Flags a method as deprecated.

    :param instructions: human-readable note to assist migration.
    """

    @decorator
    def wrapper(func, *args, **kwargs):
        message = "{0} is deprecated and may break unexpectedly.\n{1}".format(
            func.__name__,
            instructions)

        warnings.warn(message,
                      GmusicapiWarning,
                      stacklevel=2)

        return func(*args, **kwargs)

    return wrapper


def longest_increasing_subseq(seq):
    """Returns the longest (non-contiguous) subsequence
    of seq that is strictly increasing.
    """
    # adapted from http://goo.gl/lddm3c
    if not seq:
        return []

    # head[j] = index in 'seq' of the final member of the best subsequence
    # of length 'j + 1' yet found
    head = [0]
    # predecessor[j] = linked list of indices of best subsequence ending
    # at seq[j], in reverse order
    predecessor = [-1]
    for i in xrange(1, len(seq)):
        ## Find j such that:  seq[head[j - 1]] < seq[i] <= seq[head[j]]
        ## seq[head[j]] is increasing, so use binary search.
        j = bisect_left([seq[head[idx]] for idx in xrange(len(head))], seq[i])

        if j == len(head):
            head.append(i)
        if seq[i] < seq[head[j]]:
            head[j] = i

        predecessor.append(head[j - 1] if j > 0 else -1)

    ## trace subsequence back to output
    result = []
    trace_idx = head[-1]
    while (trace_idx >= 0):
        result.append(seq[trace_idx])
        trace_idx = predecessor[trace_idx]

    return result[::-1]


def id_or_nid(song_dict):
    """Equivalent to ``d.get('id') or d['nid']``.

    Uploaded songs have an id key, while AA tracks
    have a nid key, which can often be used interchangably.
    """

    return song_dict.get('id') or song_dict['nid']


def datetime_to_microseconds(dt):
    """Return microseconds since epoch, as an int.

    :param dt: a datetime.datetime

    """
    return int(time.mktime(dt.timetuple()) * 1000000) + dt.microsecond


def is_valid_mac(mac_string):
    """Return True if mac_string is of form
    eg '00:11:22:33:AA:BB'.
    """
    if not _mac_pattern.match(mac_string):
        return False

    return True


def create_mac_string(num, splitter=':'):
    """Return the mac address interpretation of num,
    in the form eg '00:11:22:33:AA:BB'.

    :param num: a 48-bit integer (eg from uuid.getnode)
    :param spliiter: a string to join the hex pairs with
    """

    mac = hex(num)[2:]

    # trim trailing L for long consts
    if mac[-1] == 'L':
        mac = mac[:-1]

    pad = max(12 - len(mac), 0)
    mac = '0' * pad + mac
    mac = splitter.join([mac[x:x + 2] for x in range(0, 12, 2)])
    mac = mac.upper()

    return mac


# from http://stackoverflow.com/a/5032238/1231454
def make_sure_path_exists(path, mode=None):
    try:
        if mode is not None:
            os.makedirs(path, mode)
        else:
            os.makedirs(path)

    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise


# from http://stackoverflow.com/a/8101118/1231454
class DocstringInheritMeta(type):
    """A variation on
    http://groups.google.com/group/comp.lang.python/msg/26f7b4fcb4d66c95
    by Paul McGuire
    """

    def __new__(meta, name, bases, clsdict):
        if not('__doc__' in clsdict and clsdict['__doc__']):
            for mro_cls in (mro_cls for base in bases for mro_cls in base.mro()):
                doc = mro_cls.__doc__
                if doc:
                    clsdict['__doc__'] = doc
                    break
        for attr, attribute in clsdict.items():
            if not attribute.__doc__:
                for mro_cls in (mro_cls for base in bases for mro_cls in base.mro()
                                if hasattr(mro_cls, attr)):
                    doc = getattr(getattr(mro_cls, attr), '__doc__')
                    if doc:
                        attribute.__doc__ = doc
                        break
        return type.__new__(meta, name, bases, clsdict)


def dual_decorator(func):
    """This is a decorator that converts a paramaterized decorator for no-param use.

    source: http://stackoverflow.com/questions/3888158.
    """
    @functools.wraps(func)
    def inner(*args, **kw):
        if ((len(args) == 1 and not kw and callable(args[0])
             and not (type(args[0]) == type and issubclass(args[0], BaseException)))):
            return func()(args[0])
        else:
            return func(*args, **kw)
    return inner


@dual_decorator
def enforce_id_param(position=1):
    """Verifies that the caller is passing a single song id, and not
    a song dictionary.

    :param position: (optional) the position of the expected id - defaults to 1.
    """

    @decorator
    def wrapper(function, *args, **kw):

        if not isinstance(args[position], basestring):
            raise ValueError("Invalid param type in position %s;"
                             " expected an id (did you pass a dictionary?)" % position)

        return function(*args, **kw)

    return wrapper


@dual_decorator
def enforce_ids_param(position=1):
    """Verifies that the caller is passing a list of song ids, and not a
    list of song dictionaries.

    :param position: (optional) the position of the expected list - defaults to 1.
    """

    @decorator
    def wrapper(function, *args, **kw):

        if ((not isinstance(args[position], (list, tuple)) or
             not all([isinstance(e, basestring) for e in args[position]]))):
            raise ValueError("Invalid param type in position %s;"
                             " expected ids (did you pass dictionaries?)" % position)

        return function(*args, **kw)

    return wrapper


def configure_debug_log_handlers(logger):
    """Warnings and above to stderr, below to gmusicapi.log when possible.
    Output includes line number."""

    global printed_log_start_message

    logger.setLevel(logging.DEBUG)

    logging_to_file = True
    try:
        make_sure_path_exists(os.path.dirname(log_filepath), 0o700)
        debug_handler = logging.FileHandler(log_filepath)
    except OSError:
        logging_to_file = False
        debug_handler = logging.StreamHandler()

    debug_handler.setLevel(logging.DEBUG)

    important_handler = logging.StreamHandler()
    important_handler.setLevel(logging.WARNING)

    logger.addHandler(debug_handler)
    logger.addHandler(important_handler)

    if not printed_log_start_message:
        #print out startup message without verbose formatting
        logger.info("!-- begin debug log --!")
        logger.info("version: " + __version__)
        if logging_to_file:
            logger.info("logging to: " + log_filepath)

        printed_log_start_message = True

    formatter = logging.Formatter(
        '%(asctime)s - %(name)s (%(module)s:%(lineno)s) [%(levelname)s]: %(message)s'
    )
    debug_handler.setFormatter(formatter)
    important_handler.setFormatter(formatter)


@dual_decorator
def retry(retry_exception=None, tries=5, delay=2, backoff=2, logger=None):
    """Retry calling the decorated function using an exponential backoff.

    An exception from a final attempt will propogate.

    :param retry_exception: exception (or tuple of exceptions) to check for and retry on.
      If None, use (AssertionError, CallFailure).
    :param tries: number of times to try (not retry) before giving up
    :param delay: initial delay between retries in seconds
    :param backoff: backoff multiplier
    :param logger: logger to use. If None, use 'gmusicapi.utils' logger

    Modified from
    http://www.saltycrane.com/blog/2009/11/trying-out-retry-decorator-python.
    """

    if logger is None:
        logger = logging.getLogger('gmusicapi.utils')

    if retry_exception is None:
        retry_exception = (AssertionError, CallFailure)

    @decorator
    def retry_wrapper(f, *args, **kwargs):
        mtries, mdelay = tries, delay  # make our own mutable copies
        while mtries > 1:
            try:
                return f(*args, **kwargs)
            except retry_exception as e:
                logger.info("%s, retrying in %s seconds...", e, mdelay)

                time.sleep(mdelay)
                mtries -= 1
                mdelay *= backoff
        return f(*args, **kwargs)

    return retry_wrapper


def pb_set(msg, field_name, val):
    """Return True and set val to field_name in msg if the assignment
    is type-compatible, else return False.

    val will be coerced to a proper type if needed.

    :param msg: an instance of a protobuf.message
    :param field_name:
    :param val
    """

    #Find the proper type.
    field_desc = msg.DESCRIPTOR.fields_by_name[field_name]
    proper_type = cpp_type_to_python[field_desc.cpp_type]

    #Try with the given type first.
    #Their set hooks will automatically coerce.
    try_types = (type(val), proper_type)

    for t in try_types:
        log.debug("attempt %s.%s = %s(%r)", msg.__class__.__name__, field_name, t, val)
        try:
            setattr(msg, field_name, t(val))
            log.debug("! success")
            break
        except (TypeError, ValueError):
            log.debug("X failure")
    else:
        return False  # no assignments stuck

    return True


def transcode_to_mp3(filepath, quality='320k', slice_start=None, slice_duration=None):
    """Return the bytestring result of transcoding the file at *filepath* to mp3.
    An ID3 header is not included in the result.

    :param filepath: location of file
    :param quality: if int, pass to -q:a. if string, pass to -b:a
                    -q:a roughly corresponds to libmp3lame -V0, -V1...
    :param slice_start: (optional) transcode a slice, starting at this many seconds
    :param slice_duration: (optional) when used with slice_start, the number of seconds in the slice

    Raise IOError on transcoding problems, or ValueError on param problems.
    """

    err_output = None
    cmd_path = spawn.find_executable('ffmpeg')
    if cmd_path is None:
        cmd_path = spawn.find_executable('avconv')
        if cmd_path is None:
            raise IOError('Neither ffmpeg nor avconv was found in your PATH')
    cmd = [cmd_path, '-i', filepath]

    if slice_duration is not None:
        cmd.extend(['-t', str(slice_duration)])
    if slice_start is not None:
        cmd.extend(['-ss', str(slice_start)])

    if isinstance(quality, int):
        cmd.extend(['-q:a', str(quality)])
    elif isinstance(quality, basestring):
        cmd.extend(['-b:a', quality])
    else:
        raise ValueError("quality must be int or string, but received %r" % quality)

    cmd.extend(['-f', 's16le',  # don't output id3 headers
                '-c', 'libmp3lame',
                'pipe:1'])

    log.debug('running transcode command %r', cmd)

    try:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)

        audio_out, err_output = proc.communicate()

        if proc.returncode != 0:
            err_output = ("(return code: %r)\n" % proc.returncode) + err_output
            raise IOError  # handle errors in except

    except (OSError, IOError) as e:

        err_msg = "transcoding command (%s) failed: %s. " % (' '.join(cmd), e)

        if 'No such file or directory' in str(e):
            err_msg += '\navconv must be installed and in the system path.'

        if err_output is not None:
            err_msg += "\nstderr: '%s'" % err_output

        log.exception('transcoding failure:\n%s', err_msg)

        raise IOError(err_msg)

    else:
        return audio_out


def truncate(x, max_els=100, recurse_levels=0):
    """Return a 'shorter' truncated x of the same type, useful for logging.
    recurse_levels is only valid for homogeneous lists/tuples.
    max_els ignored for song dictionaries."""

    #Coerce tuple to list to ease truncation.
    is_tuple = False
    if isinstance(x, tuple):
        is_tuple = True
        x = list(x)

    try:
        if len(x) > max_els:
            if isinstance(x, basestring):
                return x[:max_els] + '...'

            if isinstance(x, dict):
                if 'id' in x and 'titleNorm' in x:
                    #assume to be a song dict
                    trunc = dict((k, x.get(k)) for k in ['title', 'artist', 'album'])
                    trunc['...'] = '...'
                    return trunc
                else:
                    return dict(x.items()[:max_els] + [('...', '...')])

            if isinstance(x, list):
                trunc = x[:max_els] + ['...']
                if recurse_levels > 0:
                    trunc = [truncate(e, recurse_levels - 1) for e in trunc[:-1]]
                if is_tuple:
                    trunc = tuple(trunc)
                return trunc

    except TypeError:
        #does not have len
        pass

    return x


@dual_decorator
def empty_arg_shortcircuit(return_code='[]', position=1):
    """Decorate a function to shortcircuit and return something immediately if
    the length of a positional arg is 0.

    :param return_code: (optional) code to exec as the return value - default is a list.
    :param position: (optional) the position of the expected list - default is 1.
    """

    #The normal pattern when making a collection an optional arg is to use
    # a sentinel (like None). Otherwise, you run the risk of the collection
    # being mutated - there's only one, not a new one on each call.
    #Here we've got multiple things we'd like to
    # return, so we can't do that. Rather than make some kind of enum for
    # 'accepted return values' I'm just allowing freedom to return anything.
    #Less safe? Yes. More convenient? Definitely.

    @decorator
    def wrapper(function, *args, **kw):
        if len(args[position]) == 0:
            #avoid polluting our namespace
            ns = {}
            exec 'retval = ' + return_code in ns
            return ns['retval']
        else:
            return function(*args, **kw)

    return wrapper


def accept_singleton(expected_type, position=1):
    """Allows a function expecting a list to accept a single item as well.
    The item will be wrapped in a list.
    Will not work for nested lists.

    :param expected_type: the type of the items in the list
    :param position: (optional) the position of the expected list - defaults to 1.
    """

    @decorator
    def wrapper(function, *args, **kw):

        if isinstance(args[position], expected_type):
            #args are a tuple, can't assign into them
            args = list(args)
            args[position] = [args[position]]
            args = tuple(args)

        return function(*args, **kw)

    return wrapper


#Used to mark a field as unimplemented.
@property
def NotImplementedField(self):
    raise NotImplementedError

########NEW FILE########
__FILENAME__ = _version
__version__ = "3.1.1-dev"

########NEW FILE########
