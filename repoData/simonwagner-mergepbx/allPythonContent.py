__FILENAME__ = build
#! /usr/bin/env python

#This script builds a standalone version of mergepbx.py
#all scripts are bundled into one single file that can be easily distributed
#the user will only need the file generated by this script and he can execute 
#it like any other program
#idea: http://code.activestate.com/recipes/215301/

import zipfile
import tempfile
from ConfigParser import SafeConfigParser
from ConfigParser import NoOptionError
from collections import namedtuple
import os
import stat
import sys
import fnmatch

#templates
HEADER = \
"""\
#!/bin/sh
PYTHON=$(which python 2>/dev/null)
if [ ! -x "$PYTHON" ] ; then
    echo "Python executable not found - can't continue!"
    echo "Please install Python (>= 2.3) to run this program"
    exit 1
fi
exec $PYTHON - $0 $@ << END_OF_PYTHON_CODE

import sys
sys.path.insert(0, sys.argv[1])
del sys.argv[0:1]
import %(mainmodule)s
%(mainmodule)s.main()

END_OF_PYTHON_CODE
"""

class Manifest(object):
    ModuleFile = namedtuple("ModuleFile", ("file_path", "egg_path"))
    def __init__(self, mainmodule, files, default_target=None):
        self.mainmodule = mainmodule
        self.files = files
        self._default_target = default_target

    def iterfiles(self):
        return iter(self.files)

    def default_target(self):
        return self._default_target

    @staticmethod
    def read(fpath):
        config = SafeConfigParser()
        config.read(fpath)

        mainmodule = config.get("build", "mainmodule")
        mainmodule_path = config.get("build", "mainmodule_path")
        modules = config.get("build", "modules").split(",")
        try:
            default_target = config.get("build", "default_target")
        except NoOptionError:
            default_target = None

        print modules
        #add modules
        files = []
        for module in modules:
            path = config.get(module, "path")
            files += Manifest._get_module_files(module, path)

        #add main module
        files += [Manifest.ModuleFile(mainmodule_path, mainmodule + ".py")]

        return Manifest(mainmodule, files, default_target)

    @staticmethod
    def _get_module_files(module, path):
        module_files = []

        for (dir_path, dirs, files) in os.walk(path):
            python_files = fnmatch.filter(files, "*.py")
            python_files = [os.path.join(dir_path, file) for file in python_files]
            egg_python_files = [Manifest._get_egg_path(module, path, python_file) for python_file in python_files]

            module_files += [Manifest.ModuleFile(python_file, egg_python_file) for python_file, egg_python_file in zip(python_files, egg_python_files)]

        return module_files

    @staticmethod
    def _get_egg_path(module, module_path, file_path):
        rel_file_path = os.path.relpath(file_path, module_path)
        rel_file_path = os.path.normpath(rel_file_path)
        egg_path_components =  [module] + rel_file_path.split(os.sep)
        egg_path = str.join("/", egg_path_components)

        return egg_path

def main():
    #default settings
    target_file = None
    manifest_file = "MANIFEST"

    if len(sys.argv) >= 2:
        target_file = sys.argv[1]
    if len(sys.argv) >= 3:
        manifest_file = sys.argv[2]

    manifest = Manifest.read(manifest_file)
    if not target_file:
        target_file = manifest.default_target()
        if not target_file:
            sys.stderr.write("please specify a target by using: ./build.py target\n")
            sys.exit(os.EX_USAGE)

    build(target_file, manifest)

def build(target_file, manifest):
    pack_egg(target_file, manifest)

def pack_egg(target_file, manifest):
    zip_fd, zip_path = tempfile.mkstemp()

    egg = zipfile.ZipFile(zip_path, "w")

    for file_path, egg_path in manifest.iterfiles():
        print "adding %s as %s" % (file_path, egg_path)
        egg.write(file_path, egg_path)

    egg.close()

    target = open(target_file, "w")
    eggf = open(zip_path, "r")

    target.write(HEADER % {
        "mainmodule" : manifest.mainmodule
    })
    target.write(eggf.read())

    target.close()
    eggf.close()

    egg_permissions = os.stat(target_file).st_mode
    os.chmod(target_file, egg_permissions | (stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = mergepbx
#!/usr/bin/env python

import sys
import os
from argparse import ArgumentParser

from plist.nextstep import NSPlistReader
import pbxproj
from pbxproj.merge import merge_pbxs
from pbxproj.merge.pbxmerge import MergeException

def get_argument_parser():
    parser = ArgumentParser()

    parser.add_argument("base",
                        help="base version - the last common version of mine and theirs")
    parser.add_argument("mine",
                        help="my version")
    parser.add_argument("theirs",
                        help="their version")
    parser.add_argument("-o", "--output",
                        help="output path for the merged file",
                        default=None)
    parser.add_argument("-d", "--debug",
                        help="enable debugger on exceptions",
                        action="store_true")

    return parser

def install_pdb_exception_handler():
    def info(type, value, tb):
       if hasattr(sys, 'ps1') or not sys.stderr.isatty():
          # we are in interactive mode or we don't have a tty-like
          # device, so we call the default hook
          sys.__excepthook__(type, value, tb)
       else:
          import traceback, pdb
          # we are NOT in interactive mode, print the exception...
          traceback.print_exception(type, value, tb)
          print
          # ...then start the debugger in post-mortem mode.
          pdb.pm()

    sys.excepthook = info

def main():
    log = sys.stderr
    parser = get_argument_parser()
    args = parser.parse_args()

    if args.output:
        output = args.output
    else:
        output = args.mine

    if args.debug:
        #if debugging is enabled, install the pdb
        #handler and let him handle the exception
        install_pdb_exception_handler()
        merge_pbx_files(args.base, args.mine, args.theirs, output)
    else:
        #if debugging is not enabled, simply report the exception
        try:
            merge_pbx_files(args.base, args.mine, args.theirs, output)
            sys.exit(0)
        except Exception as e:
            log.write("merging failed: %s\n" % str(e))
            sys.exit(1)

def merge_pbx_files(basef, minef, theirsf, mergedf):
    base, mine, theirs = read_pbxs((basef, minef, theirsf))

    merged_project = merge_pbxs(base, mine, theirs)

    pbxproj.write(mergedf, merged_project)

def read_pbxs(pbx_files):
    projects = [pbxproj.read(pbx_file) for pbx_file in pbx_files]

    return projects

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = orderedset
import collections
import weakref

class OrderedSetEntry(object):
    def __init__(self, *args, **kwargs):
        self.prev = kwargs.get("prev", None)
        self.key = kwargs.get("key", None)
        self._set_next(kwargs.get("next", None))

    @property
    def prev(self):
        if self._ref_prev is None:
            return None
        else:
            value = self._ref_prev()
            return value

    @prev.setter
    def prev(self, value):
        if value is None:
            self._ref_prev = None
        else:
            self._ref_prev = weakref.ref(value)

    @property
    def next(self):
        if self._ref_next is None:
            return None
        else:
            value = self._ref_next()
            return value

    def _set_next(self, value):
        if value is None:
            self._ref_next = None
        else:
            self._ref_next = weakref.ref(value)

    @next.setter
    def next(self, value):
        self._set_next(value)

class OrderedSet(collections.MutableSet):

    def __init__(self, iterable=None):
        self.clear()

        if iterable is not None:
            self |= iterable

    def __len__(self):
        return len(self.map)

    def __contains__(self, key):
        return key in self.map

    def add(self, key):
        if key not in self.map:
            cur = OrderedSetEntry(prev=self.end.prev, key=key, next=self.end)
            self.map[key] = cur

            self.end.prev.next = cur
            self.end.prev = cur

    def clear(self):
        self.end = OrderedSetEntry()
        self.start = OrderedSetEntry()

        self.start.key = None
        self.end.key = None

        self.start.next = self.end
        self.end.prev = self.start

        self.map = {}

    def discard(self, key):
        if key in self.map:        
            entry = self.map.pop(key)
            prev = entry.prev
            next = entry.next

            prev.next = entry.next
            next.prev = entry.prev

    def __iter__(self):
        end = self.end
        cur = self.start.next
        while not cur is end:
            yield cur.key
            cur = cur.next

    def __reversed__(self):
        start = self.start
        cur = self.end.prev
        while not cur is start:
            yield cur.key
            cur = cur.prev

    def pop(self, last=True):
        if not self:
            raise KeyError('set is empty')
        key = next(reversed(self)) if last else next(iter(self))
        self.discard(key)
        return key

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, list(self))

    def __eq__(self, other):
        if isinstance(other, OrderedSet):
            return len(self) == len(other) and list(self) == list(other)
        return set(self) == set(other)

########NEW FILE########
__FILENAME__ = core
class DictionaryBoundObject(object):
    def __init__(self, dict, restricted_to_keys=None):
        self._dict = dict
        assert self._dict != None
        self._restricted_to_keys = set(restricted_to_keys) if restricted_to_keys != None else None

    def __getattr__(self, attr):
        if not attr.startswith("_") and self._can_access(attr):
            return self._dict[attr]
        else:
            raise AttributeError(attr)

    def __setattr__(self, attr, value):
        if not attr.startswith("_") and attr in self._dict and self._can_access(attr):
            self._dict[attr] = value
        else:
            return super(DictionaryBoundObject, self).__setattr__(attr, value)

    def _get_dict(self):
        return self._dict

    def iterkeys():
        return self._dict.iterkeys()

    def _can_access(self, attr):
        return self._restricted_to_keys == None or attr in self._restricted_to_keys

########NEW FILE########
__FILENAME__ = isa
from .core import DictionaryBoundObject
from inspect import isclass

class PBXISA(object):
    def __init__(self, identifier, *args, **kwargs):
        self._identifier = identifier
        super(PBXISA, self).__init__(identifier, *args, **kwargs)

    def get_name(self, project):
        return None

    def get_identifier(self):
        return self._identifier

class PBXISADictionaryBound(DictionaryBoundObject):
    def __init__(self, identifier, isa_dict, *args, **kwargs):
        super(PBXISADictionaryBound, self).__init__(isa_dict, *args, **kwargs)

class PBXBuildFile(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXBuildFile, self).__init__(*args, **kwargs)

    def get_name(self, project):
        fileRef = self.fileRef
        file = project.get_objects().get(fileRef)
        name = file.get_name(project)
        container = project.phase_of_object(self._identifier)

        return "%s in %s" % (name, container)

class PBXContainerItemProxy(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXContainerItemProxy, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "PBXContainerItemProxy"

class PBXCopyFilesBuildPhase(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXCopyFilesBuildPhase, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "CopyFiles"

class PBXFileReference(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXFileReference, self).__init__(*args, **kwargs)

    def get_name(self, project):
        if hasattr(self, "name"):
            return self.name
        else:
            return self.path.split("/")[-1]

class PBXFrameworksBuildPhase(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXFrameworksBuildPhase, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "Frameworks"

class PBXGroup(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXGroup, self).__init__(*args, **kwargs)

    def get_name(self, project):
        if hasattr(self, "name"):
            return self.name
        elif hasattr(self, "path"):
            return self.path
        else:
            return None

class PBXLegacyTarget(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXLegacyTarget, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return self.name

class PBXNativeTarget(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXNativeTarget, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return self.name

class PBXProject(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXProject, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "Project object"

    def get_project_name(self, project):
        targets = self.targets
        objects = project.get_objects()
        target_names = [objects.get(target).name for target in targets]

        return target_names[0]

class PBXReferenceProxy(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXReferenceProxy, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return self.path

class PBXResourcesBuildPhase(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXResourcesBuildPhase, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "Resources"

class PBXShellScriptBuildPhase(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXShellScriptBuildPhase, self).__init__(*args, **kwargs)

    def get_name(self, project):
        if hasattr(self, "name"):
            return self.name
        else:
            return "ShellScript"

class PBXSourcesBuildPhase(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXSourcesBuildPhase, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "Sources"

class PBXTargetDependency(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXTargetDependency, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return "PBXTargetDependency"

class PBXVariantGroup(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(PBXVariantGroup, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return self.name

class XCBuildConfiguration(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(XCBuildConfiguration, self).__init__(*args, **kwargs)

    def get_name(self, project):
        return self.name

class XCConfigurationList(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(XCConfigurationList, self).__init__(*args, **kwargs)

    def get_name(self, project):
        targets = self.get_targets(project)
        target = targets[0]

        if isinstance(target, PBXProject):
            project_name = target.get_project_name(project)
            #whitespaces apparently get removed by XCode
            #so we need to remove them too.
            target_name = str.join("", project_name.split())
        else:
            target_name = target.get_name(project)

        return "Build configuration list for %s \"%s\"" % (target.isa, target_name)

    def get_targets(self, project):
        targets = []
        identifier = self.get_identifier()

        for object_identifier, object in project.get_objects().iterobjects():
            if hasattr(object, "buildConfigurationList"):
                if object.buildConfigurationList == identifier:
                    targets.append(object)
        return targets

class XCVersionGroup(PBXISA, PBXISADictionaryBound):
    def __init__(self, *args, **kwargs):
        super(XCVersionGroup, self).__init__(*args, **kwargs)

    def get_name(self, project):
        if hasattr(self, "name"):
            return self.name
        else:
            return self.path

local_vars = dict(locals())
ISA_MAPPING = dict(
    ((clazz.__name__, clazz) for varname, clazz in local_vars.iteritems() if isclass(clazz) and issubclass(clazz, PBXISA))
)

def is_known(isa):
    return isa in ISA_MAPPING

def create(identifier, isa_dict):
    isa = isa_dict["isa"]
    isa_class = ISA_MAPPING[isa]

    return isa_class(identifier, isa_dict)

########NEW FILE########
__FILENAME__ = coremerge
from collections import namedtuple, OrderedDict
from itertools import chain, izip
from orderedset import OrderedSet

KeysDictDiff = namedtuple("KeysDictDiff", ("added", "deleted", "common"))
KeysDictDiff3 = namedtuple("KeysDictDiff", ("mine_added", "theirs_added", "deleted", "common", "conflicting_deleted"))
DictDiff = namedtuple("DictDiff", ("added", "deleted", "updated", "common"))
DictDiff3 = namedtuple("DictDiff3", ("mine_added", "theirs_added", "deleted", "mine_updated", "theirs_updated", "conflicting", "common"))
SetDiff3 = namedtuple("SetDiff3", ("added", "deleted", "common"))

def diff_dict_keys(base, mine):
    base_keys = set(base.iterkeys())
    mine_keys = set(mine.iterkeys())

    added = mine_keys - base_keys
    deleted = base_keys - mine_keys
    common = base_keys & mine_keys

    return KeysDictDiff(added, deleted, common)

def diff3_dict_keys(base, mine, theirs):
    base_keys = set(base.iterkeys())
    mine_keys = set(mine.iterkeys())
    theirs_keys = set(theirs.iterkeys())

    diff_base_with_mine = diff_dict_keys(base, mine)
    diff_base_with_theirs = diff_dict_keys(base, theirs)

    #only the ones which are added exclusivly by mine or theirs
    #can be merged without possible conflicts
    mine_added = diff_base_with_mine.added - diff_base_with_theirs.added
    theirs_added = diff_base_with_theirs.added - diff_base_with_mine.added
    #those which are added by both might contain conflicts in their values
    #those keys will be saved in common later on

    #only the ones which are deleted in both can be savely deleted
    deleted = diff_base_with_mine.deleted & diff_base_with_theirs.deleted
    #keys that are still present in mine or theirs might have been edited
    #and therefore conflict
    conflicting_deleted = (mine_keys & diff_base_with_theirs.deleted) | (theirs_keys & diff_base_with_theirs.deleted)

    #common keys between mine and theirs (includes keys added by both)
    common = (mine_keys & theirs_keys)

    return KeysDictDiff3(mine_added, theirs_added, deleted, common, conflicting_deleted)

def diff_dict(base, mine, test_updated = lambda a,b: a != b):
    keys_diff = diff_dict_keys(base, mine)
    updated_keys = set()
    for key in keys_diff.common:
        if test_updated(base[key], mine[key]):
            updated_keys.add(key)
    common = keys_diff.common - updated_keys
    return DictDiff(added=keys_diff.added, deleted=keys_diff.deleted, updated=updated_keys, common=common)

def diff3_dict(base, mine, theirs, test_updated = lambda a,b: a != b):
    diff_base_with_mine = diff_dict(base, mine, test_updated)
    diff_base_with_theirs = diff_dict(base, theirs, test_updated)
    diff_mine_with_theirs = diff_dict(mine, theirs, test_updated)

    conflicting_update = (diff_base_with_mine.updated & diff_base_with_theirs.updated) - diff_mine_with_theirs.common
    conflicting_added = (diff_base_with_mine.added | diff_base_with_theirs.added) & diff_mine_with_theirs.updated
    conflicting_deleted = (diff_base_with_mine.deleted & diff_base_with_theirs.updated) | (diff_base_with_theirs.deleted & diff_base_with_mine.updated)

    conflicting = conflicting_update | conflicting_added | conflicting_deleted

    mine_added = diff_base_with_mine.added - conflicting
    theirs_added = diff_base_with_theirs.added - conflicting
    deleted = (diff_base_with_theirs.deleted | diff_base_with_mine.deleted) - conflicting
    mine_updated = diff_base_with_mine.updated - conflicting
    theirs_updated = diff_base_with_theirs.updated - conflicting

    common = diff_base_with_mine.common & diff_base_with_theirs.common

    return DictDiff3(mine_added=mine_added, theirs_added=theirs_added, deleted=deleted, mine_updated=mine_updated, theirs_updated=theirs_updated, conflicting=conflicting, common=common)

def diff3_set(base, mine, theirs):
    added = (mine - base) | (theirs - base)
    deleted = set(e for e in base if not e in mine or not e in theirs)
    common = base & mine & theirs

    return SetDiff3(added=added, deleted=deleted, common=common)

def merge_dict(diff, base, mine, theirs):
    assert(len(diff.conflicting) == 0)

    result = {}

    for key in chain(diff.mine_added, diff.mine_updated):
        result[key] = mine[key]
    for key in chain(diff.theirs_added, diff.theirs_updated):
        result[key] = theirs[key]
    for key in diff.common:
        result[key] = mine[key]

    return result

def merge_key_order(result, base, mine, theirs):
    base_keys, mine_keys, theirs_keys = (OrderedSet(k) for k in (base.iterkeys(), mine.iterkeys(), theirs.iterkeys()))

    keys_diff = diff3_set(base_keys, mine_keys, theirs_keys)
    keys_merged = merge_ordered_set(keys_diff, base_keys, mine_keys, theirs_keys)

    result = OrderedDict((key, result[key]) for key in keys_merged)

    return result 

def merge_ordered_dict(diff, base, mine, theirs):
    unordered = merge_dict(diff, base, mine, theirs)
    result = merge_key_order(unordered, base, mine, theirs)

    return result

# merge an ordered so that with the following holds true
# MINE:   m1 - M
#            /   \
# THEIRS: t1 ----> t2
# the result of the merged version of m1 and t1 (which is called M)
# should be the same when merging t1 and M (that means t1 + diff(t1, M) = M)
def merge_ordered_set(diff, base, mine, theirs):
    mine_merged = mine - diff.deleted
    theirs_merged = theirs - diff.deleted
    mine_added = mine_merged - theirs_merged
    merged = OrderedSet()

    theirs_merged_iter = iter(theirs_merged)
    mine_merged_iter = iter(mine_merged)

    for theirs_el in theirs_merged_iter:
        for mine_el in mine_merged_iter:
            if mine_el in mine_added:
                merged.add(mine_el)
            else:
                break
        merged.add(theirs_el)

    for mine_el in mine_merged_iter:
        merged.add(mine_el)

    return merged

def merge_set(diff, base, mine, theirs):
    return diff.common | diff.added

########NEW FILE########
__FILENAME__ = pbxmerge
from collections import namedtuple, OrderedDict
from orderedset import OrderedSet
from inspect import isclass
import logging

from .coremerge import *
from ..pbxobjects import PBXProjFile

class MergeConflict(object):
    def __init__(self, *args, **kwargs):
        if not "msg" in kwargs:
            raise Exception("msg keyword argument is required for %s" % self.__class__.__name__)
        self.msg = kwargs["msg"]

    def __repr__(self):
        return "<%s: '%s'>" % (self.__class__.__name__, self.msg)

class MergeConflictException(Exception):
    pass

class MergeException(Exception):
    pass

class MergeStrategyManager(object):
    def __init__(self, strategies = {}, *args, **kwargs):
        strategies = dict(strategies)
        strategies.update(kwargs)
        self.strategies = {}

        for key, strategie_class in strategies.iteritems():
            self.strategies[key] = strategie_class(self)

    def get_merger(self, strategy):
        if not strategy in self.strategies:
            raise Exception("strategy not found: %s" % strategy)
        else:
            return self.strategies[strategy]

    def get_project_file_merger(self):
        return self.get_merger("PBXProjectFileMerger3")

class Merger(object):
    def __init__(self, manager):
        self.manager = manager

class _SimpleDictMerger3(Merger):
    IGNORE_CONFLICTS_IN_KEYS = set()

    def __init__(self, manager):
        super(_SimpleDictMerger3, self).__init__(manager)
        self.logger = logging.getLogger()
        self.merging_functions = {}
        for attr_name in dir(self):
            attr = getattr(self, attr_name)
            if callable(attr) and attr_name.startswith("merge_"):
                key = attr_name.replace("merge_", "", 1)
                self.merging_functions[key] = attr

    def merge(self, base, mine, theirs):
        #make a diff for merging
        diff3 = diff3_dict(base, mine, theirs)

        #remove conflicts in ignored keys
        #where we have a special merging function
        for key in self.merging_functions:
            if key in diff3.conflicting:
                diff3.conflicting.remove(key)

        #test if we still have conflicts after removing all keys
        #that have an auto_merge function
        if len(diff3.conflicting) > 0:
            result = self.handle_conflicts(base, mine, theirs, diff3)
        else:
            result = merge_dict(diff3, base, mine, theirs)

        assert(result != None)
        #resolve conflicts with the declared auto merge functions
        result = self.auto_merge(base, mine, theirs, result, diff3)

        assert(result != None)

        #in the end, sort result
        result = merge_key_order(result, base, mine, theirs)

        return result

    def auto_merge(self, base, mine, theirs, result, diff3):
        for name, function in self.merging_functions.iteritems():
            result = function(base, mine, theirs, result, diff3)
        return result

    def handle_conflicts(self, base, mine, theirs, diff3):
        raise MergeConflictException("conflict while merging with %s merger" % self.__class__.__name__)

def create_auto_merge_set(attribute, optional = False):
    def auto_merge_set(self, base, mine, theirs, result, diff3):
        if optional and (False, False, False) == (attribute in base, attribute in mine, attribute in theirs):
            return result

        values = _get_3(attribute, base, mine, theirs, optional = optional, replace_value = ())

        values = Value3(*(OrderedSet(v) for v in values)) #convert to OrderedSet

        values_diff = diff3_set(OrderedSet(values.base), OrderedSet(values.mine), OrderedSet(values.theirs))
        result[attribute] = tuple(merge_ordered_set(values_diff, values.base, values.mine, values.theirs))

        return result

    return auto_merge_set

def create_auto_merge_dict(attribute, optional = False):
    def auto_merge_dict(self, base, mine, theirs, result, diff3):
        if optional and (False, False, False) == (attribute in base, attribute in mine, attribute in theirs):
            return result

        values = _get_3(attribute, base, mine, theirs, optional = optional, replace_value = {})

        values_diff = diff3_dict(values.base, values.mine, values.theirs)

        if len(values_diff.conflicting) > 0:
            raise MergeException("can't merge %s, conflicting values in dictionary: %r" % (attribute, values_diff.conflicting))
        result[attribute] = merge_ordered_dict(values_diff, values.base, values.mine, values.theirs)

        return result

    return auto_merge_dict

class PBXProjectFileMerger3(Merger):
    SUPPORTED_ARCHIVE_VERSIONS = set((1,))
    SUPPORTED_OBJECT_VERSIONS = set((46,))

    def merge(self, base, mine, theirs):
        result = OrderedDict()

        #check if the encoding for all project is
        #the same, otherwise abort
        if base.get_encoding() != theirs.get_encoding() or base.get_encoding() != mine.get_encoding():
            raise ValueError("merging projects with different encoding is not supported.")
        encoding = mine.get_encoding()
        #use plist for merging
        base, mine, theirs = (base._plist, mine._plist, theirs._plist)

        self.merge_archiveVersion(result, base, mine, theirs)
        self.merge_classes(result, base, mine, theirs)
        self.merge_objectVersion(result, base, mine, theirs)
        self.merge_objects(result, base, mine, theirs)
        self.merge_rootObject(result, base, mine, theirs)

        return PBXProjFile(result, encoding=encoding)

    def merge_archiveVersion(self, result, base, mine, theirs):
        archiveVersion = _get_3("archiveVersion", base, mine, theirs)
        if not archiveVersion.base == archiveVersion.mine or not archiveVersion.base == archiveVersion.theirs:
            raise MergeException("can not merge projects with different archiveVersion")
        if not int(archiveVersion.base) in self.SUPPORTED_ARCHIVE_VERSIONS:
            raise MergeException("can not merge projects with archiveVersion %s" % archiveVersion.base)

        result["archiveVersion"] = archiveVersion.base

    def merge_classes(self, result, base, mine, theirs):
        classes = _get_3("classes", base, mine, theirs)

        if tuple(len(d) for d in classes) == (0,0,0):
            result["classes"] = {}
        else:
            raise MergeException("merging classes in pbxproj not supported")

    def merge_objectVersion(self, result, base, mine, theirs):
        objectVersion = _get_3("objectVersion", base, mine, theirs)
        if not objectVersion.base == objectVersion.mine or not objectVersion.base == objectVersion.theirs:
            raise MergeException("can not merge projects with different objectVersion")
        if not int(objectVersion.base) in self.SUPPORTED_OBJECT_VERSIONS:
            raise MergeException("can not merge projects with objectVersion %s" % objectVersion.base)

        result["objectVersion"] = objectVersion.base

    def merge_objects(self, result, base, mine, theirs):
        base_objs, mine_objs, theirs_objs = _get_3("objects", base, mine, theirs)

        diff_obj_keys = diff3_dict_keys(base_objs, mine_objs, theirs_objs)

        merged_objects = {}
        #add objects that are new
        for added_object_key in diff_obj_keys.mine_added:
            merged_objects[added_object_key] = mine_objs[added_object_key]
        for added_object_key in diff_obj_keys.theirs_added:
            merged_objects[added_object_key] = theirs_objs[added_object_key]
        #for deleted objects, simply do not add them

        #for common objects we will have to merge
        for common_object_key in diff_obj_keys.common:
            mine_obj_isa = mine_objs[common_object_key]["isa"]

            base_obj, mine_obj, theirs_obj = _get_3(common_object_key, base_objs, mine_objs, theirs_objs, optional = True, replace_value = {"isa" : mine_obj_isa})
            base_isa, mine_isa, theirs_isa = _get_3("isa", base_obj, mine_obj, theirs_obj)

            if not base_isa == mine_isa or not base_isa == theirs_isa:
                raise MergeException("can't merge objects whose ISA has changed. %s %s, %s, %s" %(common_object_key, base_isa, mine_isa, theirs_isa))

            merger_name = base_isa + "Merger3"

            merger = self.manager.get_merger(merger_name)

            merged_obj = merger.merge(base_obj, mine_obj, theirs_obj)
            merged_objects[common_object_key] = merged_obj

        result["objects"] = merge_key_order(merged_objects, base_objs, mine_objs, theirs_objs)

    def merge_rootObject(self, result, base, mine, theirs):
        if mine["rootObject"] != theirs["rootObject"]:
            raise MergeConflictException("conflict in rootObject, can't handle that")
        else:
            result["rootObject"] = mine["rootObject"]

class _AbstractPBXBuildObjectMerger3(_SimpleDictMerger3):
    merge_files = create_auto_merge_set("files", optional = True)

class PBXBuildFileMerger3(_AbstractPBXBuildObjectMerger3):
    pass

class PBXCopyFilesBuildPhaseMerger3(_AbstractPBXBuildObjectMerger3):
    pass

class PBXFileReferenceMerger3(_SimpleDictMerger3):

    def merge_lastKnownFileType(self, base, mine, theirs, result, diff3):
        #special handling for lastKnownFileType
        base_lastKnownFileType, mine_lastKnownFileType, theirs_lastKnownFileType = _get_3("lastKnownFileType", base, mine, theirs, optional = True, replace_value = "")

        #if lastKnownFileType is nowhere present, do nothing
        if (base_lastKnownFileType, mine_lastKnownFileType, theirs_lastKnownFileType) == ("", "", ""):
            return result

        if not base_lastKnownFileType == mine_lastKnownFileType or not base_lastKnownFileType == theirs_lastKnownFileType:
            #if last known file type is different, well, then we delete it simply and let xcode figure out what it should do
            #if however base is empty, then we set it to a known file type
            if base_lastKnownFileType == "":
                if mine_lastKnownFileType == theirs_lastKnownFileType:
                    lastKnownFileType = mine_lastKnownFileType
                else:
                    lastKnownFileType = ""
            else:
                lastKnownFileType = ""
        else:
            lastKnownFileType = base_lastKnownFileType

        result["lastKnownFileType"] = lastKnownFileType

        return result

class PBXFrameworksBuildPhaseMerger3(_AbstractPBXBuildObjectMerger3):
    pass

class PBXGroupMerger3(_SimpleDictMerger3):
    merge_children = create_auto_merge_set("children")
    def merge_sourceTree(self, base, mine, theirs, result, diff3):
        base_sourceTree, mine_sourceTree, theirs_sourceTree = _get_3("sourceTree", base, mine, theirs)

        if not base_sourceTree == mine_sourceTree or not base_sourceTree == theirs_sourceTree:
            raise MergeException("can't merge PBXGroup whose sourceTree has changed")

        return result

class _AbstractTargetMerger3(_SimpleDictMerger3):
    merge_buildPhases = create_auto_merge_set("buildPhases", optional = True)
    merge_dependencies = create_auto_merge_set("dependencies", optional = True)
    merge_files = create_auto_merge_set("files", optional = True)

class PBXFrameworksBuildPhaseMerger3(_AbstractTargetMerger3):
    pass

class PBXResourcesBuildPhaseMerger3(_AbstractTargetMerger3):
    pass

class PBXLegacyTargetMerger3(_AbstractTargetMerger3):
    pass

class PBXNativeTargetMerger3(_AbstractTargetMerger3):
    pass

class PBXShellScriptBuildPhaseMerger3(_AbstractTargetMerger3):
    merge_buildPhases = create_auto_merge_set("inputPaths", optional = True)
    merge_dependencies = create_auto_merge_set("outputPaths", optional = True)
    merge_files = create_auto_merge_set("files", optional = True)

class PBXReferenceProxyMerger3(_SimpleDictMerger3):
    pass

class PBXContainerItemProxyMerger3(_SimpleDictMerger3):
    pass

class PBXTargetDependencyMerger3(_SimpleDictMerger3):
    pass

class PBXProjectMerger3(_SimpleDictMerger3):
    merge_knownRegions = create_auto_merge_set("knownRegions", optional = True)
    merge_targets = create_auto_merge_set("targets")
    merge_attributes = create_auto_merge_dict("attributes", optional = True)

class PBXSourcesBuildPhaseMerger3(_SimpleDictMerger3):
    merge_files = create_auto_merge_set("files")

class XCBuildConfigurationMerger3(_SimpleDictMerger3):
    def merge_buildSettings(self, base, mine, theirs, result, diff3):
        attribute = "buildSettings"
        values = _get_3(attribute, base, mine, theirs)

        values_diff = diff3_dict(values.base, values.mine, values.theirs)

        resolved_conflicts = {}
        for conflict in values_diff.conflicting:
            #check if conflict happens with a tuple or another list-like type
            for value in values:
                if not conflict in value:
                    continue
                dict_value = value[conflict]
                if not isinstance(dict_value, (tuple, list, set, OrderedSet)):
                    raise MergeException("can't merge %s, conflicting values in dictionary: %r" % (attribute, values_diff.conflicting))
            #ok, we now can merge it with merge_ordered_set as we are sure that it is a tuple or something like that
            #and we assume that items are unique
            dict_values = Value3(values.base[conflict], values.mine[conflict], values.theirs[conflict])

            dict_values_diff = diff3_set(OrderedSet(dict_values.base), OrderedSet(dict_values.mines), OrderedSet(dict_values.theirs))
            resolved_conflicts[conflict] = tuple(merge_ordered_set(dict_values_diff, dict_values.base, dict_values.mines, dict_values.theirs))

            values_diff.conflicting.remove(conflict) #mark as merged

        result[attribute] = merge_ordered_dict(values_diff, values.base, values.mine, values.theirs)
        for conflict, resolution in resolved_conflicts.iteritems():
            result[attribute] = resolution

        return result

class XCConfigurationListMerger3(_SimpleDictMerger3):
    merge_buildConfigurations = create_auto_merge_set("buildConfigurations")

class PBXVariantGroupMerger3(_SimpleDictMerger3):
    merge_children = create_auto_merge_set("children")

class XCVersionGroupMerger3(_SimpleDictMerger3):
    merge_files = create_auto_merge_set("children")

Value3 = namedtuple("Value3", ("base", "mine", "theirs"))

def _get_3(key, base, mine, theirs, optional = False, replace_value = None):
    if not optional:
        get = lambda d, key: d[key]
    else:
        get = lambda d, key, replace_value=replace_value: d.get(key, replace_value)

    base_value = get(base, key)
    mine_value = get(mine, key)
    theirs_value = get(theirs, key)

    return Value3(base_value, mine_value, theirs_value)

def _find_merger(vars):
    classes = ((clazz.__name__, clazz) for varname, clazz in vars.iteritems() if isclass(clazz))
    merger_classes = ((name, clazz) for name, clazz in classes if issubclass(clazz, Merger) and name != "Merger")
    public_classes = ((name, clazz) for name, clazz in merger_classes if not name.startswith("_"))

    return dict(public_classes)

MERGER_MAPPING = _find_merger(dict(locals()))

DEFAULT_MERGE_STRATEGY_MANAGER = MergeStrategyManager(MERGER_MAPPING)

def get_project_file_merger():
    return DEFAULT_MERGE_STRATEGY_MANAGER.get_project_file_merger()

########NEW FILE########
__FILENAME__ = pbxobjects
from itertools import chain

from .core import DictionaryBoundObject
from . import isa

class PBXProjFile(DictionaryBoundObject):
    MAPPED_ATTRIBUTES = ("archiveVersion", "objectVersion", "rootObject")
    def __init__(self, plist, ignore_unknown_objects=False, encoding=None):
        super(self.__class__, self).__init__(plist, self.__class__.MAPPED_ATTRIBUTES)
        self._plist = plist
        self._classes = PBXClasses(self._plist["classes"])
        self._objects = PBXObjects(self._plist["objects"], ignore_unknown_objects)
        self._load_phases()
        self._encoding = encoding

    def _load_phases(self):
        self._phases = dict()
        phases = (
            ("Frameworks", "PBXFrameworksBuildPhase"),
            ("Sources", "PBXSourcesBuildPhase"),
            ("Resources", "PBXResourcesBuildPhase")
        )

        for (section, phase_isa) in phases:
            phase_objects_with_identifier = self._objects.getobjects(phase_isa)
            phase_objects = (t[1] for t in phase_objects_with_identifier)
            self._phases[section] = set(
                chain.from_iterable(phase_object.files for phase_object in phase_objects)
            )

    def get_objects(self):
        return self._objects

    def phase_of_object(self, identifier):
        for phase, files in self._phases.iteritems():
            if identifier in files:
                return phase

    def get_encoding(self):
        return self._encoding

class PBXClasses(object):
    def __init__(self, data_dict):
        self.data_dict = data_dict

class PBXObjects(object):
    def __init__(self, data_dict, ignore_unknown_objects):
        self.data_dict = data_dict
        self.ignore_unknown_objects = ignore_unknown_objects

    def keys(self):
        return self.data_dict.keys()

    def get(self, key):
        return self._make_isa_object(key, self.data_dict[key])

    def iterobjects(self, isa=None):
        if self.ignore_unknown_objects:
            items_iter = ((key, value) for key,value in self.data_dict.iteritems() if isa.is_known(value["isa"]))
        else:
            items_iter = self.data_dict.iteritems()

        return (
            (key, self._make_isa_object(key, value)) for key, value in items_iter \
            if isa == None or value["isa"] == isa
        )

    def getobjects(self, isa=None):
        return tuple(self.iterobjects(isa))

    def getobject(self, isa):
        found_objects = self.getobjects(isa)

        if len(found_objects) >= 1:
            return self.getobjects(isa)[0][1]
        else:
            return None

    def _make_isa_object(self, identifier, isa_dict):
        return isa.create(identifier, isa_dict)

########NEW FILE########
__FILENAME__ = reader
from plist import NSPlistReader
from .pbxobjects import PBXProjFile

def read_pbx(pbx_file, ignore_unknown_objects=False):
    f = open(pbx_file)
    r = NSPlistReader(f)
    plist = r.read()
    project = PBXProjFile(plist, ignore_unknown_objects=False)
    r.close()

    return project

########NEW FILE########
__FILENAME__ = writer
import re

from plist import NSPlistWriter

class PBXProjectPlistWriter(NSPlistWriter):
    OBJECTID_RE = re.compile(r"^[0-9A-F]{24}")
    COMMENT_BLACKLIST = frozenset((
        "remoteGlobalIDString",
        "TargetAttributes",
    ))

    def __init__(self, f):
        super(PBXProjectPlistWriter, self).__init__(f)
        self.multiline = True
        self.auto_comment = True

    def write_project(self, pbxproj):
        self.pbxproj = pbxproj
        self.write_header()
        self.write_project_dict(pbxproj)
        self.write("\n")

    def write_project_dict(self, pbxproj):
        plist = pbxproj._plist

        self.write("{")
        self.indent()

        for key, value in pbxproj._plist.iteritems():
            self.write("\n")
            if key == "objects":
                self.write_object_dict(pbxproj, value)
            elif key == "rootObject":
                self.write("rootObject = %s /* Project object */;" % pbxproj.rootObject)
            else:
                self.write_dict_item(key, value)

        self.deindent()
        self.write(u"\n}")

    def write_object_dict(self, pbxproj, object_dict):
        self.write("objects = {")
        self.indent()

        current_isa = None

        def compare_object_items(item1, item2):
            key1, value1 = item1
            key2, value2 = item2

            return cmp(value1["isa"], value2["isa"])

        sorted_object_items = sorted(object_dict.iteritems(), cmp=compare_object_items)

        for key, value in sorted_object_items:
            value_isa = value["isa"]
            if value_isa != current_isa:
                if current_isa != None:
                    self.deindent()
                    self.deindent()
                    self.write("\n/* End %s section */" % current_isa)
                    self.indent()
                    self.indent()

                self.deindent()
                self.deindent()
                self.write("\n\n/* Begin %s section */" % value_isa)
                self.indent()
                self.indent()

                current_isa = value_isa
            self.write("\n")
            if current_isa in set(("PBXFileReference", "PBXBuildFile")):
                self.multiline = False
            else:
                self.multiline = True

            self.write_dict_item(key, value)

        #write end of last section
        self.deindent()
        self.deindent()
        self.write("\n/* End %s section */" % current_isa)
        self.indent()
        self.indent()

        self.deindent()
        self.write(u"\n};")

    def decide_multiline(self, value):
        return self.multiline

    def write_dict_item(self, key, value, comment = None):
        if key in self.COMMENT_BLACKLIST:
            old = self.auto_comment
            self.auto_comment = False
            super(PBXProjectPlistWriter, self).write_dict_item(key, value, comment)
            self.auto_comment = old
        else:
            super(PBXProjectPlistWriter, self).write_dict_item(key, value, comment)

    def write_string(self, string):
        if self.auto_comment and PBXProjectPlistWriter.OBJECTID_RE.match(string):
            comment = self.get_comment_for_object(string)
            super(PBXProjectPlistWriter, self).write_string(string)
            if comment != None:
                self.write(" /* %s */" % comment)
        else:
            super(PBXProjectPlistWriter, self).write_string(string)

    def write_dict_key(self, key, value, comment = None, comment_before_value = False):
        if not isinstance(value, dict) or value.get("isa", None) != "PBXProject":
            super(PBXProjectPlistWriter, self).write_dict_key(key, value, comment, comment_before_value)
        else:
            comment = "Project object"
            super(PBXProjectPlistWriter, self).write_string(key)
            if comment_before_value and comment != None:
                self.write(u" /* " + comment + " */")

    def get_comment_for_object(self, identifier):
        try:
            object = self.pbxproj.get_objects().get(identifier)
        except KeyError:
            return None # if object does not exist, make no comment about it
        if object == None:
            return None
        else:
            return object.get_name(self.pbxproj)

########NEW FILE########
__FILENAME__ = PlistLexer
# $ANTLR 3.2 Sep 23, 2009 12:02:23 Plist.g 2013-12-12 18:02:36

import sys
from itertools import chain
from .runtime.antlr3 import *
from .runtime.antlr3.compat import set, frozenset


# for convenience in actions
HIDDEN = BaseRecognizer.HIDDEN

# token types
BRACE_OPEN=13
WS=16
ESC_SEQ=7
BRACE_CLOSE=14
WS_CHAR=5
IDENTIFIER=6
DICTIONARY_SEPERATOR=10
ARRAY_SEPERATOR=9
HEX_DIGIT=17
ASSIGNMENT=15
COMMENT=4
EOF=-1
BRACKET_CLOSE=12
STRING=8
BRACKET_OPEN=11

"""
yield all numbers from start to stop, including start and stop
"""
def range_inc(start, stop):
    current = start
    while current <= stop:
        yield current
        current += 1


class PlistLexer(Lexer):

    grammarFileName = "Plist.g"
    antlr_version = version_str_to_tuple("3.1 Sep 23, 2009 12:02:23")
    antlr_version_str = "3.1 Sep 23, 2009 12:02:23"

    def __init__(self, input=None, state=None):
        if state is None:
            state = RecognizerSharedState()
        super(PlistLexer, self).__init__(input, state)


        self.dfa7 = self.DFA7(
            self, 7,
            eot = self.DFA7_eot,
            eof = self.DFA7_eof,
            min = self.DFA7_min,
            max = self.DFA7_max,
            accept = self.DFA7_accept,
            special = self.DFA7_special,
            transition = self.DFA7_transition
            )




                               
    def displayRecognitionError(self, tokenNames, exception):
        pass



    # $ANTLR start "COMMENT"
    def mCOMMENT(self, ):

        try:
            _type = COMMENT
            _channel = DEFAULT_CHANNEL

            # Plist.g:28:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
            alt4 = 2
            LA4_0 = self.input.LA(1)

            if (LA4_0 == 47) :
                LA4_1 = self.input.LA(2)

                if (LA4_1 == 47) :
                    alt4 = 1
                elif (LA4_1 == 42) :
                    alt4 = 2
                else:
                    nvae = NoViableAltException("", 4, 1, self.input)

                    raise nvae

            else:
                nvae = NoViableAltException("", 4, 0, self.input)

                raise nvae

            if alt4 == 1:
                # Plist.g:28:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
                pass 
                self.match("//")
                # Plist.g:28:14: (~ ( '\\n' | '\\r' ) )*
                while True: #loop1
                    alt1 = 2
                    LA1_0 = self.input.LA(1)

                    if ((0 <= LA1_0 <= 9) or (11 <= LA1_0 <= 12) or (14 <= LA1_0 <= 65535)) :
                        alt1 = 1


                    if alt1 == 1:
                        # Plist.g:28:14: ~ ( '\\n' | '\\r' )
                        pass
                        LA1_2 = self.input.LA(1)
                        if (0 <= LA1_2 <= 9) or (11 <= LA1_2 <= 12) or (14 <= LA1_2 <= 65535):
                            self.input.consume()
                        else:
                            mse = MismatchedSetException(None, self.input)
                            self.recover(mse)
                            raise mse



                    else:
                        break #loop1
                # Plist.g:28:28: ( '\\r' )?
                alt2 = 2
                LA2_0 = self.input.LA(1)

                if (LA2_0 == 13) :
                    alt2 = 1
                if alt2 == 1:
                    # Plist.g:28:28: '\\r'
                    pass 
                    self.match(13)



                self.match(10)
                #action start
                _channel=HIDDEN;
                #action end


            elif alt4 == 2:
                # Plist.g:29:9: '/*' ( options {greedy=false; } : . )* '*/'
                pass 
                self.match("/*")
                # Plist.g:29:14: ( options {greedy=false; } : . )*
                while True: #loop3
                    alt3 = 2
                    LA3_0 = self.input.LA(1)

                    if (LA3_0 == 42) :
                        LA3_1 = self.input.LA(2)

                        if (LA3_1 == 47) :
                            alt3 = 2
                        elif ((0 <= LA3_1 <= 46) or (48 <= LA3_1 <= 65535)) :
                            alt3 = 1


                    elif ((0 <= LA3_0 <= 41) or (43 <= LA3_0 <= 65535)) :
                        alt3 = 1


                    if alt3 == 1:
                        # Plist.g:29:42: .
                        pass 
                        self.matchAny()


                    else:
                        break #loop3
                self.match("*/")
                #action start
                _channel=HIDDEN;
                #action end


            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "COMMENT"



    # $ANTLR start "IDENTIFIER"
    IDENTIFIER_SET = frozenset(chain(
                        range_inc(0,8),
                        range_inc(11,12),
                        range_inc(14,31),
                        range_inc(33,33),
                        range_inc(35,39),
                        range_inc(42,43),
                        range_inc(45,58),
                        range_inc(63,122),
                        range_inc(124,124)
                        ))

    def mIDENTIFIER(self, ):

        try:
            _type = IDENTIFIER
            _channel = DEFAULT_CHANNEL

            # Plist.g:33:5: ( (~ ( ';' | WS_CHAR | '=' | '(' | ')' | '{' | '}' | ',' | '\"' | '<' | '>' ) )+ )
            # Plist.g:33:7: (~ ( ';' | WS_CHAR | '=' | '(' | ')' | '{' | '}' | ',' | '\"' | '<' | '>' ) )+
            pass 
            # Plist.g:33:7: (~ ( ';' | WS_CHAR | '=' | '(' | ')' | '{' | '}' | ',' | '\"' | '<' | '>' ) )+
            cnt5 = 0
            while True: #loop5
                alt5 = 2
                LA5_0 = self.input.LA(1)

                if LA5_0 in self.IDENTIFIER_SET or (126 <= LA5_0 <= 65535):
                    alt5 = 1


                if alt5 == 1:
                    # Plist.g:33:8: ~ ( ';' | WS_CHAR | '=' | '(' | ')' | '{' | '}' | ',' | '\"' | '<' | '>' )
                    pass
                    la = self.input.LA(1)
                    if la in self.IDENTIFIER_SET or (126 <= la <= 65535):
                        self.input.consume()
                    else:
                        mse = MismatchedSetException(None, self.input)
                        self.recover(mse)
                        raise mse



                else:
                    if cnt5 >= 1:
                        break #loop5

                    eee = EarlyExitException(5, self.input)
                    raise eee

                cnt5 += 1



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "IDENTIFIER"



    # $ANTLR start "STRING"
    def mSTRING(self, ):

        try:
            _type = STRING
            _channel = DEFAULT_CHANNEL

            # Plist.g:37:5: ( '\"' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )* '\"' )
            # Plist.g:37:8: '\"' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )* '\"'
            pass 
            self.match(34)
            # Plist.g:37:12: ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )*
            while True: #loop6
                alt6 = 3
                LA6_0 = self.input.LA(1)

                if (LA6_0 == 92) :
                    alt6 = 1
                elif ((0 <= LA6_0 <= 33) or (35 <= LA6_0 <= 91) or (93 <= LA6_0 <= 65535)) :
                    alt6 = 2


                if alt6 == 1:
                    # Plist.g:37:14: ESC_SEQ
                    pass 
                    self.mESC_SEQ()


                elif alt6 == 2:
                    # Plist.g:37:24: ~ ( '\\\\' | '\"' )
                    pass
                    LA6_1 = self.input.LA(1)
                    if (0 <= LA6_1 <= 33) or (35 <= LA6_1 <= 91) or (93 <= LA6_1 <= 65535):
                        self.input.consume()
                    else:
                        mse = MismatchedSetException(None, self.input)
                        self.recover(mse)
                        raise mse



                else:
                    break #loop6
            self.match(34)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "STRING"



    # $ANTLR start "ARRAY_SEPERATOR"
    def mARRAY_SEPERATOR(self, ):

        try:
            _type = ARRAY_SEPERATOR
            _channel = DEFAULT_CHANNEL

            # Plist.g:41:2: ( ',' )
            # Plist.g:41:4: ','
            pass 
            self.match(44)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "ARRAY_SEPERATOR"



    # $ANTLR start "DICTIONARY_SEPERATOR"
    def mDICTIONARY_SEPERATOR(self, ):

        try:
            _type = DICTIONARY_SEPERATOR
            _channel = DEFAULT_CHANNEL

            # Plist.g:45:2: ( ';' )
            # Plist.g:45:4: ';'
            pass 
            self.match(59)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "DICTIONARY_SEPERATOR"



    # $ANTLR start "BRACKET_OPEN"
    def mBRACKET_OPEN(self, ):

        try:
            _type = BRACKET_OPEN
            _channel = DEFAULT_CHANNEL

            # Plist.g:49:2: ( '(' )
            # Plist.g:49:4: '('
            pass 
            self.match(40)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "BRACKET_OPEN"



    # $ANTLR start "BRACKET_CLOSE"
    def mBRACKET_CLOSE(self, ):

        try:
            _type = BRACKET_CLOSE
            _channel = DEFAULT_CHANNEL

            # Plist.g:53:2: ( ')' )
            # Plist.g:53:4: ')'
            pass 
            self.match(41)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "BRACKET_CLOSE"



    # $ANTLR start "BRACE_OPEN"
    def mBRACE_OPEN(self, ):

        try:
            _type = BRACE_OPEN
            _channel = DEFAULT_CHANNEL

            # Plist.g:57:2: ( '{' )
            # Plist.g:57:4: '{'
            pass 
            self.match(123)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "BRACE_OPEN"



    # $ANTLR start "BRACE_CLOSE"
    def mBRACE_CLOSE(self, ):

        try:
            _type = BRACE_CLOSE
            _channel = DEFAULT_CHANNEL

            # Plist.g:61:2: ( '}' )
            # Plist.g:61:4: '}'
            pass 
            self.match(125)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "BRACE_CLOSE"



    # $ANTLR start "ASSIGNMENT"
    def mASSIGNMENT(self, ):

        try:
            _type = ASSIGNMENT
            _channel = DEFAULT_CHANNEL

            # Plist.g:65:9: ( '=' )
            # Plist.g:65:11: '='
            pass 
            self.match(61)



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "ASSIGNMENT"



    # $ANTLR start "WS"
    def mWS(self, ):

        try:
            _type = WS
            _channel = DEFAULT_CHANNEL

            # Plist.g:68:4: ( ( WS_CHAR ) )
            # Plist.g:68:6: ( WS_CHAR )
            pass 
            # Plist.g:68:6: ( WS_CHAR )
            # Plist.g:68:7: WS_CHAR
            pass 
            self.mWS_CHAR()



            #action start
            _channel=HIDDEN;
            #action end



            self._state.type = _type
            self._state.channel = _channel

        finally:

            pass

    # $ANTLR end "WS"



    # $ANTLR start "HEX_DIGIT"
    def mHEX_DIGIT(self, ):

        try:
            # Plist.g:72:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
            # Plist.g:72:13: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
            pass
            LA0 = self.input.LA(1)
            if (48 <= LA0 <= 57) or (65 <= LA0 <= 70) or (97 <= LA0 <= 102):
                self.input.consume()
            else:
                mse = MismatchedSetException(None, self.input)
                self.recover(mse)
                raise mse





        finally:

            pass

    # $ANTLR end "HEX_DIGIT"



    # $ANTLR start "ESC_SEQ"
    def mESC_SEQ(self, ):

        try:
            # Plist.g:76:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) )
            # Plist.g:76:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
            pass 
            self.match(92)
            LA0 = self.input.LA(1)
            if LA0 == 34 or LA0 == 39 or LA0 == 92 or LA0 == 98 or LA0 == 102 or LA0 == 110 or LA0 == 114 or LA0 == 116:
                self.input.consume()
            else:
                mse = MismatchedSetException(None, self.input)
                self.recover(mse)
                raise mse





        finally:

            pass

    # $ANTLR end "ESC_SEQ"



    # $ANTLR start "WS_CHAR"
    def mWS_CHAR(self, ):

        try:
            # Plist.g:80:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
            # Plist.g:80:9: ( ' ' | '\\t' | '\\r' | '\\n' )
            pass
            LA0 = self.input.LA(1)
            if (9 <= LA0 <= 10) or LA0 == 13 or LA0 == 32:
                self.input.consume()
            else:
                mse = MismatchedSetException(None, self.input)
                self.recover(mse)
                raise mse





        finally:

            pass

    # $ANTLR end "WS_CHAR"



    def mTokens(self):
        # Plist.g:1:8: ( COMMENT | IDENTIFIER | STRING | ARRAY_SEPERATOR | DICTIONARY_SEPERATOR | BRACKET_OPEN | BRACKET_CLOSE | BRACE_OPEN | BRACE_CLOSE | ASSIGNMENT | WS )
        alt7 = 11
        alt7 = self.dfa7.predict(self.input)
        if alt7 == 1:
            # Plist.g:1:10: COMMENT
            pass 
            self.mCOMMENT()


        elif alt7 == 2:
            # Plist.g:1:18: IDENTIFIER
            pass 
            self.mIDENTIFIER()


        elif alt7 == 3:
            # Plist.g:1:29: STRING
            pass 
            self.mSTRING()


        elif alt7 == 4:
            # Plist.g:1:36: ARRAY_SEPERATOR
            pass 
            self.mARRAY_SEPERATOR()


        elif alt7 == 5:
            # Plist.g:1:52: DICTIONARY_SEPERATOR
            pass 
            self.mDICTIONARY_SEPERATOR()


        elif alt7 == 6:
            # Plist.g:1:73: BRACKET_OPEN
            pass 
            self.mBRACKET_OPEN()


        elif alt7 == 7:
            # Plist.g:1:86: BRACKET_CLOSE
            pass 
            self.mBRACKET_CLOSE()


        elif alt7 == 8:
            # Plist.g:1:100: BRACE_OPEN
            pass 
            self.mBRACE_OPEN()


        elif alt7 == 9:
            # Plist.g:1:111: BRACE_CLOSE
            pass 
            self.mBRACE_CLOSE()


        elif alt7 == 10:
            # Plist.g:1:123: ASSIGNMENT
            pass 
            self.mASSIGNMENT()


        elif alt7 == 11:
            # Plist.g:1:134: WS
            pass 
            self.mWS()







    # lookup tables for DFA #7

    DFA7_eot = DFA.unpack(
        u"\1\uffff\1\2\12\uffff\3\2\1\uffff\2\2\1\17"
        )

    DFA7_eof = DFA.unpack(
        u"\23\uffff"
        )

    DFA7_min = DFA.unpack(
        u"\1\0\1\52\12\uffff\3\0\1\uffff\3\0"
        )

    DFA7_max = DFA.unpack(
        u"\1\uffff\1\57\12\uffff\3\uffff\1\uffff\3\uffff"
        )

    DFA7_accept = DFA.unpack(
        u"\2\uffff\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\3\uffff\1"
        u"\1\3\uffff"
        )

    DFA7_special = DFA.unpack(
        u"\1\5\13\uffff\1\0\1\6\1\1\1\uffff\1\4\1\2\1\3"
        )

            
    DFA7_transition = [
        DFA.unpack(u"\11\2\2\13\2\2\1\13\22\2\1\13\1\2\1\3\5\2\1\6\1\7\2"
        u"\2\1\4\2\2\1\1\13\2\1\5\1\uffff\1\12\1\uffff\74\2\1\10\1\2\1\11"
        u"\uff82\2"),
        DFA.unpack(u"\1\15\4\uffff\1\14"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\11\16\2\17\2\16\1\17\22\16\1\17\1\16\1\17\5\16\2\17"
        u"\2\16\1\17\16\16\4\17\74\16\1\17\1\16\1\17\uff82\16"),
        DFA.unpack(u"\11\21\2\17\2\21\1\17\22\21\1\17\1\21\1\17\5\21\2\17"
        u"\1\20\1\21\1\17\16\21\4\17\74\21\1\17\1\21\1\17\uff82\21"),
        DFA.unpack(u"\11\16\2\17\2\16\1\17\22\16\1\17\1\16\1\17\5\16\2\17"
        u"\2\16\1\17\16\16\4\17\74\16\1\17\1\16\1\17\uff82\16"),
        DFA.unpack(u""),
        DFA.unpack(u"\11\21\2\17\2\21\1\17\22\21\1\17\1\21\1\17\5\21\2\17"
        u"\1\20\1\21\1\17\2\21\1\22\13\21\4\17\74\21\1\17\1\21\1\17\uff82"
        u"\21"),
        DFA.unpack(u"\11\21\2\17\2\21\1\17\22\21\1\17\1\21\1\17\5\21\2\17"
        u"\1\20\1\21\1\17\16\21\4\17\74\21\1\17\1\21\1\17\uff82\21"),
        DFA.unpack(u"\11\21\2\uffff\2\21\1\uffff\22\21\1\uffff\1\21\1\uffff"
        u"\5\21\2\uffff\1\20\1\21\1\uffff\16\21\4\uffff\74\21\1\uffff\1\21"
        u"\1\uffff\uff82\21")
    ]

    # class definition for DFA #7

    class DFA7(DFA):
        pass

        SET1 = frozenset(chain(
            range_inc(0,8),
            range_inc(11,12),
            range_inc(14,31),
            range_inc(33,33),
            range_inc(35,39),
            range_inc(42,43),
            range_inc(45, 58),
            range_inc(63, 122),
            range_inc(124,124),
        ))
        SET2 = frozenset(chain(
            range_inc(9, 10),
            range_inc(13,13),
            range_inc(32, 32),
            range_inc(34, 34),
            range_inc(40, 41),
            range_inc(44, 44),
            range_inc(59, 62),
            range_inc(123, 123),
            range_inc(125, 125),
        ))
        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA7_12 = input.LA(1)

                s = -1
                if LA7_12 in self_.SET1 or (126 <= LA7_12 <= 65535):
                    s = 14

                elif LA7_12 in self_.SET2:
                    s = 15

                else:
                    s = 2

                if s >= 0:
                    return s
            elif s == 1: 
                LA7_14 = input.LA(1)

                s = -1
                if LA7_14 in self_.SET2:
                    s = 15

                elif LA7_14 in self_.SET1 or (126 <= LA7_14 <= 65535):
                    s = 14

                else:
                    s = 2

                if s >= 0:
                    return s
            elif s == 2: 
                LA7_17 = input.LA(1)

                s = -1
                if (LA7_17 == 42):
                    s = 16

                elif LA7_17 in self_.SET1 or (126 <= LA7_17 <= 65535):
                    s = 17

                elif LA7_17 in self_.SET2:
                    s = 15

                else:
                    s = 2

                if s >= 0:
                    return s
            elif s == 3: 
                LA7_18 = input.LA(1)

                s = -1
                if (LA7_18 == 42):
                    s = 16

                elif LA7_18 in self_.SET1 or (126 <= LA7_18 <= 65535):
                    s = 17

                else:
                    s = 15

                if s >= 0:
                    return s
            elif s == 4: 
                LA7_16 = input.LA(1)

                s = -1
                if (LA7_16 == 47):
                    s = 18

                elif (LA7_16 == 42):
                    s = 16

                elif LA7_16 in self_.SET1 or (126 <= LA7_16 <= 65535):
                    s = 17

                elif LA7_16 in self_.SET2:
                    s = 15

                else:
                    s = 2

                if s >= 0:
                    return s
            elif s == 5: 
                LA7_0 = input.LA(1)

                s = -1
                if (LA7_0 == 47):
                    s = 1

                elif LA7_0 in self_.SET1 or (126 <= LA7_0 <= 65535):
                    s = 2

                elif (LA7_0 == 34):
                    s = 3

                elif (LA7_0 == 44):
                    s = 4

                elif (LA7_0 == 59):
                    s = 5

                elif (LA7_0 == 40):
                    s = 6

                elif (LA7_0 == 41):
                    s = 7

                elif (LA7_0 == 123):
                    s = 8

                elif (LA7_0 == 125):
                    s = 9

                elif (LA7_0 == 61):
                    s = 10

                elif ((9 <= LA7_0 <= 10) or LA7_0 == 13 or LA7_0 == 32):
                    s = 11

                if s >= 0:
                    return s
            elif s == 6: 
                LA7_13 = input.LA(1)

                s = -1
                if (LA7_13 == 42):
                    s = 16

                elif LA7_13 in self_.SET1 or (126 <= LA7_13 <= 65535):
                    s = 17

                elif LA7_13 in self_.SET2:
                    s = 15

                else:
                    s = 2

                if s >= 0:
                    return s

            nvae = NoViableAltException(self_.getDescription(), 7, _s, input)
            self_.error(nvae)
            raise nvae
 



def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import LexerMain
    main = LexerMain(PlistLexer)
    main.stdin = stdin
    main.stdout = stdout
    main.stderr = stderr
    main.execute(argv)


if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = PlistParser
# $ANTLR 3.2 Sep 23, 2009 12:02:23 Plist.g 2013-12-12 18:02:36

import sys
from .runtime.antlr3 import *
from .runtime.antlr3.compat import set, frozenset
         
from collections import OrderedDict


from ..escape import unescape_string

# for convenience in actions
HIDDEN = BaseRecognizer.HIDDEN

# token types
BRACE_OPEN=13
WS=16
ESC_SEQ=7
BRACE_CLOSE=14
WS_CHAR=5
IDENTIFIER=6
DICTIONARY_SEPERATOR=10
ARRAY_SEPERATOR=9
HEX_DIGIT=17
ASSIGNMENT=15
COMMENT=4
EOF=-1
BRACKET_CLOSE=12
STRING=8
BRACKET_OPEN=11

# token names
tokenNames = [
    "<invalid>", "<EOR>", "<DOWN>", "<UP>", 
    "COMMENT", "WS_CHAR", "IDENTIFIER", "ESC_SEQ", "STRING", "ARRAY_SEPERATOR", 
    "DICTIONARY_SEPERATOR", "BRACKET_OPEN", "BRACKET_CLOSE", "BRACE_OPEN", 
    "BRACE_CLOSE", "ASSIGNMENT", "WS", "HEX_DIGIT"
]




class PlistParser(Parser):
    grammarFileName = "Plist.g"
    antlr_version = version_str_to_tuple("3.1 Sep 23, 2009 12:02:23")
    antlr_version_str = "3.1 Sep 23, 2009 12:02:23"
    tokenNames = tokenNames

    def __init__(self, input, state=None, *args, **kwargs):
        if state is None:
            state = RecognizerSharedState()

        super(PlistParser, self).__init__(input, state, *args, **kwargs)






                


        

                      
    def displayRecognitionError(self, tokenNames, exception):
        pass



    # $ANTLR start "plist"
    # Plist.g:87:1: plist returns [value] : (lbl_value= dictionary | lbl_value= array );
    def plist(self, ):

        value = None

        lbl_value = None


        try:
            try:
                # Plist.g:91:5: (lbl_value= dictionary | lbl_value= array )
                alt1 = 2
                LA1_0 = self.input.LA(1)

                if (LA1_0 == BRACE_OPEN) :
                    alt1 = 1
                elif (LA1_0 == BRACKET_OPEN) :
                    alt1 = 2
                else:
                    nvae = NoViableAltException("", 1, 0, self.input)

                    raise nvae

                if alt1 == 1:
                    # Plist.g:91:8: lbl_value= dictionary
                    pass 
                    self._state.following.append(self.FOLLOW_dictionary_in_plist474)
                    lbl_value = self.dictionary()

                    self._state.following.pop()


                elif alt1 == 2:
                    # Plist.g:91:31: lbl_value= array
                    pass 
                    self._state.following.append(self.FOLLOW_array_in_plist480)
                    lbl_value = self.array()

                    self._state.following.pop()


                #action start
                            
                value = lbl_value
                    
                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "plist"


    # $ANTLR start "value"
    # Plist.g:93:1: value returns [value] : (lbl_value= dictionary | lbl_value= array | lbl_value= identifier | lbl_value= string );
    def value(self, ):

        value = None

        lbl_value = None


        try:
            try:
                # Plist.g:97:5: (lbl_value= dictionary | lbl_value= array | lbl_value= identifier | lbl_value= string )
                alt2 = 4
                LA2 = self.input.LA(1)
                if LA2 == BRACE_OPEN:
                    alt2 = 1
                elif LA2 == BRACKET_OPEN:
                    alt2 = 2
                elif LA2 == IDENTIFIER:
                    alt2 = 3
                elif LA2 == STRING:
                    alt2 = 4
                else:
                    nvae = NoViableAltException("", 2, 0, self.input)

                    raise nvae

                if alt2 == 1:
                    # Plist.g:97:8: lbl_value= dictionary
                    pass 
                    self._state.following.append(self.FOLLOW_dictionary_in_value508)
                    lbl_value = self.dictionary()

                    self._state.following.pop()


                elif alt2 == 2:
                    # Plist.g:97:31: lbl_value= array
                    pass 
                    self._state.following.append(self.FOLLOW_array_in_value514)
                    lbl_value = self.array()

                    self._state.following.pop()


                elif alt2 == 3:
                    # Plist.g:97:49: lbl_value= identifier
                    pass 
                    self._state.following.append(self.FOLLOW_identifier_in_value520)
                    lbl_value = self.identifier()

                    self._state.following.pop()


                elif alt2 == 4:
                    # Plist.g:97:72: lbl_value= string
                    pass 
                    self._state.following.append(self.FOLLOW_string_in_value526)
                    lbl_value = self.string()

                    self._state.following.pop()


                #action start
                            
                value = lbl_value
                    
                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "value"


    # $ANTLR start "string"
    # Plist.g:99:1: string returns [value] : lbl_string= STRING ;
    def string(self, ):

        value = None

        lbl_string = None

        try:
            try:
                # Plist.g:103:5: (lbl_string= STRING )
                # Plist.g:103:9: lbl_string= STRING
                pass 
                lbl_string=self.match(self.input, STRING, self.FOLLOW_STRING_in_string555)



                #action start

                value = unescape_string(lbl_string.text[1:-1])

                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "string"


    # $ANTLR start "identifier"
    # Plist.g:105:1: identifier returns [value] : lbl_identifier= IDENTIFIER ;
    def identifier(self, ):

        value = None

        lbl_identifier = None

        try:
            try:
                # Plist.g:109:5: (lbl_identifier= IDENTIFIER )
                # Plist.g:109:7: lbl_identifier= IDENTIFIER
                pass 
                lbl_identifier=self.match(self.input, IDENTIFIER, self.FOLLOW_IDENTIFIER_in_identifier586)



                #action start
                            
                value = lbl_identifier.text
                    
                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "identifier"


    # $ANTLR start "array"
    # Plist.g:112:1: array returns [value] : BRACKET_OPEN (lbl_first_value= value ( ARRAY_SEPERATOR lbl_value= value )* )? ( ARRAY_SEPERATOR )? BRACKET_CLOSE ;
    def array(self, ):

        value = None

        lbl_first_value = None

        lbl_value = None


                   
        value = []
            
        try:
            try:
                # Plist.g:116:5: ( BRACKET_OPEN (lbl_first_value= value ( ARRAY_SEPERATOR lbl_value= value )* )? ( ARRAY_SEPERATOR )? BRACKET_CLOSE )
                # Plist.g:116:8: BRACKET_OPEN (lbl_first_value= value ( ARRAY_SEPERATOR lbl_value= value )* )? ( ARRAY_SEPERATOR )? BRACKET_CLOSE
                pass 
                self.match(self.input, BRACKET_OPEN, self.FOLLOW_BRACKET_OPEN_in_array617)
                # Plist.g:116:21: (lbl_first_value= value ( ARRAY_SEPERATOR lbl_value= value )* )?
                alt4 = 2
                LA4_0 = self.input.LA(1)

                if (LA4_0 == IDENTIFIER or LA4_0 == STRING or LA4_0 == BRACKET_OPEN or LA4_0 == BRACE_OPEN) :
                    alt4 = 1
                if alt4 == 1:
                    # Plist.g:116:22: lbl_first_value= value ( ARRAY_SEPERATOR lbl_value= value )*
                    pass 
                    self._state.following.append(self.FOLLOW_value_in_array622)
                    lbl_first_value = self.value()

                    self._state.following.pop()
                    #action start
                    value.append(lbl_first_value)
                    #action end
                    # Plist.g:116:84: ( ARRAY_SEPERATOR lbl_value= value )*
                    while True: #loop3
                        alt3 = 2
                        LA3_0 = self.input.LA(1)

                        if (LA3_0 == ARRAY_SEPERATOR) :
                            LA3_1 = self.input.LA(2)

                            if (LA3_1 == IDENTIFIER or LA3_1 == STRING or LA3_1 == BRACKET_OPEN or LA3_1 == BRACE_OPEN) :
                                alt3 = 1




                        if alt3 == 1:
                            # Plist.g:116:85: ARRAY_SEPERATOR lbl_value= value
                            pass 
                            self.match(self.input, ARRAY_SEPERATOR, self.FOLLOW_ARRAY_SEPERATOR_in_array627)
                            self._state.following.append(self.FOLLOW_value_in_array631)
                            lbl_value = self.value()

                            self._state.following.pop()
                            #action start
                            value.append(lbl_value)
                            #action end


                        else:
                            break #loop3



                # Plist.g:116:155: ( ARRAY_SEPERATOR )?
                alt5 = 2
                LA5_0 = self.input.LA(1)

                if (LA5_0 == ARRAY_SEPERATOR) :
                    alt5 = 1
                if alt5 == 1:
                    # Plist.g:116:156: ARRAY_SEPERATOR
                    pass 
                    self.match(self.input, ARRAY_SEPERATOR, self.FOLLOW_ARRAY_SEPERATOR_in_array640)



                self.match(self.input, BRACKET_CLOSE, self.FOLLOW_BRACKET_CLOSE_in_array644)




                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "array"


    # $ANTLR start "dictionary_key"
    # Plist.g:119:1: dictionary_key returns [value] : (lbl_key= identifier | lbl_key= string ) ;
    def dictionary_key(self, ):

        value = None

        lbl_key = None


        try:
            try:
                # Plist.g:123:2: ( (lbl_key= identifier | lbl_key= string ) )
                # Plist.g:123:6: (lbl_key= identifier | lbl_key= string )
                pass 
                # Plist.g:123:6: (lbl_key= identifier | lbl_key= string )
                alt6 = 2
                LA6_0 = self.input.LA(1)

                if (LA6_0 == IDENTIFIER) :
                    alt6 = 1
                elif (LA6_0 == STRING) :
                    alt6 = 2
                else:
                    nvae = NoViableAltException("", 6, 0, self.input)

                    raise nvae

                if alt6 == 1:
                    # Plist.g:123:7: lbl_key= identifier
                    pass 
                    self._state.following.append(self.FOLLOW_identifier_in_dictionary_key673)
                    lbl_key = self.identifier()

                    self._state.following.pop()


                elif alt6 == 2:
                    # Plist.g:123:28: lbl_key= string
                    pass 
                    self._state.following.append(self.FOLLOW_string_in_dictionary_key679)
                    lbl_key = self.string()

                    self._state.following.pop()






                #action start
                         
                value = lbl_key
                	
                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "dictionary_key"


    # $ANTLR start "dictionary_entry"
    # Plist.g:126:1: dictionary_entry returns [value] : lbl_key= dictionary_key ASSIGNMENT lbl_value= value DICTIONARY_SEPERATOR ;
    def dictionary_entry(self, ):

        value = None

        lbl_key = None

        lbl_value = None


        try:
            try:
                # Plist.g:130:5: (lbl_key= dictionary_key ASSIGNMENT lbl_value= value DICTIONARY_SEPERATOR )
                # Plist.g:130:8: lbl_key= dictionary_key ASSIGNMENT lbl_value= value DICTIONARY_SEPERATOR
                pass 
                self._state.following.append(self.FOLLOW_dictionary_key_in_dictionary_entry710)
                lbl_key = self.dictionary_key()

                self._state.following.pop()
                self.match(self.input, ASSIGNMENT, self.FOLLOW_ASSIGNMENT_in_dictionary_entry712)
                self._state.following.append(self.FOLLOW_value_in_dictionary_entry716)
                lbl_value = self.value()

                self._state.following.pop()
                self.match(self.input, DICTIONARY_SEPERATOR, self.FOLLOW_DICTIONARY_SEPERATOR_in_dictionary_entry718)



                #action start
                            
                value = (lbl_key, lbl_value)
                    
                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "dictionary_entry"


    # $ANTLR start "dictionary"
    # Plist.g:133:1: dictionary returns [value] : BRACE_OPEN (lbl_entry= dictionary_entry )* BRACE_CLOSE ;
    def dictionary(self, ):

        value = None

        lbl_entry = None


                   
        entries = []
            
        try:
            try:
                # Plist.g:140:5: ( BRACE_OPEN (lbl_entry= dictionary_entry )* BRACE_CLOSE )
                # Plist.g:140:8: BRACE_OPEN (lbl_entry= dictionary_entry )* BRACE_CLOSE
                pass 
                self.match(self.input, BRACE_OPEN, self.FOLLOW_BRACE_OPEN_in_dictionary758)
                # Plist.g:140:19: (lbl_entry= dictionary_entry )*
                while True: #loop7
                    alt7 = 2
                    LA7_0 = self.input.LA(1)

                    if (LA7_0 == IDENTIFIER or LA7_0 == STRING) :
                        alt7 = 1


                    if alt7 == 1:
                        # Plist.g:140:20: lbl_entry= dictionary_entry
                        pass 
                        self._state.following.append(self.FOLLOW_dictionary_entry_in_dictionary763)
                        lbl_entry = self.dictionary_entry()

                        self._state.following.pop()
                        #action start
                        entries.append(lbl_entry)
                        #action end


                    else:
                        break #loop7
                self.match(self.input, BRACE_CLOSE, self.FOLLOW_BRACE_CLOSE_in_dictionary769)



                #action start
                            
                value = OrderedDict(entries)
                    
                #action end

                        
            except RecognitionException, e:
                raise e
        finally:

            pass
        return value

    # $ANTLR end "dictionary"


    # Delegated rules


 

    FOLLOW_dictionary_in_plist474 = frozenset([1])
    FOLLOW_array_in_plist480 = frozenset([1])
    FOLLOW_dictionary_in_value508 = frozenset([1])
    FOLLOW_array_in_value514 = frozenset([1])
    FOLLOW_identifier_in_value520 = frozenset([1])
    FOLLOW_string_in_value526 = frozenset([1])
    FOLLOW_STRING_in_string555 = frozenset([1])
    FOLLOW_IDENTIFIER_in_identifier586 = frozenset([1])
    FOLLOW_BRACKET_OPEN_in_array617 = frozenset([6, 8, 9, 11, 12, 13])
    FOLLOW_value_in_array622 = frozenset([9, 12])
    FOLLOW_ARRAY_SEPERATOR_in_array627 = frozenset([6, 8, 11, 13])
    FOLLOW_value_in_array631 = frozenset([9, 12])
    FOLLOW_ARRAY_SEPERATOR_in_array640 = frozenset([12])
    FOLLOW_BRACKET_CLOSE_in_array644 = frozenset([1])
    FOLLOW_identifier_in_dictionary_key673 = frozenset([1])
    FOLLOW_string_in_dictionary_key679 = frozenset([1])
    FOLLOW_dictionary_key_in_dictionary_entry710 = frozenset([15])
    FOLLOW_ASSIGNMENT_in_dictionary_entry712 = frozenset([6, 8, 11, 13])
    FOLLOW_value_in_dictionary_entry716 = frozenset([10])
    FOLLOW_DICTIONARY_SEPERATOR_in_dictionary_entry718 = frozenset([1])
    FOLLOW_BRACE_OPEN_in_dictionary758 = frozenset([6, 8, 11, 13, 14])
    FOLLOW_dictionary_entry_in_dictionary763 = frozenset([6, 8, 11, 13, 14])
    FOLLOW_BRACE_CLOSE_in_dictionary769 = frozenset([1])



def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import ParserMain
    main = ParserMain("PlistLexer", PlistParser)
    main.stdin = stdin
    main.stdout = stdout
    main.stderr = stderr
    main.execute(argv)


if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = compat
"""Compatibility stuff"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

try:
    set = set
    frozenset = frozenset
except NameError:
    from sets import Set as set, ImmutableSet as frozenset


try:
    reversed = reversed
except NameError:
    def reversed(l):
        l = l[:]
        l.reverse()
        return l



########NEW FILE########
__FILENAME__ = constants
"""ANTLR3 runtime package"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

EOF = -1

## All tokens go to the parser (unless skip() is called in that rule)
# on a particular "channel".  The parser tunes to a particular channel
# so that whitespace etc... can go to the parser on a "hidden" channel.
DEFAULT_CHANNEL = 0

## Anything on different channel than DEFAULT_CHANNEL is not parsed
# by parser.
HIDDEN_CHANNEL = 99

# Predefined token types
EOR_TOKEN_TYPE = 1

##
# imaginary tree navigation type; traverse "get child" link
DOWN = 2
##
#imaginary tree navigation type; finish with a child list
UP = 3

MIN_TOKEN_TYPE = UP+1
	
INVALID_TOKEN_TYPE = 0


########NEW FILE########
__FILENAME__ = debug
# begin[licence]
#
#  [The "BSD licence"]
#  Copyright (c) 2005-2009 Terence Parr
#  All rights reserved.

#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.

#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

import socket
from . import Parser, TokenStream, RecognitionException, Token
from .tree import CommonTreeAdaptor, TreeAdaptor, Tree

class DebugParser(Parser):
    def __init__(self, stream, state=None, dbg=None, *args, **kwargs):
        # wrap token stream in DebugTokenStream (unless user already did so).
        if not isinstance(stream, DebugTokenStream):
            stream = DebugTokenStream(stream, dbg)

        super(DebugParser, self).__init__(stream, state, *args, **kwargs)

        # Who to notify when events in the parser occur.
        self._dbg = None

        self.setDebugListener(dbg)


    def setDebugListener(self, dbg):
	"""Provide a new debug event listener for this parser.  Notify the
        input stream too that it should send events to this listener.
	"""

        if hasattr(self.input, 'dbg'):
            self.input.dbg = dbg

        self._dbg = dbg

    def getDebugListener(self):
        return self._dbg

    dbg = property(getDebugListener, setDebugListener)


    def beginResync(self):
        self._dbg.beginResync()


    def endResync(self):
        self._dbg.endResync()


    def beginBacktrack(self, level):
        self._dbg.beginBacktrack(level)


    def endBacktrack(self, level, successful):
        self._dbg.endBacktrack(level,successful)


    def reportError(self, exc):
        if isinstance(exc, RecognitionException):
            self._dbg.recognitionException(exc)

        else:
            traceback.print_exc(exc)


class DebugTokenStream(TokenStream):
    def __init__(self, input, dbg=None):
        self.input = input
        self.initialStreamState = True
        # Track the last mark() call result value for use in rewind().
        self.lastMarker = None

        self._dbg = None
        self.setDebugListener(dbg)

        # force TokenStream to get at least first valid token
        # so we know if there are any hidden tokens first in the stream
        self.input.LT(1)


    def getDebugListener(self):
        return self._dbg

    def setDebugListener(self, dbg):
        self._dbg = dbg

    dbg = property(getDebugListener, setDebugListener)


    def consume(self):
        if self.initialStreamState:
            self.consumeInitialHiddenTokens()

        a = self.input.index()
        t = self.input.LT(1)
        self.input.consume()
        b = self.input.index()
        self._dbg.consumeToken(t)

        if b > a+1:
            # then we consumed more than one token; must be off channel tokens
            for idx in range(a+1, b):
                self._dbg.consumeHiddenToken(self.input.get(idx));


    def consumeInitialHiddenTokens(self):
        """consume all initial off-channel tokens"""
        
        firstOnChannelTokenIndex = self.input.index()
        for idx in range(firstOnChannelTokenIndex):
            self._dbg.consumeHiddenToken(self.input.get(idx))

        self.initialStreamState = False


    def LT(self, i):
        if self.initialStreamState:
            self.consumeInitialHiddenTokens()

        t = self.input.LT(i)
        self._dbg.LT(i, t)
        return t


    def LA(self, i):
        if self.initialStreamState:
            self.consumeInitialHiddenTokens()

        t = self.input.LT(i)
        self._dbg.LT(i, t)
        return t.type


    def get(self, i):
        return self.input.get(i)


    def index(self):
        return self.input.index()


    def mark(self):
        self.lastMarker = self.input.mark()
        self._dbg.mark(self.lastMarker)
        return self.lastMarker


    def rewind(self, marker=None):
        self._dbg.rewind(marker)
        self.input.rewind(marker)


    def release(self, marker):
        pass


    def seek(self, index):
        # TODO: implement seek in dbg interface
        # self._dbg.seek(index);
        self.input.seek(index)


    def size(self):
        return self.input.size()


    def getTokenSource(self):
        return self.input.getTokenSource()


    def getSourceName(self):
        return self.getTokenSource().getSourceName()


    def toString(self, start=None, stop=None):
        return self.input.toString(start, stop)


class DebugTreeAdaptor(TreeAdaptor):
    """A TreeAdaptor proxy that fires debugging events to a DebugEventListener
    delegate and uses the TreeAdaptor delegate to do the actual work.  All
    AST events are triggered by this adaptor; no code gen changes are needed
    in generated rules.  Debugging events are triggered *after* invoking
    tree adaptor routines.

    Trees created with actions in rewrite actions like "-> ^(ADD {foo} {bar})"
    cannot be tracked as they might not use the adaptor to create foo, bar.
    The debug listener has to deal with tree node IDs for which it did
    not see a createNode event.  A single <unknown> node is sufficient even
    if it represents a whole tree.
    """

    def __init__(self, dbg, adaptor):
        self.dbg = dbg
        self.adaptor = adaptor


    def createWithPayload(self, payload):
        if payload.getTokenIndex() < 0:
            # could be token conjured up during error recovery
            return self.createFromType(payload.getType(), payload.getText())

        node = self.adaptor.createWithPayload(payload)
        self.dbg.createNode(node, payload)
        return node

    def createFromToken(self, tokenType, fromToken, text=None):
        node = self.adaptor.createFromToken(tokenType, fromToken, text)
        self.dbg.createNode(node)
        return node

    def createFromType(self, tokenType, text):
        node = self.adaptor.createFromType(tokenType, text)
        self.dbg.createNode(node)
        return node


    def errorNode(self, input, start, stop, exc):
        node = selfadaptor.errorNode(input, start, stop, exc)
        if node is not None:
            dbg.errorNode(node)

        return node


    def dupTree(self, tree):
        t = self.adaptor.dupTree(tree)
        # walk the tree and emit create and add child events
        # to simulate what dupTree has done. dupTree does not call this debug
        # adapter so I must simulate.
        self.simulateTreeConstruction(t)
        return t


    def simulateTreeConstruction(self, t):
	"""^(A B C): emit create A, create B, add child, ..."""
        self.dbg.createNode(t)
        for i in range(self.adaptor.getChildCount(t)):
            child = self.adaptor.getChild(t, i)
            self.simulateTreeConstruction(child)
            self.dbg.addChild(t, child)


    def dupNode(self, treeNode):
        d = self.adaptor.dupNode(treeNode)
        self.dbg.createNode(d)
        return d


    def nil(self):
        node = self.adaptor.nil()
        self.dbg.nilNode(node)
        return node


    def isNil(self, tree):
        return self.adaptor.isNil(tree)


    def addChild(self, t, child):
        if isinstance(child, Token):
            n = self.createWithPayload(child)
            self.addChild(t, n)

        else:
            if t is None or child is None:
                return

            self.adaptor.addChild(t, child)
            self.dbg.addChild(t, child)

    def becomeRoot(self, newRoot, oldRoot):
        if isinstance(newRoot, Token):
            n = self.createWithPayload(newRoot)
            self.adaptor.becomeRoot(n, oldRoot)
        else:
            n = self.adaptor.becomeRoot(newRoot, oldRoot)

        self.dbg.becomeRoot(newRoot, oldRoot)
        return n


    def rulePostProcessing(self, root):
        return self.adaptor.rulePostProcessing(root)


    def getType(self, t):
        return self.adaptor.getType(t)


    def setType(self, t, type):
        self.adaptor.setType(t, type)


    def getText(self, t):
        return self.adaptor.getText(t)


    def setText(self, t, text):
        self.adaptor.setText(t, text)


    def getToken(self, t):
        return self.adaptor.getToken(t)


    def setTokenBoundaries(self, t, startToken, stopToken):
        self.adaptor.setTokenBoundaries(t, startToken, stopToken)
        if t is not None and startToken is not None and stopToken is not None:
            self.dbg.setTokenBoundaries(
                t, startToken.getTokenIndex(),
                stopToken.getTokenIndex())


    def getTokenStartIndex(self, t):
        return self.adaptor.getTokenStartIndex(t)


    def getTokenStopIndex(self, t):
        return self.adaptor.getTokenStopIndex(t)


    def getChild(self, t, i):
        return self.adaptor.getChild(t, i)


    def setChild(self, t, i, child):
        self.adaptor.setChild(t, i, child)


    def deleteChild(self, t, i):
        return self.adaptor.deleteChild(t, i)


    def getChildCount(self, t):
        return self.adaptor.getChildCount(t)


    def getUniqueID(self, node):
        return self.adaptor.getUniqueID(node)


    def getParent(self, t):
        return self.adaptor.getParent(t)


    def getChildIndex(self, t):
        return self.adaptor.getChildIndex(t)


    def setParent(self, t, parent):
        self.adaptor.setParent(t, parent)


    def setChildIndex(self, t, index):
        self.adaptor.setChildIndex(t, index)


    def replaceChildren(self, parent, startChildIndex, stopChildIndex, t):
        self.adaptor.replaceChildren(parent, startChildIndex, stopChildIndex, t)


    ## support

    def getDebugListener(self):
        return dbg

    def setDebugListener(self, dbg):
        self.dbg = dbg


    def getTreeAdaptor(self):
        return self.adaptor



class DebugEventListener(object):
    """All debugging events that a recognizer can trigger.
 
    I did not create a separate AST debugging interface as it would create
    lots of extra classes and DebugParser has a dbg var defined, which makes
    it hard to change to ASTDebugEventListener.  I looked hard at this issue
    and it is easier to understand as one monolithic event interface for all
    possible events.  Hopefully, adding ST debugging stuff won't be bad.  Leave
    for future. 4/26/2006.
    """

    # Moved to version 2 for v3.1: added grammar name to enter/exit Rule
    PROTOCOL_VERSION = "2"

    def enterRule(self, grammarFileName, ruleName):
	"""The parser has just entered a rule. No decision has been made about
        which alt is predicted.  This is fired AFTER init actions have been
        executed.  Attributes are defined and available etc...
        The grammarFileName allows composite grammars to jump around among
        multiple grammar files.
        """

        pass


    def enterAlt(self, alt):
	"""Because rules can have lots of alternatives, it is very useful to
        know which alt you are entering.  This is 1..n for n alts.
        """
        pass


    def exitRule(self, grammarFileName, ruleName):
	"""This is the last thing executed before leaving a rule.  It is
        executed even if an exception is thrown.  This is triggered after
        error reporting and recovery have occurred (unless the exception is
        not caught in this rule).  This implies an "exitAlt" event.
        The grammarFileName allows composite grammars to jump around among
        multiple grammar files.
	"""
        pass


    def enterSubRule(self, decisionNumber):
	"""Track entry into any (...) subrule other EBNF construct"""
        pass


    def exitSubRule(self, decisionNumber):
        pass


    def enterDecision(self, decisionNumber):
	"""Every decision, fixed k or arbitrary, has an enter/exit event
        so that a GUI can easily track what LT/consume events are
        associated with prediction.  You will see a single enter/exit
        subrule but multiple enter/exit decision events, one for each
        loop iteration.
        """
        pass


    def exitDecision(self, decisionNumber):
        pass


    def consumeToken(self, t):
	"""An input token was consumed; matched by any kind of element.
        Trigger after the token was matched by things like match(), matchAny().
	"""
        pass


    def consumeHiddenToken(self, t):
	"""An off-channel input token was consumed.
        Trigger after the token was matched by things like match(), matchAny().
        (unless of course the hidden token is first stuff in the input stream).
	"""
        pass


    def LT(self, i, t):
	"""Somebody (anybody) looked ahead.  Note that this actually gets
        triggered by both LA and LT calls.  The debugger will want to know
        which Token object was examined.  Like consumeToken, this indicates
        what token was seen at that depth.  A remote debugger cannot look
        ahead into a file it doesn't have so LT events must pass the token
        even if the info is redundant.
	"""
        pass


    def mark(self, marker):
	"""The parser is going to look arbitrarily ahead; mark this location,
        the token stream's marker is sent in case you need it.
	"""
        pass


    def rewind(self, marker=None):
	"""After an arbitrairly long lookahead as with a cyclic DFA (or with
        any backtrack), this informs the debugger that stream should be
        rewound to the position associated with marker.

        """
        pass


    def beginBacktrack(self, level):
        pass


    def endBacktrack(self, level, successful):
        pass


    def location(self, line, pos):
	"""To watch a parser move through the grammar, the parser needs to
        inform the debugger what line/charPos it is passing in the grammar.
        For now, this does not know how to switch from one grammar to the
        other and back for island grammars etc...

        This should also allow breakpoints because the debugger can stop
        the parser whenever it hits this line/pos.
	"""
        pass


    def recognitionException(self, e):
	"""A recognition exception occurred such as NoViableAltException.  I made
        this a generic event so that I can alter the exception hierachy later
        without having to alter all the debug objects.

        Upon error, the stack of enter rule/subrule must be properly unwound.
        If no viable alt occurs it is within an enter/exit decision, which
        also must be rewound.  Even the rewind for each mark must be unwount.
        In the Java target this is pretty easy using try/finally, if a bit
        ugly in the generated code.  The rewind is generated in DFA.predict()
        actually so no code needs to be generated for that.  For languages
        w/o this "finally" feature (C++?), the target implementor will have
        to build an event stack or something.

        Across a socket for remote debugging, only the RecognitionException
        data fields are transmitted.  The token object or whatever that
        caused the problem was the last object referenced by LT.  The
        immediately preceding LT event should hold the unexpected Token or
        char.

        Here is a sample event trace for grammar:

        b : C ({;}A|B) // {;} is there to prevent A|B becoming a set
          | D
          ;

        The sequence for this rule (with no viable alt in the subrule) for
        input 'c c' (there are 3 tokens) is:

		commence
		LT(1)
		enterRule b
		location 7 1
		enter decision 3
		LT(1)
		exit decision 3
		enterAlt1
		location 7 5
		LT(1)
		consumeToken [c/<4>,1:0]
		location 7 7
		enterSubRule 2
		enter decision 2
		LT(1)
		LT(1)
		recognitionException NoViableAltException 2 1 2
		exit decision 2
		exitSubRule 2
		beginResync
		LT(1)
		consumeToken [c/<4>,1:1]
		LT(1)
		endResync
		LT(-1)
		exitRule b
		terminate
	"""
        pass


    def beginResync(self):
	"""Indicates the recognizer is about to consume tokens to resynchronize
        the parser.  Any consume events from here until the recovered event
        are not part of the parse--they are dead tokens.
        """
        pass

    
    def endResync(self):
	"""Indicates that the recognizer has finished consuming tokens in order
        to resychronize.  There may be multiple beginResync/endResync pairs
        before the recognizer comes out of errorRecovery mode (in which
        multiple errors are suppressed).  This will be useful
        in a gui where you want to probably grey out tokens that are consumed
        but not matched to anything in grammar.  Anything between
        a beginResync/endResync pair was tossed out by the parser.
	"""
        pass


    def semanticPredicate(self, result, predicate):
	"""A semantic predicate was evaluate with this result and action text"""
        pass


    def commence(self):
	"""Announce that parsing has begun.  Not technically useful except for
        sending events over a socket.  A GUI for example will launch a thread
        to connect and communicate with a remote parser.  The thread will want
        to notify the GUI when a connection is made.  ANTLR parsers
        trigger this upon entry to the first rule (the ruleLevel is used to
        figure this out).
	"""
        pass


    def terminate(self):
        """Parsing is over; successfully or not.  Mostly useful for telling
        remote debugging listeners that it's time to quit.  When the rule
        invocation level goes to zero at the end of a rule, we are done
        parsing.
	"""
        pass


    ## T r e e  P a r s i n g

    def consumeNode(self, t):
        """Input for a tree parser is an AST, but we know nothing for sure
        about a node except its type and text (obtained from the adaptor).
        This is the analog of the consumeToken method.  Again, the ID is
        the hashCode usually of the node so it only works if hashCode is
        not implemented.  If the type is UP or DOWN, then
        the ID is not really meaningful as it's fixed--there is
        just one UP node and one DOWN navigation node.
        """
        pass


    def LT(self, i, t):
	"""The tree parser lookedahead.  If the type is UP or DOWN,
        then the ID is not really meaningful as it's fixed--there is
        just one UP node and one DOWN navigation node.
	"""
        pass



    ## A S T  E v e n t s

    def nilNode(self, t):
	"""A nil was created (even nil nodes have a unique ID...
        they are not "null" per se).  As of 4/28/2006, this
        seems to be uniquely triggered when starting a new subtree
        such as when entering a subrule in automatic mode and when
        building a tree in rewrite mode.

        If you are receiving this event over a socket via
        RemoteDebugEventSocketListener then only t.ID is set.
	"""
        pass


    def errorNode(self, t):
	"""Upon syntax error, recognizers bracket the error with an error node
        if they are building ASTs.
        """
        pass


    def createNode(self, node, token=None):
	"""Announce a new node built from token elements such as type etc...

        If you are receiving this event over a socket via
        RemoteDebugEventSocketListener then only t.ID, type, text are
        set.
	"""
        pass


    def becomeRoot(self, newRoot, oldRoot):
	"""Make a node the new root of an existing root.

        Note: the newRootID parameter is possibly different
        than the TreeAdaptor.becomeRoot() newRoot parameter.
        In our case, it will always be the result of calling
        TreeAdaptor.becomeRoot() and not root_n or whatever.

        The listener should assume that this event occurs
        only when the current subrule (or rule) subtree is
        being reset to newRootID.

        If you are receiving this event over a socket via
        RemoteDebugEventSocketListener then only IDs are set.

        @see antlr3.tree.TreeAdaptor.becomeRoot()
	"""
        pass


    def addChild(self, root, child):
	"""Make childID a child of rootID.

        If you are receiving this event over a socket via
        RemoteDebugEventSocketListener then only IDs are set.

        @see antlr3.tree.TreeAdaptor.addChild()
        """
        pass


    def setTokenBoundaries(self, t, tokenStartIndex, tokenStopIndex):
	"""Set the token start/stop token index for a subtree root or node.

        If you are receiving this event over a socket via
        RemoteDebugEventSocketListener then only t.ID is set.
	"""
        pass


class BlankDebugEventListener(DebugEventListener):
    """A blank listener that does nothing; useful for real classes so
    they don't have to have lots of blank methods and are less
    sensitive to updates to debug interface.

    Note: this class is identical to DebugEventListener and exists purely
    for compatibility with Java.
    """
    pass


class TraceDebugEventListener(DebugEventListener):
    """A listener that simply records text representations of the events.

    Useful for debugging the debugging facility ;)

    Subclasses can override the record() method (which defaults to printing to
    stdout) to record the events in a different way.
    """

    def __init__(self, adaptor=None):
        super(TraceDebugEventListener, self).__init__()

        if adaptor is None:
            adaptor = CommonTreeAdaptor()
        self.adaptor = adaptor

    def record(self, event):
        sys.stdout.write(event + '\n')

    def enterRule(self, grammarFileName, ruleName):
        self.record("enterRule "+ruleName)

    def exitRule(self, grammarFileName, ruleName):
        self.record("exitRule "+ruleName)

    def enterSubRule(self, decisionNumber):
        self.record("enterSubRule")

    def exitSubRule(self, decisionNumber):
        self.record("exitSubRule")

    def location(self, line, pos):
        self.record("location %s:%s" % (line, pos))

    ## Tree parsing stuff

    def consumeNode(self, t):
        self.record("consumeNode %s %s %s" % (
                self.adaptor.getUniqueID(t),
                self.adaptor.getText(t),
                self.adaptor.getType(t)))

    def LT(self, i, t):
        self.record("LT %s %s %s %s" % (
                i,
                self.adaptor.getUniqueID(t),
                self.adaptor.getText(t),
                self.adaptor.getType(t)))


    ## AST stuff
    def nilNode(self, t):
        self.record("nilNode %s" % self.adaptor.getUniqueID(t))

    def createNode(self, t, token=None):
        if token is None:
            self.record("create %s: %s, %s" % (
                    self.adaptor.getUniqueID(t),
                    self.adaptor.getText(t),
                    self.adaptor.getType(t)))

        else:
            self.record("create %s: %s" % (
                    self.adaptor.getUniqueID(t),
                    token.getTokenIndex()))

    def becomeRoot(self, newRoot, oldRoot):
        self.record("becomeRoot %s, %s" % (
                self.adaptor.getUniqueID(newRoot),
                self.adaptor.getUniqueID(oldRoot)))

    def addChild(self, root, child):
        self.record("addChild %s, %s" % (
                self.adaptor.getUniqueID(root),
                self.adaptor.getUniqueID(child)))

    def setTokenBoundaries(self, t, tokenStartIndex, tokenStopIndex):
        self.record("setTokenBoundaries %s, %s, %s" % (
                self.adaptor.getUniqueID(t),
                tokenStartIndex, tokenStopIndex))


class RecordDebugEventListener(TraceDebugEventListener):
    """A listener that records events as strings in an array."""

    def __init__(self, adaptor=None):
        super(RecordDebugEventListener, self).__init__(adaptor)

        self.events = []

    def record(self, event):
        self.events.append(event)


class DebugEventSocketProxy(DebugEventListener):
    """A proxy debug event listener that forwards events over a socket to
    a debugger (or any other listener) using a simple text-based protocol;
    one event per line.  ANTLRWorks listens on server socket with a
    RemoteDebugEventSocketListener instance.  These two objects must therefore
    be kept in sync.  New events must be handled on both sides of socket.
    """

    DEFAULT_DEBUGGER_PORT = 49100

    def __init__(self, recognizer, adaptor=None, port=None,
                 debug=None):
        super(DebugEventSocketProxy, self).__init__()

        self.grammarFileName = recognizer.getGrammarFileName()

	# Almost certainly the recognizer will have adaptor set, but
        # we don't know how to cast it (Parser or TreeParser) to get
        # the adaptor field.  Must be set with a constructor. :(
        self.adaptor = adaptor

        self.port = port or self.DEFAULT_DEBUGGER_PORT

        self.debug = debug

        self.socket = None
        self.connection = None
        self.input = None
        self.output = None


    def log(self, msg):
        if self.debug is not None:
            self.debug.write(msg + '\n')


    def handshake(self):
        if self.socket is None:
            # create listening socket
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind(('', self.port))
            self.socket.listen(1)
            self.log("Waiting for incoming connection on port %d" % self.port)

            # wait for an incoming connection
            self.connection, addr = self.socket.accept()
            self.log("Accepted connection from %s:%d" % addr)

            self.connection.setblocking(1)
            self.connection.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)

            # FIXME(pink): wrap into utf8 encoding stream
            self.output = self.connection.makefile('w', 0)
            self.input = self.connection.makefile('r', 0)

            self.write("ANTLR %s" % self.PROTOCOL_VERSION)
            self.write("grammar \"%s" % self.grammarFileName)
            self.ack()


    def write(self, msg):
        self.log("> %s" % msg)
        self.output.write("%s\n" % msg)
        self.output.flush()


    def ack(self):
        t = self.input.readline()
        self.log("< %s" % t.rstrip())


    def transmit(self, event):
        self.write(event);
        self.ack();


    def commence(self):
        # don't bother sending event; listener will trigger upon connection
        pass


    def terminate(self):
        self.transmit("terminate")
        self.output.close()
        self.input.close()
        self.connection.close()
        self.socket.close()


    def enterRule(self, grammarFileName, ruleName):
        self.transmit("enterRule\t%s\t%s" % (grammarFileName, ruleName))


    def enterAlt(self, alt):
        self.transmit("enterAlt\t%d" % alt)


    def exitRule(self, grammarFileName, ruleName):
        self.transmit("exitRule\t%s\t%s" % (grammarFileName, ruleName))


    def enterSubRule(self, decisionNumber):
        self.transmit("enterSubRule\t%d" % decisionNumber)


    def exitSubRule(self, decisionNumber):
        self.transmit("exitSubRule\t%d" % decisionNumber)


    def enterDecision(self, decisionNumber):
        self.transmit("enterDecision\t%d" % decisionNumber)


    def exitDecision(self, decisionNumber):
        self.transmit("exitDecision\t%d" % decisionNumber)


    def consumeToken(self, t):
        self.transmit("consumeToken\t%s" % self.serializeToken(t))


    def consumeHiddenToken(self, t):
        self.transmit("consumeHiddenToken\t%s" % self.serializeToken(t))


    def LT(self, i, o):
        if isinstance(o, Tree):
            return self.LT_tree(i, o)
        return self.LT_token(i, o)


    def LT_token(self, i, t):
        if t is not None:
            self.transmit("LT\t%d\t%s" % (i, self.serializeToken(t)))


    def mark(self, i):
        self.transmit("mark\t%d" % i)


    def rewind(self, i=None):
        if i is not None:
            self.transmit("rewind\t%d" % i)
        else:
            self.transmit("rewind")


    def beginBacktrack(self, level):
        self.transmit("beginBacktrack\t%d" % level)


    def endBacktrack(self, level, successful):
        self.transmit("endBacktrack\t%d\t%s" % (
                level, ['0', '1'][bool(successful)]))


    def location(self, line, pos):
        self.transmit("location\t%d\t%d" % (line, pos))


    def recognitionException(self, exc):
        self.transmit('\t'.join([
                    "exception",
                    exc.__class__.__name__,
                    str(int(exc.index)),
                    str(int(exc.line)),
                    str(int(exc.charPositionInLine))]))


    def beginResync(self):
        self.transmit("beginResync")


    def endResync(self):
        self.transmit("endResync")


    def semanticPredicate(self, result, predicate):
        self.transmit('\t'.join([
                    "semanticPredicate",
                    str(int(result)),
                    self.escapeNewlines(predicate)]))

    ## A S T  P a r s i n g  E v e n t s

    def consumeNode(self, t):
        FIXME(31)
#         StringBuffer buf = new StringBuffer(50);
#         buf.append("consumeNode");
#         serializeNode(buf, t);
#         transmit(buf.toString());


    def LT_tree(self, i, t):
        FIXME(34)
#         int ID = adaptor.getUniqueID(t);
#         String text = adaptor.getText(t);
#         int type = adaptor.getType(t);
#         StringBuffer buf = new StringBuffer(50);
#         buf.append("LN\t"); // lookahead node; distinguish from LT in protocol
#         buf.append(i);
#         serializeNode(buf, t);
#         transmit(buf.toString());


    def serializeNode(self, buf, t):
        FIXME(33)
#         int ID = adaptor.getUniqueID(t);
#         String text = adaptor.getText(t);
#         int type = adaptor.getType(t);
#         buf.append("\t");
#         buf.append(ID);
#         buf.append("\t");
#         buf.append(type);
#         Token token = adaptor.getToken(t);
#         int line = -1;
#         int pos = -1;
#         if ( token!=null ) {
#             line = token.getLine();
#             pos = token.getCharPositionInLine();
#             }
#         buf.append("\t");
#         buf.append(line);
#         buf.append("\t");
#         buf.append(pos);
#         int tokenIndex = adaptor.getTokenStartIndex(t);
#         buf.append("\t");
#         buf.append(tokenIndex);
#         serializeText(buf, text);

	
    ## A S T  E v e n t s

    def nilNode(self, t):
        self.transmit("nilNode\t%d" % self.adaptor.getUniqueID(t))


    def errorNode(self, t):
        self.transmit("errorNode\t%d\t%d\t\"%s" % (
             self.adaptor.getUniqueID(t),
             Token.INVALID_TOKEN_TYPE,
             self.escapeNewlines(t.toString())))



    def createNode(self, node, token=None):
        if token is not None:
            self.transmit("createNode\t%d\t%d" % (
                    self.adaptor.getUniqueID(node),
                    token.getTokenIndex()))

        else:
            self.transmit("createNodeFromTokenElements\t%d\t%d\t\"%s" % (
                    self.adaptor.getUniqueID(node),
                    self.adaptor.getType(node),
                    self.adaptor.getText(node)))


    def becomeRoot(self, newRoot, oldRoot):
        self.transmit("becomeRoot\t%d\t%d" % (
                self.adaptor.getUniqueID(newRoot),
                self.adaptor.getUniqueID(oldRoot)))


    def addChild(self, root, child):
        self.transmit("addChild\t%d\t%d" % (
                self.adaptor.getUniqueID(root),
                self.adaptor.getUniqueID(child)))


    def setTokenBoundaries(self, t, tokenStartIndex, tokenStopIndex):
        self.transmit("setTokenBoundaries\t%d\t%d\t%d" % (
                self.adaptor.getUniqueID(t),
                tokenStartIndex, tokenStopIndex))



    ## support

    def setTreeAdaptor(self, adaptor):
        self.adaptor = adaptor

    def getTreeAdaptor(self):
        return self.adaptor


    def serializeToken(self, t):
        buf = [str(int(t.getTokenIndex())),
               str(int(t.getType())),
               str(int(t.getChannel())),
               str(int(t.getLine() or 0)),
               str(int(t.getCharPositionInLine() or 0)),
               '\"' + self.escapeNewlines(t.getText())]
        return '\t'.join(buf)


    def escapeNewlines(self, txt):
        if txt is None:
            return ''

        txt = txt.replace("%","%25")   # escape all escape char ;)
        txt = txt.replace("\n","%0A")  # escape \n
        txt = txt.replace("\r","%0D")  # escape \r
        return txt

########NEW FILE########
__FILENAME__ = dfa
"""ANTLR3 runtime package"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licensc]

from .constants import EOF
from .exceptions import NoViableAltException, BacktrackingFailed


class DFA(object):
    """@brief A DFA implemented as a set of transition tables.

    Any state that has a semantic predicate edge is special; those states
    are generated with if-then-else structures in a specialStateTransition()
    which is generated by cyclicDFA template.
    
    """
    
    def __init__(
        self,
        recognizer, decisionNumber,
        eot, eof, min, max, accept, special, transition
        ):
        ## Which recognizer encloses this DFA?  Needed to check backtracking
        self.recognizer = recognizer

        self.decisionNumber = decisionNumber
        self.eot = eot
        self.eof = eof
        self.min = min
        self.max = max
        self.accept = accept
        self.special = special
        self.transition = transition


    def predict(self, input):
        """
        From the input stream, predict what alternative will succeed
	using this DFA (representing the covering regular approximation
	to the underlying CFL).  Return an alternative number 1..n.  Throw
	 an exception upon error.
	"""
        mark = input.mark()
        s = 0 # we always start at s0
        try:
            for _ in xrange(50000):
                #print "***Current state = %d" % s
                
                specialState = self.special[s]
                if specialState >= 0:
                    #print "is special"
                    s = self.specialStateTransition(specialState, input)
                    if s == -1:
                        self.noViableAlt(s, input)
                        return 0
                    input.consume()
                    continue

                if self.accept[s] >= 1:
                    #print "accept state for alt %d" % self.accept[s]
                    return self.accept[s]

                # look for a normal char transition
                c = input.LA(1)

                #print "LA = %d (%r)" % (c, unichr(c) if c >= 0 else 'EOF')
                #print "range = %d..%d" % (self.min[s], self.max[s])

                if c >= self.min[s] and c <= self.max[s]:
                    # move to next state
                    snext = self.transition[s][c-self.min[s]]
                    #print "in range, next state = %d" % snext
                    
                    if snext < 0:
                        #print "not a normal transition"
                        # was in range but not a normal transition
                        # must check EOT, which is like the else clause.
                        # eot[s]>=0 indicates that an EOT edge goes to another
                        # state.
                        if self.eot[s] >= 0: # EOT Transition to accept state?
                            #print "EOT trans to accept state %d" % self.eot[s]
                            
                            s = self.eot[s]
                            input.consume()
                            # TODO: I had this as return accept[eot[s]]
                            # which assumed here that the EOT edge always
                            # went to an accept...faster to do this, but
                            # what about predicated edges coming from EOT
                            # target?
                            continue

                        #print "no viable alt"
                        self.noViableAlt(s, input)
                        return 0

                    s = snext
                    input.consume()
                    continue

                if self.eot[s] >= 0:
                    #print "EOT to %d" % self.eot[s]
                    
                    s = self.eot[s]
                    input.consume()
                    continue

                # EOF Transition to accept state?
                if c == EOF and self.eof[s] >= 0:
                    #print "EOF Transition to accept state %d" \
                    #  % self.accept[self.eof[s]]
                    return self.accept[self.eof[s]]

                # not in range and not EOF/EOT, must be invalid symbol
                self.noViableAlt(s, input)
                return 0

            else:
                raise RuntimeError("DFA bang!")
            
        finally:
            input.rewind(mark)


    def noViableAlt(self, s, input):
        if self.recognizer._state.backtracking > 0:
            raise BacktrackingFailed

        nvae = NoViableAltException(
            self.getDescription(),
            self.decisionNumber,
            s,
            input
            )

        self.error(nvae)
        raise nvae


    def error(self, nvae):
        """A hook for debugging interface"""
        pass


    def specialStateTransition(self, s, input):
        return -1


    def getDescription(self):
        return "n/a"


##     def specialTransition(self, state, symbol):
##         return 0


    def unpack(cls, string):
        """@brief Unpack the runlength encoded table data.

        Terence implemented packed table initializers, because Java has a
        size restriction on .class files and the lookup tables can grow
        pretty large. The generated JavaLexer.java of the Java.g example
        would be about 15MB with uncompressed array initializers.

        Python does not have any size restrictions, but the compilation of
        such large source files seems to be pretty memory hungry. The memory
        consumption of the python process grew to >1.5GB when importing a
        15MB lexer, eating all my swap space and I was to impacient to see,
        if it could finish at all. With packed initializers that are unpacked
        at import time of the lexer module, everything works like a charm.
        
        """
        
        ret = []
        for i in range(len(string) / 2):
            (n, v) = ord(string[i*2]), ord(string[i*2+1])

            # Is there a bitwise operation to do this?
            if v == 0xFFFF:
                v = -1

            ret += [v] * n

        return ret
    
    unpack = classmethod(unpack)

########NEW FILE########
__FILENAME__ = dottreegen
""" @package antlr3.dottreegenerator
@brief ANTLR3 runtime package, tree module

This module contains all support classes for AST construction and tree parsers.

"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

# lot's of docstrings are missing, don't complain for now...
# pylint: disable-msg=C0111

from .tree import CommonTreeAdaptor
import stringtemplate3

class DOTTreeGenerator(object):
    """
    A utility class to generate DOT diagrams (graphviz) from
    arbitrary trees.  You can pass in your own templates and
    can pass in any kind of tree or use Tree interface method.
    """

    _treeST = stringtemplate3.StringTemplate(
        template=(
        "digraph {\n" +
        "  ordering=out;\n" +
        "  ranksep=.4;\n" +
        "  node [shape=plaintext, fixedsize=true, fontsize=11, fontname=\"Courier\",\n" +
        "        width=.25, height=.25];\n" +
        "  edge [arrowsize=.5]\n" +
        "  $nodes$\n" +
        "  $edges$\n" +
        "}\n")
        )

    _nodeST = stringtemplate3.StringTemplate(
        template="$name$ [label=\"$text$\"];\n"
        )

    _edgeST = stringtemplate3.StringTemplate(
        template="$parent$ -> $child$ // \"$parentText$\" -> \"$childText$\"\n"
        )

    def __init__(self):
        ## Track node to number mapping so we can get proper node name back
        self.nodeToNumberMap = {}

        ## Track node number so we can get unique node names
        self.nodeNumber = 0


    def toDOT(self, tree, adaptor=None, treeST=_treeST, edgeST=_edgeST):
        if adaptor is None:
            adaptor = CommonTreeAdaptor()

        treeST = treeST.getInstanceOf()

        self.nodeNumber = 0
        self.toDOTDefineNodes(tree, adaptor, treeST)

        self.nodeNumber = 0
        self.toDOTDefineEdges(tree, adaptor, treeST, edgeST)
        return treeST


    def toDOTDefineNodes(self, tree, adaptor, treeST, knownNodes=None):
        if knownNodes is None:
            knownNodes = set()

        if tree is None:
            return

        n = adaptor.getChildCount(tree)
        if n == 0:
            # must have already dumped as child from previous
            # invocation; do nothing
            return

        # define parent node
        number = self.getNodeNumber(tree)
        if number not in knownNodes:
            parentNodeST = self.getNodeST(adaptor, tree)
            treeST.setAttribute("nodes", parentNodeST)
            knownNodes.add(number)

        # for each child, do a "<unique-name> [label=text]" node def
        for i in range(n):
            child = adaptor.getChild(tree, i)
            
            number = self.getNodeNumber(child)
            if number not in knownNodes:
                nodeST = self.getNodeST(adaptor, child)
                treeST.setAttribute("nodes", nodeST)
                knownNodes.add(number)

            self.toDOTDefineNodes(child, adaptor, treeST, knownNodes)


    def toDOTDefineEdges(self, tree, adaptor, treeST, edgeST):
        if tree is None:
            return

        n = adaptor.getChildCount(tree)
        if n == 0:
            # must have already dumped as child from previous
            # invocation; do nothing
            return

        parentName = "n%d" % self.getNodeNumber(tree)

        # for each child, do a parent -> child edge using unique node names
        parentText = adaptor.getText(tree)
        for i in range(n):
            child = adaptor.getChild(tree, i)
            childText = adaptor.getText(child)
            childName = "n%d" % self.getNodeNumber(child)
            edgeST = edgeST.getInstanceOf()
            edgeST.setAttribute("parent", parentName)
            edgeST.setAttribute("child", childName)
            edgeST.setAttribute("parentText", parentText)
            edgeST.setAttribute("childText", childText)
            treeST.setAttribute("edges", edgeST)
            self.toDOTDefineEdges(child, adaptor, treeST, edgeST)


    def getNodeST(self, adaptor, t):
        text = adaptor.getText(t)
        nodeST = self._nodeST.getInstanceOf()
        uniqueName = "n%d" % self.getNodeNumber(t)
        nodeST.setAttribute("name", uniqueName)
        if text is not None:
            text = text.replace('"', r'\\"')
        nodeST.setAttribute("text", text)
        return nodeST


    def getNodeNumber(self, t):
        try:
            return self.nodeToNumberMap[t]
        except KeyError:
            self.nodeToNumberMap[t] = self.nodeNumber
            self.nodeNumber += 1
            return self.nodeNumber - 1


def toDOT(tree, adaptor=None, treeST=DOTTreeGenerator._treeST, edgeST=DOTTreeGenerator._edgeST):
    """
    Generate DOT (graphviz) for a whole tree not just a node.
    For example, 3+4*5 should generate:

    digraph {
        node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
            width=.4, height=.2];
        edge [arrowsize=.7]
        "+"->3
        "+"->"*"
        "*"->4
        "*"->5
    }

    Return the ST not a string in case people want to alter.

    Takes a Tree interface object.

    Example of invokation:

        import antlr3
        import antlr3.extras

        input = antlr3.ANTLRInputStream(sys.stdin)
        lex = TLexer(input)
        tokens = antlr3.CommonTokenStream(lex)
        parser = TParser(tokens)
        tree = parser.e().tree
        print tree.toStringTree()
        st = antlr3.extras.toDOT(t)
        print st
        
    """

    gen = DOTTreeGenerator()
    return gen.toDOT(tree, adaptor, treeST, edgeST)

########NEW FILE########
__FILENAME__ = exceptions
"""ANTLR3 exception hierarchy"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

from .constants import INVALID_TOKEN_TYPE


class BacktrackingFailed(Exception):
    """@brief Raised to signal failed backtrack attempt"""

    pass


class RecognitionException(Exception):
    """@brief The root of the ANTLR exception hierarchy.

    To avoid English-only error messages and to generally make things
    as flexible as possible, these exceptions are not created with strings,
    but rather the information necessary to generate an error.  Then
    the various reporting methods in Parser and Lexer can be overridden
    to generate a localized error message.  For example, MismatchedToken
    exceptions are built with the expected token type.
    So, don't expect getMessage() to return anything.

    Note that as of Java 1.4, you can access the stack trace, which means
    that you can compute the complete trace of rules from the start symbol.
    This gives you considerable context information with which to generate
    useful error messages.

    ANTLR generates code that throws exceptions upon recognition error and
    also generates code to catch these exceptions in each rule.  If you
    want to quit upon first error, you can turn off the automatic error
    handling mechanism using rulecatch action, but you still need to
    override methods mismatch and recoverFromMismatchSet.
    
    In general, the recognition exceptions can track where in a grammar a
    problem occurred and/or what was the expected input.  While the parser
    knows its state (such as current input symbol and line info) that
    state can change before the exception is reported so current token index
    is computed and stored at exception time.  From this info, you can
    perhaps print an entire line of input not just a single token, for example.
    Better to just say the recognizer had a problem and then let the parser
    figure out a fancy report.
    
    """

    def __init__(self, input=None):
        Exception.__init__(self)

	# What input stream did the error occur in?
        self.input = None

        # What is index of token/char were we looking at when the error
        # occurred?
        self.index = None

	# The current Token when an error occurred.  Since not all streams
	# can retrieve the ith Token, we have to track the Token object.
	# For parsers.  Even when it's a tree parser, token might be set.
        self.token = None

	# If this is a tree parser exception, node is set to the node with
	# the problem.
        self.node = None

	# The current char when an error occurred. For lexers.
        self.c = None

	# Track the line at which the error occurred in case this is
	# generated from a lexer.  We need to track this since the
        # unexpected char doesn't carry the line info.
        self.line = None

        self.charPositionInLine = None

        # If you are parsing a tree node stream, you will encounter som
        # imaginary nodes w/o line/col info.  We now search backwards looking
        # for most recent token with line/col info, but notify getErrorHeader()
        # that info is approximate.
        self.approximateLineInfo = False

        
        if input is not None:
            self.input = input
            self.index = input.index()

            # late import to avoid cyclic dependencies
            from antlr3.streams import TokenStream, CharStream
            from antlr3.tree import TreeNodeStream

            if isinstance(self.input, TokenStream):
                self.token = self.input.LT(1)
                self.line = self.token.line
                self.charPositionInLine = self.token.charPositionInLine

            if isinstance(self.input, TreeNodeStream):
                self.extractInformationFromTreeNodeStream(self.input)

            else:
                if isinstance(self.input, CharStream):
                    self.c = self.input.LT(1)
                    self.line = self.input.line
                    self.charPositionInLine = self.input.charPositionInLine

                else:
                    self.c = self.input.LA(1)

    def extractInformationFromTreeNodeStream(self, nodes):
        from .tree import Tree, CommonTree
        from .tokens import CommonToken

        self.node = nodes.LT(1)
        adaptor = nodes.adaptor
        payload = adaptor.getToken(self.node)
        if payload is not None:
            self.token = payload
            if payload.line <= 0:
                # imaginary node; no line/pos info; scan backwards
                i = -1
                priorNode = nodes.LT(i)
                while priorNode is not None:
                    priorPayload = adaptor.getToken(priorNode)
                    if priorPayload is not None and priorPayload.line > 0:
                        # we found the most recent real line / pos info
                        self.line = priorPayload.line
                        self.charPositionInLine = priorPayload.charPositionInLine
                        self.approximateLineInfo = True
                        break
                    
                    i -= 1
                    priorNode = nodes.LT(i)
                    
            else: # node created from real token
                self.line = payload.line
                self.charPositionInLine = payload.charPositionInLine
                
        elif isinstance(self.node, Tree):
            self.line = self.node.line
            self.charPositionInLine = self.node.charPositionInLine
            if isinstance(self.node, CommonTree):
                self.token = self.node.token

        else:
            type = adaptor.getType(self.node)
            text = adaptor.getText(self.node)
            self.token = CommonToken(type=type, text=text)

     
    def getUnexpectedType(self):
        """Return the token type or char of the unexpected input element"""

        from .streams import TokenStream
        from .tree import TreeNodeStream

        if isinstance(self.input, TokenStream):
            return self.token.type

        elif isinstance(self.input, TreeNodeStream):
            adaptor = self.input.treeAdaptor
            return adaptor.getType(self.node)

        else:
            return self.c

    unexpectedType = property(getUnexpectedType)
    

class MismatchedTokenException(RecognitionException):
    """@brief A mismatched char or Token or tree node."""
    
    def __init__(self, expecting, input):
        RecognitionException.__init__(self, input)
        self.expecting = expecting
        

    def __str__(self):
        #return "MismatchedTokenException("+self.expecting+")"
        return "MismatchedTokenException(%r!=%r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__


class UnwantedTokenException(MismatchedTokenException):
    """An extra token while parsing a TokenStream"""

    def getUnexpectedToken(self):
        return self.token


    def __str__(self):
        exp = ", expected %s" % self.expecting
        if self.expecting == INVALID_TOKEN_TYPE:
            exp = ""

        if self.token is None:
            return "UnwantedTokenException(found=%s%s)" % (None, exp)

        return "UnwantedTokenException(found=%s%s)" % (self.token.text, exp)
    __repr__ = __str__


class MissingTokenException(MismatchedTokenException):
    """
    We were expecting a token but it's not found.  The current token
    is actually what we wanted next.
    """

    def __init__(self, expecting, input, inserted):
        MismatchedTokenException.__init__(self, expecting, input)

        self.inserted = inserted


    def getMissingType(self):
        return self.expecting


    def __str__(self):
        if self.inserted is not None and self.token is not None:
            return "MissingTokenException(inserted %r at %r)" % (
                self.inserted, self.token.text)

        if self.token is not None:
            return "MissingTokenException(at %r)" % self.token.text

        return "MissingTokenException"
    __repr__ = __str__


class MismatchedRangeException(RecognitionException):
    """@brief The next token does not match a range of expected types."""

    def __init__(self, a, b, input):
        RecognitionException.__init__(self, input)

        self.a = a
        self.b = b
        

    def __str__(self):
        return "MismatchedRangeException(%r not in [%r..%r])" % (
            self.getUnexpectedType(), self.a, self.b
            )
    __repr__ = __str__
    

class MismatchedSetException(RecognitionException):
    """@brief The next token does not match a set of expected types."""

    def __init__(self, expecting, input):
        RecognitionException.__init__(self, input)

        self.expecting = expecting
        

    def __str__(self):
        return "MismatchedSetException(%r not in %r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__


class MismatchedNotSetException(MismatchedSetException):
    """@brief Used for remote debugger deserialization"""
    
    def __str__(self):
        return "MismatchedNotSetException(%r!=%r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__


class NoViableAltException(RecognitionException):
    """@brief Unable to decide which alternative to choose."""

    def __init__(
        self, grammarDecisionDescription, decisionNumber, stateNumber, input
        ):
        RecognitionException.__init__(self, input)

        self.grammarDecisionDescription = grammarDecisionDescription
        self.decisionNumber = decisionNumber
        self.stateNumber = stateNumber


    def __str__(self):
        return "NoViableAltException(%r!=[%r])" % (
            self.unexpectedType, self.grammarDecisionDescription
            )
    __repr__ = __str__
    

class EarlyExitException(RecognitionException):
    """@brief The recognizer did not match anything for a (..)+ loop."""

    def __init__(self, decisionNumber, input):
        RecognitionException.__init__(self, input)

        self.decisionNumber = decisionNumber


class FailedPredicateException(RecognitionException):
    """@brief A semantic predicate failed during validation.

    Validation of predicates
    occurs when normally parsing the alternative just like matching a token.
    Disambiguating predicate evaluation occurs when we hoist a predicate into
    a prediction decision.
    """

    def __init__(self, input, ruleName, predicateText):
        RecognitionException.__init__(self, input)
        
        self.ruleName = ruleName
        self.predicateText = predicateText


    def __str__(self):
        return "FailedPredicateException("+self.ruleName+",{"+self.predicateText+"}?)"
    __repr__ = __str__
    

class MismatchedTreeNodeException(RecognitionException):
    """@brief The next tree mode does not match the expected type."""

    def __init__(self, expecting, input):
        RecognitionException.__init__(self, input)
        
        self.expecting = expecting

    def __str__(self):
        return "MismatchedTreeNodeException(%r!=%r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__

########NEW FILE########
__FILENAME__ = extras
""" @package antlr3.dottreegenerator
@brief ANTLR3 runtime package, tree module

This module contains all support classes for AST construction and tree parsers.

"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

# lot's of docstrings are missing, don't complain for now...
# pylint: disable-msg=C0111

from treewizard import TreeWizard

try:
    from .dottreegen import toDOT
except ImportError, exc:
    def toDOT(*args, **kwargs):
        raise exc

########NEW FILE########
__FILENAME__ = main
"""ANTLR3 runtime package"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]


import sys
import optparse

import antlr3


class _Main(object):
    def __init__(self):
        self.stdin = sys.stdin
        self.stdout = sys.stdout
        self.stderr = sys.stderr

        
    def parseOptions(self, argv):
        optParser = optparse.OptionParser()
        optParser.add_option(
            "--encoding",
            action="store",
            type="string",
            dest="encoding"
            )
        optParser.add_option(
            "--input",
            action="store",
            type="string",
            dest="input"
            )
        optParser.add_option(
            "--interactive", "-i",
            action="store_true",
            dest="interactive"
            )
        optParser.add_option(
            "--no-output",
            action="store_true",
            dest="no_output"
            )
        optParser.add_option(
            "--profile",
            action="store_true",
            dest="profile"
            )
        optParser.add_option(
            "--hotshot",
            action="store_true",
            dest="hotshot"
            )
        optParser.add_option(
            "--port",
            type="int",
            dest="port",
            default=None
            )
        optParser.add_option(
            "--debug-socket",
            action='store_true',
            dest="debug_socket",
            default=None
            )

        self.setupOptions(optParser)
        
        return optParser.parse_args(argv[1:])


    def setupOptions(self, optParser):
        pass


    def execute(self, argv):
        options, args = self.parseOptions(argv)

        self.setUp(options)
        
        if options.interactive:
            while True:
                try:
                    input = raw_input(">>> ")
                except (EOFError, KeyboardInterrupt):
                    self.stdout.write("\nBye.\n")
                    break
            
                inStream = antlr3.ANTLRStringStream(input)
                self.parseStream(options, inStream)
            
        else:
            if options.input is not None:
                inStream = antlr3.ANTLRStringStream(options.input)

            elif len(args) == 1 and args[0] != '-':
                inStream = antlr3.ANTLRFileStream(
                    args[0], encoding=options.encoding
                    )

            else:
                inStream = antlr3.ANTLRInputStream(
                    self.stdin, encoding=options.encoding
                    )

            if options.profile:
                try:
                    import cProfile as profile
                except ImportError:
                    import profile

                profile.runctx(
                    'self.parseStream(options, inStream)',
                    globals(),
                    locals(),
                    'profile.dat'
                    )

                import pstats
                stats = pstats.Stats('profile.dat')
                stats.strip_dirs()
                stats.sort_stats('time')
                stats.print_stats(100)

            elif options.hotshot:
                import hotshot

                profiler = hotshot.Profile('hotshot.dat')
                profiler.runctx(
                    'self.parseStream(options, inStream)',
                    globals(),
                    locals()
                    )

            else:
                self.parseStream(options, inStream)


    def setUp(self, options):
        pass

    
    def parseStream(self, options, inStream):
        raise NotImplementedError


    def write(self, options, text):
        if not options.no_output:
            self.stdout.write(text)


    def writeln(self, options, text):
        self.write(options, text + '\n')


class LexerMain(_Main):
    def __init__(self, lexerClass):
        _Main.__init__(self)

        self.lexerClass = lexerClass
        
    
    def parseStream(self, options, inStream):
        lexer = self.lexerClass(inStream)
        for token in lexer:
            self.writeln(options, str(token))


class ParserMain(_Main):
    def __init__(self, lexerClassName, parserClass):
        _Main.__init__(self)

        self.lexerClassName = lexerClassName
        self.lexerClass = None
        self.parserClass = parserClass
        
    
    def setupOptions(self, optParser):
        optParser.add_option(
            "--lexer",
            action="store",
            type="string",
            dest="lexerClass",
            default=self.lexerClassName
            )
        optParser.add_option(
            "--rule",
            action="store",
            type="string",
            dest="parserRule"
            )


    def setUp(self, options):
        lexerMod = __import__(options.lexerClass)
        self.lexerClass = getattr(lexerMod, options.lexerClass)

        
    def parseStream(self, options, inStream):
        kwargs = {}
        if options.port is not None:
            kwargs['port'] = options.port
        if options.debug_socket is not None:
            kwargs['debug_socket'] = sys.stderr

        lexer = self.lexerClass(inStream)
        tokenStream = antlr3.CommonTokenStream(lexer)
        parser = self.parserClass(tokenStream, **kwargs)
        result = getattr(parser, options.parserRule)()
        if result is not None:
            if hasattr(result, 'tree'):
                if result.tree is not None:
                    self.writeln(options, result.tree.toStringTree())
            else:
                self.writeln(options, repr(result))


class WalkerMain(_Main):
    def __init__(self, walkerClass):
        _Main.__init__(self)

        self.lexerClass = None
        self.parserClass = None
        self.walkerClass = walkerClass
        
    
    def setupOptions(self, optParser):
        optParser.add_option(
            "--lexer",
            action="store",
            type="string",
            dest="lexerClass",
            default=None
            )
        optParser.add_option(
            "--parser",
            action="store",
            type="string",
            dest="parserClass",
            default=None
            )
        optParser.add_option(
            "--parser-rule",
            action="store",
            type="string",
            dest="parserRule",
            default=None
            )
        optParser.add_option(
            "--rule",
            action="store",
            type="string",
            dest="walkerRule"
            )


    def setUp(self, options):
        lexerMod = __import__(options.lexerClass)
        self.lexerClass = getattr(lexerMod, options.lexerClass)
        parserMod = __import__(options.parserClass)
        self.parserClass = getattr(parserMod, options.parserClass)

        
    def parseStream(self, options, inStream):
        lexer = self.lexerClass(inStream)
        tokenStream = antlr3.CommonTokenStream(lexer)
        parser = self.parserClass(tokenStream)
        result = getattr(parser, options.parserRule)()
        if result is not None:
            assert hasattr(result, 'tree'), "Parser did not return an AST"
            nodeStream = antlr3.tree.CommonTreeNodeStream(result.tree)
            nodeStream.setTokenStream(tokenStream)
            walker = self.walkerClass(nodeStream)
            result = getattr(walker, options.walkerRule)()
            if result is not None:
                if hasattr(result, 'tree'):
                    self.writeln(options, result.tree.toStringTree())
                else:
                    self.writeln(options, repr(result))


########NEW FILE########
__FILENAME__ = recognizers
"""ANTLR3 runtime package"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

import sys
import inspect

from . import runtime_version, runtime_version_str
from .constants import DEFAULT_CHANNEL, HIDDEN_CHANNEL, EOF, \
     EOR_TOKEN_TYPE, INVALID_TOKEN_TYPE
from .exceptions import RecognitionException, MismatchedTokenException, \
     MismatchedRangeException, MismatchedTreeNodeException, \
     NoViableAltException, EarlyExitException, MismatchedSetException, \
     MismatchedNotSetException, FailedPredicateException, \
     BacktrackingFailed, UnwantedTokenException, MissingTokenException
from .tokens import CommonToken, EOF_TOKEN, SKIP_TOKEN
from .compat import set, frozenset, reversed


class RecognizerSharedState(object):
    """
    The set of fields needed by an abstract recognizer to recognize input
    and recover from errors etc...  As a separate state object, it can be
    shared among multiple grammars; e.g., when one grammar imports another.

    These fields are publically visible but the actual state pointer per
    parser is protected.
    """

    def __init__(self):
        # Track the set of token types that can follow any rule invocation.
        # Stack grows upwards.
        self.following = []

        # This is true when we see an error and before having successfully
        # matched a token.  Prevents generation of more than one error message
        # per error.
        self.errorRecovery = False

        # The index into the input stream where the last error occurred.
        # This is used to prevent infinite loops where an error is found
        # but no token is consumed during recovery...another error is found,
        # ad naseum.  This is a failsafe mechanism to guarantee that at least
        # one token/tree node is consumed for two errors.
        self.lastErrorIndex = -1

        # If 0, no backtracking is going on.  Safe to exec actions etc...
        # If >0 then it's the level of backtracking.
        self.backtracking = 0

        # An array[size num rules] of Map<Integer,Integer> that tracks
        # the stop token index for each rule.  ruleMemo[ruleIndex] is
        # the memoization table for ruleIndex.  For key ruleStartIndex, you
        # get back the stop token for associated rule or MEMO_RULE_FAILED.
        #
        # This is only used if rule memoization is on (which it is by default).
        self.ruleMemo = None

        ## Did the recognizer encounter a syntax error?  Track how many.
        self.syntaxErrors = 0


        # LEXER FIELDS (must be in same state object to avoid casting
        # constantly in generated code and Lexer object) :(


	## The goal of all lexer rules/methods is to create a token object.
        # This is an instance variable as multiple rules may collaborate to
        # create a single token.  nextToken will return this object after
        # matching lexer rule(s).  If you subclass to allow multiple token
        # emissions, then set this to the last token to be matched or
        # something nonnull so that the auto token emit mechanism will not
        # emit another token.
        self.token = None

        ## What character index in the stream did the current token start at?
        # Needed, for example, to get the text for current token.  Set at
        # the start of nextToken.
        self.tokenStartCharIndex = -1

        ## The line on which the first character of the token resides
        self.tokenStartLine = None

        ## The character position of first character within the line
        self.tokenStartCharPositionInLine = None

        ## The channel number for the current token
        self.channel = None

        ## The token type for the current token
        self.type = None

        ## You can set the text for the current token to override what is in
        # the input char buffer.  Use setText() or can set this instance var.
        self.text = None
        

class BaseRecognizer(object):
    """
    @brief Common recognizer functionality.
    
    A generic recognizer that can handle recognizers generated from
    lexer, parser, and tree grammars.  This is all the parsing
    support code essentially; most of it is error recovery stuff and
    backtracking.
    """

    MEMO_RULE_FAILED = -2
    MEMO_RULE_UNKNOWN = -1

    # copies from Token object for convenience in actions
    DEFAULT_TOKEN_CHANNEL = DEFAULT_CHANNEL

    # for convenience in actions
    HIDDEN = HIDDEN_CHANNEL

    # overridden by generated subclasses
    tokenNames = None

    # The antlr_version attribute has been introduced in 3.1. If it is not
    # overwritten in the generated recognizer, we assume a default of 3.0.1.
    antlr_version = (3, 0, 1, 0)
    antlr_version_str = "3.0.1"

    def __init__(self, state=None):
        # Input stream of the recognizer. Must be initialized by a subclass.
        self.input = None

        ## State of a lexer, parser, or tree parser are collected into a state
        # object so the state can be shared.  This sharing is needed to
        # have one grammar import others and share same error variables
        # and other state variables.  It's a kind of explicit multiple
        # inheritance via delegation of methods and shared state.
        if state is None:
            state = RecognizerSharedState()
        self._state = state

        if self.antlr_version > runtime_version:
            raise RuntimeError(
                "ANTLR version mismatch: "
                "The recognizer has been generated by V%s, but this runtime "
                "is V%s. Please use the V%s runtime or higher."
                % (self.antlr_version_str,
                   runtime_version_str,
                   self.antlr_version_str))
        elif (self.antlr_version < (3, 1, 0, 0) and
              self.antlr_version != runtime_version):
            # FIXME: make the runtime compatible with 3.0.1 codegen
            # and remove this block.
            raise RuntimeError(
                "ANTLR version mismatch: "
                "The recognizer has been generated by V%s, but this runtime "
                "is V%s. Please use the V%s runtime."
                % (self.antlr_version_str,
                   runtime_version_str,
                   self.antlr_version_str))

    # this one only exists to shut up pylint :(
    def setInput(self, input):
        self.input = input

        
    def reset(self):
        """
        reset the parser's state; subclasses must rewinds the input stream
        """
        
        # wack everything related to error recovery
        if self._state is None:
            # no shared state work to do
            return
        
        self._state.following = []
        self._state.errorRecovery = False
        self._state.lastErrorIndex = -1
        self._state.syntaxErrors = 0
        # wack everything related to backtracking and memoization
        self._state.backtracking = 0
        if self._state.ruleMemo is not None:
            self._state.ruleMemo = {}


    def match(self, input, ttype, follow):
        """
        Match current input symbol against ttype.  Attempt
        single token insertion or deletion error recovery.  If
        that fails, throw MismatchedTokenException.

        To turn off single token insertion or deletion error
        recovery, override recoverFromMismatchedToken() and have it
        throw an exception. See TreeParser.recoverFromMismatchedToken().
        This way any error in a rule will cause an exception and
        immediate exit from rule.  Rule would recover by resynchronizing
        to the set of symbols that can follow rule ref.
        """
        
        matchedSymbol = self.getCurrentInputSymbol(input)
        if self.input.LA(1) == ttype:
            self.input.consume()
            self._state.errorRecovery = False
            return matchedSymbol

        if self._state.backtracking > 0:
            # FIXME: need to return matchedSymbol here as well. damn!!
            raise BacktrackingFailed

        matchedSymbol = self.recoverFromMismatchedToken(input, ttype, follow)
        return matchedSymbol


    def matchAny(self, input):
        """Match the wildcard: in a symbol"""

        self._state.errorRecovery = False
        self.input.consume()


    def mismatchIsUnwantedToken(self, input, ttype):
        return input.LA(2) == ttype


    def mismatchIsMissingToken(self, input, follow):
        if follow is None:
            # we have no information about the follow; we can only consume
            # a single token and hope for the best
            return False
        
        # compute what can follow this grammar element reference
        if EOR_TOKEN_TYPE in follow:
            viableTokensFollowingThisRule = self.computeContextSensitiveRuleFOLLOW()
            follow = follow | viableTokensFollowingThisRule

            if len(self._state.following) > 0:
                # remove EOR if we're not the start symbol
                follow = follow - set([EOR_TOKEN_TYPE])

        # if current token is consistent with what could come after set
        # then we know we're missing a token; error recovery is free to
        # "insert" the missing token
        if input.LA(1) in follow or EOR_TOKEN_TYPE in follow:
            return True

        return False


    def reportError(self, e):
        """Report a recognition problem.
            
        This method sets errorRecovery to indicate the parser is recovering
        not parsing.  Once in recovery mode, no errors are generated.
        To get out of recovery mode, the parser must successfully match
        a token (after a resync).  So it will go:

        1. error occurs
        2. enter recovery mode, report error
        3. consume until token found in resynch set
        4. try to resume parsing
        5. next match() will reset errorRecovery mode

        If you override, make sure to update syntaxErrors if you care about
        that.
        
        """
        
        # if we've already reported an error and have not matched a token
        # yet successfully, don't report any errors.
        if self._state.errorRecovery:
            return

        self._state.syntaxErrors += 1 # don't count spurious
        self._state.errorRecovery = True

        self.displayRecognitionError(self.tokenNames, e)


    def displayRecognitionError(self, tokenNames, e):
        hdr = self.getErrorHeader(e)
        msg = self.getErrorMessage(e, tokenNames)
        self.emitErrorMessage(hdr+" "+msg)


    def getErrorMessage(self, e, tokenNames):
        """
        What error message should be generated for the various
        exception types?
        
        Not very object-oriented code, but I like having all error message
        generation within one method rather than spread among all of the
        exception classes. This also makes it much easier for the exception
        handling because the exception classes do not have to have pointers back
        to this object to access utility routines and so on. Also, changing
        the message for an exception type would be difficult because you
        would have to subclassing exception, but then somehow get ANTLR
        to make those kinds of exception objects instead of the default.
        This looks weird, but trust me--it makes the most sense in terms
        of flexibility.

        For grammar debugging, you will want to override this to add
        more information such as the stack frame with
        getRuleInvocationStack(e, this.getClass().getName()) and,
        for no viable alts, the decision description and state etc...

        Override this to change the message generated for one or more
        exception types.
        """

        if isinstance(e, UnwantedTokenException):
            tokenName = "<unknown>"
            if e.expecting == EOF:
                tokenName = "EOF"

            else:
                tokenName = self.tokenNames[e.expecting]

            msg = "extraneous input %s expecting %s" % (
                self.getTokenErrorDisplay(e.getUnexpectedToken()),
                tokenName
                )

        elif isinstance(e, MissingTokenException):
            tokenName = "<unknown>"
            if e.expecting == EOF:
                tokenName = "EOF"

            else:
                tokenName = self.tokenNames[e.expecting]

            msg = "missing %s at %s" % (
                tokenName, self.getTokenErrorDisplay(e.token)
                )

        elif isinstance(e, MismatchedTokenException):
            tokenName = "<unknown>"
            if e.expecting == EOF:
                tokenName = "EOF"
            else:
                tokenName = self.tokenNames[e.expecting]

            msg = "mismatched input " \
                  + self.getTokenErrorDisplay(e.token) \
                  + " expecting " \
                  + tokenName

        elif isinstance(e, MismatchedTreeNodeException):
            tokenName = "<unknown>"
            if e.expecting == EOF:
                tokenName = "EOF"
            else:
                tokenName = self.tokenNames[e.expecting]

            msg = "mismatched tree node: %s expecting %s" \
                  % (e.node, tokenName)

        elif isinstance(e, NoViableAltException):
            msg = "no viable alternative at input " \
                  + self.getTokenErrorDisplay(e.token)

        elif isinstance(e, EarlyExitException):
            msg = "required (...)+ loop did not match anything at input " \
                  + self.getTokenErrorDisplay(e.token)

        elif isinstance(e, MismatchedSetException):
            msg = "mismatched input " \
                  + self.getTokenErrorDisplay(e.token) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, MismatchedNotSetException):
            msg = "mismatched input " \
                  + self.getTokenErrorDisplay(e.token) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, FailedPredicateException):
            msg = "rule " \
                  + e.ruleName \
                  + " failed predicate: {" \
                  + e.predicateText \
                  + "}?"

        else:
            msg = str(e)

        return msg
    

    def getNumberOfSyntaxErrors(self):
        """
        Get number of recognition errors (lexer, parser, tree parser).  Each
        recognizer tracks its own number.  So parser and lexer each have
        separate count.  Does not count the spurious errors found between
        an error and next valid token match

        See also reportError()
	"""
        return self._state.syntaxErrors


    def getErrorHeader(self, e):
        """
        What is the error header, normally line/character position information?
        """
        
        return "line %d:%d" % (e.line, e.charPositionInLine)


    def getTokenErrorDisplay(self, t):
        """
        How should a token be displayed in an error message? The default
        is to display just the text, but during development you might
        want to have a lot of information spit out.  Override in that case
        to use t.toString() (which, for CommonToken, dumps everything about
        the token). This is better than forcing you to override a method in
        your token objects because you don't have to go modify your lexer
        so that it creates a new Java type.
        """
        
        s = t.text
        if s is None:
            if t.type == EOF:
                s = "<EOF>"
            else:
                s = "<"+t.type+">"

        return repr(s)
    

    def emitErrorMessage(self, msg):
        """Override this method to change where error messages go"""
        sys.stderr.write(msg + '\n')


    def recover(self, input, re):
        """
        Recover from an error found on the input stream.  This is
        for NoViableAlt and mismatched symbol exceptions.  If you enable
        single token insertion and deletion, this will usually not
        handle mismatched symbol exceptions but there could be a mismatched
        token that the match() routine could not recover from.
        """
        
        # PROBLEM? what if input stream is not the same as last time
        # perhaps make lastErrorIndex a member of input
        if self._state.lastErrorIndex == input.index():
            # uh oh, another error at same token index; must be a case
            # where LT(1) is in the recovery token set so nothing is
            # consumed; consume a single token so at least to prevent
            # an infinite loop; this is a failsafe.
            input.consume()

        self._state.lastErrorIndex = input.index()
        followSet = self.computeErrorRecoverySet()
        
        self.beginResync()
        self.consumeUntil(input, followSet)
        self.endResync()


    def beginResync(self):
        """
        A hook to listen in on the token consumption during error recovery.
        The DebugParser subclasses this to fire events to the listenter.
        """

        pass


    def endResync(self):
        """
        A hook to listen in on the token consumption during error recovery.
        The DebugParser subclasses this to fire events to the listenter.
        """

        pass


    def computeErrorRecoverySet(self):
        """
        Compute the error recovery set for the current rule.  During
        rule invocation, the parser pushes the set of tokens that can
        follow that rule reference on the stack; this amounts to
        computing FIRST of what follows the rule reference in the
        enclosing rule. This local follow set only includes tokens
        from within the rule; i.e., the FIRST computation done by
        ANTLR stops at the end of a rule.

        EXAMPLE

        When you find a "no viable alt exception", the input is not
        consistent with any of the alternatives for rule r.  The best
        thing to do is to consume tokens until you see something that
        can legally follow a call to r *or* any rule that called r.
        You don't want the exact set of viable next tokens because the
        input might just be missing a token--you might consume the
        rest of the input looking for one of the missing tokens.

        Consider grammar:

        a : '[' b ']'
          | '(' b ')'
          ;
        b : c '^' INT ;
        c : ID
          | INT
          ;

        At each rule invocation, the set of tokens that could follow
        that rule is pushed on a stack.  Here are the various "local"
        follow sets:

        FOLLOW(b1_in_a) = FIRST(']') = ']'
        FOLLOW(b2_in_a) = FIRST(')') = ')'
        FOLLOW(c_in_b) = FIRST('^') = '^'

        Upon erroneous input "[]", the call chain is

        a -> b -> c

        and, hence, the follow context stack is:

        depth  local follow set     after call to rule
          0         \<EOF>                    a (from main())
          1          ']'                     b
          3          '^'                     c

        Notice that ')' is not included, because b would have to have
        been called from a different context in rule a for ')' to be
        included.

        For error recovery, we cannot consider FOLLOW(c)
        (context-sensitive or otherwise).  We need the combined set of
        all context-sensitive FOLLOW sets--the set of all tokens that
        could follow any reference in the call chain.  We need to
        resync to one of those tokens.  Note that FOLLOW(c)='^' and if
        we resync'd to that token, we'd consume until EOF.  We need to
        sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
        In this case, for input "[]", LA(1) is in this set so we would
        not consume anything and after printing an error rule c would
        return normally.  It would not find the required '^' though.
        At this point, it gets a mismatched token error and throws an
        exception (since LA(1) is not in the viable following token
        set).  The rule exception handler tries to recover, but finds
        the same recovery set and doesn't consume anything.  Rule b
        exits normally returning to rule a.  Now it finds the ']' (and
        with the successful match exits errorRecovery mode).

        So, you cna see that the parser walks up call chain looking
        for the token that was a member of the recovery set.

        Errors are not generated in errorRecovery mode.

        ANTLR's error recovery mechanism is based upon original ideas:

        "Algorithms + Data Structures = Programs" by Niklaus Wirth

        and

        "A note on error recovery in recursive descent parsers":
        http://portal.acm.org/citation.cfm?id=947902.947905

        Later, Josef Grosch had some good ideas:

        "Efficient and Comfortable Error Recovery in Recursive Descent
        Parsers":
        ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip

        Like Grosch I implemented local FOLLOW sets that are combined
        at run-time upon error to avoid overhead during parsing.
        """
        
        return self.combineFollows(False)

        
    def computeContextSensitiveRuleFOLLOW(self):
        """
        Compute the context-sensitive FOLLOW set for current rule.
        This is set of token types that can follow a specific rule
        reference given a specific call chain.  You get the set of
        viable tokens that can possibly come next (lookahead depth 1)
        given the current call chain.  Contrast this with the
        definition of plain FOLLOW for rule r:

         FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}

        where x in T* and alpha, beta in V*; T is set of terminals and
        V is the set of terminals and nonterminals.  In other words,
        FOLLOW(r) is the set of all tokens that can possibly follow
        references to r in *any* sentential form (context).  At
        runtime, however, we know precisely which context applies as
        we have the call chain.  We may compute the exact (rather
        than covering superset) set of following tokens.

        For example, consider grammar:

        stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
             | "return" expr '.'
             ;
        expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
        atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
             | '(' expr ')'
             ;

        The FOLLOW sets are all inclusive whereas context-sensitive
        FOLLOW sets are precisely what could follow a rule reference.
        For input input "i=(3);", here is the derivation:

        stat => ID '=' expr ';'
             => ID '=' atom ('+' atom)* ';'
             => ID '=' '(' expr ')' ('+' atom)* ';'
             => ID '=' '(' atom ')' ('+' atom)* ';'
             => ID '=' '(' INT ')' ('+' atom)* ';'
             => ID '=' '(' INT ')' ';'

        At the "3" token, you'd have a call chain of

          stat -> expr -> atom -> expr -> atom

        What can follow that specific nested ref to atom?  Exactly ')'
        as you can see by looking at the derivation of this specific
        input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.

        You want the exact viable token set when recovering from a
        token mismatch.  Upon token mismatch, if LA(1) is member of
        the viable next token set, then you know there is most likely
        a missing token in the input stream.  "Insert" one by just not
        throwing an exception.
        """

        return self.combineFollows(True)


    def combineFollows(self, exact):
        followSet = set()
        for idx, localFollowSet in reversed(list(enumerate(self._state.following))):
            followSet |= localFollowSet
            if exact:
                # can we see end of rule?
                if EOR_TOKEN_TYPE in localFollowSet:
                    # Only leave EOR in set if at top (start rule); this lets
                    # us know if have to include follow(start rule); i.e., EOF
                    if idx > 0:
                        followSet.remove(EOR_TOKEN_TYPE)
                        
                else:
                    # can't see end of rule, quit
                    break

        return followSet


    def recoverFromMismatchedToken(self, input, ttype, follow):
        """Attempt to recover from a single missing or extra token.

        EXTRA TOKEN

        LA(1) is not what we are looking for.  If LA(2) has the right token,
        however, then assume LA(1) is some extra spurious token.  Delete it
        and LA(2) as if we were doing a normal match(), which advances the
        input.

        MISSING TOKEN

        If current token is consistent with what could come after
        ttype then it is ok to 'insert' the missing token, else throw
        exception For example, Input 'i=(3;' is clearly missing the
        ')'.  When the parser returns from the nested call to expr, it
        will have call chain:

          stat -> expr -> atom

        and it will be trying to match the ')' at this point in the
        derivation:

             => ID '=' '(' INT ')' ('+' atom)* ';'
                                ^
        match() will see that ';' doesn't match ')' and report a
        mismatched token error.  To recover, it sees that LA(1)==';'
        is in the set of tokens that can follow the ')' token
        reference in rule atom.  It can assume that you forgot the ')'.
        """

        e = None

        # if next token is what we are looking for then "delete" this token
        if self.mismatchIsUnwantedToken(input, ttype):
            e = UnwantedTokenException(ttype, input)

            self.beginResync()
            input.consume() # simply delete extra token
            self.endResync()

            # report after consuming so AW sees the token in the exception
            self.reportError(e)

            # we want to return the token we're actually matching
            matchedSymbol = self.getCurrentInputSymbol(input)

            # move past ttype token as if all were ok
            input.consume()
            return matchedSymbol

        # can't recover with single token deletion, try insertion
        if self.mismatchIsMissingToken(input, follow):
            inserted = self.getMissingSymbol(input, e, ttype, follow)
            e = MissingTokenException(ttype, input, inserted)

            # report after inserting so AW sees the token in the exception
            self.reportError(e)
            return inserted

        # even that didn't work; must throw the exception
        e = MismatchedTokenException(ttype, input)
        raise e


    def recoverFromMismatchedSet(self, input, e, follow):
        """Not currently used"""

        if self.mismatchIsMissingToken(input, follow):
            self.reportError(e)
            # we don't know how to conjure up a token for sets yet
            return self.getMissingSymbol(input, e, INVALID_TOKEN_TYPE, follow)

        # TODO do single token deletion like above for Token mismatch
        raise e


    def getCurrentInputSymbol(self, input):
        """
        Match needs to return the current input symbol, which gets put
        into the label for the associated token ref; e.g., x=ID.  Token
        and tree parsers need to return different objects. Rather than test
        for input stream type or change the IntStream interface, I use
        a simple method to ask the recognizer to tell me what the current
        input symbol is.

        This is ignored for lexers.
        """
        
        return None


    def getMissingSymbol(self, input, e, expectedTokenType, follow):
        """Conjure up a missing token during error recovery.

        The recognizer attempts to recover from single missing
        symbols. But, actions might refer to that missing symbol.
        For example, x=ID {f($x);}. The action clearly assumes
        that there has been an identifier matched previously and that
        $x points at that token. If that token is missing, but
        the next token in the stream is what we want we assume that
        this token is missing and we keep going. Because we
        have to return some token to replace the missing token,
        we have to conjure one up. This method gives the user control
        over the tokens returned for missing tokens. Mostly,
        you will want to create something special for identifier
        tokens. For literals such as '{' and ',', the default
        action in the parser or tree parser works. It simply creates
        a CommonToken of the appropriate type. The text will be the token.
        If you change what tokens must be created by the lexer,
        override this method to create the appropriate tokens.
        """

        return None


##     def recoverFromMissingElement(self, input, e, follow):
##         """
##         This code is factored out from mismatched token and mismatched set
##         recovery.  It handles "single token insertion" error recovery for
##         both.  No tokens are consumed to recover from insertions.  Return
##         true if recovery was possible else return false.
##         """
        
##         if self.mismatchIsMissingToken(input, follow):
##             self.reportError(e)
##             return True

##         # nothing to do; throw exception
##         return False


    def consumeUntil(self, input, tokenTypes):
        """
        Consume tokens until one matches the given token or token set

        tokenTypes can be a single token type or a set of token types
        
        """
        
        if not isinstance(tokenTypes, (set, frozenset)):
            tokenTypes = frozenset([tokenTypes])

        ttype = input.LA(1)
        while ttype != EOF and ttype not in tokenTypes:
            input.consume()
            ttype = input.LA(1)


    def getRuleInvocationStack(self):
        """
        Return List<String> of the rules in your parser instance
        leading up to a call to this method.  You could override if
        you want more details such as the file/line info of where
        in the parser java code a rule is invoked.

        This is very useful for error messages and for context-sensitive
        error recovery.

        You must be careful, if you subclass a generated recognizers.
        The default implementation will only search the module of self
        for rules, but the subclass will not contain any rules.
        You probably want to override this method to look like

        def getRuleInvocationStack(self):
            return self._getRuleInvocationStack(<class>.__module__)

        where <class> is the class of the generated recognizer, e.g.
        the superclass of self.
        """

        return self._getRuleInvocationStack(self.__module__)


    def _getRuleInvocationStack(cls, module):
        """
        A more general version of getRuleInvocationStack where you can
        pass in, for example, a RecognitionException to get it's rule
        stack trace.  This routine is shared with all recognizers, hence,
        static.

        TODO: move to a utility class or something; weird having lexer call
        this
        """

        # mmmhhh,... perhaps look at the first argument
        # (f_locals[co_varnames[0]]?) and test if it's a (sub)class of
        # requested recognizer...
        
        rules = []
        for frame in reversed(inspect.stack()):
            code = frame[0].f_code
            codeMod = inspect.getmodule(code)
            if codeMod is None:
                continue

            # skip frames not in requested module
            if codeMod.__name__ != module:
                continue

            # skip some unwanted names
            if code.co_name in ('nextToken', '<module>'):
                continue

            rules.append(code.co_name)

        return rules
        
    _getRuleInvocationStack = classmethod(_getRuleInvocationStack)
    

    def getBacktrackingLevel(self):
        return self._state.backtracking

    def setBacktrackingLevel(self, n):
        self._state.backtracking = n


    def failed(self):
        """Return whether or not a backtracking attempt failed."""

        return self._state.failed


    def getGrammarFileName(self):
        """For debugging and other purposes, might want the grammar name.
        
        Have ANTLR generate an implementation for this method.
        """

        return self.grammarFileName


    def getSourceName(self):
        raise NotImplementedError

    
    def toStrings(self, tokens):
        """A convenience method for use most often with template rewrites.

        Convert a List<Token> to List<String>
        """

        if tokens is None:
            return None

        return [token.text for token in tokens]


    def getRuleMemoization(self, ruleIndex, ruleStartIndex):
        """
        Given a rule number and a start token index number, return
        MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
        start index.  If this rule has parsed input starting from the
        start index before, then return where the rule stopped parsing.
        It returns the index of the last token matched by the rule.
        """
        
        if ruleIndex not in self._state.ruleMemo:
            self._state.ruleMemo[ruleIndex] = {}

        return self._state.ruleMemo[ruleIndex].get(
            ruleStartIndex, self.MEMO_RULE_UNKNOWN
            )


    def alreadyParsedRule(self, input, ruleIndex):
        """
        Has this rule already parsed input at the current index in the
        input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
        If we attempted but failed to parse properly before, return
        MEMO_RULE_FAILED.

        This method has a side-effect: if we have seen this input for
        this rule and successfully parsed before, then seek ahead to
        1 past the stop token matched for this rule last time.
        """

        stopIndex = self.getRuleMemoization(ruleIndex, input.index())
        if stopIndex == self.MEMO_RULE_UNKNOWN:
            return False

        if stopIndex == self.MEMO_RULE_FAILED:
            raise BacktrackingFailed

        else:
            input.seek(stopIndex + 1)

        return True


    def memoize(self, input, ruleIndex, ruleStartIndex, success):
        """
        Record whether or not this rule parsed the input at this position
        successfully.
        """

        if success:
            stopTokenIndex = input.index() - 1
        else:
            stopTokenIndex = self.MEMO_RULE_FAILED
        
        if ruleIndex in self._state.ruleMemo:
            self._state.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex


    def traceIn(self, ruleName, ruleIndex, inputSymbol):
        sys.stdout.write("enter %s %s" % (ruleName, inputSymbol))
        
        if self._state.backtracking > 0:
            sys.stdout.write(" backtracking=%s" % self._state.backtracking)

        sys.stdout.write('\n')


    def traceOut(self, ruleName, ruleIndex, inputSymbol):
        sys.stdout.write("exit %s %s" % (ruleName, inputSymbol))
        
        if self._state.backtracking > 0:
            sys.stdout.write(" backtracking=%s" % self._state.backtracking)

        if self._state.failed:
            sys.stdout.write(" failed")
        else:
            sys.stdout.write(" succeeded")

        sys.stdout.write('\n')


class TokenSource(object):
    """
    @brief Abstract baseclass for token producers.
    
    A source of tokens must provide a sequence of tokens via nextToken()
    and also must reveal it's source of characters; CommonToken's text is
    computed from a CharStream; it only store indices into the char stream.

    Errors from the lexer are never passed to the parser.  Either you want
    to keep going or you do not upon token recognition error.  If you do not
    want to continue lexing then you do not want to continue parsing.  Just
    throw an exception not under RecognitionException and Java will naturally
    toss you all the way out of the recognizers.  If you want to continue
    lexing then you should not throw an exception to the parser--it has already
    requested a token.  Keep lexing until you get a valid one.  Just report
    errors and keep going, looking for a valid token.
    """
    
    def nextToken(self):
        """Return a Token object from your input stream (usually a CharStream).
        
        Do not fail/return upon lexing error; keep chewing on the characters
        until you get a good one; errors are not passed through to the parser.
        """

        raise NotImplementedError
    

    def __iter__(self):
        """The TokenSource is an interator.

        The iteration will not include the final EOF token, see also the note
        for the next() method.

        """
        
        return self

    
    def next(self):
        """Return next token or raise StopIteration.

        Note that this will raise StopIteration when hitting the EOF token,
        so EOF will not be part of the iteration.
        
        """

        token = self.nextToken()
        if token is None or token.type == EOF:
            raise StopIteration
        return token

    
class Lexer(BaseRecognizer, TokenSource):
    """
    @brief Baseclass for generated lexer classes.
    
    A lexer is recognizer that draws input symbols from a character stream.
    lexer grammars result in a subclass of this object. A Lexer object
    uses simplified match() and error recovery mechanisms in the interest
    of speed.
    """

    def __init__(self, input, state=None):
        BaseRecognizer.__init__(self, state)
        TokenSource.__init__(self)
        
        # Where is the lexer drawing characters from?
        self.input = input


    def reset(self):
        BaseRecognizer.reset(self) # reset all recognizer state variables

        if self.input is not None:
            # rewind the input
            self.input.seek(0)

        if self._state is None:
            # no shared state work to do
            return
        
        # wack Lexer state variables
        self._state.token = None
        self._state.type = INVALID_TOKEN_TYPE
        self._state.channel = DEFAULT_CHANNEL
        self._state.tokenStartCharIndex = -1
        self._state.tokenStartLine = -1
        self._state.tokenStartCharPositionInLine = -1
        self._state.text = None


    def nextToken(self):
        """
        Return a token from this source; i.e., match a token on the char
        stream.
        """
        
        while 1:
            self._state.token = None
            self._state.channel = DEFAULT_CHANNEL
            self._state.tokenStartCharIndex = self.input.index()
            self._state.tokenStartCharPositionInLine = self.input.charPositionInLine
            self._state.tokenStartLine = self.input.line
            self._state.text = None
            if self.input.LA(1) == EOF:
                return EOF_TOKEN

            try:
                self.mTokens()
                
                if self._state.token is None:
                    self.emit()
                    
                elif self._state.token == SKIP_TOKEN:
                    continue

                return self._state.token

            except NoViableAltException, re:
                self.reportError(re)
                self.recover(re) # throw out current char and try again

            except RecognitionException, re:
                self.reportError(re)
                # match() routine has already called recover()


    def skip(self):
        """
        Instruct the lexer to skip creating a token for current lexer rule
        and look for another token.  nextToken() knows to keep looking when
        a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
        if token==null at end of any token rule, it creates one for you
        and emits it.
        """
        
        self._state.token = SKIP_TOKEN


    def mTokens(self):
        """This is the lexer entry point that sets instance var 'token'"""

        # abstract method
        raise NotImplementedError
    

    def setCharStream(self, input):
        """Set the char stream and reset the lexer"""
        self.input = None
        self.reset()
        self.input = input


    def getSourceName(self):
        return self.input.getSourceName()


    def emit(self, token=None):
        """
        The standard method called to automatically emit a token at the
        outermost lexical rule.  The token object should point into the
        char buffer start..stop.  If there is a text override in 'text',
        use that to set the token's text.  Override this method to emit
        custom Token objects.

        If you are building trees, then you should also override
        Parser or TreeParser.getMissingSymbol().
        """

        if token is None:
            token = CommonToken(
                input=self.input,
                type=self._state.type,
                channel=self._state.channel,
                start=self._state.tokenStartCharIndex,
                stop=self.getCharIndex()-1
                )
            token.line = self._state.tokenStartLine
            token.text = self._state.text
            token.charPositionInLine = self._state.tokenStartCharPositionInLine

        self._state.token = token
        
        return token


    def match(self, s):
        if isinstance(s, basestring):
            for c in s:
                if self.input.LA(1) != ord(c):
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    mte = MismatchedTokenException(c, self.input)
                    self.recover(mte)
                    raise mte

                self.input.consume()

        else:
            if self.input.LA(1) != s:
                if self._state.backtracking > 0:
                    raise BacktrackingFailed

                mte = MismatchedTokenException(unichr(s), self.input)
                self.recover(mte) # don't really recover; just consume in lexer
                raise mte
        
            self.input.consume()
            

    def matchAny(self):
        self.input.consume()


    def matchRange(self, a, b):
        if self.input.LA(1) < a or self.input.LA(1) > b:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            mre = MismatchedRangeException(unichr(a), unichr(b), self.input)
            self.recover(mre)
            raise mre

        self.input.consume()


    def getLine(self):
        return self.input.line


    def getCharPositionInLine(self):
        return self.input.charPositionInLine


    def getCharIndex(self):
        """What is the index of the current character of lookahead?"""
        
        return self.input.index()


    def getText(self):
        """
        Return the text matched so far for the current token or any
        text override.
        """
        if self._state.text is not None:
            return self._state.text
        
        return self.input.substring(
            self._state.tokenStartCharIndex,
            self.getCharIndex()-1
            )


    def setText(self, text):
        """
        Set the complete text of this token; it wipes any previous
        changes to the text.
        """
        self._state.text = text


    text = property(getText, setText)


    def reportError(self, e):
        ## TODO: not thought about recovery in lexer yet.

        ## # if we've already reported an error and have not matched a token
        ## # yet successfully, don't report any errors.
        ## if self.errorRecovery:
        ##     #System.err.print("[SPURIOUS] ");
        ##     return;
        ## 
        ## self.errorRecovery = True

        self.displayRecognitionError(self.tokenNames, e)


    def getErrorMessage(self, e, tokenNames):
        msg = None
        
        if isinstance(e, MismatchedTokenException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting " \
                  + self.getCharErrorDisplay(e.expecting)

        elif isinstance(e, NoViableAltException):
            msg = "no viable alternative at character " \
                  + self.getCharErrorDisplay(e.c)

        elif isinstance(e, EarlyExitException):
            msg = "required (...)+ loop did not match anything at character " \
                  + self.getCharErrorDisplay(e.c)
            
        elif isinstance(e, MismatchedNotSetException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, MismatchedSetException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, MismatchedRangeException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting set " \
                  + self.getCharErrorDisplay(e.a) \
                  + ".." \
                  + self.getCharErrorDisplay(e.b)

        else:
            msg = BaseRecognizer.getErrorMessage(self, e, tokenNames)

        return msg


    def getCharErrorDisplay(self, c):
        if c == EOF:
            c = '<EOF>'
        return repr(c)


    def recover(self, re):
        """
        Lexers can normally match any char in it's vocabulary after matching
        a token, so do the easy thing and just kill a character and hope
        it all works out.  You can instead use the rule invocation stack
        to do sophisticated error recovery if you are in a fragment rule.
        """

        self.input.consume()


    def traceIn(self, ruleName, ruleIndex):
        inputSymbol = "%s line=%d:%s" % (self.input.LT(1),
                                         self.getLine(),
                                         self.getCharPositionInLine()
                                         )
        
        BaseRecognizer.traceIn(self, ruleName, ruleIndex, inputSymbol)


    def traceOut(self, ruleName, ruleIndex):
        inputSymbol = "%s line=%d:%s" % (self.input.LT(1),
                                         self.getLine(),
                                         self.getCharPositionInLine()
                                         )

        BaseRecognizer.traceOut(self, ruleName, ruleIndex, inputSymbol)



class Parser(BaseRecognizer):
    """
    @brief Baseclass for generated parser classes.
    """
    
    def __init__(self, lexer, state=None):
        BaseRecognizer.__init__(self, state)

        self.setTokenStream(lexer)


    def reset(self):
        BaseRecognizer.reset(self) # reset all recognizer state variables
        if self.input is not None:
            self.input.seek(0) # rewind the input


    def getCurrentInputSymbol(self, input):
        return input.LT(1)


    def getMissingSymbol(self, input, e, expectedTokenType, follow):
        if expectedTokenType == EOF:
            tokenText = "<missing EOF>"
        else:
            tokenText = "<missing " + self.tokenNames[expectedTokenType] + ">"
        t = CommonToken(type=expectedTokenType, text=tokenText)
        current = input.LT(1)
        if current.type == EOF:
            current = input.LT(-1)

        if current is not None:
            t.line = current.line
            t.charPositionInLine = current.charPositionInLine
        t.channel = DEFAULT_CHANNEL
        return t


    def setTokenStream(self, input):
        """Set the token stream and reset the parser"""
        
        self.input = None
        self.reset()
        self.input = input


    def getTokenStream(self):
        return self.input


    def getSourceName(self):
        return self.input.getSourceName()


    def traceIn(self, ruleName, ruleIndex):
        BaseRecognizer.traceIn(self, ruleName, ruleIndex, self.input.LT(1))


    def traceOut(self, ruleName, ruleIndex):
        BaseRecognizer.traceOut(self, ruleName, ruleIndex, self.input.LT(1))


class RuleReturnScope(object):
    """
    Rules can return start/stop info as well as possible trees and templates.
    """

    def getStart(self):
        """Return the start token or tree."""
        return None
    

    def getStop(self):
        """Return the stop token or tree."""
        return None

    
    def getTree(self):
        """Has a value potentially if output=AST."""
        return None


    def getTemplate(self):
        """Has a value potentially if output=template."""
        return None


class ParserRuleReturnScope(RuleReturnScope):
    """
    Rules that return more than a single value must return an object
    containing all the values.  Besides the properties defined in
    RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
    return values.  This class simply defines the minimum properties that
    are always defined and methods to access the others that might be
    available depending on output option such as template and tree.

    Note text is not an actual property of the return value, it is computed
    from start and stop using the input stream's toString() method.  I
    could add a ctor to this so that we can pass in and store the input
    stream, but I'm not sure we want to do that.  It would seem to be undefined
    to get the .text property anyway if the rule matches tokens from multiple
    input streams.

    I do not use getters for fields of objects that are used simply to
    group values such as this aggregate.  The getters/setters are there to
    satisfy the superclass interface.
    """

    def __init__(self):
        self.start = None
        self.stop = None

    
    def getStart(self):
        return self.start


    def getStop(self):
        return self.stop


########NEW FILE########
__FILENAME__ = streams
"""ANTLR3 runtime package"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

import codecs
from StringIO import StringIO

from .constants import DEFAULT_CHANNEL, EOF
from .tokens import Token, EOF_TOKEN


############################################################################
#
# basic interfaces
#   IntStream
#    +- CharStream
#    \- TokenStream
#
# subclasses must implemented all methods
#
############################################################################

class IntStream(object):
    """
    @brief Base interface for streams of integer values.

    A simple stream of integers used when all I care about is the char
    or token type sequence (such as interpretation).
    """

    def consume(self):
        raise NotImplementedError
    

    def LA(self, i):
        """Get int at current input pointer + i ahead where i=1 is next int.

        Negative indexes are allowed.  LA(-1) is previous token (token
	just matched).  LA(-i) where i is before first token should
	yield -1, invalid char / EOF.
	"""
        
        raise NotImplementedError
        

    def mark(self):
        """
        Tell the stream to start buffering if it hasn't already.  Return
        current input position, index(), or some other marker so that
        when passed to rewind() you get back to the same spot.
        rewind(mark()) should not affect the input cursor.  The Lexer
        track line/col info as well as input index so its markers are
        not pure input indexes.  Same for tree node streams.
        """

        raise NotImplementedError


    def index(self):
        """
        Return the current input symbol index 0..n where n indicates the
        last symbol has been read.  The index is the symbol about to be
        read not the most recently read symbol.
        """

        raise NotImplementedError


    def rewind(self, marker=None):
        """
        Reset the stream so that next call to index would return marker.
        The marker will usually be index() but it doesn't have to be.  It's
        just a marker to indicate what state the stream was in.  This is
        essentially calling release() and seek().  If there are markers
        created after this marker argument, this routine must unroll them
        like a stack.  Assume the state the stream was in when this marker
        was created.

        If marker is None:
        Rewind to the input position of the last marker.
        Used currently only after a cyclic DFA and just
        before starting a sem/syn predicate to get the
        input position back to the start of the decision.
        Do not "pop" the marker off the state.  mark(i)
        and rewind(i) should balance still. It is
        like invoking rewind(last marker) but it should not "pop"
        the marker off.  It's like seek(last marker's input position).       
	"""

        raise NotImplementedError


    def release(self, marker=None):
        """
        You may want to commit to a backtrack but don't want to force the
        stream to keep bookkeeping objects around for a marker that is
        no longer necessary.  This will have the same behavior as
        rewind() except it releases resources without the backward seek.
        This must throw away resources for all markers back to the marker
        argument.  So if you're nested 5 levels of mark(), and then release(2)
        you have to release resources for depths 2..5.
	"""

        raise NotImplementedError


    def seek(self, index):
        """
        Set the input cursor to the position indicated by index.  This is
        normally used to seek ahead in the input stream.  No buffering is
        required to do this unless you know your stream will use seek to
        move backwards such as when backtracking.

        This is different from rewind in its multi-directional
        requirement and in that its argument is strictly an input cursor
        (index).

        For char streams, seeking forward must update the stream state such
        as line number.  For seeking backwards, you will be presumably
        backtracking using the mark/rewind mechanism that restores state and
        so this method does not need to update state when seeking backwards.

        Currently, this method is only used for efficient backtracking using
        memoization, but in the future it may be used for incremental parsing.

        The index is 0..n-1.  A seek to position i means that LA(1) will
        return the ith symbol.  So, seeking to 0 means LA(1) will return the
        first element in the stream. 
        """

        raise NotImplementedError


    def size(self):
        """
        Only makes sense for streams that buffer everything up probably, but
        might be useful to display the entire stream or for testing.  This
        value includes a single EOF.
	"""

        raise NotImplementedError


    def getSourceName(self):
        """
        Where are you getting symbols from?  Normally, implementations will
        pass the buck all the way to the lexer who can ask its input stream
        for the file name or whatever.
        """

        raise NotImplementedError


class CharStream(IntStream):
    """
    @brief A source of characters for an ANTLR lexer.

    This is an abstract class that must be implemented by a subclass.
    
    """

    # pylint does not realize that this is an interface, too
    #pylint: disable-msg=W0223
    
    EOF = -1


    def substring(self, start, stop):
        """
        For infinite streams, you don't need this; primarily I'm providing
        a useful interface for action code.  Just make sure actions don't
        use this on streams that don't support it.
        """

        raise NotImplementedError
        
    
    def LT(self, i):
        """
        Get the ith character of lookahead.  This is the same usually as
        LA(i).  This will be used for labels in the generated
        lexer code.  I'd prefer to return a char here type-wise, but it's
        probably better to be 32-bit clean and be consistent with LA.
        """

        raise NotImplementedError


    def getLine(self):
        """ANTLR tracks the line information automatically"""

        raise NotImplementedError


    def setLine(self, line):
        """
        Because this stream can rewind, we need to be able to reset the line
        """

        raise NotImplementedError


    def getCharPositionInLine(self):
        """
        The index of the character relative to the beginning of the line 0..n-1
        """

        raise NotImplementedError


    def setCharPositionInLine(self, pos):
        raise NotImplementedError


class TokenStream(IntStream):
    """

    @brief A stream of tokens accessing tokens from a TokenSource

    This is an abstract class that must be implemented by a subclass.
    
    """
    
    # pylint does not realize that this is an interface, too
    #pylint: disable-msg=W0223
    
    def LT(self, k):
        """
        Get Token at current input pointer + i ahead where i=1 is next Token.
        i<0 indicates tokens in the past.  So -1 is previous token and -2 is
        two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
        Return null for LT(0) and any index that results in an absolute address
        that is negative.
	"""

        raise NotImplementedError


    def get(self, i):
        """
        Get a token at an absolute index i; 0..n-1.  This is really only
        needed for profiling and debugging and token stream rewriting.
        If you don't want to buffer up tokens, then this method makes no
        sense for you.  Naturally you can't use the rewrite stream feature.
        I believe DebugTokenStream can easily be altered to not use
        this method, removing the dependency.
        """

        raise NotImplementedError


    def getTokenSource(self):
        """
        Where is this stream pulling tokens from?  This is not the name, but
        the object that provides Token objects.
	"""

        raise NotImplementedError


    def toString(self, start=None, stop=None):
        """
        Return the text of all tokens from start to stop, inclusive.
        If the stream does not buffer all the tokens then it can just
        return "" or null;  Users should not access $ruleLabel.text in
        an action of course in that case.

        Because the user is not required to use a token with an index stored
        in it, we must provide a means for two token objects themselves to
        indicate the start/end location.  Most often this will just delegate
        to the other toString(int,int).  This is also parallel with
        the TreeNodeStream.toString(Object,Object).
	"""

        raise NotImplementedError

        
############################################################################
#
# character streams for use in lexers
#   CharStream
#   \- ANTLRStringStream
#
############################################################################


class ANTLRStringStream(CharStream):
    """
    @brief CharStream that pull data from a unicode string.
    
    A pretty quick CharStream that pulls all data from an array
    directly.  Every method call counts in the lexer.

    """

    
    def __init__(self, data):
        """
        @param data This should be a unicode string holding the data you want
           to parse. If you pass in a byte string, the Lexer will choke on
           non-ascii data.
           
        """
        
        CharStream.__init__(self)
        
  	# The data being scanned
        self.strdata = unicode(data)
        self.data = [ord(c) for c in self.strdata]
        
	# How many characters are actually in the buffer
        self.n = len(data)

 	# 0..n-1 index into string of next char
        self.p = 0

	# line number 1..n within the input
        self.line = 1

 	# The index of the character relative to the beginning of the
        # line 0..n-1
        self.charPositionInLine = 0

	# A list of CharStreamState objects that tracks the stream state
        # values line, charPositionInLine, and p that can change as you
        # move through the input stream.  Indexed from 0..markDepth-1.
        self._markers = [ ]
        self.lastMarker = None
        self.markDepth = 0

        # What is name or source of this char stream?
        self.name = None


    def reset(self):
        """
        Reset the stream so that it's in the same state it was
        when the object was created *except* the data array is not
        touched.
        """
        
        self.p = 0
        self.line = 1
        self.charPositionInLine = 0
        self._markers = [ ]


    def consume(self):
        try:
            if self.data[self.p] == 10: # \n
                self.line += 1
                self.charPositionInLine = 0
            else:
                self.charPositionInLine += 1

            self.p += 1
            
        except IndexError:
            # happend when we reached EOF and self.data[self.p] fails
            # just do nothing
            pass



    def LA(self, i):
        if i == 0:
            return 0 # undefined

        if i < 0:
            i += 1 # e.g., translate LA(-1) to use offset i=0; then data[p+0-1]

        try:
            return self.data[self.p+i-1]
        except IndexError:
            return EOF



    def LT(self, i):
        if i == 0:
            return 0 # undefined

        if i < 0:
            i += 1 # e.g., translate LA(-1) to use offset i=0; then data[p+0-1]

        try:
            return self.strdata[self.p+i-1]
        except IndexError:
            return EOF


    def index(self):
        """
        Return the current input symbol index 0..n where n indicates the
        last symbol has been read.  The index is the index of char to
        be returned from LA(1).
        """
        
        return self.p


    def size(self):
        return self.n


    def mark(self):
        state = (self.p, self.line, self.charPositionInLine)
        try:
            self._markers[self.markDepth] = state
        except IndexError:
            self._markers.append(state)
        self.markDepth += 1
        
        self.lastMarker = self.markDepth
        
        return self.lastMarker


    def rewind(self, marker=None):
        if marker is None:
            marker = self.lastMarker

        p, line, charPositionInLine = self._markers[marker-1]

        self.seek(p)
        self.line = line
        self.charPositionInLine = charPositionInLine
        self.release(marker)


    def release(self, marker=None):
        if marker is None:
            marker = self.lastMarker

        self.markDepth = marker-1


    def seek(self, index):
        """
        consume() ahead until p==index; can't just set p=index as we must
        update line and charPositionInLine.
        """
        
        if index <= self.p:
            self.p = index # just jump; don't update stream state (line, ...)
            return

        # seek forward, consume until p hits index
        while self.p < index:
            self.consume()


    def substring(self, start, stop):
        return self.strdata[start:stop+1]


    def getLine(self):
        """Using setter/getter methods is deprecated. Use o.line instead."""
        return self.line


    def getCharPositionInLine(self):
        """
        Using setter/getter methods is deprecated. Use o.charPositionInLine
        instead.
        """
        return self.charPositionInLine


    def setLine(self, line):
        """Using setter/getter methods is deprecated. Use o.line instead."""
        self.line = line


    def setCharPositionInLine(self, pos):
        """
        Using setter/getter methods is deprecated. Use o.charPositionInLine
        instead.
        """
        self.charPositionInLine = pos


    def getSourceName(self):
        return self.name


class ANTLRFileStream(ANTLRStringStream):
    """
    @brief CharStream that opens a file to read the data.
    
    This is a char buffer stream that is loaded from a file
    all at once when you construct the object.
    """

    def __init__(self, fileName, encoding=None):
        """
        @param fileName The path to the file to be opened. The file will be
           opened with mode 'rb'.

        @param encoding If you set the optional encoding argument, then the
           data will be decoded on the fly.
           
        """
        
        self.fileName = fileName

        fp = codecs.open(fileName, 'rb', encoding)
        try:
            data = fp.read()
        finally:
            fp.close()
            
        ANTLRStringStream.__init__(self, data)


    def getSourceName(self):
        """Deprecated, access o.fileName directly."""
        
        return self.fileName


class ANTLRInputStream(ANTLRStringStream):
    """
    @brief CharStream that reads data from a file-like object.

    This is a char buffer stream that is loaded from a file like object
    all at once when you construct the object.
    
    All input is consumed from the file, but it is not closed.
    """

    def __init__(self, file, encoding=None):
        """
        @param file A file-like object holding your input. Only the read()
           method must be implemented.

        @param encoding If you set the optional encoding argument, then the
           data will be decoded on the fly.
           
        """
        
        if encoding is not None:
            # wrap input in a decoding reader
            reader = codecs.lookup(encoding)[2]
            file = reader(file)

        data = file.read()
            
        ANTLRStringStream.__init__(self, data)


# I guess the ANTLR prefix exists only to avoid a name clash with some Java
# mumbojumbo. A plain "StringStream" looks better to me, which should be
# the preferred name in Python.
StringStream = ANTLRStringStream
FileStream = ANTLRFileStream
InputStream = ANTLRInputStream


############################################################################
#
# Token streams
#   TokenStream
#   +- CommonTokenStream
#   \- TokenRewriteStream
#
############################################################################


class CommonTokenStream(TokenStream):
    """
    @brief The most common stream of tokens
    
    The most common stream of tokens is one where every token is buffered up
    and tokens are prefiltered for a certain channel (the parser will only
    see these tokens and cannot change the filter channel number during the
    parse).
    """

    def __init__(self, tokenSource=None, channel=DEFAULT_CHANNEL):
        """
        @param tokenSource A TokenSource instance (usually a Lexer) to pull
            the tokens from.

        @param channel Skip tokens on any channel but this one; this is how we
            skip whitespace...
            
        """
        
        TokenStream.__init__(self)
        
        self.tokenSource = tokenSource

	# Record every single token pulled from the source so we can reproduce
        # chunks of it later.
        self.tokens = []

	# Map<tokentype, channel> to override some Tokens' channel numbers
        self.channelOverrideMap = {}

	# Set<tokentype>; discard any tokens with this type
        self.discardSet = set()

	# Skip tokens on any channel but this one; this is how we skip whitespace...
        self.channel = channel

	# By default, track all incoming tokens
        self.discardOffChannelTokens = False

	# The index into the tokens list of the current token (next token
        # to consume).  p==-1 indicates that the tokens list is empty
        self.p = -1

        # Remember last marked position
        self.lastMarker = None
        

    def setTokenSource(self, tokenSource):
        """Reset this token stream by setting its token source."""
        
        self.tokenSource = tokenSource
        self.tokens = []
        self.p = -1
        self.channel = DEFAULT_CHANNEL


    def reset(self):
        self.p = 0
        self.lastMarker = None


    def fillBuffer(self):
        """
        Load all tokens from the token source and put in tokens.
	This is done upon first LT request because you might want to
        set some token type / channel overrides before filling buffer.
        """
        

        index = 0
        t = self.tokenSource.nextToken()
        while t is not None and t.type != EOF:
            discard = False
            
            if self.discardSet is not None and t.type in self.discardSet:
                discard = True

            elif self.discardOffChannelTokens and t.channel != self.channel:
                discard = True

            # is there a channel override for token type?
            if t.type in self.channelOverrideMap:
                overrideChannel = self.channelOverrideMap[t.type]

                if overrideChannel == self.channel:
                    t.channel = overrideChannel
                else:
                    discard = True
            
            if not discard:
                t.index = index
                self.tokens.append(t)
                index += 1

            t = self.tokenSource.nextToken()
       
        # leave p pointing at first token on channel
        self.p = 0
        self.p = self.skipOffTokenChannels(self.p)


    def consume(self):
        """
        Move the input pointer to the next incoming token.  The stream
        must become active with LT(1) available.  consume() simply
        moves the input pointer so that LT(1) points at the next
        input symbol. Consume at least one token.

        Walk past any token not on the channel the parser is listening to.
        """
        
        if self.p < len(self.tokens):
            self.p += 1

            self.p = self.skipOffTokenChannels(self.p) # leave p on valid token


    def skipOffTokenChannels(self, i):
        """
        Given a starting index, return the index of the first on-channel
        token.
        """

        try:
            while self.tokens[i].channel != self.channel:
                i += 1
        except IndexError:
            # hit the end of token stream
            pass
        
        return i


    def skipOffTokenChannelsReverse(self, i):
        while i >= 0 and self.tokens[i].channel != self.channel:
            i -= 1

        return i


    def setTokenTypeChannel(self, ttype, channel):
        """
        A simple filter mechanism whereby you can tell this token stream
        to force all tokens of type ttype to be on channel.  For example,
        when interpreting, we cannot exec actions so we need to tell
        the stream to force all WS and NEWLINE to be a different, ignored
        channel.
	"""
        
        self.channelOverrideMap[ttype] = channel


    def discardTokenType(self, ttype):
        self.discardSet.add(ttype)


    def getTokens(self, start=None, stop=None, types=None):
        """
        Given a start and stop index, return a list of all tokens in
        the token type set.  Return None if no tokens were found.  This
        method looks at both on and off channel tokens.
        """

        if self.p == -1:
            self.fillBuffer()

        if stop is None or stop >= len(self.tokens):
            stop = len(self.tokens) - 1
            
        if start is None or stop < 0:
            start = 0

        if start > stop:
            return None

        if isinstance(types, (int, long)):
            # called with a single type, wrap into set
            types = set([types])
            
        filteredTokens = [
            token for token in self.tokens[start:stop]
            if types is None or token.type in types
            ]

        if len(filteredTokens) == 0:
            return None

        return filteredTokens


    def LT(self, k):
        """
        Get the ith token from the current position 1..n where k=1 is the
        first symbol of lookahead.
        """

        if self.p == -1:
            self.fillBuffer()

        if k == 0:
            return None

        if k < 0:
            return self.LB(-k)
                
        i = self.p
        n = 1
        # find k good tokens
        while n < k:
            # skip off-channel tokens
            i = self.skipOffTokenChannels(i+1) # leave p on valid token
            n += 1

        try:
            return self.tokens[i]
        except IndexError:
            return EOF_TOKEN


    def LB(self, k):
        """Look backwards k tokens on-channel tokens"""

        if self.p == -1:
            self.fillBuffer()

        if k == 0:
            return None

        if self.p - k < 0:
            return None

        i = self.p
        n = 1
        # find k good tokens looking backwards
        while n <= k:
            # skip off-channel tokens
            i = self.skipOffTokenChannelsReverse(i-1) # leave p on valid token
            n += 1

        if i < 0:
            return None
            
        return self.tokens[i]


    def get(self, i):
        """
        Return absolute token i; ignore which channel the tokens are on;
        that is, count all tokens not just on-channel tokens.
        """

        return self.tokens[i]


    def LA(self, i):
        return self.LT(i).type


    def mark(self):
        self.lastMarker = self.index()
        return self.lastMarker
    

    def release(self, marker=None):
        # no resources to release
        pass
    

    def size(self):
        return len(self.tokens)


    def index(self):
        return self.p


    def rewind(self, marker=None):
        if marker is None:
            marker = self.lastMarker
            
        self.seek(marker)


    def seek(self, index):
        self.p = index


    def getTokenSource(self):
        return self.tokenSource


    def getSourceName(self):
        return self.tokenSource.getSourceName()


    def toString(self, start=None, stop=None):
        if self.p == -1:
            self.fillBuffer()

        if start is None:
            start = 0
        elif not isinstance(start, int):
            start = start.index

        if stop is None:
            stop = len(self.tokens) - 1
        elif not isinstance(stop, int):
            stop = stop.index
        
        if stop >= len(self.tokens):
            stop = len(self.tokens) - 1

        return ''.join([t.text for t in self.tokens[start:stop+1]])


class RewriteOperation(object):
    """@brief Internal helper class."""
    
    def __init__(self, stream, index, text):
        self.stream = stream
        self.index = index
        self.text = text

    def execute(self, buf):
        """Execute the rewrite operation by possibly adding to the buffer.
        Return the index of the next token to operate on.
        """

        return self.index

    def toString(self):
        opName = self.__class__.__name__
        return '<%s@%d:"%s">' % (opName, self.index, self.text)

    __str__ = toString
    __repr__ = toString


class InsertBeforeOp(RewriteOperation):
    """@brief Internal helper class."""

    def execute(self, buf):
        buf.write(self.text)
        buf.write(self.stream.tokens[self.index].text)
        return self.index + 1


class ReplaceOp(RewriteOperation):
    """
    @brief Internal helper class.
    
    I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
    instructions.
    """

    def __init__(self, stream, first, last, text):
        RewriteOperation.__init__(self, stream, first, text)
        self.lastIndex = last


    def execute(self, buf):
        if self.text is not None:
            buf.write(self.text)

        return self.lastIndex + 1


    def toString(self):
        return '<ReplaceOp@%d..%d:"%s">' % (
            self.index, self.lastIndex, self.text)

    __str__ = toString
    __repr__ = toString


class DeleteOp(ReplaceOp):
    """
    @brief Internal helper class.
    """

    def __init__(self, stream, first, last):
        ReplaceOp.__init__(self, stream, first, last, None)


    def toString(self):
        return '<DeleteOp@%d..%d>' % (self.index, self.lastIndex)

    __str__ = toString
    __repr__ = toString


class TokenRewriteStream(CommonTokenStream):
    """@brief CommonTokenStream that can be modified.

    Useful for dumping out the input stream after doing some
    augmentation or other manipulations.

    You can insert stuff, replace, and delete chunks.  Note that the
    operations are done lazily--only if you convert the buffer to a
    String.  This is very efficient because you are not moving data around
    all the time.  As the buffer of tokens is converted to strings, the
    toString() method(s) check to see if there is an operation at the
    current index.  If so, the operation is done and then normal String
    rendering continues on the buffer.  This is like having multiple Turing
    machine instruction streams (programs) operating on a single input tape. :)

    Since the operations are done lazily at toString-time, operations do not
    screw up the token index values.  That is, an insert operation at token
    index i does not change the index values for tokens i+1..n-1.

    Because operations never actually alter the buffer, you may always get
    the original token stream back without undoing anything.  Since
    the instructions are queued up, you can easily simulate transactions and
    roll back any changes if there is an error just by removing instructions.
    For example,

     CharStream input = new ANTLRFileStream("input");
     TLexer lex = new TLexer(input);
     TokenRewriteStream tokens = new TokenRewriteStream(lex);
     T parser = new T(tokens);
     parser.startRule();

     Then in the rules, you can execute
        Token t,u;
        ...
        input.insertAfter(t, "text to put after t");}
        input.insertAfter(u, "text after u");}
        System.out.println(tokens.toString());

    Actually, you have to cast the 'input' to a TokenRewriteStream. :(

    You can also have multiple "instruction streams" and get multiple
    rewrites from a single pass over the input.  Just name the instruction
    streams and use that name again when printing the buffer.  This could be
    useful for generating a C file and also its header file--all from the
    same buffer:

        tokens.insertAfter("pass1", t, "text to put after t");}
        tokens.insertAfter("pass2", u, "text after u");}
        System.out.println(tokens.toString("pass1"));
        System.out.println(tokens.toString("pass2"));

    If you don't use named rewrite streams, a "default" stream is used as
    the first example shows.
    """
    
    DEFAULT_PROGRAM_NAME = "default"
    MIN_TOKEN_INDEX = 0

    def __init__(self, tokenSource=None, channel=DEFAULT_CHANNEL):
        CommonTokenStream.__init__(self, tokenSource, channel)

        # You may have multiple, named streams of rewrite operations.
        # I'm calling these things "programs."
        #  Maps String (name) -> rewrite (List)
        self.programs = {}
        self.programs[self.DEFAULT_PROGRAM_NAME] = []
        
 	# Map String (program name) -> Integer index
        self.lastRewriteTokenIndexes = {}
        

    def rollback(self, *args):
        """
        Rollback the instruction stream for a program so that
        the indicated instruction (via instructionIndex) is no
        longer in the stream.  UNTESTED!
        """

        if len(args) == 2:
            programName = args[0]
            instructionIndex = args[1]
        elif len(args) == 1:
            programName = self.DEFAULT_PROGRAM_NAME
            instructionIndex = args[0]
        else:
            raise TypeError("Invalid arguments")
        
        p = self.programs.get(programName, None)
        if p is not None:
            self.programs[programName] = (
                p[self.MIN_TOKEN_INDEX:instructionIndex])


    def deleteProgram(self, programName=DEFAULT_PROGRAM_NAME):
        """Reset the program so that no instructions exist"""
            
        self.rollback(programName, self.MIN_TOKEN_INDEX)


    def insertAfter(self, *args):
        if len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            index = args[0]
            text = args[1]
            
        elif len(args) == 3:
            programName = args[0]
            index = args[1]
            text = args[2]

        else:
            raise TypeError("Invalid arguments")

        if isinstance(index, Token):
            # index is a Token, grap the stream index from it
            index = index.index

        # to insert after, just insert before next index (even if past end)
        self.insertBefore(programName, index+1, text)


    def insertBefore(self, *args):
        if len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            index = args[0]
            text = args[1]
            
        elif len(args) == 3:
            programName = args[0]
            index = args[1]
            text = args[2]

        else:
            raise TypeError("Invalid arguments")

        if isinstance(index, Token):
            # index is a Token, grap the stream index from it
            index = index.index

        op = InsertBeforeOp(self, index, text)
        rewrites = self.getProgram(programName)
        rewrites.append(op)


    def replace(self, *args):
        if len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            first = args[0]
            last = args[0]
            text = args[1]
            
        elif len(args) == 3:
            programName = self.DEFAULT_PROGRAM_NAME
            first = args[0]
            last = args[1]
            text = args[2]
            
        elif len(args) == 4:
            programName = args[0]
            first = args[1]
            last = args[2]
            text = args[3]

        else:
            raise TypeError("Invalid arguments")

        if isinstance(first, Token):
            # first is a Token, grap the stream index from it
            first = first.index

        if isinstance(last, Token):
            # last is a Token, grap the stream index from it
            last = last.index

        if first > last or first < 0 or last < 0 or last >= len(self.tokens):
            raise ValueError(
                "replace: range invalid: "+first+".."+last+
                "(size="+len(self.tokens)+")")

        op = ReplaceOp(self, first, last, text)
        rewrites = self.getProgram(programName)
        rewrites.append(op)
        

    def delete(self, *args):
        self.replace(*(list(args) + [None]))


    def getLastRewriteTokenIndex(self, programName=DEFAULT_PROGRAM_NAME):
        return self.lastRewriteTokenIndexes.get(programName, -1)


    def setLastRewriteTokenIndex(self, programName, i):
        self.lastRewriteTokenIndexes[programName] = i


    def getProgram(self, name):
        p = self.programs.get(name, None)
        if p is  None:
            p = self.initializeProgram(name)

        return p


    def initializeProgram(self, name):
        p = []
        self.programs[name] = p
        return p


    def toOriginalString(self, start=None, end=None):
        if start is None:
            start = self.MIN_TOKEN_INDEX
        if end is None:
            end = self.size() - 1
        
        buf = StringIO()
        i = start
        while i >= self.MIN_TOKEN_INDEX and i <= end and i < len(self.tokens):
            buf.write(self.get(i).text)
            i += 1

        return buf.getvalue()


    def toString(self, *args):
        if len(args) == 0:
            programName = self.DEFAULT_PROGRAM_NAME
            start = self.MIN_TOKEN_INDEX
            end = self.size() - 1
            
        elif len(args) == 1:
            programName = args[0]
            start = self.MIN_TOKEN_INDEX
            end = self.size() - 1

        elif len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            start = args[0]
            end = args[1]
            
        if start is None:
            start = self.MIN_TOKEN_INDEX
        elif not isinstance(start, int):
            start = start.index

        if end is None:
            end = len(self.tokens) - 1
        elif not isinstance(end, int):
            end = end.index

        # ensure start/end are in range
        if end >= len(self.tokens):
            end = len(self.tokens) - 1

        if start < 0:
            start = 0

        rewrites = self.programs.get(programName)
        if rewrites is None or len(rewrites) == 0:
            # no instructions to execute
            return self.toOriginalString(start, end)
        
        buf = StringIO()

        # First, optimize instruction stream
        indexToOp = self.reduceToSingleOperationPerIndex(rewrites)

        # Walk buffer, executing instructions and emitting tokens
        i = start
        while i <= end and i < len(self.tokens):
            op = indexToOp.get(i)
            # remove so any left have index size-1
            try:
                del indexToOp[i]
            except KeyError:
                pass

            t = self.tokens[i]
            if op is None:
                # no operation at that index, just dump token
                buf.write(t.text)
                i += 1 # move to next token

            else:
                i = op.execute(buf) # execute operation and skip

        # include stuff after end if it's last index in buffer
        # So, if they did an insertAfter(lastValidIndex, "foo"), include
        # foo if end==lastValidIndex.
        if end == len(self.tokens) - 1:
            # Scan any remaining operations after last token
            # should be included (they will be inserts).
            for i in sorted(indexToOp.keys()):
                op = indexToOp[i]
                if op.index >= len(self.tokens)-1:
                    buf.write(op.text)

        return buf.getvalue()

    __str__ = toString


    def reduceToSingleOperationPerIndex(self, rewrites):
        """
        We need to combine operations and report invalid operations (like
        overlapping replaces that are not completed nested).  Inserts to
        same index need to be combined etc...   Here are the cases:

        I.i.u I.j.v                           leave alone, nonoverlapping
        I.i.u I.i.v                           combine: Iivu

        R.i-j.u R.x-y.v | i-j in x-y          delete first R
        R.i-j.u R.i-j.v                       delete first R
        R.i-j.u R.x-y.v | x-y in i-j          ERROR
        R.i-j.u R.x-y.v | boundaries overlap  ERROR

        I.i.u R.x-y.v   | i in x-y            delete I
        I.i.u R.x-y.v   | i not in x-y        leave alone, nonoverlapping
        R.x-y.v I.i.u   | i in x-y            ERROR
        R.x-y.v I.x.u                         R.x-y.uv (combine, delete I)
        R.x-y.v I.i.u   | i not in x-y        leave alone, nonoverlapping

        I.i.u = insert u before op @ index i
        R.x-y.u = replace x-y indexed tokens with u

        First we need to examine replaces.  For any replace op:

          1. wipe out any insertions before op within that range.
          2. Drop any replace op before that is contained completely within
             that range.
          3. Throw exception upon boundary overlap with any previous replace.

        Then we can deal with inserts:

          1. for any inserts to same index, combine even if not adjacent.
          2. for any prior replace with same left boundary, combine this
             insert with replace and delete this replace.
          3. throw exception if index in same range as previous replace

        Don't actually delete; make op null in list. Easier to walk list.
        Later we can throw as we add to index -> op map.

        Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
        inserted stuff would be before the replace range.  But, if you
        add tokens in front of a method body '{' and then delete the method
        body, I think the stuff before the '{' you added should disappear too.

        Return a map from token index to operation.
        """
        
        # WALK REPLACES
        for i, rop in enumerate(rewrites):
            if rop is None:
                continue

            if not isinstance(rop, ReplaceOp):
                continue

            # Wipe prior inserts within range
            for j, iop in self.getKindOfOps(rewrites, InsertBeforeOp, i):
                if iop.index >= rop.index and iop.index <= rop.lastIndex:
                    rewrites[j] = None  # delete insert as it's a no-op.

            # Drop any prior replaces contained within
            for j, prevRop in self.getKindOfOps(rewrites, ReplaceOp, i):
                if (prevRop.index >= rop.index
                    and prevRop.lastIndex <= rop.lastIndex):
                    rewrites[j] = None  # delete replace as it's a no-op.
                    continue

                # throw exception unless disjoint or identical
                disjoint = (prevRop.lastIndex < rop.index
                            or prevRop.index > rop.lastIndex)
                same = (prevRop.index == rop.index
                        and prevRop.lastIndex == rop.lastIndex)
                if not disjoint and not same:
                    raise ValueError(
                        "replace op boundaries of %s overlap with previous %s"
                        % (rop, prevRop))

        # WALK INSERTS
        for i, iop in enumerate(rewrites):
            if iop is None:
                continue

            if not isinstance(iop, InsertBeforeOp):
                continue

            # combine current insert with prior if any at same index
            for j, prevIop in self.getKindOfOps(rewrites, InsertBeforeOp, i):
                if prevIop.index == iop.index: # combine objects
                    # convert to strings...we're in process of toString'ing
                    # whole token buffer so no lazy eval issue with any
                    # templates
                    iop.text = self.catOpText(iop.text, prevIop.text)
                    rewrites[j] = None  # delete redundant prior insert

            # look for replaces where iop.index is in range; error
            for j, rop in self.getKindOfOps(rewrites, ReplaceOp, i):
                if iop.index == rop.index:
                    rop.text = self.catOpText(iop.text, rop.text)
                    rewrites[i] = None  # delete current insert
                    continue

                if iop.index >= rop.index and iop.index <= rop.lastIndex:
                    raise ValueError(
                        "insert op %s within boundaries of previous %s"
                        % (iop, rop))
        
        m = {}
        for i, op in enumerate(rewrites):
            if op is None:
                continue # ignore deleted ops

            assert op.index not in m, "should only be one op per index"
            m[op.index] = op

        return m


    def catOpText(self, a, b):
        x = ""
        y = ""
        if a is not None:
            x = a
        if b is not None:
            y = b
        return x + y


    def getKindOfOps(self, rewrites, kind, before=None):
        if before is None:
            before = len(rewrites)
        elif before > len(rewrites):
            before = len(rewrites)

        for i, op in enumerate(rewrites[:before]):
            if op is None:
                # ignore deleted
                continue
            if op.__class__ == kind:
                yield i, op


    def toDebugString(self, start=None, end=None):
        if start is None:
            start = self.MIN_TOKEN_INDEX
        if end is None:
            end = self.size() - 1

        buf = StringIO()
        i = start
        while i >= self.MIN_TOKEN_INDEX and i <= end and i < len(self.tokens):
            buf.write(self.get(i))
            i += 1

        return buf.getvalue()

########NEW FILE########
__FILENAME__ = tokens
"""ANTLR3 runtime package"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

from .constants import EOF, DEFAULT_CHANNEL, INVALID_TOKEN_TYPE

############################################################################
#
# basic token interface
#
############################################################################

class Token(object):
    """@brief Abstract token baseclass."""

    def getText(self):
        """@brief Get the text of the token.

        Using setter/getter methods is deprecated. Use o.text instead.
        """
        raise NotImplementedError
    
    def setText(self, text):
        """@brief Set the text of the token.

        Using setter/getter methods is deprecated. Use o.text instead.
        """
        raise NotImplementedError


    def getType(self):
        """@brief Get the type of the token.

        Using setter/getter methods is deprecated. Use o.type instead."""

        raise NotImplementedError
    
    def setType(self, ttype):
        """@brief Get the type of the token.

        Using setter/getter methods is deprecated. Use o.type instead."""

        raise NotImplementedError
    
    
    def getLine(self):
        """@brief Get the line number on which this token was matched

        Lines are numbered 1..n
        
        Using setter/getter methods is deprecated. Use o.line instead."""

        raise NotImplementedError
    
    def setLine(self, line):
        """@brief Set the line number on which this token was matched

        Using setter/getter methods is deprecated. Use o.line instead."""

        raise NotImplementedError
    
    
    def getCharPositionInLine(self):
        """@brief Get the column of the tokens first character,
        
        Columns are numbered 0..n-1
        
        Using setter/getter methods is deprecated. Use o.charPositionInLine instead."""

        raise NotImplementedError
    
    def setCharPositionInLine(self, pos):
        """@brief Set the column of the tokens first character,

        Using setter/getter methods is deprecated. Use o.charPositionInLine instead."""

        raise NotImplementedError
    

    def getChannel(self):
        """@brief Get the channel of the token

        Using setter/getter methods is deprecated. Use o.channel instead."""

        raise NotImplementedError
    
    def setChannel(self, channel):
        """@brief Set the channel of the token

        Using setter/getter methods is deprecated. Use o.channel instead."""

        raise NotImplementedError
    

    def getTokenIndex(self):
        """@brief Get the index in the input stream.

        An index from 0..n-1 of the token object in the input stream.
        This must be valid in order to use the ANTLRWorks debugger.
        
        Using setter/getter methods is deprecated. Use o.index instead."""

        raise NotImplementedError
    
    def setTokenIndex(self, index):
        """@brief Set the index in the input stream.

        Using setter/getter methods is deprecated. Use o.index instead."""

        raise NotImplementedError


    def getInputStream(self):
        """@brief From what character stream was this token created.

        You don't have to implement but it's nice to know where a Token
        comes from if you have include files etc... on the input."""

        raise NotImplementedError

    def setInputStream(self, input):
        """@brief From what character stream was this token created.

        You don't have to implement but it's nice to know where a Token
        comes from if you have include files etc... on the input."""

        raise NotImplementedError


############################################################################
#
# token implementations
#
# Token
# +- CommonToken
# \- ClassicToken
#
############################################################################

class CommonToken(Token):
    """@brief Basic token implementation.

    This implementation does not copy the text from the input stream upon
    creation, but keeps start/stop pointers into the stream to avoid
    unnecessary copy operations.

    """
    
    def __init__(self, type=None, channel=DEFAULT_CHANNEL, text=None,
                 input=None, start=None, stop=None, oldToken=None):
        Token.__init__(self)
        
        if oldToken is not None:
            self.type = oldToken.type
            self.line = oldToken.line
            self.charPositionInLine = oldToken.charPositionInLine
            self.channel = oldToken.channel
            self.index = oldToken.index
            self._text = oldToken._text
            if isinstance(oldToken, CommonToken):
                self.input = oldToken.input
                self.start = oldToken.start
                self.stop = oldToken.stop
            
        else:
            self.type = type
            self.input = input
            self.charPositionInLine = -1 # set to invalid position
            self.line = 0
            self.channel = channel
            
	    #What token number is this from 0..n-1 tokens; < 0 implies invalid index
            self.index = -1
            
            # We need to be able to change the text once in a while.  If
            # this is non-null, then getText should return this.  Note that
            # start/stop are not affected by changing this.
            self._text = text

            # The char position into the input buffer where this token starts
            self.start = start

            # The char position into the input buffer where this token stops
            # This is the index of the last char, *not* the index after it!
            self.stop = stop


    def getText(self):
        if self._text is not None:
            return self._text

        if self.input is None:
            return None
        
        return self.input.substring(self.start, self.stop)


    def setText(self, text):
        """
        Override the text for this token.  getText() will return this text
        rather than pulling from the buffer.  Note that this does not mean
        that start/stop indexes are not valid.  It means that that input
        was converted to a new string in the token object.
	"""
        self._text = text

    text = property(getText, setText)


    def getType(self):
        return self.type 

    def setType(self, ttype):
        self.type = ttype

    
    def getLine(self):
        return self.line
    
    def setLine(self, line):
        self.line = line


    def getCharPositionInLine(self):
        return self.charPositionInLine
    
    def setCharPositionInLine(self, pos):
        self.charPositionInLine = pos


    def getChannel(self):
        return self.channel
    
    def setChannel(self, channel):
        self.channel = channel
    

    def getTokenIndex(self):
        return self.index
    
    def setTokenIndex(self, index):
        self.index = index


    def getInputStream(self):
        return self.input

    def setInputStream(self, input):
        self.input = input


    def __str__(self):
        if self.type == EOF:
            return "<EOF>"

        channelStr = ""
        if self.channel > 0:
            channelStr = ",channel=" + str(self.channel)

        txt = self.text
        if txt is not None:
            txt = txt.replace("\n","\\\\n")
            txt = txt.replace("\r","\\\\r")
            txt = txt.replace("\t","\\\\t")
        else:
            txt = "<no text>"

        return "[@%d,%d:%d=%r,<%d>%s,%d:%d]" % (
            self.index,
            self.start, self.stop,
            txt,
            self.type, channelStr,
            self.line, self.charPositionInLine
            )
    

class ClassicToken(Token):
    """@brief Alternative token implementation.
    
    A Token object like we'd use in ANTLR 2.x; has an actual string created
    and associated with this object.  These objects are needed for imaginary
    tree nodes that have payload objects.  We need to create a Token object
    that has a string; the tree node will point at this token.  CommonToken
    has indexes into a char stream and hence cannot be used to introduce
    new strings.
    """

    def __init__(self, type=None, text=None, channel=DEFAULT_CHANNEL,
                 oldToken=None
                 ):
        Token.__init__(self)
        
        if oldToken is not None:
            self.text = oldToken.text
            self.type = oldToken.type
            self.line = oldToken.line
            self.charPositionInLine = oldToken.charPositionInLine
            self.channel = oldToken.channel
            
        self.text = text
        self.type = type
        self.line = None
        self.charPositionInLine = None
        self.channel = channel
        self.index = None


    def getText(self):
        return self.text

    def setText(self, text):
        self.text = text


    def getType(self):
        return self.type 

    def setType(self, ttype):
        self.type = ttype

    
    def getLine(self):
        return self.line
    
    def setLine(self, line):
        self.line = line


    def getCharPositionInLine(self):
        return self.charPositionInLine
    
    def setCharPositionInLine(self, pos):
        self.charPositionInLine = pos


    def getChannel(self):
        return self.channel
    
    def setChannel(self, channel):
        self.channel = channel
    

    def getTokenIndex(self):
        return self.index
    
    def setTokenIndex(self, index):
        self.index = index


    def getInputStream(self):
        return None

    def setInputStream(self, input):
        pass


    def toString(self):
        channelStr = ""
        if self.channel > 0:
            channelStr = ",channel=" + str(self.channel)
            
        txt = self.text
        if txt is None:
            txt = "<no text>"

        return "[@%r,%r,<%r>%s,%r:%r]" % (self.index,
                                          txt,
                                          self.type,
                                          channelStr,
                                          self.line,
                                          self.charPositionInLine
                                          )
    

    __str__ = toString
    __repr__ = toString



EOF_TOKEN = CommonToken(type=EOF)
	
INVALID_TOKEN = CommonToken(type=INVALID_TOKEN_TYPE)

# In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
# will avoid creating a token for this symbol and try to fetch another.
SKIP_TOKEN = CommonToken(type=INVALID_TOKEN_TYPE)



########NEW FILE########
__FILENAME__ = tree
""" @package antlr3.tree
@brief ANTLR3 runtime package, tree module

This module contains all support classes for AST construction and tree parsers.

"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

# lot's of docstrings are missing, don't complain for now...
# pylint: disable-msg=C0111

import re

from .constants import UP, DOWN, EOF, INVALID_TOKEN_TYPE
from .recognizers import BaseRecognizer, RuleReturnScope
from .streams import IntStream
from .tokens import CommonToken, Token, INVALID_TOKEN
from .exceptions import MismatchedTreeNodeException, \
     MissingTokenException, UnwantedTokenException, MismatchedTokenException, \
     NoViableAltException


############################################################################
#
# tree related exceptions
#
############################################################################


class RewriteCardinalityException(RuntimeError):
    """
    @brief Base class for all exceptions thrown during AST rewrite construction.

    This signifies a case where the cardinality of two or more elements
    in a subrule are different: (ID INT)+ where |ID|!=|INT|
    """

    def __init__(self, elementDescription):
        RuntimeError.__init__(self, elementDescription)

        self.elementDescription = elementDescription


    def getMessage(self):
        return self.elementDescription


class RewriteEarlyExitException(RewriteCardinalityException):
    """@brief No elements within a (...)+ in a rewrite rule"""

    def __init__(self, elementDescription=None):
        RewriteCardinalityException.__init__(self, elementDescription)


class RewriteEmptyStreamException(RewriteCardinalityException):
    """
    @brief Ref to ID or expr but no tokens in ID stream or subtrees in expr stream
    """

    pass


############################################################################
#
# basic Tree and TreeAdaptor interfaces
#
############################################################################

class Tree(object):
    """
    @brief Abstract baseclass for tree nodes.
    
    What does a tree look like?  ANTLR has a number of support classes
    such as CommonTreeNodeStream that work on these kinds of trees.  You
    don't have to make your trees implement this interface, but if you do,
    you'll be able to use more support code.

    NOTE: When constructing trees, ANTLR can build any kind of tree; it can
    even use Token objects as trees if you add a child list to your tokens.
    
    This is a tree node without any payload; just navigation and factory stuff.
    """


    def getChild(self, i):
        raise NotImplementedError
    

    def getChildCount(self):
        raise NotImplementedError
    

    def getParent(self):
        """Tree tracks parent and child index now > 3.0"""

        raise NotImplementedError
    
    def setParent(self, t):
        """Tree tracks parent and child index now > 3.0"""

        raise NotImplementedError
    

    def hasAncestor(self, ttype):
        """Walk upwards looking for ancestor with this token type."""

        raise NotImplementedError

    def getAncestor(self, ttype):
        """Walk upwards and get first ancestor with this token type."""

        raise NotImplementedError

    def getAncestors(self):
        """Return a list of all ancestors of this node.

        The first node of list is the root and the last is the parent of
        this node.
        """

        raise NotImplementedError


    def getChildIndex(self):
        """This node is what child index? 0..n-1"""

        raise NotImplementedError
        
    def setChildIndex(self, index):
        """This node is what child index? 0..n-1"""

        raise NotImplementedError
        

    def freshenParentAndChildIndexes(self):
        """Set the parent and child index values for all children"""
        
        raise NotImplementedError

        
    def addChild(self, t):
        """
        Add t as a child to this node.  If t is null, do nothing.  If t
        is nil, add all children of t to this' children.
        """

        raise NotImplementedError
    

    def setChild(self, i, t):
        """Set ith child (0..n-1) to t; t must be non-null and non-nil node"""

        raise NotImplementedError

            
    def deleteChild(self, i):
        raise NotImplementedError
        
 
    def replaceChildren(self, startChildIndex, stopChildIndex, t):
        """
        Delete children from start to stop and replace with t even if t is
        a list (nil-root tree).  num of children can increase or decrease.
        For huge child lists, inserting children can force walking rest of
        children to set their childindex; could be slow.
        """

        raise NotImplementedError


    def isNil(self):
        """
        Indicates the node is a nil node but may still have children, meaning
        the tree is a flat list.
        """

        raise NotImplementedError
    

    def getTokenStartIndex(self):
        """
        What is the smallest token index (indexing from 0) for this node
           and its children?
        """

        raise NotImplementedError


    def setTokenStartIndex(self, index):
        raise NotImplementedError


    def getTokenStopIndex(self):
        """
        What is the largest token index (indexing from 0) for this node
        and its children?
        """

        raise NotImplementedError


    def setTokenStopIndex(self, index):
        raise NotImplementedError


    def dupNode(self):
        raise NotImplementedError
    
    
    def getType(self):
        """Return a token type; needed for tree parsing."""

        raise NotImplementedError
    

    def getText(self):
        raise NotImplementedError
    

    def getLine(self):
        """
        In case we don't have a token payload, what is the line for errors?
        """

        raise NotImplementedError
    

    def getCharPositionInLine(self):
        raise NotImplementedError


    def toStringTree(self):
        raise NotImplementedError


    def toString(self):
        raise NotImplementedError



class TreeAdaptor(object):
    """
    @brief Abstract baseclass for tree adaptors.
    
    How to create and navigate trees.  Rather than have a separate factory
    and adaptor, I've merged them.  Makes sense to encapsulate.

    This takes the place of the tree construction code generated in the
    generated code in 2.x and the ASTFactory.

    I do not need to know the type of a tree at all so they are all
    generic Objects.  This may increase the amount of typecasting needed. :(
    """
    
    # C o n s t r u c t i o n

    def createWithPayload(self, payload):
        """
        Create a tree node from Token object; for CommonTree type trees,
        then the token just becomes the payload.  This is the most
        common create call.

        Override if you want another kind of node to be built.
        """

        raise NotImplementedError
    

    def dupNode(self, treeNode):
        """Duplicate a single tree node.

        Override if you want another kind of node to be built."""

        raise NotImplementedError


    def dupTree(self, tree):
        """Duplicate tree recursively, using dupNode() for each node"""

        raise NotImplementedError


    def nil(self):
        """
        Return a nil node (an empty but non-null node) that can hold
        a list of element as the children.  If you want a flat tree (a list)
        use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
        """

        raise NotImplementedError


    def errorNode(self, input, start, stop, exc):
        """
        Return a tree node representing an error.  This node records the
        tokens consumed during error recovery.  The start token indicates the
        input symbol at which the error was detected.  The stop token indicates
        the last symbol consumed during recovery.

        You must specify the input stream so that the erroneous text can
        be packaged up in the error node.  The exception could be useful
        to some applications; default implementation stores ptr to it in
        the CommonErrorNode.

        This only makes sense during token parsing, not tree parsing.
        Tree parsing should happen only when parsing and tree construction
        succeed.
        """

        raise NotImplementedError


    def isNil(self, tree):
        """Is tree considered a nil node used to make lists of child nodes?"""

        raise NotImplementedError


    def addChild(self, t, child):
        """
        Add a child to the tree t.  If child is a flat tree (a list), make all
        in list children of t.  Warning: if t has no children, but child does
        and child isNil then you can decide it is ok to move children to t via
        t.children = child.children; i.e., without copying the array.  Just
        make sure that this is consistent with have the user will build
        ASTs. Do nothing if t or child is null.
        """

        raise NotImplementedError


    def becomeRoot(self, newRoot, oldRoot):
        """
        If oldRoot is a nil root, just copy or move the children to newRoot.
        If not a nil root, make oldRoot a child of newRoot.
        
           old=^(nil a b c), new=r yields ^(r a b c)
           old=^(a b c), new=r yields ^(r ^(a b c))

        If newRoot is a nil-rooted single child tree, use the single
        child as the new root node.

           old=^(nil a b c), new=^(nil r) yields ^(r a b c)
           old=^(a b c), new=^(nil r) yields ^(r ^(a b c))

        If oldRoot was null, it's ok, just return newRoot (even if isNil).

           old=null, new=r yields r
           old=null, new=^(nil r) yields ^(nil r)

        Return newRoot.  Throw an exception if newRoot is not a
        simple node or nil root with a single child node--it must be a root
        node.  If newRoot is ^(nil x) return x as newRoot.

        Be advised that it's ok for newRoot to point at oldRoot's
        children; i.e., you don't have to copy the list.  We are
        constructing these nodes so we should have this control for
        efficiency.
        """

        raise NotImplementedError


    def rulePostProcessing(self, root):
        """
        Given the root of the subtree created for this rule, post process
        it to do any simplifications or whatever you want.  A required
        behavior is to convert ^(nil singleSubtree) to singleSubtree
        as the setting of start/stop indexes relies on a single non-nil root
        for non-flat trees.

        Flat trees such as for lists like "idlist : ID+ ;" are left alone
        unless there is only one ID.  For a list, the start/stop indexes
        are set in the nil node.

        This method is executed after all rule tree construction and right
        before setTokenBoundaries().
        """

        raise NotImplementedError


    def getUniqueID(self, node):
        """For identifying trees.

        How to identify nodes so we can say "add node to a prior node"?
        Even becomeRoot is an issue.  Use System.identityHashCode(node)
        usually.
        """

        raise NotImplementedError


    # R e w r i t e  R u l e s

    def createFromToken(self, tokenType, fromToken, text=None):
        """
        Create a new node derived from a token, with a new token type and
        (optionally) new text.

        This is invoked from an imaginary node ref on right side of a
        rewrite rule as IMAG[$tokenLabel] or IMAG[$tokenLabel "IMAG"].

        This should invoke createToken(Token).
        """

        raise NotImplementedError


    def createFromType(self, tokenType, text):
        """Create a new node derived from a token, with a new token type.

        This is invoked from an imaginary node ref on right side of a
        rewrite rule as IMAG["IMAG"].

        This should invoke createToken(int,String).
        """

        raise NotImplementedError


    # C o n t e n t

    def getType(self, t):
        """For tree parsing, I need to know the token type of a node"""

        raise NotImplementedError


    def setType(self, t, type):
        """Node constructors can set the type of a node"""

        raise NotImplementedError


    def getText(self, t):
        raise NotImplementedError

    def setText(self, t, text):
        """Node constructors can set the text of a node"""

        raise NotImplementedError


    def getToken(self, t):
        """Return the token object from which this node was created.

        Currently used only for printing an error message.
        The error display routine in BaseRecognizer needs to
        display where the input the error occurred. If your
        tree of limitation does not store information that can
        lead you to the token, you can create a token filled with
        the appropriate information and pass that back.  See
        BaseRecognizer.getErrorMessage().
        """

        raise NotImplementedError


    def setTokenBoundaries(self, t, startToken, stopToken):
        """
        Where are the bounds in the input token stream for this node and
        all children?  Each rule that creates AST nodes will call this
        method right before returning.  Flat trees (i.e., lists) will
        still usually have a nil root node just to hold the children list.
        That node would contain the start/stop indexes then.
        """

        raise NotImplementedError


    def getTokenStartIndex(self, t):
        """
        Get the token start index for this subtree; return -1 if no such index
        """

        raise NotImplementedError

        
    def getTokenStopIndex(self, t):
        """
        Get the token stop index for this subtree; return -1 if no such index
        """

        raise NotImplementedError
        

    # N a v i g a t i o n  /  T r e e  P a r s i n g

    def getChild(self, t, i):
        """Get a child 0..n-1 node"""

        raise NotImplementedError


    def setChild(self, t, i, child):
        """Set ith child (0..n-1) to t; t must be non-null and non-nil node"""

        raise NotImplementedError


    def deleteChild(self, t, i):
        """Remove ith child and shift children down from right."""
        
        raise NotImplementedError


    def getChildCount(self, t):
        """How many children?  If 0, then this is a leaf node"""

        raise NotImplementedError


    def getParent(self, t):
        """
        Who is the parent node of this node; if null, implies node is root.
        If your node type doesn't handle this, it's ok but the tree rewrites
        in tree parsers need this functionality.
        """
        
        raise NotImplementedError


    def setParent(self, t, parent):
        """
        Who is the parent node of this node; if null, implies node is root.
        If your node type doesn't handle this, it's ok but the tree rewrites
        in tree parsers need this functionality.
        """

        raise NotImplementedError


    def getChildIndex(self, t):
        """
        What index is this node in the child list? Range: 0..n-1
        If your node type doesn't handle this, it's ok but the tree rewrites
        in tree parsers need this functionality.
        """

        raise NotImplementedError

        
    def setChildIndex(self, t, index):
        """
        What index is this node in the child list? Range: 0..n-1
        If your node type doesn't handle this, it's ok but the tree rewrites
        in tree parsers need this functionality.
        """

        raise NotImplementedError


    def replaceChildren(self, parent, startChildIndex, stopChildIndex, t):
        """
        Replace from start to stop child index of parent with t, which might
        be a list.  Number of children may be different
        after this call.

        If parent is null, don't do anything; must be at root of overall tree.
        Can't replace whatever points to the parent externally.  Do nothing.
        """

        raise NotImplementedError


    # Misc

    def create(self, *args):
        """
        Deprecated, use createWithPayload, createFromToken or createFromType.

        This method only exists to mimic the Java interface of TreeAdaptor.
        
        """

        if len(args) == 1 and isinstance(args[0], Token):
            # Object create(Token payload);
##             warnings.warn(
##                 "Using create() is deprecated, use createWithPayload()",
##                 DeprecationWarning,
##                 stacklevel=2
##                 )
            return self.createWithPayload(args[0])

        if (len(args) == 2
            and isinstance(args[0], (int, long))
            and isinstance(args[1], Token)
            ):
            # Object create(int tokenType, Token fromToken);
##             warnings.warn(
##                 "Using create() is deprecated, use createFromToken()",
##                 DeprecationWarning,
##                 stacklevel=2
##                 )
            return self.createFromToken(args[0], args[1])

        if (len(args) == 3
            and isinstance(args[0], (int, long))
            and isinstance(args[1], Token)
            and isinstance(args[2], basestring)
            ):
            # Object create(int tokenType, Token fromToken, String text);
##             warnings.warn(
##                 "Using create() is deprecated, use createFromToken()",
##                 DeprecationWarning,
##                 stacklevel=2
##                 )
            return self.createFromToken(args[0], args[1], args[2])

        if (len(args) == 2
            and isinstance(args[0], (int, long))
            and isinstance(args[1], basestring)
            ):
            # Object create(int tokenType, String text);
##             warnings.warn(
##                 "Using create() is deprecated, use createFromType()",
##                 DeprecationWarning,
##                 stacklevel=2
##                 )
            return self.createFromType(args[0], args[1])

        raise TypeError(
            "No create method with this signature found: %s"
            % (', '.join(type(v).__name__ for v in args))
            )
    

############################################################################
#
# base implementation of Tree and TreeAdaptor
#
# Tree
# \- BaseTree
#
# TreeAdaptor
# \- BaseTreeAdaptor
#
############################################################################


class BaseTree(Tree):
    """
    @brief A generic tree implementation with no payload.

    You must subclass to
    actually have any user data.  ANTLR v3 uses a list of children approach
    instead of the child-sibling approach in v2.  A flat tree (a list) is
    an empty node whose children represent the list.  An empty, but
    non-null node is called "nil".
    """

    # BaseTree is abstract, no need to complain about not implemented abstract
    # methods
    # pylint: disable-msg=W0223
    
    def __init__(self, node=None):
        """
        Create a new node from an existing node does nothing for BaseTree
        as there are no fields other than the children list, which cannot
        be copied as the children are not considered part of this node. 
        """
        
        Tree.__init__(self)
        self.children = []
        self.parent = None
        self.childIndex = 0
        

    def getChild(self, i):
        try:
            return self.children[i]
        except IndexError:
            return None


    def getChildren(self):
        """@brief Get the children internal List

        Note that if you directly mess with
        the list, do so at your own risk.
        """
        
        # FIXME: mark as deprecated
        return self.children


    def getFirstChildWithType(self, treeType):
        for child in self.children:
            if child.getType() == treeType:
                return child

        return None


    def getChildCount(self):
        return len(self.children)


    def addChild(self, childTree):
        """Add t as child of this node.

        Warning: if t has no children, but child does
        and child isNil then this routine moves children to t via
        t.children = child.children; i.e., without copying the array.
        """

        # this implementation is much simpler and probably less efficient
        # than the mumbo-jumbo that Ter did for the Java runtime.
        
        if childTree is None:
            return

        if childTree.isNil():
            # t is an empty node possibly with children

            if self.children is childTree.children:
                raise ValueError("attempt to add child list to itself")

            # fix parent pointer and childIndex for new children
            for idx, child in enumerate(childTree.children):
                child.parent = self
                child.childIndex = len(self.children) + idx
                
            self.children += childTree.children

        else:
            # child is not nil (don't care about children)
            self.children.append(childTree)
            childTree.parent = self
            childTree.childIndex = len(self.children) - 1


    def addChildren(self, children):
        """Add all elements of kids list as children of this node"""

        self.children += children


    def setChild(self, i, t):
        if t is None:
            return

        if t.isNil():
            raise ValueError("Can't set single child to a list")
        
        self.children[i] = t
        t.parent = self
        t.childIndex = i
        

    def deleteChild(self, i):
        killed = self.children[i]
        
        del self.children[i]
        
        # walk rest and decrement their child indexes
        for idx, child in enumerate(self.children[i:]):
            child.childIndex = i + idx
            
        return killed

    
    def replaceChildren(self, startChildIndex, stopChildIndex, newTree):
        """
        Delete children from start to stop and replace with t even if t is
        a list (nil-root tree).  num of children can increase or decrease.
        For huge child lists, inserting children can force walking rest of
        children to set their childindex; could be slow.
        """

        if (startChildIndex >= len(self.children)
            or stopChildIndex >= len(self.children)
            ):
            raise IndexError("indexes invalid")

        replacingHowMany = stopChildIndex - startChildIndex + 1

        # normalize to a list of children to add: newChildren
        if newTree.isNil():
            newChildren = newTree.children

        else:
            newChildren = [newTree]

        replacingWithHowMany = len(newChildren)
        delta = replacingHowMany - replacingWithHowMany
        
        
        if delta == 0:
            # if same number of nodes, do direct replace
            for idx, child in enumerate(newChildren):
                self.children[idx + startChildIndex] = child
                child.parent = self
                child.childIndex = idx + startChildIndex

        else:
            # length of children changes...

            # ...delete replaced segment...
            del self.children[startChildIndex:stopChildIndex+1]

            # ...insert new segment...
            self.children[startChildIndex:startChildIndex] = newChildren

            # ...and fix indeces
            self.freshenParentAndChildIndexes(startChildIndex)
            

    def isNil(self):
        return False


    def freshenParentAndChildIndexes(self, offset=0):
        for idx, child in enumerate(self.children[offset:]):
            child.childIndex = idx + offset
            child.parent = self


    def sanityCheckParentAndChildIndexes(self, parent=None, i=-1):
        if parent != self.parent:
            raise ValueError(
                "parents don't match; expected %r found %r"
                % (parent, self.parent)
                )
        
        if i != self.childIndex:
            raise ValueError(
                "child indexes don't match; expected %d found %d"
                % (i, self.childIndex)
                )

        for idx, child in enumerate(self.children):
            child.sanityCheckParentAndChildIndexes(self, idx)


    def getChildIndex(self):
        """BaseTree doesn't track child indexes."""
        
        return 0


    def setChildIndex(self, index):
        """BaseTree doesn't track child indexes."""

        pass
    

    def getParent(self):
        """BaseTree doesn't track parent pointers."""

        return None

    def setParent(self, t):
        """BaseTree doesn't track parent pointers."""

        pass


    def hasAncestor(self, ttype):
        """Walk upwards looking for ancestor with this token type."""
        return self.getAncestor(ttype) is not None

    def getAncestor(self, ttype):
        """Walk upwards and get first ancestor with this token type."""
        t = self.getParent()
        while t is not None:
            if t.getType() == ttype:
                return t
            t = t.getParent()

        return None

    def getAncestors(self):
        """Return a list of all ancestors of this node.

        The first node of list is the root and the last is the parent of
        this node.
        """
        if selfgetParent() is None:
            return None

        ancestors = []
        t = self.getParent()
        while t is not None:
            ancestors.insert(0, t) # insert at start
            t = t.getParent()

        return ancestors


    def toStringTree(self):
        """Print out a whole tree not just a node"""

        if len(self.children) == 0:
            return self.toString()

        buf = []
        if not self.isNil():
            buf.append('(')
            buf.append(self.toString())
            buf.append(' ')

        for i, child in enumerate(self.children):
            if i > 0:
                buf.append(' ')
            buf.append(child.toStringTree())

        if not self.isNil():
            buf.append(')')

        return ''.join(buf)


    def getLine(self):
        return 0


    def getCharPositionInLine(self):
        return 0


    def toString(self):
        """Override to say how a node (not a tree) should look as text"""

        raise NotImplementedError



class BaseTreeAdaptor(TreeAdaptor):
    """
    @brief A TreeAdaptor that works with any Tree implementation.
    """
    
    # BaseTreeAdaptor is abstract, no need to complain about not implemented
    # abstract methods
    # pylint: disable-msg=W0223
    
    def nil(self):
        return self.createWithPayload(None)


    def errorNode(self, input, start, stop, exc):
        """
        create tree node that holds the start and stop tokens associated
        with an error.

        If you specify your own kind of tree nodes, you will likely have to
        override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
        if no token payload but you might have to set token type for diff
        node type.

        You don't have to subclass CommonErrorNode; you will likely need to
        subclass your own tree node class to avoid class cast exception.
        """
        
        return CommonErrorNode(input, start, stop, exc)
    

    def isNil(self, tree):
        return tree.isNil()


    def dupTree(self, t, parent=None):
        """
        This is generic in the sense that it will work with any kind of
        tree (not just Tree interface).  It invokes the adaptor routines
        not the tree node routines to do the construction.
        """

        if t is None:
            return None

        newTree = self.dupNode(t)
        
        # ensure new subtree root has parent/child index set

        # same index in new tree
        self.setChildIndex(newTree, self.getChildIndex(t))
        
        self.setParent(newTree, parent)

        for i in range(self.getChildCount(t)):
            child = self.getChild(t, i)
            newSubTree = self.dupTree(child, t)
            self.addChild(newTree, newSubTree)

        return newTree


    def addChild(self, tree, child):
        """
        Add a child to the tree t.  If child is a flat tree (a list), make all
        in list children of t.  Warning: if t has no children, but child does
        and child isNil then you can decide it is ok to move children to t via
        t.children = child.children; i.e., without copying the array.  Just
        make sure that this is consistent with have the user will build
        ASTs.
        """

        #if isinstance(child, Token):
        #    child = self.createWithPayload(child)
        
        if tree is not None and child is not None:
            tree.addChild(child)


    def becomeRoot(self, newRoot, oldRoot):
        """
        If oldRoot is a nil root, just copy or move the children to newRoot.
        If not a nil root, make oldRoot a child of newRoot.

          old=^(nil a b c), new=r yields ^(r a b c)
          old=^(a b c), new=r yields ^(r ^(a b c))

        If newRoot is a nil-rooted single child tree, use the single
        child as the new root node.

          old=^(nil a b c), new=^(nil r) yields ^(r a b c)
          old=^(a b c), new=^(nil r) yields ^(r ^(a b c))

        If oldRoot was null, it's ok, just return newRoot (even if isNil).

          old=null, new=r yields r
          old=null, new=^(nil r) yields ^(nil r)

        Return newRoot.  Throw an exception if newRoot is not a
        simple node or nil root with a single child node--it must be a root
        node.  If newRoot is ^(nil x) return x as newRoot.

        Be advised that it's ok for newRoot to point at oldRoot's
        children; i.e., you don't have to copy the list.  We are
        constructing these nodes so we should have this control for
        efficiency.
        """

        if isinstance(newRoot, Token):
            newRoot = self.create(newRoot)

        if oldRoot is None:
            return newRoot
        
        if not isinstance(newRoot, CommonTree):
            newRoot = self.createWithPayload(newRoot)

        # handle ^(nil real-node)
        if newRoot.isNil():
            nc = newRoot.getChildCount()
            if nc == 1:
                newRoot = newRoot.getChild(0)
                
            elif nc > 1:
                # TODO: make tree run time exceptions hierarchy
                raise RuntimeError("more than one node as root")

        # add oldRoot to newRoot; addChild takes care of case where oldRoot
        # is a flat list (i.e., nil-rooted tree).  All children of oldRoot
        # are added to newRoot.
        newRoot.addChild(oldRoot)
        return newRoot


    def rulePostProcessing(self, root):
        """Transform ^(nil x) to x and nil to null"""
        
        if root is not None and root.isNil():
            if root.getChildCount() == 0:
                root = None

            elif root.getChildCount() == 1:
                root = root.getChild(0)
                # whoever invokes rule will set parent and child index
                root.setParent(None)
                root.setChildIndex(-1)

        return root


    def createFromToken(self, tokenType, fromToken, text=None):
        assert isinstance(tokenType, (int, long)), type(tokenType).__name__
        assert isinstance(fromToken, Token), type(fromToken).__name__
        assert text is None or isinstance(text, basestring), type(text).__name__

        fromToken = self.createToken(fromToken)
        fromToken.type = tokenType
        if text is not None:
            fromToken.text = text
        t = self.createWithPayload(fromToken)
        return t


    def createFromType(self, tokenType, text):
        assert isinstance(tokenType, (int, long)), type(tokenType).__name__
        assert isinstance(text, basestring) or text is None, type(text).__name__
                          
        fromToken = self.createToken(tokenType=tokenType, text=text)
        t = self.createWithPayload(fromToken)
        return t


    def getType(self, t):
        return t.getType()


    def setType(self, t, type):
        raise RuntimeError("don't know enough about Tree node")


    def getText(self, t):
        return t.getText()


    def setText(self, t, text):
        raise RuntimeError("don't know enough about Tree node")


    def getChild(self, t, i):
        return t.getChild(i)


    def setChild(self, t, i, child):
        t.setChild(i, child)


    def deleteChild(self, t, i):
        return t.deleteChild(i)


    def getChildCount(self, t):
        return t.getChildCount()


    def getUniqueID(self, node):
        return hash(node)


    def createToken(self, fromToken=None, tokenType=None, text=None):
        """
        Tell me how to create a token for use with imaginary token nodes.
        For example, there is probably no input symbol associated with imaginary
        token DECL, but you need to create it as a payload or whatever for
        the DECL node as in ^(DECL type ID).

        If you care what the token payload objects' type is, you should
        override this method and any other createToken variant.
        """

        raise NotImplementedError


############################################################################
#
# common tree implementation
#
# Tree
# \- BaseTree
#    \- CommonTree
#       \- CommonErrorNode
#
# TreeAdaptor
# \- BaseTreeAdaptor
#    \- CommonTreeAdaptor
#
############################################################################


class CommonTree(BaseTree):
    """@brief A tree node that is wrapper for a Token object.

    After 3.0 release
    while building tree rewrite stuff, it became clear that computing
    parent and child index is very difficult and cumbersome.  Better to
    spend the space in every tree node.  If you don't want these extra
    fields, it's easy to cut them out in your own BaseTree subclass.
    
    """

    def __init__(self, payload):
        BaseTree.__init__(self)
        
        # What token indexes bracket all tokens associated with this node
        # and below?
        self.startIndex = -1
        self.stopIndex = -1

        # Who is the parent node of this node; if null, implies node is root
        self.parent = None
        
        # What index is this node in the child list? Range: 0..n-1
        self.childIndex = -1

        # A single token is the payload
        if payload is None:
            self.token = None
            
        elif isinstance(payload, CommonTree):
            self.token = payload.token
            self.startIndex = payload.startIndex
            self.stopIndex = payload.stopIndex
            
        elif payload is None or isinstance(payload, Token):
            self.token = payload
            
        else:
            raise TypeError(type(payload).__name__)



    def getToken(self):
        return self.token


    def dupNode(self):
        return CommonTree(self)


    def isNil(self):
        return self.token is None


    def getType(self):
        if self.token is None:
            return INVALID_TOKEN_TYPE

        return self.token.getType()

    type = property(getType)
    

    def getText(self):
        if self.token is None:
            return None
        
        return self.token.text

    text = property(getText)
    

    def getLine(self):
        if self.token is None or self.token.getLine() == 0:
            if self.getChildCount():
                return self.getChild(0).getLine()
            else:
                return 0

        return self.token.getLine()

    line = property(getLine)
    

    def getCharPositionInLine(self):
        if self.token is None or self.token.getCharPositionInLine() == -1:
            if self.getChildCount():
                return self.getChild(0).getCharPositionInLine()
            else:
                return 0

        else:
            return self.token.getCharPositionInLine()

    charPositionInLine = property(getCharPositionInLine)
    

    def getTokenStartIndex(self):
        if self.startIndex == -1 and self.token is not None:
            return self.token.getTokenIndex()
        
        return self.startIndex
    
    def setTokenStartIndex(self, index):
        self.startIndex = index

    tokenStartIndex = property(getTokenStartIndex, setTokenStartIndex)


    def getTokenStopIndex(self):
        if self.stopIndex == -1 and self.token is not None:
            return self.token.getTokenIndex()
        
        return self.stopIndex

    def setTokenStopIndex(self, index):
        self.stopIndex = index

    tokenStopIndex = property(getTokenStopIndex, setTokenStopIndex)


    def setUnknownTokenBoundaries(self):
        """For every node in this subtree, make sure it's start/stop token's
        are set.  Walk depth first, visit bottom up.  Only updates nodes
        with at least one token index < 0.
        """

        if self.children is None:
            if self.startIndex < 0 or self.stopIndex < 0:
                self.startIndex = self.stopIndex = self.token.getTokenIndex()

            return
 
        for child in self.children:
            child.setUnknownTokenBoundaries()

        if self.startIndex >= 0 and self.stopIndex >= 0:
            # already set
            return

        if self.children:
            firstChild = self.children[0]
            lastChild = self.children[-1]
            self.startIndex = firstChild.getTokenStartIndex()
            self.stopIndex = lastChild.getTokenStopIndex()


    def getChildIndex(self):
        #FIXME: mark as deprecated
        return self.childIndex


    def setChildIndex(self, idx):
        #FIXME: mark as deprecated
        self.childIndex = idx


    def getParent(self):
        #FIXME: mark as deprecated
        return self.parent


    def setParent(self, t):
        #FIXME: mark as deprecated
        self.parent = t

        
    def toString(self):
        if self.isNil():
            return "nil"

        if self.getType() == INVALID_TOKEN_TYPE:
            return "<errornode>"

        return self.token.text

    __str__ = toString   



    def toStringTree(self):
        if not self.children:
            return self.toString()

        ret = ''
        if not self.isNil():
            ret += '(%s ' % (self.toString())
        
        ret += ' '.join([child.toStringTree() for child in self.children])

        if not self.isNil():
            ret += ')'

        return ret


INVALID_NODE = CommonTree(INVALID_TOKEN)


class CommonErrorNode(CommonTree):
    """A node representing erroneous token range in token stream"""

    def __init__(self, input, start, stop, exc):
        CommonTree.__init__(self, None)

        if (stop is None or
            (stop.getTokenIndex() < start.getTokenIndex() and
             stop.getType() != EOF
             )
            ):
            # sometimes resync does not consume a token (when LT(1) is
            # in follow set.  So, stop will be 1 to left to start. adjust.
            # Also handle case where start is the first token and no token
            # is consumed during recovery; LT(-1) will return null.
            stop = start

        self.input = input
        self.start = start
        self.stop = stop
        self.trappedException = exc


    def isNil(self):
        return False


    def getType(self):
        return INVALID_TOKEN_TYPE


    def getText(self):
        if isinstance(self.start, Token):
            i = self.start.getTokenIndex()
            j = self.stop.getTokenIndex()
            if self.stop.getType() == EOF:
                j = self.input.size()

            badText = self.input.toString(i, j)

        elif isinstance(self.start, Tree):
            badText = self.input.toString(self.start, self.stop)

        else:
            # people should subclass if they alter the tree type so this
            # next one is for sure correct.
            badText = "<unknown>"

        return badText


    def toString(self):
        if isinstance(self.trappedException, MissingTokenException):
            return ("<missing type: "
                    + str(self.trappedException.getMissingType())
                    + ">")

        elif isinstance(self.trappedException, UnwantedTokenException):
            return ("<extraneous: "
                    + str(self.trappedException.getUnexpectedToken())
                    + ", resync=" + self.getText() + ">")

        elif isinstance(self.trappedException, MismatchedTokenException):
            return ("<mismatched token: "
                    + str(self.trappedException.token)
                    + ", resync=" + self.getText() + ">")

        elif isinstance(self.trappedException, NoViableAltException):
            return ("<unexpected: "
                    + str(self.trappedException.token)
                    + ", resync=" + self.getText() + ">")

        return "<error: "+self.getText()+">"


class CommonTreeAdaptor(BaseTreeAdaptor):
    """
    @brief A TreeAdaptor that works with any Tree implementation.
    
    It provides
    really just factory methods; all the work is done by BaseTreeAdaptor.
    If you would like to have different tokens created than ClassicToken
    objects, you need to override this and then set the parser tree adaptor to
    use your subclass.

    To get your parser to build nodes of a different type, override
    create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
    dupNode is called to duplicate nodes during rewrite operations.
    """
    
    def dupNode(self, treeNode):
        """
        Duplicate a node.  This is part of the factory;
        override if you want another kind of node to be built.

        I could use reflection to prevent having to override this
        but reflection is slow.
        """

        if treeNode is None:
            return None
        
        return treeNode.dupNode()


    def createWithPayload(self, payload):
        return CommonTree(payload)


    def createToken(self, fromToken=None, tokenType=None, text=None):
        """
        Tell me how to create a token for use with imaginary token nodes.
        For example, there is probably no input symbol associated with imaginary
        token DECL, but you need to create it as a payload or whatever for
        the DECL node as in ^(DECL type ID).

        If you care what the token payload objects' type is, you should
        override this method and any other createToken variant.
        """
        
        if fromToken is not None:
            return CommonToken(oldToken=fromToken)

        return CommonToken(type=tokenType, text=text)


    def setTokenBoundaries(self, t, startToken, stopToken):
        """
        Track start/stop token for subtree root created for a rule.
        Only works with Tree nodes.  For rules that match nothing,
        seems like this will yield start=i and stop=i-1 in a nil node.
        Might be useful info so I'll not force to be i..i.
        """
        
        if t is None:
            return

        start = 0
        stop = 0
        
        if startToken is not None:
            start = startToken.index
                
        if stopToken is not None:
            stop = stopToken.index

        t.setTokenStartIndex(start)
        t.setTokenStopIndex(stop)


    def getTokenStartIndex(self, t):
        if t is None:
            return -1
        return t.getTokenStartIndex()


    def getTokenStopIndex(self, t):
        if t is None:
            return -1
        return t.getTokenStopIndex()


    def getText(self, t):
        if t is None:
            return None
        return t.getText()


    def getType(self, t):
        if t is None:
            return INVALID_TOKEN_TYPE
        
        return t.getType()


    def getToken(self, t):
        """
        What is the Token associated with this node?  If
        you are not using CommonTree, then you must
        override this in your own adaptor.
        """

        if isinstance(t, CommonTree):
            return t.getToken()

        return None # no idea what to do


    def getChild(self, t, i):
        if t is None:
            return None
        return t.getChild(i)


    def getChildCount(self, t):
        if t is None:
            return 0
        return t.getChildCount()


    def getParent(self, t):
        return t.getParent()


    def setParent(self, t, parent):
        t.setParent(parent)


    def getChildIndex(self, t):
        if t is None:
            return 0
        return t.getChildIndex()


    def setChildIndex(self, t, index):
        t.setChildIndex(index)


    def replaceChildren(self, parent, startChildIndex, stopChildIndex, t):
        if parent is not None:
            parent.replaceChildren(startChildIndex, stopChildIndex, t)


############################################################################
#
# streams
#
# TreeNodeStream
# \- BaseTree
#    \- CommonTree
#
# TreeAdaptor
# \- BaseTreeAdaptor
#    \- CommonTreeAdaptor
#
############################################################################



class TreeNodeStream(IntStream):
    """@brief A stream of tree nodes

    It accessing nodes from a tree of some kind.
    """
    
    # TreeNodeStream is abstract, no need to complain about not implemented
    # abstract methods
    # pylint: disable-msg=W0223
    
    def get(self, i):
        """Get a tree node at an absolute index i; 0..n-1.
        If you don't want to buffer up nodes, then this method makes no
        sense for you.
        """

        raise NotImplementedError


    def LT(self, k):
        """
        Get tree node at current input pointer + i ahead where i=1 is next node.
        i<0 indicates nodes in the past.  So LT(-1) is previous node, but
        implementations are not required to provide results for k < -1.
        LT(0) is undefined.  For i>=n, return null.
        Return null for LT(0) and any index that results in an absolute address
        that is negative.

        This is analogus to the LT() method of the TokenStream, but this
        returns a tree node instead of a token.  Makes code gen identical
        for both parser and tree grammars. :)
        """

        raise NotImplementedError


    def getTreeSource(self):
        """
        Where is this stream pulling nodes from?  This is not the name, but
        the object that provides node objects.
        """

        raise NotImplementedError
    

    def getTokenStream(self):
        """
        If the tree associated with this stream was created from a TokenStream,
        you can specify it here.  Used to do rule $text attribute in tree
        parser.  Optional unless you use tree parser rule text attribute
        or output=template and rewrite=true options.
        """

        raise NotImplementedError


    def getTreeAdaptor(self):
        """
        What adaptor can tell me how to interpret/navigate nodes and
        trees.  E.g., get text of a node.
        """

        raise NotImplementedError
        

    def setUniqueNavigationNodes(self, uniqueNavigationNodes):
        """
        As we flatten the tree, we use UP, DOWN nodes to represent
        the tree structure.  When debugging we need unique nodes
        so we have to instantiate new ones.  When doing normal tree
        parsing, it's slow and a waste of memory to create unique
        navigation nodes.  Default should be false;
        """

        raise NotImplementedError
        

    def toString(self, start, stop):
        """
        Return the text of all nodes from start to stop, inclusive.
        If the stream does not buffer all the nodes then it can still
        walk recursively from start until stop.  You can always return
        null or "" too, but users should not access $ruleLabel.text in
        an action of course in that case.
        """

        raise NotImplementedError


    # REWRITING TREES (used by tree parser)
    def replaceChildren(self, parent, startChildIndex, stopChildIndex, t):
        """
 	Replace from start to stop child index of parent with t, which might
        be a list.  Number of children may be different
        after this call.  The stream is notified because it is walking the
        tree and might need to know you are monkeying with the underlying
        tree.  Also, it might be able to modify the node stream to avoid
        restreaming for future phases.

        If parent is null, don't do anything; must be at root of overall tree.
        Can't replace whatever points to the parent externally.  Do nothing.
        """

        raise NotImplementedError


class CommonTreeNodeStream(TreeNodeStream):
    """@brief A buffered stream of tree nodes.

    Nodes can be from a tree of ANY kind.

    This node stream sucks all nodes out of the tree specified in
    the constructor during construction and makes pointers into
    the tree using an array of Object pointers. The stream necessarily
    includes pointers to DOWN and UP and EOF nodes.

    This stream knows how to mark/release for backtracking.

    This stream is most suitable for tree interpreters that need to
    jump around a lot or for tree parsers requiring speed (at cost of memory).
    There is some duplicated functionality here with UnBufferedTreeNodeStream
    but just in bookkeeping, not tree walking etc...

    @see UnBufferedTreeNodeStream
    """
    
    def __init__(self, *args):
        TreeNodeStream.__init__(self)

        if len(args) == 1:
            adaptor = CommonTreeAdaptor()
            tree = args[0]

            nodes = None
            down = None
            up = None
            eof = None

        elif len(args) == 2:
            adaptor = args[0]
            tree = args[1]

            nodes = None
            down = None
            up = None
            eof = None

        elif len(args) == 3:
            parent = args[0]
            start = args[1]
            stop = args[2]

            adaptor = parent.adaptor
            tree = parent.root

            nodes = parent.nodes[start:stop]
            down = parent.down
            up = parent.up
            eof = parent.eof

        else:
            raise TypeError("Invalid arguments")
        
        # all these navigation nodes are shared and hence they
        # cannot contain any line/column info
        if down is not None:
            self.down = down
        else:
            self.down = adaptor.createFromType(DOWN, "DOWN")

        if up is not None:
            self.up = up
        else:
            self.up = adaptor.createFromType(UP, "UP")

        if eof is not None:
            self.eof = eof
        else:
            self.eof = adaptor.createFromType(EOF, "EOF")

        # The complete mapping from stream index to tree node.
        # This buffer includes pointers to DOWN, UP, and EOF nodes.
        # It is built upon ctor invocation.  The elements are type
        #  Object as we don't what the trees look like.

        # Load upon first need of the buffer so we can set token types
        # of interest for reverseIndexing.  Slows us down a wee bit to
        # do all of the if p==-1 testing everywhere though.
        if nodes is not None:
            self.nodes = nodes
        else:
            self.nodes = []

        # Pull nodes from which tree?
        self.root = tree

        # IF this tree (root) was created from a token stream, track it.
        self.tokens = None

        # What tree adaptor was used to build these trees
        self.adaptor = adaptor

        # Reuse same DOWN, UP navigation nodes unless this is true
        self.uniqueNavigationNodes = False

        # The index into the nodes list of the current node (next node
        # to consume).  If -1, nodes array not filled yet.
        self.p = -1

        # Track the last mark() call result value for use in rewind().
        self.lastMarker = None

        # Stack of indexes used for push/pop calls
        self.calls = []


    def fillBuffer(self):
        """Walk tree with depth-first-search and fill nodes buffer.
        Don't do DOWN, UP nodes if its a list (t is isNil).
        """

        self._fillBuffer(self.root)
        self.p = 0 # buffer of nodes intialized now


    def _fillBuffer(self, t):
        nil = self.adaptor.isNil(t)
        
        if not nil:
            self.nodes.append(t) # add this node

        # add DOWN node if t has children
        n = self.adaptor.getChildCount(t)
        if not nil and n > 0:
            self.addNavigationNode(DOWN)

        # and now add all its children
        for c in range(n):
            self._fillBuffer(self.adaptor.getChild(t, c))

        # add UP node if t has children
        if not nil and n > 0:
            self.addNavigationNode(UP)


    def getNodeIndex(self, node):
        """What is the stream index for node? 0..n-1
        Return -1 if node not found.
        """
        
        if self.p == -1:
            self.fillBuffer()

        for i, t in enumerate(self.nodes):
            if t == node:
                return i

        return -1


    def addNavigationNode(self, ttype):
        """
        As we flatten the tree, we use UP, DOWN nodes to represent
        the tree structure.  When debugging we need unique nodes
        so instantiate new ones when uniqueNavigationNodes is true.
        """
        
        navNode = None
        
        if ttype == DOWN:
            if self.hasUniqueNavigationNodes():
                navNode = self.adaptor.createFromType(DOWN, "DOWN")

            else:
                navNode = self.down

        else:
            if self.hasUniqueNavigationNodes():
                navNode = self.adaptor.createFromType(UP, "UP")
                
            else:
                navNode = self.up

        self.nodes.append(navNode)


    def get(self, i):
        if self.p == -1:
            self.fillBuffer()

        return self.nodes[i]


    def LT(self, k):
        if self.p == -1:
            self.fillBuffer()

        if k == 0:
            return None

        if k < 0:
            return self.LB(-k)

        if self.p + k - 1 >= len(self.nodes):
            return self.eof

        return self.nodes[self.p + k - 1]
    

    def getCurrentSymbol(self):
        return self.LT(1)


    def LB(self, k):
        """Look backwards k nodes"""
        
        if k == 0:
            return None

        if self.p - k < 0:
            return None

        return self.nodes[self.p - k]


    def getTreeSource(self):
        return self.root


    def getSourceName(self):
        return self.getTokenStream().getSourceName()


    def getTokenStream(self):
        return self.tokens


    def setTokenStream(self, tokens):
        self.tokens = tokens


    def getTreeAdaptor(self):
        return self.adaptor


    def hasUniqueNavigationNodes(self):
        return self.uniqueNavigationNodes


    def setUniqueNavigationNodes(self, uniqueNavigationNodes):
        self.uniqueNavigationNodes = uniqueNavigationNodes


    def consume(self):
        if self.p == -1:
            self.fillBuffer()
            
        self.p += 1

        
    def LA(self, i):
        return self.adaptor.getType(self.LT(i))


    def mark(self):
        if self.p == -1:
            self.fillBuffer()

        
        self.lastMarker = self.index()
        return self.lastMarker


    def release(self, marker=None):
        # no resources to release

        pass


    def index(self):
        return self.p


    def rewind(self, marker=None):
        if marker is None:
            marker = self.lastMarker
            
        self.seek(marker)


    def seek(self, index):
        if self.p == -1:
            self.fillBuffer()

        self.p = index


    def push(self, index):
        """
        Make stream jump to a new location, saving old location.
        Switch back with pop().
        """

        self.calls.append(self.p) # save current index
        self.seek(index)


    def pop(self):
        """
        Seek back to previous index saved during last push() call.
        Return top of stack (return index).
        """

        ret = self.calls.pop(-1)
        self.seek(ret)
        return ret


    def reset(self):
        self.p = 0
        self.lastMarker = 0
        self.calls = []

        
    def size(self):
        if self.p == -1:
            self.fillBuffer()

        return len(self.nodes)


    # TREE REWRITE INTERFACE

    def replaceChildren(self, parent, startChildIndex, stopChildIndex, t):
        if parent is not None:
            self.adaptor.replaceChildren(
                parent, startChildIndex, stopChildIndex, t
                )


    def __str__(self):
        """Used for testing, just return the token type stream"""

        if self.p == -1:
            self.fillBuffer()

        return ' '.join([str(self.adaptor.getType(node))
                         for node in self.nodes
                         ])


    def toString(self, start, stop):
        if start is None or stop is None:
            return None

        if self.p == -1:
            self.fillBuffer()

        #System.out.println("stop: "+stop);
        #if ( start instanceof CommonTree )
        #    System.out.print("toString: "+((CommonTree)start).getToken()+", ");
        #else
        #    System.out.println(start);
        #if ( stop instanceof CommonTree )
        #    System.out.println(((CommonTree)stop).getToken());
        #else
        #    System.out.println(stop);
            
        # if we have the token stream, use that to dump text in order
        if self.tokens is not None:
            beginTokenIndex = self.adaptor.getTokenStartIndex(start)
            endTokenIndex = self.adaptor.getTokenStopIndex(stop)
            
            # if it's a tree, use start/stop index from start node
            # else use token range from start/stop nodes
            if self.adaptor.getType(stop) == UP:
                endTokenIndex = self.adaptor.getTokenStopIndex(start)

            elif self.adaptor.getType(stop) == EOF:
                endTokenIndex = self.size() -2 # don't use EOF

            return self.tokens.toString(beginTokenIndex, endTokenIndex)

        # walk nodes looking for start
        i, t = 0, None
        for i, t in enumerate(self.nodes):
            if t == start:
                break

        # now walk until we see stop, filling string buffer with text
        buf = []
        t = self.nodes[i]
        while t != stop:
            text = self.adaptor.getText(t)
            if text is None:
                text = " " + self.adaptor.getType(t)

            buf.append(text)
            i += 1
            t = self.nodes[i]

        # include stop node too
        text = self.adaptor.getText(stop)
        if text is None:
            text = " " +self.adaptor.getType(stop)

        buf.append(text)
        
        return ''.join(buf)
    

    ## iterator interface
    def __iter__(self):
        if self.p == -1:
            self.fillBuffer()

        for node in self.nodes:
            yield node


#############################################################################
#
# tree parser
#
#############################################################################

class TreeParser(BaseRecognizer):
    """@brief Baseclass for generated tree parsers.
    
    A parser for a stream of tree nodes.  "tree grammars" result in a subclass
    of this.  All the error reporting and recovery is shared with Parser via
    the BaseRecognizer superclass.
    """

    def __init__(self, input, state=None):
        BaseRecognizer.__init__(self, state)

        self.input = None
        self.setTreeNodeStream(input)


    def reset(self):
        BaseRecognizer.reset(self) # reset all recognizer state variables
        if self.input is not None:
            self.input.seek(0) # rewind the input


    def setTreeNodeStream(self, input):
        """Set the input stream"""

        self.input = input


    def getTreeNodeStream(self):
        return self.input


    def getSourceName(self):
        return self.input.getSourceName()


    def getCurrentInputSymbol(self, input):
        return input.LT(1)


    def getMissingSymbol(self, input, e, expectedTokenType, follow):
        tokenText = "<missing " + self.tokenNames[expectedTokenType] + ">"
        return CommonTree(CommonToken(type=expectedTokenType, text=tokenText))


    # precompiled regex used by inContext
    dotdot = ".*[^.]\\.\\.[^.].*"
    doubleEtc = ".*\\.\\.\\.\\s+\\.\\.\\..*"
    dotdotPattern = re.compile(dotdot)
    doubleEtcPattern = re.compile(doubleEtc)

    def inContext(self, context, adaptor=None, tokenName=None, t=None):
        """Check if current node in input has a context.

        Context means sequence of nodes towards root of tree.  For example,
        you might say context is "MULT" which means my parent must be MULT.
        "CLASS VARDEF" says current node must be child of a VARDEF and whose
        parent is a CLASS node.  You can use "..." to mean zero-or-more nodes.
        "METHOD ... VARDEF" means my parent is VARDEF and somewhere above
        that is a METHOD node.  The first node in the context is not
        necessarily the root.  The context matcher stops matching and returns
        true when it runs out of context.  There is no way to force the first
        node to be the root. 
        """

        return _inContext(
            self.input.getTreeAdaptor(), self.getTokenNames(), 
            self.input.LT(1), context)

    @classmethod
    def _inContext(cls, adaptor, tokenNames, t, context):
        """The worker for inContext.

        It's static and full of parameters for testing purposes.
        """

        if cls.dotdotPattern.match(context):
            # don't allow "..", must be "..."
            raise ValueError("invalid syntax: ..")

        if cls.doubleEtcPattern.match(context):
            # don't allow double "..."
            raise ValueError("invalid syntax: ... ...")

        # ensure spaces around ...
        context = context.replace("...", " ... ")
        context = context.strip()
        nodes = context.split()

        ni = len(nodes) - 1
        t = adaptor.getParent(t)
        while ni >= 0 and t is not None:
            if nodes[ni] == "...":
                # walk upwards until we see nodes[ni-1] then continue walking
                if ni == 0:
                    # ... at start is no-op
                    return True
                goal = nodes[ni-1]
                ancestor = cls._getAncestor(adaptor, tokenNames, t, goal)
                if ancestor is None:
                    return False
                t = ancestor
                ni -= 1

            name = tokenNames[adaptor.getType(t)]
            if name != nodes[ni]:
                return False

            # advance to parent and to previous element in context node list
            ni -= 1
            t = adaptor.getParent(t)

        # at root but more nodes to match
        if t is None and ni >= 0:
            return False

        return True

    @staticmethod
    def _getAncestor(adaptor, tokenNames, t, goal):
        """Helper for static inContext."""
        while t is not None:
            name = tokenNames[adaptor.getType(t)]
            if name == goal:
                return t
            t = adaptor.getParent(t)

        return None


    def matchAny(self, ignore): # ignore stream, copy of this.input
        """
        Match '.' in tree parser has special meaning.  Skip node or
        entire tree if node has children.  If children, scan until
        corresponding UP node.
        """
        
        self._state.errorRecovery = False

        look = self.input.LT(1)
        if self.input.getTreeAdaptor().getChildCount(look) == 0:
            self.input.consume() # not subtree, consume 1 node and return
            return

        # current node is a subtree, skip to corresponding UP.
        # must count nesting level to get right UP
        level = 0
        tokenType = self.input.getTreeAdaptor().getType(look)
        while tokenType != EOF and not (tokenType == UP and level==0):
            self.input.consume()
            look = self.input.LT(1)
            tokenType = self.input.getTreeAdaptor().getType(look)
            if tokenType == DOWN:
                level += 1

            elif tokenType == UP:
                level -= 1

        self.input.consume() # consume UP


    def mismatch(self, input, ttype, follow):
        """
        We have DOWN/UP nodes in the stream that have no line info; override.
        plus we want to alter the exception type. Don't try to recover
        from tree parser errors inline...
        """

        raise MismatchedTreeNodeException(ttype, input)


    def getErrorHeader(self, e):
        """
        Prefix error message with the grammar name because message is
        always intended for the programmer because the parser built
        the input tree not the user.
        """

        return (self.getGrammarFileName() +
                ": node from %sline %s:%s"
                % (['', "after "][e.approximateLineInfo],
                   e.line,
                   e.charPositionInLine
                   )
                )

    def getErrorMessage(self, e, tokenNames):
        """
        Tree parsers parse nodes they usually have a token object as
        payload. Set the exception token and do the default behavior.
        """

        if isinstance(self, TreeParser):
            adaptor = e.input.getTreeAdaptor()
            e.token = adaptor.getToken(e.node)
            if e.token is not None: # could be an UP/DOWN node
                e.token = CommonToken(
                    type=adaptor.getType(e.node),
                    text=adaptor.getText(e.node)
                    )

        return BaseRecognizer.getErrorMessage(self, e, tokenNames)


    def traceIn(self, ruleName, ruleIndex):
        BaseRecognizer.traceIn(self, ruleName, ruleIndex, self.input.LT(1))


    def traceOut(self, ruleName, ruleIndex):
        BaseRecognizer.traceOut(self, ruleName, ruleIndex, self.input.LT(1))


#############################################################################
#
# tree visitor
#
#############################################################################

class TreeVisitor(object):
    """Do a depth first walk of a tree, applying pre() and post() actions
    we go.
    """

    def __init__(self, adaptor=None):
        if adaptor is not None:
            self.adaptor = adaptor
        else:
            self.adaptor = CommonTreeAdaptor()
    
    def visit(self, t, pre_action=None, post_action=None):
        """Visit every node in tree t and trigger an action for each node
        before/after having visited all of its children.  Bottom up walk.
        Execute both actions even if t has no children.  Ignore return
        results from transforming children since they will have altered
        the child list of this node (their parent).  Return result of
        applying post action to this node.

        The Python version differs from the Java version by taking two
        callables 'pre_action' and 'post_action' instead of a class instance
        that wraps those methods. Those callables must accept a TreeNode as
        their single argument and return the (potentially transformed or
        replaced) TreeNode.
        """

        isNil = self.adaptor.isNil(t)
        if pre_action is not None and not isNil:
            # if rewritten, walk children of new t
            t = pre_action(t)

        for idx in xrange(self.adaptor.getChildCount(t)):
            child = self.adaptor.getChild(t, idx)
            self.visit(child, pre_action, post_action)

        if post_action is not None and not isNil:
            t = post_action(t)

        return t


#############################################################################
#
# streams for rule rewriting
#
#############################################################################

class RewriteRuleElementStream(object):
    """@brief Internal helper class.
    
    A generic list of elements tracked in an alternative to be used in
    a -> rewrite rule.  We need to subclass to fill in the next() method,
    which returns either an AST node wrapped around a token payload or
    an existing subtree.

    Once you start next()ing, do not try to add more elements.  It will
    break the cursor tracking I believe.

    @see org.antlr.runtime.tree.RewriteRuleSubtreeStream
    @see org.antlr.runtime.tree.RewriteRuleTokenStream
    
    TODO: add mechanism to detect/puke on modification after reading from
    stream
    """

    def __init__(self, adaptor, elementDescription, elements=None):
        # Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
        # which bumps it to 1 meaning no more elements.
        self.cursor = 0

        # Track single elements w/o creating a list.  Upon 2nd add, alloc list
        self.singleElement = None

        # The list of tokens or subtrees we are tracking
        self.elements = None

        # Once a node / subtree has been used in a stream, it must be dup'd
        # from then on.  Streams are reset after subrules so that the streams
        # can be reused in future subrules.  So, reset must set a dirty bit.
        # If dirty, then next() always returns a dup.
        self.dirty = False
        
        # The element or stream description; usually has name of the token or
        # rule reference that this list tracks.  Can include rulename too, but
        # the exception would track that info.
        self.elementDescription = elementDescription

        self.adaptor = adaptor

        if isinstance(elements, (list, tuple)):
            # Create a stream, but feed off an existing list
            self.singleElement = None
            self.elements = elements

        else:
            # Create a stream with one element
            self.add(elements)


    def reset(self):
        """
        Reset the condition of this stream so that it appears we have
        not consumed any of its elements.  Elements themselves are untouched.
        Once we reset the stream, any future use will need duplicates.  Set
        the dirty bit.
        """
        
        self.cursor = 0
        self.dirty = True

        
    def add(self, el):
        if el is None:
            return

        if self.elements is not None: # if in list, just add
            self.elements.append(el)
            return

        if self.singleElement is None: # no elements yet, track w/o list
            self.singleElement = el
            return

        # adding 2nd element, move to list
        self.elements = []
        self.elements.append(self.singleElement)
        self.singleElement = None
        self.elements.append(el)


    def nextTree(self):
        """
        Return the next element in the stream.  If out of elements, throw
        an exception unless size()==1.  If size is 1, then return elements[0].
        
        Return a duplicate node/subtree if stream is out of elements and
        size==1. If we've already used the element, dup (dirty bit set).
        """
        
        if (self.dirty
            or (self.cursor >= len(self) and len(self) == 1)
            ):
            # if out of elements and size is 1, dup
            el = self._next()
            return self.dup(el)

        # test size above then fetch
        el = self._next()
        return el


    def _next(self):
        """
        do the work of getting the next element, making sure that it's
        a tree node or subtree.  Deal with the optimization of single-
        element list versus list of size > 1.  Throw an exception
        if the stream is empty or we're out of elements and size>1.
        protected so you can override in a subclass if necessary.
        """

        if len(self) == 0:
            raise RewriteEmptyStreamException(self.elementDescription)
            
        if self.cursor >= len(self): # out of elements?
            if len(self) == 1: # if size is 1, it's ok; return and we'll dup 
                return self.toTree(self.singleElement)

            # out of elements and size was not 1, so we can't dup
            raise RewriteCardinalityException(self.elementDescription)

        # we have elements
        if self.singleElement is not None:
            self.cursor += 1 # move cursor even for single element list
            return self.toTree(self.singleElement)

        # must have more than one in list, pull from elements
        o = self.toTree(self.elements[self.cursor])
        self.cursor += 1
        return o


    def dup(self, el):
        """
        When constructing trees, sometimes we need to dup a token or AST
        subtree.  Dup'ing a token means just creating another AST node
        around it.  For trees, you must call the adaptor.dupTree() unless
        the element is for a tree root; then it must be a node dup.
        """

        raise NotImplementedError
    

    def toTree(self, el):
        """
        Ensure stream emits trees; tokens must be converted to AST nodes.
        AST nodes can be passed through unmolested.
        """

        return el


    def hasNext(self):
        return ( (self.singleElement is not None and self.cursor < 1)
                 or (self.elements is not None
                     and self.cursor < len(self.elements)
                     )
                 )

                 
    def size(self):
        if self.singleElement is not None:
            return 1

        if self.elements is not None:
            return len(self.elements)

        return 0

    __len__ = size
    

    def getDescription(self):
        """Deprecated. Directly access elementDescription attribute"""
        
        return self.elementDescription


class RewriteRuleTokenStream(RewriteRuleElementStream):
    """@brief Internal helper class."""

    def toTree(self, el):
        # Don't convert to a tree unless they explicitly call nextTree.
        # This way we can do hetero tree nodes in rewrite.
        return el


    def nextNode(self):
        t = self._next()
        return self.adaptor.createWithPayload(t)

    
    def nextToken(self):
        return self._next()

    
    def dup(self, el):
        raise TypeError("dup can't be called for a token stream.")


class RewriteRuleSubtreeStream(RewriteRuleElementStream):
    """@brief Internal helper class."""

    def nextNode(self):
        """
        Treat next element as a single node even if it's a subtree.
        This is used instead of next() when the result has to be a
        tree root node.  Also prevents us from duplicating recently-added
        children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
        must dup the type node, but ID has been added.

        Referencing a rule result twice is ok; dup entire tree as
        we can't be adding trees as root; e.g., expr expr.

        Hideous code duplication here with super.next().  Can't think of
        a proper way to refactor.  This needs to always call dup node
        and super.next() doesn't know which to call: dup node or dup tree.
        """
        
        if (self.dirty
            or (self.cursor >= len(self) and len(self) == 1)
            ):
            # if out of elements and size is 1, dup (at most a single node
            # since this is for making root nodes).
            el = self._next()
            return self.adaptor.dupNode(el)

        # test size above then fetch
        el = self._next()
        return el


    def dup(self, el):
        return self.adaptor.dupTree(el)



class RewriteRuleNodeStream(RewriteRuleElementStream):
    """
    Queues up nodes matched on left side of -> in a tree parser. This is
    the analog of RewriteRuleTokenStream for normal parsers. 
    """
    
    def nextNode(self):
        return self._next()


    def toTree(self, el):
        return self.adaptor.dupNode(el)


    def dup(self, el):
        # we dup every node, so don't have to worry about calling dup; short-
        #circuited next() so it doesn't call.
        raise TypeError("dup can't be called for a node stream.")


class TreeRuleReturnScope(RuleReturnScope):
    """
    This is identical to the ParserRuleReturnScope except that
    the start property is a tree nodes not Token object
    when you are parsing trees.  To be generic the tree node types
    have to be Object.
    """

    def __init__(self):
        self.start = None
        self.tree = None
        
    
    def getStart(self):
        return self.start

    
    def getTree(self):
        return self.tree


########NEW FILE########
__FILENAME__ = treewizard
""" @package antlr3.tree
@brief ANTLR3 runtime package, treewizard module

A utility module to create ASTs at runtime.
See <http://www.antlr.org/wiki/display/~admin/2007/07/02/Exploring+Concept+of+TreeWizard> for an overview. Note that the API of the Python implementation is slightly different.

"""

# begin[licence]
#
# [The "BSD licence"]
# Copyright (c) 2005-2008 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# end[licence]

from .constants import INVALID_TOKEN_TYPE
from .tokens import CommonToken
from .tree import CommonTree, CommonTreeAdaptor


def computeTokenTypes(tokenNames):
    """
    Compute a dict that is an inverted index of
    tokenNames (which maps int token types to names).
    """

    if tokenNames is None:
        return {}

    return dict((name, type) for type, name in enumerate(tokenNames))


## token types for pattern parser
EOF = -1
BEGIN = 1
END = 2
ID = 3
ARG = 4
PERCENT = 5
COLON = 6
DOT = 7

class TreePatternLexer(object):
    def __init__(self, pattern):
        ## The tree pattern to lex like "(A B C)"
        self.pattern = pattern

	## Index into input string
        self.p = -1

	## Current char
        self.c = None

	## How long is the pattern in char?
        self.n = len(pattern)

	## Set when token type is ID or ARG
        self.sval = None

        self.error = False

        self.consume()


    __idStartChar = frozenset(
        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_'
        )
    __idChar = __idStartChar | frozenset('0123456789')
    
    def nextToken(self):
        self.sval = ""
        while self.c != EOF:
            if self.c in (' ', '\n', '\r', '\t'):
                self.consume()
                continue

            if self.c in self.__idStartChar:
                self.sval += self.c
                self.consume()
                while self.c in self.__idChar:
                    self.sval += self.c
                    self.consume()

                return ID

            if self.c == '(':
                self.consume()
                return BEGIN

            if self.c == ')':
                self.consume()
                return END

            if self.c == '%':
                self.consume()
                return PERCENT

            if self.c == ':':
                self.consume()
                return COLON

            if self.c == '.':
                self.consume()
                return DOT

            if self.c == '[': # grab [x] as a string, returning x
                self.consume()
                while self.c != ']':
                    if self.c == '\\':
                        self.consume()
                        if self.c != ']':
                            self.sval += '\\'

                        self.sval += self.c

                    else:
                        self.sval += self.c

                    self.consume()

                self.consume()
                return ARG

            self.consume()
            self.error = True
            return EOF

        return EOF


    def consume(self):
        self.p += 1
        if self.p >= self.n:
            self.c = EOF

        else:
            self.c = self.pattern[self.p]


class TreePatternParser(object):
    def __init__(self, tokenizer, wizard, adaptor):
        self.tokenizer = tokenizer
        self.wizard = wizard
        self.adaptor = adaptor
        self.ttype = tokenizer.nextToken() # kickstart


    def pattern(self):
        if self.ttype == BEGIN:
            return self.parseTree()

        elif self.ttype == ID:
            node = self.parseNode()
            if self.ttype == EOF:
                return node

            return None # extra junk on end

        return None


    def parseTree(self):
        if self.ttype != BEGIN:
            return None

        self.ttype = self.tokenizer.nextToken()
        root = self.parseNode()
        if root is None:
            return None

        while self.ttype in (BEGIN, ID, PERCENT, DOT):
            if self.ttype == BEGIN:
                subtree = self.parseTree()
                self.adaptor.addChild(root, subtree)

            else:
                child = self.parseNode()
                if child is None:
                    return None

                self.adaptor.addChild(root, child)

        if self.ttype != END:
            return None

        self.ttype = self.tokenizer.nextToken()
        return root


    def parseNode(self):
        # "%label:" prefix
        label = None
        
        if self.ttype == PERCENT:
            self.ttype = self.tokenizer.nextToken()
            if self.ttype != ID:
                return None

            label = self.tokenizer.sval
            self.ttype = self.tokenizer.nextToken()
            if self.ttype != COLON:
                return None
            
            self.ttype = self.tokenizer.nextToken() # move to ID following colon

        # Wildcard?
        if self.ttype == DOT:
            self.ttype = self.tokenizer.nextToken()
            wildcardPayload = CommonToken(0, ".")
            node = WildcardTreePattern(wildcardPayload)
            if label is not None:
                node.label = label
            return node

        # "ID" or "ID[arg]"
        if self.ttype != ID:
            return None

        tokenName = self.tokenizer.sval
        self.ttype = self.tokenizer.nextToken()
        
        if tokenName == "nil":
            return self.adaptor.nil()

        text = tokenName
        # check for arg
        arg = None
        if self.ttype == ARG:
            arg = self.tokenizer.sval
            text = arg
            self.ttype = self.tokenizer.nextToken()

        # create node
        treeNodeType = self.wizard.getTokenType(tokenName)
        if treeNodeType == INVALID_TOKEN_TYPE:
            return None

        node = self.adaptor.createFromType(treeNodeType, text)
        if label is not None and isinstance(node, TreePattern):
            node.label = label

        if arg is not None and isinstance(node, TreePattern):
            node.hasTextArg = True

        return node


class TreePattern(CommonTree):
    """
    When using %label:TOKENNAME in a tree for parse(), we must
    track the label.
    """

    def __init__(self, payload):
        CommonTree.__init__(self, payload)

        self.label = None
        self.hasTextArg = None
        

    def toString(self):
        if self.label is not None:
            return '%' + self.label + ':' + CommonTree.toString(self)
        
        else:
            return CommonTree.toString(self)


class WildcardTreePattern(TreePattern):
    pass


class TreePatternTreeAdaptor(CommonTreeAdaptor):
    """This adaptor creates TreePattern objects for use during scan()"""

    def createWithPayload(self, payload):
        return TreePattern(payload)


class TreeWizard(object):
    """
    Build and navigate trees with this object.  Must know about the names
    of tokens so you have to pass in a map or array of token names (from which
    this class can build the map).  I.e., Token DECL means nothing unless the
    class can translate it to a token type.

    In order to create nodes and navigate, this class needs a TreeAdaptor.

    This class can build a token type -> node index for repeated use or for
    iterating over the various nodes with a particular type.

    This class works in conjunction with the TreeAdaptor rather than moving
    all this functionality into the adaptor.  An adaptor helps build and
    navigate trees using methods.  This class helps you do it with string
    patterns like "(A B C)".  You can create a tree from that pattern or
    match subtrees against it.
    """

    def __init__(self, adaptor=None, tokenNames=None, typeMap=None):
        self.adaptor = adaptor
        if typeMap is None:
            self.tokenNameToTypeMap = computeTokenTypes(tokenNames)

        else:
            if tokenNames is not None:
                raise ValueError("Can't have both tokenNames and typeMap")

            self.tokenNameToTypeMap = typeMap


    def getTokenType(self, tokenName):
        """Using the map of token names to token types, return the type."""

        try:
            return self.tokenNameToTypeMap[tokenName]
        except KeyError:
            return INVALID_TOKEN_TYPE


    def create(self, pattern):
        """
        Create a tree or node from the indicated tree pattern that closely
        follows ANTLR tree grammar tree element syntax:
        
        (root child1 ... child2).
        
        You can also just pass in a node: ID
         
        Any node can have a text argument: ID[foo]
        (notice there are no quotes around foo--it's clear it's a string).
        
        nil is a special name meaning "give me a nil node".  Useful for
        making lists: (nil A B C) is a list of A B C.
        """
        
        tokenizer = TreePatternLexer(pattern)
        parser = TreePatternParser(tokenizer, self, self.adaptor)
        return parser.pattern()


    def index(self, tree):
        """Walk the entire tree and make a node name to nodes mapping.
        
        For now, use recursion but later nonrecursive version may be
        more efficient.  Returns a dict int -> list where the list is
        of your AST node type.  The int is the token type of the node.
        """

        m = {}
        self._index(tree, m)
        return m


    def _index(self, t, m):
        """Do the work for index"""

        if t is None:
            return

        ttype = self.adaptor.getType(t)
        elements = m.get(ttype)
        if elements is None:
            m[ttype] = elements = []

        elements.append(t)
        for i in range(self.adaptor.getChildCount(t)):
            child = self.adaptor.getChild(t, i)
            self._index(child, m)


    def find(self, tree, what):
        """Return a list of matching token.

        what may either be an integer specifzing the token type to find or
        a string with a pattern that must be matched.
        
        """
        
        if isinstance(what, (int, long)):
            return self._findTokenType(tree, what)

        elif isinstance(what, basestring):
            return self._findPattern(tree, what)

        else:
            raise TypeError("'what' must be string or integer")


    def _findTokenType(self, t, ttype):
        """Return a List of tree nodes with token type ttype"""

        nodes = []

        def visitor(tree, parent, childIndex, labels):
            nodes.append(tree)

        self.visit(t, ttype, visitor)

        return nodes


    def _findPattern(self, t, pattern):
        """Return a List of subtrees matching pattern."""
        
        subtrees = []
        
        # Create a TreePattern from the pattern
        tokenizer = TreePatternLexer(pattern)
        parser = TreePatternParser(tokenizer, self, TreePatternTreeAdaptor())
        tpattern = parser.pattern()
        
        # don't allow invalid patterns
        if (tpattern is None or tpattern.isNil()
            or isinstance(tpattern, WildcardTreePattern)):
            return None

        rootTokenType = tpattern.getType()

        def visitor(tree, parent, childIndex, label):
            if self._parse(tree, tpattern, None):
                subtrees.append(tree)
                
        self.visit(t, rootTokenType, visitor)

        return subtrees


    def visit(self, tree, what, visitor):
        """Visit every node in tree matching what, invoking the visitor.

        If what is a string, it is parsed as a pattern and only matching
        subtrees will be visited.
        The implementation uses the root node of the pattern in combination
        with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
        Patterns with wildcard roots are also not allowed.

        If what is an integer, it is used as a token type and visit will match
        all nodes of that type (this is faster than the pattern match).
        The labels arg of the visitor action method is never set (it's None)
        since using a token type rather than a pattern doesn't let us set a
        label.
        """

        if isinstance(what, (int, long)):
            self._visitType(tree, None, 0, what, visitor)

        elif isinstance(what, basestring):
            self._visitPattern(tree, what, visitor)

        else:
            raise TypeError("'what' must be string or integer")
        
              
    def _visitType(self, t, parent, childIndex, ttype, visitor):
        """Do the recursive work for visit"""
        
        if t is None:
            return

        if self.adaptor.getType(t) == ttype:
            visitor(t, parent, childIndex, None)

        for i in range(self.adaptor.getChildCount(t)):
            child = self.adaptor.getChild(t, i)
            self._visitType(child, t, i, ttype, visitor)


    def _visitPattern(self, tree, pattern, visitor):
        """
        For all subtrees that match the pattern, execute the visit action.
        """

        # Create a TreePattern from the pattern
        tokenizer = TreePatternLexer(pattern)
        parser = TreePatternParser(tokenizer, self, TreePatternTreeAdaptor())
        tpattern = parser.pattern()
        
        # don't allow invalid patterns
        if (tpattern is None or tpattern.isNil()
            or isinstance(tpattern, WildcardTreePattern)):
            return

        rootTokenType = tpattern.getType()

        def rootvisitor(tree, parent, childIndex, labels):
            labels = {}
            if self._parse(tree, tpattern, labels):
                visitor(tree, parent, childIndex, labels)
                
        self.visit(tree, rootTokenType, rootvisitor)
        

    def parse(self, t, pattern, labels=None):
        """
        Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
        on the various nodes and '.' (dot) as the node/subtree wildcard,
        return true if the pattern matches and fill the labels Map with
        the labels pointing at the appropriate nodes.  Return false if
        the pattern is malformed or the tree does not match.

        If a node specifies a text arg in pattern, then that must match
        for that node in t.
        """

        tokenizer = TreePatternLexer(pattern)
        parser = TreePatternParser(tokenizer, self, TreePatternTreeAdaptor())
        tpattern = parser.pattern()

        return self._parse(t, tpattern, labels)


    def _parse(self, t1, tpattern, labels):
        """
        Do the work for parse. Check to see if the tpattern fits the
        structure and token types in t1.  Check text if the pattern has
        text arguments on nodes.  Fill labels map with pointers to nodes
        in tree matched against nodes in pattern with labels.
	"""
        
        # make sure both are non-null
        if t1 is None or tpattern is None:
            return False

        # check roots (wildcard matches anything)
        if not isinstance(tpattern, WildcardTreePattern):
            if self.adaptor.getType(t1) != tpattern.getType():
                return False

            # if pattern has text, check node text
            if (tpattern.hasTextArg
                and self.adaptor.getText(t1) != tpattern.getText()):
                return False

        if tpattern.label is not None and labels is not None:
            # map label in pattern to node in t1
            labels[tpattern.label] = t1

        # check children
        n1 = self.adaptor.getChildCount(t1)
        n2 = tpattern.getChildCount()
        if n1 != n2:
            return False

        for i in range(n1):
            child1 = self.adaptor.getChild(t1, i)
            child2 = tpattern.getChild(i)
            if not self._parse(child1, child2, labels):
                return False

        return True


    def equals(self, t1, t2, adaptor=None):
        """
        Compare t1 and t2; return true if token types/text, structure match
        exactly.
        The trees are examined in their entirety so that (A B) does not match
        (A B C) nor (A (B C)). 
        """

        if adaptor is None:
            adaptor = self.adaptor

        return self._equals(t1, t2, adaptor)


    def _equals(self, t1, t2, adaptor):
        # make sure both are non-null
        if t1 is None or t2 is None:
            return False

        # check roots
        if adaptor.getType(t1) != adaptor.getType(t2):
            return False

        if adaptor.getText(t1) != adaptor.getText(t2):
            return False
        
        # check children
        n1 = adaptor.getChildCount(t1)
        n2 = adaptor.getChildCount(t2)
        if n1 != n2:
            return False

        for i in range(n1):
            child1 = adaptor.getChild(t1, i)
            child2 = adaptor.getChild(t2, i)
            if not self._equals(child1, child2, adaptor):
                return False

        return True

########NEW FILE########
__FILENAME__ = binary

########NEW FILE########
__FILENAME__ = core

########NEW FILE########
__FILENAME__ = escape
import re

CONTROL_CHARS = {
    u"\n" : u"\\n",
    u"\t" : u"\\t",
    u"\"" : u"\\\"",
    u"\\" : u"\\\\",
}

ESCAPED_CHARS = dict((value, key) for key, value in CONTROL_CHARS.iteritems())

CONTROL_CHAR_RE = re.compile(
    unicode.join(u"|", (u"(%s)" % re.escape(char) for char in CONTROL_CHARS.iterkeys()))
)

ESCAPED_CHARS_RE = re.compile(
    unicode.join(u"|", (u"(%s)" % re.escape(char) for char in ESCAPED_CHARS.iterkeys()))
)

def escape_string(s):
    escaped_s = CONTROL_CHAR_RE.sub(
        lambda match: CONTROL_CHARS[match.group()],
        s
    )
    return escaped_s

def unescape_string(s):
    unescaped_s = ESCAPED_CHARS_RE.sub(
        lambda match: ESCAPED_CHARS[match.group()],
        s
    )
    return unescaped_s

########NEW FILE########
__FILENAME__ = nextstep
import re
from collections import OrderedDict
import codecs
from itertools import izip, izip_longest
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

from .antlr import PlistLexer
from .antlr import PlistParser
import antlr.runtime.antlr3 as antlr3

from .escape import escape_string


class NSPlistReader(object):
    CODEC_DEF_RE = re.compile(r"^//\s*!\$\*(.+)\*\$!$") #e.g. "// !$*UTF8*$!"
    def __init__(self, f):
        self.f = f

    def read(self):
        content = self.f.read()

        self._encoding = self._detect_encoding(content)
        unicode_content = unicode(content, encoding=self._encoding)
        stream = antlr3.ANTLRStringStream(unicode_content)
        lexer = PlistLexer(stream)
        tokens = antlr3.CommonTokenStream(lexer)
        parser = PlistParser(tokens)
        plist = parser.plist()

        return plist

    def _detect_encoding(self, content):
        #first line may contain comment that
        #includes encoding of the file
        splitting = content.split("\n", 1)
        first_line = splitting[0]

        codec_def_match = self.__class__.CODEC_DEF_RE.match(first_line)
        if codec_def_match:
            codec_name = codec_def_match.group(1)
            return codec_name
        else:
            return "ascii"

    def get_encoding(self):
        return self._encoding

    def close(self):
        self.f.close()

class IndentWriter(object):
    ONLY_SPACES_RE = re.compile(r"\A\s+\Z")
    def __init__(self, f, indent_char="\t", indent_size=1):
        self.f = f
        self.indent_char = indent_char
        self.indent_size = indent_size
        self.indent_count = 0
        self.current_indent = ""

    def indent(self):
        self.indent_count += 1
        self.current_indent = self.indent_char*(self.indent_count*self.indent_size)

    def deindent(self):
        self.indent_count -= 1
        self.current_indent = self.indent_char*(self.indent_count*self.indent_size)

    def write(self, s):
        lines = s.splitlines(True)
        indendet_lines = (self.indent_line(line) for line in lines)
        self.f.write(str.join("", indendet_lines))

    def indent_line(self, line):
        if False:
            return line
        elif line.endswith("\n"):
            return line + self.current_indent
        else:
            return line

    def close(self):
        self.f.close()

class NSPlistWriter(IndentWriter):
    IDENTIFIER_RE = re.compile(r"^([A-Za-z0-9'_\.\$/]+)$")

    def __init__(self, f, codec="utf8"):
        super(NSPlistWriter, self).__init__(f, indent_char="\t", indent_size=1)
        self.codec = codec.upper()

    def write_plist(self, plist):
        self.write_header()
        self.write_value(plist)

    def write_header(self):
        self.write(u"// !$*%s*$!\n" % self.codec)

    def decide_multiline(self, value):
        return True

    def write_value(self, value):
        if isinstance(value, dict):
            multiline = self.decide_multiline(value)
            if multiline:
                self.write_dict_multiline(value)
            else:
                self.write_dict(value)
        elif isinstance(value, tuple) or isinstance(value, set) or isinstance(value, list):
            multiline = self.decide_multiline(value)
            if multiline:
                self.write_set_multiline(value)
            else:
                self.write_set(value)
        else:
            self.write_string(value)

    def write_string(self, string):
        if NSPlistWriter.IDENTIFIER_RE.match(string):
            self.write(string)
        else:
            self.write((u"\"%s\"" % escape_string(string)))

    def write_dict_multiline(self, dict, comments = {}):
        self.write(u"{")
        self.indent()

        for key, value in dict.iteritems():
            self.write(u"\n")
            if key in comments:
                comment = comments[key]
            else:
                comment = None

            self.write_dict_item(key, value, comment)

        self.deindent()
        self.write(u"\n}")

    def write_dict(self, dict, comments = {}):
        self.write(u"{")
        self.indent()

        for key, value in dict.iteritems():
            if key in comments:
                comment = comments[key]
            else:
                comment = None

            self.write_dict_item(key, value, comment)
            self.write(" ")

        self.deindent()
        self.write(u"}")

    def write_dict_item(self, key, value, comment = None):
        if isinstance(value, dict) or isinstance(value, tuple) or isinstance(value, set) or isinstance(value, list):
            comment_before_value = True
        else:
            comment_before_value = False

        self.write_dict_key(key, value, comment, comment_before_value)

        self.write(u" = ")
        self.write_value(value)
        self.write(u";")

        if not comment_before_value and comment != None:
            self.write(u" /*" + comment + u"*/ ")

    def write_dict_key(self, key, value, comment = None, comment_before_value = False):
        self.write_string(key)
        if comment_before_value and comment != None:
            self.write(u" /*" + comment + "*/ ")

    def write_set_multiline(self, values, comments = ()):
        self.write(u"(")
        self.indent()

        for value, comment in izip_longest(values, comments, fillvalue=None):
            self.write("\n")
            self.write_set_item(value, comment)
            self.write(u",")

        self.deindent()
        self.write(u"\n)")

    def write_set(self, values, comments = ()):
        self.write(u"(\n")
        self.indent()

        for value, comment in izip_longest(values, comments, fillvalue=None):
            self.write_set_item(value, comment)
            self.write(u",")

        self.deindent()
        self.write(u"\n)")

    def write_set_item(self, value, comment = None):
        self.write_value(value)
        if comment != None:
            self.write(u" ")
            self.write_comment(comment)

########NEW FILE########
__FILENAME__ = xml

########NEW FILE########
__FILENAME__ = __main__
import sys
from argparse import ArgumentParser

from .nextstep import NSPlistReader

def get_argument_parser():
    parser = ArgumentParser()

    parser.add_argument("file",
                        help="The file to parse")
    parser.add_argument("debug",
                        help="If an exception is thrown, start the debugger",
                        action="store_true")

    return parser


def install_pdb_exception_handler():
    def info(type, value, tb):
       if hasattr(sys, 'ps1') or not sys.stderr.isatty():
          # we are in interactive mode or we don't have a tty-like
          # device, so we call the default hook
          sys.__excepthook__(type, value, tb)
       else:
          import traceback, pdb
          # we are NOT in interactive mode, print the exception...
          traceback.print_exception(type, value, tb)
          print
          # ...then start the debugger in post-mortem mode.
          pdb.pm()

    sys.excepthook = info


def main():
    parser = get_argument_parser()
    args = parser.parse_args()

    if args.debug:
        install_pdb_exception_handler()

    f = open(args.file)
    r = NSPlistReader(f)
    plist = r.read()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = testhelpers
import os
import logging
import codecs

TEST_DIR = os.path.dirname(__file__)
FIXTURES_DIR = os.path.join(TEST_DIR, "fixtures")

def fixture_path(path):
    return os.path.join(FIXTURES_DIR, path)

def make_logger(clazz):
    logger_name = "test.%s.%s" % (clazz.__module__, clazz.__name__)
    return logging.getLogger(logger_name)

def listpath(dir):
    return [os.path.join(dir, entry) for entry in os.listdir(dir) if not entry.startswith(".")]

def wrap_with_codec(f, codec):
    codecinfo = codecs.lookup(codec)
    wrapper = codecs.StreamReaderWriter(f,
            codecinfo.streamreader, codecinfo.streamwriter)

    return wrapper

########NEW FILE########
__FILENAME__ = test_coremerge
import sys
import logging
if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest

from pbxproj.merge.coremerge import *
from orderedset import OrderedSet
from collections import OrderedDict

class CoreMergeTest(unittest.TestCase):
    def test_diff_dict_keys(self):
        base = {
            "a" : "base",
            "b" : "base",
            "c" : "base"
        }

        mine = {
            "a" : "base",
            "c" : "mine_conflict",
            "d" : "mine_new"
        }

        expected_added = set(("d",))
        expected_deleted = set(("b",))
        expected_common = set(("a", "c"))

        diff = diff_dict_keys(base, mine)

        self.assertEquals(expected_added, diff.added)
        self.assertEquals(expected_deleted, diff.deleted)
        self.assertEquals(expected_common, diff.common)

    def test_diff3_dict_keys(self):
        base = {
            "a" : "base",
            "b" : "base",
            "c" : "base",
            "e" : "base",
            "g" : "base",
        }

        mine = {
            "a" : "base",
            "c" : "mine_conflict",
            "d" : "mine_new",
            "e" : "base",
            "g" : "mine_conflict",
        }

        theirs = {
           "a" : "base",
           "c" : "theirs_conflict",
           "f" : "theirs_new",
        }

        expected_mine_added = set(("d",))
        expected_theirs_added = set(("f",))
        expected_deleted = set(("b",))
        expected_conflicting_deleted = set(("g", "e"))
        expected_common = set(("a", "c"))

        diff = diff3_dict_keys(base, mine, theirs)

        self.assertEquals(expected_mine_added, diff.mine_added)
        self.assertEquals(expected_theirs_added, diff.theirs_added)
        self.assertEquals(expected_conflicting_deleted, diff.conflicting_deleted)
        self.assertEquals(expected_deleted, diff.deleted)
        self.assertEquals(expected_common, diff.common)

    def test_diff_dict(self):
        base = {
            "a" : "base",
            "b" : "base",
            "c" : "base"
        }

        mine = {
            "a" : "base",
            "c" : "mine_updated",
            "d" : "mine_new"
        }

        expected_added = set(("d",))
        expected_updated = set(("c",))
        expected_deleted = set(("b",))
        expected_common = set(("a",))

        diff = diff_dict(base, mine)

        self.assertEquals(expected_added, diff.added)
        self.assertEquals(expected_updated, diff.updated)
        self.assertEquals(expected_deleted, diff.deleted)
        self.assertEquals(expected_common, diff.common)

    def test_diff3_dict(self):
        base = {
            "a" : "base",
            "b" : "base",
            "c" : "base",
            "e" : "base",
            "g" : "base",
            "h" : "base"
        }

        mine = {
            "a" : "base",
            "c" : "mine_conflict",
            "d" : "mine_new",
            "e" : "base",
            "g" : "mine_conflict",
            "h" : "mine"
        }

        theirs = {
           "a" : "base",
           "c" : "theirs_conflict",
           "f" : "theirs_new",
           "h" : "base"
        }

        expected_mine_added = set(("d",))
        expected_theirs_added = set(("f",))
        expected_mine_updated = set(("h",))
        expected_theirs_updated = set()
        expected_deleted = set(("b","e"))
        expected_conflicting = set(("c","g"))
        expected_common = set(("a",))

        diff = diff3_dict(base, mine, theirs)

        self.assertEquals(expected_mine_added, diff.mine_added)
        self.assertEquals(expected_mine_updated, diff.mine_updated)
        self.assertEquals(expected_theirs_added, diff.theirs_added)
        self.assertEquals(expected_theirs_updated, diff.theirs_updated)
        self.assertEquals(expected_conflicting, diff.conflicting)
        self.assertEquals(expected_deleted, diff.deleted)
        self.assertEquals(expected_common, diff.common)

    def test_diff_set(self):
        base = set((
            "a", "b", "c"
        ))
        mine = set((
            "a", "e", "d"
        ))
        theirs = set((
            "a", "f", "b", "c"
        ))

        expected_added = set((
            "e", "d", "f"
        ))
        expected_deleted = set((
            "b", "c"
        ))
        expected_common = set((
            "a"
        ))

        diff = diff3_set(base, mine, theirs)
        self.assertEquals(expected_added, diff.added)
        self.assertEquals(expected_deleted, diff.deleted)
        self.assertEquals(expected_common, diff.common)

    def test_merge_set(self):
        logger = logging.getLogger("test.CoreMergeTest.test_merge_set")

        base = set((
            "a", "b", "c"
        ))
        mine = set((
            "a", "e", "d"
        ))
        theirs = set((
            "a", "f", "b", "c"
        ))

        expected_merged = set((
            "a", "e", "d", "f"
        ))

        diff = diff3_set(base, mine, theirs)
        merged = merge_set(diff, base, mine, theirs)
        self.assertEquals(expected_merged, merged)

    def test_merge_ordered_set(self):
        logger = logging.getLogger("test.CoreMergeTest.test_merge_ordered_set")

        base = OrderedSet((
            "a", "b", "c"
        ))
        mine = OrderedSet((
            "a", "e", "d"
        ))
        theirs = OrderedSet((
            "a", "f", "b", "c"
        ))

        expected_merged = OrderedSet((
            "a", "e", "d", "f"
        ))

        diff = diff3_set(base, mine, theirs)
        merged = merge_ordered_set(diff, base, mine, theirs)

        self.assertEquals(tuple(expected_merged), tuple(merged))

        #test if we can apply it cleanly to theirs
        diff_theirs = diff3_set(theirs, theirs, merged)
        merged_theirs = merge_ordered_set(diff, theirs, theirs, merged)

        self.assertEquals(tuple(merged), tuple(merged_theirs))

    def test_merge_dict(self):
        base = {
            "a" : "base",
            "b" : "base",
            "c" : "base",
            "e" : "base",
            "g" : "base",
            "h" : "base"
        }

        mine = {
            "a" : "base",
            "c" : "base",
            "d" : "mine_new",
            "e" : "base",
            "g" : "base",
            "h" : "mine"
        }

        theirs = {
           "a" : "base",
           "c" : "theirs",
           "f" : "theirs_new",
           "h" : "base"
        }

        expected_merged = {
            "a" : "base",
            "c" : "theirs",
            "d" : "mine_new",
            "f" : "theirs_new",
            "h" : "mine"
        }

        diff = diff3_dict(base, mine, theirs)

        merged = merge_dict(diff, base, mine, theirs)

        self.assertEqual(merged, expected_merged)

    def test_merge_ordered_dict(self):
        base = OrderedDict((
            ("a", "base"),
            ("b", "base"),
            ("c", "base"),
            ("e", "base"),
            ("g", "base"),
            ("h", "base")
        ))

        mine = OrderedDict((
            ("a", "base"),
            ("c", "base"),
            ("d", "mine_new"),
            ("e", "base"),
            ("g", "base"),
            ("h", "mine")
        ))

        theirs = OrderedDict((
           ("a", "base"),
           ("c", "theirs"),
           ("f", "theirs_new"),
           ("h", "base"),
        ))

        expected_merged = OrderedDict((
            ("a", "base"),
            ("c", "theirs"),
            ("d", "mine_new"),
            ("f", "theirs_new"),
            ("h", "mine")
        ))

        diff = diff3_dict(base, mine, theirs)

        merged = merge_ordered_dict(diff, base, mine, theirs)

        self.assertEqual(merged, expected_merged)

    def test_pbx_merge(self):
        mine = OrderedSet((
				"a",
                "b"
		))

        theirs = OrderedSet((
            "a",
        ))

        base = OrderedSet((
            "a",
        ))

        expected_merged = OrderedSet((
            "a",
            "b"
        ))

        diff = diff3_set(base, mine, theirs)

        merged = merge_ordered_set(diff, base, mine, theirs)

        self.assertEquals(tuple(expected_merged), tuple(merged))

        #test if we can apply it cleanly to theirs
        diff_theirs = diff3_set(theirs, theirs, merged)
        merged_theirs = merge_ordered_set(diff, theirs, theirs, merged)

        self.assertEquals(tuple(merged), tuple(merged_theirs))

########NEW FILE########
__FILENAME__ = test_dictionaryboundobject
import sys
if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest

from pbxproj.core import DictionaryBoundObject

class DictionaryBoundObjectTest(unittest.TestCase):
    def test_readValue(self):
        data = {"a": "hello", "b" : "world"}
        boundObj = DictionaryBoundObject(data)

        self.assertEquals("hello", boundObj.a)
        self.assertEquals("world", boundObj.b)

    def test_writeValue(self):
        data = {"a": "hello", "b" : "world"}
        boundObj = DictionaryBoundObject(data)

        boundObj.b = "simon"
        self.assertEquals("simon", boundObj.b)
        self.assertEquals("simon", data["b"])

########NEW FILE########
__FILENAME__ = test_orderedset
from orderedset import OrderedSet

import sys
if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest

class TokenStreamTest(unittest.TestCase):
    def test_clear(self):
        s = OrderedSet((1,2,3,4))
        s.clear()

    def test_weakref(self):
        s = OrderedSet((1,2,3,4))
        actual = list(s)

        self.assertEqual(actual , [1,2,3,4])

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pbxmerge
import sys
if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest
import os
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO
import difflib
from itertools import chain

import pbxproj
import pbxproj.merge.pbxmerge as pbxmerge
from pbxproj.merge import merge_pbxs
import pbxproj.isa as isa

from testhelpers import fixture_path, make_logger, listpath, wrap_with_codec

def first(iterable, predicate, default=None):
    for item in iterable:
        if predicate(item):
            return item
    return default

def load_merge_task(files_to_be_merged):
    postfixes = (".base", ".mine", ".theirs", ".merged")

    base, mine, theirs, merged = (first(
                                    files_to_be_merged,
                                    lambda file: file.endswith(postfix),
                                    None)
                                  for postfix
                                  in postfixes)
    return (base, mine, theirs, merged)

class PBXMergeTest(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super(PBXMergeTest, self).__init__(*args, **kwargs)
        self.logger = make_logger(self.__class__)

    def test_check_available_merger(self):
        isa_names = isa.ISA_MAPPING.keys()
        expected_mergers = set(isa_name + "Merger3" for isa_name in isa_names) - set(("PBXISAMerger3",))
        available_merger_names = set(pbxmerge.MERGER_MAPPING.keys())

        for expected_merger in expected_mergers:
            self.assertIn(expected_merger, available_merger_names, "Missing merger %s" % expected_merger)

    def test_merge_fixtures(self):
        merge_fixtures_path = fixture_path("merge")
        merge_projects = listpath(merge_fixtures_path)
        merge_tasks = [listpath(merge_project) for merge_project in merge_projects]

        for merge_task in chain.from_iterable(merge_tasks):
            task_files = listpath(merge_task)
            project_files = load_merge_task(task_files)

            self.logger.info("merging base %s with my %s and their %s and comparing with %s..." % project_files)

            projects = [pbxproj.read(project_file) for project_file in project_files]
            base, mine, theirs, merged = projects

            merged_buffer = StringIO()
            merged_buffer = wrap_with_codec(merged_buffer, codec=base.get_encoding())
            merged_project = merge_pbxs(base, mine, theirs)
            pbxproj.write(merged_buffer, merged_project)

            #now compare the content of the written file with the original file
            #this should stay the same
            expected_merged_content = open(project_files[-1]).read()
            merged_content = merged_buffer.getvalue()
            merged_buffer.close()

            #if assert will fail, generate a diff for this failure
            if not merged_content == expected_merged_content:
                self.logger.error("failed to generate an exact replica, diff follows:")
                diff_lines = difflib.unified_diff(expected_merged_content.splitlines(), merged_content.splitlines())
                for line in diff_lines:
                    self.logger.error(line)

            self.assertEquals(merged_content, expected_merged_content, "%s was not correctly merged" % merge_task)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pbxparsing
import sys
import logging
import os
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest

import pbxproj
from testhelpers import fixture_path, make_logger, listpath, wrap_with_codec
from orderedset import OrderedSet
from collections import OrderedDict
import difflib

class PBXParsingTest(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super(PBXParsingTest, self).__init__(*args, **kwargs)
        self.logger = make_logger(self.__class__)

    def test_fixtures(self):
        parsing_fixtures_path = fixture_path("parse")

        project_files = [file for file in listpath(parsing_fixtures_path) if file.endswith(".pbxproj")]

        self.logger.debug("parsing %d files..." % len(project_files))

        for project_file in project_files:
            self.logger.debug("trying to parse file %s" % project_file)

            data = pbxproj.read(project_file)
            f_o = wrap_with_codec(StringIO(), data.get_encoding())
            pbxproj.write(f_o, data)

            #now compare the content of the written file with the original file
            #this should stay the same
            original_content = open(project_file).read()
            new_content = f_o.getvalue()
            f_o.close()

            #if assert will fail, generate a diff for this failure
            if not new_content == original_content:
                self.logger.error("failed to generate an exact replica, diff follows:")
                diff_lines = difflib.unified_diff(original_content.splitlines(), new_content.splitlines())
                for line in diff_lines:
                    self.logger.error(line)

            self.assertEquals(new_content, original_content, "%s was not correctly parsed" % project_file)

########NEW FILE########
__FILENAME__ = test_plist_nextstep
import sys
from StringIO import StringIO
if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest

import plist.nextstep
from plist.nextstep import NSPlistReader


class ParserTest(unittest.TestCase):
    def test_simple_dict(self):
        input = """{a = valuea; b = valueb;}"""
        expected = {"a" : "valuea", "b" : "valueb"}

        self.assertPlistEquals(input, expected)

    def test_simple_array(self):
        input = """(a,b,c)"""
        expected = ["a", "b", "c"]

        self.assertPlistEquals(input, expected)

    def test_complex_string(self):
        input = """{a = "\\"abc\\"\\nlinebreak"; b = valueb;}"""
        expected = {"a" : "\"abc\"\nlinebreak", "b" : "valueb"}

        self.assertPlistEquals(input, expected)


    def assertPlistEquals(self, input, expected, msg=None):
        r = NSPlistReader(StringIO(input))
        actual = r.read()

        self.assertEquals(actual, expected, msg)

########NEW FILE########
__FILENAME__ = benchmark
from argparse import ArgumentParser
import csv
import os
from subprocess import check_output
from tempfile import mkdtemp
import shutil
import time
import sys
import gc
import numpy as np
import scipy
from scipy.stats import t
try:
    import cProfile as profile
except:
    print "WARNING: could not load cProfile, results may not be comparable!"
    import profile
import pstats

from . import reloader
from . import helpers
from . import PROJECT_DIR, TEST_DIR

#files that are used for the benchmark
BENCHMARK_FILES = (
    [os.path.join(TEST_DIR, file) for file in (
        "fixtures/merge/iosbsh/c95f65c-86c9e3b-fdcc4a7/project.pbxproj.base",
        "fixtures/merge/iosbsh/c95f65c-86c9e3b-fdcc4a7/project.pbxproj.mine",
        "fixtures/merge/iosbsh/c95f65c-86c9e3b-fdcc4a7/project.pbxproj.theirs"
    )],
)


def get_argument_parser():
    parser = ArgumentParser()

    parser.add_argument("--start",
                        help="ref where to start",
                        default="HEAD")
    parser.add_argument("--stop",
                        help="ref where to stop",
                        default="origin/master")
    parser.add_argument("-o",
                        help="benchmark outputfile",
                        default="benchmark.csv")

    return parser


def main():
    parser = get_argument_parser()
    args = parser.parse_args()

    repo = Repo(PROJECT_DIR)
    tmp_repo = clone_repository(PROJECT_DIR)

    tmp_project = tmp_repo.working_dir
    tmp_src = os.path.join(tmp_project, "src")

    #add the temporary repository to the
    #load path. Add it to the beginning,
    #so we are sure that our modules
    #are loaded first
    sys.path = [tmp_src] + sys.path

    #enable reloader now
    reloader.enable(
        blacklist=lambda module: not module.__file__.startswith(tmp_src)
    )

    #import module to benchmark
    import pbxproj

    #now execute the benchmark for each commit
    for commit in walk_history(repo, args.start, args.stop):
        sys.stdout.write("Benchmarking %s" % commit)
        sys.stdout.flush()

        checkout_commit(tmp_repo, commit)
        clean_pyc(tmp_src)
        #first reload to get all new dependencies
        pbxproj = reload_pbxproj(repo, pbxproj)
        #then reload for real
        pbxproj = reload_pbxproj(repo, pbxproj)

        sys.stdout.write("...")
        sys.stdout.flush()
        result = run_benchmark(pbxproj, BENCHMARK_FILES, timer_impl=ClockTimer)
        sys.stdout.write(" [%gs, %gs]\n" % result.confidence_interval())

    reloader.disable()

    #delete temporary repo
    shutil.rmtree(tmp_repo.git_dir)
    shutil.rmtree(tmp_repo.working_dir)


class ProfileTimer(object):
    def __enter__(self):
        self._profile = profile.Profile()
        self._profile.enable()

    def __exit__(self, type, value, traceback):
        # Error handling here
        self._profile.disable()
        self._profile.create_stats()

    def duration_in_seconds(self):
        stats = pstats.Stats(self._profile)
        return stats.total_tt

class ClockTimer(object):
    def __enter__(self):
        self._start = time.time()

    def __exit__(self, type, value, traceback):
        # Error handling here
        self._finish = time.time()

    def duration_in_seconds(self):
        return self._finish - self._start


class BenchmarkResult(object):
    def __init__(self, results):
        self.results = results

    def avg(self):
        return sum(self.results)/len(self.results)

    def confidence_interval(self, confidence=0.95):
        a = 1.0*np.array(self.results)
        n = len(a)
        m, se = np.mean(a), scipy.stats.sem(a)
        h = se * scipy.stats.t._ppf((1+confidence)/2., n-1)
        return m-h, m+h

class Repo(object):
    def __init__(self, working_dir, git_dir=None):
        if git_dir is None:
            git_dir = os.path.join(working_dir, ".git")

        self.working_dir = working_dir
        self.git_dir = git_dir

    def cmd(self, git_cmd, git_cmd_args):
        args = [
            "git",
            "--git-dir", self.git_dir,
            "--work-tree", self.working_dir,
            git_cmd
        ] + git_cmd_args

        return check_output(args)

def clone_repository(orig_repro):
    temp_repro = mkdtemp()

    args = ["git", "clone",
        "-s", "-q",
        orig_repro,
        temp_repro
    ]
    check_output(args)
    return Repo(temp_repro)


def walk_history(repo, start, stop):
    args = [
        "--format=format:%h",
        "--topo-order",
        "--reverse",
        "%s..%s" % (start, stop)
    ]
    log = repo.cmd("log", args)
    return (sha for sha in log.splitlines())


def checkout_commit(repo, commit):
    repo.cmd("checkout", ["-q", commit])


def clean_pyc(path):
    for root, dirs, files in os.walk('/home/paulo-freitas'):
        pyc_files = (file for file in files if file.endswith(".pyc"))
        for pyc_file in pyc_files:
            os.remove(os.path.join(root, pyc_file))


def reload_pbxproj(repo, pbxproj):
    reloader.reload(pbxproj)
    return pbxproj


def run_benchmark(pbxproj, test_files, runs=10, timer_impl=ProfileTimer):
    timer = timer_impl()

    results = [-1.0]*runs
    for i in range(runs):
        gc.collect()
        with timer:
            for test_file in test_files:
                basef, minef, theirsf = test_file

                base, mine, theirs = (pbxproj.read(f) for f in (basef, minef, theirsf))
                pbxproj.merge.merge_pbxs(base, mine, theirs)

        results[i] = timer.duration_in_seconds()

    return BenchmarkResult(results)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = get_fixtures
#! /usr/bin/env python

import os
import sys
from collections import namedtuple
from git import Repo, GitCmdObjectDB

def main():
    repo_path, file_path, destination = sys.argv[1:4]

    collector = MergeCollector(repo_path)

    for hashes, file_contents in collector.itermerges(file_path):
        print "saving merge of %s and %s with %s as base" % (hashes.mine, hashes.theirs, hashes.base)
        dirname = str.join("-", hashes)
        full_dir_path = os.path.join(destination, dirname)

        os.mkdir(full_dir_path)

        for (name, file_content) in zip(("project.pbxproj.base", "project.pbxproj.mine", "project.pbxproj.theirs"), file_contents):
            full_file_path = os.path.join(full_dir_path, name)
            f = open(full_file_path, "w")
            f.write(file_content)
            f.close()

Merge = namedtuple("Merge", ("base", "mine", "theirs"))

class MergeCollector(object):
    def __init__(self, repo_path):
        repo = Repo(repo_path, odbt=GitCmdObjectDB)
        self.git = repo.git
        self.repo_path = repo_path

    def itermerges(self, filename):
        merges_with_base_iter = self._git_iter_merges_with_base_on_file(filename)

        for merge in merges_with_base_iter:
            base_content, mine_content, theirs_content = (self._git_show(commit, filename) for commit in merge)
            content_merge = Merge(base_content, mine_content, theirs_content)
            yield merge, content_merge

    def _git_iter_merges_with_base_on_file(self, filename):
        for (mine, theirs) in self._git_iter_merges_on_file(filename):
            base = self._git_get_merge_base(mine, theirs)

            yield Merge(base, mine, theirs)

    def _git_iter_merges_on_file(self, filename):
        log = self.git.log(filename)

        for line in log.splitlines():
            if line.startswith("Merge: "):
                line = line.replace("Merge: ", "", 1)
                parents = line.split()
                yield parents

    def _git_get_merge_base(self, a,b):
        return self.git.merge_base(a,b)[:7]

    def _git_show(self, commit, fname):
        file_repo_path = os.path.relpath(fname, self.repo_path)
        return self.git.show("%s:%s" % (commit, file_repo_path))

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = helpers
import logging
import os
import sys

from . import SRC_DIR

def setup_path():
    sys.path.append(SRC_DIR)

def setup_logging(log_level = logging.DEBUG):
    logger = logging.getLogger()
    logger.setLevel(log_level)

    formatter = logging.Formatter('%(levelname)s %(name)s - %(message)s')

    ch = logging.StreamHandler(sys.stderr)
    ch.setLevel(log_level)
    ch.setFormatter(formatter)
    logger.addHandler(ch)

########NEW FILE########
__FILENAME__ = merge_pbxproj_fixtures
#!/usr/bin/env python

import logging
import sys
import os
from StringIO import StringIO
import os.path

from . import helpers
helpers.setup_path()

from plist.nextstep import NSPlistReader
import pbxproj
from pbxproj.pbxobjects import PBXProjFile
from pbxproj.merge import get_project_file_merger

def main():
    print sys.argv
    for directory in sys.argv[1:]:
        print "merging files in %s" % directory
        merge_fixtures(directory)

def read_pbxs(pbx_files):
    projects = []
    for pbx_file in pbx_files:
            f = open(pbx_file)
            r = NSPlistReader(f)
            plist = r.read()
            projects.append(PBXProjFile(plist))

    return projects

def merge_pbxs(base, mine, theirs):
    merger = get_project_file_merger()

    return merger.merge(base, mine, theirs)

def merge_pbx_files(basef, minef, theirsf, mergedf):
    base, mine, theirs = read_pbxs((basef, minef, theirsf))

    merged_project = merge_pbxs(base, mine, theirs)

    pbxproj.write(mergedf, merged_project)

def find_fixtures(path):
    dirlist = [os.path.join(path, entry) for entry in os.listdir(path)]
    directories = [entry for entry in dirlist if os.path.isdir(entry)]

    for directory in directories:
        merged_files = [os.path.join(directory, file) for file in ("project.pbxproj.base", "project.pbxproj.mine", "project.pbxproj.theirs")]
        files_exist = [os.path.exists(file) for file in merged_files]

        merged_files += [os.path.join(directory, "project.pbxproj.merged")]

        if reduce(lambda a, b: a and b, files_exist):
            yield tuple(merged_files)
        else:
            print "could not find files, skipping %s (%r)" % (directory, files_exist)
    return

def merge_fixtures(fixtures_dir):
    fixtures = find_fixtures(fixtures_dir)

    for fixture in fixtures:
        print \
            ("Merging \n" + \
            "\tbase: %s\n" + \
            "\tmine: %s\n" + \
            "\ttheirs: %s\n" + \
            "\tmerged: %s\n") % (fixture[0], fixture[1], fixture[2], fixture[3])
        merge_pbx_files(*fixture)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = nsplist
#!/usr/bin/env python

import logging
import sys
import os

from . import helpers
helpers.setup_path()

from plist.nextstep import NSPlistReader, NSPlistWriter

fname = sys.argv[1]
f = open(fname)
r = NSPlistReader(f)

w = NSPlistWriter(sys.stdout)
w.write(r.read())

########NEW FILE########
__FILENAME__ = profile_merging
#!/usr/bin/env python
import sys
from argparse import ArgumentParser
try:
    import cProfile as profile
except:
    import profile

from . import helpers
from . import TEST_DIR

helpers.setup_path()

import pbxproj
from pbxproj.merge import merge_pbxs

def get_argument_parser():
    parser = ArgumentParser()

    parser.add_argument("base",
                        help="base for merging")
    parser.add_argument("mine",
                        help="mine for merging")
    parser.add_argument("theirs",
                        help="theirs for merging")
    parser.add_argument("-p", "--profile",
                        help="store profile under this file path",
                        default=None)
    parser.add_argument("-r", "--runs",
                        type=int,
                        help="how often should we parse the file",
                        default=1)

    return parser

def main():
    parser = get_argument_parser()
    args = parser.parse_args()


    profile.runctx("for i in range(args.runs): merge_pbx_files(args.base, args.mine, args.theirs)", globals(), locals(), args.profile)

def merge_pbx_files(basef, minef, theirsf):
    base, mine, theirs = (pbxproj.read(f) for f in (basef, minef, theirsf))

    merged_project = merge_pbxs(base, mine, theirs)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = profile_parsing
#!/usr/bin/env python
import sys
from argparse import ArgumentParser
try:
    import cProfile as profile
except:
    import profile

from . import helpers
from . import TEST_DIR

helpers.setup_path()

import pbxproj

def get_argument_parser():
    parser = ArgumentParser()

    parser.add_argument("file",
                        help="file to be parsed during the profiling")
    parser.add_argument("-p", "--profile",
                        help="store profile under this file path",
                        default=None)
    parser.add_argument("-r", "--runs",
                        type=int,
                        help="how often should we merge the file",
                        default=1)

    return parser

def main():
    parser = get_argument_parser()
    args = parser.parse_args()

    profile.runctx("for i in range(runs): pbxproj.read(file)",
        globals={},
        locals=dict(
            pbxproj=pbxproj, file=args.file, runs=args.runs
        ),
        filename=args.profile)



if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = reloader
# Python Module Reloader
#
# Copyright (c) 2009-2014 Jon Parise <jon@indelible.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#Edited by Simon Wagner, to serve the needs of mergepbx:
# * Turn blacklist into a callable, that decides, whether the module is loaded or not

"""Python Module Reloader"""

try:
    import builtins
except ImportError:
    import __builtin__ as builtins

import imp
import sys
import types

__author__ = 'Jon Parise <jon@indelible.org>'
__version__ = '0.5'

__all__ = ('enable', 'disable', 'get_dependencies', 'reload')

_baseimport = builtins.__import__
_default_blacklist = lambda name: False
_blacklist = _default_blacklist
_dependencies = dict()
_parent = None

# Jython doesn't have imp.reload().
if not hasattr(imp, 'reload'):
    imp.reload = reload

# PEP 328 changed the default level to 0 in Python 3.3.
_default_level = -1 if sys.version_info < (3, 3) else 0

def enable(blacklist=_default_blacklist):
    """Enable global module dependency tracking.

A blacklist can be specified to exclude specific modules (and their import
hierachies) from the reloading process. The blacklist can be any iterable
listing the fully-qualified names of modules that should be ignored. Note
that blacklisted modules will still appear in the dependency graph; they
will just not be reloaded.
"""
    global _blacklist
    builtins.__import__ = _import
    if callable(blacklist):
        _blacklist = blacklist
    else:
        raise ValueError("blacklist must be a callable")

def disable():
    """Disable global module dependency tracking."""
    global _blacklist, _parent
    builtins.__import__ = _baseimport
    _blacklist = _default_blacklist
    _dependencies.clear()
    _parent = None

def get_dependencies(m):
    """Get the dependency list for the given imported module."""
    name = m.__name__ if isinstance(m, types.ModuleType) else m
    return _dependencies.get(name, None)

def _deepcopy_module_dict(m):
    """Make a deep copy of a module's dictionary."""
    import copy

    # We can't deepcopy() everything in the module's dictionary because some
    # items, such as '__builtins__', aren't deepcopy()-able. To work around
    # that, we start by making a shallow copy of the dictionary, giving us a
    # way to remove keys before performing the deep copy.
    d = vars(m).copy()
    del d['__builtins__']
    return copy.deepcopy(d)

def _reload(m, visited):
    """Internal module reloading routine."""
    name = m.__name__

    # If this module's name appears in our blacklist, skip its entire
    # dependency hierarchy.
    global _blacklist
    if _blacklist(m):
        return

    # Start by adding this module to our set of visited modules. We use this
    # set to avoid running into infinite recursion while walking the module
    # dependency graph.
    visited.add(m)

    # Start by reloading all of our dependencies in reverse order. Note that
    # we recursively call ourself to perform the nested reloads.
    deps = _dependencies.get(name, None)
    if deps is not None:
        for dep in reversed(deps):
            if dep not in visited:
                _reload(dep, visited)

    # Clear this module's list of dependencies. Some import statements may
    # have been removed. We'll rebuild the dependency list as part of the
    # reload operation below.
    try:
        del _dependencies[name]
    except KeyError:
        pass

    # Because we're triggering a reload and not an import, the module itself
    # won't run through our _import hook below. In order for this module's
    # dependencies (which will pass through the _import hook) to be associated
    # with this module, we need to set our parent pointer beforehand.
    global _parent
    _parent = name

    # If the module has a __reload__(d) function, we'll call it with a copy of
    # the original module's dictionary after it's been reloaded.
    callback = getattr(m, '__reload__', None)
    if callback is not None:
        d = _deepcopy_module_dict(m)
        imp.reload(m)
        callback(d)
    else:
        imp.reload(m)

    # Reset our parent pointer now that the reloading operation is complete.
    _parent = None

def reload(m):
    """Reload an existing module.

Any known dependencies of the module will also be reloaded.

If a module has a __reload__(d) function, it will be called with a copy of
the original module's dictionary after the module is reloaded."""
    _reload(m, set())

def _import(name, globals=None, locals=None, fromlist=None, level=_default_level):
    """__import__() replacement function that tracks module dependencies."""
    # Track our current parent module. This is used to find our current place
    # in the dependency graph.
    global _parent
    parent = _parent
    _parent = _resolve_relative(parent, name, fromlist)

    # Perform the actual import work using the base import function.
    base = _baseimport(name, globals, locals, fromlist, level)

    if base is not None and parent is not None:
        m = base

        # We manually walk through the imported hierarchy because the import
        # function only returns the top-level package reference for a nested
        # import statement (e.g. 'package' for `import package.module`) when
        # no fromlist has been specified.
        if fromlist is None:
            for component in name.split('.')[1:]:
                m = getattr(m, component)

        # If we have a relative import, we need to do the same
        if name == "":
            relm_name = fromlist[0]
            m = getattr(m, relm_name)

        # If this is a nested import for a reloadable (source-based) module,
        # we append ourself to our parent's dependency list.
        if hasattr(m, '__file__'):
            l = _dependencies.setdefault(parent, [])
            l.append(m)

    # Lastly, we always restore our global _parent pointer.
    _parent = parent

    return base

def _resolve_relative(parent, name, fromlist):
    if not name == "":
        return name #this is an absolute namen, no need to resolve

    return parent + "." + fromlist[0]

########NEW FILE########
__FILENAME__ = scan_isa
#!/usr/bin/env python

import logging
import sys
import os

from . import helpers
helpers.setup_path()

from plist.nextstep import NSPlistReader, NSPlistWriter
from pbxproj.isa import ISA_MAPPING

fname = sys.argv[1]
f = open(fname)
r = NSPlistReader(f)
project = r.read()

objects = project["objects"]
isas = set(object["isa"] for object_id, object in objects.iteritems())

isas_known = set(ISA_MAPPING.iterkeys())

isas_unknown = isas - isas_known

if len(isas_unknown) == 0:
    print "no unknown objects"
else:
    for isa in sorted(isas_unknown):
        print isa

########NEW FILE########
__FILENAME__ = test
#!/usr/bin/env python
import sys
import os
import logging
from argparse import ArgumentParser
if sys.version_info >= (2,7):
    import unittest
else:
    import unittest2 as unittest

from . import helpers
from . import TEST_DIR

helpers.setup_path()

class OnlyTestLogsFilter(logging.Filter):
    def filter(self, record):
        return record.name.startswith("test.")

def get_argument_parser():
    parser = ArgumentParser()

    parser.add_argument("--logging",
                        help="show all log messages",
                        action="store_true")
    parser.add_argument("--test-logging",
                        help="show only log messages from test cases",
                        action="store_true")
    parser.add_argument("--debug",
                        help="start the debugger when an exception is thrown",
                        action="store_true")

    return parser

def setup_logging():
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    formatter = logging.Formatter('%(name)s: %(message)s')

    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    return ch

def install_pdb_exception_handler():
    def info(type, value, tb):
       if hasattr(sys, 'ps1') or not sys.stderr.isatty():
          # we are in interactive mode or we don't have a tty-like
          # device, so we call the default hook
          sys.__excepthook__(type, value, tb)
       else:
          import traceback, pdb
          # we are NOT in interactive mode, print the exception...
          traceback.print_exception(type, value, tb)
          print
          # ...then start the debugger in post-mortem mode.
          pdb.pm()

    sys.excepthook = info

if __name__ == '__main__':
    log_handler = None

    parser = get_argument_parser()
    args = parser.parse_args()
    if args.logging:
        setup_logging()
    if args.test_logging and log_handler == None:
        handler = setup_logging()
        handler.addFilter(OnlyTestLogsFilter())
    if args.debug:
        install_pdb_exception_handler()

    loader = unittest.TestLoader()
    tests = loader.discover(TEST_DIR)

    if args.debug:
        print "Running tests in debug mode..."
        for test in tests:
            test.debug()
    else:
        testRunner = unittest.runner.TextTestRunner()
        testRunner.run(tests)

########NEW FILE########
