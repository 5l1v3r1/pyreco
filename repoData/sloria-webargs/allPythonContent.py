__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# webargs documentation build configuration file.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
import webargs
sys.path.append(os.path.abspath("_themes"))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'webargs'
copyright = u'2014'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = release =  webargs.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'kr_small'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['side-primary.html', 'searchbox.html'],
    '**':       ['side-secondary.html', 'localtoc.html',
                 'relations.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'webargsdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'webargs.tex', u'webargs Documentation',
   u'Steven Loria', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'webargs', u'webargs Documentation',
     [u'Steven Loria'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'webargs', u'webargs Documentation',
   u'Steven Loria', 'webargs', 'HTTP Request Parsing for Pirates',
   ''),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }
########NEW FILE########
__FILENAME__ = tasks
# -*- coding: utf-8 -*-
import os, sys
from invoke import task, run

docs_dir = 'docs'
build_dir = os.path.join(docs_dir, '_build')

@task
def test(coverage=False):
    cmd = 'py.test'
    if coverage:
        cmd += ' --cov=webargs --cov-report=term --cov-report=html'
    run(cmd, pty=True)

@task
def clean():
    run("rm -rf build")
    run("rm -rf dist")
    run("rm -rf webargs.egg-info")
    clean_docs()
    print("Cleaned up.")

@task
def readme(browse=False):
    run('rst2html.py README.rst > README.html')
    if browse:
        run('open README.html')

@task
def clean_docs():
    run("rm -rf %s" % build_dir)

@task
def browse_docs():
    run("open %s" % os.path.join(build_dir, 'index.html'))

@task
def docs(clean=False, browse=False):
    if clean:
        clean_docs()
    run("sphinx-build %s %s" % (docs_dir, build_dir), pty=True)
    if browse:
        browse_docs()

@task
def publish(test=False):
    """Publish to the cheeseshop."""
    try:
        __import__('wheel')
    except ImportError:
        print("wheel required. Run `pip install wheel`.")
        sys.exit(1)
    if test:
        run('python setup.py register -r test sdist bdist_wheel upload -r test')
    else:
        run("python setup.py register sdist bdist_wheel upload")

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
import sys

PY2 = int(sys.version[0]) == 2

if PY2:
    text_type = unicode
    binary_type = str
    string_types = (str, unicode)
    unicode = unicode
    basestring = basestring
else:
    text_type = str
    binary_type = bytes
    string_types = (str,)
    unicode = str
    basestring = (str, bytes)

########NEW FILE########
__FILENAME__ = views
import json
from django.http import HttpResponse
from django.views.generic import View

from webargs import Arg
from webargs.djangoparser import DjangoParser

parser = DjangoParser()
hello_args = {
    'name': Arg(str, default='World')
}
hello_multi = {
    'name': Arg(multiple=True)
}

def render_json_response(data):
    return HttpResponse(
        json.dumps(data),
        content_type='application/json'
    )


class SimpleCBVWithParam(View):

    @parser.use_args(hello_args)
    def get(self, args, request, pid):
        return render_json_response(args)

class SimpleCBV(View):

    def get(self, request):
        args = parser.parse(hello_args, self.request)
        return render_json_response(args)

    def post(self, request):
        args = parser.parse(hello_args, self.request)
        return render_json_response(args)

class SimpleCBVMulti(View):

    def get(self, request):
        args = parser.parse(hello_multi, self.request)
        return render_json_response(args)

    def post(self, request):
        args = parser.parse(hello_multi, self.request)
        return render_json_response(args)

class SimpleDecoratedCBV(View):

    @parser.use_args(hello_args)
    def get(self, args, request):
        return render_json_response(args)

    @parser.use_args(hello_args)
    def post(self, args, request):
        return render_json_response(args)


def simpleview(request):
    args = parser.parse(hello_args, request)
    return render_json_response(args)

def simpleview_multi(request):
    args = parser.parse(hello_multi, request)
    return render_json_response(args)

def cookieview(request):
    request.COOKIES['name'] = 'Joe'
    args = parser.parse(hello_args, request, targets=('cookies',))
    return render_json_response(args)

@parser.use_args(hello_args)
def simpleview_with_param(request, args, pid):
    return render_json_response(args)

@parser.use_args(hello_args)
def decoratedview(request, args):
    return render_json_response(args)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testapp.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = settings
# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
import os
BASE_DIR = os.path.dirname(os.path.dirname(__file__))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/1.6/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 's$28!(eonml-m3jgbq_)bj_&#=)sym2d*kx%@j+r&vwusxz%g$'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

TEMPLATE_DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = (
    # 'django.contrib.admin',
    # 'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    # 'django.contrib.messages',
    # 'django.contrib.staticfiles',
)

MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'tests.testapp.testapp.urls'

WSGI_APPLICATION = 'tests.testapp.testapp.wsgi.application'


# Database
# https://docs.djangoproject.com/en/1.6/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

# Internationalization
# https://docs.djangoproject.com/en/1.6/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.6/howto/static-files/

STATIC_URL = '/static/'

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from tests.testapp.echo.views import (SimpleCBV, SimpleDecoratedCBV,
    SimpleCBVWithParam, SimpleCBVMulti
)

urlpatterns = patterns('',
    url(r'^simpleview/$', 'tests.testapp.echo.views.simpleview'),
    url(r'^simpleview/(?P<pid>\d+)/$', 'tests.testapp.echo.views.simpleview_with_param'),
    url(r'^simplecbvview/$', SimpleCBV.as_view()),
    url(r'^simplecbvview/(?P<pid>\d+)/$', SimpleCBVWithParam.as_view()),
    url(r'^decoratedview/', 'tests.testapp.echo.views.decoratedview'),
    url(r'^decoratedcbv/', SimpleDecoratedCBV.as_view()),
    url(r'^cookieview/$', 'tests.testapp.echo.views.cookieview'),
    url(r'^simpleview_multi/$', 'tests.testapp.echo.views.simpleview_multi'),
    url(r'^simplecbv_multi/$', SimpleCBVMulti.as_view())
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for helloapp project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/1.6/howto/deployment/wsgi/
"""

import os
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tests.testapp.testapp.settings")

from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

########NEW FILE########
__FILENAME__ = test_bottleparser
# -*- coding: utf-8 -*-
import mock

import pytest
from bottle import Bottle, debug, request, response
from webtest import TestApp

from webargs import Arg
from webargs.bottleparser import BottleParser

from .compat import text_type

hello_args = {
    'name': Arg(text_type, default='World', validate=lambda n: len(n) >= 3),
}
hello_multiple = {
    'name': Arg(multiple=True)
}

parser = BottleParser()


@pytest.fixture
def app():
    app = Bottle()
    @app.route('/echo', method=['GET', 'POST'])
    def index():
        return parser.parse(hello_args, request)
    @app.route('/echomulti/', method=['GET', 'POST'])
    def multi():
        return parser.parse(hello_multiple, request)
    debug(True)
    return app

@pytest.fixture
def testapp(app):
    return TestApp(app)

def test_parse_querystring_args(testapp):
    assert testapp.get('/echo?name=Fred').json == {'name': 'Fred'}

def test_parse_querystring_multiple(testapp):
    expected = {'name': ['steve', 'Loria']}
    assert testapp.get('/echomulti/?name=steve&name=Loria').json == expected

def test_parse_form_multiple(testapp):
    expected = {'name': ['steve', 'Loria']}
    assert testapp.post('/echomulti/', {'name': ['steve', 'Loria']}).json == expected

def test_parse_form(testapp):
    assert testapp.post('/echo', {'name': 'Joe'}).json == {'name': 'Joe'}

def test_parse_json(testapp):
    assert testapp.post_json('/echo', {'name': 'Fred'}).json == {'name': 'Fred'}

def test_parse_json_default(testapp):
    assert testapp.post_json('/echo', {}).json == {'name': 'World'}

def test_parsing_form_default(testapp):
    assert testapp.post('/echo', {}).json == {'name': 'World'}

@mock.patch('webargs.bottleparser.abort')
def test_abort_called_on_validation_error(abort, testapp):
    testapp.post('/echo', {'name': 'b'})
    assert abort.called

def test_use_args_decorator(app, testapp):
    @app.route('/foo/', method=['GET', 'POST'])
    @parser.use_args({'myvalue': Arg(int)})
    def echo2(args):
        return args
    assert testapp.post('/foo/', {'myvalue': 23}).json == {'myvalue': 23}

def test_use_args_with_url_params(app, testapp):
    @app.route('/foo/<name>')
    @parser.use_args({'myvalue': Arg(int)})
    def foo(args, name):
        return args
    assert testapp.get('/foo/Fred?myvalue=42').json == {'myvalue': 42}

def test_use_kwargs_decorator(app, testapp):
    @app.route('/foo/', method=['GET', 'POST'])
    @parser.use_kwargs({'myvalue': Arg(int)})
    def echo2(myvalue):
        return {'myvalue': myvalue}
    assert testapp.post('/foo/', {'myvalue': 23}).json == {'myvalue': 23}

def test_use_kwargs_with_url_params(app, testapp):
    @app.route('/foo/<name>')
    @parser.use_kwargs({'myvalue': Arg(int)})
    def foo(myvalue, name):
        return {'myvalue': myvalue}
    assert testapp.get('/foo/Fred?myvalue=42').json == {'myvalue': 42}

def test_parsing_headers(app, testapp):
    @app.route('/echo2')
    def echo2():
        args = parser.parse(hello_args, request, targets=('headers',))
        return args
    res = testapp.get('/echo2', headers={'name': 'Fred'}).json
    assert res == {'name': 'Fred'}

def test_parsing_cookies(app, testapp):
    @app.route('/setcookie')
    def setcookie():
        response.set_cookie('name', 'Fred')
        return {}

    @app.route('/echocookie')
    def echocookie():
        args = parser.parse(hello_args, request, targets=('cookies',))
        return args
    testapp.get('/setcookie')
    assert testapp.get('/echocookie').json == {'name': 'Fred'}

def test_arg_specific_targets(app, testapp):
    testargs = {
        'name': Arg(str, target='json'),
        'age': Arg(int, target='querystring'),
    }
    @app.route('/echo', method=['POST'])
    def echo():
        args = parser.parse(testargs, request)
        return args
    resp = testapp.post_json('/echo?age=42', {'name': 'Fred'})
    assert resp.json['age'] == 42
    assert resp.json['name'] == 'Fred'

########NEW FILE########
__FILENAME__ = test_core
# -*- coding: utf-8 -*-
import mock

import pytest

from webargs.core import Parser, Arg, ValidationError

@pytest.fixture
def request():
    return mock.Mock()

# Arg tests

def test_bad_validate_param():
    with pytest.raises(ValueError):
        Arg(validate='bad')

def test_validated():
    arg = Arg(validate=lambda x: x == 42)
    assert arg.validated(42) == 42
    with pytest.raises(ValidationError):
        arg.validated(32)

def test_validated_with_conversion():
    arg = Arg(validate=lambda x: x == 42, type_=int)
    assert arg.validated('42') == 42

def test_validated_with_bad_type():
    arg = Arg(type_=int)
    assert arg.validated(42) == 42
    with pytest.raises(ValidationError):
        arg.validated('nonint')

def test_custom_error():
    arg = Arg(type_=int, error='not an int!')
    with pytest.raises(ValidationError) as excinfo:
        arg.validated('badinput')
    assert 'not an int!' in str(excinfo)

def test_default_valdation_msg():
    arg = Arg(validate=lambda x: x == 42)
    with pytest.raises(ValidationError) as excinfo:
        arg.validated(1)
    assert 'Validator <lambda>(1) is not True' in str(excinfo)

def test_conversion_to_str():
    arg = Arg(str)
    assert arg.validated(42) == '42'

def test_use_param():
    arg = Arg(use=lambda x: x.upper())
    assert arg.validated('foo') == 'FOO'

def test_convert_and_use_params():
    arg = Arg(int, use=lambda x: x + 1)
    assert arg.validated('41') == 42

def test_error_raised_if_use_is_uncallable():
    with pytest.raises(ValueError) as excinfo:
        Arg(use='bad')
    assert '{0!r} is not callable.'.format('bad') in str(excinfo)

def test_use_is_called_before_validate():
    arg = Arg(use=lambda x: x + 1, validate=lambda x: x == 41)
    with pytest.raises(ValidationError):
        arg.validated(41)

def test_use_can_be_none():
    arg = Arg(use=None)
    assert arg.validated(41) == 41

def test_validate_can_be_none():
    arg = Arg(validate=None)
    assert arg.validated(41) == 41

def test_multiple_with_type_arg():
    arg = Arg(int, multiple=True)
    assert arg.validated(['1', 2, 3.0]) == [1, 2, 3]

def test_multiple_with_use_arg():
    arg = Arg(multiple=True, use=lambda x: x.upper())
    assert arg.validated(['foo', 'bar']) == ['FOO', 'BAR']

# Parser tests

@mock.patch('webargs.core.Parser.parse_json')
def test_parse_json_called_by_parse_arg(parse_json, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request)
    assert parse_json.called

@mock.patch('webargs.core.Parser.parse_querystring')
def test_parse_querystring_called_by_parse_arg(parse_querystring, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request)
    assert parse_querystring.called

@mock.patch('webargs.core.Parser.parse_form')
def test_parse_form_called_by_parse_arg(parse_form, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request)
    assert parse_form.called

@mock.patch('webargs.core.Parser.parse_json')
def test_parse_json_not_called_when_json_not_a_target(parse_json, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request, targets=('form', 'querystring'))
    assert parse_json.call_count == 0

@mock.patch('webargs.core.Parser.parse_headers')
def test_parse_headers_called_when_headers_is_a_target(parse_headers, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request)
    assert parse_headers.call_count == 0
    p.parse_arg('foo', arg, request, targets=('headers',))
    assert parse_headers.called

@mock.patch('webargs.core.Parser.parse_cookies')
def test_parse_cookies_called_when_cookies_is_a_target(parse_cookies, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request)
    assert parse_cookies.call_count == 0
    p.parse_arg('foo', arg, request, targets=('cookies',))
    assert parse_cookies.called

@mock.patch('webargs.core.Parser.fallback')
def test_fallback_used_if_all_other_functions_return_none(fallback, request):
    arg = Arg()
    p = Parser()
    p.parse_arg('foo', arg, request)
    assert fallback.called

@mock.patch('webargs.core.Parser.parse_json')
def test_parse(parse_json, request):
    parse_json.return_value = 42
    argmap = {
        'username': Arg(),
        'password': Arg()
    }
    p = Parser()
    ret = p.parse(argmap, request)
    assert {'username': 42, 'password': 42} == ret

def test_parse_required_arg_raises_validation_error(request):
    arg = Arg(required=True)
    p = Parser()
    with pytest.raises(ValidationError) as excinfo:
        p.parse_arg('foo', arg, request)
    assert 'Required parameter ' + repr('foo') + ' not found.' in str(excinfo)

@mock.patch('webargs.core.Parser.parse_json')
def test_parse_required_arg(parse_json, request):
    arg = Arg(required=True)
    parse_json.return_value = 42
    p = Parser()
    result = p.parse_arg('foo', arg, request, targets=('json', ))
    assert result == 42

@mock.patch('webargs.core.Parser.parse_form')
def test_parse_required_multiple_arg(parse_form, request):
    parse_form.return_value = []
    arg = Arg(multiple=True, required=True)
    p = Parser()
    with pytest.raises(ValidationError):
        p.parse_arg('foo', arg, request)

    parse_form.return_value = None
    with pytest.raises(ValidationError):
        p.parse_arg('foo', arg, request)

def test_default_targets():
    assert set(Parser.DEFAULT_TARGETS) == set(['json', 'querystring', 'form'])

def test_value_error_raised_if_invalid_target(request):
    arg = Arg()
    p = Parser()
    with pytest.raises(ValueError) as excinfo:
        p.parse_arg('foo', arg, request, targets=('invalidtarget', 'headers'))
    assert 'Invalid targets arguments: {0}'.format(['invalidtarget']) in str(excinfo)

@mock.patch('webargs.core.Parser.parse_json')
def test_conversion(parse_json, request):
    parse_json.return_value = 42
    arg = Arg(str)
    assert Parser().parse_arg('foo', arg, request, targets=('json',)) == '42'

@mock.patch('webargs.core.Parser.handle_error')
@mock.patch('webargs.core.Parser.parse_json')
def test_handle_error_called_when_parsing_raises_error(parse_json, handle_error, request):
    val_err = ValidationError('error occurred')
    parse_json.side_effect = val_err
    p = Parser()
    p.parse({'foo': Arg()}, request, targets=('json',))
    assert handle_error.called
    parse_json.side_effect = Exception('generic exception')
    p.parse({'foo': Arg()}, request, targets=('json',))
    assert handle_error.call_count == 2

def test_handle_error_reraises_errors():
    p = Parser()
    with pytest.raises(ValidationError):
        p.handle_error(ValidationError('error raised'))

def test_passing_exception_as_error_argument():
    arg = Arg(int, validate=lambda n: n == 42,
        error=AttributeError('an error occurred.'))
    with pytest.raises(ValidationError) as excinfo:
        arg.validated(41)
    assert 'an error occurred' in str(excinfo)

@mock.patch('webargs.core.Parser.parse_headers')
def test_targets_as_init_arguments(parse_headers, request):
    p = Parser(targets=('headers',))
    p.parse({'foo': Arg()}, request)
    assert parse_headers.called

@mock.patch('webargs.core.Parser.parse_files')
def test_parse_files(parse_files, request):
    p = Parser()
    p.parse({'foo': Arg()}, request, targets=('files',))
    assert parse_files.called

@mock.patch('webargs.core.Parser.parse_json')
def test_custom_error_handler(parse_json, request):
    class CustomError(Exception):
        pass

    def error_handler(error):
        raise CustomError(error)
    parse_json.side_effect = AttributeError('parse_json failed')
    p = Parser(error_handler=error_handler)
    with pytest.raises(CustomError):
        p.parse({'foo': Arg()}, request)

########NEW FILE########
__FILENAME__ = test_djangoparser
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

import pytest
import mock
from webtest import TestApp
from tests.testapp.testapp.wsgi import application
from webargs import Arg
from webargs.djangoparser import DjangoParser


@pytest.fixture
def testapp():
    """A webtest app that wraps the django wsgi app.
    """
    return TestApp(application)

@pytest.fixture
def mockrequest():
    return mock.Mock()

# Parametrize each test with a route that uses a function view and a route that
# uses a class-based view

@pytest.mark.parametrize("route", [
    '/simpleview/?name=Fred',
    '/simplecbvview/?name=Fred'
])
def test_parse_querystring(route, testapp):
    res = testapp.get(route)
    assert res.json == {'name': 'Fred'}


@pytest.mark.parametrize("route", [
    '/simpleview/',
    '/simplecbvview/'
])
def test_default(route, testapp):
    res = testapp.get(route)
    assert res.json == {'name': 'World'}

@pytest.mark.parametrize("route", [
    '/simpleview/',
    '/simplecbvview/'
])
def test_parse_form_data(route, testapp):
    res = testapp.post(route, {'name': 'Fred'})
    assert res.json == {'name': 'Fred'}

@pytest.mark.parametrize("route", [
    '/simpleview/',
    '/simplecbvview/'
])
def test_parse_json_data(route, testapp):
    res = testapp.post_json(route, {'name': 'Fred'})
    assert res.json == {'name': 'Fred'}


@pytest.mark.parametrize("route", [
    '/decoratedview/?name=Fred',
    '/decoratedcbv/?name=Fred'
])
def test_decorated_view(route, testapp):
    res = testapp.get(route)
    assert res.json == {'name': 'Fred'}

@pytest.mark.parametrize("route", [
    '/simpleview/42/?name=Fred',
    '/simplecbvview/42/?name=Fred'
])
def test_decorated_with_url_param(route, testapp):
    res = testapp.get(route)
    assert res.json == {'name': 'Fred'}

def test_parse_headers_raises_not_implemented_error(mockrequest):
    arg = Arg()
    p = DjangoParser()
    with pytest.raises(NotImplementedError) as excinfo:
        p.parse_arg('foo', arg, req=mockrequest, targets=('headers',))
    assert 'Header parsing not supported by DjangoParser' in str(excinfo)

def test_parse_cookies(testapp):
    res = testapp.get('/cookieview/')
    assert res.json == {'name': 'Joe'}

@pytest.mark.parametrize("route", [
    '/simpleview_multi/?name=steve&name=Loria',
    '/simplecbv_multi/?name=steve&name=Loria'
])
def test_parse_multiple_querystring(route, testapp):
    res = testapp.get(route)
    assert res.json == {'name': ['steve', 'Loria']}

@pytest.mark.parametrize('route', [
    '/simpleview_multi/',
    '/simplecbv_multi/'
])
def test_parse_multiple_form(route, testapp):
    payload = {'name': ['steve', 'Loria']}
    res = testapp.post(route, payload)
    assert res.json == {'name': ['steve', 'Loria']}

########NEW FILE########
__FILENAME__ = test_flaskparser
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import json
import mock
import io

from flask import Flask, jsonify
from flask.views import MethodView
from werkzeug.exceptions import HTTPException
from werkzeug.datastructures import ImmutableMultiDict
import pytest

from webargs import Arg
from webargs.flaskparser import FlaskParser, use_args, use_kwargs, abort

from .compat import text_type

class TestAppConfig:
    TESTING = True
    DEBUG = True

parser = FlaskParser()

hello_args = {
    'name': Arg(text_type, default='World'),
}

@pytest.fixture
def testapp():
    app = Flask(__name__)
    app.config.from_object(TestAppConfig)
    @app.route('/handleform', methods=['post'])
    def handleform():
        """View that just returns the jsonified args."""
        args = parser.parse(hello_args, targets=('form', ))
        return jsonify(args)
    return app


def test_parsing_get_args_in_request_context(testapp):
    with testapp.test_request_context('/myendpoint?name=Fred', method='get'):
        args = parser.parse(hello_args)
        assert args == {'name': 'Fred'}

def test_parsing_get_args_default(testapp):
    with testapp.test_request_context('/myendpoint', method='get'):
        args = parser.parse(hello_args)
        assert args == {'name': 'World'}

def test_parsing_json_in_request_context(testapp):
    with testapp.test_request_context('/myendpoint', method='post',
                                    data=json.dumps({'name': 'Fred'}),
                                        content_type='application/json'):
        args = parser.parse(hello_args)
        assert args['name'] == 'Fred'

def test_arg_with_target(testapp):
    testargs = {
        'name': Arg(str, target='json'),
        'age': Arg(int, target='querystring'),
    }
    with testapp.test_request_context('/myendpoint?age=42', method='post',
        data=json.dumps({'name': 'Fred'}), content_type='application/json'):
        args = parser.parse(testargs)
        assert args['name'] == 'Fred'
        assert args['age'] == 42


def test_parsing_json_default(testapp):
    with testapp.test_request_context('/myendpoint', method='post',
                                    data=json.dumps({}),
                                    content_type='application/json'):
        args = parser.parse(hello_args)
        assert args == {'name': 'World'}


def test_parsing_json_if_no_json(testapp):
    with testapp.test_request_context('/myendpoint', method='post'):
        args = parser.parse(hello_args)
        assert args == {'name': 'World'}


def test_parsing_form(testapp):
    test_client = testapp.test_client()
    res = test_client.post('/handleform', data={'name': 'Fred'})
    assert json.loads(res.data.decode('utf-8')) == {'name': 'Fred'}

def test_parsing_form_default(testapp):
    test_client = testapp.test_client()
    res = test_client.post('/handleform')
    assert json.loads(res.data.decode('utf-8')) == {'name': 'World'}

@mock.patch('webargs.flaskparser.abort')
def test_abort_called_on_validation_error(mock_abort, testapp):
    argmap = {'value': Arg(validate=lambda x: x == 42, type_=int)}
    with testapp.test_request_context('/foo', method='post',
        data=json.dumps({'value': 41}), content_type='application/json'):
        parser.parse(argmap)
        assert mock_abort.called_once_with(400)

@mock.patch('webargs.flaskparser.abort')
def test_abort_called_on_type_conversion_error(mock_abort, testapp):
    argmap = {'value': Arg(type_=int)}
    with testapp.test_request_context('/foo', method='post',
        data=json.dumps({'value': 'badinput'}), content_type='application/json'):
        parser.parse(argmap)
        assert mock_abort.called_once_with(400)

def test_use_args_decorator(testapp):
    @testapp.route('/foo/', methods=['post', 'get'])
    @parser.use_args({'myvalue': Arg(type_=int)})
    def echo(args):
        return jsonify(args)
    test_client = testapp.test_client()
    res = test_client.post('/foo/', data={'myvalue': 23})
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 23}


def test_use_args_decorator_on_a_method(testapp):
    class MyMethodView(MethodView):
        @parser.use_args({'myvalue': Arg(int)})
        def post(self, args):
            return jsonify(args)
    testapp.add_url_rule('/methodview/',
        view_func=MyMethodView.as_view(str('mymethodview')))
    test_client = testapp.test_client()
    res = test_client.post('/methodview/', data={'myvalue': 42})
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 42}

def test_use_kwargs_decorator_on_a_method(testapp):

    class MyMethodView(MethodView):
        @parser.use_kwargs({'myvalue': Arg(int)})
        def post(self, myvalue):
            return jsonify({'myvalue': myvalue})

    testapp.add_url_rule('/methodview/',
        view_func=MyMethodView.as_view(str('mymethodview')))
    test_client = testapp.test_client()
    res = test_client.post('/methodview/', data={'myvalue': 42})
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 42}


def test_use_args_decorator_with_url_parameters(testapp):
    @testapp.route('/foo/<int:id>', methods=['post', 'get'])
    @parser.use_args({'myvalue': Arg(type_=int)})
    def echo(args, id):
        assert id == 42
        return jsonify(args)
    test_client = testapp.test_client()
    res = test_client.post('/foo/42', data={'myvalue': 23})
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 23}

def test_use_args_singleton(testapp):
    @testapp.route('/foo/')
    @use_args({'myvalue': Arg(int)})
    def echo(args):
        return jsonify(args)
    test_client = testapp.test_client()
    res = test_client.get('/foo/?myvalue=42')
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 42}

def test_use_args_doesnt_change_docstring(testapp):
    @testapp.route('/foo/', methods=['post', 'get'])
    @parser.use_args({'myvalue': Arg(type_=int)})
    def echo(args, id):
        """Echo docstring."""
        return jsonify(args)
    assert echo.__doc__ == 'Echo docstring.'

def test_use_kwargs_decorator(testapp):
    @testapp.route('/foo/', methods=['post', 'get'])
    @parser.use_kwargs({'myvalue': Arg(type_=int)})
    def echo(myvalue):
        return jsonify(myvalue=myvalue)
    test_client = testapp.test_client()
    res = test_client.post('/foo/', data={'myvalue': 23})
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 23}

def test_use_kwargs_decorator_with_url_parameters(testapp):
    @testapp.route('/foo/<int:id>', methods=['post', 'get'])
    @parser.use_kwargs({'myvalue': Arg(type_=int)})
    def echo(myvalue, id):
        assert id == 42
        return jsonify(myvalue=myvalue)
    test_client = testapp.test_client()
    res = test_client.post('/foo/42', data={'myvalue': 23})
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 23}

def test_use_kwargs_singleton(testapp):
    @testapp.route('/foo/')
    @use_kwargs({'myvalue': Arg(int)})
    def echo(myvalue):
        return jsonify(myvalue=myvalue)
    test_client = testapp.test_client()
    res = test_client.get('/foo/?myvalue=42')
    assert json.loads(res.data.decode('utf-8')) == {'myvalue': 42}

def test_use_kwargs_doesnt_change_docstring(testapp):
    @testapp.route('/foo/', methods=['post', 'get'])
    @parser.use_kwargs({'myvalue': Arg(type_=int)})
    def echo(args, id):
        """Echo docstring."""
        return jsonify(args)
    assert echo.__doc__ == 'Echo docstring.'

@mock.patch('webargs.flaskparser.abort')
def test_abort_called_when_required_arg_not_present(mock_abort, testapp):
    args = {'required': Arg(required=True)}
    with testapp.test_request_context('/foo', method='post',
        data=json.dumps({}), content_type='application/json'):
        parser.parse(args)
        assert mock_abort.called_once_with(400)

def test_arg_allowed_missing(testapp):
    # 'last' argument is allowed to be missing
    args = {'first': Arg(str), 'last': Arg(str, allow_missing=True)}
    with testapp.test_request_context('/foo', method='post',
            data=json.dumps({'first': 'Fred'}), content_type='application/json'):
        args = parser.parse(args)
        assert 'first' in args
        assert 'last' not in args

def test_parsing_headers(testapp):
    with testapp.test_request_context('/foo', headers={'Name': 'Fred'}):
        args = parser.parse(hello_args, targets=('headers',))
        # Header key is lowercased
        assert args['name'] == 'Fred'

def test_parsing_cookies(testapp):
    @testapp.route('/getcookiearg')
    def echo():
        args = parser.parse(hello_args, targets=('cookies',))
        return jsonify(args)
    testclient = testapp.test_client()
    testclient.set_cookie('localhost', key='name', value='Fred')
    res = testclient.get('/getcookiearg')
    assert json.loads(res.data.decode('utf-8')) == {'name': 'Fred'}

def test_parse_form_returns_none_if_no_form():
    req = mock.Mock()
    req.form.get.side_effect = AttributeError('no form')
    assert parser.parse_form(req, 'foo', Arg()) is None

def test_unicode_arg(testapp):
    with testapp.test_request_context('/foo?name=Früd'):
        args = parser.parse(hello_args)
        assert args['name'] == 'Früd'

def test_abort_with_message():
    with pytest.raises(HTTPException) as excinfo:
        abort(400, message='custom error message')
    assert excinfo.value.data['message'] == 'custom error message'


def test_parse_files(testapp):
    payload = {'myfile': (io.BytesIO(b'bar'), 'baz.txt')}
    file_args = {'myfile': Arg()}
    with testapp.test_request_context('/foo', method='POST',
            data=payload):
        args = parser.parse(file_args, targets=('files', ))
        assert args['myfile'].read() == b'bar'

@pytest.mark.parametrize('context', [
    # querystring
    {'path': '/foo?name=steve&name=Loria&nums=4&nums=2'},
    # form
    {'path': '/foo', 'method': 'POST', 'data': ImmutableMultiDict(
        [('name', 'steve'), ('name', 'Loria'),
         ('nums', 4), ('nums', 2)])},
])
def test_parse_multiple(context, testapp):
    multargs = {'name': Arg(multiple=True), 'nums': Arg(int, multiple=True)}
    with testapp.test_request_context(**context):
        args = parser.parse(multargs)
        assert args['name'] == ['steve', 'Loria']
        assert args['nums'] == [4, 2]

def test_parse_multiple_arg_with_single_value(testapp):
    multargs = {'name': Arg(multiple=True)}
    with testapp.test_request_context('/foo?name=steve'):
        args = parser.parse(multargs)
        assert args['name'] == ['steve']

def test_parse_multiple_arg_defaults_to_empty_list(testapp):
    multargs = {'name': Arg(multiple=True)}
    with testapp.test_request_context('/foo'):
        args = parser.parse(multargs)
        assert args['name'] == []

def test_parse_multiple_json(testapp):
    multargs = {'name': Arg(multiple=True)}
    with testapp.test_request_context('/foo', data=json.dumps({'name': 'steve'}),
            content_type='application/json', method='POST'):
        args = parser.parse(multargs, targets=('json',))
        assert args['name'] == ['steve']



########NEW FILE########
__FILENAME__ = test_tornadoparser
# -*- coding: utf-8 -*-

import json
import itertools
try:
    from urllib import urlencode  # python2
except ImportError:
    from urllib.parse import urlencode  # python3

import pytest

import tornado.web
import tornado.httputil
import tornado.httpserver

from webargs import Arg
from webargs.tornadoparser import parser, use_args, use_kwargs


class TestQueryArgs(object):
    def test_it_should_get_single_values(self):
        query = [(name, value)]
        arg = Arg(multiple=False)
        request = make_get_request(query)

        result = parser.parse_querystring(request, name, arg)

        assert result == bvalue

    def test_it_should_get_multiple_values(self):
        query = [(name, value), (name, value)]
        arg = Arg(multiple=True)
        request = make_get_request(query)

        result = parser.parse_querystring(request, name, arg)

        assert result == [bvalue, bvalue]

    def test_it_should_return_none_if_not_present(self):
        query = []
        arg = Arg(multiple=False)
        request = make_get_request(query)

        result = parser.parse_querystring(request, name, arg)

        assert result == None

    def test_it_should_return_empty_list_if_multiple_and_not_present(self):
        query = []
        arg = Arg(multiple=True)
        request = make_get_request(query)

        result = parser.parse_querystring(request, name, arg)

        assert result == []


class TestFormArgs(object):
    def test_it_should_get_single_values(self):
        query = [(name, value)]
        arg = Arg(multiple=False)
        request = make_form_request(query)

        result = parser.parse_form(request, name, arg)

        assert result == bvalue

    def test_it_should_get_multiple_values(self):
        query = [(name, value), (name, value)]
        arg = Arg(multiple=True)
        request = make_form_request(query)

        result = parser.parse_form(request, name, arg)

        assert result == [bvalue, bvalue]

    def test_it_should_return_none_if_not_present(self):
        query = []
        arg = Arg(multiple=False)
        request = make_form_request(query)

        result = parser.parse_form(request, name, arg)

        assert result == None

    def test_it_should_return_empty_list_if_multiple_and_not_present(self):
        query = []
        arg = Arg(multiple=True)
        request = make_form_request(query)

        result = parser.parse_form(request, name, arg)

        assert result == []


class TestJSONArgs(object):
    def test_it_should_get_single_values(self):
        query = {name: value}
        arg = Arg(multiple=False)
        request = make_json_request(query)

        parser._parse_json_body(request)
        result = parser.parse_json(request, name, arg)

        assert result == value

    def test_it_should_get_multiple_values(self):
        query = {name: [value, value]}
        arg = Arg(multiple=True)
        request = make_json_request(query)

        parser._parse_json_body(request)
        result = parser.parse_json(request, name, arg)

        assert result == [value, value]

    def test_it_should_return_none_if_not_present(self):
        query = {}
        arg = Arg(multiple=False)
        request = make_json_request(query)

        parser._parse_json_body(request)
        result = parser.parse_json(request, name, arg)

        assert result == None

    def test_it_should_return_empty_list_if_multiple_and_not_present(self):
        query = {}
        arg = Arg(multiple=True)
        request = make_json_request(query)

        parser._parse_json_body(request)
        result = parser.parse_json(request, name, arg)

        assert result == []


class TestHeadersArgs(object):
    def test_it_should_get_single_values(self):
        query = {name: value}
        arg = Arg(multiple=False)
        request = make_request(headers=query)

        result = parser.parse_headers(request, name, arg)

        assert result == value

    def test_it_should_get_multiple_values(self):
        query = {name: [value, value]}
        arg = Arg(multiple=True)
        request = make_request(headers=query)

        result = parser.parse_headers(request, name, arg)

        assert result == [value, value]

    def test_it_should_return_none_if_not_present(self):
        query = {}
        arg = Arg(multiple=False)
        request = make_request(headers=query)

        result = parser.parse_headers(request, name, arg)

        assert result == None

    def test_it_should_return_empty_list_if_multiple_and_not_present(self):
        query = {}
        arg = Arg(multiple=True)
        request = make_request(headers=query)

        result = parser.parse_headers(request, name, arg)

        assert result == []


class TestFilesArgs(object):
    def test_it_should_get_single_values(self):
        query = [(name, value)]
        arg = Arg(multiple=False)
        request = make_files_request(query)

        result = parser.parse_files(request, name, arg)

        assert result == value

    def test_it_should_get_multiple_values(self):
        query = [(name, value), (name, value)]
        arg = Arg(multiple=True)
        request = make_files_request(query)

        result = parser.parse_files(request, name, arg)

        assert result == [value, value]

    def test_it_should_return_none_if_not_present(self):
        query = []
        arg = Arg(multiple=False)
        request = make_files_request(query)

        result = parser.parse_files(request, name, arg)

        assert result == None

    def test_it_should_return_empty_list_if_multiple_and_not_present(self):
        query = []
        arg = Arg(multiple=True)
        request = make_files_request(query)

        result = parser.parse_files(request, name, arg)

        assert result == []


class TestErrorHandler(object):
    def test_it_should_fail_with_bad_request_on_error(self):
        with pytest.raises(tornado.web.HTTPError) as error:
            parser.parse(None, make_request())


class TestParse(object):
    def test_it_should_parse_query_arguments(self):
        attrs = {
            'string': Arg(),
            'integer': Arg(int, multiple=True)
        }

        request = make_get_request([
            ('string', 'value'),('integer', '1'), ('integer', '2')
        ])

        parsed = parser.parse(attrs, request)

        assert parsed['integer'] == [1, 2]
        assert parsed['string'] == bvalue

    def test_it_should_parse_form_arguments(self):
        attrs = {
            'string': Arg(),
            'integer': Arg(int, multiple=True)
        }

        request = make_form_request([
            ('string', 'value'),('integer', '1'), ('integer', '2')
        ])

        parsed = parser.parse(attrs, request)

        assert parsed['integer'] == [1, 2]
        assert parsed['string'] == bvalue

    def test_it_should_parse_json_arguments(self):
        attrs = {
            'string': Arg(str),
            'integer': Arg(int, multiple=True)
        }

        request = make_json_request({
            'string': 'value',
            'integer': [1, 2]
        })

        parsed = parser.parse(attrs, request)

        assert parsed['integer'] == [1, 2]
        assert parsed['string'] == value

    def test_it_should_parse_header_arguments(self):
        attrs = {
            'string': Arg(str),
            'integer': Arg(int, multiple=True)
        }

        request = make_request(headers={
            'string': 'value',
            'integer': ['1', '2']
        })

        parsed = parser.parse(attrs, request, targets=['headers'])

        assert parsed['string'] == value
        assert parsed['integer'] == [1, 2]

    def test_it_should_parse_cookies_arguments(self):
        attrs = {
            'string': Arg(str),
            'integer': Arg(int, multiple=True)
        }

        request = make_cookie_request([
            ('string', 'value'),('integer', '1'), ('integer', '2')
        ])

        parsed = parser.parse(attrs, request, targets=['cookies'])

        assert parsed['string'] == value
        assert parsed['integer'] == [2]

    def test_it_should_parse_files_arguments(self):
        attrs = {
            'string': Arg(str),
            'integer': Arg(int, multiple=True)
        }

        request = make_files_request([
            ('string', 'value'),('integer', '1'), ('integer', '2')
        ])

        parsed = parser.parse(attrs, request, targets=['files'])

        assert parsed['string'] == value
        assert parsed['integer'] == [1, 2]


class TestUseArgs(object):
    def test_it_should_pass_parsed_as_first_argument(self):
        class Handler(object):
            request = make_json_request({'key': 'value'})

            @use_args({'key': Arg()})
            def get(self, *args, **kwargs):
                assert args[0] == {'key': 'value'}
                assert kwargs == {}
                return True

        handler = Handler()
        result = handler.get()

        assert result is True

    def test_it_should_pass_parsed_as_kwargs_arguments(self):
        class Handler(object):
            request = make_json_request({'key': 'value'})

            @use_kwargs({'key': Arg()})
            def get(self, *args, **kwargs):
                assert args == ()
                assert kwargs == {'key': 'value'}
                return True

        handler = Handler()
        result = handler.get()

        assert result is True


name = 'name'
bvalue = b'value'
value = 'value'


def make_uri(args):
    return '/test?' + urlencode(args)


def make_form_body(args):
    return urlencode(args)


def make_json_body(args):
    return json.dumps(args)


def make_get_request(args):
    return make_request(uri=make_uri(args))


def make_form_request(args):
    return make_request(
        body=make_form_body(args),
        headers={
            'Content-Type': 'application/x-www-form-urlencoded'
        }
    )


def make_json_request(args):
    return make_request(
        body=make_json_body(args),
        headers={
            'Content-Type': 'application/json'
        }
    )


def make_cookie_request(args):
    return make_request(
        headers={
            'Cookie': ' ;'.join('='.join(pair) for pair in args)
        }
    )


def make_files_request(args):
    files = {}

    for key, value in args:
        if isinstance(value, list):
            files.setdefault(key, []).extend(value)
        else:
            files.setdefault(key, []).append(value)

    return make_request(files=files)


def make_request(uri=None, body=None, headers=None, files=None):
    uri = uri if uri is not None else u''
    body = body if body is not None else u''
    method = 'POST' if body else 'GET'

    request = tornado.httpserver.HTTPRequest(
        method=method, uri=uri, body=body, headers=headers, files=files)

    content_type = headers.get('Content-Type', u'') if headers else u''

    tornado.httputil.parse_body_arguments(
        content_type=content_type,
        body=body.encode('latin-1'),  # Tornado expects bodies to be latin-1
        arguments=request.body_arguments,
        files=request.files
    )

    return request

########NEW FILE########
__FILENAME__ = bottleparser
# -*- coding: utf-8 -*-
"""Bottle request argument parsing module.

Example: ::

    from bottle import route
    from webargs import Arg
    from webargs.bottleparser import use_args

    hello_args = {
        'name': Arg(str, default='World')
    }

    @route('/', method=['GET', 'POST'])
    @use_args(hello_args)
    def index(args)
        return 'Hello ' + args['name']
"""
from bottle import abort, request

from webargs import core


class BottleParser(core.Parser):
    """Bottle.py request argument parser."""

    def parse_querystring(self, req, name, arg):
        """Pull a querystring value from the request."""
        return core.get_value(req.query, name, arg.multiple)


    def parse_form(self, req, name, arg):
        """Pull a form value from the request."""
        return core.get_value(req.forms, name, arg.multiple)

    def parse_json(self, req, name, arg):
        """Pull a json value from the request."""
        try:
            return core.get_value(req.json, name, arg.multiple)
        except (AttributeError, ValueError):
            return None

    def parse_headers(self, req, name, arg):
        """Pull a value from the header data."""
        return core.get_value(req.headers, name, arg.multiple)

    def parse_cookies(self, req, name, arg):
        """Pull a value from the cookiejar."""
        return req.get_cookie(name)

    def parse_files(self, req, name, arg):
        """Pull a file from the request."""
        return core.get_value(req.files, name, arg.multiple)

    def handle_error(self, error):
        """Handles errors during parsing. Aborts the current request with a
        400 error.
        """
        return abort(400, str(error))

    def parse(self, argmap, req=None, *args, **kwargs):
        """Parses the request using the given arguments map.
        Uses Bottle's context-local request object if req=None.
        """
        req_obj = req or request  # Default to context-local request
        return super(BottleParser, self).parse(argmap, req_obj, *args, **kwargs)

parser = BottleParser()
use_args = parser.use_args
use_kwargs = parser.use_kwargs

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-
import sys
import functools

PY2 = sys.version_info[0] == 2

if not PY2:
    iteritems = lambda d: iter(d.items())
else:
    iteritems = lambda d: d.iteritems()


class WebargsError(Exception):
    """Base class for all webargs-related errors."""
    pass


class ValidationError(WebargsError):
    """Raised in case of an argument validation error."""
    def __init__(self, underlying_exception):
        super(ValidationError, self).__init__(str(underlying_exception))


def _callable(obj):
    """Makes sure an object is callable if it is not ``None``. If not
    callable, a ValueError is raised.
    """
    if obj and not callable(obj):
        raise ValueError('{0!r} is not callable.'.format(obj))
    else:
        return obj


def get_value(d, name, multiple, method='get'):
    func = getattr(d, method)
    val = func(name)
    if multiple:
        if hasattr(d, 'getlist'):
            return d.getlist(name)
        elif hasattr(d, 'getall'):
            return d.getall(name)
        else:
            return [val]
    return val


def noop(x):
    return x


class Arg(object):
    """A request argument.

    :param default: Default value for the argument. Used if the value is not found
        on the request.
    :param type type\_: Value type. Will try to convert the passed in value to this
        type. If ``None``, no type conversion will be performed.
    :param callable validate: Callable (function or object with ``__call__`` method
        defined) used for custom validation. Returns whether or not the
        value is valid.
    :param callable use: Callable used for converting or pre-processing the value.
        Defaults to noop.
        Example: ``use=lambda s: s.lower()``
    :param bool multiple: Return a list of values for the argument. Useful for
        querystrings or forms that pass multiple values to the same parameter,
        e.g. ``/?name=foo&name=bar``
    :param str error: Custom error message to use if validation fails.
    :param bool allow_missing: If the argument's value is ``None``, don't
        include it in the returned arguments dictionary.
    """
    def __init__(self, type_=None, default=None, required=False,
                 validate=None, use=None, multiple=False, error=None,
                 allow_missing=False, target=None):
        self.type = type_ or noop  # default to no type conversion
        if multiple and default is None:
            self.default = []
        else:
            self.default = default
        self.required = required
        self.validate = _callable(validate) or (lambda x: True)
        self.use = _callable(use) or noop
        self.error = error
        self.multiple = multiple
        if required and allow_missing:
            raise ValueError('"required" and "allow_missing" cannot both be True.')
        self.allow_missing = allow_missing
        self.target = target

    def _validate(self, value):
        """Perform conversion and validation on ``value``."""
        ret = value
        # First convert the value
        try:
            ret = self.use(self.type(value))
        except ValueError as error:
            raise ValidationError(self.error or error)
        # Then call validation function
        if not self.validate(ret):
            msg = 'Validator {0}({1}) is not True'.format(
                self.validate.__name__, ret
            )
            raise ValidationError(self.error or msg)
        return ret

    def validated(self, value):
        """Convert and validate the given value according to the ``type_``,
        ``use``, and ``validate`` attributes.

        :returns: The validated, converted value
        :raises: ValidationError if validation fails
        """
        if self.multiple and isinstance(value, list):
            return [self._validate(each) for each in value]
        else:
            return self._validate(value)


class Parser(object):
    """Base parser class that provides high-level implementation for parsing
    a request.

    Descendant classes must provide lower-level implementations for parsing
    different targets, e.g. ``parse_json``, ``parse_querystring``, etc.

    :param tuple targets: Default targets to parse.
    :param callable error_handler: Custom error handler function.
    """
    DEFAULT_TARGETS = ('querystring', 'form', 'json',)

    #: Maps target => method name
    TARGET_MAP = {
        'json': 'parse_json',
        'querystring': 'parse_querystring',
        'form': 'parse_form',
        'headers': 'parse_headers',
        'cookies': 'parse_cookies',
        'files': 'parse_files',
    }

    def __init__(self, targets=None, error_handler=None):
        self.targets = targets or self.DEFAULT_TARGETS
        self.error_handler = _callable(error_handler)

    def _validated_targets(self, targets):
        """Ensure that the given targets argument is valid.

        :raises: ValueError if a given targets includes an invalid target.
        """
        # The set difference between the given targets and the available targets
        # will be the set of invalid targets
        valid_targets = set(self.TARGET_MAP.keys())
        given = set(targets)
        invalid_targets = given - valid_targets
        if len(invalid_targets):
            msg = "Invalid targets arguments: {0}".format(list(invalid_targets))
            raise ValueError(msg)
        return targets

    def __get_value(self, name, argobj, req, target):
            method_name = self.TARGET_MAP.get(target)
            if method_name:
                method = getattr(self, method_name)
                value = method(req, name, argobj)
            else:
                value = None
            return value

    def parse_arg(self, name, argobj, req, targets=None):
        """Parse a single argument.

        :param str name: The name of the value.
        :param Arg argobj: The ``Arg`` object.
        :param req: The request object to parse.
        :param tuple targets: The targets ('json', 'querystring', etc.) where
            to search for the value.
        :return: The argument value.
        """
        value = None
        if argobj.target:
            value = self.__get_value(name, argobj, req=req, target=argobj.target)
            if value is not None:
                return argobj.validated(value)

        for target in self._validated_targets(targets or self.targets):
            value = self.__get_value(name, argobj, req=req, target=target)
            if argobj.multiple and not (isinstance(value, list) and len(value)):
                continue
            # Found the value; validate and return it
            if value is not None:
                return argobj.validated(value)
        if value is None:
            if argobj.default is not None:
                value = argobj.default
            else:
                value = self.fallback(req, name, argobj)
            if not value and argobj.required:
                raise ValidationError('Required parameter {0!r} not found.'.format(name))
        return value

    def parse(self, argmap, req, targets=None):
        """Main request parsing method.

        :param dict argmap: Dictionary of argname:Arg object pairs.
        :param req: The request object to parse.
        :param tuple targets: Where on the request to search for values.
            Can include one or more of ``('json', 'querystring', 'form',
            'headers', 'cookies', 'files')``.
        :return: A dictionary of parsed arguments
        """
        try:
            parsed = {}
            for argname, argobj in iteritems(argmap):
                parsed_value = self.parse_arg(argname, argobj, req,
                    targets=targets or self.targets)
                # Skip missing values
                if parsed_value is None and argobj.allow_missing:
                    continue
                else:
                    parsed[argname] = parsed_value
            return parsed
        except Exception as error:
            if self.error_handler:
                self.error_handler(error)
            else:
                self.handle_error(error)

    def use_args(self, argmap, req=None, targets=None, as_kwargs=False):
        """Decorator that injects parsed arguments into a view function or method.

        Example usage with Flask: ::

            @app.route('/echo', methods=['get', 'post'])
            @parser.use_args({'name': Arg(type_=str)})
            def greet(args):
                return 'Hello ' + args['name']

        :param dict argmap: Dictionary of argument_name:Arg object pairs.
        :param tuple targets: Where on the request to search for values.
        :param bool as_kwargs: Whether to insert arguments as keyword arguments.
        """
        targets = targets or self.DEFAULT_TARGETS
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                parsed_args = self.parse(argmap, req=req, targets=targets)
                if as_kwargs:
                    kwargs.update(parsed_args)
                    return func(*args, **kwargs)
                else:
                    # Wrapped function is a method, so inject parsed_args
                    # after 'self'
                    if args and args[0]:
                        return func(args[0], parsed_args, *args[1:], **kwargs)
                    return func(parsed_args, *args, **kwargs)
            return wrapper
        return decorator

    def use_kwargs(self, *args, **kwargs):
        """Decorator that injects parsed arguments into a view function or method as keyword arguments.

        This is a shortcut to :py:func:`use_args` with as_kwargs=True

        Example usage with Flask: ::

            @app.route('/echo', methods=['get', 'post'])
            @parser.use_kwargs({'name': Arg(type_=str)})
            def greet(name):
                return 'Hello ' + name
        """
        kwargs['as_kwargs'] = True
        return self.use_args(*args, **kwargs)

    # Abstract Methods

    def parse_json(self, req, name, arg):
        """Pulls a JSON value from a request object or returns ``None`` if the
        value cannot be found.
        """
        return None

    def parse_querystring(self, req, name, arg):
        """Pulls a value from the query string of a request object or returns ``None`` if
        the value cannot be found.
        """
        return None

    def parse_form(self, req, name, arg):
        """Pulls a value from the form data of a request object or returns
        ``None`` if the value cannot be found.
        """
        return None

    def parse_headers(self, req, name, arg):
        """Pulls a value from the headers or returns ``None`` if the value
        cannot be found.
        """
        return None

    def parse_cookies(self, req, name, arg):
        """Pulls a cookie value from the request or returns ``None`` if the value
        cannot be found.
        """
        return None

    def parse_files(self, req, name, arg):
        """Pull a file from the request or return ``None`` if the value file
        cannot be found.
        """
        return None

    def handle_error(self, error):
        """Called if an error occurs while parsing args.
        """
        raise error

    def fallback(self, req, name, arg):
        """Called if all other parsing functions (parse_json, parse_form...) return
        ``None``.
        """
        return None

########NEW FILE########
__FILENAME__ = djangoparser
# -*- coding: utf-8 -*-
"""Django request argument parsing.

Example usage: ::

    from django.views.generic import View
    from django.http import HttpResponse
    from webargs import Arg
    from webargs.djangoparser import use_args

    hello_args = {
        'name': Arg(str, default='World')
    }

    class MyView(View):

        @use_args(hello_args)
        def get(self, args, request):
            return HttpResponse('Hello ' + args['name'])
"""
import json
import functools

from webargs import core


class DjangoParser(core.Parser):
    """Django request argument parser."""

    def parse_querystring(self, req, name, arg):
        """Pull the querystring value from the request."""
        return core.get_value(req.GET, name, arg.multiple)

    def parse_form(self, req, name, arg):
        """Pull the form value from the request."""
        return core.get_value(req.POST, name, arg.multiple)

    def parse_json(self, req, name, arg):
        """Pull a json value from the request body."""
        try:
            reqdata = json.loads(req.body.decode('utf-8'))
            return core.get_value(reqdata, name, arg.multiple)
        except (AttributeError, ValueError):
            return None

    def parse_cookies(self, req, name, arg):
        """Pull the value from the cookiejar."""
        return core.get_value(req.COOKIES, name, arg.multiple)

    def parse_headers(self, req, name, arg):
        raise NotImplementedError('Header parsing not supported by {0}'
            .format(self.__class__.__name__))

    def parse_files(self, req, name, arg):
        """Pull a file from the request."""
        return core.get_value(req.FILES, name, arg.multiple)

    def use_args(self, argmap, req=None, targets=core.Parser.DEFAULT_TARGETS):
        """Decorator that injects parsed arguments into a view function or method.

        Example: ::

            @parser.use_args({'name': 'World'})
            def myview(request, args):
                return HttpResponse('Hello ' + args['name'])

        :param dict argmap: Dictionary of argument_name:Arg object pairs.
        :param req: The request object to parse
        :param tuple targets: Where on the request to search for values.
        """
        def decorator(func):
            @functools.wraps(func)
            def wrapper(obj, *args, **kwargs):
                # The first argument is either `self` or `request`
                try:  # get self.request
                    request = obj.request
                except AttributeError:  # first arg is request
                    request = obj
                parsed_args = self.parse(argmap, req=request, targets=targets)
                return func(obj, parsed_args, *args, **kwargs)
            return wrapper
        return decorator

parser = DjangoParser()
use_args = parser.use_args
use_kwargs = parser.use_kwargs

########NEW FILE########
__FILENAME__ = flaskparser
# -*- coding: utf-8 -*-
"""Flask request argument parsing module.

Example: ::

    from flask import Flask
    from webargs import Arg
    from webargs.flaskparser import use_args

    app = Flask(__name__)

    hello_args = {
        'name': Arg(str, required=True)
    }

    @app.route('/')
    @use_args(hello_args)
    def index(args):
        return 'Hello ' + args['name']
"""
from flask import request, abort as flask_abort
from werkzeug.exceptions import HTTPException

from webargs import core

def abort(http_status_code, **kwargs):
    """Raise a HTTPException for the given http_status_code. Attach any keyword
    arguments to the exception for later processing.

    From Flask-Restful. See NOTICE file for license information.
    """
    try:
        flask_abort(http_status_code)
    except HTTPException as err:
        if len(kwargs):
            err.data = kwargs
        raise err


class FlaskParser(core.Parser):
    """Flask request argument parser."""

    def parse_json(self, req, name, arg):
        """Pull a json value from the request."""
        if req.content_type == 'application/json' and hasattr(req, 'json'):
            try:
                return core.get_value(req.json, name, arg.multiple)
            except AttributeError:
                return None
        else:
            return None

    def parse_querystring(self, req, name, arg):
        """Pull a querystring value from the request."""
        return core.get_value(req.args, name, arg.multiple)

    def parse_form(self, req, name, arg):
        """Pull a form value from the request."""
        try:
            return core.get_value(req.form, name, arg.multiple)
        except AttributeError:
            return None

    def parse_headers(self, req, name, arg):
        """Pull a value from the header data."""
        return core.get_value(req.headers, name, arg.multiple)

    def parse_cookies(self, req, name, arg):
        """Pull a value from the cookiejar."""
        return core.get_value(req.cookies, name, arg.multiple)

    def parse_files(self, req, name, arg):
        """Pull a file from the request."""
        return core.get_value(req.files, name, arg.multiple)

    def handle_error(self, error):
        """Handles errors during parsing. Aborts the current HTTP request and
        responds with a 400 error.
        """
        abort(400, message=error)

    def parse(self, argmap, req=None, *args, **kwargs):
        """Parses the request using the given arguments map.
        Uses Flask's context-local request object if req=None.
        """
        req_obj = req or request  # Default to context-local request
        return super(FlaskParser, self).parse(argmap, req_obj, *args, **kwargs)

parser = FlaskParser()
use_args = parser.use_args
use_kwargs = parser.use_kwargs

########NEW FILE########
__FILENAME__ = tornadoparser
# -*- coding: utf-8 -*-

import json
import functools

import tornado.web

from webargs import core


class TornadoParser(core.Parser):
    """Tornado request argument parser."""

    def parse_json(self, req, name, arg):
        """Pull a json value from the request."""
        return self.json.get(name, [] if arg.multiple else None)

    def parse_querystring(self, req, name, arg):
        """Pull a querystring value from the request."""
        return get_value(req.query_arguments, name, arg.multiple)

    def parse_form(self, req, name, arg):
        """Pull a form value from the request."""
        return get_value(req.body_arguments, name, arg.multiple)

    def parse_headers(self, req, name, arg):
        """Pull a value from the header data."""
        return get_value(req.headers, name, arg.multiple)

    def parse_cookies(self, req, name, arg):
        """Pull a value from the header data."""
        cookie = req.cookies.get(name)

        if cookie is not None:
            return [cookie.value] if arg.multiple else cookie.value
        else:
            return [] if arg.multiple else None

    def parse_files(self, req, name, arg):
        """Pull a file from the request."""
        return get_value(req.files, name, arg.multiple)

    def handle_error(self, error):
        """Handles errors during parsing. Raises a `tornado.web.HTTPError`
        with a 400 error.
        """
        raise tornado.web.HTTPError(400, error)

    def _parse_json_body(self, req):
        if req.headers.get('Content-Type') == 'application/json':
            self.json = json.loads(req.body)
        else:
            self.json = {}

    def parse(self, argmap, req, *args, **kwargs):
        """Parses the request using the given arguments map.

        Initializes :attr:`json` attribute.
        """
        self._parse_json_body(req)
        return super(TornadoParser, self).parse(argmap, req, *args, **kwargs)

    def use_args(self, argmap, req=None, targets=core.Parser.DEFAULT_TARGETS,
                as_kwargs=False):
        """Decorator that injects parsed arguments into a view function or method.

        Example: ::

            @parser.use_kwargs({'name': Arg(type_=str)})
            def myview(request, args):
                self.write('Hello ' + args['name'])

        :param dict argmap: Dictionary of argument_name:Arg object pairs.
        :param req: The request object to parse
        :param tuple targets: Where on the request to search for values.
        :param as_kwargs: Wether to pass arguments to the handler as kwargs
        """
        def decorator(func):
            @functools.wraps(func)
            def wrapper(obj, *args, **kwargs):
                parsed_args = self.parse(
                    argmap, req=obj.request, targets=targets)

                if as_kwargs:
                    kwargs.update(parsed_args)
                else:
                    args = (parsed_args,) + args

                return func(obj, *args, **kwargs)
            return wrapper
        return decorator


def get_value(d, name, multiple):
    """Handle gets from 'multidicts' made of lists

    It handles cases: ``{"key": [value]}`` and ``{"key": value}``
    """
    value = d.get(name)

    if multiple:
        return [] if value is None else value

    if value and isinstance(value, list):
        return value[0]

    return value


parser = TornadoParser()
use_args = parser.use_args
use_kwargs = parser.use_kwargs

########NEW FILE########
