__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# txZMQ documentation build configuration file, created by
# sphinx-quickstart on Mon Oct 29 00:35:01 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.extlinks',
              'sphinx.ext.viewcode']

autodoc_member_order = 'bysource'

_tm_base = 'http://twistedmatrix.com/documents/current/api/'
extlinks = {'tm': (_tm_base + 'twisted.%s.html', '')}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'txZMQ'
copyright = u'2012, Andrey Smirnov'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = open('../VERSION').read().strip()
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'txZMQdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'txZMQ.tex', u'txZMQ Documentation',
   u'Andrey Smirnov', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'txzmq', u'txZMQ Documentation',
     [u'Andrey Smirnov'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'txZMQ', u'txZMQ Documentation',
   u'Andrey Smirnov', 'txZMQ', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = integration_test
#!env/bin/python

"""
Trying simple REQ/REP interaction to verify that txZMQ works.

Required for Python3 until Trial stats working.
"""
from __future__ import print_function, unicode_literals

import os
import sys

from twisted.internet import reactor

rootdir = os.path.realpath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
sys.path.insert(0, rootdir)
os.chdir(rootdir)

from txzmq import ZmqEndpoint, ZmqFactory, ZmqREQConnection, ZmqREPConnection

zf = ZmqFactory()
endpoint = "ipc:///tmp/txzmq-test"


req = ZmqREQConnection(zf, ZmqEndpoint("connect", endpoint))
rep = ZmqREPConnection(zf, ZmqEndpoint("bind", endpoint))


def gotMessage(messageId, message):
    rep.reply(messageId, b"REP: " + message)

rep.gotMessage = gotMessage
exitCode = 0


def start():
    def gotReply(reply):
        if reply != [b"REP: REQ1"]:
            print("Unexpected reply: %r" % (reply, ))

            global exitCode
            exitCode = 1
            reactor.crash()
            return

        print("OK")
        reactor.crash()

    req.sendMsg(b"REQ1").addCallback(gotReply)

reactor.callWhenRunning(reactor.callLater, 1, start)

reactor.run()
sys.exit(exitCode)

########NEW FILE########
__FILENAME__ = pub_sub
#!env/bin/python

"""
Example txzmq client.

    examples/pub_sub.py --method=bind --endpoint=ipc:///tmp/sock --mode=publisher

    examples/pub_sub.py --method=connect --endpoint=ipc:///tmp/sock --mode=subscriber
"""
import os
import sys
import time
from optparse import OptionParser

from twisted.internet import reactor

rootdir = os.path.realpath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
sys.path.append(rootdir)
os.chdir(rootdir)

from txzmq import ZmqEndpoint, ZmqFactory, ZmqPubConnection, ZmqSubConnection


parser = OptionParser("")
parser.add_option("-m", "--method", dest="method", help="0MQ socket connection: bind|connect")
parser.add_option("-e", "--endpoint", dest="endpoint", help="0MQ Endpoint")
parser.add_option("-M", "--mode", dest="mode", help="Mode: publisher|subscriber")
parser.set_defaults(method="connect", endpoint="epgm://eth1;239.0.5.3:10011")

(options, args) = parser.parse_args()

zf = ZmqFactory()
e = ZmqEndpoint(options.method, options.endpoint)

if options.mode == "publisher":
    s = ZmqPubConnection(zf, e)

    def publish():
        data = str(time.time())
        print "publishing %r" % data
        s.publish(data)

        reactor.callLater(1, publish)

    publish()
else:
    s = ZmqSubConnection(zf, e)
    s.subscribe("")

    def doPrint(*args):
        print "message received: %r" % (args, )

    s.gotMessage = doPrint

reactor.run()

########NEW FILE########
__FILENAME__ = push_pull
#!env/bin/python

"""
Example txzmq client.

    examples/push_pull.py --method=connect --endpoint=ipc:///tmp/sock
    --mode=push

    examples/push_pull.py --method=bind --endpoint=ipc:///tmp/sock
    --mode=pull
"""
import os
import socket
import sys
import time
import zmq
from optparse import OptionParser

from twisted.internet import reactor

rootdir = os.path.realpath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
sys.path.insert(0, rootdir)
os.chdir(rootdir)

from txzmq import ZmqEndpoint, ZmqFactory, ZmqPushConnection, ZmqPullConnection


parser = OptionParser("")
parser.add_option("-m", "--method", dest="method", help="0MQ socket connection: bind|connect")
parser.add_option("-e", "--endpoint", dest="endpoint", help="0MQ Endpoint")
parser.add_option("-M", "--mode", dest="mode", help="Mode: push|pull")
parser.set_defaults(method="connect", endpoint="ipc:///tmp/txzmq-pc-demo")

(options, args) = parser.parse_args()

zf = ZmqFactory()
e = ZmqEndpoint(options.method, options.endpoint)

if options.mode == "push":
    s = ZmqPushConnection(zf, e)

    def produce():
        data = [str(time.time()), socket.gethostname()]
        print "producing %r" % data
        try:
            s.push(data)
        except zmq.error.Again:
            print "Skipping, no pull consumers..."

        reactor.callLater(1, produce)

    reactor.callWhenRunning(reactor.callLater, 1, produce)
else:
    s = ZmqPullConnection(zf, e)

    def doPrint(message):
        print "consuming %r" % (message,)

    s.onPull = doPrint

reactor.run()

########NEW FILE########
__FILENAME__ = req_rep
#!env/bin/python

"""
Example txzmq client.

    examples/req_rep.py --method=connect --endpoint=ipc:///tmp/req_rep_sock --mode=req

    examples/req_rep.py --method=bind --endpoint=ipc:///tmp/req_rep_sock --mode=rep
"""
import os
import sys
import time
import zmq
from optparse import OptionParser

from twisted.internet import reactor

rootdir = os.path.realpath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
sys.path.insert(0, rootdir)
os.chdir(rootdir)

from txzmq import ZmqEndpoint, ZmqFactory, ZmqREQConnection, ZmqREPConnection, ZmqRequestTimeoutError


parser = OptionParser("")
parser.add_option("-m", "--method", dest="method", help="0MQ socket connection: bind|connect")
parser.add_option("-e", "--endpoint", dest="endpoint", help="0MQ Endpoint")
parser.add_option("-M", "--mode", dest="mode", help="Mode: req|rep")
parser.set_defaults(method="connect", endpoint="ipc:///tmp/txzmq-pc-demo")

(options, args) = parser.parse_args()

zf = ZmqFactory()
e = ZmqEndpoint(options.method, options.endpoint)

if options.mode == "req":
    s = ZmqREQConnection(zf, e)

    def produce():
        # data = [str(time.time()), socket.gethostname()]
        data = str(time.time())

        print "Requesting %r" % data
        try:
            d = s.sendMsg(data, timeout=0.95)

            def doPrint(reply):
                print("Got reply: %s" % (reply))

            def onTimeout(fail):
                fail.trap(ZmqRequestTimeoutError)
                print "Timeout on request, is reply server running?"

            d.addCallback(doPrint).addErrback(onTimeout)

        except zmq.error.Again:
            print "Skipping, no pull consumers..."

        reactor.callLater(1, produce)

    reactor.callWhenRunning(reactor.callLater, 1, produce)
else:
    s = ZmqREPConnection(zf, e)

    def doPrint(messageId, message):
        print "Replying to %s, %r" % (messageId, message)
        s.reply(messageId, "%s %r " % (messageId, message))

    s.gotMessage = doPrint

reactor.run()

########NEW FILE########
__FILENAME__ = connection
"""
ZeroMQ connection.
"""
from collections import deque, namedtuple

from zmq import constants, error
from zmq import Socket

from zope.interface import implementer

from twisted.internet import reactor
from twisted.internet.interfaces import IFileDescriptor, IReadDescriptor
from twisted.python import log

from zmq import zmq_version_info
ZMQ3 = zmq_version_info()[0] >= 3


class ZmqEndpointType(object):
    """
    Endpoint could be "bound" or "connected".
    """
    bind = "bind"
    """
    Bind, listen for connection.
    """
    connect = "connect"
    """
    Connect to another endpoint.
    """


class ZmqEndpoint(namedtuple('ZmqEndpoint', ['type', 'address'])):
    """
    ZeroMQ endpoint used when connecting or listening for connections.

    Consists of two members: `type` and `address`.

    :var type: Could be either :attr:`ZmqEndpointType.bind` or
        :attr:`ZmqEndpointType.connect`.
    :var address: ZeroMQ address of endpoint, could be IP address,
        filename, see ZeroMQ docs for more details.
    :vartype address: str
    """


@implementer(IReadDescriptor, IFileDescriptor)
class ZmqConnection(object):
    """
    Connection through ZeroMQ, wraps up ZeroMQ socket.

    This class isn't supposed to be used directly, instead use one of the
    descendants like :class:`ZmqPushConnection`.

    :class:`ZmqConnection` implements glue between ZeroMQ and Twisted
    reactor: putting polling ZeroMQ file descriptor into reactor,
    processing events, reading data from socket.

    :var socketType: socket type, from ZeroMQ
    :var allowLoopbackMulticast: is loopback multicast allowed?
    :vartype allowLoopbackMulticast: bool
    :var multicastRate: maximum allowed multicast rate, kbps
    :vartype multicastRate: int
    :var highWaterMark: hard limit on the maximum number of outstanding
        messages 0MQ shall queue in memory for any single peer
    :vartype highWaterMark: int
    :var tcpKeepalive: if set to 1, enable TCP keepalive, otherwise leave
        it as default
    :vartype tcpKeepalive: int
    :var tcpKeepaliveCount: override TCP_KEEPCNT socket option
        (where supported by OS)
    :vartype tcpKeepaliveCount: int
    :var tcpKeepaliveIdle: override TCP_KEEPCNT(or TCP_KEEPALIVE
        on some OS) socket option(where supported by OS).
    :vartype tcpKeepaliveIdle: int
    :var tcpKeepaliveInterval: override TCP_KEEPINTVL socket
        option(where supported by OS)
    :vartype tcpKeepaliveInterval: int
    :var reconnectInterval: set reconnection interval
    :vartype reconnectInterval: int
    :var reconnectIntervalMax: set maximum reconnection interval
    :vartype reconnectIntervalMax: int
    :var factory: ZeroMQ Twisted factory reference
    :vartype factory: :class:`ZmqFactory`
    :var socket: ZeroMQ Socket
    :vartype socket: zmq.Socket
    :var endpoints: ZeroMQ addresses for connect/bind
    :vartype endpoints: list of :class:`ZmqEndpoint`
    :var fd: file descriptor of zmq mailbox
    :vartype fd: int
    :var queue: output message queue
    :vartype queue: deque
    """

    socketType = None
    allowLoopbackMulticast = False
    multicastRate = 100
    highWaterMark = 0

    # Only supported by zeromq3 and pyzmq>=2.2.0.1
    tcpKeepalive = 0
    tcpKeepaliveCount = 0
    tcpKeepaliveIdle = 0
    tcpKeepaliveInterval = 0

    reconnectInterval = 100
    reconnectIntervalMax = 0

    def __init__(self, factory, endpoint=None, identity=None):
        """
        Constructor.

        One endpoint is passed to the constructor, more could be added
        via call to :meth:`addEndpoints`.

        :param factory: ZeroMQ Twisted factory
        :type factory: :class:`ZmqFactory`
        :param endpoint: ZeroMQ address for connect/bind
        :type endpoint:  :class:`ZmqEndpoint`
        :param identity: socket identity (ZeroMQ), don't set unless you know
            how it works
        :type identity: str
        """
        self.factory = factory
        self.endpoints = []
        self.identity = identity
        self.socket = Socket(factory.context, self.socketType)
        self.queue = deque()
        self.recv_parts = []
        self.read_scheduled = None

        self.fd = self.socket.get(constants.FD)
        self.socket.set(constants.LINGER, factory.lingerPeriod)

        if not ZMQ3:
            self.socket.set(
                constants.MCAST_LOOP, int(self.allowLoopbackMulticast))

        self.socket.set(constants.RATE, self.multicastRate)

        if not ZMQ3:
            self.socket.set(constants.HWM, self.highWaterMark)
        else:
            self.socket.set(constants.SNDHWM, self.highWaterMark)
            self.socket.set(constants.RCVHWM, self.highWaterMark)

        if ZMQ3 and self.tcpKeepalive:
            self.socket.set(
                constants.TCP_KEEPALIVE, self.tcpKeepalive)
            self.socket.set(
                constants.TCP_KEEPALIVE_CNT, self.tcpKeepaliveCount)
            self.socket.set(
                constants.TCP_KEEPALIVE_IDLE, self.tcpKeepaliveIdle)
            self.socket.set(
                constants.TCP_KEEPALIVE_INTVL, self.tcpKeepaliveInterval)

        if ZMQ3 and self.reconnectInterval:
            self.socket.set(
                constants.RECONNECT_IVL, self.reconnectInterval)

        if ZMQ3 and self.reconnectIntervalMax:
            self.socket.set(
                constants.RECONNECT_IVL_MAX, self.reconnectIntervalMax)

        if self.identity is not None:
            self.socket.set(constants.IDENTITY, self.identity)

        if endpoint:
            self.addEndpoints([endpoint])

        self.factory.connections.add(self)

        self.factory.reactor.addReader(self)
        self.doRead()

    def addEndpoints(self, endpoints):
        """
        Add more connection endpoints.

        Connection may have many endpoints, mixing ZeroMQ protocols
        (TCP, IPC, ...) and types (connect or bind).

        :param endpoints: list of endpoints to add
        :type endpoints: list of :class:`ZmqEndpoint`
        """
        self.endpoints.extend(endpoints)
        self._connectOrBind(endpoints)

    def shutdown(self):
        """
        Shutdown (close) connection and ZeroMQ socket.
        """
        self.factory.reactor.removeReader(self)

        self.factory.connections.discard(self)

        self.socket.close()
        self.socket = None

        self.factory = None

        if self.read_scheduled is not None:
            self.read_scheduled.cancel()
            self.read_scheduled = None

    def __repr__(self):
        return "%s(%r, %r)" % (
            self.__class__.__name__, self.factory, self.endpoints)

    def fileno(self):
        """
        Implementation of :tm:`IFileDescriptor
        <internet.interfaces.IFileDescriptor>`.

        Returns ZeroMQ polling file descriptor.

        :return: The platform-specified representation of a file descriptor
            number.
        """
        return self.fd

    def connectionLost(self, reason):
        """
        Called when the connection was lost.

        Implementation of :tm:`IFileDescriptor
        <internet.interfaces.IFileDescriptor>`.

        This is called when the connection on a selectable object has been
        lost.  It will be called whether the connection was closed explicitly,
        an exception occurred in an event handler, or the other end of the
        connection closed it first.
        """
        if self.factory:
            self.factory.reactor.removeReader(self)

    def _readMultipart(self):
        """
        Read multipart in non-blocking manner, returns with ready message
        or raising exception (in case of no more messages available).
        """
        while True:
            self.recv_parts.append(self.socket.recv(constants.NOBLOCK))
            if not self.socket.get(constants.RCVMORE):
                result, self.recv_parts = self.recv_parts, []

                return result

    def doRead(self):
        """
        Some data is available for reading on ZeroMQ descriptor.

        ZeroMQ is signalling that we should process some events,
        we're starting to receive incoming messages.

        Implementation of :tm:`IReadDescriptor
        <internet.interfaces.IReadDescriptor>`.
        """
        if self.read_scheduled is not None:
            if not self.read_scheduled.called:
                self.read_scheduled.cancel()
            self.read_scheduled = None

        while True:
            if self.factory is None:  # disconnected
                return

            events = self.socket.get(constants.EVENTS)

            if (events & constants.POLLIN) != constants.POLLIN:
                return

            try:
                message = self._readMultipart()
            except error.ZMQError as e:
                if e.errno == constants.EAGAIN:
                    continue

                raise e

            log.callWithLogger(self, self.messageReceived, message)

    def logPrefix(self):
        """
        Implementation of :tm:`ILoggingContext
        <internet.interfaces.ILoggingContext>`.

        :return: Prefix used during log formatting to indicate context.
        :rtype: str
        """
        return 'ZMQ'

    def send(self, message):
        """
        Send message via ZeroMQ socket.

        Sending is performed directly to ZeroMQ without queueing. If HWM is
        reached on ZeroMQ side, sending operation is aborted with exception
        from ZeroMQ (EAGAIN).

        After writing read is scheduled as ZeroMQ may not signal incoming
        messages after we touched socket with write request.

        :param message: message data, could be either list of str (multipart
            message) or just str
        :type message: str or list of str
        """
        if not hasattr(message, '__iter__'):
            self.socket.send(message, constants.NOBLOCK)
        else:
            for m in message[:-1]:
                self.socket.send(m, constants.NOBLOCK | constants.SNDMORE)
            self.socket.send(message[-1], constants.NOBLOCK)

        if self.read_scheduled is None:
            self.read_scheduled = reactor.callLater(0, self.doRead)

    def messageReceived(self, message):
        """
        Called when complete message is received.

        Not implemented in :class:`ZmqConnection`, should be overridden to
        handle incoming messages.

        :param message: message data
        """
        raise NotImplementedError(self)

    def _connectOrBind(self, endpoints):
        """
        Connect and/or bind socket to endpoints.
        """
        for endpoint in endpoints:
            if endpoint.type == ZmqEndpointType.connect:
                self.socket.connect(endpoint.address)
            elif endpoint.type == ZmqEndpointType.bind:
                self.socket.bind(endpoint.address)
            else:
                assert False, "Unknown endpoint type %r" % endpoint

########NEW FILE########
__FILENAME__ = factory
"""
ZeroMQ Twisted factory which is controlling ZeroMQ context.
"""
from zmq import Context

from twisted.internet import reactor


class ZmqFactory(object):
    """
    I control individual ZeroMQ connections.

    Factory creates and destroys ZeroMQ context.

    :var reactor: reference to Twisted reactor used by all the connections
    :var ioThreads: number of IO threads ZeroMQ will be using for this context
    :vartype ioThreads: int
    :var lingerPeriod: number of milliseconds to block when closing socket
        (terminating context), when there are some messages pending to be sent
    :vartype lingerPeriod: int

    :var connections: set of instanciated :class:`ZmqConnection`
    :vartype connections: set
    :var context: ZeroMQ context
    """

    reactor = reactor
    ioThreads = 1
    lingerPeriod = 100

    def __init__(self):
        """
        Constructor.

        Create ZeroMQ context.
        """
        self.connections = set()
        self.context = Context(self.ioThreads)

    def __repr__(self):
        return "ZmqFactory()"

    def shutdown(self):
        """
        Shutdown factory.

        This is shutting down all created connections
        and terminating ZeroMQ context. Also cleans up
        Twisted reactor.
        """
        for connection in self.connections.copy():
            connection.shutdown()

        self.connections = None

        self.context.term()
        self.context = None

    def registerForShutdown(self):
        """
        Register factory to be automatically shut down
        on reactor shutdown.

        It is recommended that this method is called on any
        created factory.
        """
        reactor.addSystemEventTrigger('during', 'shutdown', self.shutdown)

########NEW FILE########
__FILENAME__ = pubsub
"""
ZeroMQ PUB-SUB wrappers.
"""
from __future__ import unicode_literals

from zmq import constants

from txzmq.connection import ZmqConnection


class ZmqPubConnection(ZmqConnection):
    """
    Publishing in broadcast manner.
    """
    socketType = constants.PUB

    def publish(self, message, tag=''):
        """
        Publish `message` with specified `tag`.

        :param message: message data
        :type message: str
        :param tag: message tag
        :type tag: str
        """
        self.send(tag + b'\0' + message)


class ZmqSubConnection(ZmqConnection):
    """
    Subscribing to messages published by publishers.

    Subclass this class and implement :meth:`gotMessage` to handle incoming
    messages.
    """
    socketType = constants.SUB

    def subscribe(self, tag):
        """
        Subscribe to messages with specified tag (prefix).

        Function may be called several times.

        :param tag: message tag
        :type tag: str
        """
        self.socket.set(constants.SUBSCRIBE, tag)

    def unsubscribe(self, tag):
        """
        Unsubscribe from messages with specified tag (prefix).

        Function may be called several times.

        :param tag: message tag
        :type tag: str
        """
        self.socket.set(constants.UNSUBSCRIBE, tag)

    def messageReceived(self, message):
        """
        Overridden from :class:`ZmqConnection` to process
        and unframe incoming messages.

        All parsed messages are passed to :meth:`gotMessage`.

        :param message: message data
        """
        if len(message) == 2:
            # compatibility receiving of tag as first part
            # of multi-part message
            self.gotMessage(message[1], message[0])
        else:
            self.gotMessage(*reversed(message[0].split(b'\0', 1)))

    def gotMessage(self, message, tag):
        """
        Called on incoming message recevied by subscriber.

        Should be overridden to handle incoming messages.

        :param message: message data
        :param tag: message tag
        """
        raise NotImplementedError(self)

########NEW FILE########
__FILENAME__ = pushpull
"""
ZeroMQ PUSH-PULL wrappers.
"""
from zmq import constants

from txzmq.connection import ZmqConnection


class ZmqPushConnection(ZmqConnection):
    """
    Pushing messages to the socket.

    Wrapper around ZeroMQ PUSH socket.
    """
    socketType = constants.PUSH

    def push(self, message):
        """
        Push a message L{message}.

        :param message: message data
        :type message: str
        """
        self.send(message)


class ZmqPullConnection(ZmqConnection):
    """
    Pull messages from a socket.

    Wrapper around ZeroMQ PULL socket.

    Subclass and override :meth:`onPull`.
    """
    socketType = constants.PULL

    def messageReceived(self, message):
        """
        Called on incoming message from ZeroMQ.

        :param message: message data
        """
        self.onPull(message)

    def onPull(self, message):
        """
        Called on incoming message received by puller.

        :param message: message data
        """
        raise NotImplementedError(self)

########NEW FILE########
__FILENAME__ = req_rep
"""
ZeroMQ REQ-REP wrappers.
"""
from __future__ import unicode_literals

import uuid
import warnings

from zmq import constants

from twisted.internet import defer, reactor

from txzmq.connection import ZmqConnection


class ZmqRequestTimeoutError(Exception):
    """
    Request has been timed out.
    """


class ZmqREQConnection(ZmqConnection):
    """
    A Request ZeroMQ connection.

    This is implemented with an underlying DEALER socket, even though
    semantics are closer to REQ socket.

    Socket mimics request-reply behavior by sending each message with unique
    uuid and recording Deferred associated with the message. When reply comes,
    it uses that Deferred to pass response back to the caller.

    :var defaultRequestTimeout: default timeout for requests, disabled
        by default (seconds)
    :type defaultRequestTimeout: float
    """
    socketType = constants.DEALER
    defaultRequestTimeout = None

    # the number of new UUIDs to generate when the pool runs out of them
    UUID_POOL_GEN_SIZE = 5

    def __init__(self, *args, **kwargs):
        ZmqConnection.__init__(self, *args, **kwargs)
        self._requests = {}
        self._uuids = []

    def _getNextId(self):
        """
        Returns an unique id.

        By default, generates pool of UUID in increments
        of ``UUID_POOL_GEN_SIZE``. Could be overridden to
        provide custom ID generation.

        :return: generated unique "on the wire" message ID
        :rtype: str
        """
        if not self._uuids:
            for _ in range(self.UUID_POOL_GEN_SIZE):
                self._uuids.append(uuid.uuid4().bytes)
        return self._uuids.pop()

    def _releaseId(self, msgId):
        """
        Release message ID to the pool.

        @param msgId: message ID, no longer on the wire
        @type msgId: C{str}
        """
        self._uuids.append(msgId)
        if len(self._uuids) > 2 * self.UUID_POOL_GEN_SIZE:
            self._uuids[-self.UUID_POOL_GEN_SIZE:] = []

    def _cancel(self, msgId):
        """
        Cancel outstanding REQ, drop reply silently.

        @param msgId: message ID to cancel
        @type msgId: C{str}
        """
        self._requests.pop(msgId, (None, None))

    def _timeoutRequest(self, msgId):
        """
        Cancel timedout request.
        @param msgId: message ID to cancel
        @type msgId: C{str}
        """
        d, _ = self._requests.pop(msgId, (None, None))
        if not d.called:
            d.errback(ZmqRequestTimeoutError(msgId))

    def sendMsg(self, *messageParts, **kwargs):
        """
        Send request and deliver response back when available.

        :param messageParts: message data
        :type messageParts: tuple
        :param timeout: as keyword argument, timeout on request
        :type timeout: float
        :return: Deferred that will fire when response comes back
        """
        messageId = self._getNextId()
        d = defer.Deferred(canceller=lambda _: self._cancel(messageId))

        timeout = kwargs.pop('timeout', None)
        if timeout is None:
            timeout = self.defaultRequestTimeout
        assert len(kwargs) == 0, "Unsupported keyword argument"

        canceller = None
        if timeout is not None:
            canceller = reactor.callLater(timeout, self._timeoutRequest,
                                          messageId)

        self._requests[messageId] = (d, canceller)
        self.send([messageId, b''] + list(messageParts))
        return d

    def messageReceived(self, message):
        """
        Called on incoming message from ZeroMQ.

        Dispatches message to back to the requestor.

        :param message: message data
        """
        msgId, msg = message[0], message[2:]
        self._releaseId(msgId)
        d, canceller = self._requests.pop(msgId, (None, None))

        if canceller is not None and canceller.active():
            canceller.cancel()

        if d is None:
            # reply came for timed out or cancelled request, drop it silently
            return

        d.callback(msg)


class ZmqREPConnection(ZmqConnection):
    """
    A Reply ZeroMQ connection.

    This is implemented with an underlying ROUTER socket, but the semantics
    are close to REP socket.
    """
    socketType = constants.ROUTER

    def __init__(self, *args, **kwargs):
        ZmqConnection.__init__(self, *args, **kwargs)
        self._routingInfo = {}  # keep track of routing info

    def reply(self, messageId, *messageParts):
        """
        Send reply to request with specified ``messageId``.

        :param messageId: message uuid
        :type messageId: str
        :param message: message data
        :type message: str
        """
        routingInfo = self._routingInfo.pop(messageId)
        self.send(routingInfo + [messageId, b''] + list(messageParts))

    def messageReceived(self, message):
        """
        Called on incoming message from ZeroMQ.

        :param message: message data
        """
        i = message.index(b'')
        assert i > 0
        (routingInfo, msgId, payload) = (
            message[:i - 1], message[i - 1], message[i + 1:])
        msgParts = payload[0:]
        self._routingInfo[msgId] = routingInfo
        self.gotMessage(msgId, *msgParts)

    def gotMessage(self, messageId, *messageParts):
        """
        Called on incoming request.

        Override this method in subclass and reply using
        :meth:`reply` using the same ``messageId``.

        :param messageId: message uuid
        :type messageId: str
        :param messageParts: message data
        """
        raise NotImplementedError(self)


class ZmqXREPConnection(ZmqREPConnection):
    """
    Provided for backwards compatibility.

    Deprecated in favour of either ZmqREPConnection or ZmqROUTERConnection.

    """

    def __init__(self, factory, *endpoints):
        warnings.warn("ZmqXREPConnection is deprecated in favour of "
                      "either ZmqREPConnection or ZmqROUTERConnection",
                      DeprecationWarning)
        ZmqREPConnection.__init__(self, factory)
        self.add_endpoints(endpoints)


class ZmqXREQConnection(ZmqREQConnection):
    """
    Provided for backwards compatibility.

    Deprecated in favour of either ZmqREQConnection or ZmqDEALERConnection.

    """

    def __init__(self, factory, *endpoints):
        warnings.warn("ZmqXREQConnection is deprecated in favour of "
                      "either ZmqREQConnection or ZmqDEALERConnection",
                      DeprecationWarning)
        ZmqREQConnection.__init__(self, factory)
        self.add_endpoints(endpoints)

########NEW FILE########
__FILENAME__ = router_dealer
"""
ZeroMQ ROUTER and DEALER connection types.
"""

from zmq import constants

from txzmq.connection import ZmqConnection


# TODO: ideally, all connection classes would inherit from this in the future
# so that we'd have a consistent wrapper API over all underlying socket types.
class ZmqBase(ZmqConnection):
    """
    Base class for all ZMQ connection classes with a uniform interface.

    Subclasses should override sendMsg and sendMultipart with their own
    connection-type specific implementations, which can have a different
    argument signature. Thus, ZmqBase does not attempt to hide away the
    differences between different connection classes--this is simply
    impossible--It simply attempts to provide a more consistent way of
    interacting with them.

    By default, these methods simply delegate to the unerlying low-level
    ZmqConnection.send, which handles both single and multi-part messages.

    Subclasses can/should add their own semantic aliases for sendMsg and
    sendMultipart, such as publish and publishMultipart for a PUB socket.
    """
    def sendMsg(self, message):
        """
        Provides a higher level wrapper over ZmqConnection.send for sending
        single-part messages.

        @param message: message data
        @type message: C{str}
        """
        self.sendMultipart([message])

    def sendMultipart(self, parts):
        """
        Provides a higher level wrapper over ZmqConnection.send for sending
        multipart messages.

        @param parts: message data
        """
        self.send(parts)

    def messageReceived(self, message):
        """
        Called on incoming message from ZeroMQ.

        Override this to handle generic messages received and pass them to
        gotMessage with a socket-type specific signature.

        @param message: message data
        """
        self.gotMessage(*message)

    def gotMessage(self, *args, **kwargs):
        raise NotImplementedError


class ZmqDealerConnection(ZmqBase):
    """
    Raw ZeroMQ DEALER connection.
    """
    socketType = constants.DEALER


class ZmqRouterConnection(ZmqBase):
    """
    Raw ZeroMQ ROUTER connection.
    """
    socketType = constants.ROUTER

    def sendMsg(self, recipientId, message):
        self.send([recipientId, message])

    def sendMultipart(self, recipientId, parts):
        self.send([recipientId] + parts)

    def messageReceived(self, message):
        sender_id = message.pop(0)
        self.gotMessage(sender_id, *message)

########NEW FILE########
__FILENAME__ = test_connection
"""
Tests for L{txzmq.connection}.
"""
from zmq import constants

from zope.interface import verify as ziv

from twisted.internet.interfaces import IFileDescriptor, IReadDescriptor
from twisted.trial import unittest

from txzmq.connection import ZmqConnection, ZmqEndpoint, ZmqEndpointType
from txzmq.factory import ZmqFactory
from txzmq.test import _wait


class ZmqTestSender(ZmqConnection):
    socketType = constants.PUSH


class ZmqTestReceiver(ZmqConnection):
    socketType = constants.PULL

    def messageReceived(self, message):
        if not hasattr(self, 'messages'):
            self.messages = []

        self.messages.append(message)


class ZmqConnectionTestCase(unittest.TestCase):
    """
    Test case for L{zmq.twisted.connection.Connection}.
    """

    def setUp(self):
        self.factory = ZmqFactory()

    def tearDown(self):
        self.factory.shutdown()

    def test_interfaces(self):
        ziv.verifyClass(IReadDescriptor, ZmqConnection)
        ziv.verifyClass(IFileDescriptor, ZmqConnection)

    def test_init(self):
        ZmqTestReceiver(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind, "inproc://#1"))
        ZmqTestSender(
            self.factory, ZmqEndpoint(ZmqEndpointType.connect, "inproc://#1"))

    def test_addEndpoints(self):
        r = ZmqTestReceiver(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind, "inproc://#1"))
        r.addEndpoints([ZmqEndpoint(ZmqEndpointType.bind, "inproc://#2"),
                        ZmqEndpoint(ZmqEndpointType.bind, "inproc://#3")])

        s = ZmqTestSender(
            self.factory, ZmqEndpoint(ZmqEndpointType.connect, "inproc://#3"))

        s.send('abcd')

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = [['abcd']]
            self.failUnlessEqual(
                result, expected, "Message should have been received")

        return _wait(0.01).addCallback(check)

    def test_repr(self):
        expected = ("ZmqTestReceiver(ZmqFactory(), "
                    "[ZmqEndpoint(type='bind', address='inproc://#1')])")
        result = ZmqTestReceiver(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind, "inproc://#1"))
        self.failUnlessEqual(expected, repr(result))

    def test_send_recv(self):
        r = ZmqTestReceiver(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind, "inproc://#1"))
        s = ZmqTestSender(
            self.factory, ZmqEndpoint(ZmqEndpointType.connect, "inproc://#1"))

        s.send('abcd')

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = [['abcd']]
            self.failUnlessEqual(
                result, expected, "Message should have been received")

        return _wait(0.01).addCallback(check)

    def test_send_recv_tcp(self):
        r = ZmqTestReceiver(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind,
                                      "tcp://127.0.0.1:5555"))
        s = ZmqTestSender(
            self.factory, ZmqEndpoint(ZmqEndpointType.connect,
                                      "tcp://127.0.0.1:5555"))

        for i in range(100):
            s.send(str(i))

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = map(lambda i: [str(i)], range(100))
            self.failUnlessEqual(
                result, expected, "Messages should have been received")

        return _wait(0.01).addCallback(check)

    def test_send_recv_tcp_large(self):
        r = ZmqTestReceiver(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind,
                                      "tcp://127.0.0.1:5555"))
        s = ZmqTestSender(
            self.factory, ZmqEndpoint(ZmqEndpointType.connect,
                                      "tcp://127.0.0.1:5555"))

        s.send(["0" * 10000, "1" * 10000])

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = [["0" * 10000, "1" * 10000]]
            self.failUnlessEqual(
                result, expected, "Messages should have been received")

        return _wait(0.01).addCallback(check)

########NEW FILE########
__FILENAME__ = test_factory
"""
Tests for L{txzmq.factory}.
"""
from twisted.trial import unittest

from txzmq.factory import ZmqFactory


class ZmqFactoryTestCase(unittest.TestCase):
    """
    Test case for L{zmq.twisted.factory.Factory}.
    """

    def setUp(self):
        self.factory = ZmqFactory()

    def test_shutdown(self):
        self.factory.shutdown()

########NEW FILE########
__FILENAME__ = test_pubsub
"""
Tests for L{txzmq.pubsub}.
"""
from twisted.trial import unittest

from txzmq.connection import ZmqEndpoint, ZmqEndpointType
from txzmq.factory import ZmqFactory
from txzmq.pubsub import ZmqPubConnection, ZmqSubConnection
from txzmq.test import _wait

from zmq.error import ZMQError


class ZmqTestSubConnection(ZmqSubConnection):
    def gotMessage(self, message, tag):
        if not hasattr(self, 'messages'):
            self.messages = []

        self.messages.append([tag, message])


def _detect_epgm():
    """
    Utility function to test for presence of epgm:// in zeromq.
    """
    import zmq

    context = zmq.Context()
    socket = zmq.Socket(context, zmq.constants.PUB)

    try:
        socket.bind("epgm://127.0.0.1;239.192.1.1:5557")

        return True
    except ZMQError:
        return False


class ZmqConnectionTestCase(unittest.TestCase):
    """
    Test case for L{zmq.twisted.connection.Connection}.

    In ZeroMQ 2.x, subscription is handled on receiving side:
    incoming messages are simply filtered, that's why connection.subscribe
    works immediately.

    In ZeroMQ 3.x, subscription is handled on publisher side:
    subscriber sends message to the publisher and publisher adjusts
    filtering on its side. So connection.subscribe doesn't start filtering
    immediately, it takes some time for messages to pass through the channel.
    """

    def setUp(self):
        self.factory = ZmqFactory()
        ZmqPubConnection.allowLoopbackMulticast = True

    def tearDown(self):
        del ZmqPubConnection.allowLoopbackMulticast
        self.factory.shutdown()

    def test_send_recv(self):
        r = ZmqTestSubConnection(
            self.factory, ZmqEndpoint(ZmqEndpointType.bind, "ipc://test-sock"))
        s = ZmqPubConnection(
            self.factory, ZmqEndpoint(ZmqEndpointType.connect,
                                      "ipc://test-sock"))

        r.subscribe('tag')

        def publish(ignore):
            s.publish('xyz', 'different-tag')
            s.publish('abcd', 'tag1')
            s.publish('efgh', 'tag2')

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = [['tag1', 'abcd'], ['tag2', 'efgh']]
            self.failUnlessEqual(
                result, expected, "Message should have been received")

        return _wait(0.01).addCallback(publish) \
            .addCallback(lambda _: _wait(0.01)).addCallback(check)

    def test_send_recv_pgm(self):
        r = ZmqTestSubConnection(self.factory, ZmqEndpoint(
            ZmqEndpointType.bind, "epgm://127.0.0.1;239.192.1.1:5556"))

        s = ZmqPubConnection(self.factory, ZmqEndpoint(
            ZmqEndpointType.connect, "epgm://127.0.0.1;239.192.1.1:5556"))

        r.subscribe('tag')

        def publish(ignore):
            s.publish('xyz', 'different-tag')
            s.publish('abcd', 'tag1')

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = [['tag1', 'abcd']]
            self.failUnlessEqual(
                result, expected, "Message should have been received")

        return _wait(0.2).addCallback(publish) \
            .addCallback(lambda _: _wait(0.2)).addCallback(check)

    def test_send_recv_multiple_endpoints(self):
        r = ZmqTestSubConnection(
            self.factory,
            ZmqEndpoint(ZmqEndpointType.bind, "tcp://127.0.0.1:5556"))
        r.addEndpoints([ZmqEndpoint(ZmqEndpointType.bind,
                                    "inproc://endpoint")])
        s1 = ZmqPubConnection(
            self.factory,
            ZmqEndpoint(ZmqEndpointType.connect, "tcp://127.0.0.1:5556"))
        s2 = ZmqPubConnection(
            self.factory,
            ZmqEndpoint(ZmqEndpointType.connect, "inproc://endpoint"))

        r.subscribe('')

        def publish(ignore):
            s1.publish('111', 'tag1')
            s2.publish('222', 'tag2')

        def check(ignore):
            result = getattr(r, 'messages', [])
            expected = [['tag1', '111'], ['tag2', '222']]
            self.failUnlessEqual(
                sorted(result), expected, "Message should have been received")

        return _wait(0.1).addCallback(publish) \
            .addCallback(lambda _: _wait(0.1)).addCallback(check)

    if not _detect_epgm():
        test_send_recv_pgm.skip = "epgm:// not available"

########NEW FILE########
__FILENAME__ = test_reqrep
"""
Tests for L{txzmq.req_rep}.
"""
from twisted.internet import defer, reactor
from twisted.trial import unittest

from txzmq.connection import ZmqEndpoint, ZmqEndpointType
from txzmq.factory import ZmqFactory
from txzmq.test import _wait
from txzmq.req_rep import ZmqREPConnection, ZmqREQConnection, \
    ZmqRequestTimeoutError


class ZmqTestREPConnection(ZmqREPConnection):
    def gotMessage(self, messageId, *messageParts):
        if not hasattr(self, 'messages'):
            self.messages = []
        self.messages.append([messageId, messageParts])
        self.reply(messageId, *messageParts)


class ZmqSlowREPConnection(ZmqREPConnection):
    def gotMessage(self, messageId, *messageParts):
        reactor.callLater(0.1, self.reply, messageId, *messageParts)


class ZmqREQREPConnectionTestCase(unittest.TestCase):
    """
    Test case for L{zmq.req_rep.ZmqREPConnection}.
    """

    def setUp(self):
        self.factory = ZmqFactory()
        b = ZmqEndpoint(ZmqEndpointType.bind, "ipc://#3")
        self.r = ZmqTestREPConnection(self.factory, b)
        c = ZmqEndpoint(ZmqEndpointType.connect, "ipc://#3")
        self.s = ZmqREQConnection(self.factory, c, identity='client')

    def tearDown(self):
        self.factory.shutdown()

    def test_getNextId(self):
        self.failUnlessEqual([], self.s._uuids)
        id1 = self.s._getNextId()
        self.failUnlessEqual(self.s.UUID_POOL_GEN_SIZE - 1, len(self.s._uuids))
        self.failUnlessIsInstance(id1, str)

        id2 = self.s._getNextId()
        self.failUnlessIsInstance(id2, str)

        self.failIfEqual(id1, id2)

        ids = [self.s._getNextId() for _ in range(1000)]
        self.failUnlessEqual(len(ids), len(set(ids)))

    def test_releaseId(self):
        self.s._releaseId(self.s._getNextId())
        self.failUnlessEqual(self.s.UUID_POOL_GEN_SIZE, len(self.s._uuids))

    def test_send_recv(self):
        self.count = 0

        def get_next_id():
            self.count += 1
            return 'msg_id_%d' % (self.count,)

        self.s._getNextId = get_next_id

        self.s.sendMsg('aaa', 'aab')
        self.s.sendMsg('bbb')

        def check(ignore):
            result = getattr(self.r, 'messages', [])
            expected = [['msg_id_1', ('aaa', 'aab')], ['msg_id_2', ('bbb',)]]
            self.failUnlessEqual(
                result, expected, "Message should have been received")

        return _wait(0.01).addCallback(check)

    def test_send_recv_reply(self):
        d = self.s.sendMsg('aaa')

        def check_response(response):
            self.assertEqual(response, ['aaa'])

        d.addCallback(check_response)
        return d

    def test_lot_send_recv_reply(self):
        deferreds = []
        for i in range(10):
            msg_id = "msg_id_%d" % (i,)
            d = self.s.sendMsg('aaa')

            def check_response(response, msg_id):
                self.assertEqual(response, ['aaa'])

            d.addCallback(check_response, msg_id)
            deferreds.append(d)
        return defer.DeferredList(deferreds, fireOnOneErrback=True)

    def test_cleanup_requests(self):
        """The request dict is cleanedup properly."""
        def check(ignore):
            self.assertEqual(self.s._requests, {})
            self.failUnlessEqual(self.s.UUID_POOL_GEN_SIZE, len(self.s._uuids))

        return self.s.sendMsg('aaa').addCallback(check)

    def test_cancel(self):
        d = self.s.sendMsg('aaa')
        d.cancel()

        def check_requests(_):
            self.assertEqual(self.s._requests, {})
            self.failUnlessEqual(self.s.UUID_POOL_GEN_SIZE,
                                 len(self.s._uuids) + 1)

        return d.addCallbacks(lambda _: self.fail("Should have errored"),
                              lambda fail: fail.trap(
                              "twisted.internet.defer.CancelledError")) \
            .addCallback(check_requests) \
            .addCallback(lambda _: _wait(0.01))

    def test_send_timeout_ok(self):
        return self.s.sendMsg('aaa', timeout=0.1) \
            .addCallback(lambda response: self.assertEquals(response, ['aaa']))

    def test_send_timeout_fail(self):
        b = ZmqEndpoint(ZmqEndpointType.bind, "ipc://#4")
        ZmqSlowREPConnection(self.factory, b)
        c = ZmqEndpoint(ZmqEndpointType.connect, "ipc://#4")
        s = ZmqREQConnection(self.factory, c, identity='client2')

        return s.sendMsg('aaa', timeout=0.05) \
            .addCallbacks(lambda _: self.fail("Should timeout"),
                          lambda fail: fail.trap(ZmqRequestTimeoutError)) \
            .addCallback(lambda _: _wait(0.1))


class ZmqReplyConnection(ZmqREPConnection):
    def messageReceived(self, message):
        if not hasattr(self, 'message_count'):
            self.message_count = 0

        if message[1] == 'stop':
            reactor.callLater(0, self.send, ['master', 'exit'])
        else:
            self.message_count += 1
            self.send(['master', 'event'])
            for _ in range(2):
                reactor.callLater(0, self.send, ['master', 'event'])


class ZmqRequestConnection(ZmqREQConnection):
    def messageReceived(self, message):
        if not hasattr(self, 'message_count'):
            self.message_count = 0
        if message[0] == 'event':
            self.message_count += 1
        elif message[0] == 'exit':
            self.d.callback(None)
        else:
            assert False


class ZmqREQREPTwoFactoryConnectionTestCase(unittest.TestCase):
    """
    Test case for L{zmq.req_rep} with REQ/REP in two factories.
    """

    REQUEST_COUNT = 10000

    def setUp(self):
        self.factory1 = ZmqFactory()
        self.factory2 = ZmqFactory()
        c = ZmqEndpoint(ZmqEndpointType.connect, "tcp://127.0.0.1:7859")
        self.c1 = ZmqRequestConnection(self.factory1, c, identity='master')
        b = ZmqEndpoint(ZmqEndpointType.bind, "tcp://127.0.0.1:7859")
        self.c2 = ZmqReplyConnection(self.factory2, b, identity='slave')
        self.c1.d = defer.Deferred()

    def tearDown(self):
        self.factory2.shutdown()
        self.factory1.shutdown()

    def test_start(self):
        for _ in range(self.REQUEST_COUNT):
            reactor.callLater(0, self.c1.send, 'req')
        reactor.callLater(0, self.c1.send, 'stop')

        def checkResults(_):
            self.failUnlessEqual(self.c1.message_count, 3 * self.REQUEST_COUNT)
            self.failUnlessEqual(self.c2.message_count, self.REQUEST_COUNT)

        return self.c1.d.addCallback(checkResults)

########NEW FILE########
__FILENAME__ = test_router_dealer
"""
Tests for L{txzmq.router_dealer}.
"""
from twisted.internet import defer, reactor
from twisted.trial import unittest

from txzmq.connection import ZmqEndpoint, ZmqEndpointType
from txzmq.factory import ZmqFactory
from txzmq.router_dealer import ZmqRouterConnection, ZmqDealerConnection


class ZmqTestRouterConnection(ZmqRouterConnection):
    message_count = 0

    def gotMessage(self, senderId, message):
        assert senderId == 'dealer'

        if message == 'stop':
            reactor.callLater(0, self.sendMsg, 'dealer', 'exit')
        else:
            self.message_count += 1
            self.sendMsg('dealer', 'event')
            for _ in range(2):
                reactor.callLater(0, self.sendMsg, 'dealer', 'event')


class ZmqTestDealerConnection(ZmqDealerConnection):
    message_count = 0

    def gotMessage(self, message):
        if message == 'event':
            self.message_count += 1
        elif message == 'exit':
            self.d.callback(None)
        else:
            assert False, "received unexpected message: %r" % (message,)


class ZmqRouterDealerTwoFactoryConnectionTestCase(unittest.TestCase):
    """
    Test case for L{txzmq.req_rep} with ROUTER/DEALER in two factories.
    """

    REQUEST_COUNT = 10000

    def setUp(self):
        self.factory1 = ZmqFactory()
        dealer_endpoint = ZmqEndpoint(ZmqEndpointType.connect, "ipc://#7")
        self.dealer = ZmqTestDealerConnection(self.factory1, dealer_endpoint,
                                              identity='dealer')
        self.dealer.d = defer.Deferred()

        self.factory2 = ZmqFactory()
        router_endpoint = ZmqEndpoint(ZmqEndpointType.bind, "ipc://#7")
        self.router = ZmqTestRouterConnection(self.factory2, router_endpoint,
                                              identity='router')

    def tearDown(self):
        self.factory2.shutdown()
        self.factory1.shutdown()

    def test_start(self):
        for _ in range(self.REQUEST_COUNT):
            reactor.callLater(0, self.dealer.sendMsg, 'req')
        reactor.callLater(0, self.dealer.sendMsg, 'stop')

        def checkResults(_):
            self.failUnlessEqual(self.dealer.message_count,
                                 3 * self.REQUEST_COUNT)
            self.failUnlessEqual(self.router.message_count, self.REQUEST_COUNT)

        return self.dealer.d.addCallback(checkResults)

########NEW FILE########
