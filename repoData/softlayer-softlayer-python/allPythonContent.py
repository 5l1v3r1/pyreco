__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# SoftLayer API Python Client documentation build configuration file, created by
# sphinx-quickstart on Fri Mar 22 11:08:48 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
# sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
# source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'SoftLayer API Python Client'
# Hack to avoid the "Redefining built-in 'copyright'" error from static
# analysis tools
globals()['copyright'] = u'2014, SoftLayer Technologies, Inc.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '3.1.0'
# The full version, including alpha/beta/rc tags.
release = '3.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
# today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'friendly'

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
if on_rtd:
    html_theme = 'default'
else:
    html_theme = 'nature'
    html_style = "style.css"

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
# html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
# html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
# html_domain_indices = True

# If false, no index is generated.
# html_use_index = True

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
# html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
# html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
# html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'SoftLayerAPIPythonClientdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
# 'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
# 'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
# 'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'SoftLayerAPIPythonClient.tex', u'SoftLayer API Python Client Documentation',
   u'SoftLayer Technologies, Inc.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# If true, show page references after internal links.
# latex_show_pagerefs = False

# If true, show URL addresses after external links.
# latex_show_urls = False

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'softlayerapipythonclient', u'SoftLayer API Python Client Documentation',
     [u'SoftLayer Technologies, Inc.'], 1)
]

# If true, show URL addresses after external links.
# man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'SoftLayerAPIPythonClient', u'SoftLayer API Python Client Documentation',
   u'SoftLayer Technologies, Inc.', 'SoftLayerAPIPythonClient', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
# texinfo_appendices = []

# If false, no module index is generated.
# texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
# texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = fabfile
import os.path
import shutil

from fabric.api import local, lcd, puts, abort


def make_html():
    "Build HTML docs"
    with lcd('docs'):
        local('make html')


def upload():
    "Upload distribution to PyPi"
    local('python setup.py sdist upload')
    local('python setup.py bdist_wheel upload')


def clean():
    puts("* Cleaning Repo")
    dirs = ['.tox', 'SoftLayer.egg-info', 'build', 'dist']
    for d in dirs:
        if os.path.exists(d) and os.path.isdir(d):
            shutil.rmtree(d)


def release(version, force=False):
    """Perform a release. Example:

    $ fab release:3.0.0

    """
    if version.startswith("v"):
        abort("Version should not start with 'v'")
    version_str = "v%s" % version

    clean()

    puts(" * Tagging Version %s" % version_str)
    f = 'f' if force else ''
    local("git tag -%sam \"%s\" %s" % (f, version_str, version_str))

    local("pip install wheel")

    puts(" * Uploading to PyPI")
    upload()

    puts(" * Pushing Tag to upstream")
    local("git push upstream %s" % version_str)

########NEW FILE########
__FILENAME__ = API
"""
    SoftLayer.API
    ~~~~~~~~~~~~~
    SoftLayer API bindings

    :license: MIT, see LICENSE for more details.
"""
import time

from .consts import API_PUBLIC_ENDPOINT, API_PRIVATE_ENDPOINT, USER_AGENT
from .transports import make_xml_rpc_api_call
from .auth import TokenAuthentication
from .config import get_client_settings


__all__ = ['Client', 'TimedClient', 'API_PUBLIC_ENDPOINT',
           'API_PRIVATE_ENDPOINT']

VALID_CALL_ARGS = set([
    'id',
    'mask',
    'filter',
    'headers',
    'compress',
    'raw_headers',
    'limit',
    'offset',
])


class Client(object):
    """ A SoftLayer API client.

    :param username: an optional API username if you wish to bypass the
        package's built-in username
    :param api_key: an optional API key if you wish to bypass the package's
        built in API key
    :param endpoint_url: the API endpoint base URL you wish to connect to.
        Set this to API_PRIVATE_ENDPOINT to connect via SoftLayer's private
        network.
    :param proxy: proxy to be used to make API calls
    :param integer timeout: timeout for API requests
    :param auth: an object which responds to get_headers() to be inserted into
        the xml-rpc headers. Example: `BasicAuthentication`
    :param config_file: A path to a configuration file used to load settings

    Usage:

        >>> import SoftLayer
        >>> client = SoftLayer.Client(username="username", api_key="api_key")
        >>> resp = client['Account'].getObject()
        >>> resp['companyName']
        'Your Company'

    """
    _prefix = "SoftLayer_"

    def __init__(self, username=None, api_key=None, endpoint_url=None,
                 timeout=None, auth=None, config_file=None, proxy=None):

        settings = get_client_settings(username=username,
                                       api_key=api_key,
                                       endpoint_url=endpoint_url,
                                       timeout=timeout,
                                       auth=auth,
                                       proxy=proxy,
                                       config_file=config_file)
        self.auth = settings.get('auth')
        self.endpoint_url = (
            settings.get('endpoint_url') or API_PUBLIC_ENDPOINT).rstrip('/')
        self.timeout = None
        if settings.get('timeout'):
            self.timeout = float(settings.get('timeout'))
        self.proxy = None
        if settings.get('proxy'):
            self.proxy = settings.get('proxy')

    def authenticate_with_password(self, username, password,
                                   security_question_id=None,
                                   security_question_answer=None):
        """ Performs Username/Password Authentication and gives back an auth
            handler to use to create a client that uses token-based auth.

        :param string username: your SoftLayer username
        :param string password: your SoftLayer password
        :param int security_question_id: The security question id to answer
        :param string security_question_answer: The answer to the security
                                                question

        """
        self.auth = None
        res = self['User_Customer'].getPortalLoginToken(
            username,
            password,
            security_question_id,
            security_question_answer)
        self.auth = TokenAuthentication(res['userId'], res['hash'])
        return res['userId'], res['hash']

    def __getitem__(self, name):
        """ Get a SoftLayer Service.

        :param name: The name of the service. E.G. Account

        Usage:
            >>> import SoftLayer
            >>> client = SoftLayer.Client()
            >>> client['Account']
            <Service: Account>

        """
        return Service(self, name)

    def call(self, service, method, *args, **kwargs):
        """ Make a SoftLayer API call

        :param service: the name of the SoftLayer API service
        :param method: the method to call on the service
        :param \\*args: same optional arguments that ``Service.call`` takes
        :param \\*\\*kwargs: same optional keyword arguments that
                           ``Service.call`` takes

        :param service: the name of the SoftLayer API service

        Usage:
            >>> import SoftLayer
            >>> client = SoftLayer.Client()
            >>> client['Account'].getVirtualGuests(mask="id", limit=10)
            [...]

        """
        if kwargs.pop('iter', False):
            return self.iter_call(service, method, *args, **kwargs)

        invalid_kwargs = set(kwargs.keys()) - VALID_CALL_ARGS
        if invalid_kwargs:
            raise TypeError(
                'Invalid keyword arguments: %s' % ','.join(invalid_kwargs))

        if not service.startswith(self._prefix):
            service = self._prefix + service

        headers = kwargs.get('headers', {})

        if self.auth:
            headers.update(self.auth.get_headers())

        if kwargs.get('id') is not None:
            headers[service + 'InitParameters'] = {'id': kwargs.get('id')}

        if kwargs.get('mask') is not None:
            headers.update(self.__format_object_mask(kwargs.get('mask'),
                                                     service))

        if kwargs.get('filter') is not None:
            headers['%sObjectFilter' % service] = kwargs.get('filter')

        if kwargs.get('limit'):
            headers['resultLimit'] = {
                'limit': kwargs.get('limit'),
                'offset': kwargs.get('offset', 0),
            }

        http_headers = {
            'User-Agent': USER_AGENT,
            'Content-Type': 'application/xml',
        }

        if kwargs.get('compress', True):
            http_headers['Accept'] = '*/*'
            http_headers['Accept-Encoding'] = 'gzip, deflate, compress'

        if kwargs.get('raw_headers'):
            http_headers.update(kwargs.get('raw_headers'))

        uri = '/'.join([self.endpoint_url, service])
        return make_xml_rpc_api_call(uri, method, args,
                                     headers=headers,
                                     http_headers=http_headers,
                                     timeout=self.timeout,
                                     proxy=self.proxy)

    __call__ = call

    def iter_call(self, service, method,
                  chunk=100, limit=None, offset=0, *args, **kwargs):
        """ A generator that deals with paginating through results.

        :param service: the name of the SoftLayer API service
        :param method: the method to call on the service
        :param integer chunk: result size for each API call
        :param \\*args: same optional arguments that ``Service.call`` takes
        :param \\*\\*kwargs: same optional keyword arguments that
                           ``Service.call`` takes

        """
        if chunk <= 0:
            raise AttributeError("Chunk size should be greater than zero.")

        if limit:
            chunk = min(chunk, limit)

        result_count = 0
        kwargs['iter'] = False
        while True:
            if limit:
                # We've reached the end of the results
                if result_count >= limit:
                    break

                # Don't over-fetch past the given limit
                if chunk + result_count > limit:
                    chunk = limit - result_count
            results = self.call(service, method,
                                offset=offset, limit=chunk, *args, **kwargs)

            # It looks like we ran out results
            if not results:
                break

            # Apparently this method doesn't return a list.
            # Why are you even iterating over this?
            if not isinstance(results, list):
                yield results
                break

            for item in results:
                yield item
                result_count += 1

            offset += chunk

            if len(results) < chunk:
                break

    def __format_object_mask(self, objectmask, service):
        """ Format new and old style object masks into proper headers.

        :param objectmask: a string- or dict-based object mask
        :param service: a SoftLayer API service name

        """
        if isinstance(objectmask, dict):
            mheader = '%sObjectMask' % service
        else:
            mheader = self._prefix + 'ObjectMask'

            objectmask = objectmask.strip()
            if not objectmask.startswith('mask') \
                    and not objectmask.startswith('['):
                objectmask = "mask[%s]" % objectmask

        return {mheader: {'mask': objectmask}}

    def __repr__(self):
        return "<Client: endpoint=%s, user=%r>" \
            % (self.endpoint_url, self.auth)

    __str__ = __repr__

    def __len__(self):
        return 0


class TimedClient(Client):
    """ Subclass of Client()

    Using this class will time every call to the API and store it in an
    internal list. This will have a slight impact on your client's memory
    usage and performance. You should only use this for debugging.
    """

    def __init__(self, *args, **kwargs):
        self.last_calls = []
        super(TimedClient, self).__init__(*args, **kwargs)

    def call(self, service, method, *args, **kwargs):
        """ See Client.call for documentation. """
        start_time = time.time()
        result = super(TimedClient, self).call(service, method, *args,
                                               **kwargs)
        end_time = time.time()
        diff = end_time - start_time
        self.last_calls.append((service + '.' + method, start_time, diff))
        return result

    def get_last_calls(self):
        """ Retrieves the last_calls property.

        This property will contain a list of tuples in the form
        ('SERVICE.METHOD', initiated_utc_timestamp, execution_time)
        """
        last_calls = self.last_calls
        self.last_calls = []
        return last_calls


class Service(object):
    """ A SoftLayer Service.
        :param client: A SoftLayer.API.Client instance
        :param name str: The service name

    """
    def __init__(self, client, name):
        self.client = client
        self.name = name

    def call(self, name, *args, **kwargs):
        """ Make a SoftLayer API call

        :param method: the method to call on the service
        :param \\*args: (optional) arguments for the remote call
        :param id: (optional) id for the resource
        :param mask: (optional) object mask
        :param dict filter: (optional) filter dict
        :param dict headers: (optional) optional XML-RPC headers
        :param boolean compress: (optional) Enable/Disable HTTP compression
        :param dict raw_headers: (optional) HTTP transport headers
        :param int limit: (optional) return at most this many results
        :param int offset: (optional) offset results by this many
        :param boolean iter: (optional) if True, returns a generator with the
                             results

        Usage:
            >>> import SoftLayer
            >>> client = SoftLayer.Client()
            >>> client['Account'].getVirtualGuests(mask="id", limit=10)
            [...]

        """
        return self.client.call(self.name, name, *args, **kwargs)

    __call__ = call

    def iter_call(self, name, *args, **kwargs):
        """ A generator that deals with paginating through results.

        :param method: the method to call on the service
        :param integer chunk: result size for each API call
        :param \\*args: same optional arguments that ``Service.call`` takes
        :param \\*\\*kwargs: same optional keyword arguments that
                           ``Service.call`` takes

        Usage:
            >>> import SoftLayer
            >>> client = SoftLayer.Client()
            >>> gen = client['Account'].getVirtualGuests(iter=True)
            >>> for virtual_guest in gen:
            ...     virtual_guest['id']
            ...
            1234
            4321

        """
        return self.client.iter_call(self.name, name, *args, **kwargs)

    def __getattr__(self, name):
        if name in ["__name__", "__bases__"]:
            raise AttributeError("'Obj' object has no attribute '%s'" % name)

        def call_handler(*args, **kwargs):
            " Handler that actually makes the API call "
            return self(name, *args, **kwargs)
        return call_handler

    def __repr__(self):
        return "<Service: %s>" % (self.name,)

    __str__ = __repr__

########NEW FILE########
__FILENAME__ = auth
"""
    SoftLayer.auth
    ~~~~~~~~~~~~~~
    Module with the supported auth mechanisms for the SoftLayer API

    :license: MIT, see LICENSE for more details.
"""
__all__ = ['BasicAuthentication', 'TokenAuthentication', 'AuthenticationBase']


class AuthenticationBase(object):
    """ A base authentication class intended to be overridden """
    def get_headers(self):
        """ Return a dictionary of XML-RPC headers to be inserted for
            authentication """
        raise NotImplementedError


class TokenAuthentication(AuthenticationBase):
    """ Token-based authentication class.

        :param user_id int: a user's id
        :param auth_token str: a user's auth token, attained through
                               User_Customer::getPortalLoginToken
    """
    def __init__(self, user_id, auth_token):
        self.user_id = user_id
        self.auth_token = auth_token

    def get_headers(self):
        """ Returns token-based auth headers """
        return {
            'authenticate': {
                'complexType': 'PortalLoginToken',
                'userId': self.user_id,
                'authToken': self.auth_token,
            }
        }

    def __repr__(self):
        return "<TokenAuthentication: %s %s>" % (self.user_id, self.auth_token)


class BasicAuthentication(AuthenticationBase):
    """ Token-based authentication class.

        :param username str: a user's username
        :param api_key str: a user's API key
    """
    def __init__(self, username, api_key):
        self.username = username
        self.api_key = api_key

    def get_headers(self):
        """ Returns token-based auth headers """
        return {
            'authenticate': {
                'username': self.username,
                'apiKey': self.api_key,
            }
        }

    def __repr__(self):
        return "<BasicAuthentication: %s>" % (self.username)

########NEW FILE########
__FILENAME__ = core
"""
usage: sl <module> [<args>...]
       sl help <module>
       sl help <module> <command>
       sl [-h | --help]

SoftLayer Command-line Client

The available modules are:

Compute:
  image     Manages compute and flex images
  metadata  Get details about this machine. Also available with 'my' and 'meta'
  server    Bare metal servers
  sshkey    Manage SSH keys on your account
  vs        Virtual Servers (formerly CCIs)

Networking:
  cdn        Content Delivery Network service management
  dns        Domain Name System
  firewall   Firewall rule and security management
  globalip   Global IP address management
  messaging  Message Queue Service
  rwhois     RWhoIs operations
  ssl        Manages SSL
  subnet     Subnet ordering and management
  vlan       Manage VLANs on your account

Storage:
  iscsi     View iSCSI details
  nas       View NAS details
  snapshot  iSCSI snapshots

General:
  config    View and edit configuration for this tool
  ticket    Manage account tickets
  summary   Display an overall summary of your account
  help      Show help

See 'sl help <module>' for more information on a specific module.

To use most commands your SoftLayer username and api_key need to be configured.
The easiest way to do that is to use: 'sl config setup'
"""
# :license: MIT, see LICENSE for more details.

import sys
import logging

from docopt import docopt, DocoptExit

from SoftLayer import Client, TimedClient, SoftLayerError, SoftLayerAPIError
from SoftLayer.consts import VERSION
from .helpers import CLIAbort, ArgumentError, format_output, KeyValueTable
from .environment import Environment, InvalidCommand, InvalidModule


DEBUG_LOGGING_MAP = {
    '0': logging.CRITICAL,
    '1': logging.WARNING,
    '2': logging.INFO,
    '3': logging.DEBUG
}

VALID_FORMATS = ['raw', 'table', 'json']


class CommandParser(object):
    """ Helper class to parse commands

    :param env: Environment instance
    """
    def __init__(self, env):
        self.env = env

    def get_main_help(self):
        """ Get main help text """
        return __doc__.strip()

    def get_module_help(self, module_name):
        """ Get help text for a module """
        module = self.env.load_module(module_name)
        arg_doc = module.__doc__
        return arg_doc.strip()

    def get_command_help(self, module_name, command_name):
        """ Get help text for a specific command """
        command = self.env.get_command(module_name, command_name)

        default_format = 'raw'
        if sys.stdout.isatty():
            default_format = 'table'

        arg_doc = command.__doc__

        if 'confirm' in command.options:
            arg_doc += """
Prompt Options:
  -y, --really  Confirm all prompt actions
"""

        if '[options]' in arg_doc:
            arg_doc += """
Standard Options:
  --format=ARG            Output format. [Options: table, raw] [Default: %s]
  -C FILE --config=FILE   Config file location. [Default: ~/.softlayer]
  --debug=LEVEL           Specifies the debug noise level
                           1=warn, 2=info, 3=debug
  --timings               Time each API call and display after results
  --proxy=PROTO:PROXY_URL HTTP[s] proxy to be use to make API calls
  -h --help               Show this screen
""" % default_format
        return arg_doc.strip()

    def parse_main_args(self, args):
        """ Parse root arguments """
        main_help = self.get_main_help()
        arguments = docopt(
            main_help,
            version=VERSION,
            argv=args,
            options_first=True)
        arguments['<module>'] = self.env.get_module_name(arguments['<module>'])
        return arguments

    def parse_module_args(self, module_name, args):
        """ Parse module arguments """
        arg_doc = self.get_module_help(module_name)
        arguments = docopt(
            arg_doc,
            version=VERSION,
            argv=[module_name] + args,
            options_first=True)
        return arguments

    def parse_command_args(self, module_name, command_name, args):
        """ Parse command arguments """
        command = self.env.get_command(module_name, command_name)
        arg_doc = self.get_command_help(module_name, command_name)
        arguments = docopt(arg_doc, version=VERSION, argv=[module_name] + args)
        return command, arguments

    def parse(self, args):
        """ Parse entire tree of arguments """
        # handle `sl ...`
        main_args = self.parse_main_args(args)
        module_name = main_args['<module>']

        # handle `sl <module> ...`
        module_args = self.parse_module_args(module_name, main_args['<args>'])

        # get the command argument
        command_name = module_args.get('<command>')

        # handle `sl <module> <command> ...`
        return self.parse_command_args(
            module_name,
            command_name,
            main_args['<args>'])


def main(args=sys.argv[1:], env=Environment()):
    """
    Entry point for the command-line client.
    """
    # Parse Top-Level Arguments
    exit_status = 0
    resolver = CommandParser(env)
    try:
        command, command_args = resolver.parse(args)

        # Set logging level
        debug_level = command_args.get('--debug')
        if debug_level:
            logger = logging.getLogger()
            handler = logging.StreamHandler()
            logger.addHandler(handler)
            logger.setLevel(DEBUG_LOGGING_MAP.get(debug_level, logging.DEBUG))

        kwargs = {
            'proxy': command_args.get('--proxy'),
            'config_file': command_args.get('--config')
        }
        if command_args.get('--timings'):
            client = TimedClient(**kwargs)
        else:
            client = Client(**kwargs)

        # Do the thing
        runnable = command(client=client, env=env)
        data = runnable.execute(command_args)
        if data:
            out_format = command_args.get('--format', 'table')
            if out_format not in VALID_FORMATS:
                raise ArgumentError('Invalid format "%s"' % out_format)
            output = format_output(data, fmt=out_format)
            if output:
                env.out(output)

        if command_args.get('--timings'):
            out_format = command_args.get('--format', 'table')
            api_calls = client.get_last_calls()
            timing_table = KeyValueTable(['call', 'time'])

            for call, _, duration in api_calls:
                timing_table.add_row([call, duration])

            env.err(format_output(timing_table, fmt=out_format))

    except InvalidCommand as ex:
        env.err(resolver.get_module_help(ex.module_name))
        if ex.command_name:
            env.err('')
            env.err(str(ex))
            exit_status = 1
    except InvalidModule as ex:
        env.err(resolver.get_main_help())
        if ex.module_name:
            env.err('')
            env.err(str(ex))
        exit_status = 1
    except DocoptExit as ex:
        env.err(ex.usage)
        env.err(
            '\nUnknown argument(s), use -h or --help for available options')
        exit_status = 127
    except KeyboardInterrupt:
        env.out('')
        exit_status = 1
    except CLIAbort as ex:
        env.err(str(ex.message))
        exit_status = ex.code
    except SystemExit as ex:
        exit_status = ex.code
    except SoftLayerAPIError as ex:
        if 'invalid api token' in ex.faultString.lower():
            env.out("Authentication Failed: To update your credentials, use "
                    "'sl config setup'")
        else:
            env.err(str(ex))
            exit_status = 1
    except SoftLayerError as ex:
        env.err(str(ex))
        exit_status = 1
    except Exception:
        import traceback
        env.err("An unexpected error has occured:")
        env.err(traceback.format_exc())
        env.err("Feel free to report this error as it is likely a bug:")
        env.err("    https://github.com/softlayer/softlayer-python/issues")
        exit_status = 1

    sys.exit(exit_status)

########NEW FILE########
__FILENAME__ = environment
"""
    SoftLayer.CLI.environment
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    Abstracts everything related to the user's environment when running the CLI

    :license: MIT, see LICENSE for more details.
"""
import getpass
from importlib import import_module
import inspect
import os
import os.path
import sys

from SoftLayer.CLI.modules import get_module_list
from SoftLayer.utils import console_input
from SoftLayer import SoftLayerError

# pylint: disable=R0201


class InvalidCommand(SoftLayerError):
    " Raised when trying to use a command that does not exist "
    def __init__(self, module_name, command_name, *args):
        self.module_name = module_name
        self.command_name = command_name
        error = 'Invalid command: "%s".' % self.command_name
        SoftLayerError.__init__(self, error, *args)


class InvalidModule(SoftLayerError):
    " Raised when trying to use a module that does not exist "
    def __init__(self, module_name, *args):
        self.module_name = module_name
        error = 'Invalid module: "%s".' % self.module_name
        SoftLayerError.__init__(self, error, *args)


class Environment(object):
    """ Provides access to the current CLI environment """
    def __init__(self):
        # {'module_name': {'action': 'actionClass'}}
        self.plugins = {}
        self.aliases = {
            'meta': 'metadata',
            'my': 'metadata',
            'vm': 'vs',
            'cci': 'vs',
            'hardware': 'server',
            'hw': 'server',
            'bmetal': 'bmc',
            'virtual': 'vs',
            'lb': 'loadbal',
        }
        self.stdout = sys.stdout
        self.stderr = sys.stderr

    def get_command(self, module_name, command_name):
        """ Based on the loaded modules, return a command """
        actions = self.plugins.get(module_name) or {}
        if command_name in actions:
            return actions[command_name]
        if None in actions:
            return actions[None]
        raise InvalidCommand(module_name, command_name)

    def get_module_name(self, module_name):
        """ Returns the actual module name. Uses the alias mapping """
        if module_name in self.aliases:
            return self.aliases[module_name]
        return module_name

    def load_module(self, module_name):  # pragma: no cover
        """ Loads module by name """
        try:
            module = import_module('SoftLayer.CLI.modules.%s' % module_name)
            for _, obj in inspect.getmembers(module):
                if inspect.isclass(obj) and issubclass(obj, CLIRunnable):
                    self.add_plugin(obj)
            return module
        except ImportError:
            raise InvalidModule(module_name)

    def add_plugin(self, cls):
        """ Add a CLIRunnable as a plugin to the environment """
        command = cls.__module__.split('.')[-1]
        if command not in self.plugins:
            self.plugins[command] = {}
        self.plugins[command][cls.action] = cls

    def plugin_list(self):
        """ Returns the list of modules in SoftLayer.CLI.modules """
        return get_module_list()

    def out(self, output, newline=True):
        """ Outputs a string to the console (stdout) """
        self.stdout.write(output)
        if newline:
            self.stdout.write(os.linesep)

    def err(self, output, newline=True):
        """ Outputs an error string to the console (stderr) """
        self.stderr.write(output)
        if newline:
            self.stderr.write(os.linesep)

    def input(self, prompt):
        """ Provide a command prompt """
        return console_input(prompt)

    def getpass(self, prompt):
        """ Provide a password prompt """
        return getpass.getpass(prompt)

    def exit(self, code=0):
        """ Exit """
        sys.exit(code)


class CLIRunnable(object):
    """ CLIRunnable is intended to be subclassed. It represents a descrete
        command or action in the CLI. """
    options = []  # set by subclass
    action = 'not set'  # set by subclass

    def __init__(self, client=None, env=None):
        self.client = client
        self.env = env

    def execute(self, args):
        """ Execute the command. This is intended to be overridden in a
            subclass """
        pass

########NEW FILE########
__FILENAME__ = exceptions
"""
    SoftLayer.CLI.exceptions
    ~~~~~~~~~~~~~~~~~~~~~~~~
    Exceptions to be used in the CLI modules.

    :license: MIT, see LICENSE for more details.
"""


class CLIHalt(SystemExit):
    """ Smoothly halt the execution of the command. No error """
    def __init__(self, code=0, *args):
        super(CLIHalt, self).__init__(*args)
        self.code = code


class CLIAbort(CLIHalt):
    """ Halt the execution of the command. Gives an exit code of 2 """
    def __init__(self, msg, *args):
        super(CLIAbort, self).__init__(code=2, *args)
        self.message = msg


class ArgumentError(CLIAbort):
    """ Halt the execution of the command because of invalid arguments. """
    def __init__(self, msg, *args):
        super(ArgumentError, self).__init__(msg, *args)
        self.message = "Argument Error: %s" % msg

########NEW FILE########
__FILENAME__ = formatting
"""
    SoftLayer.formatting
    ~~~~~~~~~~~~~~~~~~~~
    Provider classes and helper functions to display output onto a
    command-line.

    :license: MIT, see LICENSE for more details.
"""
# pylint: disable=E0202
import os
import json

from prettytable import PrettyTable, FRAME, NONE

from SoftLayer.utils import string_types, console_input


def format_output(data, fmt='table'):  # pylint: disable=R0911,R0912
    """ Given some data, will format it for output

    :param data: One of: String, Table, FormattedItem, List, Tuple,
                 SequentialOutput
    :param string fmt (optional): One of: table, raw, json, python
    """
    if isinstance(data, string_types):
        if fmt == 'json':
            return json.dumps(data)
        return data

    # responds to .prettytable()
    if hasattr(data, 'prettytable'):
        if fmt == 'table':
            return str(format_prettytable(data))
        elif fmt == 'raw':
            return str(format_no_tty(data))

    # responds to .to_python()
    if hasattr(data, 'to_python'):
        if fmt == 'json':
            return json.dumps(
                format_output(data, fmt='python'),
                indent=4,
                cls=CLIJSONEncoder)
        elif fmt == 'python':
            return data.to_python()

    # responds to .formatted
    if hasattr(data, 'formatted'):
        if fmt == 'table':
            return str(data.formatted)

    # responds to .separator
    if hasattr(data, 'separator'):
        output = [format_output(d, fmt=fmt) for d in data if d]
        return str(SequentialOutput(data.separator, output))

    # is iterable
    if isinstance(data, list) or isinstance(data, tuple):
        output = [format_output(d, fmt=fmt) for d in data]
        if fmt == 'python':
            return output
        return format_output(listing(output, separator=os.linesep))

    # fallback, convert this odd object to a string
    return data


def format_prettytable(table):
    """ Takes a SoftLayer.CLI.formatting.Table instance and returns a formatted
        prettytable """
    for i, row in enumerate(table.rows):
        for j, item in enumerate(row):
            table.rows[i][j] = format_output(item)
    ptable = table.prettytable()
    ptable.hrules = FRAME
    ptable.horizontal_char = '.'
    ptable.vertical_char = ':'
    ptable.junction_char = ':'
    return ptable


def format_no_tty(table):
    """ Takes a SoftLayer.CLI.formatting.Table instance and returns a formatted
        prettytable that has as little formatting as possible """
    for i, row in enumerate(table.rows):
        for j, item in enumerate(row):
            table.rows[i][j] = format_output(item, fmt='raw')
    ptable = table.prettytable()
    for col in table.columns:
        ptable.align[col] = 'l'
    ptable.hrules = NONE
    ptable.border = False
    ptable.header = False
    ptable.left_padding_width = 0
    ptable.right_padding_width = 2
    return ptable


def mb_to_gb(megabytes):
    """ Takes in the number of megabytes and returns a FormattedItem that
        displays gigabytes.

    :param int megabytes: number of megabytes
    """
    return FormattedItem(megabytes, "%dG" % (float(megabytes) / 1024))


def gb(gigabytes):  # pylint: disable=C0103
    """ Takes in the number of gigabytes and returns a FormattedItem that
        displays gigabytes.

    :param int gigabytes: number of gigabytes
    """
    return FormattedItem(int(float(gigabytes)) * 1024,
                         "%dG" % int(float(gigabytes)))


def blank():
    """ Returns FormattedItem to make pretty output use a dash
        and raw formatting to use NULL
    """
    return FormattedItem(None, '-')


def listing(items, separator=','):
    """ Given an iterable, returns a FormattedItem which display a list of
        items

        :param items: An iterable that outputs strings
        :param string separator: the separator to use
    """
    return SequentialOutput(separator, items)


def active_txn(item):
    """ Returns a FormattedItem describing the active transaction (if any) on
        the given object. If no active transaction is running, returns a blank
        FormattedItem.

        :param item: An object capable of having an active transaction
    """
    if not item['activeTransaction'].get('transactionStatus'):
        return blank()

    return FormattedItem(
        item['activeTransaction']['transactionStatus'].get('name'),
        item['activeTransaction']['transactionStatus'].get('friendlyName'))


def transaction_status(transaction):
    """ Returns a FormattedItem describing the transaction status (if any) on
        the given object. If there is no status, returns a blank FormattedItem.

        :param item: An object capable of having an active transaction
    """
    if not transaction.get('transactionStatus'):
        return blank()

    return FormattedItem(
        transaction['transactionStatus'].get('name'),
        transaction['transactionStatus'].get('friendlyName'))


def valid_response(prompt, *valid):
    """ Will display a prompt for a command-line user. If the input is in the
        valid given valid list then it will return True. Otherwise, it will
        return False. If no input is received from the user, None is returned
        instead.

    :param string prompt: string prompt to give to the user
    :param string \\*valid: valid responses
    """
    ans = console_input(prompt).lower()

    if ans in valid:
        return True
    elif ans == '':
        return None

    return False


def confirm(prompt_str, default=False):
    """ Show a confirmation prompt to a command-line user.

    :param string prompt_str: prompt to give to the user
    :param bool default: Default value to True or False
    """
    if default:
        prompt = '%s [Y/n]: ' % prompt_str
    else:
        prompt = '%s [y/N]: ' % prompt_str

    response = valid_response(prompt, 'y', 'yes', 'yeah', 'yup', 'yolo')

    if response is None:
        return default

    return response


def no_going_back(confirmation):
    """ Show a confirmation to a user.

    :param confirmation str: the string the user has to enter in order to
                             confirm their action.
    """
    if not confirmation:
        confirmation = 'yes'

    return valid_response(
        'This action cannot be undone! '
        'Type "%s" or press Enter to abort: ' % confirmation,
        str(confirmation))


class SequentialOutput(list):
    """ This object represents output in a sequence. The purpose is to
        de-couple the separator from the output itself.

    :param separator str: string to use as a default separator
    """
    def __init__(self, separator=os.linesep, *args, **kwargs):
        self.separator = separator
        super(SequentialOutput, self).__init__(*args, **kwargs)

    def to_python(self):
        """ returns itself, since it itself is a list """
        return self

    def __str__(self):
        return self.separator.join(str(x) for x in self)


class CLIJSONEncoder(json.JSONEncoder):
    " A JSON encoder which is able to use a .to_python() method on objects. "
    def default(self, obj):
        """ If the normal JSONEncoder doesn't understand, we have a chance to
            encode the object into a native python type.
        """
        if hasattr(obj, 'to_python'):
            return obj.to_python()
        return super(CLIJSONEncoder, self).default(obj)


class Table(object):
    """ A Table structure.

    :param list columns: a list of column names
    """
    def __init__(self, columns):
        self.columns = columns
        self.rows = []
        self.align = {}
        self.format = {}
        self.sortby = None

    def add_row(self, row):
        """ Add a row to the table

        :param list row: the row of string to be added
        """
        self.rows.append(row)

    def to_python(self):
        """ Decode this Table object to standard Python types """
        # Adding rows
        items = []
        for row in self.rows:
            formatted_row = [_format_python_value(v) for v in row]
            items.append(dict(zip(self.columns, formatted_row)))
        return items

    def prettytable(self):
        """ Returns a new prettytable instance. """
        table = PrettyTable(self.columns)
        if self.sortby:
            table.sortby = self.sortby
        for a_col, alignment in self.align.items():
            table.align[a_col] = alignment

        # Adding rows
        for row in self.rows:
            table.add_row(row)
        return table


class KeyValueTable(Table):
    """ This is a Table which is intended to be used to display key-value
        pairs. It expects there to be only two columns."""
    def to_python(self):
        """ Decode this KeyValueTable object to standard Python types """
        mapping = {}
        for row in self.rows:
            mapping[row[0]] = _format_python_value(row[1])
        return mapping


class FormattedItem(object):
    """ This is an object which wraps a single value that is able to be
        represented in a human readable and a machine-readable way.

        :param original: raw (machine-readable) value
        :param string formatted: human-readable value
    """
    def __init__(self, original, formatted=None):
        self.original = original
        if formatted is not None:
            self.formatted = formatted
        else:
            self.formatted = self.original

    def to_python(self):
        """ returns the original (raw) value """
        return self.original

    def __str__(self):
        """ returns the formatted value """
        # If the original value is None, represent this as 'NULL'
        if self.original is None:
            return 'NULL'
        return str(self.original)

    __repr__ = __str__


def _format_python_value(value):
    """ If the value has to_python() defined then return that """
    if hasattr(value, 'to_python'):
        return value.to_python()
    return value

########NEW FILE########
__FILENAME__ = helpers
"""
    SoftLayer.CLI.helpers
    ~~~~~~~~~~~~~~~~~~~~~
    Helpers to be used in CLI modules in SoftLayer.CLI.modules.*

    :license: MIT, see LICENSE for more details.
"""

from SoftLayer.utils import NestedDict
from SoftLayer.CLI.environment import CLIRunnable
from .exceptions import CLIHalt, CLIAbort, ArgumentError
from .formatting import (
    Table, KeyValueTable, FormattedItem, SequentialOutput, confirm,
    no_going_back, mb_to_gb, gb, listing, blank, format_output,
    active_txn, valid_response, transaction_status)
from .template import update_with_template_args, export_to_template

__all__ = [
    # Core/Misc
    'CLIRunnable', 'NestedDict', 'FALSE_VALUES', 'resolve_id',
    # Exceptions
    'CLIAbort', 'CLIHalt', 'ArgumentError',
    # Formatting
    'Table', 'KeyValueTable', 'FormattedItem', 'SequentialOutput',
    'valid_response', 'confirm', 'no_going_back', 'mb_to_gb', 'gb',
    'listing', 'format_output', 'blank', 'active_txn', 'transaction_status',
    # Template
    'update_with_template_args', 'export_to_template',
]

FALSE_VALUES = ['0', 'false', 'FALSE', 'no', 'False']


def resolve_id(resolver, identifier, name='object'):
    """ Resolves a single id using an id resolver function which returns a list
        of ids.

    :param resolver: function that resolves ids. Should return None or a list
                     of ids.
    :param string identifier: a string identifier used to resolve ids
    :param string name: the object type, to be used in error messages

    """
    ids = resolver(identifier)

    if len(ids) == 0:
        raise CLIAbort("Error: Unable to find %s '%s'" % (name, identifier))

    if len(ids) > 1:
        raise CLIAbort(
            "Error: Multiple %s found for '%s': %s" %
            (name, identifier, ', '.join([str(_id) for _id in ids])))

    return ids[0]

########NEW FILE########
__FILENAME__ = cdn
"""
usage: sl cdn [<command>] [<args>...] [options]

Manage CDN accounts and configuration

The available commands are:
  detail         Show details for a CDN account
  list           List CDN accounts
  load           Cache one or more files on all edge nodes
  origin-add     Add an origin pull mapping
  origin-list    Show origin pull mappings on a CDN account
  origin-remove  Remove an origin pull mapping
  purge          Purge one or more cached files from all edge nodes
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer.CLI import CLIRunnable, Table, KeyValueTable, blank
from SoftLayer.managers.cdn import CDNManager


class ListAccounts(CLIRunnable):
    """
usage: sl cdn list [options]

List all CDN accounts

Options:
  --sortby=SORTBY  Sort by this value. [Default: id]
                     [Options: id, account_name, type, created, notes]
"""
    action = 'list'

    def execute(self, args):
        manager = CDNManager(self.client)
        accounts = manager.list_accounts()

        table = Table(['id', 'account_name', 'type', 'created', 'notes'])
        for account in accounts:
            table.add_row([
                account['id'],
                account['cdnAccountName'],
                account['cdnSolutionName'],
                account['createDate'],
                account.get('cdnAccountNote', blank())
            ])

        table.sortby = args['--sortby']
        return table


class DetailAccount(CLIRunnable):
    """
usage: sl cdn detail <account> [options]

Show CDN account details
"""
    action = 'detail'

    def execute(self, args):
        manager = CDNManager(self.client)
        account = manager.get_account(args.get('<account>'))

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        table.add_row(['id', account['id']])
        table.add_row(['account_name', account['cdnAccountName']])
        table.add_row(['type', account['cdnSolutionName']])
        table.add_row(['status', account['status']['name']])
        table.add_row(['created', account['createDate']])
        table.add_row(['notes', account.get('cdnAccountNote', blank())])

        return table


class LoadContent(CLIRunnable):
    """
usage: sl cdn load <account> <content_url>... [options]

Cache one or more files on all edge nodes

Required:
  account      The CDN account ID to cache content in
  content_url  The CDN URL(s) or CDN CNAME-based URL(s) for the content
                 you wish to cache (can be repeated)
"""
    action = 'load'
    required_params = ['account', 'content_url']

    def execute(self, args):
        manager = CDNManager(self.client)
        manager.load_content(args.get('<account>'), args.get('<content_url>'))


class PurgeContent(CLIRunnable):
    """
usage: sl cdn purge <account> <content_url>... [options]

Purge one or more cached files from all edge nodes

Required:
  account      The CDN account ID to purge content from
  content_url  The CDN URL(s) or CDN CNAME-based URL(s) for the content
                 you wish to cache (can be repeated)
"""
    action = 'purge'
    required_params = ['account', 'content_url']

    def execute(self, args):
        manager = CDNManager(self.client)
        manager.purge_content(args.get('<account>'),
                              args.get('<content_url>'))


class ListOrigins(CLIRunnable):
    """
usage: sl cdn origin-list <account> [options]

List origin pull mappings associated with a CDN account.
"""
    action = 'origin-list'

    def execute(self, args):
        manager = CDNManager(self.client)
        origins = manager.get_origins(args.get('<account>'))

        table = Table(['id', 'media_type', 'cname', 'origin_url'])

        for origin in origins:
            table.add_row([origin['id'],
                           origin['mediaType'],
                           origin.get('cname', blank()),
                           origin['originUrl']])

        return table


class AddOrigin(CLIRunnable):
    """
usage: sl cdn origin-add <account> <url> [options]

Create an origin pull mapping on a CDN account

Required:
  account  The CDN account ID to create a mapping on
  url      A full URL where content should be pulled from by
             CDN edge nodes

Options:
  --type=TYPE    The media type for this mapping (http, flash, wm, ...)
                   (default: http)
  --cname=CNAME  An optional CNAME to attach to the mapping
"""
    action = 'origin-add'
    required_params = ['account', 'url']

    def execute(self, args):
        manager = CDNManager(self.client)
        media_type = args.get('--type') or 'http'

        manager.add_origin(args.get('<account>'), media_type,
                           args.get('<url>'), args.get('--cname', None))


class RemoveOrigin(CLIRunnable):
    """
usage: sl cdn origin-remove <account> <origin_id> [options]

Remove an origin pull mapping from a CDN account

Required:
  account    The CDN account ID to remove a mapping from
  origin_id  The origin mapping ID to remove
"""
    action = 'origin-remove'
    required_params = ['account', 'origin_id']

    def execute(self, args):
        manager = CDNManager(self.client)
        manager.remove_origin(args.get('<account>'),
                              args.get('<origin_id>'))

########NEW FILE########
__FILENAME__ = config
"""
usage: sl config [<command>] [<args>...] [options]

View and edit configuration

The available commands are:
  setup  Setup configuration
  show   Show current configuration
"""
# :license: MIT, see LICENSE for more details.

import os.path

from SoftLayer import (
    SoftLayerAPIError, API_PUBLIC_ENDPOINT, API_PRIVATE_ENDPOINT)
from SoftLayer.auth import BasicAuthentication
from SoftLayer.CLI import (
    CLIRunnable, CLIAbort, KeyValueTable, confirm, format_output)
from SoftLayer.utils import configparser


def get_settings_from_client(client):
    """ Pull out settings from a SoftLayer.Client instance.

    :param client: SoftLayer.Client instance
    """
    settings = {
        'username': '',
        'api_key': '',
        'timeout': client.timeout or '',
        'endpoint_url': client.endpoint_url,
    }
    try:
        settings['username'] = client.auth.username
        settings['api_key'] = client.auth.api_key
    except AttributeError:
        pass

    return settings


def config_table(settings):
    """ Returns a config table """
    table = KeyValueTable(['Name', 'Value'])
    table.align['Name'] = 'r'
    table.align['Value'] = 'l'
    table.add_row(['Username', settings['username'] or 'not set'])
    table.add_row(['API Key', settings['api_key'] or 'not set'])
    table.add_row(['Endpoint URL', settings['endpoint_url'] or 'not set'])
    table.add_row(['Timeout', settings['timeout'] or 'not set'])
    return table


def get_api_key(client, username, secret, endpoint_url=None):
    """ Tries API-Key and password auth to get (and potentially generate) an
        API key. """

    client.endpoint_url = endpoint_url
    client.auth = None
    # Try to use a client with username/api key
    if len(secret) == 64:
        try:
            client.auth = BasicAuthentication(username, secret)
            client['Account'].getCurrentUser()
            return secret
        except SoftLayerAPIError as ex:
            if 'invalid api token' not in ex.faultString.lower():
                raise
    else:
        # Try to use a client with username/password
        client.authenticate_with_password(username, secret)

        user_record = client['Account'].getCurrentUser(
            mask='id, apiAuthenticationKeys')
        api_keys = user_record['apiAuthenticationKeys']
        if len(api_keys) == 0:
            return client['User_Customer'].addApiAuthenticationKey(
                id=user_record['id'])
        return api_keys[0]['authenticationKey']


class Setup(CLIRunnable):
    """
usage: sl config setup [options]

Setup configuration
"""
    action = 'setup'

    def execute(self, args):
        username, secret, endpoint_url, timeout = self.get_user_input()

        api_key = get_api_key(self.client, username, secret,
                              endpoint_url=endpoint_url)

        path = '~/.softlayer'
        if args.get('--config'):
            path = args.get('--config')
        config_path = os.path.expanduser(path)

        self.env.out(
            format_output(config_table({'username': username,
                                        'api_key': api_key,
                                        'endpoint_url': endpoint_url,
                                        'timeout': timeout})))

        if not confirm('Are you sure you want to write settings to "%s"?'
                       % config_path, default=True):
            raise CLIAbort('Aborted.')

        # Persist the config file. Read the target config file in before
        # setting the values to avoid clobbering settings
        config = configparser.RawConfigParser()
        config.read(config_path)
        try:
            config.add_section('softlayer')
        except configparser.DuplicateSectionError:
            pass

        config.set('softlayer', 'username', username)
        config.set('softlayer', 'api_key', api_key)
        config.set('softlayer', 'endpoint_url', endpoint_url)

        config_file = os.fdopen(os.open(config_path,
                                        (os.O_WRONLY | os.O_CREAT),
                                        0o600),
                                'w')
        try:
            config.write(config_file)
        finally:
            config_file.close()

        return "Configuration Updated Successfully"

    def get_user_input(self):
        """ Ask for username, secret (api_key or password) and endpoint_url """

        defaults = get_settings_from_client(self.client)
        timeout = defaults['timeout']

        # Ask for username
        while True:
            username = self.env.input(
                'Username [%s]: ' % defaults['username']) \
                or defaults['username']
            if username:
                break

        # Ask for 'secret' which can be api_key or their password
        while True:
            secret = self.env.getpass(
                'API Key or Password [%s]: ' % defaults['api_key']) \
                or defaults['api_key']
            if secret:
                break

        # Ask for which endpoint they want to use
        while True:
            endpoint_type = self.env.input(
                'Endpoint (public|private|custom): ')
            endpoint_type = endpoint_type.lower()
            if not endpoint_type:
                endpoint_url = API_PUBLIC_ENDPOINT
                break
            if endpoint_type == 'public':
                endpoint_url = API_PUBLIC_ENDPOINT
                break
            elif endpoint_type == 'private':
                endpoint_url = API_PRIVATE_ENDPOINT
                break
            elif endpoint_type == 'custom':
                endpoint_url = self.env.input(
                    'Endpoint URL [%s]: ' % defaults['endpoint_url']
                ) or defaults['endpoint_url']
                break

        return username, secret, endpoint_url, timeout


class Show(CLIRunnable):
    """
usage: sl config show [options]

Show current configuration
"""
    action = 'show'

    def execute(self, args):
        settings = get_settings_from_client(self.client)
        return config_table(settings)

########NEW FILE########
__FILENAME__ = dns
"""
usage: sl dns [<command>] [<args>...] [options]

Manage DNS

The available zone commands are:
  create  Create zone
  delete  Delete zone
  list    List zones or a zone's records
  print   Print zone in BIND format

The available record commands are:
  add     Add resource record
  edit    Update resource records (bulk/single)
  remove  Remove resource records
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer.CLI import (
    CLIRunnable, no_going_back, Table, CLIAbort, resolve_id)
from SoftLayer import DNSManager


class DumpZone(CLIRunnable):
    """
usage: sl dns print <zone> [options]

print zone in BIND format

Arguments:
  <zone>    Zone name (softlayer.com)
"""
    action = "print"

    def execute(self, args):
        manager = DNSManager(self.client)
        zone_id = resolve_id(manager.resolve_ids, args['<zone>'], name='zone')
        return manager.dump_zone(zone_id)


class CreateZone(CLIRunnable):
    """
usage: sl dns create <zone> [options]

Create a zone

Arguments:
  <zone>    Zone name (softlayer.com)
"""
    action = 'create'

    def execute(self, args):
        manager = DNSManager(self.client)
        manager.create_zone(args['<zone>'])


class DeleteZone(CLIRunnable):
    """
usage: sl dns delete <zone> [options]

Delete zone

Arguments:
  <zone>    Zone name (softlayer.com)
"""
    action = 'delete'
    options = ['confirm']

    def execute(self, args):
        manager = DNSManager(self.client)
        zone_id = resolve_id(manager.resolve_ids, args['<zone>'], name='zone')

        if args['--really'] or no_going_back(args['<zone>']):
            manager.delete_zone(zone_id)
        else:
            raise CLIAbort("Aborted.")


class ListZones(CLIRunnable):
    """
usage: sl dns list [<zone>] [options]

List zones and optionally, records

Filters:
  --data=DATA    Record data, such as an IP address
  --record=HOST  Host record, such as www
  --ttl=TTL      TTL value in seconds, such as 86400
  --type=TYPE    Record type, such as A or CNAME
"""
    action = 'list'

    def execute(self, args):
        if args['<zone>']:
            return self.list_zone(args)

        return self.list_all_zones()

    def list_zone(self, args):
        """ list records for a particular zone """
        manager = DNSManager(self.client)
        table = Table(['id', 'record', 'type', 'ttl', 'value'])

        table.align['ttl'] = 'l'
        table.align['record'] = 'r'
        table.align['value'] = 'l'

        zone_id = resolve_id(manager.resolve_ids, args['<zone>'], name='zone')

        records = manager.get_records(
            zone_id,
            record_type=args.get('--type'),
            host=args.get('--record'),
            ttl=args.get('--ttl'),
            data=args.get('--data'),
        )

        for record in records:
            table.add_row([
                record['id'],
                record['host'],
                record['type'].upper(),
                record['ttl'],
                record['data']
            ])

        return table

    def list_all_zones(self):
        """ List all zones """
        manager = DNSManager(self.client)
        zones = manager.list_zones()
        table = Table(['id', 'zone', 'serial', 'updated'])
        table.align['serial'] = 'c'
        table.align['updated'] = 'c'

        for zone in zones:
            table.add_row([
                zone['id'],
                zone['name'],
                zone['serial'],
                zone['updateDate'],
            ])

        return table


class AddRecord(CLIRunnable):
    """
usage: sl dns add <zone> <record> <type> <data> [--ttl=TTL] [options]

Add resource record

Arguments:
  <zone>    Zone name (softlayer.com)
  <record>  Resource record (www)
  <type>    Record type. [Options: A, AAAA,
              CNAME, MX, NS, PTR, SPF, SRV, TXT]
  <data>    Record data. NOTE: only minor validation is done

Options:
  --ttl=TTL  Time to live
"""
    action = 'add'

    def execute(self, args):
        manager = DNSManager(self.client)

        zone_id = resolve_id(manager.resolve_ids, args['<zone>'], name='zone')

        manager.create_record(
            zone_id,
            args['<record>'],
            args['<type>'],
            args['<data>'],
            ttl=args['--ttl'] or 7200)


class EditRecord(CLIRunnable):
    """
usage: sl dns edit <zone> <record> [--data=DATA] [--ttl=TTL] [--id=ID]
                   [options]

Update resource records (bulk/single)

Arguments:
  <zone>    Zone name (softlayer.com)
  <record>  Resource record (www)

Options:
  --data=DATA
  --id=ID      Modify only the given ID
  --ttl=TTL    Time to live
"""
    action = 'edit'

    def execute(self, args):
        manager = DNSManager(self.client)
        zone_id = resolve_id(manager.resolve_ids, args['<zone>'], name='zone')

        results = manager.get_records(
            zone_id,
            host=args['<record>'])

        for result in results:
            if args['--id'] and str(result['id']) != args['--id']:
                continue
            result['data'] = args['--data'] or result['data']
            result['ttl'] = args['--ttl'] or result['ttl']
            manager.edit_record(result)


class RecordRemove(CLIRunnable):
    """
usage: sl dns remove <zone> <record> [--id=ID] [options]

Remove resource records

Arguments:
  <zone>    Zone name (softlayer.com)
  <record>  Resource record (www)

Options:
  --id=ID  Remove only the given ID
"""
    action = 'remove'
    options = ['confirm']

    def execute(self, args):
        manager = DNSManager(self.client)
        zone_id = resolve_id(manager.resolve_ids, args['<zone>'], name='zone')

        if args['--id']:
            records = [{'id': args['--id']}]
        else:
            records = manager.get_records(
                zone_id,
                host=args['<record>'])

        if args['--really'] or no_going_back('yes'):
            table = Table(['record'])
            for result in records:
                manager.delete_record(result['id'])
                table.add_row([result['id']])

            return table
        raise CLIAbort("Aborted.")

########NEW FILE########
__FILENAME__ = filters
"""
usage: sl help filters

Filters are used to limit the amount of results. Some commands will accept a
filter operation for certain fields. Filters can be applied across multiple
fields in most cases.

Available Operations:
  Case Insensitive
    'value'   Exact value match
    'value*'  Begins with value
    '*value'  Ends with value
    '*value*' Contains value

  Case Sensitive
    '~ value'   Exact value match
    '> value'   Greater than value
    '< value'   Less than value
    '>= value'  Greater than or equal to value
    '<= value'  Less than or equal to value

Examples:
    sl server list --datacenter=dal05
    sl server list --hostname='prod*'
    sl vs list --network=100 --cpu=2
    sl vs list --network='< 100' --cpu=2
    sl vs list --memory='>= 2048'

Note: Comparison operators (>, <, >=, <=) can be used with integers, floats,
      and strings.
"""
# :license: MIT, see LICENSE for more details.

########NEW FILE########
__FILENAME__ = firewall
"""
usage: sl firewall [<command>] [<args>...] [options]

Firewall rule and security management

The available commands are:
  add    Add a new firewall
  cancel Cancel an existing firewall
  detail Provide details about a particular firewall
  edit   Edit the rules of a particular firewall
  list   List active firewalls - both dedicated and shared

"""
# :license: MIT, see LICENSE for more details.

from __future__ import print_function
from subprocess import call
import os
import tempfile

from SoftLayer import FirewallManager, SoftLayerError
from SoftLayer.utils import lookup
from SoftLayer.CLI import CLIRunnable, Table, listing, resolve_id, confirm
from SoftLayer.CLI.helpers import blank, CLIAbort

DELIMITER = "=========================================\n"


def get_ids(input_id):
    """ Helper package to retrieve the actual IDs
    :param input_id: the ID provided by the user
    :returns: A list of valid IDs
    """
    key_value = input_id.split(':')

    if len(key_value) != 2:
        raise CLIAbort('Invalid ID %s: ID should be of the form xxx:yyy'
                       % input_id)
    return key_value


def print_package_info(package):
    """ Helper package to print the firewall price.

    :param dict package: A dictionary representing the firewall package
    """
    print("******************")
    print("Product: %s" % package[0]['description'])
    print("Price: %s$ monthly" % package[0]['prices'][0]['recurringFee'])
    print("******************")
    return


def has_firewall_component(server):
    """ Helper to determine whether or not a server has a firewall.

    :param dict server: A dictionary representing a server
    :returns: True if the Server has a firewall.
    """
    if server['status'] != 'no_edit':
        return True

    return False


def get_rules_table(rules):
    """ Helper to format the rules into a table

    :param list rules: A list containing the rules of the firewall
    :returns: a formatted table of the firewall rules
    """
    table = Table(['#', 'action', 'protocol', 'src_ip', 'src_mask', 'dest',
                   'dest_mask'])
    table.sortby = '#'
    for rule in rules:
        table.add_row([
            rule['orderValue'],
            rule['action'],
            rule['protocol'],
            rule['sourceIpAddress'],
            rule['sourceIpSubnetMask'],
            '%s:%s-%s' % (rule['destinationIpAddress'],
                          rule['destinationPortRangeStart'],
                          rule['destinationPortRangeEnd']),
            rule['destinationIpSubnetMask']])
    return table


def get_formatted_rule(rule=None):
    """ Helper to format the rule into a user friendly format
        for editing purposes

    :param dict rule: A dict containing one rule of the firewall
    :returns: a formatted string that get be pushed into the editor
    """
    rule = rule or {}
    return ('action: %s\n'
            'protocol: %s\n'
            'source_ip_address: %s\n'
            'source_ip_subnet_mask: %s\n'
            'destination_ip_address: %s\n'
            'destination_ip_subnet_mask: %s\n'
            'destination_port_range_start: %s\n'
            'destination_port_range_end: %s\n'
            'version: %s\n'
            % (rule.get('action', 'permit'),
               rule.get('protocol', 'tcp'),
               rule.get('sourceIpAddress', 'any'),
               rule.get('sourceIpSubnetMask', '255.255.255.255'),
               rule.get('destinationIpAddress', 'any'),
               rule.get('destinationIpSubnetMask', '255.255.255.255'),
               rule.get('destinationPortRangeStart', 1),
               rule.get('destinationPortRangeEnd', 1),
               rule.get('version', 4)))


def open_editor(rules=None, content=None):
    """ Helper to open an editor for editing the firewall rules
        This method takes two parameters, if content is provided,
        that means that submitting the rules failed and we are allowing
        the user to re-edit what they provided.
        If content is not provided, the rules retrieved from the firewall
        will be displayed to the user.

    :param list rules: A list containing the rules of the firewall
    :param string content: the content that the user provided in the editor
    :returns: a formatted string that get be pushed into the editor
    """

    # Let's get the default EDITOR of the environment,
    # use nano if none is specified
    editor = os.environ.get('EDITOR', 'nano')

    with tempfile.NamedTemporaryFile(suffix=".tmp") as tfile:

        if content:
            # if content is provided, just display it as is
            tfile.write(content)
            tfile.flush()
            call([editor, tfile.name])
            tfile.seek(0)
            data = tfile.read()
            return data

        if not rules:
            # if the firewall has no rules, provide a template
            tfile.write(DELIMITER)
            tfile.write(get_formatted_rule())
        else:
            # if the firewall has rules, display those to the user
            for rule in rules:
                tfile.write(DELIMITER)
                tfile.write(get_formatted_rule(rule))
        tfile.write(DELIMITER)
        tfile.flush()
        call([editor, tfile.name])
        tfile.seek(0)
        data = tfile.read()
        return data

    return


def parse_rules(content=None):
    """ Helper to parse the input from the user into a list of rules.

    :param string content: the content of the editor
    :returns: a list of rules
    """
    rules = content.split(DELIMITER)
    parsed_rules = list()
    order = 1
    for rule in rules:
        if rule.strip() == '':
            continue
        parsed_rule = {}
        lines = rule.split("\n")
        parsed_rule['orderValue'] = order
        order += 1
        for line in lines:
            if line.strip() == '':
                continue
            key_value = line.strip().split(':')
            key = key_value[0].strip()
            value = key_value[1].strip()
            if key == 'action':
                parsed_rule['action'] = value
            elif key == 'protocol':
                parsed_rule['protocol'] = value
            elif key == 'source_ip_address':
                parsed_rule['sourceIpAddress'] = value
            elif key == 'source_ip_subnet_mask':
                parsed_rule['sourceIpSubnetMask'] = value
            elif key == 'destination_ip_address':
                parsed_rule['destinationIpAddress'] = value
            elif key == 'destination_ip_subnet_mask':
                parsed_rule['destinationIpSubnetMask'] = value
            elif key == 'destination_port_range_start':
                parsed_rule['destinationPortRangeStart'] = int(value)
            elif key == 'destination_port_range_end':
                parsed_rule['destinationPortRangeEnd'] = int(value)
            elif key == 'version':
                parsed_rule['version'] = int(value)
        parsed_rules.append(parsed_rule)
    return parsed_rules


class FWList(CLIRunnable):
    """
usage: sl firewall list [options]

List active firewalls
"""
    action = 'list'

    def execute(self, args):
        mgr = FirewallManager(self.client)
        table = Table(['firewall id',
                       'type',
                       'features',
                       'server/vlan id'])
        fwvlans = mgr.get_firewalls()
        dedicated_firewalls = [firewall for firewall in fwvlans
                               if firewall['dedicatedFirewallFlag']]

        for vlan in dedicated_firewalls:
            features = []
            if vlan['highAvailabilityFirewallFlag']:
                features.append('HA')

            if features:
                feature_list = listing(features, separator=',')
            else:
                feature_list = blank()

            table.add_row([
                'vlan:%s' % vlan['networkVlanFirewall']['id'],
                'VLAN - dedicated',
                feature_list,
                vlan['id']
            ])

        shared_vlan = [firewall for firewall in fwvlans
                       if not firewall['dedicatedFirewallFlag']]
        for vlan in shared_vlan:
            vs_firewalls = [guest
                            for guest in vlan['firewallGuestNetworkComponents']
                            if has_firewall_component(guest)]

            for firewall in vs_firewalls:
                table.add_row([
                    'cci:%s' % firewall['id'],
                    'CCI - standard',
                    '-',
                    firewall['guestNetworkComponent']['guest']['id']
                ])

            server_firewalls = [server
                                for server in vlan['firewallNetworkComponents']
                                if has_firewall_component(server)]

            for firewall in server_firewalls:
                table.add_row([
                    'server:%s' % firewall['id'],
                    'Server - standard',
                    '-',
                    lookup(firewall,
                           'networkComponent',
                           'downlinkComponent',
                           'hardwareId')
                ])

        return table


class FWCancel(CLIRunnable):
    """
usage: sl firewall cancel <identifier> [options]

Cancels a firewall

Options:
  --really     Whether to skip the confirmation prompt

"""
    action = 'cancel'
    options = ['really']

    def execute(self, args):
        mgr = FirewallManager(self.client)
        input_id = args.get('<identifier>')
        key_value = get_ids(input_id)
        firewall_id = int(key_value[1])

        if args['--really'] or confirm("This action will cancel a firewall"
                                       " from your account. Continue?"):
            if key_value[0] in ['cci', 'server']:
                mgr.cancel_firewall(firewall_id, dedicated=False)
            elif key_value[0] == 'vlan':
                mgr.cancel_firewall(firewall_id, dedicated=True)
            return 'Firewall with id %s is being cancelled!' % input_id
        else:
            raise CLIAbort('Aborted.')


class FWAdd(CLIRunnable):
    """
usage: sl firewall add <identifier> (--cci | --vlan | --server) [options]

Adds a firewall of type either standard (cci or server) or dedicated(vlan)
Options:
  --cci     creates a standard firewall for a CCI
  --vlan    creates a dedicated firewall for a VLAN
  --server  creates a standard firewall for a server
  --ha      whether HA will be on or off - only for dedicated
  --really  whether to skip the confirmation prompt
"""
    action = 'add'
    options = ['really', 'ha']

    def execute(self, args):
        mgr = FirewallManager(self.client)
        input_id = resolve_id(
            mgr.resolve_ids, args.get('<identifier>'), 'firewall')
        ha_support = args.get('--ha', False)
        if not args['--really']:
            if args['--vlan']:
                pkg = mgr.get_dedicated_package(ha_enabled=ha_support)
            elif args['--cci']:
                pkg = mgr.get_standard_package(input_id)
            elif args['--server']:
                pkg = mgr.get_standard_package(input_id, is_cci=False)

            if not pkg:
                return "Unable to add firewall - Is network public enabled?"
            print_package_info(pkg)

            if not confirm("This action will incur charges on your account. "
                           "Continue?"):
                raise CLIAbort('Aborted.')

        if args['--vlan']:
            mgr.add_vlan_firewall(input_id, ha_enabled=ha_support)
        elif args['--cci']:
            mgr.add_standard_firewall(input_id, is_cci=True)
        elif args['--server']:
            mgr.add_standard_firewall(input_id, is_cci=False)

        return "Firewall is being created!"


class FWDetails(CLIRunnable):
    """
usage: sl firewall detail <identifier> [options]

Get firewall details
"""
    action = 'detail'

    def execute(self, args):
        mgr = FirewallManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        if key_value[0] == 'vlan':
            rules = mgr.get_dedicated_fwl_rules(key_value[1])
        else:
            rules = mgr.get_standard_fwl_rules(key_value[1])

        return get_rules_table(rules)


class FWEdit(CLIRunnable):
    """
usage: sl firewall edit <identifier> [options]

Edit the rules for a firewall
"""
    action = 'edit'

    def execute(self, args):
        mgr = FirewallManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        firewall_id = int(key_value[1])
        if key_value[0] == 'vlan':
            orig_rules = mgr.get_dedicated_fwl_rules(firewall_id)
        else:
            orig_rules = mgr.get_standard_fwl_rules(firewall_id)
        # open an editor for the user to enter their rules
        edited_rules = open_editor(rules=orig_rules)
        print(edited_rules)
        if confirm("Would you like to submit the rules. "
                   "Continue?"):
            while True:
                try:
                    rules = parse_rules(edited_rules)
                    if key_value[0] == 'vlan':
                        rules = mgr.edit_dedicated_fwl_rules(firewall_id,
                                                             rules)
                    else:
                        rules = mgr.edit_standard_fwl_rules(firewall_id,
                                                            rules)
                    break
                except (SoftLayerError, ValueError) as error:
                    print("Unexpected error({%s})" % (error))
                    if confirm("Would you like to continue editing the rules"
                               ". Continue?"):
                        edited_rules = open_editor(content=edited_rules)
                        print(edited_rules)
                        if confirm("Would you like to submit the rules. "
                                   "Continue?"):
                            continue
                        else:
                            raise CLIAbort('Aborted.')
                    else:
                        raise CLIAbort('Aborted.')
                    return 'Firewall updated!'
        else:
            raise CLIAbort('Aborted.')

########NEW FILE########
__FILENAME__ = globalip
"""
usage: sl globalip [<command>] [<args>...] [options]

Orders or configures global IP addresses

The available commands are:
  assign    Assign a target to a global IP address
  cancel    Cancels a global IP
  create    Orders a new global IP address
  list      Display a list of global IP addresses
  unassign  Unassigns a global IP
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import NetworkManager
from SoftLayer.CLI import (
    CLIRunnable, Table, confirm, no_going_back, resolve_id)
from SoftLayer.CLI.helpers import CLIAbort


class GlobalIpAssign(CLIRunnable):
    """
usage: sl globalip assign <identifier> <target> [options]

Assigns a global IP to a target.

Required:
  <identifier>  The ID or address of the global IP
  <target>      The IP address to assign to the global IP
"""
    action = 'assign'

    def execute(self, args):
        mgr = NetworkManager(self.client)
        global_ip_id = resolve_id(mgr.resolve_global_ip_ids,
                                  args.get('<identifier>'),
                                  name='global ip')
        mgr.assign_global_ip(global_ip_id, args['<target>'])


class GlobalIpCancel(CLIRunnable):
    """
usage: sl globalip cancel <identifier> [options]

Cancel a subnet
"""

    action = 'cancel'
    options = ['confirm']

    def execute(self, args):
        mgr = NetworkManager(self.client)
        global_ip_id = resolve_id(mgr.resolve_global_ip_ids,
                                  args.get('<identifier>'),
                                  name='global ip')

        if args['--really'] or no_going_back(global_ip_id):
            mgr.cancel_global_ip(global_ip_id)
        else:
            raise CLIAbort('Aborted')


class GlobalIpCreate(CLIRunnable):
    """
usage:
  sl globalip create [options]

Add a new global IP address to your account.

Options:
  --v6                 Orders IPv6
  --test               Do not order the IP; just get a quote
"""
    action = 'create'
    options = ['confirm']

    def execute(self, args):
        mgr = NetworkManager(self.client)

        version = 4
        if args.get('--v6'):
            version = 6
        if not args.get('--test') and not args['--really']:
            if not confirm("This action will incur charges on your account."
                           "Continue?"):
                raise CLIAbort('Cancelling order.')
        result = mgr.add_global_ip(version=version,
                                   test_order=args.get('--test'))

        table = Table(['Item', 'cost'])
        table.align['Item'] = 'r'
        table.align['cost'] = 'r'

        total = 0.0
        for price in result['orderDetails']['prices']:
            total += float(price.get('recurringFee', 0.0))
            rate = "%.2f" % float(price['recurringFee'])

            table.add_row([price['item']['description'], rate])

        table.add_row(['Total monthly cost', "%.2f" % total])
        return table


class GlobalIpList(CLIRunnable):
    """
usage: sl globalip list [options]

Displays a list of global IPs

Filters:
  --v4                     Display only IPV4
  --v6                     Display only IPV6
"""
    action = 'list'

    def execute(self, args):
        mgr = NetworkManager(self.client)

        table = Table(['id', 'ip', 'assigned', 'target'])
        table.sortby = args.get('--sortby') or 'id'

        version = 0
        if args.get('--v4'):
            version = 4
        elif args.get('--v6'):
            version = 6

        ips = mgr.list_global_ips(version=version)

        for ip_address in ips:
            assigned = 'No'
            target = 'None'
            if ip_address.get('destinationIpAddress'):
                dest = ip_address['destinationIpAddress']
                assigned = 'Yes'
                target = dest['ipAddress']
                virtual_guest = dest.get('virtualGuest')
                if virtual_guest:
                    target += (' (%s)'
                               % virtual_guest['fullyQualifiedDomainName'])
                elif ip_address['destinationIpAddress'].get('hardware'):
                    target += (' (%s)'
                               % dest['hardware']['fullyQualifiedDomainName'])

            table.add_row([ip_address['id'],
                           ip_address['ipAddress']['ipAddress'],
                           assigned,
                           target])
        return table


class GlobalIpUnassign(CLIRunnable):
    """
usage: sl globalip unassign <identifier> [options]

Unassigns a global IP from a target.

Required:
  <identifier>  The ID or address of the global IP
"""
    action = 'unassign'

    def execute(self, args):
        mgr = NetworkManager(self.client)
        global_ip_id = resolve_id(mgr.resolve_global_ip_ids,
                                  args.get('<identifier>'),
                                  name='global ip')
        mgr.unassign_global_ip(global_ip_id)

########NEW FILE########
__FILENAME__ = help
"""
usage: sl help [options]
       sl help <module> [options]
       sl help <module> <command> [options]

View help on a module or command.
"""
# :license: MIT, see LICENSE for more details.
# Missing docstrings ignored due to __doc__ = __doc__ magic
# pylint: disable=C0111

from SoftLayer.CLI.core import CommandParser
from SoftLayer.CLI import CLIRunnable


class Show(CLIRunnable):
    # Use the same documentation as the module
    __doc__ = __doc__
    action = None

    def execute(self, args):
        parser = CommandParser(self.env)
        if not any([args['<command>'], args['<module>']]):
            return parser.get_module_help('help')

        self.env.load_module(args['<module>'])

        if args['<command>']:
            return parser.get_command_help(args['<module>'], args['<command>'])
        elif args['<module>']:
            return parser.get_module_help(args['<module>'])

########NEW FILE########
__FILENAME__ = image
"""
usage: sl image [<command>] [<args>...] [options]

Manage compute images

The available commands are:
  delete  Delete an image
  detail  Output details about an image
  list    List images
  edit    Edit an image
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import ImageManager
from SoftLayer.CLI import CLIRunnable, Table, KeyValueTable, blank, resolve_id
from SoftLayer.CLI.helpers import CLIAbort


class ListImages(CLIRunnable):
    """
usage: sl image list [--public | --private] [options]

List images

Options:
  --private  Display only private images
  --public   Display only public images
"""
    action = 'list'

    def execute(self, args):
        image_mgr = ImageManager(self.client)

        neither = not any([args['--private'], args['--public']])
        mask = 'id,accountId,name,globalIdentifier,blockDevices,parentId'

        images = []
        if args['--private'] or neither:
            for image in image_mgr.list_private_images(mask=mask):
                image['visibility'] = 'private'
                images.append(image)

        if args['--public'] or neither:
            for image in image_mgr.list_public_images(mask=mask):
                image['visibility'] = 'public'
                images.append(image)

        table = Table(['id',
                       'account',
                       'visibility',
                       'name',
                       'global_identifier'])

        images = [image for image in images if image['parentId'] == '']
        for image in images:
            table.add_row([
                image['id'],
                image.get('accountId', blank()),
                image['visibility'],
                image['name'].strip(),
                image.get('globalIdentifier', blank()),
            ])

        return table


class DetailImage(CLIRunnable):
    """
usage: sl image detail <identifier> [options]

Get details for an image
"""
    action = 'detail'

    def execute(self, args):
        image_mgr = ImageManager(self.client)
        image_id = resolve_id(image_mgr.resolve_ids,
                              args.get('<identifier>'),
                              'image')

        image = image_mgr.get_image(image_id)

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        table.add_row(['id', image['id']])
        table.add_row(['account', image.get('accountId', blank())])
        table.add_row(['name', image['name'].strip()])
        table.add_row(['global_identifier',
                       image.get('globalIdentifier', blank())])

        return table


class DeleteImage(CLIRunnable):
    """
usage: sl image delete <identifier> [options]

Get details for an image
"""
    action = 'delete'

    def execute(self, args):
        image_mgr = ImageManager(self.client)
        image_id = resolve_id(image_mgr.resolve_ids,
                              args.get('<identifier>'),
                              'image')

        image_mgr.delete_image(image_id)


class EditImage(CLIRunnable):
    """
usage: sl image edit <identifier> [--tag=Tag...] [options]

Edit Details for an image

Options:
    --name=Name     Name of the Image
    --note=Note     Note of the Image
    --tag=TAG...    Tags of the Image. Can be specified multiple times.

Note: Image to be edited must be private
"""
    action = 'edit'

    def execute(self, args):
        image_mgr = ImageManager(self.client)
        data = {}
        if args.get('--name'):
            data['name'] = args.get('--name')
        if args.get('--note'):
            data['note'] = args.get('--note')
        if args.get('--tag'):
            data['tag'] = args.get('--tag')
        image_id = resolve_id(image_mgr.resolve_ids,
                              args.get('<identifier>'), 'image')
        if not image_mgr.edit(image_id, **data):
            raise CLIAbort("Failed to Edit Image")

########NEW FILE########
__FILENAME__ = iscsi
"""
usage: sl iscsi [<command>] [<args>...] [options]

Manage, order, delete iSCSI targets

The available commands are:
  cancel  Cancel an existing iSCSI target
  create  Order and create an iSCSI target
  detail  Output details about an iSCSI
  list    List iSCSI targets on the account

For several commands, <identifier> will be asked for. This will be the id
for iSCSI target.
"""
from SoftLayer.CLI import (CLIRunnable, Table, no_going_back, FormattedItem)
from SoftLayer.CLI.helpers import (
    CLIAbort, ArgumentError, NestedDict, blank, resolve_id, KeyValueTable)
from SoftLayer import ISCSIManager


class ListISCSIs(CLIRunnable):

    """
usage: sl iscsi list [options]

List iSCSI targets
"""
    action = 'list'

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        iscsi_list = iscsi_mgr.list_iscsi()
        iscsi_list = [NestedDict(n) for n in iscsi_list]
        table = Table([
            'id',
            'datacenter',
            'size',
            'username',
            'password',
            'server'
        ])
        for iscsi in iscsi_list:
            table.add_row([
                iscsi['id'],
                iscsi['serviceResource']['datacenter'].get('name', blank()),
                FormattedItem(
                    iscsi.get('capacityGb', blank()),
                    "%dGB" % iscsi.get('capacityGb', 0)),
                iscsi.get('username', blank()),
                iscsi.get('password', blank()),
                iscsi.get('serviceResourceBackendIpAddress', blank())])
        return table


class CreateISCSI(CLIRunnable):

    """
usage: sl iscsi create [options]

Orders and creates an iSCSI target.

Examples:
    sl iscsi create --size=1 --datacenter=dal05
    sl iscsi create --size 1 -d dal05
    sl iscsi create -s 1 -d dal05

Required:
  -s, --size=SIZE       Size of the iSCSI volume to create
  -d, --datacenter=DC   Datacenter shortname (sng01, dal05, ...)
"""
    action = 'create'
    options = ['confirm']
    required_params = ['--size', '--datacenter']

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        self._validate_create_args(args)
        size, location = self._parse_create_args(args)
        iscsi_mgr.create_iscsi(size=size, location=location)

    def _parse_create_args(self, args):
        """ Converts CLI arguments to arguments that can be passed into
            ISCSIManager.create_iscsi.
        :param dict args: CLI arguments
        """
        size = args['--size']
        location = args['--datacenter']
        return int(size), str(location)

    def _validate_create_args(self, args):
        """ Raises an ArgumentError if the given arguments are not valid """
        invalid_args = [k for k in self.required_params if args.get(k) is None]
        if invalid_args:
            raise ArgumentError('Missing required options: %s'
                                % ','.join(invalid_args))


class CancelISCSI(CLIRunnable):

    """
usage: sl iscsi cancel <identifier> [options]

Cancel existing iSCSI

Examples:
    sl iscsi cancel 12345
    sl iscsi cancel 12345 --immediate
    sl iscsi cancel 12345 --immediate --reason='no longer needed'

options :
  --immediate    Cancels the iSCSI immediately (instead of on the billing
                    anniversary)
  --reason=REASON    An optional reason for cancellation.
"""
    action = 'cancel'
    options = ['confirm']

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        iscsi_id = resolve_id(
            iscsi_mgr.resolve_ids,
            args.get('<identifier>'),
            'iSCSI')

        immediate = args.get('--immediate', False)

        reason = args.get('--reason')
        if args['--really'] or no_going_back(iscsi_id):
            iscsi_mgr.cancel_iscsi(iscsi_id, reason, immediate)
        else:
            CLIAbort('Aborted')


class ISCSIDetails(CLIRunnable):

    """
usage: sl iscsi detail [--password] <identifier> [options]

Get details for an iSCSI

Examples:
    sl iscsi detail 12345
    sl iscsi detail 12345 --password

Options:
  --password  Show credentials to access the iSCSI target
"""
    action = 'detail'

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        iscsi_id = resolve_id(
            iscsi_mgr.resolve_ids,
            args.get('<identifier>'),
            'iSCSI')
        result = iscsi_mgr.get_iscsi(iscsi_id)
        result = NestedDict(result)

        table.add_row(['id', result['id']])
        table.add_row(['serviceResourceName', result['serviceResourceName']])
        table.add_row(['createDate', result['createDate']])
        table.add_row(['nasType', result['nasType']])
        table.add_row(['capacityGb', result['capacityGb']])
        if result['snapshotCapacityGb']:
            table.add_row(['snapshotCapacityGb', result['snapshotCapacityGb']])
        table.add_row(['mountableFlag', result['mountableFlag']])
        table.add_row(
            ['serviceResourceBackendIpAddress',
             result['serviceResourceBackendIpAddress']])
        table.add_row(['price', result['billingItem']['recurringFee']])
        table.add_row(['BillingItemId', result['billingItem']['id']])
        if result.get('notes'):
            table.add_row(['notes', result['notes']])

        if args.get('--password'):
            pass_table = Table(['username', 'password'])
            pass_table.add_row([result['username'], result['password']])
            table.add_row(['users', pass_table])

        return table

########NEW FILE########
__FILENAME__ = loadbal
"""
usage: sl loadbal [<command>] [<args>...] [options]

Local LoadBalancer management

The available commands are:
  cancel           Cancel an existing load balancer
  create           Create a new load balancer
  create-options   Lists the different packages for load balancers
  detail           Provide details about a particular load balancer
  group-add        Add a new service group in the load balancer
  group-delete     Delete a service group from the load balancer
  group-edit       Edit the properties of a service group
  group-reset      Resets all the connections on a service group
  health-checks    List the different health check values
  list             List active load balancers
  routing-methods  List supported routing methods
  routing-types    List supported routing types
  service-add      Add a service to an existing service group
  service-delete   Delete an existing service
  service-edit     Edit an existing service
  service-toggle   Toggle the status of the service
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import LoadBalancerManager
from SoftLayer.CLI import (CLIRunnable, Table, resolve_id,
                           confirm, KeyValueTable)
from SoftLayer.CLI.helpers import CLIAbort


def get_ids(input_id):
    """ Helper package to retrieve the actual IDs

    :param input_id: the ID provided by the user
    :returns: A list of valid IDs
    """
    key_value = input_id.split(':')
    if len(key_value) != 2:
        raise CLIAbort('Invalid ID %s: ID should be of the form xxx:yyy'
                       % input_id)
    return key_value


def get_local_lbs_table(load_balancers):
    """ Helper package to format the local load balancers into a table.

    :param dict load_balancers: A dictionary representing the load_balancers
    :returns: A table containing the local load balancers
    """
    table = Table(['ID',
                   'VIP Address',
                   'Location',
                   'SSL Offload',
                   'Connections/second',
                   'Type'])

    table.align['Connections/second'] = 'r'

    for load_balancer in load_balancers:
        ssl_support = 'Not Supported'
        if load_balancer['sslEnabledFlag']:
            if load_balancer['sslActiveFlag']:
                ssl_support = 'On'
            else:
                ssl_support = 'Off'
        lb_type = 'Standard'
        if load_balancer['dedicatedFlag']:
            lb_type = 'Dedicated'
        elif load_balancer['highAvailabilityFlag']:
            lb_type = 'HA'
        table.add_row([
            'local:%s' % load_balancer['id'],
            load_balancer['ipAddress']['ipAddress'],
            load_balancer['loadBalancerHardware'][0]['datacenter']['name'],
            ssl_support,
            load_balancer['connectionLimit'],
            lb_type
        ])
    return table


def get_local_lb_table(load_balancer):
    """ Helper package to format the local loadbal details into a table.

    :param dict load_balancer: A dictionary representing the loadbal
    :returns: A table containing the local loadbal details
    """
    table = KeyValueTable(['Name', 'Value'])
    table.align['Name'] = 'l'
    table.align['Value'] = 'l'
    table.add_row(['General properties', '----------'])
    table.add_row([' ID', 'local:%s' % load_balancer['id']])
    table.add_row([' IP Address', load_balancer['ipAddress']['ipAddress']])
    name = load_balancer['loadBalancerHardware'][0]['datacenter']['name']
    table.add_row([' Datacenter', name])
    table.add_row([' Connections limit', load_balancer['connectionLimit']])
    table.add_row([' Dedicated', load_balancer['dedicatedFlag']])
    table.add_row([' HA', load_balancer['highAvailabilityFlag']])
    table.add_row([' SSL Enabled', load_balancer['sslEnabledFlag']])
    table.add_row([' SSL Active', load_balancer['sslActiveFlag']])
    index0 = 1
    for virtual_server in load_balancer['virtualServers']:
        table.add_row(['Service group %s' % index0,
                       '**************'])
        index0 += 1
        table2 = Table(['Service group ID', 'Port', 'Allocation',
                        'Routing type', 'Routing Method'])

        for group in virtual_server['serviceGroups']:
            table2.add_row([
                '%s:%s' % (load_balancer['id'], virtual_server['id']),
                virtual_server['port'],
                '%s %%' % virtual_server['allocation'],
                '%s:%s' % (group['routingTypeId'],
                           group['routingType']['name']),
                '%s:%s' % (group['routingMethodId'],
                           group['routingMethod']['name'])
            ])

            table.add_row([' Group Properties', table2])

            table3 = Table(['Service_ID', 'IP Address', 'Port',
                            'Health Check', 'Weight', 'Enabled', 'Status'])
            service_exist = False
            for service in group['services']:
                service_exist = True
                health_check = service['healthChecks'][0]
                table3.add_row([
                    '%s:%s' % (load_balancer['id'], service['id']),
                    service['ipAddress']['ipAddress'],
                    service['port'],
                    '%s:%s' % (health_check['healthCheckTypeId'],
                               health_check['type']['name']),
                    service['groupReferences'][0]['weight'],
                    service['enabled'],
                    service['status']
                ])
            if service_exist:
                table.add_row([' Services', table3])
            else:
                table.add_row([' Services', 'None'])
    return table


class LoadBalancerList(CLIRunnable):
    """
usage: sl loadbal list [options]

List active load balancers

"""
    action = 'list'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)

        load_balancers = mgr.get_local_lbs()
        return get_local_lbs_table(load_balancers)


class LoadBalancerHealthChecks(CLIRunnable):
    """
usage: sl loadbal health-checks [options]

List load balancer service health check types that can be used
"""
    action = 'health-checks'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)

        hc_types = mgr.get_hc_types()
        table = KeyValueTable(['ID', 'Name'])
        table.align['ID'] = 'l'
        table.align['Name'] = 'l'
        table.sortby = 'ID'
        for hc_type in hc_types:
            table.add_row([hc_type['id'], hc_type['name']])
        return table


class LoadBalancerRoutingMethods(CLIRunnable):
    """
usage: sl loadbal routing-methods [options]

List load balancers routing methods that can be used
"""
    action = 'routing-methods'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)

        routing_methods = mgr.get_routing_methods()
        table = KeyValueTable(['ID', 'Name'])
        table.align['ID'] = 'l'
        table.align['Name'] = 'l'
        table.sortby = 'ID'
        for routing_method in routing_methods:
            table.add_row([routing_method['id'], routing_method['name']])
        return table


class LoadBalancerRoutingTypes(CLIRunnable):
    """
usage: sl loadbal routing-types [options]

List load balancers routing types that can be used
"""
    action = 'routing-types'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)

        routing_types = mgr.get_routing_types()
        table = KeyValueTable(['ID', 'Name'])
        table.align['ID'] = 'l'
        table.align['Name'] = 'l'
        table.sortby = 'ID'
        for routing_type in routing_types:
            table.add_row([routing_type['id'], routing_type['name']])
        return table


class LoadBalancerDetails(CLIRunnable):
    """
usage: sl loadbal detail <identifier> [options]

Get Load balancer details

"""
    action = 'detail'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)

        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        loadbal_id = int(key_value[1])

        load_balancer = mgr.get_local_lb(loadbal_id)
        return get_local_lb_table(load_balancer)


class LoadBalancerCancel(CLIRunnable):
    """
usage: sl loadbal cancel <identifier> [options]

Cancels an existing load_balancer

"""
    action = 'cancel'
    options = ['confirm']

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        loadbal_id = int(key_value[1])

        if args['--really'] or confirm("This action will cancel a load "
                                       "balancer. Continue?"):
            mgr.cancel_lb(loadbal_id)
            return 'Load Balancer with id %s is being cancelled!' % input_id
        else:
            raise CLIAbort('Aborted.')


class LoadBalancerServiceDelete(CLIRunnable):
    """
usage: sl loadbal service-delete <identifier> [options]

Deletes an existing load_balancer service

"""
    action = 'service-delete'
    options = ['confirm']

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        service_id = int(key_value[1])

        if args['--really'] or confirm("This action will cancel a service "
                                       "from your load balancer. Continue?"):
            mgr.delete_service(service_id)
            return 'Load balancer service %s is being cancelled!' % input_id
        else:
            raise CLIAbort('Aborted.')


class LoadBalancerServiceToggle(CLIRunnable):
    """
usage: sl loadbal service-toggle <identifier> [options]

Toggle the status of an existing load_balancer service

"""
    action = 'service-toggle'
    options = ['confirm']

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        service_id = int(key_value[1])

        if args['--really'] or confirm("This action will toggle the service "
                                       "status on the service. Continue?"):
            mgr.toggle_service_status(service_id)
            return 'Load balancer service %s status updated!' % input_id
        else:
            raise CLIAbort('Aborted.')


class LoadBalancerServiceEdit(CLIRunnable):
    """
usage: sl loadbal service-edit <identifier> [options]

Enable an existing load_balancer service
Options:
--enabled=ENABLED  Set to 1 to enable the service, or 0 to disable
--port=PORT        Change the value of the port
--weight=WEIGHT    Change the weight of the service
--hc_type=HCTYPE   Change the health check type
--ip=IP            Change the IP of the service

"""
    action = 'service-edit'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        loadbal_id = int(key_value[0])
        service_id = int(key_value[1])

        # check if any input is provided
        if not (args['--ip'] or args['--enabled'] or args['--weight']
                or args['--port'] or args['--hc_type']):
            return 'At least one property is required to be changed!'

        # check if the IP is valid
        ip_address_id = None
        if args['--ip']:
            ip_address = mgr.get_ip_address(args['--ip'])
            if not ip_address:
                return 'Provided IP address is not valid!'
            else:
                ip_address_id = ip_address['id']

        mgr.edit_service(loadbal_id,
                         service_id,
                         ip_address_id=ip_address_id,
                         enabled=args.get('--enabled'),
                         port=args.get('--port'),
                         weight=args.get('--weight'),
                         hc_type=args.get('--hc_type'))
        return 'Load balancer service %s is being modified!' % input_id


class LoadBalancerServiceAdd(CLIRunnable):
    """
usage: sl loadbal service-add <identifier> --ip=IP --port=PORT \
--weight=WEIGHT --hc_type=HCTYPE --enabled=ENABLED [options]

Adds a new load_balancer service
Required:
--enabled=ENABLED  Set to 1 to enable the service, 0 to disable [default: 1].
--port=PORT        Set to the desired port value [default: 80].
--weight=WEIGHT    Set to the desired weight  value [default: 1].
--hc_type=HCTYPE   Set to the desired health check value [default: 21].
--ip=IP            Set to the desired IP value.

"""
    action = 'service-add'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        loadbal_id = int(key_value[0])
        group_id = int(key_value[1])

        # check if the IP is valid
        ip_address = None
        if args['--ip']:
            ip_address = mgr.get_ip_address(args['--ip'])
            if not ip_address:
                return 'Provided IP address is not valid!'

        mgr.add_service(loadbal_id,
                        group_id,
                        ip_address_id=ip_address['id'],
                        enabled=args.get('--enabled'),
                        port=args.get('--port'),
                        weight=args.get('--weight'),
                        hc_type=args.get('--hc_type'))
        return 'Load balancer service is being added!'


class LoadBalancerServiceGroupDelete(CLIRunnable):
    """
usage: sl loadbal group-delete <identifier> [options]

Deletes an existing load_balancer service group

"""
    action = 'group-delete'
    options = ['confirm']

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        group_id = int(key_value[1])

        if args['--really'] or confirm("This action will cancel a service"
                                       " group. Continue?"):
            mgr.delete_service_group(group_id)
            return 'Service group %s is being deleted!' % input_id
        else:
            raise CLIAbort('Aborted.')


class LoadBalancerServiceGroupEdit(CLIRunnable):
    """
usage: sl loadbal group-edit <identifier> [options]

Edits an existing load_balancer service group
Options:
--allocation=PERC        Change the allocated % of connections
--port=PORT              Change the port
--routing_type=TYPE      Change the port routing type
--routing_method=METHOD  Change the routing method

"""
    action = 'group-edit'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        loadbal_id = int(key_value[0])
        group_id = int(key_value[1])

        # check if any input is provided
        if not (args['--allocation'] or args['--port']
                or args['--routing_type'] or args['--routing_method']):
            return 'At least one property is required to be changed!'

        routing_type = args.get('--routing_type')
        routing_method = args.get('--routing_method')

        mgr.edit_service_group(loadbal_id,
                               group_id,
                               allocation=args.get('--allocation'),
                               port=args.get('--port'),
                               routing_type=routing_type,
                               routing_method=routing_method)

        return 'Load balancer service group %s is being updated!' % input_id


class LoadBalancerServiceGroupReset(CLIRunnable):
    """
usage: sl loadbal group-reset <identifier> [options]

Resets the connections on a certain service group

"""
    action = 'group-reset'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')

        key_value = get_ids(input_id)
        loadbal_id = int(key_value[0])
        group_id = int(key_value[1])

        mgr.reset_service_group(loadbal_id, group_id)
        return 'Load balancer service group connections are being reset!'


class LoadBalancerServiceGroupAdd(CLIRunnable):
    """
usage: sl loadbal group-add <identifier> --allocation=PERC --port=PORT \
--routing_type=TYPE --routing_method=METHOD [options]

Adds a new load_balancer service
Required:
--allocation=PERC        The % of connections that will be allocated
--port=PORT              The virtual port number for the group
--routing_type=TYPE      The routing type for the group
--routing_method=METHOD  The routing method for the group

"""
    action = 'group-add'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = args.get('<identifier>')
        key_value = get_ids(input_id)

        loadbal_id = int(key_value[1])

        mgr.add_service_group(loadbal_id,
                              allocation=int(args.get('--allocation')),
                              port=int(args.get('--port')),
                              routing_type=int(args.get('--routing_type')),
                              routing_method=int(args.get('--routing_method')))

        return 'Load balancer service group is being added!'


class LoadBalancerCreate(CLIRunnable):
    """
usage: sl loadbal create <identifier> (--datacenter=DC) [options]

Adds a load_balancer given the billing id returned from create-options

Options:
  -d, --datacenter=DC    Datacenter shortname (sng01, dal05, ...)
                         Note: Omitting this value defaults to the first
                           available datacenter
"""
    action = 'create'
    options = ['confirm']

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)
        input_id = resolve_id(
            mgr.resolve_ids, args.get('<identifier>'), 'load_balancer')
        if not confirm("This action will incur charges on your account. "
                       "Continue?"):
            raise CLIAbort('Aborted.')
        mgr.add_local_lb(input_id, datacenter=args['--datacenter'])
        return "Load balancer is being created!"


class CreateOptionsLoadBalancer(CLIRunnable):
    """
usage: sl loadbal create-options

Output available options when adding a new load balancer

"""
    action = 'create-options'

    def execute(self, args):
        mgr = LoadBalancerManager(self.client)

        table = Table(['id', 'capacity', 'description', 'price'])

        table.sortby = 'price'
        table.align['price'] = 'r'
        table.align['capacity'] = 'r'
        table.align['id'] = 'r'

        packages = mgr.get_lb_pkgs()

        for package in packages:
            table.add_row([
                package['prices'][0]['id'],
                package.get('capacity'),
                package['description'],
                format(float(package['prices'][0]['recurringFee']), '.2f')
            ])

        return table

########NEW FILE########
__FILENAME__ = messaging
"""
usage: sl messaging [<command>] [<args>...] [options]

Manage the SoftLayer Message Queue service. For most commands, a queue account
is required. Use 'sl messaging accounts-list' to list current accounts

The available commands are:
  accounts-list      List all queue accounts
  endpoints-list     List all service endpoints
  ping               Ping the service

  queue-add          Create a new queue
  queue-detail       Prints the details of a queue
  queue-edit         Modifies an existing queue
  queue-list         Lists out all queues on an account
  queue-pop          Pop a message from a queue
  queue-push         Pushes a message into a queue
  queue-remove       Delete a queue

  topic-add          Creates a new topic
  topic-detail       Prints the details of a topic
  topic-list         Lists out all topics on an account
  topic-push         Pushes a notification to a topic
  topic-remove       Deletes a topic
  topic-subscribe    Adds a subscription on a topic
  topic-unsubscribe  Remove a subscription on a topic

"""
# :license: MIT, see LICENSE for more details.
# Missing docstrings ignored due to __doc__ = __doc__ magic
# pylint: disable=C0111
import sys

from SoftLayer import MessagingManager
from SoftLayer.CLI import CLIRunnable, Table
from SoftLayer.CLI.helpers import CLIAbort, listing, ArgumentError, blank


COMMON_MESSAGING_ARGS = """Service Options:
  --datacenter=NAME  Datacenter, E.G.: dal05
  --network=TYPE     Network type, [Options: public, private]
"""


class ListAccounts(CLIRunnable):
    """
usage: sl messaging accounts-list [options]

List SoftLayer Message Queue Accounts

"""
    action = 'accounts-list'

    def execute(self, args):
        manager = MessagingManager(self.client)
        accounts = manager.list_accounts()

        table = Table([
            'id', 'name', 'status'
        ])
        for account in accounts:
            if not account['nodes']:
                continue

            table.add_row([
                account['nodes'][0]['accountName'],
                account['name'],
                account['status']['name'],
            ])

        return table


class ListEndpoints(CLIRunnable):
    """
usage: sl messaging endpoints-list [options]

List SoftLayer Message Queue Endpoints

"""
    action = 'endpoints-list'

    def execute(self, args):
        manager = MessagingManager(self.client)
        regions = manager.get_endpoints()

        table = Table([
            'name', 'public', 'private'
        ])
        for region, endpoints in regions.items():
            table.add_row([
                region,
                endpoints.get('public') or blank(),
                endpoints.get('private') or blank(),
            ])

        return table


class Ping(CLIRunnable):
    __doc__ = """
usage: sl messaging ping [options]

Ping the SoftLayer Message Queue service

""" + COMMON_MESSAGING_ARGS
    action = 'ping'

    def execute(self, args):
        manager = MessagingManager(self.client)
        okay = manager.ping(
            datacenter=args['--datacenter'], network=args['--network'])
        if okay:
            return 'OK'
        else:
            CLIAbort('Ping failed')


def queue_table(queue):
    """ Returns a table with details about a queue """
    table = Table(['property', 'value'])
    table.align['property'] = 'r'
    table.align['value'] = 'l'

    table.add_row(['name', queue['name']])
    table.add_row(['message_count', queue['message_count']])
    table.add_row(['visible_message_count', queue['visible_message_count']])
    table.add_row(['tags', listing(queue['tags'] or [])])
    table.add_row(['expiration', queue['expiration']])
    table.add_row(['visibility_interval', queue['visibility_interval']])
    return table


def message_table(message):
    """ Returns a table with details about a message """
    table = Table(['property', 'value'])
    table.align['property'] = 'r'
    table.align['value'] = 'l'

    table.add_row(['id', message['id']])
    table.add_row(['initial_entry_time', message['initial_entry_time']])
    table.add_row(['visibility_delay', message['visibility_delay']])
    table.add_row(['visibility_interval', message['visibility_interval']])
    table.add_row(['fields', message['fields']])
    return [table, message['body']]


def topic_table(topic):
    """ Returns a table with details about a topic """
    table = Table(['property', 'value'])
    table.align['property'] = 'r'
    table.align['value'] = 'l'

    table.add_row(['name', topic['name']])
    table.add_row(['tags', listing(topic['tags'] or [])])
    return table


def subscription_table(sub):
    """ Returns a table with details about a subscription """
    table = Table(['property', 'value'])
    table.align['property'] = 'r'
    table.align['value'] = 'l'

    table.add_row(['id', sub['id']])
    table.add_row(['endpoint_type', sub['endpoint_type']])
    for key, val in sub['endpoint'].items():
        table.add_row([key, val])
    return table


class QueueList(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-list <account_id> [options]

List all queues on an account

""" + COMMON_MESSAGING_ARGS
    action = 'queue-list'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])

        queues = mq_client.get_queues()['items']

        table = Table([
            'name', 'message_count', 'visible_message_count'
        ])
        for queue in queues:
            table.add_row([
                queue['name'],
                queue['message_count'],
                queue['visible_message_count'],
            ])
        return table


class QueueDetail(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-detail <account_id> <queue_name> [options]

Detail a queue

""" + COMMON_MESSAGING_ARGS
    action = 'queue-detail'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        queue = mq_client.get_queue(args['<queue_name>'])
        return queue_table(queue)


class QueueCreate(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-add <account_id> <queue_name> [options]

Create a queue

Options:
  --visibility_interval=SECONDS  Time in seconds that messages will re-appear
                                   after being popped
  --expiration=SECONDS           Time in seconds that messages will live
  --tags=TAGS                    Comma-separated list of tags

""" + COMMON_MESSAGING_ARGS
    action = 'queue-add'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        tags = None
        if args.get('--tags'):
            tags = [tag.strip() for tag in args.get('--tags').split(',')]

        queue = mq_client.create_queue(
            args['<queue_name>'],
            visibility_interval=int(args.get('--visibility_interval') or 30),
            expiration=int(args.get('--expiration') or 604800),
            tags=tags,
        )
        return queue_table(queue)


class QueueModify(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-edit <account_id> <queue_name> [options]

Modify a queue

Options:
  --visibility_interval=SECONDS  Time in seconds that messages will re-appear
                                   after being popped
  --expiration=SECONDS           Time in seconds that messages will live
  --tags=TAGS                    Comma-separated list of tags

""" + COMMON_MESSAGING_ARGS
    action = 'queue-edit'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        tags = None
        if args.get('--tags'):
            tags = [tag.strip() for tag in args.get('--tags').split(',')]

        queue = mq_client.create_queue(
            args['<queue_name>'],
            visibility_interval=int(args.get('--visibility_interval') or 30),
            expiration=int(args.get('--expiration') or 604800),
            tags=tags,
        )
        return queue_table(queue)


class QueueDelete(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-remove <account_id> <queue_name> [<message_id>]
                                 [options]

Delete a queue or a queued message

Options:
  --force  Flag to force the deletion of the queue even when there are messages

""" + COMMON_MESSAGING_ARGS
    action = 'queue-remove'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])

        if args['<message_id>']:
            mq_client.delete_message(args['<queue_name>'],
                                     args['<message_id>'])
        else:
            mq_client.delete_queue(args['<queue_name>'], args.get('--force'))


class QueuePush(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-push <account_id> <queue_name> (<message> | -)
                               [options]

Push a message into a queue

Options:
  --force  Flag to force the deletion of the queue even when there are messages

""" + COMMON_MESSAGING_ARGS
    action = 'queue-push'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        body = ''
        if args['<message>'] == '-':
            body = sys.stdin.read()
        else:
            body = args['<message>']
        return message_table(
            mq_client.push_queue_message(args['<queue_name>'], body))


class QueuePop(CLIRunnable):
    __doc__ = """
usage: sl messaging queue-pop <account_id> <queue_name>  [options]

Pops a message from a queue

Options:
  --count=NUM     Count of messages to pop
  --delete-after  Remove popped messages from the queue

""" + COMMON_MESSAGING_ARGS
    action = 'queue-pop'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])

        messages = mq_client.pop_messages(
            args['<queue_name>'],
            args.get('--count') or 1)
        formatted_messages = []
        for message in messages['items']:
            formatted_messages.append(message_table(message))

        if args.get('--delete-after'):
            for message in messages['items']:
                mq_client.delete_message(
                    args['<queue_name>'],
                    message['id'])
        return formatted_messages


class TopicList(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-list <account_id> [options]

List all topics on an account

""" + COMMON_MESSAGING_ARGS
    action = 'topic-list'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        topics = mq_client.get_topics()['items']

        table = Table(['name'])
        for topic in topics:
            table.add_row([topic['name']])
        return table


class TopicDetail(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-detail <account_id> <topic_name> [options]

Detail a topic

""" + COMMON_MESSAGING_ARGS
    action = 'topic-detail'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        topic = mq_client.get_topic(args['<topic_name>'])
        subscriptions = mq_client.get_subscriptions(args['<topic_name>'])
        tables = []
        for sub in subscriptions['items']:
            tables.append(subscription_table(sub))
        return [topic_table(topic), tables]


class TopicCreate(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-add <account_id> <topic_name> [options]

Create a new topic

""" + COMMON_MESSAGING_ARGS
    action = 'topic-add'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        tags = None
        if args.get('--tags'):
            tags = [tag.strip() for tag in args.get('--tags').split(',')]

        topic = mq_client.create_topic(
            args['<topic_name>'],
            visibility_interval=int(
                args.get('--visibility_interval') or 30),
            expiration=int(args.get('--expiration') or 604800),
            tags=tags,
        )
        return topic_table(topic)


class TopicDelete(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-remove <account_id> <topic_name> [options]

Delete a topic or subscription

Options:
  --force  Flag to force the deletion of the topic even when there are
             subscriptions
""" + COMMON_MESSAGING_ARGS
    action = 'topic-remove'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        mq_client.delete_topic(args['<topic_name>'], args.get('--force'))


class TopicSubscribe(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-subscribe <account_id> <topic_name> [options]

Create a subscription on a topic

Options:
  --type=TYPE           Type of endpoint, [Options: http, queue]
  --queue-name=NAME     Queue name. Required if --type is queue
  --http-method=METHOD  HTTP Method to use if --type is http
  --http-url=URL        HTTP/HTTPS URL to use. Required if --type is http
  --http-body=BODY      HTTP Body template to use if --type is http

""" + COMMON_MESSAGING_ARGS
    action = 'topic-subscribe'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])
        if args['--type'] == 'queue':
            subscription = mq_client.create_subscription(
                args['<topic_name>'],
                'queue',
                queue_name=args['--queue-name'],
            )
        elif args['--type'] == 'http':
            subscription = mq_client.create_subscription(
                args['<topic_name>'],
                'http',
                method=args['--http-method'] or 'GET',
                url=args['--http-url'],
                body=args['--http-body']
            )
        else:
            raise ArgumentError(
                '--type should be either queue or http.')
        return subscription_table(subscription)


class TopicUnsubscribe(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-unsubscribe <account_id> <topic_name>
                                      <subscription_id> [options]

Remove a subscription on a topic

""" + COMMON_MESSAGING_ARGS
    action = 'topic-unsubscribe'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])

        mq_client.delete_subscription(
            args['<topic_name>'],
            args['<subscription_id>'])


class TopicPush(CLIRunnable):
    __doc__ = """
usage: sl messaging topic-push <account_id> <topic_name> (<message> | -)
                               [options]

Push a message into a topic

""" + COMMON_MESSAGING_ARGS
    action = 'topic-push'

    def execute(self, args):
        manager = MessagingManager(self.client)
        mq_client = manager.get_connection(args['<account_id>'])

        # the message body comes from the positional argument or stdin
        body = ''
        if args['<message>'] == '-':
            body = sys.stdin.read()
        else:
            body = args['<message>']
        return message_table(
            mq_client.push_topic_message(args['<topic_name>'], body))

########NEW FILE########
__FILENAME__ = metadata
"""
usage: sl metadata [<command>] [<args>...] [options]

Find details about this machine. These commands only work on devices on the
backend SoftLayer network. This allows for self-discovery for newly provisioned
resources.

The available commands are:
  backend_ip       Primary backend ip address
  backend_mac      Backend mac addresses
  datacenter       Datacenter name
  datacenter_id    Datacenter id
  fqdn             Fully qualified domain name
  frontend_mac     Frontend mac addresses
  hostname         Hostname
  id               Id
  ip               Primary ip address
  network          Details about either the public or private network
  provision_state  Provision state
  tags             Tags
  user_data        User-defined data
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import MetadataManager, TransportError
from SoftLayer.CLI import CLIRunnable, KeyValueTable, listing, CLIAbort


class MetaRunnable(CLIRunnable):
    """ A CLIRunnable that raises a nice error on connection issues because
        the metadata service is only accessable on a SoftLayer device """
    def execute(self, args):
        try:
            return self._execute(args)
        except TransportError:
            raise CLIAbort(
                'Cannot connect to the backend service address. Make sure '
                'this command is being ran from a device on the backend '
                'network.')

    def _execute(self, _):
        """ To be overridden exactly like the execute() method """
        pass


class BackendMacAddresses(MetaRunnable):
    """
usage: sl metadata backend_mac [options]

List backend mac addresses
"""
    action = 'backend_mac'

    def _execute(self, _):
        return listing(MetadataManager().get('backend_mac'), separator=',')


class Datacenter(MetaRunnable):
    """
usage: sl metadata datacenter [options]

Get datacenter name
"""
    action = 'datacenter'

    def _execute(self, _):
        return MetadataManager().get('datacenter')


class DatacenterId(MetaRunnable):
    """
usage: sl metadata datacenter_id [options]

Get datacenter id
"""
    action = 'datacenter_id'

    def _execute(self, _):
        return MetadataManager().get('datacenter_id')


class FrontendMacAddresses(MetaRunnable):
    """
usage: sl metadata frontend_mac [options]

List frontend mac addresses
"""
    action = 'frontend_mac'

    def _execute(self, _):
        return listing(MetadataManager().get('frontend_mac'), separator=',')


class FullyQualifiedDomainName(MetaRunnable):
    """
usage: sl metadata fqdn [options]

Get fully qualified domain name
"""
    action = 'fqdn'

    def _execute(self, _):
        return MetadataManager().get('fqdn')


class Hostname(MetaRunnable):
    """
usage: sl metadata hostname [options]

Get hostname
"""
    action = 'hostname'

    def _execute(self, _):
        return MetadataManager().get('hostname')


class Id(MetaRunnable):
    """
usage: sl metadata id

Get id
"""
    action = 'id'

    def _execute(self, _):
        return MetadataManager().get('id')


class PrimaryBackendIpAddress(MetaRunnable):
    """
usage: sl metadata backend_ip [options]

Get primary backend ip address
"""
    action = 'backend_ip'

    def _execute(self, _):
        return MetadataManager().get('primary_backend_ip')


class PrimaryIpAddress(MetaRunnable):
    """
usage: sl metadata ip [options]

Get primary ip address
"""
    action = 'ip'

    def _execute(self, _):
        return MetadataManager().get('primary_ip')


class ProvisionState(MetaRunnable):
    """
usage: sl metadata provision_state [options]

Get provision state
"""
    action = 'provision_state'

    def _execute(self, _):
        return MetadataManager().get('provision_state')


class Tags(MetaRunnable):
    """
usage: sl metadata tags [options]

List tags
"""
    action = 'tags'

    def _execute(self, _):
        return listing(MetadataManager().get('tags'), separator=',')


class UserMetadata(CLIRunnable):
    """
usage: sl metadata user_data [options]

Get user-defined data
"""
    action = 'user_data'

    def _execute(self, _):
        """ Returns user metadata """
        userdata = MetadataManager().get('user_data')
        if userdata:
            return userdata
        else:
            raise CLIAbort("No user metadata.")


class Network(MetaRunnable):
    """
usage: sl metadata network (<public> | <private>) [options]

Get details about the public or private network
"""
    action = 'network'

    def _execute(self, args):
        meta = MetadataManager()
        if args['<public>']:
            table = KeyValueTable(['Name', 'Value'])
            table.align['Name'] = 'r'
            table.align['Value'] = 'l'
            network = meta.public_network()
            table.add_row([
                'mac addresses',
                listing(network['mac_addresses'], separator=',')])
            table.add_row([
                'router', network['router']])
            table.add_row([
                'vlans', listing(network['vlans'], separator=',')])
            table.add_row([
                'vlan ids',
                listing(network['vlan_ids'], separator=',')])
            return table

        if args['<private>']:
            table = KeyValueTable(['Name', 'Value'])
            table.align['Name'] = 'r'
            table.align['Value'] = 'l'
            network = meta.private_network()
            table.add_row([
                'mac addresses',
                listing(network['mac_addresses'], separator=',')])
            table.add_row([
                'router', network['router']])
            table.add_row([
                'vlans', listing(network['vlans'], separator=',')])
            table.add_row([
                'vlan ids',
                listing(network['vlan_ids'], separator=',')])
            return table

########NEW FILE########
__FILENAME__ = nas
"""
usage: sl nas [<command>] [<args>...] [options]

Manage NAS accounts

The available commands are:
  list  List NAS accounts
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer.CLI import CLIRunnable, Table, FormattedItem
from SoftLayer.CLI.helpers import blank
from SoftLayer.utils import lookup


class ListNAS(CLIRunnable):
    """
usage: sl nas list [options]

List NAS accounts

Options:
"""
    action = 'list'

    def execute(self, args):
        account = self.client['Account']

        nas_accounts = account.getNasNetworkStorage(
            mask='eventCount,serviceResource[datacenter.name]')

        table = Table(['id', 'datacenter', 'size', 'username', 'password',
                       'server'])

        for nas_account in nas_accounts:
            table.add_row([
                nas_account['id'],
                lookup(nas_account,
                       'serviceResource',
                       'datacenter',
                       'name') or blank(),
                FormattedItem(
                    nas_account.get('capacityGb', blank()),
                    "%dGB" % nas_account.get('capacityGb', 0)),
                nas_account.get('username', blank()),
                nas_account.get('password', blank()),
                nas_account.get('serviceResourceBackendIpAddress', blank())])

        return table

########NEW FILE########
__FILENAME__ = rwhois
"""
usage: sl rwhois [<command>] [<args>...] [options]

Manage the RWhoIs information on the account.

The available commands are:
  edit  Edit the RWhois data on the account
  show  Show the RWhois data on the account
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import NetworkManager
from SoftLayer.CLI import CLIRunnable, KeyValueTable
from SoftLayer.CLI.helpers import CLIAbort


class RWhoisEdit(CLIRunnable):
    """
usage: sl rwhois edit [options]

Updates the RWhois information on your account. Only the fields you
specify will be changed. To clear a value, specify an empty string like: ""

Options:
  --abuse=EMAIL      Set the abuse email
  --address1=ADDR    Update the address 1 field
  --address2=ADDR    Update the address 2 field
  --city=CITY        Set the city information
  --company=NAME     Set the company name
  --country=COUNTRY  Set the country information. Use the two-letter
                       abbreviation.
  --firstname=NAME   Update the first name field
  --lastname=NAME    Update the last name field
  --postal=CODE      Set the postal code field
  --private          Flags the address as a private residence.
  --public           Flags the address as a public residence.
  --state=STATE      Set the state information. Use the two-letter
                       abbreviation.
"""
    action = 'edit'

    def execute(self, args):
        mgr = NetworkManager(self.client)

        update = {
            'abuse_email': args.get('--abuse'),
            'address1': args.get('--address1'),
            'address2': args.get('--address2'),
            'company_name': args.get('--company'),
            'city': args.get('--city'),
            'country': args.get('--country'),
            'first_name': args.get('--firstname'),
            'last_name': args.get('--lastname'),
            'postal_code': args.get('--postal'),
            'state': args.get('--state')
        }

        if args.get('--private'):
            update['private_residence'] = False
        elif args.get('--public'):
            update['private_residence'] = True

        check = [x for x in update.values() if x is not None]
        if not check:
            raise CLIAbort("You must specify at least one field to update.")

        mgr.edit_rwhois(**update)  # pylint: disable=W0142


class RWhoisShow(CLIRunnable):
    """
usage: sl rwhois show [options]

Display the RWhois information for your account.
"""
    action = 'show'

    def execute(self, args):
        mgr = NetworkManager(self.client)
        result = mgr.get_rwhois()

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'
        table.add_row(['Name', result['firstName'] + ' ' + result['lastName']])
        table.add_row(['Company', result['companyName']])
        table.add_row(['Abuse Email', result['abuseEmail']])
        table.add_row(['Address 1', result['address1']])
        if result.get('address2'):
            table.add_row(['Address 2', result['address2']])
        table.add_row(['City', result['city']])
        table.add_row(['State', result.get('state', '-')])
        table.add_row(['Postal Code', result.get('postalCode', '-')])
        table.add_row(['Country', result['country']])

        return table

########NEW FILE########
__FILENAME__ = server
"""
usage: sl server [<command>] [<args>...] [options]
       sl server [-h | --help]

Manage hardware servers

The available commands are:
  cancel          Cancel a dedicated server.
  cancel-reasons  Provides the list of possible cancellation reasons
  create          Create a new dedicated server
  create-options  Display a list of creation options for a specific chassis
  detail          Retrieve hardware details
  list            List hardware devices
  list-chassis    Provide a list of all chassis available for ordering
  nic-edit        Edit NIC settings
  power-cycle     Issues power cycle to server
  power-off       Powers off a running server
  power-on        Boots up a server
  reboot          Reboots a running server
  reload          Perform an OS reload

For several commands, <identifier> will be asked for. This can be the id,
hostname or the ip address for a piece of hardware.
"""
# :license: MIT, see LICENSE for more details.
import re
import os
from os import linesep
from SoftLayer.CLI.helpers import (
    CLIRunnable, Table, KeyValueTable, FormattedItem, NestedDict, CLIAbort,
    blank, listing, gb, active_txn, no_going_back, resolve_id, confirm,
    ArgumentError, update_with_template_args, export_to_template)
from SoftLayer import HardwareManager, SshKeyManager


class ListServers(CLIRunnable):
    """
usage: sl server list [options]

List hardware servers on the acount

Examples:
  sl server list --datacenter=dal05
  sl server list --network=100 --domain=example.com
  sl server list --tags=production,db

Options:
  --sortby=ARG  Column to sort by. options: id, datacenter, host, cores,
                  memory, primary_ip, backend_ip

Filters:
  -c, --cpu=CPU        Number of CPU cores
  -D, --domain=DOMAIN  Domain portion of the FQDN. example: example.com
  -d, --datacenter=DC  Datacenter shortname (sng01, dal05, ...)
  -H, --hostname=HOST  Host portion of the FQDN. example: server
  -m, --memory=MEMORY  Memory in gigabytes
  -n, --network=MBPS   Network port speed in Mbps
  --tags=ARG           Only show instances that have one of these tags.
                         Comma-separated. (production,db)

For more on filters see 'sl help filters'
"""
    action = 'list'

    def execute(self, args):
        manager = HardwareManager(self.client)

        tags = None
        if args.get('--tags'):
            tags = [tag.strip() for tag in args.get('--tags').split(',')]

        servers = manager.list_hardware(
            hostname=args.get('--hostname'),
            domain=args.get('--domain'),
            cpus=args.get('--cpu'),
            memory=args.get('--memory'),
            datacenter=args.get('--datacenter'),
            nic_speed=args.get('--network'),
            tags=tags)

        table = Table([
            'id',
            'datacenter',
            'host',
            'cores',
            'memory',
            'primary_ip',
            'backend_ip',
            'active_transaction'
        ])
        table.sortby = args.get('--sortby') or 'host'

        for server in servers:
            server = NestedDict(server)
            table.add_row([
                server['id'],
                server['datacenter']['name'] or blank(),
                server['fullyQualifiedDomainName'],
                server['processorPhysicalCoreAmount'],
                gb(server['memoryCapacity'] or 0),
                server['primaryIpAddress'] or blank(),
                server['primaryBackendIpAddress'] or blank(),
                active_txn(server),
            ])

        return table


class ServerDetails(CLIRunnable):
    """
usage: sl server detail [--passwords] [--price] <identifier> [options]

Get details for a hardware device

Options:
  --passwords  Show passwords (check over your shoulder!)
  --price      Show associated prices
"""
    action = 'detail'

    def execute(self, args):
        hardware = HardwareManager(self.client)

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        hardware_id = resolve_id(
            hardware.resolve_ids, args.get('<identifier>'), 'hardware')
        result = hardware.get_hardware(hardware_id)
        result = NestedDict(result)

        table.add_row(['id', result['id']])
        table.add_row(['hostname', result['fullyQualifiedDomainName']])
        table.add_row(['status', result['hardwareStatus']['status']])
        table.add_row(['datacenter', result['datacenter']['name'] or blank()])
        table.add_row(['cores', result['processorPhysicalCoreAmount']])
        table.add_row(['memory', gb(result['memoryCapacity'])])
        table.add_row(['public_ip', result['primaryIpAddress'] or blank()])
        table.add_row(
            ['private_ip', result['primaryBackendIpAddress'] or blank()])
        table.add_row(['ipmi_ip',
                       result['networkManagementIpAddress'] or blank()])
        table.add_row([
            'os',
            FormattedItem(
                result['operatingSystem']['softwareLicense']
                ['softwareDescription']['referenceCode'] or blank(),
                result['operatingSystem']['softwareLicense']
                ['softwareDescription']['name'] or blank()
            )])
        table.add_row(['created', result['provisionDate'] or blank()])

        vlan_table = Table(['type', 'number', 'id'])
        for vlan in result['networkVlans']:
            vlan_table.add_row([
                vlan['networkSpace'], vlan['vlanNumber'], vlan['id']])
        table.add_row(['vlans', vlan_table])

        if result.get('notes'):
            table.add_row(['notes', result['notes']])

        if args.get('--price'):
            table.add_row(['price rate',
                           result['billingItem']['recurringFee']])

        if args.get('--passwords'):
            user_strs = []
            for item in result['operatingSystem']['passwords']:
                user_strs.append(
                    "%s %s" % (item['username'], item['password']))
            table.add_row(['users', listing(user_strs)])

        tag_row = []
        for tag in result['tagReferences']:
            tag_row.append(tag['tag']['name'])

        if tag_row:
            table.add_row(['tags', listing(tag_row, separator=',')])

        # Test to see if this actually has a primary (public) ip address
        if result['primaryIpAddress']:
            ptr_domains = self.client['Hardware_Server']\
                .getReverseDomainRecords(id=hardware_id)

            for ptr_domain in ptr_domains:
                for ptr in ptr_domain['resourceRecords']:
                    table.add_row(['ptr', ptr['data']])

        return table


class ServerReload(CLIRunnable):
    """
usage: sl server reload <identifier> [--key=KEY...] [options]

Reload the OS on a hardware server based on its current configuration

Optional:
  -i, --postinstall=URI  Post-install script to download
                           (Only HTTPS executes, HTTP leaves file in /root)
  -k, --key=KEY          SSH keys to add to the root user. Can be specified
                           multiple times
"""

    action = 'reload'
    options = ['confirm']

    def execute(self, args):
        hardware = HardwareManager(self.client)
        hardware_id = resolve_id(
            hardware.resolve_ids, args.get('<identifier>'), 'hardware')
        keys = []
        if args.get('--key'):
            for key in args.get('--key'):
                key_id = resolve_id(SshKeyManager(self.client).resolve_ids,
                                    key, 'SshKey')
                keys.append(key_id)
        if args['--really'] or no_going_back(hardware_id):
            hardware.reload(hardware_id, args['--postinstall'], keys)
        else:
            CLIAbort('Aborted')


class CancelServer(CLIRunnable):
    """
usage: sl server cancel <identifier> [options]

Cancel a dedicated server

Options:
  --comment=COMMENT  An optional comment to add to the cancellation ticket
  --reason=REASON    An optional cancellation reason. See cancel-reasons for a
                       list of available options
"""

    action = 'cancel'
    options = ['confirm']

    def execute(self, args):
        mgr = HardwareManager(self.client)
        hw_id = resolve_id(
            mgr.resolve_ids, args.get('<identifier>'), 'hardware')

        comment = args.get('--comment')

        if not comment and not args['--really']:
            comment = self.env.input("(Optional) Add a cancellation comment:")

        reason = args.get('--reason')

        if args['--really'] or no_going_back(hw_id):
            mgr.cancel_hardware(hw_id, reason, comment)
        else:
            CLIAbort('Aborted')


class ServerCancelReasons(CLIRunnable):
    """
usage: sl server cancel-reasons

Display a list of cancellation reasons
"""

    action = 'cancel-reasons'

    def execute(self, args):
        table = Table(['Code', 'Reason'])
        table.align['Code'] = 'r'
        table.align['Reason'] = 'l'

        mgr = HardwareManager(self.client)

        for code, reason in mgr.get_cancellation_reasons().items():
            table.add_row([code, reason])

        return table


class ServerPowerOff(CLIRunnable):
    """
usage: sl server power-off <identifier> [options]

Power off an active server
"""
    action = 'power-off'
    options = ['confirm']

    def execute(self, args):
        mgr = HardwareManager(self.client)
        hw_id = resolve_id(mgr.resolve_ids, args.get('<identifier>'),
                           'hardware')
        if args['--really'] or confirm('This will power off the server with '
                                       'id %s. Continue?' % hw_id):
            self.client['Hardware_Server'].powerOff(id=hw_id)
        else:
            raise CLIAbort('Aborted.')


class ServerReboot(CLIRunnable):
    """
usage: sl server reboot <identifier> [--hard | --soft] [options]

Reboot an active server

Optional:
    --hard  Perform an abrupt reboot
    --soft  Perform a graceful reboot
"""
    action = 'reboot'
    options = ['confirm']

    def execute(self, args):
        hardware_server = self.client['Hardware_Server']
        mgr = HardwareManager(self.client)
        hw_id = resolve_id(mgr.resolve_ids, args.get('<identifier>'),
                           'hardware')
        if args['--really'] or confirm('This will power off the server with '
                                       'id %s. Continue?' % hw_id):
            if args['--hard']:
                hardware_server.rebootHard(id=hw_id)
            elif args['--soft']:
                hardware_server.rebootSoft(id=hw_id)
            else:
                hardware_server.rebootDefault(id=hw_id)
        else:
            raise CLIAbort('Aborted.')


class ServerPowerOn(CLIRunnable):
    """
usage: sl server power-on <identifier> [options]

Power on a server
"""
    action = 'power-on'

    def execute(self, args):
        mgr = HardwareManager(self.client)
        hw_id = resolve_id(mgr.resolve_ids, args.get('<identifier>'),
                           'hardware')
        self.client['Hardware_Server'].powerOn(id=hw_id)


class ServerPowerCycle(CLIRunnable):
    """
usage: sl server power-cycle <identifier> [options]

Issues power cycle to server via the power strip
"""
    action = 'power-cycle'
    options = ['confirm']

    def execute(self, args):
        mgr = HardwareManager(self.client)
        hw_id = resolve_id(mgr.resolve_ids, args.get('<identifier>'),
                           'hardware')

        if args['--really'] or confirm('This will power off the server with '
                                       'id %s. Continue?' % hw_id):
            self.client['Hardware_Server'].powerCycle(id=hw_id)
        else:
            raise CLIAbort('Aborted.')


class NicEditServer(CLIRunnable):
    """
usage: sl server nic-edit <identifier> (public | private) --speed=SPEED
                          [options]

Manage NIC settings

Options:
    --speed=SPEED  Port speed. 0 disables the port.
                     [Options: 0, 10, 100, 1000, 10000]
"""
    action = 'nic-edit'

    def execute(self, args):
        public = args['public']

        mgr = HardwareManager(self.client)
        hw_id = resolve_id(mgr.resolve_ids, args.get('<identifier>'),
                           'hardware')

        mgr.change_port_speed(hw_id, public, args['--speed'])


class ListChassisServer(CLIRunnable):
    """
usage: sl server list-chassis [options]

Display a list of chassis available for ordering dedicated servers.
"""
    action = 'list-chassis'

    def execute(self, args):
        table = Table(['Code', 'Chassis'])
        table.align['Code'] = 'r'
        table.align['Chassis'] = 'l'

        mgr = HardwareManager(self.client)
        chassis = mgr.get_available_dedicated_server_packages()

        for chassis in chassis:
            table.add_row([chassis[0], chassis[1]])

        return table


class ServerCreateOptions(CLIRunnable):
    """
usage: sl server create-options <chassis_id> [options]

Output available available options when creating a dedicated server with the
specified chassis.

Options:
  --all         Show all options. default if no other option provided
  --controller  Show disk controller options
  --cpu         Show CPU options
  --datacenter  Show datacenter options
  --disk        Show disk options
  --memory      Show memory size options
  --nic         Show NIC speed options
  --os          Show operating system options
"""

    action = 'create-options'
    options = ['datacenter', 'cpu', 'memory', 'os', 'disk', 'nic',
               'controller']

    def execute(self, args):
        mgr = HardwareManager(self.client)

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        chassis_id = args.get('<chassis_id>')

        found = False
        for chassis in mgr.get_available_dedicated_server_packages():
            if chassis_id == str(chassis[0]):
                found = True
                break

        if not found:
            raise CLIAbort('Invalid chassis specified.')

        ds_options = mgr.get_dedicated_server_create_options(chassis_id)

        show_all = True
        for opt_name in self.options:
            if args.get("--" + opt_name):
                show_all = False
                break

        if args['--all']:
            show_all = True

        # Determine if this is a "Bare Metal Instance" or regular server
        bmc = False
        if chassis_id == str(mgr.get_bare_metal_package_id()):
            bmc = True

        if args['--datacenter'] or show_all:
            results = self.get_create_options(ds_options, 'datacenter')[0]

            table.add_row([results[0], listing(sorted(results[1]))])

        if (args['--cpu'] or show_all) and not bmc:
            results = self.get_create_options(ds_options, 'cpu')

            cpu_table = Table(['ID', 'Description'])
            cpu_table.align['ID'] = 'r'
            cpu_table.align['Description'] = 'l'

            for result in sorted(results, key=lambda x: x[1]):
                cpu_table.add_row([result[1], result[0]])
            table.add_row(['cpu', cpu_table])

        if (args['--memory'] or show_all) and not bmc:
            results = self.get_create_options(ds_options, 'memory')[0]

            table.add_row([results[0], listing(
                item[0] for item in sorted(results[1]))])

        if bmc and (show_all or args['--memory'] or args['--cpu']):
            results = self.get_create_options(ds_options, 'server_core')
            memory_cpu_table = Table(['memory', 'cpu'])
            for result in results:
                memory_cpu_table.add_row([
                    result[0],
                    listing(
                        [item[0] for item in sorted(
                            result[1], key=lambda x: int(x[0])
                        )])])
            table.add_row(['memory/cpu', memory_cpu_table])

        if args['--os'] or show_all:
            results = self.get_create_options(ds_options, 'os')

            for result in results:
                table.add_row([
                    result[0],
                    listing(
                        [item[0] for item in sorted(result[1])],
                        separator=linesep
                    )])

        if args['--disk'] or show_all:
            results = self.get_create_options(ds_options, 'disk')[0]

            table.add_row([
                results[0],
                listing(
                    [item[0] for item in sorted(results[1])],
                    separator=linesep
                )])

        if args['--nic'] or show_all:
            results = self.get_create_options(ds_options, 'nic')

            for result in results:
                table.add_row([result[0], listing(
                    item[0] for item in sorted(result[1],))])

        if (args['--controller'] or show_all) and not bmc:
            results = self.get_create_options(ds_options, 'disk_controller')[0]

            table.add_row([results[0], listing(
                item[0] for item in sorted(results[1],))])

        return table

    def get_create_options(self, ds_options, section, pretty=True):
        """ This method can be used to parse the bare metal instance creation
        options into different sections. This can be useful for data validation
        as well as printing the options on a help screen.

        :param dict ds_options: The instance options to parse. Must come from
                                 the .get_bare_metal_create_options() function
                                 in the HardwareManager.
        :param string section: The section to parse out.
        :param bool pretty: If true, it will return the results in a 'pretty'
                            format that's easier to print.
        """
        return_value = None

        if 'datacenter' == section:
            datacenters = [loc['keyname']
                           for loc in ds_options['locations']]
            return_value = [('datacenter', datacenters)]
        elif 'cpu' == section and 'server' in ds_options['categories']:
            results = []

            for item in ds_options['categories']['server']['items']:
                results.append((
                    item['description'],
                    item['price_id']
                ))

            return_value = results
        elif 'memory' == section and 'ram' in ds_options['categories']:
            ram = []
            for option in ds_options['categories']['ram']['items']:
                ram.append((int(option['capacity']), option['price_id']))

            return_value = [('memory', ram)]
        elif 'server_core' == section and \
             'server_core' in ds_options['categories']:
            mem_options = {}
            cpu_regex = re.compile(r'(\d+) x ')
            memory_regex = re.compile(r' - (\d+) GB Ram', re.I)

            for item in ds_options['categories']['server_core']['items']:
                cpu = cpu_regex.search(item['description']).group(1)
                memory = memory_regex.search(item['description']).group(1)

                if cpu and memory:
                    if memory not in mem_options:
                        mem_options[memory] = []

                    mem_options[memory].append((cpu, item['price_id']))

            results = []
            for memory in sorted(mem_options.keys(), key=int):
                key = memory

                if pretty:
                    key = memory

                results.append((key, mem_options[memory]))

            return_value = results
        elif 'os' == section:
            os_regex = re.compile(r'(^[A-Za-z\s\/\-]+) ([\d\.]+)')
            bit_regex = re.compile(r' \((\d+)\s*bit')
            extra_regex = re.compile(r' - (.+)\(')

            os_list = {}
            flat_list = []

            # Loop through the operating systems and get their OS codes
            for opsys in ds_options['categories']['os']['items']:
                if 'Windows Server' in opsys['description']:
                    os_code = self._generate_windows_code(opsys['description'])
                else:
                    os_results = os_regex.search(opsys['description'])

                    # Skip this operating system if it's not parsable
                    if os_results is None:
                        continue

                    name = os_results.group(1)
                    version = os_results.group(2)
                    bits = bit_regex.search(opsys['description'])
                    extra_info = extra_regex.search(opsys['description'])

                    if bits:
                        bits = bits.group(1)
                    if extra_info:
                        extra_info = extra_info.group(1)

                    os_code = self._generate_os_code(name, version, bits,
                                                     extra_info)

                name = os_code.split('_')[0]

                if name not in os_list:
                    os_list[name] = []

                os_list[name].append((os_code, opsys['price_id']))
                flat_list.append((os_code, opsys['price_id']))

            if pretty:
                results = []
                for opsys in sorted(os_list.keys()):
                    results.append(('os (%s)' % opsys, os_list[opsys]))

                return_value = results
            else:
                return_value = [('os', flat_list)]

        elif 'disk' == section:
            disks = []
            type_regex = re.compile(r'^[\d\.]+[GT]B\s+(.+)$')
            for disk in ds_options['categories']['disk0']['items']:
                disk_type = 'SATA'
                disk_type = type_regex.match(disk['description']).group(1)

                disk_type = disk_type.replace('RPM', '').strip()
                disk_type = disk_type.replace(' ', '_').upper()
                disk_type = str(int(disk['capacity'])) + '_' + disk_type
                disks.append((disk_type, disk['price_id'], disk['id']))

            return_value = [('disk', disks)]
        elif 'nic' == section:
            single = []
            dual = []

            for item in ds_options['categories']['port_speed']['items']:
                if 'dual' in item['description'].lower():
                    dual.append((str(int(item['capacity'])) + '_DUAL',
                                 item['price_id']))
                else:
                    single.append((str(int(item['capacity'])),
                                   item['price_id']))

            return_value = [('single nic', single), ('dual nic', dual)]
        elif 'disk_controller' == section:
            options = []
            for item in ds_options['categories']['disk_controller']['items']:
                text = item['description'].replace(' ', '')

                if 'Non-RAID' == text:
                    text = 'None'

                options.append((text, item['price_id']))

            return_value = [('disk_controllers', options)]

        return return_value

    def _generate_os_code(self, name, version, bits, extra_info):
        """ Encapsulates the code for generating the operating system code. """
        name = name.replace(' Linux', '')
        name = name.replace('Enterprise', '')
        name = name.replace('GNU/Linux', '')

        os_code = name.strip().replace(' ', '_').upper()

        if os_code.startswith('RED_HAT'):
            os_code = 'REDHAT'

        if 'UBUNTU' in os_code:
            version = re.sub(r'\.\d+', '', version)

        os_code += '_' + version.replace('.0', '')

        if bits:
            os_code += '_' + bits

        if extra_info:
            garbage = ['Install', '(32 bit)', '(64 bit)']

            for obj in garbage:
                extra_info = extra_info.replace(obj, '')

            os_code += '_' + extra_info.strip().replace(' ', '_').upper()

        return os_code

    def _generate_windows_code(self, description):
        """ Separates the code for generating the Windows OS code
        since it's significantly different from the rest.
        """
        version_check = re.search(r'Windows Server (\d+)', description)
        version = version_check.group(1)

        os_code = 'WIN_' + version

        if 'Datacenter' in description:
            os_code += '-DC'
        elif 'Enterprise' in description:
            os_code += '-ENT'
        else:
            os_code += '-STD'

        if 'ith R2' in description:
            os_code += '-R2'
        elif 'ith Hyper-V' in description:
            os_code += '-HYPERV'

        bit_check = re.search(r'\((\d+)\s*bit', description)
        if bit_check:
            os_code += '_' + bit_check.group(1)

        return os_code


class CreateServer(CLIRunnable):
    """
usage: sl server create [--disk=SIZE...] [--key=KEY...] [options]

Order/create a dedicated server. See 'sl server list-chassis' and
'sl server create-options' for valid options.

Required:
  -H --hostname=HOST  Host portion of the FQDN. example: server
  -D --domain=DOMAIN  Domain portion of the FQDN. example: example.com
  --chassis=CHASSIS   The chassis to use for the new server
  -c --cpu=CPU        CPU model
  -o OS, --os=OS      OS install code.
  -m --memory=MEMORY  Memory in gigabytes. example: 4
  --billing=BILLING   Billing rate. Options are "monthly" (default) or
                        "hourly". The hourly rate is only available on the
                        "Bare Metal Instance" chassis.

Optional:
  -d, --datacenter=DC    Datacenter name
                           Note: Omitting this value defaults to the first
                           available datacenter
  -n, --network=MBPS     Network port speed in Mbps
  --disk=SIZE...         Disks. Can be specified multiple times
  --controller=RAID      The RAID configuration for the server.
                           Defaults to None.
  -i, --postinstall=URI  Post-install script to download
  -k KEY, --key=KEY      SSH keys to assign to the root user. Can be specified
                           multiple times.
  --test                 Do not create the server, just get a quote
  --vlan_public=VLAN     The ID of the public VLAN on which you want the
                           hardware placed
  --vlan_private=VLAN    The ID of the private VLAN on which you want the
                           hardware placed
  -t, --template=FILE    A template file that defaults the command-line
                           options using the long name in INI format
  --export=FILE          Exports options to a template file
"""
    action = 'create'
    options = ['confirm']
    required_params = ['--hostname', '--domain', '--chassis', '--cpu',
                       '--memory', '--os']

    def execute(self, args):
        update_with_template_args(args, list_args=['--disk', '--key'])
        mgr = HardwareManager(self.client)
        self._validate_args(args)

        ds_options = mgr.get_dedicated_server_create_options(args['--chassis'])

        order = self._process_args(args, ds_options)

        # Do not create hardware server with --test or --export
        do_create = not (args['--export'] or args['--test'])

        output = None
        if args.get('--test'):
            result = mgr.verify_order(**order)

            table = Table(['Item', 'cost'])
            table.align['Item'] = 'r'
            table.align['cost'] = 'r'

            total = 0.0
            for price in result['prices']:
                total += float(price.get('recurringFee', 0.0))
                rate = "%.2f" % float(price['recurringFee'])

                table.add_row([price['item']['description'], rate])

            table.add_row(['Total monthly cost', "%.2f" % total])
            output = []
            output.append(table)
            output.append(FormattedItem(
                '',
                ' -- ! Prices reflected here are retail and do not '
                'take account level discounts and are not guaranteed.'))

        if args['--export']:
            export_file = args.pop('--export')
            export_to_template(export_file, args, exclude=['--wait', '--test'])
            return 'Successfully exported options to a template file.'

        if do_create:
            if args['--really'] or confirm(
                    "This action will incur charges on your account. "
                    "Continue?"):
                result = mgr.place_order(**order)

                table = KeyValueTable(['name', 'value'])
                table.align['name'] = 'r'
                table.align['value'] = 'l'
                table.add_row(['id', result['orderId']])
                table.add_row(['created', result['orderDate']])
                output = table
            else:
                raise CLIAbort('Aborting dedicated server order.')

        return output

    def _process_args(self, args, ds_options):
        """
        Helper method to centralize argument processing without convoluting
        code flow of the main execute method.
        """
        mgr = HardwareManager(self.client)

        order = {
            'hostname': args['--hostname'],
            'domain': args['--domain'],
            'bare_metal': False,
            'package_id': args['--chassis'],
        }

        # Determine if this is a "Bare Metal Instance" or regular server
        bmc = False
        if args['--chassis'] == str(mgr.get_bare_metal_package_id()):
            bmc = True

        # Convert the OS code back into a price ID
        os_price = self._get_price_id_from_options(ds_options, 'os',
                                                   args['--os'])

        if os_price:
            order['os'] = os_price
        else:
            raise CLIAbort('Invalid operating system specified.')

        order['location'] = args['--datacenter'] or 'FIRST_AVAILABLE'

        if bmc:
            order['server'] = self._get_cpu_and_memory_price_ids(
                ds_options, args['--cpu'], args['--memory'])
            order['bare_metal'] = True

            if args['--billing'] == 'hourly':
                order['hourly'] = True
        else:
            order['server'] = args['--cpu']
            order['ram'] = self._get_price_id_from_options(
                ds_options, 'memory', int(args['--memory']))

        # Set the disk sizes
        disk_prices = []
        disk_number = 0
        for disk in args.get('--disk'):
            disk_price = self._get_disk_price(ds_options, disk, disk_number)
            disk_number += 1
            if disk_price:
                disk_prices.append(disk_price)

        if not disk_prices:
            disk_prices.append(self._get_default_value(ds_options, 'disk0'))

        order['disks'] = disk_prices

        # Set the disk controller price
        if not bmc:
            if args.get('--controller'):
                dc_price = self._get_price_id_from_options(
                    ds_options, 'disk_controller', args.get('--controller'))
            else:
                dc_price = self._get_price_id_from_options(ds_options,
                                                           'disk_controller',
                                                           'None')

            order['disk_controller'] = dc_price

        # Set the port speed
        port_speed = args.get('--network') or '100'

        nic_price = self._get_price_id_from_options(ds_options, 'nic',
                                                    port_speed)

        if nic_price:
            order['port_speed'] = nic_price
        else:
            raise CLIAbort('Invalid NIC speed specified.')

        if args.get('--postinstall'):
            order['post_uri'] = args.get('--postinstall')

        # Get the SSH keys
        if args.get('--key'):
            keys = []
            for key in args.get('--key'):
                key_id = resolve_id(SshKeyManager(self.client).resolve_ids,
                                    key, 'SshKey')
                keys.append(key_id)
            order['ssh_keys'] = keys

        if args.get('--vlan_public'):
            order['public_vlan'] = args['--vlan_public']

        if args.get('--vlan_private'):
            order['private_vlan'] = args['--vlan_private']

        return order

    def _validate_args(self, args):
        """ Raises an ArgumentError if the given arguments are not valid """
        invalid_args = [k for k in self.required_params if args.get(k) is None]
        if invalid_args:
            raise ArgumentError('Missing required options: %s'
                                % ','.join(invalid_args))

    def _get_default_value(self, ds_options, option):
        """ Returns a 'free' price id given an option """
        if option not in ds_options['categories']:
            return

        for item in ds_options['categories'][option]['items']:
            if not any([
                    float(item.get('setupFee', 0)),
                    float(item.get('recurringFee', 0)),
                    float(item.get('hourlyRecurringFee', 0)),
                    float(item.get('oneTimeFee', 0)),
                    float(item.get('laborFee', 0)),
            ]):
                return item['price_id']

    def _get_disk_price(self, ds_options, value, number):
        """ Returns a price id that matches a given disk config """
        if not number:
            return self._get_price_id_from_options(ds_options, 'disk', value)
        # This will get the item ID for the matching identifier string, which
        # we can then use to get the price ID for our specific disk
        item_id = self._get_price_id_from_options(ds_options, 'disk',
                                                  value, True)
        key = 'disk' + str(number)
        if key in ds_options['categories']:
            for item in ds_options['categories'][key]['items']:
                if item['id'] == item_id:
                    return item['price_id']

    def _get_cpu_and_memory_price_ids(self, ds_options, cpu_value,
                                      memory_value):
        """
        Returns a price id for a cpu/memory pair in pre-configured servers
        (formerly known as BMC).
        """
        ds_obj = ServerCreateOptions()
        for memory, options in ds_obj.get_create_options(ds_options,
                                                         'server_core',
                                                         False):
            if memory == memory_value:
                for cpu_size, price_id in options:
                    if cpu_size == cpu_value:
                        return price_id

    def _get_price_id_from_options(self, ds_options, option, value,
                                   item_id=False):
        """ Returns a price_id for a given option and value """
        ds_obj = ServerCreateOptions()

        for _, options in ds_obj.get_create_options(ds_options, option, False):
            for item_options in options:
                if item_options[0] == value:
                    if not item_id:
                        return item_options[1]
                    return item_options[2]


class EditServer(CLIRunnable):
    """
usage: sl server edit <identifier> [options]

Edit hardware details

Options:
  -D --domain=DOMAIN  Domain portion of the FQDN example: example.com
  -F --userfile=FILE  Read userdata from file
  -H --hostname=HOST  Host portion of the FQDN. example: server
  -u --userdata=DATA  User defined metadata string
"""
    action = 'edit'

    def execute(self, args):
        data = {}

        if args['--userdata'] and args['--userfile']:
            raise ArgumentError('[-u | --userdata] not allowed with '
                                '[-F | --userfile]')
        if args['--userfile']:
            if not os.path.exists(args['--userfile']):
                raise ArgumentError(
                    'File does not exist [-u | --userfile] = %s'
                    % args['--userfile'])

        if args.get('--userdata'):
            data['userdata'] = args['--userdata']
        elif args.get('--userfile'):
            with open(args['--userfile'], 'r') as userfile:
                data['userdata'] = userfile.read()

        data['hostname'] = args.get('--hostname')
        data['domain'] = args.get('--domain')

        mgr = HardwareManager(self.client)
        hw_id = resolve_id(mgr.resolve_ids, args.get('<identifier>'),
                           'hardware')
        if not mgr.edit(hw_id, **data):
            raise CLIAbort("Failed to update hardware")

########NEW FILE########
__FILENAME__ = snapshot
"""
usage: sl snapshot [<command>] [<args>...] [options]

Manage, order, delete iSCSI snapshots

The available commands are:
  cancel          Cancel an iSCSI snapshot
  create          Create a snapshot of given iSCSI volume
  create-space    Orders space for storing snapshots
  list            List snpshots of given iSCSI
  restore-volume  Restores volume from existing snapshot

For several commands <identifier> will be asked for.This can be the id
of iSCSI volume or iSCSI snapshot.
"""
from SoftLayer.CLI import (CLIRunnable, Table)
from SoftLayer.CLI.helpers import (
    ArgumentError, NestedDict,
    resolve_id)
from SoftLayer import ISCSIManager


class CreateSnapshot(CLIRunnable):

    """
usage: sl snapshot create <identifier> [options]

Create a snapshot of the iSCSI volume.

Examples:
    sl snapshot create 123456 --note='Backup'
    sl snapshot create 123456

Options:
  --notes=NOTE    An optional snapshot's note

"""
    action = 'create'

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        iscsi_id = resolve_id(
            iscsi_mgr.resolve_ids,
            args.get('<identifier>'),
            'iSCSI')
        notes = args.get('--notes')
        iscsi_mgr.create_snapshot(iscsi_id, notes)


class CreateSnapshotSpace(CLIRunnable):

    """
usage: sl snapshot create-space <identifier> [options]

Orders snapshot space for given iSCSI.

Examples:
    sl snapshot create-space 123456 --capacity=20

Required :
  --capacity=CAPACITY Size of snapshot space to create
"""

    action = 'create-space'
    required_params = ['--capacity']

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        invalid_args = [k for k in self.required_params if args.get(k) is None]
        if invalid_args:
            raise ArgumentError('Missing required options: %s'
                                % ','.join(invalid_args))
        iscsi_id = resolve_id(
            iscsi_mgr.resolve_ids,
            args.get('<identifier>'),
            'iSCSI')
        capacity = args.get('--capacity')
        iscsi_mgr.create_snapshot_space(iscsi_id, capacity)


class CancelSnapshot(CLIRunnable):

    """
usage: sl snapshot cancel <identifier> [options]

Cancel/Delete iSCSI snapshot.

"""
    action = 'cancel'

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        snapshot_id = resolve_id(
            iscsi_mgr.resolve_ids,
            args.get('<identifier>'),
            'Snapshot')
        iscsi_mgr.delete_snapshot(snapshot_id)


class RestoreVolumeFromSnapshot(CLIRunnable):

    """
usage: sl snapshot restore-volume <volume_identifier> <snapshot_identifier>

restores volume from existing snapshot.

"""
    action = 'restore-volume'

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        volume_id = resolve_id(
            iscsi_mgr.resolve_ids, args.get('<volume_identifier>'), 'iSCSI')
        snapshot_id = resolve_id(
            iscsi_mgr.resolve_ids,
            args.get('<snapshot_identifier>'),
            'Snapshot')
        iscsi_mgr.restore_from_snapshot(volume_id, snapshot_id)


class ListSnapshots(CLIRunnable):

    """
usage: sl snapshot list <identifier>

List iSCSI Snapshots
"""
    action = 'list'

    def execute(self, args):
        iscsi_mgr = ISCSIManager(self.client)
        iscsi_id = resolve_id(
            iscsi_mgr.resolve_ids, args.get('<identifier>'), 'iSCSI')
        iscsi = self.client['Network_Storage_Iscsi']
        snapshots = iscsi.getPartnerships(
            mask='volumeId,partnerVolumeId,createDate,type', id=iscsi_id)
        snapshots = [NestedDict(n) for n in snapshots]

        table = Table([
            'id',
            'createDate',
            'name',
            'description',
        ])

        for snapshot in snapshots:
            table.add_row([
                snapshot['partnerVolumeId'],
                snapshot['createDate'],
                snapshot['type']['name'],
                snapshot['type']['description'],
                ])
        return table

########NEW FILE########
__FILENAME__ = sshkey
"""
usage: sl sshkey [<command>] [<args>...] [options]

Manage SSH keys

The available commands are:
  add     Add a new SSH key to your account
  remove  Removes an SSH key
  edit    Edits information about the SSH key
  list    Display a list of SSH keys on your account
  print   Prints out an SSH key
"""
# :license: MIT, see LICENSE for more details.

from os.path import expanduser

from SoftLayer import SshKeyManager
from SoftLayer.CLI import CLIRunnable, Table, no_going_back
from SoftLayer.CLI.helpers import CLIAbort, resolve_id, KeyValueTable


class AddSshKey(CLIRunnable):
    """
usage: sl sshkey add <label> (--file=FILE | --key=KEY ) [options]

Add a new SSH key to your account

Required:
  <label>                  The label for your SSH key. will appear in various
                             interfaces to help you easily identify this key.
                             You can enclose multiple words in quotation marks
                             "like this" if desired
  -f FILE, --file=FILE     The id_rsa.pub file to import for this key. Mutually
                             exclusive with --key
  -k KEY, --key=KEY        The actual SSH key. Mutually exclusive with --file.
                             Should be enclosed within quotation marks

Optional:
  -n NOTES, --notes=NOTES  Any notes you want to add to the SSH key
"""
    action = 'add'

    def execute(self, args):
        if args.get('--key'):
            key = args['--key']
        else:
            key_file = open(expanduser(args['--file']), 'rU')
            key = key_file.read().strip()
            key_file.close()

        mgr = SshKeyManager(self.client)
        result = mgr.add_key(key, args['<label>'], args.get('--notes'))

        return "SSH key added: %s" % result.get('fingerprint')


class RemoveSshKey(CLIRunnable):
    """
usage: sl sshkey remove <identifier> [options]

Permanently removes an SSH key from your account

Required:
  <identifier>   The ID or label for the SSH key to be removed

"""

    action = 'remove'
    options = ['confirm']

    def execute(self, args):
        mgr = SshKeyManager(self.client)

        key_id = resolve_id(mgr.resolve_ids,
                            args.get('<identifier>'), 'SshKey')
        if args['--really'] or no_going_back(key_id):
            mgr.delete_key(key_id)
        else:
            raise CLIAbort('Aborted')


class EditSshKey(CLIRunnable):
    """
usage: sl sshkey edit <identifier> [options]

Options:
  -l, --label=LABEL The new label for the key
  -n, --notes=NOTES New notes for the key
"""

    action = 'edit'

    def execute(self, args):
        mgr = SshKeyManager(self.client)

        key_id = resolve_id(mgr.resolve_ids,
                            args.get('<identifier>'), 'SshKey')

        if not mgr.edit_key(key_id,
                            label=args['--label'],
                            notes=args['--notes']):
            raise CLIAbort('Failed to edit SSH key')


class ListSshKey(CLIRunnable):
    """
usage: sl sshkey list [options]

Display a list of SSH keys on your account

Options:
  --sortby=ARG  Column to sort by. options: label, fingerprint, notes
"""
    action = 'list'

    def execute(self, args):
        mgr = SshKeyManager(self.client)
        keys = mgr.list_keys()

        table = Table(['id', 'label', 'fingerprint', 'notes'])

        for key in keys:
            table.add_row([key['id'],
                           key.get('label'),
                           key.get('fingerprint'),
                           key.get('notes', '-')])

        return table


class PrintSshKey(CLIRunnable):
    """
usage: sl sshkey print <identifier> [--file=FILE]

Prints out an SSH key to the screen

Options:
  -f FILE, --file=FILE  If specified, the public SSH key will be written to
                          this file
"""
    action = 'print'

    def execute(self, args):
        mgr = SshKeyManager(self.client)

        key_id = resolve_id(mgr.resolve_ids,
                            args.get('<identifier>'), 'SshKey')

        key = mgr.get_key(key_id)

        if args.get('--file'):
            with open(expanduser(args['--file']), 'w') as pub_file:
                pub_file.write(key['key'])

        table = KeyValueTable(['Name', 'Value'])
        table.add_row(['id', key['id']])
        table.add_row(['label', key.get('label')])
        table.add_row(['notes', key.get('notes', '-')])
        return table

########NEW FILE########
__FILENAME__ = ssl
"""
usage: sl ssl [<command>] [<args>...] [options]
       sl ssl [-h | --help]

Manage SSL

The available commands are:
  add       Add ssl certificate
  download  Download certificate & key file
  edit      Edit ssl certificate
  list      List ssl certificates
  remove    Remove ssl certificate
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer.CLI.helpers import CLIRunnable, no_going_back, Table, CLIAbort
from SoftLayer.CLI.helpers import blank
from SoftLayer import SSLManager


class ListCerts(CLIRunnable):
    """
usage: sl ssl list [options]

List SSL certificates on the acount

Options:
  --status=STATUS  Show certificates with this status. [Default: all]
                     [Options: valid, expired, all]
  --sortby=SORTBY  Sort by this value. [Default: id]
                     [Options: id, common_name, days_until_expire, notes]
"""
    action = 'list'

    def execute(self, args):
        manager = SSLManager(self.client)

        certificates = manager.list_certs(args['--status'])

        table = Table(['id', 'common_name', 'days_until_expire', 'notes'])
        for certificate in certificates:
            table.add_row([
                certificate['id'],
                certificate['commonName'],
                certificate['validityDays'],
                certificate.get('notes', blank())
            ])
        table.sortby = args['--sortby']
        return table


class AddCertificate(CLIRunnable):
    """
usage: sl ssl add --crt=FILE --key=FILE [options]

Add and upload SSL certificate details

Options:
  --crt=FILE     Certificate file
  --csr=FILE     Certificate Signing Request file
  --icc=FILE     Intermediate Certificate file
  --key=FILE     Private Key file
  --notes=NOTES  Additional notes
"""
    action = 'add'

    def execute(self, args):
        template = {
            'intermediateCertificate': '',
            'certificateSigningRequest': '',
            'notes': args['--notes'],
        }
        try:
            template['certificate'] = open(args['--crt']).read()
            template['privateKey'] = open(args['--key']).read()
            if args['--csr']:
                template['certificateSigningRequest'] = \
                    open(args['--csr']).read()

            if args['--icc']:
                template['intermediateCertificate'] = \
                    open(args['--icc']).read()

        except IOError:
            raise CLIAbort("File does not exist")

        manager = SSLManager(self.client)
        manager.add_certificate(template)


class EditCertificate(CLIRunnable):
    """
usage: sl ssl edit <id> [options]

Edit SSL certificate

Options:
  --crt=FILE     Certificate file
  --csr=FILE     Certificate Signing Request file
  --icc=FILE     Intermediate Certificate file
  --key=FILE     Private Key file
  --notes=NOTES  Additional notes
"""
    action = 'edit'

    def execute(self, args):
        template = {'id': args['<id>']}
        if args['--crt']:
            template['certificate'] = open(args['--crt']).read()
        if args['--key']:
            template['privateKey'] = open(args['--key']).read()
        if args['--csr']:
            template['certificateSigningRequest'] = open(args['--csr']).read()
        if args['--icc']:
            template['intermediateCertificate'] = open(args['--icc']).read()
        if args['--notes']:
            template['notes'] = args['--notes']

        manager = SSLManager(self.client)
        manager.edit_certificate(template)


class RemoveCertificate(CLIRunnable):
    """
usage: sl ssl remove <id> [options]

Remove SSL certificate
"""
    action = 'remove'
    options = ['confirm']

    def execute(self, args):
        manager = SSLManager(self.client)
        if args['--really'] or no_going_back('yes'):
            manager.remove_certificate(args['<id>'])
        raise CLIAbort("Aborted.")


class DownloadCertificate(CLIRunnable):
    """
usage: sl ssl download <id> [options]

Download SSL certificate and key file
"""
    action = 'download'

    def execute(self, args):
        def write_cert(filename, content):
            """ Writes certificate body to the given file path """
            with open(filename, 'w') as cert_file:
                cert_file.write(content)

        manager = SSLManager(self.client)
        certificate = manager.get_certificate(args['<id>'])

        write_cert(
            certificate['commonName'] + '.crt', certificate['certificate'])
        write_cert(
            certificate['commonName'] + '.key', certificate['privateKey'])
        if 'intermediateCertificate' in certificate:
            write_cert(
                certificate['commonName'] + '.icc',
                certificate['intermediateCertificate'])
        if 'certificateSigningRequest' in certificate:
            write_cert(
                certificate['commonName'] + '.csr',
                certificate['certificateSigningRequest'])

########NEW FILE########
__FILENAME__ = subnet
"""
usage: sl subnet [<command>] [<args>...] [options]

Manages subnets on your account.

The available commands are:
  cancel  Cancel a subnet
  create  Create a new subnet
  detail  Display detailed information about a subnet
  list    Show a list of all subnets on the network
  lookup  Find an IP address and display its subnet and device info
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import NetworkManager
from SoftLayer.utils import lookup
from SoftLayer.CLI import (
    CLIRunnable, Table, KeyValueTable, confirm, no_going_back, resolve_id)
from SoftLayer.CLI.helpers import CLIAbort, blank


class SubnetCancel(CLIRunnable):
    """
usage: sl subnet cancel <identifier> [options]

Cancel a subnet
"""

    action = 'cancel'
    options = ['confirm']

    def execute(self, args):
        mgr = NetworkManager(self.client)
        subnet_id = resolve_id(mgr.resolve_subnet_ids,
                               args.get('<identifier>'),
                               name='subnet')

        if args['--really'] or no_going_back(subnet_id):
            mgr.cancel_subnet(subnet_id)
        else:
            CLIAbort('Aborted')


class SubnetCreate(CLIRunnable):
    """
usage:
  sl subnet create (public|private) <quantity> <vlan> [options]

Add a new subnet to your account

Required:
  <quantity>           The number of IPs to include in the subnet.
                         Valid quantities vary by type.

                         Type    - Valid Quantities (IPv4)
                         public  - 4, 8, 16, 32
                         private - 4, 8, 16, 32, 64

                         Type    - Valid Quantities (IPv6)
                         public  - 64
  <vlan>               The VLAN ID you want to attach this subnet to

Options:
  --v6                 Orders IPv6
  --test               Do not order the subnet; just get a quote
"""
    action = 'create'
    options = ['confirm']

    def execute(self, args):
        mgr = NetworkManager(self.client)

        _type = 'private'
        if args['public']:
            _type = 'public'

        version = 4
        if args.get('--v6'):
            version = 6
        if not args.get('--test') and not args['--really']:
            if not confirm("This action will incur charges on your account."
                           "Continue?"):
                raise CLIAbort('Cancelling order.')
        result = mgr.add_subnet(_type,
                                quantity=args['<quantity>'],
                                vlan_id=args['<vlan>'],
                                version=version,
                                test_order=args.get('--test'))
        if not result:
            return 'Unable to place order: No valid price IDs found.'
        table = Table(['Item', 'cost'])
        table.align['Item'] = 'r'
        table.align['cost'] = 'r'

        total = 0.0
        if 'prices' in result:
            for price in result['prices']:
                total += float(price.get('recurringFee', 0.0))
                rate = "%.2f" % float(price['recurringFee'])

                table.add_row([price['item']['description'], rate])

        table.add_row(['Total monthly cost', "%.2f" % total])
        return table


class SubnetDetail(CLIRunnable):
    """
usage: sl subnet detail <identifier> [options]

Get detailed information about objects assigned to a particular subnet

Filters:
  --no-vs, --no-cci  Hide virtual server listing
  --no-hardware      Hide hardware listing
"""
    action = 'detail'

    def execute(self, args):
        mgr = NetworkManager(self.client)
        subnet_id = resolve_id(mgr.resolve_subnet_ids,
                               args.get('<identifier>'),
                               name='subnet')
        subnet = mgr.get_subnet(subnet_id)

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        table.add_row(['id', subnet['id']])
        table.add_row(['identifier',
                       '%s/%s' % (subnet['networkIdentifier'],
                                  str(subnet['cidr']))])
        table.add_row(['subnet type', subnet['subnetType']])
        table.add_row(['gateway', subnet.get('gateway', blank())])
        table.add_row(['broadcast', subnet.get('broadcastAddress', blank())])
        table.add_row(['datacenter', subnet['datacenter']['name']])
        table.add_row(['usable ips',
                       subnet.get('usableIpAddressCount', blank())])

        if not args.get('--no-vs'):
            if subnet['virtualGuests']:
                vs_table = Table(['Hostname', 'Domain', 'IP'])
                vs_table.align['Hostname'] = 'r'
                vs_table.align['IP'] = 'l'
                for vsi in subnet['virtualGuests']:
                    vs_table.add_row([vsi['hostname'],
                                      vsi['domain'],
                                      vsi.get('primaryIpAddress')])
                table.add_row(['vs', vs_table])
            else:
                table.add_row(['vs', 'none'])

        if not args.get('--no-hardware'):
            if subnet['hardware']:
                hw_table = Table(['Hostname', 'Domain', 'IP'])
                hw_table.align['Hostname'] = 'r'
                hw_table.align['IP'] = 'l'
                for hardware in subnet['hardware']:
                    hw_table.add_row([hardware['hostname'],
                                      hardware['domain'],
                                      hardware.get('primaryIpAddress')])
                table.add_row(['hardware', hw_table])
            else:
                table.add_row(['hardware', 'none'])

        return table


class SubnetList(CLIRunnable):
    """
usage: sl subnet list [options]

Displays a list of subnets

Options:
  --sortby=ARG  Column to sort by. options: id, identifier, type, datacenter,
    vlan id, IPs, hardware, vs

Filters:
  -d DC, --datacenter=DC   datacenter shortname (sng01, dal05, ...)
  --identifier=ID          Filter by identifier
  -t TYPE, --type=TYPE     Filter by subnet type
  --v4                     Display only IPV4 subnets
  --v6                     Display only IPV6 subnets
"""
    action = 'list'

    def execute(self, args):
        mgr = NetworkManager(self.client)

        table = Table([
            'id', 'identifier', 'type', 'datacenter', 'vlan id', 'IPs',
            'hardware', 'vs',
        ])
        table.sortby = args.get('--sortby') or 'id'

        version = 0
        if args.get('--v4'):
            version = 4
        elif args.get('--v6'):
            version = 6

        subnets = mgr.list_subnets(
            datacenter=args.get('--datacenter'),
            version=version,
            identifier=args.get('--identifier'),
            subnet_type=args.get('--type'),
        )

        for subnet in subnets:
            table.add_row([
                subnet['id'],
                '%s/%s' % (subnet['networkIdentifier'], str(subnet['cidr'])),
                subnet.get('subnetType', blank()),
                lookup(subnet, 'datacenter', 'name',) or blank(),
                subnet['networkVlanId'],
                subnet['ipAddressCount'],
                len(subnet['hardware']),
                len(subnet['virtualGuests']),
            ])

        return table


class SubnetLookup(CLIRunnable):
    """
usage: sl subnet lookup <ip> [options]

Finds an IP address on the network and displays its subnet and device
information.

"""
    action = 'lookup'

    def execute(self, args):
        mgr = NetworkManager(self.client)

        addr_info = mgr.ip_lookup(args['<ip>'])

        if not addr_info:
            return 'Not found'

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        table.add_row(['id', addr_info['id']])
        table.add_row(['ip', addr_info['ipAddress']])

        subnet_table = KeyValueTable(['Name', 'Value'])
        subnet_table.align['Name'] = 'r'
        subnet_table.align['Value'] = 'l'
        subnet_table.add_row(['id', addr_info['subnet']['id']])
        subnet_table.add_row(['identifier',
                              '%s/%s'
                              % (addr_info['subnet']['networkIdentifier'],
                                 str(addr_info['subnet']['cidr']))])
        subnet_table.add_row(['netmask', addr_info['subnet']['netmask']])
        if addr_info['subnet'].get('gateway'):
            subnet_table.add_row(['gateway', addr_info['subnet']['gateway']])
        subnet_table.add_row(['type', addr_info['subnet'].get('subnetType')])

        table.add_row(['subnet', subnet_table])

        if addr_info.get('virtualGuest') or addr_info.get('hardware'):
            device_table = KeyValueTable(['Name', 'Value'])
            device_table.align['Name'] = 'r'
            device_table.align['Value'] = 'l'
            if addr_info.get('virtualGuest'):
                device = addr_info['virtualGuest']
                device_type = 'vs'
            else:
                device = addr_info['hardware']
                device_type = 'server'
            device_table.add_row(['id', device['id']])
            device_table.add_row(['name', device['fullyQualifiedDomainName']])
            device_table.add_row(['type', device_type])
            table.add_row(['device', device_table])
        return table

########NEW FILE########
__FILENAME__ = summary
"""
usage: sl summary [options]

Display summary information about the account
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import NetworkManager
from SoftLayer.CLI import CLIRunnable, Table


class Summary(CLIRunnable):
    """
usage: sl summary [options]

Display summary information about the account

Options:
  --sortby=ARG  Column to sort by. options: datacenter, vlans,
                subnets, IPs, networking, hardware, vs
"""
    action = None

    def execute(self, args):
        mgr = NetworkManager(self.client)
        datacenters = mgr.summary_by_datacenter()

        table = Table([
            'datacenter', 'vlans', 'subnets', 'IPs', 'networking',
            'hardware', 'vs'
        ])
        table.sortby = args.get('--sortby') or 'datacenter'

        for name, datacenter in datacenters.items():
            table.add_row([
                name,
                datacenter['vlanCount'],
                datacenter['subnetCount'],
                datacenter['primaryIpCount'],
                datacenter['networkingCount'],
                datacenter['hardwareCount'],
                datacenter['virtualGuestCount'],
            ])

        return table

########NEW FILE########
__FILENAME__ = ticket
"""
usage: sl ticket [<command>] [<args>...] [options]

Manages account tickets

The available commands are:
  create      Create a new ticket
  detail      Output details about an ticket
  list        List tickets
  update      Update an existing ticket
  subjects    List the subject IDs that can be used for ticket creation
  summary     Give summary info about tickets
"""
# :license: MIT, see LICENSE for more details.

import textwrap
import tempfile
import os
from subprocess import call

from SoftLayer import TicketManager
from SoftLayer.CLI import (CLIRunnable, Table, resolve_id, NestedDict,
                           KeyValueTable)

TEMPLATE_MSG = "***** SoftLayer Ticket Content ******"


def wrap_string(input_str):
    """ Utility method to wrap the a potentially long string to 80 chars """
    return textwrap.wrap(input_str, 80)


def get_ticket_results(mgr, ticket_id, update_count=1):
    """ Get output about a ticket

    :param integer id: the ticket ID
    :param integer update_count: number of entries to retrieve from ticket
    :returns: a KeyValue table containing the details of the ticket

    """
    result = mgr.get_ticket(ticket_id)
    result = NestedDict(result)

    table = KeyValueTable(['Name', 'Value'])
    table.align['Name'] = 'r'
    table.align['Value'] = 'l'

    table.add_row(['id', result['id']])
    table.add_row(['title', result['title']])
    if result['assignedUser']:
        table.add_row(['assignedUser',
                       "%s %s" % (result['assignedUser']['firstName'],
                                  result['assignedUser']['lastName'])])
    table.add_row(['createDate', result['createDate']])
    table.add_row(['lastEditDate', result['lastEditDate']])

    total_update_count = result['updateCount']
    count = min(total_update_count, update_count)
    for i, update in enumerate(result['updates'][:count]):
        update = wrap_string(update['entry'])
        table.add_row(['Update %s' % (i + 1,), update])

    return table


def open_editor(beg_msg, ending_msg=None):
    """

    :param beg_msg: generic msg to be appended at the end of the file
    :param ending_msg: placeholder msg to append at the end of the file,
            like filesystem info, etc, not being used now
    :returns: the content the user has entered

    """

    # Let's get the default EDITOR of the environment,
    # use nano if none is specified
    editor = os.environ.get('EDITOR', 'nano')

    with tempfile.NamedTemporaryFile(suffix=".tmp") as tfile:
        # populate the file with the baked messages
        tfile.write("\n")
        tfile.write(beg_msg)
        if ending_msg:
            tfile.write("\n")
            tfile.write(ending_msg)
        # flush the file and open it for editing
        tfile.flush()
        call([editor, tfile.name])
        tfile.seek(0)
        data = tfile.read()
        return data

    return


class ListTickets(CLIRunnable):
    """
usage: sl ticket list [options]

List tickets

Options:
  --closed  display closed tickets

"""
    action = 'list'

    def execute(self, args):
        ticket_mgr = TicketManager(self.client)

        tickets = ticket_mgr.list_tickets(
            open_status=not args.get('--closed'),
            closed_status=args.get('--closed'))

        table = Table(['id', 'assigned user', 'title',
                       'creation date', 'last edit date'])

        for ticket in tickets:
            if ticket['assignedUser']:
                table.add_row([
                    ticket['id'],
                    "%s %s" % (ticket['assignedUser']['firstName'],
                               ticket['assignedUser']['lastName']),
                    wrap_string(ticket['title']),
                    ticket['createDate'],
                    ticket['lastEditDate']
                ])
            else:
                table.add_row([
                    ticket['id'],
                    'N/A',
                    wrap_string(ticket['title']),
                    ticket['createDate'],
                    ticket['lastEditDate']
                ])

        return table


class ListSubjectsTickets(CLIRunnable):
    """
usage: sl ticket subjects [options]

List Subject IDs for ticket creation

"""
    action = 'subjects'

    def execute(self, args):
        ticket_mgr = TicketManager(self.client)

        table = Table(['id', 'subject'])
        for subject in ticket_mgr.list_subjects():
            table.add_row([
                subject['id'],
                subject['name']
            ])
        return table


class UpdateTicket(CLIRunnable):
    """
usage: sl ticket update <identifier> [options]

Updates a certain ticket

Options:
  --body=BODY  The entry that will be appended to the ticket

"""
    action = 'update'
    options = ['--body']

    def execute(self, args):
        mgr = TicketManager(self.client)

        ticket_id = resolve_id(
            mgr.resolve_ids, args.get('<identifier>'), 'ticket')

        body = args.get('--body')
        if body is None:
            body = open_editor(beg_msg=TEMPLATE_MSG)

        mgr.update_ticket(ticket_id=ticket_id, body=body)
        return "Ticket Updated!"


class TicketsSummary(CLIRunnable):
    """
usage: sl ticket summary [options]

Give summary info about tickets

"""
    action = 'summary'

    def execute(self, args):
        mask = ('mask[openTicketCount, closedTicketCount, '
                'openBillingTicketCount, openOtherTicketCount, '
                'openSalesTicketCount, openSupportTicketCount, '
                'openAccountingTicketCount]')
        account = self.client['Account'].getObject(mask=mask)
        table = Table(['Status', 'count'])

        nested = Table(['Type', 'count'])
        nested.add_row(['Accounting',
                        account['openAccountingTicketCount']])
        nested.add_row(['Billing', account['openBillingTicketCount']])
        nested.add_row(['Sales', account['openSalesTicketCount']])
        nested.add_row(['Support', account['openSupportTicketCount']])
        nested.add_row(['Other', account['openOtherTicketCount']])
        nested.add_row(['Total', account['openTicketCount']])
        table.add_row(['Open', nested])
        table.add_row(['Closed', account['closedTicketCount']])

        return table


class TicketDetails(CLIRunnable):
    """
usage: sl ticket detail  <identifier> [options]

Get details for a ticket

Options:
  --count=NUM  Show X count of updates [default: 10]
"""
    action = 'detail'

    def execute(self, args):
        mgr = TicketManager(self.client)

        ticket_id = resolve_id(
            mgr.resolve_ids, args.get('<identifier>'), 'ticket')

        count = args.get('--count')
        if count is None:
            count = 10
        return get_ticket_results(mgr, ticket_id, update_count=int(count))


class CreateTicket(CLIRunnable):
    """
usage: sl ticket create --title=TITLE --subject=ID [options]

Create a support ticket.

Required:
  --title=TITLE  The title of the ticket
  --subject=ID   The id of the subject to use for the ticket,
                 issue 'sl ticket subjects' to get the list

Optional:
  --body=BODY the body text to attach to the ticket,
              an editor will be opened if body is not provided
"""
    action = 'create'
    required_params = ['--title, --subject']

    def execute(self, args):
        mgr = TicketManager(self.client)
        if args.get('--title') is "":
            return 'Please provide a valid title'
        body = args.get('--body')
        if body is None:
            body = open_editor(beg_msg=TEMPLATE_MSG)

        created_ticket = mgr.create_ticket(
            title=args.get('--title'),
            body=body,
            subject=args.get('--subject'))
        return get_ticket_results(mgr, created_ticket['id'])

########NEW FILE########
__FILENAME__ = vlan
"""
usage: sl vlan [<command>] [<args>...] [options]

Display information about VLANs on the network

The available commands are:
  detail  Display detailed information about a VLAN
  list    Show a list of all VLANs on the network
"""
# :license: MIT, see LICENSE for more details.

from SoftLayer import NetworkManager
from SoftLayer.CLI import CLIRunnable, Table, KeyValueTable, blank, resolve_id


class VlanDetail(CLIRunnable):
    """
usage: sl vlan detail <identifier> [options]

Get detailed information about objects assigned to a particular VLAN

Filters:
  --no-vs, --no-cci  Hide virtual server listing
  --no-hardware      Hide hardware listing
"""
    action = 'detail'

    def execute(self, args):
        mgr = NetworkManager(self.client)

        vlan_id = resolve_id(mgr.resolve_vlan_ids,
                             args.get('<identifier>'),
                             'VLAN')
        vlan = mgr.get_vlan(vlan_id)

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        table.add_row(['id', vlan['id']])
        table.add_row(['number', vlan['vlanNumber']])
        table.add_row(['datacenter',
                       vlan['primaryRouter']['datacenter']['longName']])
        table.add_row(['primary router',
                       vlan['primaryRouter']['fullyQualifiedDomainName']])
        table.add_row(['firewall',
                       'Yes' if vlan['firewallInterfaces'] else 'No'])
        subnets = []
        for subnet in vlan['subnets']:
            subnet_table = KeyValueTable(['Name', 'Value'])
            subnet_table.align['Name'] = 'r'
            subnet_table.align['Value'] = 'l'
            subnet_table.add_row(['id', subnet['id']])
            subnet_table.add_row(['identifier', subnet['networkIdentifier']])
            subnet_table.add_row(['netmask', subnet['netmask']])
            subnet_table.add_row(['gateway', subnet.get('gateway', '-')])
            subnet_table.add_row(['type', subnet['subnetType']])
            subnet_table.add_row(['usable ips',
                                  subnet['usableIpAddressCount']])
            subnets.append(subnet_table)

        table.add_row(['subnets', subnets])

        if not args.get('--no-vs'):
            if vlan['virtualGuests']:
                vs_table = KeyValueTable(['Hostname', 'Domain', 'IP'])
                vs_table.align['Hostname'] = 'r'
                vs_table.align['IP'] = 'l'
                for vsi in vlan['virtualGuests']:
                    vs_table.add_row([vsi['hostname'],
                                      vsi['domain'],
                                      vsi.get('primaryIpAddress')])
                table.add_row(['vs', vs_table])
            else:
                table.add_row(['vs', 'none'])

        if not args.get('--no-hardware'):
            if vlan['hardware']:
                hw_table = Table(['Hostname', 'Domain', 'IP'])
                hw_table.align['Hostname'] = 'r'
                hw_table.align['IP'] = 'l'
                for hardware in vlan['hardware']:
                    hw_table.add_row([hardware['hostname'],
                                      hardware['domain'],
                                      hardware.get('primaryIpAddress')])
                table.add_row(['hardware', hw_table])
            else:
                table.add_row(['hardware', 'none'])

        return table


class VlanList(CLIRunnable):
    """
usage: sl vlan list [options]

Displays a list of VLANs

Options:
  --sortby=ARG  Column to sort by. options: id, number, datacenter, IPs,
    hardware, vs, networking

Filters:
  -d DC, --datacenter=DC  datacenter shortname (sng01, dal05, ...)
  -n NUM, --number=NUM    VLAN number
  --name=NAME             VLAN name
"""
    action = 'list'

    def execute(self, args):
        mgr = NetworkManager(self.client)

        table = Table([
            'id', 'number', 'datacenter', 'name', 'IPs', 'hardware', 'vs',
            'networking', 'firewall'
        ])
        table.sortby = args.get('--sortby') or 'id'

        vlans = mgr.list_vlans(
            datacenter=args.get('--datacenter'),
            vlan_number=args.get('--number'),
            name=args.get('--name'),
        )
        for vlan in vlans:
            table.add_row([
                vlan['id'],
                vlan['vlanNumber'],
                vlan['primaryRouter']['datacenter']['name'],
                vlan.get('name') or blank(),
                vlan['totalPrimaryIpAddressCount'],
                len(vlan['hardware']),
                len(vlan['virtualGuests']),
                len(vlan['networkComponents']),
                'Yes' if vlan['firewallInterfaces'] else 'No',
            ])

        return table

########NEW FILE########
__FILENAME__ = vs
"""
usage: sl vs [<command>] [<args>...] [options]

Manage, delete, order compute instances

The available commands are:
  cancel          Cancel a running virtual server
  capture         Create an image the disk(s) of a virtual server
  create          Order and create a virtual server
                    (see `sl vs create-options` for choices)
  create-options  Output available available options when creating a VS
  detail          Output details about a virtual server
  dns             DNS related actions to a virtual server
  edit            Edit details of a virtual server
  list            List virtual servers on the account
  nic-edit        Edit NIC settings
  pause           Pauses an active virtual server
  power-off       Powers off a running virtual server
  power-on        Boots up a virtual server
  ready           Check if a virtual server has finished provisioning
  reboot          Reboots a running virtual server
  reload          Reload the OS on a VS based on its current configuration
  resume          Resumes a paused virtual server
  upgrade         Upgrades parameters of a virtual server

For several commands, <identifier> will be asked for. This can be the id,
hostname or the ip address for a virtual server.
"""
# :license: MIT, see LICENSE for more details.

from os import linesep
import os.path

from SoftLayer import VSManager, SshKeyManager, DNSManager
from SoftLayer.utils import lookup
from SoftLayer.CLI import (
    CLIRunnable, Table, no_going_back, confirm, mb_to_gb, listing,
    FormattedItem)
from SoftLayer.CLI.helpers import (
    CLIAbort, ArgumentError, NestedDict, blank, resolve_id, KeyValueTable,
    update_with_template_args, FALSE_VALUES, export_to_template,
    active_txn, transaction_status)


class ListVSIs(CLIRunnable):
    """
usage: sl vs list [--hourly | --monthly] [--sortby=SORT_COLUMN] [--tags=TAGS]
                  [options]

List virtual servers

Examples:
    sl vs list --datacenter=dal05
    sl vs list --network=100 --cpu=2
    sl vs list --memory='>= 2048'
    sl vs list --tags=production,db

Options:
  --sortby=ARG  Column to sort by. options: id, datacenter, host,
                Cores, memory, primary_ip, backend_ip

Filters:
  -c --cpu=CPU             Number of CPU cores
  -D --domain=DOMAIN       Domain portion of the FQDN. example: example.com
  -d DC, --datacenter=DC   datacenter shortname (sng01, dal05, ...)
  -H --hostname=HOST       Host portion of the FQDN. example: server
  -m --memory=MEMORY       Memory in mebibytes
  -n MBPS, --network=MBPS  Network port speed in Mbps
  --hourly                 Show hourly instances
  --monthly                Show monthly instances
  --tags=ARG               Only show instances that have one of these tags.
                             Comma-separated. (production,db)

For more on filters see 'sl help filters'
"""
    action = 'list'

    def execute(self, args):
        vsi = VSManager(self.client)

        tags = None
        if args.get('--tags'):
            tags = [tag.strip() for tag in args.get('--tags').split(',')]

        guests = vsi.list_instances(hourly=args.get('--hourly'),
                                    monthly=args.get('--monthly'),
                                    hostname=args.get('--hostname'),
                                    domain=args.get('--domain'),
                                    cpus=args.get('--cpu'),
                                    memory=args.get('--memory'),
                                    datacenter=args.get('--datacenter'),
                                    nic_speed=args.get('--network'),
                                    tags=tags)

        table = Table([
            'id', 'datacenter', 'host',
            'cores', 'memory', 'primary_ip',
            'backend_ip', 'active_transaction',
        ])
        table.sortby = args.get('--sortby') or 'host'

        for guest in guests:
            guest = NestedDict(guest)
            table.add_row([
                guest['id'],
                guest['datacenter']['name'] or blank(),
                guest['fullyQualifiedDomainName'],
                guest['maxCpu'],
                mb_to_gb(guest['maxMemory']),
                guest['primaryIpAddress'] or blank(),
                guest['primaryBackendIpAddress'] or blank(),
                active_txn(guest),
            ])

        return table


class VSDetails(CLIRunnable):
    """
usage: sl vs detail [--passwords] [--price] <identifier> [options]

Get details for a virtual server

Options:
  --passwords  Show passwords (check over your shoulder!)
  --price      Show associated prices
"""
    action = 'detail'

    def execute(self, args):
        vsi = VSManager(self.client)
        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        result = vsi.get_instance(vs_id)
        result = NestedDict(result)

        table.add_row(['id', result['id']])
        table.add_row(['hostname', result['fullyQualifiedDomainName']])
        table.add_row(['status', FormattedItem(
            result['status']['keyName'] or blank(),
            result['status']['name'] or blank()
        )])
        table.add_row(['active_transaction', active_txn(result)])
        table.add_row(['state', FormattedItem(
            lookup(result, 'powerState', 'keyName'),
            lookup(result, 'powerState', 'name'),
        )])
        table.add_row(['datacenter', result['datacenter']['name'] or blank()])
        operating_system = lookup(result,
                                  'operatingSystem',
                                  'softwareLicense',
                                  'softwareDescription') or {}
        table.add_row([
            'os',
            FormattedItem(
                operating_system.get('version') or blank(),
                operating_system.get('name') or blank()
            )])
        table.add_row(['os_version',
                       operating_system.get('version') or blank()])
        table.add_row(['cores', result['maxCpu']])
        table.add_row(['memory', mb_to_gb(result['maxMemory'])])
        table.add_row(['public_ip', result['primaryIpAddress'] or blank()])
        table.add_row(['private_ip',
                       result['primaryBackendIpAddress'] or blank()])
        table.add_row(['private_only', result['privateNetworkOnlyFlag']])
        table.add_row(['private_cpu', result['dedicatedAccountHostOnlyFlag']])
        table.add_row(['created', result['createDate']])
        table.add_row(['modified', result['modifyDate']])

        vlan_table = Table(['type', 'number', 'id'])
        for vlan in result['networkVlans']:
            vlan_table.add_row([
                vlan['networkSpace'], vlan['vlanNumber'], vlan['id']])
        table.add_row(['vlans', vlan_table])

        if result.get('notes'):
            table.add_row(['notes', result['notes']])

        if args.get('--price'):
            table.add_row(['price rate',
                           result['billingItem']['recurringFee']])

        if args.get('--passwords'):
            pass_table = Table(['username', 'password'])
            for item in result['operatingSystem']['passwords']:
                pass_table.add_row([item['username'], item['password']])
            table.add_row(['users', pass_table])

        tag_row = []
        for tag in result['tagReferences']:
            tag_row.append(tag['tag']['name'])

        if tag_row:
            table.add_row(['tags', listing(tag_row, separator=',')])

        # Test to see if this actually has a primary (public) ip address
        if result['primaryIpAddress']:
            ptr_domains = self.client['Virtual_Guest'].\
                getReverseDomainRecords(id=vs_id)

            for ptr_domain in ptr_domains:
                for ptr in ptr_domain['resourceRecords']:
                    table.add_row(['ptr', ptr['data']])

        return table


class CreateOptionsVS(CLIRunnable):
    """
usage: sl vs create-options [options]

Output available available options when creating a virtual server

Options:
  --all         Show all options. default if no other option provided
  --cpu         Show CPU options
  --datacenter  Show datacenter options
  --disk        Show disk options
  --memory      Show memory size options
  --nic         Show NIC speed options
  --os          Show operating system options
"""
    action = 'create-options'
    options = ['datacenter', 'cpu', 'nic', 'disk', 'os', 'memory']

    def execute(self, args):
        vsi = VSManager(self.client)
        result = vsi.get_create_options()

        show_all = True
        for opt_name in self.options:
            if args.get("--" + opt_name):
                show_all = False
                break

        if args['--all']:
            show_all = True

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        if args['--datacenter'] or show_all:
            datacenters = [dc['template']['datacenter']['name']
                           for dc in result['datacenters']]
            table.add_row(['datacenter', listing(datacenters, separator=',')])

        if args['--cpu'] or show_all:
            standard_cpu = [x for x in result['processors']
                            if not x['template'].get(
                                'dedicatedAccountHostOnlyFlag', False)]

            ded_cpu = [x for x in result['processors']
                       if x['template'].get('dedicatedAccountHostOnlyFlag',
                                            False)]

            def add_cpus_row(cpu_options, name):
                """ Add CPU rows to the table """
                cpus = []
                for cpu_option in cpu_options:
                    cpus.append(str(cpu_option['template']['startCpus']))

                table.add_row(['cpus (%s)' % name,
                               listing(cpus, separator=',')])

            add_cpus_row(ded_cpu, 'private')
            add_cpus_row(standard_cpu, 'standard')

        if args['--memory'] or show_all:
            memory = [
                str(m['template']['maxMemory']) for m in result['memory']]
            table.add_row(['memory', listing(memory, separator=',')])

        if args['--os'] or show_all:
            op_sys = [
                o['template']['operatingSystemReferenceCode'] for o in
                result['operatingSystems']]

            op_sys = sorted(op_sys)
            os_summary = set()

            for operating_system in op_sys:
                os_summary.add(operating_system[0:operating_system.find('_')])

            for summary in sorted(os_summary):
                table.add_row([
                    'os (%s)' % summary,
                    linesep.join(sorted([x for x in op_sys
                                         if x[0:len(summary)] == summary]))
                ])

        if args['--disk'] or show_all:
            local_disks = [x for x in result['blockDevices']
                           if x['template'].get('localDiskFlag', False)]

            san_disks = [x for x in result['blockDevices']
                         if not x['template'].get('localDiskFlag', False)]

            def add_block_rows(disks, name):
                """ Add block rows to the table """
                simple = {}
                for disk in disks:
                    block = disk['template']['blockDevices'][0]
                    bid = block['device']

                    if bid not in simple:
                        simple[bid] = []

                    simple[bid].append(str(block['diskImage']['capacity']))

                for label in sorted(simple.keys()):
                    table.add_row(['%s disk(%s)' % (name, label),
                                   listing(simple[label], separator=',')])

            add_block_rows(local_disks, 'local')
            add_block_rows(san_disks, 'san')

        if args['--nic'] or show_all:
            speeds = []
            for comp in result['networkComponents']:
                speed = comp['template']['networkComponents'][0]['maxSpeed']
                speeds.append(str(speed))

            speeds = sorted(speeds)

            table.add_row(['nic', listing(speeds, separator=',')])

        return table


class CreateVS(CLIRunnable):
    """
usage: sl vs create [--disk=SIZE...] [--key=KEY...] [options]

Order/create a VS. See 'sl vs create-options' for valid options

Required:
  -c, --cpu=CPU        Number of CPU cores
  -D, --domain=DOMAIN  Domain portion of the FQDN. example: example.com
  -H, --hostname=HOST  Host portion of the FQDN. example: server
  --image=GUID         Image GUID. See: 'sl image list' for reference
  -m, --memory=MEMORY  Memory in mebibytes. example: 2048
  -o, --os=OS          OS install code. Tip: you can specify <OS>_LATEST

  --hourly            Hourly rate instance type
  --monthly           Monthly rate instance type


Optional:
  -d, --datacenter=DC    Datacenter shortname (sng01, dal05, ...)
                         Note: Omitting this value defaults to the first
                           available datacenter
  --dedicated            Create a dedicated VS (Virtual Server (Private Node))
  --san                  Use SAN storage instead of local disk. Applies to
                           all disks specified with --disk.
  --test                 Do not create VS, just get a quote
  --export=FILE          Exports options to a template file
  -F, --userfile=FILE    Read userdata from file
  -i, --postinstall=URI  Post-install script to download
                           (Only HTTPS executes, HTTP leaves file in /root)
  -k, --key=KEY          SSH keys to add to the root user. Can be specified
                           multiple times
  --like=IDENTIFIER      Use the configuration from an existing VS
  -n, --network=MBPS     Network port speed in Mbps
  --disk=SIZE...         Disks. Can be specified multiple times
  --private              Forces the VS to only have access the private network
  -t, --template=FILE    A template file that defaults the command-line
                           options using the long name in INI format
  -u, --userdata=DATA    User defined metadata string
  --vlan_public=VLAN     The ID of the public VLAN on which you want the VS
                           placed.
  --vlan_private=VLAN    The ID of the private VLAN on which you want the VS
                           placed.
  --wait=SECONDS         Block until VS is finished provisioning for up to X
                           seconds before returning
"""
    action = 'create'
    options = ['confirm']
    required_params = ['--hostname', '--domain', '--cpu', '--memory']

    def execute(self, args):
        update_with_template_args(args, list_args=['--disk', '--key'])
        vsi = VSManager(self.client)
        self._update_with_like_args(args)
        self._validate_args(args)

        # Do not create a virtual server with --test or --export
        do_create = not (args['--export'] or args['--test'])

        table = Table(['Item', 'cost'])
        table.align['Item'] = 'r'
        table.align['cost'] = 'r'
        data = self._parse_create_args(args)

        output = []
        if args.get('--test'):
            result = vsi.verify_create_instance(**data)
            total_monthly = 0.0
            total_hourly = 0.0

            table = Table(['Item', 'cost'])
            table.align['Item'] = 'r'
            table.align['cost'] = 'r'

            for price in result['prices']:
                total_monthly += float(price.get('recurringFee', 0.0))
                total_hourly += float(price.get('hourlyRecurringFee', 0.0))
                if args.get('--hourly'):
                    rate = "%.2f" % float(price['hourlyRecurringFee'])
                else:
                    rate = "%.2f" % float(price['recurringFee'])

                table.add_row([price['item']['description'], rate])

            if args.get('--hourly'):
                total = total_hourly
            else:
                total = total_monthly

            billing_rate = 'monthly'
            if args.get('--hourly'):
                billing_rate = 'hourly'
            table.add_row(['Total %s cost' % billing_rate, "%.2f" % total])
            output.append(table)
            output.append(FormattedItem(
                None,
                ' -- ! Prices reflected here are retail and do not '
                'take account level discounts and are not guaranteed.'))

        if args['--export']:
            export_file = args.pop('--export')
            export_to_template(export_file, args, exclude=['--wait', '--test'])
            return 'Successfully exported options to a template file.'

        if do_create:
            if args['--really'] or confirm(
                    "This action will incur charges on your account. "
                    "Continue?"):
                result = vsi.create_instance(**data)

                table = KeyValueTable(['name', 'value'])
                table.align['name'] = 'r'
                table.align['value'] = 'l'
                table.add_row(['id', result['id']])
                table.add_row(['created', result['createDate']])
                table.add_row(['guid', result['globalIdentifier']])
                output.append(table)

                if args.get('--wait'):
                    ready = vsi.wait_for_ready(
                        result['id'], int(args.get('--wait') or 1))
                    table.add_row(['ready', ready])
            else:
                raise CLIAbort('Aborting virtual server order.')

        return output

    def _validate_args(self, args):
        """ Raises an ArgumentError if the given arguments are not valid """
        invalid_args = [k for k in self.required_params if args.get(k) is None]
        if invalid_args:
            raise ArgumentError('Missing required options: %s'
                                % ','.join(invalid_args))

        if all([args['--userdata'], args['--userfile']]):
            raise ArgumentError('[-u | --userdata] not allowed with '
                                '[-F | --userfile]')

        if args['--hourly'] in FALSE_VALUES:
            args['--hourly'] = False

        if args['--monthly'] in FALSE_VALUES:
            args['--monthly'] = False

        if all([args['--hourly'], args['--monthly']]):
            raise ArgumentError('[--hourly] not allowed with [--monthly]')

        if not any([args['--hourly'], args['--monthly']]):
            raise ArgumentError('One of [--hourly | --monthly] is required')

        image_args = [args['--os'], args['--image']]
        if all(image_args):
            raise ArgumentError('[-o | --os] not allowed with [--image]')

        if not any(image_args):
            raise ArgumentError('One of [--os | --image] is required')

        if args['--userfile']:
            if not os.path.exists(args['--userfile']):
                raise ArgumentError(
                    'File does not exist [-u | --userfile] = %s'
                    % args['--userfile'])

    def _update_with_like_args(self, args):
        """ Update arguments with options taken from a currently running VS.

        :param VSManager args: A VSManager
        :param dict args: CLI arguments
        """
        if args['--like']:
            vsi = VSManager(self.client)
            vs_id = resolve_id(vsi.resolve_ids, args.pop('--like'), 'VS')
            like_details = vsi.get_instance(vs_id)
            like_args = {
                '--hostname': like_details['hostname'],
                '--domain': like_details['domain'],
                '--cpu': like_details['maxCpu'],
                '--memory': like_details['maxMemory'],
                '--hourly': like_details['hourlyBillingFlag'],
                '--monthly': not like_details['hourlyBillingFlag'],
                '--datacenter': like_details['datacenter']['name'],
                '--network': like_details['networkComponents'][0]['maxSpeed'],
                '--user-data': like_details['userData'] or None,
                '--postinstall': like_details.get('postInstallScriptUri'),
                '--dedicated': like_details['dedicatedAccountHostOnlyFlag'],
                '--private': like_details['privateNetworkOnlyFlag'],
            }

            # Handle mutually exclusive options
            like_image = lookup(like_details,
                                'blockDeviceTemplateGroup',
                                'globalIdentifier')
            like_os = lookup(like_details,
                             'operatingSystem',
                             'softwareLicense',
                             'softwareDescription',
                             'referenceCode')
            if like_image and not args.get('--os'):
                like_args['--image'] = like_image
            elif like_os and not args.get('--image'):
                like_args['--os'] = like_os

            if args.get('--hourly'):
                like_args['--monthly'] = False

            if args.get('--monthly'):
                like_args['--hourly'] = False

            # Merge like VS options with the options passed in
            for key, value in like_args.items():
                if args.get(key) in [None, False]:
                    args[key] = value

    def _parse_create_args(self, args):
        """ Converts CLI arguments to arguments that can be passed into
            VSManager.create_instance.

        :param dict args: CLI arguments
        """
        data = {
            "hourly": args['--hourly'],
            "cpus": args['--cpu'],
            "domain": args['--domain'],
            "hostname": args['--hostname'],
            "private": args['--private'],
            "dedicated": args['--dedicated'],
            "disks": args['--disk'],
            "local_disk": not args['--san'],
        }

        try:
            memory = int(args['--memory'])
            if memory < 1024:
                memory = memory * 1024
        except ValueError:
            unit = args['--memory'][-1]
            memory = int(args['--memory'][0:-1])
            if unit in ['G', 'g']:
                memory = memory * 1024
            if unit in ['T', 'r']:
                memory = memory * 1024 * 1024

        data["memory"] = memory

        if args['--monthly']:
            data['hourly'] = False

        if args.get('--os'):
            data['os_code'] = args['--os']

        if args.get('--image'):
            data['image_id'] = args['--image']

        if args.get('--datacenter'):
            data['datacenter'] = args['--datacenter']

        if args.get('--network'):
            data['nic_speed'] = args.get('--network')

        if args.get('--userdata'):
            data['userdata'] = args['--userdata']
        elif args.get('--userfile'):
            with open(args['--userfile'], 'r') as userfile:
                data['userdata'] = userfile.read()

        if args.get('--postinstall'):
            data['post_uri'] = args.get('--postinstall')

        # Get the SSH keys
        if args.get('--key'):
            keys = []
            for key in args.get('--key'):
                key_id = resolve_id(SshKeyManager(self.client).resolve_ids,
                                    key, 'SshKey')
                keys.append(key_id)
            data['ssh_keys'] = keys

        if args.get('--vlan_public'):
            data['public_vlan'] = args['--vlan_public']

        if args.get('--vlan_private'):
            data['private_vlan'] = args['--vlan_private']

        return data


class ReadyVS(CLIRunnable):
    """
usage: sl vs ready <identifier> [options]

Check if a virtual server is ready.

Optional:
  --wait=SECONDS  Block until VS is finished provisioning for up to X seconds
                    before returning.
"""
    action = 'ready'

    def execute(self, args):
        vsi = VSManager(self.client)

        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        ready = vsi.wait_for_ready(vs_id, int(args.get('--wait') or 0))

        if ready:
            return "READY"
        else:
            raise CLIAbort("Instance %s not ready" % vs_id)


class ReloadVS(CLIRunnable):
    """
usage: sl vs reload <identifier> [--key=KEY...] [options]

Reload the OS on a virtual server based on its current configuration

Optional:
  -i, --postinstall=URI  Post-install script to download
                           (Only HTTPS executes, HTTP leaves file in /root)
  -k, --key=KEY          SSH keys to add to the root user. Can be specified
                           multiple times
"""

    action = 'reload'
    options = ['confirm']

    def execute(self, args):
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        keys = []
        if args.get('--key'):
            for key in args.get('--key'):
                key_id = resolve_id(SshKeyManager(self.client).resolve_ids,
                                    key, 'SshKey')
                keys.append(key_id)
        if args['--really'] or no_going_back(vs_id):
            vsi.reload_instance(vs_id, args['--postinstall'], keys)
        else:
            CLIAbort('Aborted')


class CancelVS(CLIRunnable):
    """
usage: sl vs cancel <identifier> [options]

Cancel a virtual server
"""

    action = 'cancel'
    options = ['confirm']

    def execute(self, args):
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        if args['--really'] or no_going_back(vs_id):
            vsi.cancel_instance(vs_id)
        else:
            CLIAbort('Aborted')


class VSPowerOff(CLIRunnable):
    """
usage: sl vs power-off <identifier> [--hard] [options]

Power off an active virtual server

Optional:
    --hard  Perform a hard shutdown
"""
    action = 'power-off'
    options = ['confirm']

    def execute(self, args):
        virtual_guest = self.client['Virtual_Guest']
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        if args['--really'] or confirm('This will power off the VS with id '
                                       '%s. Continue?' % vs_id):
            if args['--hard']:
                virtual_guest.powerOff(id=vs_id)
            else:
                virtual_guest.powerOffSoft(id=vs_id)
        else:
            raise CLIAbort('Aborted.')


class VSReboot(CLIRunnable):
    """
usage: sl vs reboot <identifier> [--hard | --soft] [options]

Reboot an active virtual server

Optional:
    --hard  Perform an abrupt reboot
    --soft  Perform a graceful reboot
"""
    action = 'reboot'
    options = ['confirm']

    def execute(self, args):
        virtual_guest = self.client['Virtual_Guest']
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        if args['--really'] or confirm('This will reboot the VS with id '
                                       '%s. Continue?' % vs_id):
            if args['--hard']:
                virtual_guest.rebootHard(id=vs_id)
            elif args['--soft']:
                virtual_guest.rebootSoft(id=vs_id)
            else:
                virtual_guest.rebootDefault(id=vs_id)
        else:
            raise CLIAbort('Aborted.')


class VSPowerOn(CLIRunnable):
    """
usage: sl vs power-on <identifier> [options]

Power on a virtual server
"""
    action = 'power-on'

    def execute(self, args):
        virtual_guest = self.client['Virtual_Guest']
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        virtual_guest.powerOn(id=vs_id)


class VSPause(CLIRunnable):
    """
usage: sl vs pause <identifier> [options]

Pauses an active virtual server
"""
    action = 'pause'
    options = ['confirm']

    def execute(self, args):
        virtual_guest = self.client['Virtual_Guest']
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')

        if args['--really'] or confirm('This will pause the VS with id '
                                       '%s. Continue?' % vs_id):
            virtual_guest.pause(id=vs_id)
        else:
            raise CLIAbort('Aborted.')


class VSResume(CLIRunnable):
    """
usage: sl vs resume <identifier> [options]

Resumes a paused virtual server
"""
    action = 'resume'

    def execute(self, args):
        virtual_guest = self.client['Virtual_Guest']
        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        virtual_guest.resume(id=vs_id)


class NicEditVS(CLIRunnable):
    """
usage: sl vs nic-edit <identifier> (public | private) --speed=SPEED [options]

Manage NIC settings

Options:
    --speed=SPEED  Port speed. 0 disables the port.
                     [Options: 0, 10, 100, 1000, 10000]
"""
    action = 'nic-edit'

    def execute(self, args):
        public = args['public']

        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')

        vsi.change_port_speed(vs_id, public, args['--speed'])


class VSDNS(CLIRunnable):
    """
usage: sl vs dns sync <identifier> [options]

Attempts to update DNS for the specified VS. If you don't specify any
arguments, it will attempt to update both the A and PTR records. If you don't
want to update both records, you may use the -a or --ptr arguments to limit
the records updated.

Options:
  -a         Sync the A record for the host
  --ptr      Sync the PTR record for the host
  --ttl=TTL  Sets the TTL for the A and/or PTR records
"""
    action = 'dns'
    options = ['confirm']

    def execute(self, args):
        args['--ttl'] = args['--ttl'] or 7200
        if args['sync']:
            return self.dns_sync(args)

    def dns_sync(self, args):
        """ Sync DNS records to match the FQDN of the virtual server """
        dns = DNSManager(self.client)
        vsi = VSManager(self.client)

        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        instance = vsi.get_instance(vs_id)
        zone_id = resolve_id(dns.resolve_ids, instance['domain'], name='zone')

        def sync_a_record():
            """ Sync A record """
            records = dns.get_records(
                zone_id,
                host=instance['hostname'],
            )

            if not records:
                # don't have a record, lets add one to the base zone
                dns.create_record(
                    zone['id'],
                    instance['hostname'],
                    'a',
                    instance['primaryIpAddress'],
                    ttl=args['--ttl'])
            else:
                recs = [x for x in records if x['type'].lower() == 'a']
                if len(recs) != 1:
                    raise CLIAbort("Aborting A record sync, found %d "
                                   "A record exists!" % len(recs))
                rec = recs[0]
                rec['data'] = instance['primaryIpAddress']
                rec['ttl'] = args['--ttl']
                dns.edit_record(rec)

        def sync_ptr_record():
            """ Sync PTR record """
            host_rec = instance['primaryIpAddress'].split('.')[-1]
            ptr_domains = self.client['Virtual_Guest'].\
                getReverseDomainRecords(id=instance['id'])[0]
            edit_ptr = None
            for ptr in ptr_domains['resourceRecords']:
                if ptr['host'] == host_rec:
                    ptr['ttl'] = args['--ttl']
                    edit_ptr = ptr
                    break

            if edit_ptr:
                edit_ptr['data'] = instance['fullyQualifiedDomainName']
                dns.edit_record(edit_ptr)
            else:
                dns.create_record(
                    ptr_domains['id'],
                    host_rec,
                    'ptr',
                    instance['fullyQualifiedDomainName'],
                    ttl=args['--ttl'])

        if not instance['primaryIpAddress']:
            raise CLIAbort('No primary IP address associated with this VS')

        zone = dns.get_zone(zone_id)

        go_for_it = args['--really'] or confirm(
            "Attempt to update DNS records for %s"
            % instance['fullyQualifiedDomainName'])

        if not go_for_it:
            raise CLIAbort("Aborting DNS sync")

        both = False
        if not args['--ptr'] and not args['-a']:
            both = True

        if both or args['-a']:
            sync_a_record()

        if both or args['--ptr']:
            sync_ptr_record()


class EditVS(CLIRunnable):
    """
usage: sl vs edit <identifier> [options]

Edit a virtual server's details

Options:
  -D --domain=DOMAIN  Domain portion of the FQDN example: example.com
  -F --userfile=FILE  Read userdata from file
  -H --hostname=HOST  Host portion of the FQDN. example: server
  -u --userdata=DATA  User defined metadata string
"""
    action = 'edit'

    def execute(self, args):
        data = {}

        if args['--userdata'] and args['--userfile']:
            raise ArgumentError('[-u | --userdata] not allowed with '
                                '[-F | --userfile]')
        if args['--userfile']:
            if not os.path.exists(args['--userfile']):
                raise ArgumentError(
                    'File does not exist [-u | --userfile] = %s'
                    % args['--userfile'])

        if args.get('--userdata'):
            data['userdata'] = args['--userdata']
        elif args.get('--userfile'):
            with open(args['--userfile'], 'r') as userfile:
                data['userdata'] = userfile.read()

        data['hostname'] = args.get('--hostname')
        data['domain'] = args.get('--domain')

        vsi = VSManager(self.client)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        if not vsi.edit(vs_id, **data):
            raise CLIAbort("Failed to update virtual server")


class CaptureVS(CLIRunnable):
    """
usage: sl vs capture <identifier> [options]

Capture one or all disks from a virtual server to a SoftLayer image.

Required:
  -n --name=NAME         Name of the image

Optional:
  --all                  Capture all disks belonging to the VS
  --note=NOTE            Add a note to be associated with the image
"""
    action = 'capture'

    def execute(self, args):
        vsi = VSManager(self.client)

        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')

        if args['--all']:
            additional_disks = True
        else:
            additional_disks = False

        capture = vsi.capture(vs_id,
                              args.get('--name'),
                              additional_disks,
                              args.get('--note'))

        table = KeyValueTable(['Name', 'Value'])
        table.align['Name'] = 'r'
        table.align['Value'] = 'l'

        table.add_row(['vs_id', capture['guestId']])
        table.add_row(['date', capture['createDate'][:10]])
        table.add_row(['time', capture['createDate'][11:19]])
        table.add_row(['transaction', transaction_status(capture)])
        table.add_row(['transaction_id', capture['id']])
        table.add_row(['all_disks', additional_disks])
        return table


class UpgradeVS(CLIRunnable):
    """
usage: sl vs upgrade <identifier> [options]

Upgrade parameters of a virtual server

Examples:
    sl vs upgrade --cpus 2
    sl vs upgrade --memory 2048 --network 1000
Options:
    --cpu=CPU          Number of CPU cores
    --private          CPU core will be on a dedicated host server.
                       Default is Public.
                       Public: Resources are in multi-tenant environment.
    --memory=MEMORY    Memory in megabytes
    --network=MBPS     Network port speed in Mbps

Note: SoftLayer automatically reboots the VS once upgrade request is placed.
The VS is halted until the Upgrade transaction is completed.
However for Network, no reboot is required.
"""

    action = 'upgrade'
    options = ['confirm']

    def execute(self, args):
        vsi = VSManager(self.client)
        data = {}
        data['cpus'] = args.get('--cpu')
        data['memory'] = args.get('--memory')
        data['nic_speed'] = args.get('--network')
        data['public'] = True
        if args.get('--private'):
            data['public'] = False
        data = self.verify_upgrade_parameters(data)
        vs_id = resolve_id(vsi.resolve_ids, args.get('<identifier>'), 'VS')
        if args['--really'] or confirm(
                "This action will incur charges on your account. "
                "Continue?"):
            if not vsi.upgrade(vs_id, **data):
                raise CLIAbort('VS Upgrade Failed')

    def verify_upgrade_parameters(self, data):
        """
        param int cpus: The number of virtual CPUs to upgrade to
                            of a virtual server.
        :param int memory: RAM of the VS to be upgraded to.
        :param int nic_speed: The port speed to set
        """
        try:
            if data['memory']:
                data['memory'] = int(data['memory']) / 1024
            if data['cpus']:
                data['cpus'] = int(data['cpus'])
            if data['nic_speed']:
                data['nic_speed'] = int(data['nic_speed'])
            return data
        except:
            raise ValueError(
                "One or more Values of VS parameters are not correct")

########NEW FILE########
__FILENAME__ = template
"""
    SoftLayer.CLI.template
    ~~~~~~~~~~~~~~~~~~~~~~
    Provides functions for loading/parsing and writing template files. Template
    files are used for storing CLI arguments in the form of a file to be used
    later with the --template option.

    :license: MIT, see LICENSE for more details.
"""
import os.path

from .exceptions import ArgumentError
from SoftLayer.utils import configparser, StringIO


def update_with_template_args(args, list_args=None):
    """ Populates arguments with arguments from the template file, if provided.

    :param dict args: command-line arguments
    """
    if not args.get('--template'):
        return

    list_args = list_args or []

    template_path = args.pop('--template')
    if not os.path.exists(template_path):
        raise ArgumentError(
            'File does not exist [-t | --template] = %s'
            % template_path)

    config = configparser.ConfigParser()
    ini_str = '[settings]\n' + open(
        os.path.expanduser(template_path), 'r').read()
    ini_fp = StringIO(ini_str)
    config.readfp(ini_fp)

    # Merge template options with the options passed in
    for key, value in config.items('settings'):
        option_key = '--%s' % key
        if option_key in list_args:
            value = value.split(',')
        if not args.get(option_key):
            args[option_key] = value


def export_to_template(filename, args, exclude=None):
    """ Exports given options to the given filename in INI format

    :param filename: Filename to save options to
    :param dict args: Arguments to export
    :param list exclude (optional): Exclusion list for options that should not
                                    be exported
    """
    exclude = exclude or []
    exclude.append('--config')
    exclude.append('--really')
    exclude.append('--format')
    exclude.append('--debug')

    with open(filename, "w") as template_file:
        for k, val in args.items():
            if val and k.startswith('-') and k not in exclude:
                k = k.lstrip('-')
                if isinstance(val, list):
                    val = ','.join(val)
                template_file.write('%s=%s\n' % (k, val))

########NEW FILE########
__FILENAME__ = config
"""
    SoftLayer.config
    ~~~~~~~~~~~~~~~~
    Handles different methods for loading configuration for the API bindings

    :license: MIT, see LICENSE for more details.
"""
import os
import os.path

from .auth import BasicAuthentication
from SoftLayer.utils import configparser


def get_client_settings_args(**kwargs):
    """ Retrieve client settings from user-supplied arguments

        :param \\*\\*kwargs: Arguments that are passed into the client instance
    """
    settings = {
        'endpoint_url': kwargs.get('endpoint_url'),
        'timeout': kwargs.get('timeout'),
        'auth': kwargs.get('auth'),
        'proxy': kwargs.get('proxy'),
    }
    username = kwargs.get('username')
    api_key = kwargs.get('api_key')
    if username and api_key and not settings['auth']:
        settings['auth'] = BasicAuthentication(username, api_key)
    return settings


def get_client_settings_env(**_):
    """ Retrieve client settings from environment settings

        :param \\*\\*kwargs: Arguments that are passed into the client instance
    """
    username = os.environ.get('SL_USERNAME')
    api_key = os.environ.get('SL_API_KEY')
    proxy = os.environ.get('https_proxy')

    config = {'proxy': proxy}
    if username and api_key:
        config['auth'] = BasicAuthentication(username, api_key)
    return config


def get_client_settings_config_file(**kwargs):
    """ Retrieve client settings from the possible config file locations

        :param \\*\\*kwargs: Arguments that are passed into the client instance
    """
    config_files = ['/etc/softlayer.conf', '~/.softlayer']
    if kwargs.get('config_file'):
        config_files.append(kwargs.get('config_file'))
    config_files = [os.path.expanduser(f) for f in config_files]
    config = configparser.RawConfigParser({
        'username': '',
        'api_key': '',
        'endpoint_url': '',
        'timeout': '',
        'proxy': '',
    })
    config.read(config_files)

    if not config.has_section('softlayer'):
        return

    settings = {
        'endpoint_url': config.get('softlayer', 'endpoint_url'),
        'timeout': config.get('softlayer', 'timeout'),
        'proxy': config.get('softlayer', 'proxy'),
    }
    username = config.get('softlayer', 'username')
    api_key = config.get('softlayer', 'api_key')
    if username and api_key:
        settings['auth'] = BasicAuthentication(username, api_key)
    return settings

SETTING_RESOLVERS = [get_client_settings_args,
                     get_client_settings_env,
                     get_client_settings_config_file]


def get_client_settings(**kwargs):
    """ Parses settings from various input methods, preferring earlier values
        to later ones. Once an 'auth' value is found, it returns the gathered
        settings. The settings currently come from explicit user arguments,
        environmental variables and config files.

        :param \\*\\*kwargs: Arguments that are passed into the client instance
    """
    all_settings = {}
    for setting_method in SETTING_RESOLVERS:
        settings = setting_method(**kwargs)
        if settings:
            settings.update((k, v) for k, v in all_settings.items() if v)
            all_settings = settings
            if all_settings.get('auth'):
                break
    return all_settings

########NEW FILE########
__FILENAME__ = consts
"""
    SoftLayer.consts
    ~~~~~~~~~~~~~~~~
    Contains constants used throughout the library

    :license: MIT, see LICENSE for more details.
"""
VERSION = 'v3.1.0'
API_PUBLIC_ENDPOINT = 'https://api.softlayer.com/xmlrpc/v3.1/'
API_PRIVATE_ENDPOINT = 'https://api.service.softlayer.com/xmlrpc/v3.1/'
API_PUBLIC_ENDPOINT_REST = 'https://api.softlayer.com/rest/v3.1/'
API_PRIVATE_ENDPOINT_REST = 'https://api.service.softlayer.com/rest/v3.1/'
USER_AGENT = "SoftLayer Python %s" % VERSION

########NEW FILE########
__FILENAME__ = exceptions
"""
    SoftLayer.exceptions
    ~~~~~~~~~~~~~~~~~~~~
    Exceptions used throughout the library

    :license: MIT, see LICENSE for more details.
"""


class SoftLayerError(Exception):
    """ The base SoftLayer error. """


class Unauthenticated(SoftLayerError):
    """ Unauthenticated """


class SoftLayerAPIError(SoftLayerError):
    """ SoftLayerAPIError is an exception raised whenever an error is returned
    from the API.

    Provides faultCode and faultString properties.
    """
    def __init__(self, faultCode, faultString, *args):
        SoftLayerError.__init__(self, faultString, *args)
        self.faultCode = faultCode  # pylint: disable=C0103
        self.reason = self.faultString = faultString  # pylint: disable=C0103

    def __repr__(self):
        return '<%s(%s): %s>' % \
            (self.__class__.__name__, self.faultCode, self.faultString)

    def __str__(self):
        return '%s(%s): %s' % \
            (self.__class__.__name__, self.faultCode, self.faultString)


class ParseError(SoftLayerAPIError):
    """ Parse Error """


class ServerError(SoftLayerAPIError):
    """ Server Error """


class ApplicationError(SoftLayerAPIError):
    """ Application Error """


class RemoteSystemError(SoftLayerAPIError):
    """ System Error """


class TransportError(SoftLayerAPIError):
    """ Transport Error """


# XMLRPC Errors
class NotWellFormed(ParseError):
    """ Request was not well formed """
    pass


class UnsupportedEncoding(ParseError):
    """ Encoding not supported """
    pass


class InvalidCharacter(ParseError):
    """ There was an invalid character """
    pass


class SpecViolation(ServerError):
    """ There was a spec violation """
    pass


class MethodNotFound(ServerError):
    """ Method name not found """
    pass


class InvalidMethodParameters(ServerError):
    """ Invalid method paramters """
    pass


class InternalError(ServerError):
    """ Internal Server Error """
    pass

########NEW FILE########
__FILENAME__ = cci
"""
    SoftLayer.cci
    ~~~~~~~~~~~~~
    CCIManager to provide backwards compatibility.

    :license: MIT, see LICENSE for more details.
"""
import warnings
from SoftLayer.managers.vs import VSManager


class CCIManager(VSManager):
    """
    Wrapper for the VSManager class to provide backwards compatibility with the
    old CCIManager class.
    """
    def __init__(self, client):
        super(CCIManager, self).__init__(client)
        warnings.warn("The CCIManager class has been replaced with VSManager.",
                      DeprecationWarning)

########NEW FILE########
__FILENAME__ = cdn
"""
    SoftLayer.cdn
    ~~~~~~~~~~~~~~~~~~~~~~
    CDN Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.utils import IdentifierMixin
from six import string_types


MAX_URLS_PER_LOAD = 5
MAX_URLS_PER_PURGE = 5


class CDNManager(IdentifierMixin, object):
    """ Manage CDN accounts """

    def __init__(self, client):
        self.client = client
        self.account = self.client['Network_ContentDelivery_Account']

    def list_accounts(self):
        """ Lists CDN accounts for the active user. """

        account = self.client['Account']
        mask = 'cdnAccounts[%s]' % ', '.join(['id',
                                              'createDate',
                                              'cdnAccountName',
                                              'cdnSolutionName',
                                              'cdnAccountNote',
                                              'status'])
        return account.getObject(mask=mask).get('cdnAccounts', [])

    def get_account(self, account_id, **kwargs):
        """ Retrieves a CDN account with the specified account ID.

        :param account_id int: the numeric ID associated with the CDN account.
        :param dict \\*\\*kwargs: additional arguments to include in the object
                                mask.
        """

        if 'mask' not in kwargs:
            kwargs['mask'] = 'status'

        return self.account.getObject(id=account_id, **kwargs)

    def get_origins(self, account_id, **kwargs):
        """ Retrieves a list of origin pull mappings for a specified CDN
        account.

        :param account_id int: the numeric ID associated with the CDN account.
        :param dict \\*\\*kwargs: additional arguments to include in the object
                                mask.
        """

        return self.account.getOriginPullMappingInformation(id=account_id,
                                                            **kwargs)

    def add_origin(self, account_id, media_type, origin_url, cname=None,
                   secure=False):
        """ Adds an original pull mapping to an origin-pull based CDN account
        with the options provided.

        :param int account_id: the numeric ID associated with the CDN account.
        :param string media_type: the media type/protocol associated with this
                                  origin pull mapping; valid values are HTTP,
                                  FLASH, and WM.
        :param string origin_url: the base URL from which content should be
                                  pulled.
        :param string cname: an optional CNAME that should be associated with
                             this origin pull rule; only the hostname should be
                             included (i.e., no 'http://', directories, etc.).
        :param boolean secure: specifies whether this is an SSL origin pull
                               rule, if SSL is enabled on your account
                               (defaults to false).
        """

        config = {'mediaType': media_type,
                  'originUrl': origin_url,
                  'isSecureContent': secure}

        if cname:
            config['cname'] = cname

        return self.account.createOriginPullMapping(config, id=account_id)

    def remove_origin(self, account_id, origin_id):
        """ Removes an origin pull mapping with the given origin pull ID under
        the provided CDN account ID.

        :param int account_id: the CDN account ID from which the mapping should
                               be deleted.
        :param int origin_id: the origin pull mapping ID to delete.
        """

        return self.account.deleteOriginPullRule(origin_id, id=account_id)

    def load_content(self, account_id, urls):
        """ Prefetches one or more URLs to the CDN edge nodes.

        :param int account_id: the CDN account ID into which content should be
                               preloaded.
        :param urls: a string or a list of strings representing the CDN URLs
                     that should be pre-loaded.
        :returns: true if all load requests were successfully submitted;
                  otherwise, returns the first error encountered.
        """

        if isinstance(urls, string_types):
            urls = [urls]

        for i in range(0, len(urls), MAX_URLS_PER_LOAD):
            result = self.account.loadContent(urls[i:i + MAX_URLS_PER_LOAD],
                                              id=account_id)
            if not result:
                return result

        return True

    def purge_content(self, account_id, urls):
        """ Purges one or more URLs from the CDN edge nodes.

        :param int account_id: the CDN account ID from which content should
                               be purged.
        :param urls: a string or a list of strings representing the CDN URLs
                     that should be purged.
        :returns: true if all purge requests were successfully submitted;
                  otherwise, returns the first error encountered.
        """

        if isinstance(urls, string_types):
            urls = [urls]

        for i in range(0, len(urls), MAX_URLS_PER_PURGE):
            result = self.account.purgeContent(urls[i:i + MAX_URLS_PER_PURGE],
                                               id=account_id)
            if not result:
                return result

        return True

########NEW FILE########
__FILENAME__ = dns
"""
    SoftLayer.dns
    ~~~~~~~~~~~~~
    DNS Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
from time import strftime

from SoftLayer.utils import NestedDict, query_filter, IdentifierMixin


class DNSManager(IdentifierMixin, object):
    """ DNSManager initialization.

    :param SoftLayer.API.Client client: the client instance

    """

    def __init__(self, client):
        self.client = client
        self.service = self.client['Dns_Domain']
        self.record = self.client['Dns_Domain_ResourceRecord']
        self.resolvers = [self._get_zone_id_from_name]

    def _get_zone_id_from_name(self, name):
        """ Return zone ID based on a zone """
        results = self.client['Account'].getDomains(
            filter={"domains": {"name": query_filter(name)}})
        return [x['id'] for x in results]

    def list_zones(self, **kwargs):
        """ Retrieve a list of all DNS zones.

        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        :returns: A list of dictionaries representing the matching zones.

        """
        return self.client['Account'].getDomains(**kwargs)

    def get_zone(self, zone_id, records=True):
        """ Get a zone and its records.

        :param zone: the zone name
        :returns: A dictionary containing a large amount of information about
                  the specified zone.

        """
        mask = None
        if records:
            mask = 'resourceRecords'
        return self.service.getObject(id=zone_id, mask=mask)

    def create_zone(self, zone, serial=None):
        """ Create a zone for the specified zone.

        :param zone: the zone name to create
        :param serial: serial value on the zone (default: strftime(%Y%m%d01))

        """
        return self.service.createObject({
            'name': zone,
            'serial': serial or strftime('%Y%m%d01'),
            "resourceRecords": {}})

    def delete_zone(self, zone_id):
        """ Delete a zone by its ID.

        :param integer zone_id: the zone ID to delete

        """
        return self.service.deleteObject(id=zone_id)

    def edit_zone(self, zone):
        """ Update an existing zone with the options provided. The provided
        dict must include an 'id' key and value corresponding to the zone that
        should be updated.

        :param dict zone: the zone to update

        """
        self.service.editObject(zone)

    def create_record(self, zone_id, record, record_type, data, ttl=60):
        """ Create a resource record on a domain.

        :param integer id: the zone's ID
        :param record: the name of the record to add
        :param record_type: the type of record (A, AAAA, CNAME, MX, TXT, etc.)
        :param data: the record's value
        :param integer ttl: the TTL or time-to-live value (default: 60)

        """
        self.record.createObject({
            'domainId': zone_id,
            'ttl': ttl,
            'host': record,
            'type': record_type,
            'data': data})

    def delete_record(self, record_id):
        """ Delete a resource record by its ID.

        :param integer id: the record's ID

        """
        self.record.deleteObject(id=record_id)

    def get_records(self, zone_id, ttl=None, data=None, host=None,
                    record_type=None):
        """ List, and optionally filter, records within a zone.

        :param zone: the zone name in which to search.
        :param int ttl: optionally, time in seconds:
        :param data: optionally, the records data
        :param host: optionally, record's host
        :param record_type: optionally, the type of record:

        :returns: A list of dictionaries representing the matching records
                  within the specified zone.
        """
        _filter = NestedDict()

        if ttl:
            _filter['resourceRecords']['ttl'] = query_filter(ttl)

        if host:
            _filter['resourceRecords']['host'] = query_filter(host)

        if data:
            _filter['resourceRecords']['data'] = query_filter(data)

        if record_type:
            _filter['resourceRecords']['type'] = query_filter(
                record_type.lower())

        results = self.service.getResourceRecords(
            id=zone_id,
            mask='id,expire,domainId,host,minimum,refresh,retry,'
            'mxPriority,ttl,type,data,responsiblePerson',
            filter=_filter.to_dict(),
        )

        return results

    def edit_record(self, record):
        """ Update an existing record with the options provided. The provided
        dict must include an 'id' key and value corresponding to the record
        that should be updated.

        :param dict record: the record to update

        """
        self.record.editObject(record, id=record['id'])

    def dump_zone(self, zone_id):
        """ Retrieve a zone dump in BIND format.

        :param integer id: The zone ID to dump

        """
        return self.service.getZoneFileContents(id=zone_id)

########NEW FILE########
__FILENAME__ = firewall
"""
    SoftLayer.firewall
    ~~~~~~~~~~~~~~~~~~
    Firewall Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.utils import IdentifierMixin, NestedDict, query_filter

RULE_MASK = ('mask[orderValue,action,destinationIpAddress,'
             'destinationIpSubnetMask,protocol,destinationPortRangeStart,'
             'destinationPortRangeEnd,sourceIpAddress,sourceIpSubnetMask,'
             'version]')


def has_firewall(vlan):
    """ Helper to determine whether or not a VLAN has a firewall.

    :param dict vlan: A dictionary representing a VLAN
    :returns: True if the VLAN has a firewall, false if it doesn't.
    """
    return bool(
        vlan.get('dedicatedFirewallFlag', None) or
        vlan.get('highAvailabilityFirewallFlag', None) or
        vlan.get('firewallInterfaces', None) or
        vlan.get('firewallNetworkComponents', None) or
        vlan.get('firewallGuestNetworkComponents', None)
    )


class FirewallManager(IdentifierMixin, object):

    """ Manages firewalls.

    :param SoftLayer.API.Client client: the API client instance

    """

    def __init__(self, client):
        self.client = client
        self.account = self.client['Account']
        self.prod_pkg = self.client['Product_Package']

    def get_standard_package(self, server_id, is_cci=True):
        """ Retrieves the standard firewall package for the CCI.

        :param int server_id: The ID of the server to create the firewall for
        :param bool is_cci: True if the id provided is for a CCI,
                            False for a server
        :returns: A dictionary containing the standard CCI firewall package
        """
        mask = ('mask[primaryNetworkComponent[speed]]')
        if is_cci:
            svc = self.client['Virtual_Guest']
        else:
            svc = self.client['Hardware_Server']

        item = svc.getObject(mask=mask, id=server_id)

        _filter = NestedDict({})
        _value = "%s%s" % (item['primaryNetworkComponent']['speed'],
                           "Mbps Hardware Firewall")
        _filter['items']['description'] = query_filter(_value)

        kwargs = NestedDict({})
        kwargs['id'] = 0  # look at package id 0
        kwargs['filter'] = _filter.to_dict()
        return self.prod_pkg.getItems(**kwargs)

    def get_dedicated_package(self, ha_enabled=False):
        """ Retrieves the dedicated firewall package.

        :param bool ha_enabled: True if HA is to be enabled on the firewall
                                False for No HA
        :returns: A dictionary containing the dedicated CCI firewall package
        """

        fwl_filter = 'Hardware Firewall (Dedicated)'
        ha_fwl_filter = 'Hardware Firewall (High Availability)'
        _filter = NestedDict({})
        if ha_enabled:
            _filter['items']['description'] = query_filter(ha_fwl_filter)
        else:
            _filter['items']['description'] = query_filter(fwl_filter)

        kwargs = NestedDict({})
        kwargs['id'] = 0  # look at package id 0
        kwargs['filter'] = _filter.to_dict()
        return self.prod_pkg.getItems(**kwargs)

    def cancel_firewall(self, firewall_id, dedicated=False):
        """ Cancels the specified firewall.

        :param int firewall_id: Firewall ID to be cancelled.
        :param bool dedicated: If true, the firewall instance is dedicated,
                               otherwise, the firewall instance is shared.
        """
        fwl_billing = self._get_fwl_billing_item(firewall_id, dedicated)
        billing_id = fwl_billing['billingItem']['id']
        billing_item = self.client['Billing_Item']
        return billing_item.cancelService(id=billing_id)

    def add_standard_firewall(self, server_id, is_cci=True):
        """ Creates a firewall for the specified CCI/Server

        :param int cci_id: The ID of the CCI to create the firewall for
        :param bool is_cci: If false, will create the firewall for a server,
                            otherwise for a CCI
        :returns: A dictionary containing the standard CCI firewall order
        """
        package = self.get_standard_package(server_id, is_cci)
        if is_cci:
            product_order = {
                'complexType': 'SoftLayer_Container_Product_Order_Network_'
                               'Protection_Firewall',
                'quantity': 1,
                'packageId': 0,
                'virtualGuests': [{'id': server_id}],
                'prices': [{'id': package[0]['prices'][0]['id']}]
            }
        else:
            product_order = {
                'complexType': 'SoftLayer_Container_Product_Order_Network_'
                               'Protection_Firewall',
                'quantity': 1,
                'packageId': 0,
                'hardware': [{'id': server_id}],
                'prices': [{'id': package[0]['prices'][0]['id']}]
            }
        return self.client['Product_Order'].placeOrder(product_order)

    def add_vlan_firewall(self, vlan_id, ha_enabled=False):
        """ Creates a firewall for the specified vlan

        :param int vlan_id: The ID of the vlan to create the firewall for
        :param bool ha_enabled: If True, Ha firewall will be created

        :returns: A dictionary containing the VLAN firewall order
        """
        package = self.get_dedicated_package(ha_enabled)
        product_order = {
            'complexType': 'SoftLayer_Container_Product_Order_Network_'
                           'Protection_Firewall_Dedicated',
            'quantity': 1,
            'packageId': 0,
            'vlanId': vlan_id,
            'prices': [{'id': package[0]['prices'][0]['id']}]
        }
        return self.client['Product_Order'].placeOrder(product_order)

    def _get_fwl_billing_item(self, firewall_id, dedicated=False):
        """ Retrieves the billing item of the firewall

        :param int firewall_id: Firewall ID to get the billing item for
        :param bool dedicated: whether the firewall is dedicated or standard
        :returns: A dictionary of the firewall billing item.
        """
        mask = ('mask[id,billingItem[id]]')
        if dedicated:
            fwl_svc = self.client['Network_Vlan_Firewall']
        else:
            fwl_svc = self.client['Network_Component_Firewall']
        return fwl_svc.getObject(id=firewall_id, mask=mask)

    def get_firewalls(self):
        """ Returns a list of all firewalls on the account.

        :returns: A list of firewalls on the current account.
        """
        mask = ('firewallNetworkComponents,'
                'networkVlanFirewall,'
                'dedicatedFirewallFlag,'
                'firewallGuestNetworkComponents,'
                'firewallInterfaces,'
                'firewallRules,'
                'highAvailabilityFirewallFlag')

        return [firewall
                for firewall in self.account.getNetworkVlans(mask=mask)
                if has_firewall(firewall)]

    def get_standard_fwl_rules(self, firewall_id):
        """ Get the rules of a standard firewall

        :param integer firewall_id: the instance ID of the standard firewall
        :returns: A list of the rules.
        """
        svc = self.client['Network_Component_Firewall']
        return svc.getRules(id=firewall_id, mask=RULE_MASK)

    def get_dedicated_fwl_rules(self, firewall_id):
        """ Get the rules of a dedicated firewall

        :param integer firewall_id: the instance ID of the dedicated firewall
        :returns: A list of the rules.
        """
        svc = self.client['Network_Vlan_Firewall']
        return svc.getRules(id=firewall_id, mask=RULE_MASK)

    def edit_dedicated_fwl_rules(self, firewall_id, rules):
        """ Edit the rules for dedicated firewall

        :param integer firewall_id: the instance ID of the dedicated firewall
        :param dict rules: the rules to be pushed on the firewall
        """
        mask = ('mask[networkVlan[firewallInterfaces'
                '[firewallContextAccessControlLists]]]')
        svc = self.client['Network_Vlan_Firewall']
        fwl = svc.getObject(id=firewall_id, mask=mask)
        network_vlan = fwl['networkVlan']

        for fwl1 in network_vlan['firewallInterfaces']:
            if fwl1['name'] == 'inside':
                continue
            for control_list in fwl1['firewallContextAccessControlLists']:
                if control_list['direction'] == 'out':
                    continue
                fwl_ctx_acl_id = control_list['id']

        template = {
            'firewallContextAccessControlListId': fwl_ctx_acl_id,
            'rules': rules
        }

        svc = self.client['Network_Firewall_Update_Request']
        return svc.createObject(template)

    def edit_standard_fwl_rules(self, firewall_id, rules):
        """ Edit the rules for standard firewall

        :param integer firewall_id: the instance ID of the standard firewall
        :param dict rules: the rules to be pushed on the firewall
        """
        rule_svc = self.client['Network_Firewall_Update_Request']
        template = {
            "networkComponentFirewallId": firewall_id,
            "rules": rules}

        return rule_svc.createObject(template)

########NEW FILE########
__FILENAME__ = hardware
"""
    SoftLayer.hardware
    ~~~~~~~~~~~~~~~~~~
    Hardware Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
# Invalid names are ignored due to long method names and short argument names
# pylint: disable=C0103
import socket
from SoftLayer.utils import NestedDict, query_filter, IdentifierMixin


class HardwareManager(IdentifierMixin, object):
    """
    Manages hardware devices.

    :param SoftLayer.API.Client client: an API client instance
    """

    def __init__(self, client):
        self.client = client
        self.hardware = self.client['Hardware_Server']
        self.account = self.client['Account']
        self.resolvers = [self._get_ids_from_ip, self._get_ids_from_hostname]

    def cancel_hardware(self, hardware_id, reason='unneeded', comment=''):
        """ Cancels the specified dedicated server.

        :param int hardware_id: The ID of the hardware to be cancelled.
        :param string reason: The reason code for the cancellation. This should
                              come from :func:`get_cancellation_reasons`.
        :param string comment: An optional comment to include with the
                               cancellation.
        """
        # Check to see if this is actually a pre-configured server (BMC). They
        # require a different cancellation call.
        server = self.get_hardware(hardware_id,
                                   mask='id,bareMetalInstanceFlag')

        if server.get('bareMetalInstanceFlag'):
            return self.cancel_metal(hardware_id)

        reasons = self.get_cancellation_reasons()
        cancel_reason = reasons['unneeded']

        if reason in reasons:
            cancel_reason = reasons[reason]

        # Arguments per SLDN:
        # attachmentId - Hardware ID
        # Reason
        # content - Comment about the cancellation
        # cancelAssociatedItems
        # attachmentType - Only option is HARDWARE
        return self.client['Ticket'].createCancelServerTicket(hardware_id,
                                                              cancel_reason,
                                                              comment,
                                                              True,
                                                              'HARDWARE')

    def cancel_metal(self, hardware_id, immediate=False):
        """ Cancels the specified bare metal instance.

        :param int id: The ID of the bare metal instance to be cancelled.
        :param bool immediate: If true, the bare metal instance will be
                               cancelled immediately. Otherwise, it will be
                               scheduled to cancel on the anniversary date.
        """
        hw_billing = self.get_hardware(hardware_id,
                                       mask='mask[id, billingItem.id]')

        billing_id = hw_billing['billingItem']['id']

        billing_item = self.client['Billing_Item']

        if immediate:
            return billing_item.cancelService(id=billing_id)
        else:
            return billing_item.cancelServiceOnAnniversaryDate(id=billing_id)

    def list_hardware(self, tags=None, cpus=None, memory=None, hostname=None,
                      domain=None, datacenter=None, nic_speed=None,
                      public_ip=None, private_ip=None, **kwargs):
        """ List all hardware (servers and bare metal computing instances).

        :param list tags: filter based on tags
        :param integer cpus: filter based on number of CPUS
        :param integer memory: filter based on amount of memory in gigabytes
        :param string hostname: filter based on hostname
        :param string domain: filter based on domain
        :param string datacenter: filter based on datacenter
        :param integer nic_speed: filter based on network speed (in MBPS)
        :param string public_ip: filter based on public ip address
        :param string private_ip: filter based on private ip address
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        :returns: Returns a list of dictionaries representing the matching
                  hardware. This list will contain both dedicated servers and
                  bare metal computing instances

        """
        if 'mask' not in kwargs:
            hw_items = [
                'id',
                'hostname',
                'domain',
                'hardwareStatusId',
                'globalIdentifier',
                'fullyQualifiedDomainName',
                'processorPhysicalCoreAmount',
                'memoryCapacity',
                'primaryBackendIpAddress',
                'primaryIpAddress',
                'datacenter',
            ]
            server_items = [
                'activeTransaction[id, transactionStatus[friendlyName,name]]',
            ]

            kwargs['mask'] = '[mask[%s],' \
                             ' mask(SoftLayer_Hardware_Server)[%s]]' % \
                             (','.join(hw_items),
                              ','.join(server_items))

        _filter = NestedDict(kwargs.get('filter') or {})
        if tags:
            _filter['hardware']['tagReferences']['tag']['name'] = {
                'operation': 'in',
                'options': [{'name': 'data', 'value': tags}],
            }

        if cpus:
            _filter['hardware']['processorPhysicalCoreAmount'] = \
                query_filter(cpus)

        if memory:
            _filter['hardware']['memoryCapacity'] = query_filter(memory)

        if hostname:
            _filter['hardware']['hostname'] = query_filter(hostname)

        if domain:
            _filter['hardware']['domain'] = query_filter(domain)

        if datacenter:
            _filter['hardware']['datacenter']['name'] = \
                query_filter(datacenter)

        if nic_speed:
            _filter['hardware']['networkComponents']['maxSpeed'] = \
                query_filter(nic_speed)

        if public_ip:
            _filter['hardware']['primaryIpAddress'] = \
                query_filter(public_ip)

        if private_ip:
            _filter['hardware']['primaryBackendIpAddress'] = \
                query_filter(private_ip)

        kwargs['filter'] = _filter.to_dict()
        return self.account.getHardware(**kwargs)

    def get_bare_metal_create_options(self):
        """ Retrieves the available options for creating a bare metal server.

        :returns: A dictionary of creation options. The categories to order are
                  contained within the 'categories' key. See
                  :func:`_parse_package_data` for detailed information.

        .. note::

           The information for ordering bare metal instances comes from
           multiple API calls. In order to make the process easier, this
           function will make those calls and reformat the results into a
           dictionary that's easier to manage. It's recommended that you cache
           these results with a reasonable lifetime for performance reasons.
        """
        hw_id = self.get_bare_metal_package_id()

        if not hw_id:
            return None

        return self._parse_package_data(hw_id)

    def get_bare_metal_package_id(self):
        """ Return the bare metal package id """
        packages = self.client['Product_Package'].getAllObjects(
            mask='mask[id, name]',
            filter={'name': query_filter('Bare Metal Instance')})

        hw_id = 0
        for package in packages:
            if 'Bare Metal Instance' == package['name']:
                hw_id = package['id']
                break

        return hw_id

    def get_available_dedicated_server_packages(self):
        """ Retrieves a list of packages that are available for ordering
        dedicated servers.

        :returns: A list of tuples of available dedicated server packages in
                  the form (id, name, description)
        """

        package_obj = self.client['Product_Package']
        packages = []

        # Pull back only server packages
        mask = 'id,name,description,type'
        _filter = {
            'type': {
                'keyName': {
                    'operation': 'in',
                    'options': [
                        {'name': 'data',
                         'value': ['BARE_METAL_CPU', 'BARE_METAL_CORE']}
                    ],
                },
            },
        }

        for package in package_obj.getAllObjects(mask=mask, filter=_filter):
            # Filter out packages without a name or that are designated as
            # 'OUTLET.' The outlet packages are missing some necessary data
            # and their orders will fail.
            if package.get('name') and 'OUTLET' not in package['description']:
                packages.append((package['id'], package['name'],
                                 package['description']))

        return packages

    def get_dedicated_server_create_options(self, package_id):
        """ Retrieves the available options for creating a dedicated server in
        a specific chassis (based on package ID).

        :param int package_id: The package ID to retrieve the creation options
                               for. This should come from
                               :func:`get_available_dedicated_server_packages`.
        :returns: A dictionary of creation options. The categories to order are
                  contained within the 'categories' key. See
                  :func:`_parse_package_data` for detailed information.

        .. note::

           The information for ordering dedicated servers comes from multiple
           API calls. In order to make the process simpler, this function will
           make those calls and reformat the results into a dictionary that's
           easier to manage. It's recommended that you cache these results with
           a reasonable lifetime for performance reasons.
        """
        return self._parse_package_data(package_id)

    def get_hardware(self, hardware_id, **kwargs):
        """ Get details about a hardware device

        :param integer id: the hardware ID
        :returns: A dictionary containing a large amount of information about
                  the specified server.

        """

        if 'mask' not in kwargs:
            items = [
                'id',
                'globalIdentifier',
                'fullyQualifiedDomainName',
                'hostname',
                'domain',
                'provisionDate',
                'hardwareStatus',
                'processorPhysicalCoreAmount',
                'memoryCapacity',
                'notes',
                'privateNetworkOnlyFlag',
                'primaryBackendIpAddress',
                'primaryIpAddress',
                'networkManagementIpAddress',
                'userData',
                'datacenter',
                '''networkComponents[id, status, speed, maxSpeed, name,
                   ipmiMacAddress, ipmiIpAddress, macAddress, primaryIpAddress,
                   port, primarySubnet[id, netmask, broadcastAddress,
                                       networkIdentifier, gateway]]''',
                'hardwareChassis[id,name]',
                'activeTransaction[id, transactionStatus[friendlyName,name]]',
                '''operatingSystem[
                    softwareLicense[softwareDescription[manufacturer,
                                                        name,
                                                        version,
                                                        referenceCode]],
                    passwords[username,password]]''',
                'billingItem.recurringFee',
                'hourlyBillingFlag',
                'tagReferences[id,tag[name,id]]',
                'networkVlans[id,vlanNumber,networkSpace]',
            ]
            kwargs['mask'] = "mask[%s]" % ','.join(items)

        return self.hardware.getObject(id=hardware_id, **kwargs)

    def reload(self, hardware_id, post_uri=None, ssh_keys=None):
        """ Perform an OS reload of a server with its current configuration.

        :param integer hardware_id: the instance ID to reload
        :param string post_url: The URI of the post-install script to run
                                after reload
        :param list ssh_keys: The SSH keys to add to the root user
        """

        config = {}

        if post_uri:
            config['customProvisionScriptUri'] = post_uri

        if ssh_keys:
            config['sshKeyIds'] = [key_id for key_id in ssh_keys]

        return self.hardware.reloadOperatingSystem('FORCE', config,
                                                   id=hardware_id)

    def change_port_speed(self, hardware_id, public, speed):
        """ Allows you to change the port speed of a server's NICs.

        :param int hardware_id: The ID of the server
        :param bool public: Flag to indicate which interface to change.
                            True (default) means the public interface.
                            False indicates the private interface.
        :param int speed: The port speed to set.
        """
        if public:
            func = self.hardware.setPublicNetworkInterfaceSpeed
        else:
            func = self.hardware.setPrivateNetworkInterfaceSpeed

        return func(speed, id=hardware_id)

    def place_order(self, **kwargs):
        """ Places an order for a piece of hardware.

        Translates a list of arguments into a dictionary necessary for creating
        a server.

        .. warning::
           All items here must be price IDs, NOT quantities!

        :param int server: The identification string for the server to
                           order. This will either be the CPU/Memory
                           combination ID for bare metal instances or the
                           CPU model for dedicated servers.
        :param string hostname: The hostname to use for the new server.
        :param string domain: The domain to use for the new server.
        :param bool hourly: Flag to indicate if this server should be billed
                            hourly (default) or monthly. Only applies to bare
                            metal instances.
        :param string location: The location string (data center) for the
                                server
        :param int os: The operating system to use
        :param array disks: An array of disks for the server. Disks will be
                            added in the order specified.
        :param int port_speed: The port speed for the server.
        :param bool bare_metal: Flag to indicate if this is a bare metal server
                                or a dedicated server (default).
        :param int ram: The amount of RAM to order. Only applies to dedicated
                        servers.
        :param int package_id: The package_id to use for the server. This
                               should either be a chassis ID for dedicated
                               servers or the bare metal instance package ID,
                               which can be obtained by calling
                               get_bare_metal_package_id
        :param int disk_controller: The disk controller to use.
        :param list ssh_keys: The SSH keys to add to the root user
        :param int public_vlan: The ID of the public VLAN on which you want
                                this server placed.
        :param int private_vlan: The ID of the public VLAN on which you want
                                 this server placed.
        :param string post_uri: The URI of the post-install script to run
                                after reload

        .. warning::
           Due to how the ordering structure currently works, all ordering
           takes place using price IDs rather than quantities. See the
           following sample for an example of using HardwareManager functions
           for ordering a basic server.

        ::

           # client is assumed to be an initialized SoftLayer.API.Client object
           mgr = HardwareManager(client)

           # Package ID 32 corresponds to the 'Quad Processor, Quad Core Intel'
           # package. This information can be obtained from the
           # :func:`get_available_dedicated_server_packages` function.
           options = mgr.get_dedicated_server_create_options(32)

           # Review the contents of options to find the information that
           # applies to your order. For the sake of this example, we assume
           # that your selections are a series of item IDs for each category
           # organized into a key-value dictionary.

           # This contains selections for all required categories
           selections = {
               'server': 542, # Quad Processor Quad Core Intel 7310 - 1.60GHz
               'pri_ip_addresses': 15, # 1 IP Address
               'notification': 51, # Email and Ticket
               'ram': 280, # 16 GB FB-DIMM Registered 533/667
               'bandwidth': 173, # 5000 GB Bandwidth
               'lockbox': 45, # 1 GB Lockbox
               'monitoring': 49, # Host Ping
               'disk0': 14, # 500GB SATA II (for the first disk)
               'response': 52, # Automated Notification
               'port_speed': 187, # 100 Mbps Public & Private Networks
               'power_supply': 469, # Redundant Power Supplies
               'disk_controller': 487, # Non-RAID
               'vulnerability_scanner': 307, # Nessus
               'vpn_management': 309, # Unlimited SSL VPN Users
               'remote_management': 504, # Reboot / KVM over IP
               'os': 4166, # Ubuntu Linux 12.04 LTS Precise Pangolin (64 bit)
           }

           args = {
               'location': 'FIRST_AVAILABLE', # Pick the first available DC
               'packageId': 32, # From above
               'disks': [],
           }

           for cat, item_id in selections:
               for item in options['categories'][cat]['items'].items():
                   if item['id'] == item_id:
                       if 'disk' not in cat or 'disk_controller' == cat:
                           args[cat] = item['price_id']
                       else:
                           args['disks'].append(item['price_id'])

           # You can call :func:`verify_order` here to test the order instead
           # of actually placing it if you prefer.
           result = mgr.place_order(**args)

        """
        create_options = self._generate_create_dict(**kwargs)
        return self.client['Product_Order'].placeOrder(create_options)

    def verify_order(self, **kwargs):
        """ Verifies an order for a piece of hardware without actually placing
        it. See :func:`place_order` for a list of available options.
        """
        create_options = self._generate_create_dict(**kwargs)
        return self.client['Product_Order'].verifyOrder(create_options)

    def get_cancellation_reasons(self):
        """
        Returns a dictionary of valid cancellation reasons that can be used
        when cancelling a dedicated server via :func:`cancel_hardware`.
        """
        return {
            'unneeded': 'No longer needed',
            'closing': 'Business closing down',
            'cost': 'Server / Upgrade Costs',
            'migrate_larger': 'Migrating to larger server',
            'migrate_smaller': 'Migrating to smaller server',
            'datacenter': 'Migrating to a different SoftLayer datacenter',
            'performance': 'Network performance / latency',
            'support': 'Support response / timing',
            'sales': 'Sales process / upgrades',
            'moving': 'Moving to competitor',
        }

    def _generate_create_dict(
            self, server=None, hostname=None, domain=None, hourly=False,
            location=None, os=None, disks=None, port_speed=None,
            bare_metal=None, ram=None, package_id=None, disk_controller=None,
            ssh_keys=None, public_vlan=None, private_vlan=None, post_uri=None):
        """
        Translates a list of arguments into a dictionary necessary for creating
        a server.

        .. warning::
           All items here must be price IDs, NOT quantities!

        :param int server: The identification string for the server to
                           order. This will either be the CPU/Memory
                           combination ID for bare metal instances or the
                           CPU model for dedicated servers.
        :param string hostname: The hostname to use for the new server.
        :param string domain: The domain to use for the new server.
        :param bool hourly: Flag to indicate if this server should be billed
                            hourly (default) or monthly. Only applies to bare
                            metal instances.
        :param string location: The location string (data center) for the
                                server
        :param int os: The operating system to use
        :param array disks: An array of disks for the server. Disks will be
                            added in the order specified.
        :param int port_speed: The port speed for the server.
        :param bool bare_metal: Flag to indicate if this is a bare metal server
                                or a dedicated server (default).
        :param int ram: The amount of RAM to order. Only applies to dedicated
                        servers.
        :param int package_id: The package_id to use for the server. This
                               should either be a chassis ID for dedicated
                               servers or the bare metal instance package ID,
                               which can be obtained by calling
                               get_bare_metal_package_id
        :param int disk_controller: The disk controller to use.
        :param list ssh_keys: The SSH keys to add to the root user
        :param int public_vlan: The ID of the public VLAN on which you want
                                this server placed.
        :param int private_vlan: The ID of the public VLAN on which you want
                                 this server placed.
        """
        arguments = ['server', 'hostname', 'domain', 'location', 'os', 'disks',
                     'port_speed', 'bare_metal', 'ram', 'package_id',
                     'disk_controller', 'server_core', 'disk0']

        hardware = {
            'bareMetalInstanceFlag': bare_metal,
            'hostname': hostname,
            'domain': domain,
        }

        if public_vlan:
            hardware['primaryNetworkComponent'] = {
                "networkVlan": {"id": int(public_vlan)}}
        if private_vlan:
            hardware['primaryBackendNetworkComponent'] = {
                "networkVlan": {"id": int(private_vlan)}}

        order = {
            'hardware': [hardware],
            'location': location,
            'prices': [],
        }

        if post_uri:
            order['provisionScripts'] = [post_uri]

        if ssh_keys:
            order['sshKeys'] = [{'sshKeyIds': ssh_keys}]

        if bare_metal:
            order['packageId'] = self.get_bare_metal_package_id()
            order['prices'].append({'id': int(server)})
            p_options = self.get_bare_metal_create_options()
            if hourly:
                order['useHourlyPricing'] = True
        else:
            order['packageId'] = package_id
            order['prices'].append({'id': int(server)})
            p_options = self.get_dedicated_server_create_options(package_id)

        if disks:
            for disk in disks:
                order['prices'].append({'id': int(disk)})

        if os:
            order['prices'].append({'id': int(os)})

        if port_speed:
            order['prices'].append({'id': int(port_speed)})

        if ram:
            order['prices'].append({'id': int(ram)})

        if disk_controller:
            order['prices'].append({'id': int(disk_controller)})

        # Find all remaining required categories so we can auto-default them
        required_fields = []
        for category, data in p_options['categories'].items():
            if data.get('is_required') and category not in arguments:
                if 'disk' in category:
                    # This block makes sure that we can default unspecified
                    # disks if the user hasn't specified enough.
                    disk_count = int(category.replace('disk', ''))
                    if len(disks) >= disk_count + 1:
                        continue
                required_fields.append(category)

        for category in required_fields:
            price = get_default_value(p_options, category, hourly=hourly)
            order['prices'].append({'id': price})

        return order

    def _get_ids_from_hostname(self, hostname):
        """ Returns list of matching hardware IDs for a given hostname """
        results = self.list_hardware(hostname=hostname, mask="id")
        return [result['id'] for result in results]

    def _get_ids_from_ip(self, ip):
        """ Returns list of matching hardware IDs for a given ip address """
        try:
            # Does it look like an ip address?
            socket.inet_aton(ip)
        except socket.error:
            return []

        # Find the server via ip address. First try public ip, then private
        results = self.list_hardware(public_ip=ip, mask="id")
        if results:
            return [result['id'] for result in results]

        results = self.list_hardware(private_ip=ip, mask="id")
        if results:
            return [result['id'] for result in results]

    def _parse_package_data(self, package_id):
        """
        Parses data from the specified package into a consistent dictionary.

        The data returned by the API varies significantly from one package
        to another, which means that consuming it can make your program more
        complicated than desired. This function will make all necessary API
        calls for the specified package ID and build the results into a
        consistently formatted dictionary like so:

        result = {
            'locations': [{'delivery_information': <string>,
                           'keyname': <string>,
                           'long_name': <string>}],
            'categories': {
                'category_code': {
                    'sort': <int>,
                    'step': <int>,
                    'is_required': <bool>,
                    'name': <string>,
                    'group': <string>,
                    'items': [
                        {
                            'id': <int>,
                            'description': <string>,
                            'sort': <int>,
                            'price_id': <int>,
                            'recurring_fee': <float>,
                            'setup_fee': <float>,
                            'hourly_recurring_fee': <float>,
                            'one_time_fee': <float>,
                            'labor_fee': <float>,
                            'capacity': <float>,
                        }
                    ]
                }
            }
        }

        Your code can rely upon each of those elements always being present.
        Each list will contain at least one entry as well, though most will
        contain more than one.
        """
        package = self.client['Product_Package']

        results = {
            'categories': {},
            'locations': []
        }

        # First pull the list of available locations. We do it with the
        # getObject() call so that we get access to the delivery time info.
        object_data = package.getRegions(id=package_id)

        for loc in object_data:
            details = loc['location']['locationPackageDetails'][0]

            results['locations'].append({
                'delivery_information': details.get('deliveryTimeInformation'),
                'keyname': loc['keyname'],
                'long_name': loc['description'],
            })

        mask = 'mask[itemCategory[group]]'

        for config in package.getConfiguration(id=package_id, mask=mask):
            code = config['itemCategory']['categoryCode']
            group = NestedDict(config['itemCategory']) or {}
            category = {
                'sort': config['sort'],
                'step': config['orderStepId'],
                'is_required': config['isRequired'],
                'name': config['itemCategory']['name'],
                'group': group['group']['name'],
                'items': [],
            }

            results['categories'][code] = category

        # Now pull in the available package item
        for category in package.getCategories(id=package_id):
            code = category['categoryCode']
            items = []

            for group in category['groups']:
                for price in group['prices']:
                    items.append({
                        'id': price['itemId'],
                        'description': price['item']['description'],
                        'sort': price['sort'],
                        'price_id': price['id'],
                        'recurring_fee': price.get('recurringFee'),
                        'setup_fee': price.get('setupFee'),
                        'hourly_recurring_fee':
                        price.get('hourlyRecurringFee'),
                        'one_time_fee': price.get('oneTimeFee'),
                        'labor_fee': price.get('laborFee'),
                        'capacity': float(price['item'].get('capacity', 0)),
                    })
            results['categories'][code]['items'] = items

        return results

    def edit(self, hardware_id, userdata=None, hostname=None, domain=None,
             notes=None):
        """ Edit hostname, domain name, notes, and/or the user data of the
        hardware

        Parameters set to None will be ignored and not attempted to be updated.

        :param integer hardware_id: the instance ID to edit
        :param string userdata: user data on the hardware to edit.
                                If none exist it will be created
        :param string hostname: valid hostname
        :param string domain: valid domain name
        :param string notes: notes about this particular hardware

        """

        obj = {}
        if userdata:
            self.hardware.setUserMetadata([userdata], id=hardware_id)

        if hostname:
            obj['hostname'] = hostname

        if domain:
            obj['domain'] = domain

        if notes:
            obj['notes'] = notes

        if not obj:
            return True

        return self.hardware.editObject(obj, id=hardware_id)


def get_default_value(package_options, category, hourly=False):
    """ Returns the default price ID for the specified category.

    This determination is made by parsing the items in the package_options
    argument and finding the first item that has zero specified for every fee
    field.

    .. note::
       If the category has multiple items with no fee, this will return the
       first it finds and then short circuit. This may not match the default
       value presented on the SoftLayer ordering portal. Additionally, this
       method will return None if there are no free items in the category.

    :returns: Returns the price ID of the first free item it finds or None
              if there are no free items.
    """
    if category not in package_options['categories']:
        return

    for item in package_options['categories'][category]['items']:
        if hourly:
            if item.get('hourly_recurring_fee') is None:
                continue
        else:
            if item.get('recurring_fee') is None:
                continue

        if not any([float(item.get('setup_fee') or 0),
                    float(item.get('recurring_fee') or 0),
                    float(item.get('hourly_recurring_fee') or 0),
                    float(item.get('one_time_fee') or 0),
                    float(item.get('labor_fee') or 0)]):
            return item['price_id']

########NEW FILE########
__FILENAME__ = image
"""
    SoftLayer.image
    ~~~~~~~~~~~~~~~
    Image Manager/helpers

    :license: MIT, see LICENSE for more details.
"""

from SoftLayer.utils import query_filter, NestedDict, IdentifierMixin

IMAGE_MASK = ('id,accountId,name,globalIdentifier,blockDevices,parentId,'
              'createDate')


class ImageManager(IdentifierMixin, object):
    """
    Manages server images

    :param SoftLayer.API.Client client: an API client instance
    """

    def __init__(self, client):
        self.client = client
        self.vgbdtg = self.client['Virtual_Guest_Block_Device_Template_Group']
        self.resolvers = [self._get_ids_from_name_public,
                          self._get_ids_from_name_private]

    def get_image(self, image_id, **kwargs):
        """ Get details about an image

        :param int image: The ID of the image.
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        """
        if 'mask' not in kwargs:
            kwargs['mask'] = IMAGE_MASK

        return self.vgbdtg.getObject(id=image_id, **kwargs)

    def delete_image(self, image_id):
        """ deletes the specified image.

        :param int image: The ID of the image.
        """
        self.vgbdtg.deleteObject(id=image_id)

    def list_private_images(self, guid=None, name=None, **kwargs):
        """ List all private images.

        :param string guid: filter based on GUID
        :param string name: filter based on name
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        """
        if 'mask' not in kwargs:
            kwargs['mask'] = IMAGE_MASK

        _filter = NestedDict(kwargs.get('filter') or {})
        if name:
            _filter['privateBlockDeviceTemplateGroups']['name'] = \
                query_filter(name)

        if guid:
            _filter['privateBlockDeviceTemplateGroups']['globalIdentifier'] = \
                query_filter(guid)

        kwargs['filter'] = _filter.to_dict()

        account = self.client['Account']
        return account.getPrivateBlockDeviceTemplateGroups(**kwargs)

    def list_public_images(self, guid=None, name=None, **kwargs):
        """ List all public images.

        :param string guid: filter based on GUID
        :param string name: filter based on name
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        """
        if 'mask' not in kwargs:
            kwargs['mask'] = IMAGE_MASK

        _filter = NestedDict(kwargs.get('filter') or {})
        if name:
            _filter['name'] = query_filter(name)

        if guid:
            _filter['globalIdentifier'] = query_filter(guid)

        kwargs['filter'] = _filter.to_dict()

        return self.vgbdtg.getPublicImages(**kwargs)

    def _get_ids_from_name_public(self, name):
        """ Get public images which match the given name """
        results = self.list_public_images(name=name)
        return [result['id'] for result in results]

    def _get_ids_from_name_private(self, name):
        """ Get private images which match the given name """
        results = self.list_private_images(name=name)
        return [result['id'] for result in results]

    def edit(self, image_id, name=None, note=None, tag=None):
        """
        Edit image related details
        :param int image: The ID of the image
        :param string name: Name of the Image.
        :param string note: Note of the image.
        :param string tag: Tags of the image to be updated to.
        """
        obj = {}
        if name:
            obj['name'] = name
        if note:
            obj['note'] = note
        if obj:
            self.vgbdtg.editObject(obj, id=image_id)
        if tag:
            self.vgbdtg.setTags(str(tag), id=image_id)
        if name or note or tag:
            return True
        else:
            return False

########NEW FILE########
__FILENAME__ = iscsi
"""
    SoftLayer.iscsi
    ~~~~~~~~~~~~~~~
    ISCSI Manager/helpers
"""
from SoftLayer.utils import IdentifierMixin


class ISCSIManager(IdentifierMixin, object):

    """ Manages iSCSI storages """

    def __init__(self, client):
        self.configuration = {}
        self.client = client
        self.iscsi_svc = self.client['Network_Storage_Iscsi']
        self.product_order = self.client['Product_Order']

    def _find_item_prices(self, size, categorycode=''):
        """ Retrieves the Item Price IDs
        """
        item_prices = self.client['Product_Package'].getItems(
            id=0,
            mask='id,capacity,prices[id]',
            filter={
                'items': {
                    'capacity': {'operation': int(size)},
                    'categories': {
                        'categoryCode': {'operation': categorycode}
                    }}})
        item_price = item_prices[0]['prices'][0]['id']
        return item_price

    def _build_order(self, item_price, location):
        """ Returns a dict appropriate to pass into Product_Order::placeOrder()
        """

        location_id = self._get_location_id(location)
        order = {
            'complexType':
            'SoftLayer_Container_Product_Order_Network_Storage_Iscsi',
            'location': location_id,
            'packageId': 0,  # storage package
            'prices': [{'id': item_price}],
            'quantity': 1
        }
        return order

    def _get_location_id(self, location):
        """ Returns location id of datacenter to pass into
            ProductOrder::placeOrder()
        """
        loc_svc = self.client['Location_Datacenter']
        datacenters = loc_svc.getDatacenters(mask='mask[longName,id,name]')
        for datacenter in datacenters:
            if datacenter['name'] == location:
                location = datacenter['id']
                return location
        raise ValueError('Invalid datacenter name specified.')

    def create_iscsi(self, size=None, location=None):
        """Places an order for iSCSI volume
        :param integer size: size of iSCSI volume to create
        :param string location: datacenter to use to create volume in
        """
        item_price = self._find_item_prices(int(size),
                                            categorycode='iscsi')
        iscsi_order = self._build_order(item_price, location)
        self.product_order.verifyOrder(iscsi_order)
        self.product_order.placeOrder(iscsi_order)

    def list_iscsi(self):
        """List iSCSI volume
        """
        account = self.client['Account']
        iscsi_list = account.getIscsiNetworkStorage(
            mask='eventCount,serviceResource[datacenter.name]')
        return iscsi_list

    def get_iscsi(self, volume_id, **kwargs):
        """ Get details about a iSCSI storage

        :param integer volume_id: the volume ID
        :returns: A dictionary containing a large amount of information about
                  the specified storage.

        """

        if 'mask' not in kwargs:
            items = [
                'id',
                'serviceResourceName',
                'createDate',
                'nasType',
                'capacityGb',
                'snapshotCapacityGb',
                'mountableFlag',
                'serviceResourceBackendIpAddress',
                'billingItem',
                'notes',
                'username',
                'password'
            ]
            kwargs['mask'] = "mask[%s]" % ','.join(items)
        return self.iscsi_svc.getObject(id=volume_id, **kwargs)

    def cancel_iscsi(self, volume_id, reason='unNeeded', immediate=False):
        """ Cancels the given iSCSI volume

        :param integer volume_id: the volume ID

        """
        iscsi = self.get_iscsi(
            volume_id,
            mask='mask[id,capacityGb,username,password,billingItem[id]]')
        billingitemid = iscsi['billingItem']['id']
        self.client['Billing_Item'].cancelItem(
            immediate,
            True,
            reason,
            id=billingitemid)

    def create_snapshot(self, volume_id, notes='No longer needed'):
        """ Orders a snapshot for given volume

        :param integer volume_id: the volume ID
        """

        self.iscsi_svc.createSnapshot(notes, id=volume_id)

    def create_snapshot_space(self, volume_id, capacity):
        """ Orders a snapshot space for given volume

        :param integer volume_id: the volume ID
        :param integer capacity: capacity in ~GB
        """
        item_price = self._find_item_prices(
            int(capacity), categorycode='iscsi_snapshot_space')
        result = self.get_iscsi(
            volume_id, mask='mask[id,capacityGb,serviceResource[datacenter]]')
        snapshotspaceorder = {
            'complexType':
            'SoftLayer_Container_Product_Order_\
Network_Storage_Iscsi_SnapshotSpace',
            'location': result['serviceResource']['datacenter']['id'],
            'packageId': 0,
            'prices': [{'id': item_price}],
            'quantity': 1,
            'volumeId': volume_id}
        self.product_order.verifyOrder(snapshotspaceorder)
        self.product_order.placeOrder(snapshotspaceorder)

    def delete_snapshot(self, snapshot_id):
        """ Deletes the given snapshot

        :params: integer snapshot_id: the snapshot ID
        """

        self.iscsi_svc.deleteObject(id=snapshot_id)

    def restore_from_snapshot(self, volume_id, snapshot_id):
        """ Restore the volume to snapshot's contents
        :params: imteger volume_id: the volume ID
        :params: integer snapshot_id: the snapshot ID
        """
        self.iscsi_svc.restoreFromSnapshot(snapshot_id, id=volume_id)

########NEW FILE########
__FILENAME__ = load_balancer
"""
    SoftLayer.load_balancer
    ~~~~~~~~~~~~~~~~~~
    Load Balancer Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.utils import IdentifierMixin, NestedDict, query_filter


class LoadBalancerManager(IdentifierMixin, object):

    """ Manages load balancers.
    :param SoftLayer.API.Client client: the API client instance
    """

    def __init__(self, client):
        self.client = client
        self.account = self.client['Account']
        self.prod_pkg = self.client['Product_Package']
        self.lb_svc = self.client['Network_Application_Delivery_Controller_'
                                  'LoadBalancer_VirtualIpAddress']

    def get_lb_pkgs(self):
        """ Retrieves the local load balancer packages.

        :returns: A dictionary containing the load balancer packages
        """

        lb_filter = '*Load Balancer*'
        _filter = NestedDict({})
        _filter['items']['description'] = query_filter(lb_filter)

        kwargs = NestedDict({})
        kwargs['id'] = 0  # look at package id 0
        kwargs['filter'] = _filter.to_dict()
        packages = self.prod_pkg.getItems(**kwargs)
        pkgs = []
        for package in packages:
            if not package['description'].startswith('Global'):
                pkgs.append(package)
        return pkgs

    def get_ip_address(self, ip_address=None):
        """ Retrieves the IP address object given the ip address itself

        :returns: A dictionary containing the IP address properties
        """
        svc = self.client['Network_Subnet_IpAddress']
        return svc.getByIpAddress(ip_address)

    def get_hc_types(self):
        """ Retrieves the health check type values

        :returns: A dictionary containing the health check types
        """
        svc = self.client['Network_Application_Delivery_Controller_'
                          'LoadBalancer_Health_Check_Type']
        return svc.getAllObjects()

    def get_routing_methods(self):
        """ Retrieves the load balancer routing methods.

        :returns: A dictionary containing the load balancer routing methods
        """
        svc = self.client['Network_Application_Delivery_Controller_'
                          'LoadBalancer_Routing_Method']
        return svc.getAllObjects()

    def get_routing_types(self):
        """ Retrieves the load balancer routing types.

        :returns: A dictionary containing the load balancer routing types
        """
        svc = self.client['Network_Application_Delivery_Controller_'
                          'LoadBalancer_Routing_Type']
        return svc.getAllObjects()

    def get_location(self, datacenter):
        """ Returns the location of the specified datacenter

        :param string datacenter: The datacenter to create the loadbalancer in

        :returns: the location id of the given datacenter
        """
        dcenters = self.client['Location'].getDataCenters()
        for dcenter in dcenters:
            if dcenter['name'] == datacenter:
                return dcenter['id']
        return 'FIRST_AVAILABLE'

    def cancel_lb(self, loadbal_id):
        """ Cancels the specified load balancer.

        :param int loadbal_id: Load Balancer ID to be cancelled.
        """
        lb_billing = self.lb_svc.getBillingItem(id=loadbal_id)
        billing_id = lb_billing['id']
        billing_item = self.client['Billing_Item']
        return billing_item.cancelService(id=billing_id)

    def add_local_lb(self, price_item_id, datacenter):
        """ Creates a local load balancer in the specified data center

        :param int price_item_id: The price item ID for the load balancer
        :param string datacenter: The datacenter to create the loadbalancer in

        :returns: A dictionary containing the product order
        """
        product_order = {
            'complexType': 'SoftLayer_Container_Product_Order_Network_'
                           'LoadBalancer',
            'quantity': 1,
            'packageId': 0,
            "location": self.get_location(datacenter),
            'prices': [{'id': price_item_id}]
        }
        return self.client['Product_Order'].placeOrder(product_order)

    def get_local_lbs(self):
        """ Returns a list of all local load balancers on the account.

        :returns: A list of all local load balancers on the current account.
        """
        mask = ('mask[loadBalancerHardware[datacenter],ipAddress]')
        return self.account.getAdcLoadBalancers(mask=mask)

    def get_local_lb(self, loadbal_id, **kwargs):
        """ Returns a specified local load balancer given the id.
        :param int loadbal_id: The id of the load balancer to retrieve

        :returns: A dictionary containing the details of the load balancer
        """
        # virtualServers.serviceGroups.services.ipAddress
        if 'mask' not in kwargs:
            kwargs['mask'] = ('mask[loadBalancerHardware[datacenter], '
                              'ipAddress, virtualServers[serviceGroups'
                              '[routingMethod,routingType,services'
                              '[healthChecks[type], groupReferences,'
                              ' ipAddress]]]]')

        return self.lb_svc.getObject(id=loadbal_id, **kwargs)

    def delete_service(self, service_id):
        """ Deletes a service from the loadbal_id

        :param int service_id: The id of the service to delete
        """
        svc = self.client['Network_Application_Delivery_Controller_'
                          'LoadBalancer_Service']

        return svc.deleteObject(id=service_id)

    def delete_service_group(self, group_id):
        """ Deletes a service group from the loadbal_id

        :param int group_id: The id of the service group to delete
        """
        svc = self.client['Network_Application_Delivery_Controller_'
                          'LoadBalancer_VirtualServer']

        return svc.deleteObject(id=group_id)

    def toggle_service_status(self, service_id):
        """ Toggles the service status

        :param int service_id: The id of the service to delete
        """
        svc = self.client['Network_Application_Delivery_Controller_'
                          'LoadBalancer_Service']
        return svc.toggleStatus(id=service_id)

    def edit_service(self, loadbal_id, service_id, ip_address_id=None,
                     port=None, enabled=None, hc_type=None, weight=None):
        """ Edits an existing service properties
        :param int loadbal_id: The id of the loadbal where the service resides
        :param int service_id: The id of the service to edit
        :param string ip_address: The ip address of the service
        :param int port: the port of the service
        :param int enabled: 1 to enable the service, 0 to disable it
        :param int hc_type: The health check type
        :param int weight: the weight to give to the service
        """
        _filter = NestedDict({})
        _filter['virtualServers']['serviceGroups']['services']['id'] = \
            query_filter(service_id)

        kwargs = NestedDict({})
        kwargs['filter'] = _filter.to_dict()
        kwargs['mask'] = ('mask[serviceGroups[services[groupReferences,'
                          'healthChecks]]]')

        virtual_servers = self.lb_svc.getVirtualServers(id=loadbal_id,
                                                        **kwargs)
        for service in virtual_servers[0]['serviceGroups'][0]['services']:
            if service['id'] == service_id:
                if enabled is not None:
                    service['enabled'] = int(enabled)
                if port is not None:
                    service['port'] = int(port)
                if weight is not None:
                    service['groupReferences'][0]['weight'] = int(weight)
                if hc_type is not None:
                    service['healthChecks'][0]['healthCheckTypeId'] = \
                        int(hc_type)
                if ip_address_id is not None:
                    service['ipAddressId'] = ip_address_id

        template = {'virtualServers': virtual_servers}

        load_balancer = self.lb_svc.editObject(template, id=loadbal_id)
        return load_balancer

    def add_service(self, loadbal_id, service_group_id, ip_address_id,
                    port=80, enabled=1, hc_type=21, weight=1):
        """ Adds a new service to the service group
        :param int loadbal_id: The id of the loadbal where the service resides
        :param int service_group_id: The group to add the service to
        :param int ip_address id: The ip address ID of the service
        :param int port: the port of the service
        :param int enabled: 1 to enable the service, 0 to disable it
        :param int hc_type: The health check type
        :param int weight: the weight to give to the service
        """
        kwargs = NestedDict({})
        kwargs['mask'] = ('mask[virtualServers[serviceGroups'
                          '[services[groupReferences]]]]')

        load_balancer = self.lb_svc.getObject(id=loadbal_id, **kwargs)
        virtual_servers = load_balancer['virtualServers']
        for virtual_server in virtual_servers:
            if virtual_server['id'] == service_group_id:
                service_template = {
                    'enabled': enabled,
                    'port': port,
                    'ipAddressId': ip_address_id,
                    'healthChecks': [
                        {
                            'healthCheckTypeId': hc_type
                        }
                    ],
                    'groupReferences': [
                        {
                            'weight': weight
                        }
                    ]
                    }
                virtual_server['serviceGroups'][0]['services']. \
                    append(service_template)

        return self.lb_svc.editObject(load_balancer, id=loadbal_id)

    def add_service_group(self, lb_id, allocation=100, port=80,
                          routing_type=2, routing_method=10):
        """ Adds a new service group to the load balancer
        :param int loadbal_id: The id of the loadbal where the service resides
        :param int allocation: the % of connections to allocate to the group
        :param int port: the port of the service group
        :param int routing_type: the routing type to set on the service group
        :param int routing_method: The routing method to set on the group
        """
        kwargs = NestedDict({})
        kwargs['mask'] = ('mask[virtualServers[serviceGroups'
                          '[services[groupReferences]]]]')
        load_balancer = self.lb_svc.getObject(id=lb_id, **kwargs)
        virtual_servers = load_balancer['virtualServers']
        service_template = {
            'port': port,
            'allocation': allocation,
            'serviceGroups': [
                {
                    'routingTypeId': routing_type,
                    'routingMethodId': routing_method
                }
            ]
        }

        virtual_servers.append(service_template)
        return self.lb_svc.editObject(load_balancer, id=lb_id)

    def edit_service_group(self, loadbal_id, group_id, allocation=None,
                           port=None, routing_type=None, routing_method=None):
        """ Edit an existing service group
        :param int loadbal_id: The id of the loadbal where the service resides
        :param int group_id: The id of the service group
        :param int allocation: the % of connections to allocate to the group
        :param int port: the port of the service group
        :param int routing_type: the routing type to set on the service group
        :param int routing_method: The routing method to set on the group
        """
        kwargs = NestedDict({})
        kwargs['mask'] = ('mask[virtualServers[serviceGroups'
                          '[services[groupReferences]]]]')

        load_balancer = self.lb_svc.getObject(id=loadbal_id, **kwargs)
        virtual_servers = load_balancer['virtualServers']
        for virtual_server in virtual_servers:
            if virtual_server['id'] == group_id:
                service_group = virtual_server['serviceGroups'][0]
                if allocation is not None:
                    virtual_server['allocation'] = int(allocation)
                if port is not None:
                    virtual_server['port'] = int(port)
                if routing_type is not None:
                    service_group['routingTypeId'] = int(routing_type)
                if routing_method is not None:
                    service_group['routingMethodId'] = int(routing_method)
                break
        return self.lb_svc.editObject(load_balancer, id=loadbal_id)

    def reset_service_group(self, loadbal_id, group_id):
        """ Resets all the connections on the service group
        :param int loadbal_id: The id of the loadbal
        :param int group_id: The id of the service group to reset
        """
        _filter = NestedDict({})
        _filter['virtualServers']['id'] = query_filter(group_id)

        kwargs = NestedDict({})
        kwargs['filter'] = _filter.to_dict()
        kwargs['mask'] = 'mask[serviceGroups]'

        virtual_servers = self.lb_svc.getVirtualServers(id=loadbal_id,
                                                        **kwargs)
        actual_id = virtual_servers[0]['serviceGroups'][0]['id']

        svc = self.client['Network_Application_Delivery_Controller'
                          '_LoadBalancer_Service_Group']
        return svc.kickAllConnections(id=actual_id)

########NEW FILE########
__FILENAME__ = messaging
"""
    SoftLayer.messaging
    ~~~~~~~~~~~~~~~~~~~
    Manager for the SoftLayer Message Queue service

    :license: MIT, see LICENSE for more details.
"""
import json
import requests.auth

from SoftLayer.consts import USER_AGENT
from SoftLayer.exceptions import Unauthenticated, SoftLayerError

ENDPOINTS = {
    "dal05": {
        "public": "dal05.mq.softlayer.net",
        "private": "dal05.mq.service.networklayer.com"
    }
}


class QueueAuth(requests.auth.AuthBase):
    """ Message Queue authentication for requests

    :param endpoint: endpoint URL
    :param username: SoftLayer username
    :param api_key: SoftLayer API Key
    :param auth_token: (optional) Starting auth token
    """
    def __init__(self, endpoint, username, api_key, auth_token=None):
        self.endpoint = endpoint
        self.username = username
        self.api_key = api_key
        self.auth_token = auth_token

    def auth(self):
        """ Do Authentication """
        headers = {
            'X-Auth-User': self.username,
            'X-Auth-Key': self.api_key
        }
        resp = requests.post(self.endpoint, headers=headers)
        if resp.ok:
            self.auth_token = resp.headers['X-Auth-Token']
        else:
            raise Unauthenticated("Error while authenticating: %s"
                                  % resp.status_code)

    def handle_error(self, resp, **_):
        """ Handle errors """
        resp.request.deregister_hook('response', self.handle_error)
        if resp.status_code == 503:
            resp.connection.send(resp.request)
        elif resp.status_code == 401:
            self.auth()
            resp.request.headers['X-Auth-Token'] = self.auth_token
            resp.connection.send(resp.request)

    def __call__(self, resp):
        """ Attach auth token to the request. Do authentication if an auth
            token isn't available
        """
        if not self.auth_token:
            self.auth()
        resp.register_hook('response', self.handle_error)
        resp.headers['X-Auth-Token'] = self.auth_token
        return resp


class MessagingManager(object):
    """ Manage SoftLayer Message Queue """
    def __init__(self, client):
        self.client = client

    def list_accounts(self, **kwargs):
        """ List message queue accounts

        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        """
        if 'mask' not in kwargs:
            items = [
                'id',
                'name',
                'status',
                'nodes',
            ]
            kwargs['mask'] = "mask[%s]" % ','.join(items)

        return self.client['Account'].getMessageQueueAccounts(**kwargs)

    def get_endpoint(self, datacenter=None, network=None):
        """ Get a message queue endpoint based on datacenter/network type

        :param datacenter: datacenter code
        :param network: network ('public' or 'private')
        """
        if datacenter is None:
            datacenter = 'dal05'
        if network is None:
            network = 'public'
        try:
            host = ENDPOINTS[datacenter][network]
            return "https://%s" % host
        except KeyError:
            raise TypeError('Invalid endpoint %s/%s'
                            % (datacenter, network))

    def get_endpoints(self):
        """ Get all known message queue endpoints """
        return ENDPOINTS

    def get_connection(self, account_id, datacenter=None, network=None):
        """ Get connection to Message Queue Service

        :param account_id: Message Queue Account id
        :param datacenter: Datacenter code
        :param network: network ('public' or 'private')
        """
        if not self.client.auth \
                or not getattr(self.client.auth, 'username', None) \
                or not getattr(self.client.auth, 'api_key', None):
            raise SoftLayerError(
                'Client instance auth must be BasicAuthentication.')

        client = MessagingConnection(
            account_id, endpoint=self.get_endpoint(datacenter, network))
        client.authenticate(self.client.auth.username,
                            self.client.auth.api_key)
        return client

    def ping(self, datacenter=None, network=None):
        """ Ping a message queue endpoint """
        resp = requests.get('%s/v1/ping' %
                            self.get_endpoint(datacenter, network))
        resp.raise_for_status()
        return True


class MessagingConnection(object):
    """ Message Queue Service Connection

    :param account_id: Message Queue Account id
    :param endpoint: Endpoint URL
    """
    def __init__(self, account_id, endpoint=None):
        self.account_id = account_id
        self.endpoint = endpoint
        self.auth = None

    def _make_request(self, method, path, **kwargs):
        """ Make request. Generally not called directly

        :param method: HTTP Method
        :param path: resource Path
        :param dict \\*\\*kwargs: extra request arguments
        """
        headers = {
            'Content-Type': 'application/json',
            'User-Agent': USER_AGENT,
        }
        headers.update(kwargs.get('headers', {}))
        kwargs['headers'] = headers
        kwargs['auth'] = self.auth

        url = '/'.join((self.endpoint, 'v1', self.account_id, path))
        resp = requests.request(method, url, **kwargs)
        resp.raise_for_status()
        return resp

    def authenticate(self, username, api_key, auth_token=None):
        """ Make request. Generally not called directly

        :param username: SoftLayer username
        :param api_key: SoftLayer API Key
        :param auth_token: (optional) Starting auth token
        """
        auth_endpoint = '/'.join((self.endpoint, 'v1',
                                  self.account_id, 'auth'))
        auth = QueueAuth(auth_endpoint, username, api_key,
                         auth_token=auth_token)
        auth.auth()
        self.auth = auth

    def stats(self, period='hour'):
        """ Get account stats

        :param period: 'hour', 'day', 'week', 'month'
        """
        resp = self._make_request('get', 'stats/%s' % period)
        return resp.json()

    # QUEUE METHODS

    def get_queues(self, tags=None):
        """ Get listing of queues

        :param list tags: (optional) list of tags to filter by
        """
        params = {}
        if tags:
            params['tags'] = ','.join(tags)
        resp = self._make_request('get', 'queues', params=params)
        return resp.json()

    def create_queue(self, queue_name, **kwargs):
        """ Create Queue

        :param queue_name: Queue Name
        :param dict \\*\\*kwargs: queue options
        """
        queue = {}
        queue.update(kwargs)
        data = json.dumps(queue)
        resp = self._make_request('put', 'queues/%s' % queue_name, data=data)
        return resp.json()

    def modify_queue(self, queue_name, **kwargs):
        """ Modify Queue

        :param queue_name: Queue Name
        :param dict \\*\\*kwargs: queue options
        """
        return self.create_queue(queue_name, **kwargs)

    def get_queue(self, queue_name):
        """ Get queue details

        :param queue_name: Queue Name
        """
        resp = self._make_request('get', 'queues/%s' % queue_name)
        return resp.json()

    def delete_queue(self, queue_name, force=False):
        """ Delete Queue

        :param queue_name: Queue Name
        :param force: (optional) Force queue to be deleted even if there
                      are pending messages
        """
        params = {}
        if force:
            params['force'] = 1
        self._make_request('delete', 'queues/%s' % queue_name, params=params)
        return True

    def push_queue_message(self, queue_name, body, **kwargs):
        """ Create Queue Message

        :param queue_name: Queue Name
        :param body: Message body
        :param dict \\*\\*kwargs: Message options
        """
        message = {'body': body}
        message.update(kwargs)
        resp = self._make_request('post', 'queues/%s/messages' % queue_name,
                                  data=json.dumps(message))
        return resp.json()

    def pop_messages(self, queue_name, count=1):
        """ Pop messages from a queue

        :param queue_name: Queue Name
        :param count: (optional) number of messages to retrieve
        """
        resp = self._make_request('get', 'queues/%s/messages' % queue_name,
                                  params={'batch': count})
        return resp.json()

    def pop_message(self, queue_name):
        """ Pop a single message from a queue. If no messages are returned
            this returns None

        :param queue_name: Queue Name
        """
        messages = self.pop_messages(queue_name, count=1)
        if messages['item_count'] > 0:
            return messages['items'][0]
        else:
            return None

    def delete_message(self, queue_name, message_id):
        """ Delete a message

        :param queue_name: Queue Name
        :param message_id: Message id
        """
        self._make_request('delete', 'queues/%s/messages/%s'
                           % (queue_name, message_id))
        return True

    # TOPIC METHODS

    def get_topics(self, tags=None):
        """ Get listing of topics

        :param list tags: (optional) list of tags to filter by
        """
        params = {}
        if tags:
            params['tags'] = ','.join(tags)
        resp = self._make_request('get', 'topics', params=params)
        return resp.json()

    def create_topic(self, topic_name, **kwargs):
        """ Create Topic

        :param topic_name: Topic Name
        :param dict \\*\\*kwargs: Topic options
        """
        data = json.dumps(kwargs)
        resp = self._make_request('put', 'topics/%s' % topic_name, data=data)
        return resp.json()

    def modify_topic(self, topic_name, **kwargs):
        """ Modify Topic

        :param topic_name: Topic Name
        :param dict \\*\\*kwargs: Topic options
        """
        return self.create_topic(topic_name, **kwargs)

    def get_topic(self, topic_name):
        """ Get topic details

        :param topic_name: Topic Name
        """
        resp = self._make_request('get', 'topics/%s' % topic_name)
        return resp.json()

    def delete_topic(self, topic_name, force=False):
        """ Delete Topic

        :param topic_name: Topic Name
        :param force: (optional) Force topic to be deleted even if there
                      are attached subscribers
        """
        params = {}
        if force:
            params['force'] = 1
        self._make_request('delete', 'topics/%s' % topic_name, params=params)
        return True

    def push_topic_message(self, topic_name, body, **kwargs):
        """ Create Topic Message

        :param topic_name: Topic Name
        :param body: Message body
        :param dict \\*\\*kwargs: Topic message options
        """
        message = {'body': body}
        message.update(kwargs)
        resp = self._make_request('post', 'topics/%s/messages' % topic_name,
                                  data=json.dumps(message))
        return resp.json()

    def get_subscriptions(self, topic_name):
        """ Listing of subscriptions on a topic

        :param topic_name: Topic Name
        """
        resp = self._make_request('get',
                                  'topics/%s/subscriptions' % topic_name)
        return resp.json()

    def create_subscription(self, topic_name, subscription_type, **kwargs):
        """ Create Subscription

        :param topic_name: Topic Name
        :param subscription_type: type ('queue' or 'http')
        :param dict \\*\\*kwargs: Subscription options
        """
        resp = self._make_request(
            'post', 'topics/%s/subscriptions' % topic_name,
            data=json.dumps({
                'endpoint_type': subscription_type, 'endpoint': kwargs}))
        return resp.json()

    def delete_subscription(self, topic_name, subscription_id):
        """ Delete a subscription

        :param topic_name: Topic Name
        :param subscription_id: Subscription id
        """
        self._make_request('delete', 'topics/%s/subscriptions/%s' %
                           (topic_name, subscription_id))
        return True

########NEW FILE########
__FILENAME__ = metadata
"""
    SoftLayer.metadata
    ~~~~~~~~~~~~~~~~~~
    Metadata Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.transports import make_rest_api_call
from SoftLayer.consts import API_PRIVATE_ENDPOINT_REST, USER_AGENT
from SoftLayer.exceptions import SoftLayerAPIError, SoftLayerError


METADATA_MAPPING = {
    'backend_mac': {'call': 'BackendMacAddresses'},
    'datacenter': {'call': 'Datacenter'},
    'datacenter_id': {'call': 'DatacenterId'},
    'domain': {'call': 'Domain'},
    'frontend_mac': {'call': 'FrontendMacAddresses'},
    'fqdn': {'call': 'FullyQualifiedDomainName'},
    'hostname': {'call': 'Hostname'},
    'id': {'call': 'Id'},
    'primary_backend_ip': {'call': 'PrimaryBackendIpAddress'},
    'primary_ip': {'call': 'PrimaryIpAddress'},
    'primary_frontend_ip': {'call': 'PrimaryIpAddress'},
    'provision_state': {'call': 'ProvisionState'},
    'router': {'call': 'Router', 'param_req': True},
    'tags': {'call': 'Tags'},
    'user_data': {'call': 'UserMetadata'},
    'user_metadata': {'call': 'UserMetadata'},
    'vlan_ids': {'call': 'VlanIds', 'param_req': True},
    'vlans': {'call': 'Vlans', 'param_req': True},
}
METADATA_ATTRIBUTES = METADATA_MAPPING.keys()


class MetadataManager(object):
    """ Provides an interface for the metadata service. This provides metadata
        about the resourse it is called from. See `METADATA_ATTRIBUTES` for
        full list of attributes.

        Usage:

            >>> import SoftLayer
            >>> client = SoftLayer.Client()
            >>> from SoftLayer import MetadataManager
            >>> meta = MetadataManager(client)
            >>> meta.get('datacenter')
            'dal05'
            >>> meta.get('fqdn')
            'test.example.com'

    """

    attribs = METADATA_MAPPING

    def __init__(self, client=None, timeout=5):
        self.url = API_PRIVATE_ENDPOINT_REST.rstrip('/')
        self.timeout = timeout
        self.client = client

    def make_request(self, path):
        """ Make a request against the metadata service

        :param string path: path to the specific metadata resource
        """
        url = '/'.join([self.url, 'SoftLayer_Resource_Metadata', path])
        try:
            return make_rest_api_call('GET', url,
                                      http_headers={'User-Agent': USER_AGENT},
                                      timeout=self.timeout)
        except SoftLayerAPIError as ex:
            if ex.faultCode == 404:
                return None
            raise ex

    def get(self, name, param=None):
        """ Retreive a metadata attribute

        :param string name: name of the attribute to retrieve. See `attribs`
        :param param: Required parameter for some attributes

        """
        if name not in self.attribs:
            raise SoftLayerError('Unknown metadata attribute.')

        call_details = self.attribs[name]
        extension = '.json'
        if self.attribs[name]['call'] == 'UserMetadata':
            extension = '.txt'

        if call_details.get('param_req'):
            if not param:
                raise SoftLayerError(
                    'Parameter required to get this attribute.')
            path = "%s/%s%s" % (self.attribs[name]['call'], param, extension)
        else:
            path = "%s%s" % (self.attribs[name]['call'], extension)

        return self.make_request(path)

    def _get_network(self, kind, router=True, vlans=True, vlan_ids=True):
        """ Wrapper for getting details about networks

            :param string kind: network kind. Typically 'public' or 'private'
            :param boolean router: flag to include router information
            :param boolean vlans: flag to include vlan information
            :param boolean vlan_ids: flag to include vlan_ids

        """
        network = {}
        macs = self.get('%s_mac' % kind)
        network['mac_addresses'] = macs

        if len(macs) == 0:
            return network

        if router:
            network['router'] = self.get('router', macs[0])

        if vlans:
            network['vlans'] = self.get('vlans', macs[0])

        if vlan_ids:
            network['vlan_ids'] = self.get('vlan_ids', macs[0])

        return network

    def public_network(self, **kwargs):
        """ Returns details about the public network

        :param boolean router: True to return router details
        :param boolean vlans: True to return vlan details
        :param boolean vlan_ids: True to return vlan_ids

        """
        return self._get_network('frontend', **kwargs)

    def private_network(self, **kwargs):
        """ Returns details about the private network

        :param boolean router: True to return router details
        :param boolean vlans: True to return vlan details
        :param boolean vlan_ids: True to return vlan_ids

        """
        return self._get_network('backend', **kwargs)

########NEW FILE########
__FILENAME__ = network
"""
    SoftLayer.network
    ~~~~~~~~~~~~~~~~~
    Network Manager/helpers

    :license: MIT, see LICENSE for more details.
"""

from SoftLayer.utils import NestedDict, query_filter, resolve_ids, lookup

DEFAULT_SUBNET_MASK = ','.join(['hardware',
                                'datacenter',
                                'ipAddressCount',
                                'virtualGuests'])
DEFAULT_VLAN_MASK = ','.join(['firewallInterfaces',
                              'hardware',
                              'networkComponents',
                              'primaryRouter'  # Lack of comma intential
                              '[id, fullyQualifiedDomainName, datacenter]',
                              'subnets',
                              'totalPrimaryIpAddressCount',
                              'virtualGuests'])


class NetworkManager(object):
    """ Manage Networks """
    def __init__(self, client):
        self.client = client
        self.account = client['Account']
        self.vlan = client['Network_Vlan']
        self.subnet = client['Network_Subnet']

    def add_global_ip(self, version=4, test_order=False):
        """ Adds a global IP address to the account.

        :param int version: Specifies whether this is IPv4 or IPv6
        :param bool test_order: If true, this will only verify the order.
        """
        # This method is here to improve the public interface from a user's
        # perspective since ordering a single global IP through the subnet
        # interface is not intuitive.
        return self.add_subnet('global', version=version,
                               test_order=test_order)

    def add_subnet(self, subnet_type, quantity=None, vlan_id=None, version=4,
                   test_order=False):
        """ Orders a new subnet

        :param str subnet_type: Type of subnet to add: private, public, global
        :param int quantity: Number of IPs in the subnet
        :param int vlan_id: VLAN id for the subnet to be placed into
        :param int version: 4 for IPv4, 6 for IPv6
        :param bool test_order: If true, this will only verify the order.
        """
        package = self.client['Product_Package']
        category = 'sov_sec_ip_addresses_priv'
        desc = ''
        if version == 4:
            if subnet_type == 'global':
                quantity = 0
                category = 'global_ipv4'
            elif subnet_type == 'public':
                category = 'sov_sec_ip_addresses_pub'
        else:
            category = 'static_ipv6_addresses'
            if subnet_type == 'global':
                quantity = 0
                category = 'global_ipv6'
                desc = 'Global'
            elif subnet_type == 'public':
                desc = 'Portable'

        # In the API, every non-server item is contained within package ID 0.
        # This means that we need to get all of the items and loop through them
        # looking for the items we need based upon the category, quantity, and
        # item description.
        price_id = None
        quantity_str = str(quantity)
        for item in package.getItems(id=0, mask='itemCategory'):
            category_code = lookup(item, 'itemCategory', 'categoryCode')
            if all([category_code == category,
                    item.get('capacity') == quantity_str,
                    version == 4 or (version == 6 and
                                     desc in item['description'])]):
                price_id = item['prices'][0]['id']
                break

        if not price_id:
            raise TypeError('Invalid combination specified for ordering a'
                            ' subnet.')

        order = {
            'packageId': 0,
            'prices': [{'id': price_id}],
            'quantity': 1,
            # This is necessary in order for the XML-RPC endpoint to select the
            # correct order container
            'complexType': 'SoftLayer_Container_Product_Order_Network_Subnet',
        }

        if subnet_type != 'global':
            order['endPointVlanId'] = vlan_id

        if test_order:
            return self.client['Product_Order'].verifyOrder(order)
        else:
            return self.client['Product_Order'].placeOrder(order)

    def assign_global_ip(self, global_ip_id, target):
        """ Assigns a global IP address to a specified target.

        :param int global_ip_id: The ID of the global IP being assigned
        :param string target: The IP address to assign
        """
        return self.client['Network_Subnet_IpAddress_Global'].route(
            target, id=global_ip_id)

    def cancel_global_ip(self, global_ip_id):
        """ Cancels the specified global IP address.

        :param int id: The ID of the global IP to be cancelled.
        """
        service = self.client['Network_Subnet_IpAddress_Global']
        ip_address = service.getObject(id=global_ip_id, mask='billingItem')
        billing_id = ip_address['billingItem']['id']

        return self.client['Billing_Item'].cancelService(id=billing_id)

    def cancel_subnet(self, subnet_id):
        """ Cancels the specified subnet.

        :param int subnet_id: The ID of the subnet to be cancelled.
        """
        subnet = self.get_subnet(subnet_id, mask='id, billingItem.id')
        billing_id = subnet['billingItem']['id']

        return self.client['Billing_Item'].cancelService(id=billing_id)

    def edit_rwhois(self, abuse_email=None, address1=None, address2=None,
                    city=None, company_name=None, country=None,
                    first_name=None, last_name=None, postal_code=None,
                    private_residence=None, state=None):
        """ Edit rwhois record """
        update = {}
        for key, value in [('abuseEmail', abuse_email),
                           ('address1', address1),
                           ('address2', address2),
                           ('city', city),
                           ('companyName', company_name),
                           ('country', country),
                           ('firstName', first_name),
                           ('lastName', last_name),
                           ('privateResidenceFlag', private_residence),
                           ('state', state),
                           ('postalCode', postal_code)]:
            if value is not None:
                update[key] = value

        # If there's anything to update, update it
        if update:
            rwhois = self.get_rwhois()
            self.client['Network_Subnet_Rwhois_Data'].editObject(
                update, id=rwhois['id'])

    def ip_lookup(self, ip_address):
        """ Looks up an IP address and returns network information about it.

        :param string ip_address: An IP address. Can be IPv4 or IPv6
        :returns: A dictionary of information about the IP

        """
        obj = self.client['Network_Subnet_IpAddress']
        return obj.getByIpAddress(ip_address, mask='hardware, virtualGuest')

    def get_rwhois(self):
        """ Returns the RWhois information about the current account.

        :returns: A dictionary containing the account's RWhois information.
        """
        return self.account.getRwhoisData()

    def get_subnet(self, subnet_id, **kwargs):
        """ Returns information about a single subnet.

        :param string id: Either the ID for the subnet or its network
                          identifier
        :returns: A dictionary of information about the subnet
        """
        if 'mask' not in kwargs:
            kwargs['mask'] = DEFAULT_SUBNET_MASK

        return self.subnet.getObject(id=subnet_id, **kwargs)

    def get_vlan(self, vlan_id):
        """ Returns information about a single VLAN.

        :param int id: The unique identifier for the VLAN
        :returns: A dictionary containing a large amount of information about
                  the specified VLAN.

        """
        return self.vlan.getObject(id=vlan_id, mask=DEFAULT_VLAN_MASK)

    def list_global_ips(self, version=None, identifier=None, **kwargs):
        """ Returns a list of all global IP address records on the account.

        :param int version: Only returns IPs of this version (4 or 6)
        :param string identifier: If specified, the list will only contain the
                                  global ips matching this network identifier.
        """
        if 'mask' not in kwargs:
            mask = ['destinationIpAddress[hardware, virtualGuest]',
                    'ipAddress']
            kwargs['mask'] = ','.join(mask)

        _filter = NestedDict({})

        if version:
            ver = query_filter(version)
            _filter['globalIpRecords']['ipAddress']['subnet']['version'] = ver

        if identifier:
            subnet_filter = _filter['globalIpRecords']['ipAddress']['subnet']
            subnet_filter['networkIdentifier'] = query_filter(identifier)

        kwargs['filter'] = _filter.to_dict()
        return self.account.getGlobalIpRecords(**kwargs)

    def list_subnets(self, identifier=None, datacenter=None, version=0,
                     subnet_type=None, **kwargs):
        """ Display a list of all subnets on the account.

        This provides a quick overview of all subnets including information
        about data center residence and the number of devices attached.

        :param string identifier: If specified, the list will only contain the
                                    subnet matching this network identifier.
        :param string datacenter: If specified, the list will only contain
                                    subnets in the specified data center.
        :param int version: Only returns subnets of this version (4 or 6).
        :param string subnet_type: If specified, it will only returns subnets
                                     of this type.
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        """
        if 'mask' not in kwargs:
            kwargs['mask'] = DEFAULT_SUBNET_MASK

        _filter = NestedDict(kwargs.get('filter') or {})

        if identifier:
            _filter['subnets']['networkIdentifier'] = query_filter(identifier)
        if datacenter:
            _filter['subnets']['datacenter']['name'] = \
                query_filter(datacenter)
        if version:
            _filter['subnets']['version'] = query_filter(version)
        if subnet_type:
            _filter['subnets']['subnetType'] = query_filter(subnet_type)
        else:
            # This filters out global IPs from the subnet listing.
            _filter['subnets']['subnetType'] = {'operation': '!= GLOBAL_IP'}

        kwargs['filter'] = _filter.to_dict()

        return self.account.getSubnets(**kwargs)

    def list_vlans(self, datacenter=None, vlan_number=None, name=None,
                   **kwargs):
        """ Display a list of all VLANs on the account.

        This provides a quick overview of all VLANs including information about
        data center residence and the number of devices attached.

        :param string datacenter: If specified, the list will only contain
                                    VLANs in the specified data center.
        :param int vlan_number: If specified, the list will only contain the
                                  VLAN matching this VLAN number.
        :param int name: If specified, the list will only contain the
                                  VLAN matching this VLAN name.
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)

        """
        _filter = NestedDict(kwargs.get('filter') or {})

        if vlan_number:
            _filter['networkVlans']['vlanNumber'] = query_filter(vlan_number)

        if name:
            _filter['networkVlans']['name'] = query_filter(name)

        if datacenter:
            _filter['networkVlans']['primaryRouter']['datacenter']['name'] = \
                query_filter(datacenter)

        kwargs['filter'] = _filter.to_dict()

        if 'mask' not in kwargs:
            kwargs['mask'] = DEFAULT_VLAN_MASK

        return self.account.getNetworkVlans(**kwargs)

    def resolve_global_ip_ids(self, identifier):
        """ Resolve global ip ids """
        return resolve_ids(identifier, [self._list_global_ips_by_identifier])

    def resolve_subnet_ids(self, identifier):
        """ Resolve subnet ids """
        return resolve_ids(identifier, [self._list_subnets_by_identifier])

    def resolve_vlan_ids(self, identifier):
        """ Resolve VLAN ids """
        return resolve_ids(identifier, [self._list_vlans_by_name])

    def summary_by_datacenter(self):
        """ Provides a dictionary with a summary of all network information on
        the account, grouped by data center.

        The resultant dictionary is primarily useful for statistical purposes.
        It contains count information rather than raw data. If you want raw
        information, see the :func:`list_vlans` method instead.

        :returns: A dictionary keyed by data center with the data containing a
                    series of counts for hardware, subnets, CCIs, and other
                    objects residing within that data center.

        """
        datacenters = {}
        unique_vms = []
        unique_servers = []
        unique_network = []

        for vlan in self.list_vlans():
            datacenter = vlan['primaryRouter']['datacenter']
            name = datacenter['name']
            if name not in datacenters:
                datacenters[name] = {
                    'hardwareCount': 0,
                    'networkingCount': 0,
                    'primaryIpCount': 0,
                    'subnetCount': 0,
                    'virtualGuestCount': 0,
                    'vlanCount': 0,
                }

            datacenters[name]['vlanCount'] += 1

            for hardware in vlan['hardware']:
                if hardware['id'] not in unique_servers:
                    datacenters[name]['hardwareCount'] += 1
                    unique_servers.append(hardware['id'])

            for net in vlan['networkComponents']:
                if net['id'] not in unique_network:
                    datacenters[name]['networkingCount'] += 1
                    unique_network.append(net['id'])

            for virtual_guest in vlan['virtualGuests']:
                if virtual_guest['id'] not in unique_vms:
                    datacenters[name]['virtualGuestCount'] += 1
                    unique_vms.append(virtual_guest['id'])

            datacenters[name]['primaryIpCount'] += \
                vlan['totalPrimaryIpAddressCount']
            datacenters[name]['subnetCount'] += len(vlan['subnets'])

        return datacenters

    def unassign_global_ip(self, global_ip_id):
        """ Unassigns a global IP address from a target.

        :param int id: The ID of the global IP being unassigned
        """
        return self.client['Network_Subnet_IpAddress_Global'].unroute(
            id=global_ip_id)

    def _list_global_ips_by_identifier(self, identifier):
        """ Returns a list of IDs of the global IP matching the specified
            network identifier

        :param string identifier: The identifier to look up
        :returns: List of matching IDs
        """
        results = self.list_global_ips(identifier=identifier, mask='id')
        return [result['id'] for result in results]

    def _list_subnets_by_identifier(self, identifier):
        """ Returns a list of IDs of the subnet matching the specified
            network identifier

        :param string identifier: The identifier to look up
        :returns: List of matching IDs
        """
        identifier = identifier.split('/', 1)[0]

        results = self.list_subnets(identifier=identifier, mask='id')
        return [result['id'] for result in results]

    def _list_vlans_by_name(self, name):
        """ Returns a list of IDs of VLANs which match the given VLAN name.

        :param string name: a VLAN name
        :returns: List of matching IDs
        """
        results = self.list_vlans(name=name, mask='id')
        return [result['id'] for result in results]

########NEW FILE########
__FILENAME__ = sshkey
"""
    SoftLayer.sshkey
    ~~~~~~~~~~~~~~~~
    SSH Key Manager/helpers

    :license: MIT, see LICENSE for more details.
"""

from SoftLayer.utils import IdentifierMixin, NestedDict, query_filter


class SshKeyManager(IdentifierMixin, object):
    """
    Manages account SSH keys.

    :param SoftLayer.API.Client client: an API client instance
    """

    def __init__(self, client):
        self.client = client
        self.sshkey = client['Security_Ssh_Key']
        self.resolvers = [self._get_ids_from_label]

    def add_key(self, key, label, notes=None):
        """ Adds a new SSH key to the account.

        :param string key: The SSH key to add
        :param string label: The label for the key
        :returns: A dictionary of the new key's information.
        """
        order = {
            'key': key,
            'label': label,
            'notes': notes,
        }

        return self.sshkey.createObject(order)

    def delete_key(self, key_id):
        """ Permanently deletes an SSH key from the account.

        :param int key_id: The ID of the key to delete

        """
        return self.sshkey.deleteObject(id=key_id)

    def edit_key(self, key_id, label=None, notes=None):
        """ Edits information about an SSH key.

        :param int key_id: The ID of the key to edit
        :param string label: The new label for the key
        :param string notes: Notes to set or change on the key
        :returns: A Boolean indicating success or failure
        """
        data = {}

        if label:
            data['label'] = label

        if notes:
            data['notes'] = notes

        return self.sshkey.editObject(data, id=key_id)

    def get_key(self, key_id):
        """ Returns full information about a single SSH key.

        :param int key_id: The ID of the key to retrieve
        :returns: A dictionary of information about the key
        """
        return self.sshkey.getObject(id=key_id)

    def list_keys(self, label=None):
        """ Lists all SSH keys on the account.

        :param string label: Filter list based on SSH key label
        :returns: A list of dictionaries with information about each key
        """
        _filter = NestedDict({})
        if label:
            _filter['sshKeys']['label'] = query_filter(label)

        return self.client['Account'].getSshKeys(filter=_filter.to_dict())

    def _get_ids_from_label(self, label):
        """ Return sshkey IDs which match the given label """
        keys = self.list_keys()
        results = []
        for key in keys:
            if key['label'] == label:
                results.append(key['id'])
        return results

########NEW FILE########
__FILENAME__ = ssl
"""
    SoftLayer.ssl
    ~~~~~~~~~~~~~
    SSL Manager/helpers

    :license: MIT, see LICENSE for more details.
"""


class SSLManager(object):
    """
    Manages SSL certificates.

    :param SoftLayer.API.Client client: an API client instance
    """

    def __init__(self, client):
        self.client = client
        self.ssl = self.client['Security_Certificate']

    def list_certs(self, method='all'):
        """ List all certificates.

        :param string method: The type of certificates to list. Options are
                              'all', 'expired', and 'valid'.
        :returns: A list of dictionaries representing the requested SSL certs.

        """
        ssl = self.client['Account']
        methods = {
            'all': 'getSecurityCertificates',
            'expired': 'getExpiredSecurityCertificates',
            'valid': 'getValidSecurityCertificates'
        }

        mask = "mask[id, commonName, validityDays, notes]"
        func = getattr(ssl, methods[method])
        return func(mask=mask)

    def add_certificate(self, certificate):
        """ Creates a new certificate.

        :param dict certificate: A dictionary representing the parts of the
                                 certificate. See SLDN for more information.

        """
        return self.ssl.createObject(certificate)

    def remove_certificate(self, cert_id):
        """ Removes a certificate.

        :param integer cert_id: a certificate ID to remove

        """
        return self.ssl.deleteObject(id=cert_id)

    def edit_certificate(self, certificate):
        """ Updates a certificate with the included options.

        The provided dict must include an 'id' key and value corresponding to
        the certificate ID that should be updated.

        :param dict certificate: the certificate to update.

        """
        return self.ssl.editObject(certificate, id=certificate['id'])

    def get_certificate(self, cert_id):
        """ Gets a certificate with the ID specified.

        :param integer cert_id: the certificate ID to retrieve

        """
        return self.ssl.getObject(id=cert_id)

########NEW FILE########
__FILENAME__ = ticket
"""
    SoftLayer.ticket
    ~~~~~~~~~~~~~~~
    Ticket Manager/helpers

    :license: MIT, see LICENSE for more details.
"""

from SoftLayer.utils import IdentifierMixin


class TicketManager(IdentifierMixin, object):
    """
    Manages account Tickets

    :param SoftLayer.API.Client client: an API client instance
    """

    def __init__(self, client):
        self.client = client
        self.account = self.client['Account']
        self.ticket = self.client['Ticket']

    def list_tickets(self, open_status=True, closed_status=True):
        """ List all tickets

        :param boolean open_status: include open tickets
        :param boolean closed_status: include closed tickets
        """
        mask = ('mask[id, title, assignedUser[firstName, lastName],'
                'createDate,lastEditDate,accountId]')

        call = 'getTickets'
        if not all([open_status, closed_status]):
            if open_status:
                call = 'getOpenTickets'
            elif closed_status:
                call = 'getClosedTickets'

        func = getattr(self.account, call)
        return func(mask=mask)

    def list_subjects(self):
        """ List all tickets"""
        return self.client['Ticket_Subject'].getAllObjects()

    def get_ticket(self, ticket_id):
        """ Get details about a ticket

        :param integer id: the ticket ID
        :returns: A dictionary containing a large amount of information about
                  the specified ticket.

        """
        mask = ('mask[id, title, assignedUser[firstName, lastName],'
                'createDate,lastEditDate,updates[entry],updateCount]')
        return self.ticket.getObject(id=ticket_id, mask=mask)

    def create_ticket(self, title=None, body=None, subject=None):
        """ Create a new ticket

        :param string title: title for the new ticket
        :param string body: body for the new ticket
        :param integer subject: id of the subject to be assigned to the ticket
        """

        current_user = self.account.getCurrentUser()
        new_ticket = {
            'subjectId': subject,
            'contents': body,
            'assignedUserId': current_user['id'],
            'title': title,
        }
        created_ticket = self.ticket.createStandardTicket(new_ticket, body)
        return created_ticket

    def update_ticket(self, ticket_id=None, body=None):
        """ Update a ticket

        :param integer ticket_id: the id of the ticket to update
        :param string body: entry to update in the ticket
        """

        ticket = self.ticket.getObject(id=ticket_id)
        return self.ticket.edit(ticket, body, id=ticket_id)

########NEW FILE########
__FILENAME__ = vs
"""
    SoftLayer.vs
    ~~~~~~~~~~~~
    VS Manager/helpers

    :license: MIT, see LICENSE for more details.
"""
import socket
from time import sleep
import datetime
from itertools import repeat

from SoftLayer.utils import NestedDict, query_filter, IdentifierMixin, lookup


class VSManager(IdentifierMixin, object):
    """ Manage Virtual Servers """
    def __init__(self, client):
        self.client = client
        self.account = client['Account']
        self.guest = client['Virtual_Guest']
        self.resolvers = [self._get_ids_from_ip, self._get_ids_from_hostname]

    def list_instances(self, hourly=True, monthly=True, tags=None, cpus=None,
                       memory=None, hostname=None, domain=None,
                       local_disk=None, datacenter=None, nic_speed=None,
                       public_ip=None, private_ip=None, **kwargs):
        """ Retrieve a list of all virtual servers on the account.

        :param boolean hourly: include hourly instances
        :param boolean monthly: include monthly instances
        :param list tags: filter based on tags
        :param integer cpus: filter based on number of CPUS
        :param integer memory: filter based on amount of memory
        :param string hostname: filter based on hostname
        :param string domain: filter based on domain
        :param string local_disk: filter based on local_disk
        :param string datacenter: filter based on datacenter
        :param integer nic_speed: filter based on network speed (in MBPS)
        :param string public_ip: filter based on public ip address
        :param string private_ip: filter based on private ip address
        :param dict \\*\\*kwargs: response-level options (mask, limit, etc.)
        :returns: Returns a list of dictionaries representing the matching
                  virtual servers

        ::

           # Print out a list of all hourly instances in the DAL05 data center.
           # env variables
           # SL_USERNAME = YOUR_USERNAME
           # SL_API_KEY = YOUR_API_KEY
           import SoftLayer
           client = SoftLayer.Client()

           mgr = SoftLayer.VSManager(client)
           for vsi in mgr.list_instances(hourly=True, datacenter='dal05'):
               print vsi['fullyQualifiedDomainName'], vs['primaryIpAddress']

        """
        if 'mask' not in kwargs:
            items = [
                'id',
                'globalIdentifier',
                'hostname',
                'domain',
                'fullyQualifiedDomainName',
                'primaryBackendIpAddress',
                'primaryIpAddress',
                'lastKnownPowerState.name',
                'powerState',
                'maxCpu',
                'maxMemory',
                'datacenter',
                'activeTransaction.transactionStatus[friendlyName,name]',
                'status',
            ]
            kwargs['mask'] = "mask[%s]" % ','.join(items)

        call = 'getVirtualGuests'
        if not all([hourly, monthly]):
            if hourly:
                call = 'getHourlyVirtualGuests'
            elif monthly:
                call = 'getMonthlyVirtualGuests'

        _filter = NestedDict(kwargs.get('filter') or {})
        if tags:
            _filter['virtualGuests']['tagReferences']['tag']['name'] = {
                'operation': 'in',
                'options': [{'name': 'data', 'value': tags}],
            }

        if cpus:
            _filter['virtualGuests']['maxCpu'] = query_filter(cpus)

        if memory:
            _filter['virtualGuests']['maxMemory'] = query_filter(memory)

        if hostname:
            _filter['virtualGuests']['hostname'] = query_filter(hostname)

        if domain:
            _filter['virtualGuests']['domain'] = query_filter(domain)

        if local_disk is not None:
            _filter['virtualGuests']['localDiskFlag'] = \
                query_filter(bool(local_disk))

        if datacenter:
            _filter['virtualGuests']['datacenter']['name'] = \
                query_filter(datacenter)

        if nic_speed:
            _filter['virtualGuests']['networkComponents']['maxSpeed'] = \
                query_filter(nic_speed)

        if public_ip:
            _filter['virtualGuests']['primaryIpAddress'] = \
                query_filter(public_ip)

        if private_ip:
            _filter['virtualGuests']['primaryBackendIpAddress'] = \
                query_filter(private_ip)

        kwargs['filter'] = _filter.to_dict()
        func = getattr(self.account, call)
        return func(**kwargs)

    def get_instance(self, instance_id, **kwargs):
        """ Get details about a virtual server instance

        :param integer instance_id: the instance ID
        :returns: A dictionary containing a large amount of information about
                  the specified instance.

        ::

           # Print out the FQDN and IP address for instance ID 12345.
           # env variables
           # SL_USERNAME = YOUR_USERNAME
           # SL_API_KEY = YOUR_API_KEY
           import SoftLayer
           client = SoftLayer.Client()

           mgr = SoftLayer.VSManager(client)
           vsi = mgr.get_instance(12345)
           print vsi['fullyQualifiedDomainName'], vs['primaryIpAddress']

        """

        if 'mask' not in kwargs:
            items = [
                'id',
                'globalIdentifier',
                'fullyQualifiedDomainName',
                'hostname',
                'domain',
                'createDate',
                'modifyDate',
                'provisionDate',
                'notes',
                'dedicatedAccountHostOnlyFlag',
                'privateNetworkOnlyFlag',
                'primaryBackendIpAddress',
                'primaryIpAddress',
                '''networkComponents[id, status, speed, maxSpeed, name,
                                     macAddress, primaryIpAddress, port,
                                     primarySubnet]''',
                'lastKnownPowerState.name',
                'powerState',
                'status',
                'maxCpu',
                'maxMemory',
                'datacenter',
                'activeTransaction[id, transactionStatus[friendlyName,name]]',
                'lastOperatingSystemReload.id',
                'blockDevices',
                'blockDeviceTemplateGroup[id, name, globalIdentifier]',
                'postInstallScriptUri',
                'userData',
                '''operatingSystem[passwords[username,password],
                                   softwareLicense.softwareDescription[
                                       manufacturer,name,version,
                                       referenceCode]]''',
                'hourlyBillingFlag',
                'billingItem.recurringFee',
                'tagReferences[id,tag[name,id]]',
                'networkVlans[id,vlanNumber,networkSpace]',
            ]
            kwargs['mask'] = "mask[%s]" % ','.join(items)

        return self.guest.getObject(id=instance_id, **kwargs)

    def get_create_options(self):
        """ Retrieves the available options for creating a VS.

        :returns: A dictionary of creation options.

        """
        return self.guest.getCreateObjectOptions()

    def cancel_instance(self, instance_id):
        """ Cancel an instance immediately, deleting all its data.

        :param integer instance_id: the instance ID to cancel

        ::

           # Cancel for instance ID 12345.
           # env variables
           # SL_USERNAME = YOUR_USERNAME
           # SL_API_KEY = YOUR_API_KEY
           import SoftLayer
           client = SoftLayer.Client()

           mgr = SoftLayer.VSManager(client)
           mgr.cancel_instance(12345)

        """
        return self.guest.deleteObject(id=instance_id)

    def reload_instance(self, instance_id, post_uri=None, ssh_keys=None):
        """ Perform an OS reload of an instance with its current configuration.

        :param integer instance_id: the instance ID to reload
        :param string post_url: The URI of the post-install script to run
                                after reload
        :param list ssh_keys: The SSH keys to add to the root user

        ::

           # Reload instance ID 12345 then run a custom post-provision script.
           # env variables
           # SL_USERNAME = YOUR_USERNAME
           # SL_API_KEY = YOUR_API_KEY
           import SoftLayer
           client = SoftLayer.Client()

           post_uri = 'https://somehost.com/bootstrap.sh'
           mgr = SoftLayer.VSManager(client)
           vsi = mgr.reload_instance(12345, post_uri=post_url)

        """
        config = {}

        if post_uri:
            config['customProvisionScriptUri'] = post_uri

        if ssh_keys:
            config['sshKeyIds'] = [key_id for key_id in ssh_keys]

        return self.guest.reloadOperatingSystem('FORCE', config,
                                                id=instance_id)

    def _generate_create_dict(
            self, cpus=None, memory=None, hourly=True,
            hostname=None, domain=None, local_disk=True,
            datacenter=None, os_code=None, image_id=None,
            dedicated=False, public_vlan=None, private_vlan=None,
            userdata=None, nic_speed=None, disks=None, post_uri=None,
            private=False, ssh_keys=None):
        """ Returns a dict appropriate to pass into Virtual_Guest::createObject
            See :func:`create_instance` for a list of available options.
        """
        required = [cpus, memory, hostname, domain]

        mutually_exclusive = [
            {'os_code': os_code, "image_id": image_id},
        ]

        if not all(required):
            raise ValueError("cpu, memory, hostname, and domain are required")

        for mu_ex in mutually_exclusive:
            if all(mu_ex.values()):
                raise ValueError(
                    'Can only specify one of: %s' % (','.join(mu_ex.keys())))

        data = {
            "startCpus": int(cpus),
            "maxMemory": int(memory),
            "hostname": hostname,
            "domain": domain,
            "localDiskFlag": local_disk,
        }

        data["hourlyBillingFlag"] = hourly

        if dedicated:
            data["dedicatedAccountHostOnlyFlag"] = dedicated

        if private:
            data['privateNetworkOnlyFlag'] = private

        if image_id:
            data["blockDeviceTemplateGroup"] = {"globalIdentifier": image_id}
        elif os_code:
            data["operatingSystemReferenceCode"] = os_code

        if datacenter:
            data["datacenter"] = {"name": datacenter}

        if public_vlan:
            data.update({
                'primaryNetworkComponent': {
                    "networkVlan": {"id": int(public_vlan)}}})
        if private_vlan:
            data.update({
                "primaryBackendNetworkComponent": {
                    "networkVlan": {"id": int(private_vlan)}}})

        if userdata:
            data['userData'] = [{'value': userdata}]

        if nic_speed:
            data['networkComponents'] = [{'maxSpeed': nic_speed}]

        if disks and isinstance(disks, list):
            data['blockDevices'] = [
                {"device": "0", "diskImage": {"capacity": disks[0]}}
            ]

            for dev_id, disk in enumerate(disks[1:], start=2):
                data['blockDevices'].append(
                    {
                        "device": str(dev_id),
                        "diskImage": {"capacity": disk}
                    }
                )

        if post_uri:
            data['postInstallScriptUri'] = post_uri

        if ssh_keys:
            data['sshKeys'] = [{'id': key_id} for key_id in ssh_keys]

        return data

    def wait_for_transaction(self, instance_id, limit, delay=1):
        """ Waits on a VS transaction for the specified amount of time.
        is really just a wrapper for wait_for_ready(pending=True).
        Provided for backwards compatibility.


        :param int instance_id: The instance ID with the pending transaction
        :param int limit: The maximum amount of time to wait.
        :param int delay: The number of seconds to sleep before checks.
                          Defaults to 1.
        """

        return self.wait_for_ready(instance_id, limit, delay=delay,
                                   pending=True)

    def wait_for_ready(self, instance_id, limit, delay=1, pending=False):
        """ Determine if a VS is ready and available.  In some cases
        though, that can mean that no transactions are running. The default
        arguments imply a VS is operational and ready for use by having
        network connectivity and remote access is available.  Setting
        ``pending=True`` will ensure future API calls
        against this instance will not error due to pending
        transactions such as OS Reloads and cancellations.

        :param int instance_id: The instance ID with the pending transaction
        :param int limit: The maximum amount of time to wait.
        :param int delay: The number of seconds to sleep before checks.
                          Defaults to 1.
        :param bool pending: Wait for pending transactions not related to
                             provisioning or reloads such as monitoring.
        """
        for count, new_instance in enumerate(repeat(instance_id), start=1):
            instance = self.get_instance(new_instance)
            last_reload = lookup(instance, 'lastOperatingSystemReload', 'id')
            active_transaction = lookup(instance, 'activeTransaction', 'id')

            reloading = all((
                active_transaction,
                last_reload,
                last_reload == active_transaction
            ))

            # only check for outstanding transactions if requested
            outstanding = False
            if pending:
                outstanding = active_transaction

            # return True if the instance has only if the instance has
            # finished provisioning and isn't currently reloading the OS.
            if instance.get('provisionDate') \
                    and not reloading and not outstanding:
                return True

            if count >= limit:
                return False

            sleep(delay)

    def verify_create_instance(self, **kwargs):
        """ Verifies an instance creation command without actually placing an
        order. See :func:`create_instance` for a list of available
        options. """
        create_options = self._generate_create_dict(**kwargs)
        return self.guest.generateOrderTemplate(create_options)

    def create_instance(self, **kwargs):
        """
        Creates a new virtual server instance

        :param int cpus: The number of virtual CPUs to include in the instance.
        :param int memory: The amount of RAM to order.
        :param bool hourly: Flag to indicate if this server should be billed
                            hourly (default) or monthly.
        :param string hostname: The hostname to use for the new server.
        :param string domain: The domain to use for the new server.
        :param bool local_disk: Flag to indicate if this should be a local disk
                                (default) or a SAN disk.
        :param string datacenter: The short name of the data center in which
                                  the VS should reside.
        :param string os_code: The operating system to use. Cannot be specified
                               if image_id is specified.
        :param int image_id: The ID of the image to load onto the server.
                             Cannot be specified if os_code is specified.
        :param bool dedicated: Flag to indicate if this should be housed on a
                               dedicated or shared host (default). This will
                               incur a fee on your account.
        :param int public_vlan: The ID of the public VLAN on which you want
                                this VS placed.
        :param int private_vlan: The ID of the public VLAN on which you want
                                 this VS placed.
        :param bool bare_metal: Flag to indicate if this is a bare metal server
                                or a dedicated server (default).
        :param list disks: A list of disk capacities for this server.
        :param string post_uri: The URI of the post-install script to run
                                after reload
        :param bool private: If true, the VS will be provisioned only with
                             access to the private network. Defaults to false
        :param list ssh_keys: The SSH keys to add to the root user
        """
        create_options = self._generate_create_dict(**kwargs)
        return self.guest.createObject(create_options)

    def change_port_speed(self, instance_id, public, speed):
        """ Allows you to change the port speed of a virtual server's NICs.

        :param int instance_id: The ID of the VS
        :param bool public: Flag to indicate which interface to change.
                            True (default) means the public interface.
                            False indicates the private interface.
        :param int speed: The port speed to set.
        """
        if public:
            func = self.guest.setPublicNetworkInterfaceSpeed
        else:
            func = self.guest.setPrivateNetworkInterfaceSpeed

        return func(speed, id=instance_id)

    def _get_ids_from_hostname(self, hostname):
        """ List VS ids which match the given hostname """
        results = self.list_instances(hostname=hostname, mask="id")
        return [result['id'] for result in results]

    def _get_ids_from_ip(self, ip_address):
        """ List VS ids which match the given ip address """
        try:
            # Does it look like an ip address?
            socket.inet_aton(ip_address)
        except socket.error:
            return []

        # Find the VS via ip address. First try public ip, then private
        results = self.list_instances(public_ip=ip_address, mask="id")
        if results:
            return [result['id'] for result in results]

        results = self.list_instances(private_ip=ip_address, mask="id")
        if results:
            return [result['id'] for result in results]

    def edit(self, instance_id, userdata=None, hostname=None, domain=None,
             notes=None):
        """ Edit hostname, domain name, notes, and/or the user data of a VS

        Parameters set to None will be ignored and not attempted to be updated.

        :param integer instance_id: the instance ID to edit
        :param string userdata: user data on VS to edit.
                                If none exist it will be created
        :param string hostname: valid hostname
        :param string domain: valid domain namem
        :param string notes: notes about this particular VS

        """

        obj = {}
        if userdata:
            self.guest.setUserMetadata([userdata], id=instance_id)

        if hostname:
            obj['hostname'] = hostname

        if domain:
            obj['domain'] = domain

        if notes:
            obj['notes'] = notes

        if not obj:
            return True

        return self.guest.editObject(obj, id=instance_id)

    def capture(self, instance_id, name, additional_disks=False, notes=None):
        """ Capture one or all disks from a VS to a SoftLayer image.

        Parameters set to None will be ignored and not attempted to be updated.

        :param integer instance_id: the instance ID to edit
        :param string name: name assigned to the image
        :param string additional_disks: set to true to include all additional
                                        attached storage devices
        :param string notes: notes about this particular image

        """
        vsi = self.get_instance(instance_id)

        disk_filter = lambda x: x['device'] == '0'
        # Disk 1 is swap partition.  Need to skip its capture.
        if additional_disks:
            disk_filter = lambda x: x['device'] != '1'

        disks = [block_device for block_device in vsi['blockDevices']
                 if disk_filter(block_device)]

        return self.guest.createArchiveTransaction(
            name, disks, notes, id=instance_id)

    def upgrade(self, instance_id, cpus=None, memory=None,
                nic_speed=None, public=True):
        """
        Upgrades a VS instance

        :param int instance_id: Instance id of the VS to be upgraded
        :param int cpus: The number of virtual CPUs to upgrade to
                            of a VS instance.
        :param bool public: CPU will be in Private/Public Node.
        :param int memory: RAM of the VS to be upgraded to.
        :param int nic_speed: The port speed to set

        ::

           # Upgrade instance 12345 to 4 CPUs and 4 GB of memory
           import SoftLayer
           client = SoftLayer.Client(config="~/.softlayer")

           mgr = SoftLayer.VSManager(client)
           mgr.upgrade(12345, cpus=4, memory=4)

        """
        package_items = self._get_package_items()
        item_id = []
        if cpus:
            item_id.append({'id': self._get_item_id_for_upgrade(
                package_items, 'cpus', cpus, public)})
        if memory:
            item_id.append({'id': self._get_item_id_for_upgrade(
                package_items, 'memory', memory)})
        if nic_speed:
            item_id.append({'id': self._get_item_id_for_upgrade(
                package_items, 'nic_speed', nic_speed)})

        order = {}
        order['complexType'] = \
            'SoftLayer_Container_Product_Order_Virtual_Guest_Upgrade'
        order['virtualGuests'] = [{'id': int(instance_id)}]
        order['prices'] = item_id
        order['properties'] = [{'name': 'MAINTENANCE_WINDOW',
                                'value': str(datetime.datetime.now())}]
        if cpus or memory or nic_speed:
            self.client['Product_Order'].verifyOrder(order)
            self.client['Product_Order'].placeOrder(order)
            return True
        return False

    def _get_package_items(self):
        """
        Following Method gets all the item ids related to VS
        """
        mask = "mask[description,capacity,prices.id,categories[name,id]]"
        package = self.client['Product_Package']
        return package.getItems(id=46, mask=mask)

    def _get_item_id_for_upgrade(self, package_items, option, value,
                                 public=True):
        """
        Find the item ids for the parameters you want to upgrade to.
        :param list package_items: Contains all the items related to an VS
        :param string option: Describes type of parameter to be upgraded
        :param int value: The value of the parameter to be upgraded
        :param bool public: CPU will be in Private/Public Node.
        """
        vs_id = {'memory': 3, 'cpus': 80, 'nic_speed': 26}
        for item in package_items:
            for j in range(len(item['categories'])):
                if not (item['categories'][j]['id'] == vs_id[option] and
                        item['capacity'] == str(value)):
                    continue
                if option == 'cpus':
                    if public and ('Private' not in item['description']):
                        return item['prices'][0]['id']
                    elif not public and ('Private' in item['description']):
                        return item['prices'][0]['id']
                elif option == 'nic_speed':
                    if 'Public' in item['description']:
                        return item['prices'][0]['id']
                else:
                    return item['prices'][0]['id']

########NEW FILE########
__FILENAME__ = api_tests
"""
    SoftLayer.tests.api_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import patch, call, Mock, ANY

import SoftLayer
import SoftLayer.API
from SoftLayer.tests import unittest
from SoftLayer.consts import USER_AGENT


class Inititialization(unittest.TestCase):
    def test_init(self):
        client = SoftLayer.Client(username='doesnotexist',
                                  api_key='issurelywrong', timeout=10)

        auth_headers = {'authenticate': {'username': 'doesnotexist',
                                         'apiKey': 'issurelywrong'}}
        self.assertEquals(client.auth.get_headers(), auth_headers)
        self.assertEquals(client.endpoint_url,
                          SoftLayer.API_PUBLIC_ENDPOINT.rstrip('/'))
        self.assertEquals(client.timeout, 10)

    @patch('SoftLayer.API.get_client_settings')
    def test_env(self, get_client_settings):
        auth = Mock()
        get_client_settings.return_value = {
            'auth': auth,
            'timeout': 10,
            'endpoint_url': 'http://endpoint_url/',
        }
        client = SoftLayer.Client()
        self.assertEquals(client.auth.get_headers(), auth.get_headers())
        self.assertEquals(client.timeout, 10)
        self.assertEquals(client.endpoint_url, 'http://endpoint_url')


class ClientMethods(unittest.TestCase):
    def test_help(self):
        help(SoftLayer)
        help(SoftLayer.Client)
        client = SoftLayer.Client(
            username='doesnotexist',
            api_key='issurelywrong'
        )
        help(client)
        help(client['SERVICE'])

    def test_repr(self):
        client = SoftLayer.Client(
            username='doesnotexist',
            api_key='issurelywrong'
        )
        self.assertIn("Client", repr(client))

    def test_service_repr(self):
        client = SoftLayer.Client(
            username='doesnotexist',
            api_key='issurelywrong'
        )
        self.assertIn("Service", repr(client['SERVICE']))

    def test_len(self):
        client = SoftLayer.Client(
            username='doesnotexist',
            api_key='issurelywrong'
        )
        self.assertEqual(len(client), 0)


class APIClient(unittest.TestCase):
    def setUp(self):
        self.client = SoftLayer.Client(
            username='doesnotexist', api_key='issurelywrong',
            endpoint_url="ENDPOINT")

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_simple_call(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD()
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers={
                'authenticate': {
                    'username': 'doesnotexist', 'apiKey': 'issurelywrong'}},
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate, compress',
            })

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_complex(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD(
            1234,
            id=5678,
            mask={'object': {'attribute': ''}},
            raw_headers={'RAW': 'HEADER'},
            filter={
                'TYPE': {'obj': {'attribute': {'operation': '^= prefix'}}}},
            limit=9, offset=10)

        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (1234, ),
            headers={
                'SoftLayer_SERVICEObjectMask': {
                    'mask': {'object': {'attribute': ''}}},
                'SoftLayer_SERVICEObjectFilter': {
                    'TYPE': {
                        'obj': {'attribute': {'operation': '^= prefix'}}}},
                'authenticate': {
                    'username': 'doesnotexist', 'apiKey': 'issurelywrong'},
                'SoftLayer_SERVICEInitParameters': {'id': 5678},
                'resultLimit': {'limit': 9, 'offset': 10}},
            proxy=None,
            timeout=None,
            http_headers={
                'RAW': 'HEADER',
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate, compress',
            })

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_mask_call_v2(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD(
            mask="mask[something[nested]]")
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers={
                'authenticate': {
                    'username': 'doesnotexist', 'apiKey': 'issurelywrong'},
                'SoftLayer_ObjectMask': {'mask': 'mask[something[nested]]'}},
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate, compress',
            })

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_mask_call_v2_dot(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD(
            mask="mask.something.nested")
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers={
                'authenticate': {
                    'username': 'doesnotexist', 'apiKey': 'issurelywrong'},
                'SoftLayer_ObjectMask': {'mask': 'mask.something.nested'}},
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate, compress',
            })

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_mask_call_no_mask_prefix(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD(mask="something.nested")
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers={
                'authenticate': {
                    'username': 'doesnotexist', 'apiKey': 'issurelywrong'},
                'SoftLayer_ObjectMask': {'mask': 'mask[something.nested]'}},
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate, compress',
            })

    @patch('SoftLayer.API.Client.iter_call')
    def test_iterate(self, _iter_call):
        self.client['SERVICE'].METHOD(iter=True)
        _iter_call.assert_called_with('SERVICE', 'METHOD')

    @patch('SoftLayer.API.Client.iter_call')
    def test_service_iter_call(self, _iter_call):
        self.client['SERVICE'].iter_call('METHOD')
        _iter_call.assert_called_with('SERVICE', 'METHOD')

    @patch('SoftLayer.API.Client.call')
    def test_iter_call(self, _call):
        # chunk=100, no limit
        _call.side_effect = [list(range(100)), list(range(100, 125))]
        result = list(self.client.iter_call('SERVICE', 'METHOD', iter=True))

        self.assertEquals(list(range(125)), result)
        _call.assert_has_calls([
            call('SERVICE', 'METHOD', limit=100, iter=False, offset=0),
            call('SERVICE', 'METHOD', limit=100, iter=False, offset=100),
        ])
        _call.reset_mock()

        # chunk=100, no limit. Requires one extra request.
        _call.side_effect = [list(range(100)), list(range(100, 200)), []]
        result = list(self.client.iter_call('SERVICE', 'METHOD', iter=True))
        self.assertEquals(list(range(200)), result)
        _call.assert_has_calls([
            call('SERVICE', 'METHOD', limit=100, iter=False, offset=0),
            call('SERVICE', 'METHOD', limit=100, iter=False, offset=100),
            call('SERVICE', 'METHOD', limit=100, iter=False, offset=200),
        ])
        _call.reset_mock()

        # chunk=25, limit=30
        _call.side_effect = [list(range(0, 25)), list(range(25, 30))]
        result = list(self.client.iter_call(
            'SERVICE', 'METHOD', iter=True, limit=30, chunk=25))
        self.assertEquals(list(range(30)), result)
        _call.assert_has_calls([
            call('SERVICE', 'METHOD', iter=False, limit=25, offset=0),
            call('SERVICE', 'METHOD', iter=False, limit=5, offset=25),
        ])
        _call.reset_mock()

        # A non-list was returned
        _call.side_effect = ["test"]
        result = list(self.client.iter_call('SERVICE', 'METHOD', iter=True))
        self.assertEquals(["test"], result)
        _call.assert_has_calls([
            call('SERVICE', 'METHOD', iter=False, limit=100, offset=0),
        ])
        _call.reset_mock()

        # chunk=25, limit=30, offset=12
        _call.side_effect = [list(range(0, 25)), list(range(25, 30))]
        result = list(self.client.iter_call(
            'SERVICE', 'METHOD', iter=True, limit=30, chunk=25, offset=12))
        self.assertEquals(list(range(30)), result)
        _call.assert_has_calls([
            call('SERVICE', 'METHOD', iter=False, limit=25, offset=12),
            call('SERVICE', 'METHOD', iter=False, limit=5, offset=37),
        ])

        # Chunk size of 0 is invalid
        self.assertRaises(
            AttributeError,
            lambda: list(self.client.iter_call(
                'SERVICE', 'METHOD', iter=True, chunk=0)))

    def test_call_invalid_arguments(self):
        self.assertRaises(
            TypeError,
            self.client.call, 'SERVICE', 'METHOD', invalid_kwarg='invalid')

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_call_compression_disabled(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD(compress=False)
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers=ANY,
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
            })

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_call_compression_enabled(self, make_xml_rpc_api_call):
        self.client['SERVICE'].METHOD(compress=True)
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers=ANY,
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept': '*/*',
                'Accept-Encoding': 'gzip, deflate, compress',
            })

    @patch('SoftLayer.API.make_xml_rpc_api_call')
    def test_call_compression_override(self, make_xml_rpc_api_call):
        # raw_headers should override compress=False
        self.client['SERVICE'].METHOD(
            compress=False,
            raw_headers={'Accept-Encoding': 'gzip'})
        make_xml_rpc_api_call.assert_called_with(
            'ENDPOINT/SoftLayer_SERVICE', 'METHOD', (),
            headers=ANY,
            proxy=None,
            timeout=None,
            http_headers={
                'Content-Type': 'application/xml',
                'User-Agent': USER_AGENT,
                'Accept-Encoding': 'gzip',
            })


class APITimedClient(unittest.TestCase):
    def setUp(self):
        self.client = SoftLayer.TimedClient(
            username='doesnotexist', api_key='issurelywrong',
            endpoint_url="ENDPOINT")

    @patch('SoftLayer.API.time.time')
    @patch('SoftLayer.API.Client.call')
    def test_overriden_call_times_methods(self, _call, _time):
        _call.side_effect = [list(range(10))]
        _time.side_effect = [1121362200, 1121762200]

        result = list(self.client.call('SERVICE', 'METHOD'))

        self.assertEqual(list(range(10)), result)

        expected_calls = [('SERVICE.METHOD', 1121362200, 400000)]
        self.assertEqual(expected_calls, self.client.get_last_calls())


class UnauthenticatedAPIClient(unittest.TestCase):
    def setUp(self):
        self.client = SoftLayer.Client(endpoint_url="ENDPOINT")

    @patch('SoftLayer.API.get_client_settings')
    def test_init(self, get_client_settings):
        get_client_settings.return_value = {}
        client = SoftLayer.Client()
        self.assertIsNone(client.auth)

    @patch('SoftLayer.API.get_client_settings')
    def test_init_with_proxy(self, get_client_settings):
        get_client_settings.return_value = {'proxy': 'http://localhost:3128'}
        client = SoftLayer.Client()
        self.assertEqual(client.proxy, 'http://localhost:3128')

    @patch('SoftLayer.API.Client.call')
    def test_authenticate_with_password(self, _call):
        _call.return_value = {
            'userId': 12345,
            'hash': 'TOKEN',
        }
        self.client.authenticate_with_password('USERNAME', 'PASSWORD')
        _call.assert_called_with(
            'User_Customer',
            'getPortalLoginToken',
            'USERNAME',
            'PASSWORD',
            None,
            None)
        self.assertIsNotNone(self.client.auth)
        self.assertEquals(self.client.auth.user_id, 12345)
        self.assertEquals(self.client.auth.auth_token, 'TOKEN')

########NEW FILE########
__FILENAME__ = auth_tests
"""
    SoftLayer.tests.auth_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.auth import (
    AuthenticationBase, BasicAuthentication, TokenAuthentication)
from SoftLayer.tests import unittest


class TestAuthenticationBase(unittest.TestCase):
    def test_get_headers(self):
        auth = AuthenticationBase()
        self.assertRaises(NotImplementedError, auth.get_headers)


class TestBasicAuthentication(unittest.TestCase):
    def setUp(self):
        self.auth = BasicAuthentication('USERNAME', 'APIKEY')

    def test_attribs(self):
        self.assertEquals(self.auth.username, 'USERNAME')
        self.assertEquals(self.auth.api_key, 'APIKEY')

    def test_get_headers(self):
        self.assertEquals(self.auth.get_headers(), {
            'authenticate': {
                'username': 'USERNAME',
                'apiKey': 'APIKEY',
            }
        })

    def test_repr(self):
        s = repr(self.auth)
        self.assertIn('BasicAuthentication', s)
        self.assertIn('USERNAME', s)


class TestTokenAuthentication(unittest.TestCase):
    def setUp(self):
        self.auth = TokenAuthentication(12345, 'TOKEN')

    def test_attribs(self):
        self.assertEquals(self.auth.user_id, 12345)
        self.assertEquals(self.auth.auth_token, 'TOKEN')

    def test_get_headers(self):
        self.assertEquals(self.auth.get_headers(), {
            'authenticate': {
                'complexType': 'PortalLoginToken',
                'userId': 12345,
                'authToken': 'TOKEN',
            }
        })

    def test_repr(self):
        s = repr(self.auth)
        self.assertIn('TokenAuthentication', s)
        self.assertIn('12345', s)
        self.assertIn('TOKEN', s)

########NEW FILE########
__FILENAME__ = basic_tests
"""
    SoftLayer.tests.basic_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Tests shared code

    :license: MIT, see LICENSE for more details.
"""
import SoftLayer
from SoftLayer.tests import unittest


class TestExceptions(unittest.TestCase):

    def test_softlayer_api_error(self):
        e = SoftLayer.SoftLayerAPIError('fault code', 'fault string')
        self.assertEquals(e.faultCode, 'fault code')
        self.assertEquals(e.faultString, 'fault string')
        self.assertEquals(e.reason, 'fault string')
        self.assertEquals(
            repr(e), "<SoftLayerAPIError(fault code): fault string>")
        self.assertEquals(
            str(e), "SoftLayerAPIError(fault code): fault string")

    def test_parse_error(self):
        e = SoftLayer.ParseError('fault code', 'fault string')
        self.assertEquals(e.faultCode, 'fault code')
        self.assertEquals(e.faultString, 'fault string')
        self.assertEquals(e.reason, 'fault string')
        self.assertEquals(
            repr(e), "<ParseError(fault code): fault string>")
        self.assertEquals(
            str(e), "ParseError(fault code): fault string")


class TestUtils(unittest.TestCase):

    def test_query_filter(self):
        result = SoftLayer.utils.query_filter('test')
        self.assertEqual({'operation': '_= test'}, result)

        result = SoftLayer.utils.query_filter('~ test')
        self.assertEqual({'operation': '~ test'}, result)

        result = SoftLayer.utils.query_filter('*test')
        self.assertEqual({'operation': '$= test'}, result)

        result = SoftLayer.utils.query_filter('test*')
        self.assertEqual({'operation': '^= test'}, result)

        result = SoftLayer.utils.query_filter('*test*')
        self.assertEqual({'operation': '*= test'}, result)

        result = SoftLayer.utils.query_filter('> 10')
        self.assertEqual({'operation': '> 10'}, result)

        result = SoftLayer.utils.query_filter('>10')
        self.assertEqual({'operation': '> 10'}, result)

        result = SoftLayer.utils.query_filter(10)
        self.assertEqual({'operation': 10}, result)


class TestNestedDict(unittest.TestCase):

    def test_basic(self):
        n = SoftLayer.utils.NestedDict()
        self.assertEqual(n['test'], SoftLayer.utils.NestedDict())

        n['test_set'] = 1
        self.assertEqual(n['test_set'], 1)

        d = {
            'test': {
                'nested': 1
            }}

        n = SoftLayer.utils.NestedDict(d)
        self.assertEqual(d, n)
        self.assertEqual(n['test']['nested'], 1)

        # new default top level elements should return a new NestedDict()
        self.assertEqual(n['not']['nested'], SoftLayer.utils.NestedDict())

        # NestedDict doesn't convert dict children, just the top level dict
        # so you can't assume the same behavior with children
        self.assertRaises(KeyError, lambda: n['test']['not']['nested'])

    def test_to_dict(self):
        n = SoftLayer.utils.NestedDict()
        n['test']['test1']['test2']['test3'] = {}
        d = n.to_dict()

        self.assertEqual({
            'test': {'test1': {'test2': {'test3': {}}}}
        }, d)
        self.assertEqual(dict, type(d))
        self.assertEqual(dict, type(d['test']))
        self.assertEqual(dict, type(d['test']['test1']))
        self.assertEqual(dict, type(d['test']['test1']['test2']))
        self.assertEqual(dict, type(d['test']['test1']['test2']['test3']))


class TestLookup(unittest.TestCase):

    def test_lookup(self):
        d = {'test': {'nested': 1}}
        val = SoftLayer.utils.lookup(d, 'test')
        self.assertEqual(val, {'nested': 1})

        val = SoftLayer.utils.lookup(d, 'test', 'nested')
        self.assertEqual(val, 1)

        val = SoftLayer.utils.lookup(d, 'test1')
        self.assertEqual(val, None)

        val = SoftLayer.utils.lookup(d, 'test1', 'nested1')
        self.assertEqual(val, None)


def is_a(string):
    if string == 'a':
        return ['this', 'is', 'a']


def is_b(string):
    if string == 'b':
        return ['this', 'is', 'b']


class IdentifierFixture(SoftLayer.utils.IdentifierMixin):
    resolvers = [is_a, is_b]


class TestIdentifierMixin(unittest.TestCase):

    def setUp(self):
        self.fixture = IdentifierFixture()

    def test_integer(self):
        ids = self.fixture.resolve_ids(1234)
        self.assertEqual(ids, [1234])

    def test_a(self):
        ids = self.fixture.resolve_ids('a')
        self.assertEqual(ids, ['this', 'is', 'a'])

    def test_b(self):
        ids = self.fixture.resolve_ids('b')
        self.assertEqual(ids, ['this', 'is', 'b'])

    def test_not_found(self):
        ids = self.fixture.resolve_ids('something')
        self.assertEqual(ids, [])

    def test_globalidentifier(self):
        ids = self.fixture.resolve_ids('9d888bc2-7c9a-4dba-bbd8-6bd688687bae')
        self.assertEqual(ids, ['9d888bc2-7c9a-4dba-bbd8-6bd688687bae'])

    def test_globalidentifier_upper(self):
        ids = self.fixture.resolve_ids('B534EF96-55C4-4891-B51A-63866411B58E')
        self.assertEqual(ids, ['B534EF96-55C4-4891-B51A-63866411B58E'])

########NEW FILE########
__FILENAME__ = core_tests
"""
    SoftLayer.tests.CLI.core_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import MagicMock, patch

import SoftLayer

from SoftLayer.tests import unittest
from SoftLayer.CLI import core
from SoftLayer.CLI.helpers import CLIAbort
from SoftLayer.CLI.environment import Environment, InvalidModule, CLIRunnable


def module_fixture():
    """
usage: sl vs <command> [<args>...] [options]
       sl vs [-h | --help]
"""


def module_no_command_fixture():
    """
usage: sl vs [<args>...] [options]
       sl vs [-h | --help]
"""


class submodule_fixture(CLIRunnable):
    """
usage: sl vs list [options]

Options:
  --hourly  Show hourly instances
"""
    options = []

    def execute(self, args):
        return "test"


class EnvironmentFixture(Environment):
    def __init__(self):
        super(EnvironmentFixture, self).__init__()
        self.plugins = {'vs': {'list': submodule_fixture}}
        self.aliases = {
            'meta': 'metadata',
            'my': 'metadata',
        }
        self.config = {}

    def load_module(self, *args, **kwargs):
        return module_fixture

    def plugin_list(self, *args, **kwargs):
        return self.plugins.keys()


class CommandLineTests(unittest.TestCase):
    def setUp(self):
        self.env = EnvironmentFixture()
        self.env.get_module_name = MagicMock()

    def test_normal_path(self):
        self.env.get_module_name.return_value = 'vs'
        self.assertRaises(
            SystemExit, core.main,
            args=['vs', 'list', '--config=path/to/config'],
            env=self.env)
        self.assertRaises(
            SystemExit, core.main,
            args=['vs', 'nope', '--config=path/to/config'], env=self.env)
        self.assertRaises(
            SystemExit, core.main,
            args=['vs', 'list', '--format=totallynotvalid'], env=self.env)

    @patch('SoftLayer.TimedClient.get_last_calls')
    def test_normal_path_with_timings(self, calls_mock):
        calls_mock.return_value = [('SERVICE.METHOD', 1000, 0.25)]
        self.env.get_module_name.return_value = 'vs'
        self.assertRaises(
            SystemExit, core.main,
            args=['vs', 'list', '--config=path/to/config', '--timings'],
            env=self.env)
        calls_mock.assert_called()

    @patch('logging.getLogger')
    @patch('logging.StreamHandler')
    def test_with_debug(self, stream_handler, logger):
        self.env.get_module_name.return_value = 'vs'
        self.assertRaises(
            SystemExit, core.main,
            args=['vs', 'list', '--debug=3'],
            env=self.env)
        logger().setLevel.assert_called_with(10)
        logger().addHandler.assert_called_with(stream_handler())

    def test_invalid_module(self):
        self.env.get_module_name.return_value = 'nope'
        self.assertRaises(
            SystemExit, core.main,
            args=['nope', 'list', '--config=path/to/config'], env=self.env)

    def test_module_with_no_command(self):
        self.env.plugins = {
            'vs': {'list': submodule_fixture, None: submodule_fixture}
        }
        self.env.get_module_name.return_value = 'vs'
        self.env.load_module = MagicMock()
        self.env.load_module.return_value = module_no_command_fixture
        resolver = core.CommandParser(self.env)
        command, command_args = resolver.parse(['vs', 'list'])
        self.assertEqual(submodule_fixture, command)

    def test_main(self):
        self.env.get_module_name.return_value = 'vs'
        self.env.plugins = {
            'vs': {'list': submodule_fixture}
        }
        self.assertRaises(
            SystemExit, core.main,
            args=['vs', 'list'],
            env=self.env)

    def test_help(self):
        self.env.get_module_name.return_value = 'help'
        self.assertRaises(
            SystemExit, core.main,
            args=['help', 'vs', '--config=path/to/config'], env=self.env)

    def test_keyboard_interrupt(self):
        self.env.get_module_name.side_effect = KeyboardInterrupt
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    def test_abort(self):
        self.env.get_module_name.side_effect = CLIAbort('exit!')
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    def test_invalid_module_error(self):
        self.env.get_module_name.side_effect = InvalidModule('vs')
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    def test_softlayer_error(self):
        self.env.get_module_name.side_effect = SoftLayer.SoftLayerError
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    def test_softlayer_api_error(self):
        error = SoftLayer.SoftLayerAPIError('Exception', 'Exception Text')
        self.env.get_module_name.side_effect = error
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    def test_softlayer_api_error_authentication_error(self):
        error = SoftLayer.SoftLayerAPIError('SoftLayerException',
                                            'Invalid API Token')
        self.env.get_module_name.side_effect = error
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    def test_system_exit_error(self):
        self.env.get_module_name.side_effect = SystemExit
        self.assertRaises(
            SystemExit, core.main, args=['vs', 'list'], env=self.env)

    @patch('traceback.format_exc')
    def test_uncaught_error(self, m):
        # Exceptions not caught should just Exit
        errors = [TypeError, RuntimeError, NameError, OSError, SystemError]
        for err in errors:
            m.reset_mock()
            m.return_value = 'testing'
            self.env.get_module_name.side_effect = err
            self.assertRaises(
                SystemExit, core.main, args=['vs', 'list'], env=self.env)
            m.assert_called_once_with()


class TestCommandParser(unittest.TestCase):
    def setUp(self):
        self.env = EnvironmentFixture()
        self.parser = core.CommandParser(self.env)

    def test_main(self,):
        args = self.parser.parse_main_args(
            args=['vs', 'list'])

        self.assertEqual(args['help'], False)
        self.assertEqual(args['<module>'], 'vs')
        self.assertEqual(args['<args>'], ['list'])

    def test_primary_help(self):
        args = self.parser.parse_main_args(args=[])
        self.assertEqual({
            '--help': False,
            '-h': False,
            '<args>': [],
            '<module>': None,
            '<command>': None,
            'help': False,
        }, args)

        args = self.parser.parse_main_args(args=['help'])
        self.assertEqual({
            '--help': False,
            '-h': False,
            '<args>': [],
            '<module>': 'help',
            '<command>': None,
            'help': False,
        }, args)

        args = self.parser.parse_main_args(args=['help', 'module'])
        self.assertEqual({
            '--help': False,
            '-h': False,
            '<args>': ['module'],
            '<module>': 'help',
            '<command>': None,
            'help': False,
        }, args)

        self.assertRaises(
            SystemExit, self.parser.parse_main_args, args=['--help'])

    @patch('sys.stdout.isatty', return_value=True)
    def test_tty(self, tty):
        self.assertRaises(
            SystemExit, self.parser.parse_command_args, 'vs', 'list', [])

    def test_confirm(self):
        command = MagicMock()
        command.options = ['confirm']
        command.__doc__ = 'usage: sl vs list [options]'
        self.env.get_command = MagicMock()
        self.env.get_command.return_value = command
        self.assertRaises(
            SystemExit, self.parser.parse_command_args, 'vs', 'list', [])

########NEW FILE########
__FILENAME__ = environment_tests
"""
    SoftLayer.tests.CLI.environment_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
import os
from mock import patch, MagicMock

from SoftLayer.tests import unittest
from SoftLayer.CLI.environment import Environment, InvalidCommand


class EnvironmentTests(unittest.TestCase):

    def setUp(self):
        self.env = Environment()

    def test_plugin_list(self):
        actions = self.env.plugin_list()
        self.assertIn('vs', actions)
        self.assertIn('dns', actions)

    def test_add_plugin(self):
        m = MagicMock()
        m.action = 'add_plugin_action_test'
        self.env.add_plugin(m)

        self.assertEqual(self.env.plugins,
                         {'mock': {'add_plugin_action_test': m}})

    def test_out(self):
        self.env.stdout = MagicMock()
        self.env.out('TEXT OUTPUT')
        self.env.stdout.write.assert_any_call('TEXT OUTPUT')
        self.env.stdout.write.assert_any_call(os.linesep)

    def test_err(self):
        self.env.stderr = MagicMock()
        self.env.err('TEXT OUTPUT')
        self.env.stderr.write.assert_any_call('TEXT OUTPUT')
        self.env.stderr.write.assert_any_call(os.linesep)

    @patch('SoftLayer.CLI.environment.console_input')
    def test_input(self, raw_input_mock):
        r = self.env.input('input')
        raw_input_mock.assert_called_with('input')
        self.assertEqual(raw_input_mock(), r)

    @patch('getpass.getpass')
    def test_getpass(self, getpass):
        r = self.env.getpass('input')
        getpass.assert_called_with('input')
        self.assertEqual(getpass(), r)

    def test_get_module_name(self):
        self.env.aliases = {'aliasname': 'realname'}
        r = self.env.get_module_name('aliasname')
        self.assertEqual(r, 'realname')

        r = self.env.get_module_name('realname')
        self.assertEqual(r, 'realname')

    def test_get_command_invalid(self):
        self.assertRaises(InvalidCommand, self.env.get_command, 'vs', 'list')

    def test_get_command(self):
        self.env.plugins = {'vs': {'list': 'something'}}
        command = self.env.get_command('vs', 'list')
        self.assertEqual(command, 'something')

    def test_get_command_none(self):
        # If None is in the action list, anything that doesn't exist as a
        # command will return the value of the None key. This is to support
        # sl help any_module_name
        self.env.plugins = {'vs': {None: 'something'}}
        command = self.env.get_command('vs', 'something else')
        self.assertEqual(command, 'something')

    def test_exit(self):
        self.assertRaises(SystemExit, self.env.exit, 1)

########NEW FILE########
__FILENAME__ = helper_tests
"""
    SoftLayer.tests.CLI.helper_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
import sys
import os
import json

import SoftLayer.CLI as cli
from SoftLayer.tests import FIXTURE_PATH, unittest
from mock import patch, mock_open, call

if sys.version_info >= (3,):
    open_path = 'builtins.open'
else:
    open_path = '__builtin__.open'


class CLIJSONEncoderTest(unittest.TestCase):
    def test_default(self):
        out = json.dumps({
            'formattedItem': cli.helpers.FormattedItem('normal', 'formatted')
        }, cls=cli.formatting.CLIJSONEncoder)
        self.assertEqual(out, '{"formattedItem": "normal"}')

        out = json.dumps({'normal': 'string'},
                         cls=cli.formatting.CLIJSONEncoder)
        self.assertEqual(out, '{"normal": "string"}')

    def test_fail(self):
        self.assertRaises(
            TypeError,
            json.dumps, {'test': object()}, cls=cli.formatting.CLIJSONEncoder)


class PromptTests(unittest.TestCase):

    @patch('SoftLayer.CLI.formatting.console_input')
    def test_invalid_response(self, raw_input_mock):
        raw_input_mock.return_value = 'y'
        result = cli.helpers.valid_response('test', 'n')
        raw_input_mock.assert_called_with('test')
        self.assertFalse(result)

        raw_input_mock.return_value = 'wakakwakwaka'
        result = cli.helpers.valid_response('test', 'n')
        raw_input_mock.assert_called_with('test')
        self.assertFalse(result)

        raw_input_mock.return_value = ''
        result = cli.helpers.valid_response('test', 'n')
        raw_input_mock.assert_called_with('test')
        self.assertEqual(result, None)

    @patch('SoftLayer.CLI.formatting.console_input')
    def test_valid_response(self, raw_input_mock):
        raw_input_mock.return_value = 'n'
        result = cli.helpers.valid_response('test', 'n')
        raw_input_mock.assert_called_with('test')
        self.assertTrue(result)

        raw_input_mock.return_value = 'N'
        result = cli.helpers.valid_response('test', 'n')
        raw_input_mock.assert_called_with('test')
        self.assertTrue(result)

    @patch('SoftLayer.CLI.formatting.console_input')
    def test_do_or_die(self, raw_input_mock):
        confirmed = '37347373737'
        raw_input_mock.return_value = confirmed
        result = cli.no_going_back(confirmed)
        self.assertTrue(result)

        # no_going_back should cast int's to str()
        confirmed = '4712309182309'
        raw_input_mock.return_value = confirmed
        result = cli.no_going_back(int(confirmed))
        self.assertTrue(result)

        confirmed = None
        raw_input_mock.return_value = ''
        result = cli.no_going_back(confirmed)
        self.assertFalse(result)

    def test_clirunnable_exercise(self):
        runnable = cli.CLIRunnable()
        res = runnable.execute({})
        self.assertEqual(res, None)

    @patch('SoftLayer.CLI.formatting.console_input')
    def test_confirmation(self, raw_input_mock):
        raw_input_mock.return_value = 'Y'
        res = cli.confirm('Confirm?', default=False)
        self.assertTrue(res)

        raw_input_mock.return_value = 'N'
        res = cli.confirm('Confirm?', default=False)
        self.assertFalse(res)

        raw_input_mock.return_value = ''
        res = cli.confirm('Confirm?', default=True)
        self.assertTrue(res)


class FormattedItemTests(unittest.TestCase):

    def test_init(self):
        item = cli.FormattedItem('test', 'test_formatted')
        self.assertEqual('test', item.original)
        self.assertEqual('test_formatted', item.formatted)
        self.assertEqual('test', str(item))

        item = cli.FormattedItem('test')
        self.assertEqual('test', item.original)
        self.assertEqual('test', item.formatted)
        self.assertEqual('test', str(item))

    def test_mb_to_gb(self):
        item = cli.mb_to_gb(1024)
        self.assertEqual(1024, item.original)
        self.assertEqual('1G', item.formatted)

        item = cli.mb_to_gb('1024')
        self.assertEqual('1024', item.original)
        self.assertEqual('1G', item.formatted)

        item = cli.mb_to_gb('1025.0')
        self.assertEqual('1025.0', item.original)
        self.assertEqual('1G', item.formatted)

        self.assertRaises(ValueError, cli.mb_to_gb, '1024string')

    def test_gb(self):
        item = cli.gb(2)
        self.assertEqual(2048, item.original)
        self.assertEqual('2G', item.formatted)

        item = cli.gb('2')
        self.assertEqual(2048, item.original)
        self.assertEqual('2G', item.formatted)

        item = cli.gb('2.0')
        self.assertEqual(2048, item.original)
        self.assertEqual('2G', item.formatted)

    def test_blank(self):
        item = cli.helpers.blank()
        self.assertEqual(None, item.original)
        self.assertEqual('-', item.formatted)
        self.assertEqual('NULL', str(item))


class FormattedListTests(unittest.TestCase):
    def test_init(self):
        l = cli.listing([1, 'two'], separator=':')
        self.assertEqual([1, 'two'], list(l))
        self.assertEqual(':', l.separator)

        l = cli.listing([])
        self.assertEqual(',', l.separator)

    def test_to_python(self):
        l = cli.listing([1, 'two'])
        result = l.to_python()
        self.assertEqual([1, 'two'], result)

        l = cli.listing(x for x in [1, 'two'])
        result = l.to_python()
        self.assertEqual([1, 'two'], result)

    def test_str(self):
        l = cli.listing([1, 'two'])
        result = str(l)
        self.assertEqual('1,two', result)

        l = cli.listing((x for x in [1, 'two']), separator=':')
        result = str(l)
        self.assertEqual('1:two', result)


class FormattedTxnTests(unittest.TestCase):
    def test_active_txn_empty(self):
        self.assertRaises(KeyError, cli.active_txn, {})

    def test_active_txn(self):
        result = cli.active_txn({
            'activeTransaction': {
                'transactionStatus': {
                    'name': 'a',
                    'friendlyName': 'b'
                }
            }
        })
        self.assertEquals(result.original, 'a')
        self.assertEquals(result.formatted, 'b')
        self.assertIsInstance(result, cli.FormattedItem)

    def test_active_txn_missing(self):
        """ a dict with activeTransaction but not transactionStatus
            should return blank() instead of raising an exception"""
        b = cli.blank()

        result = cli.active_txn({
            'activeTransaction': {}
        })
        self.assertIsInstance(result, cli.FormattedItem)
        self.assertEquals(result.original, b.original)

    def test_transaction_status(self):
        result = cli.transaction_status({
            'transactionStatus': {
                'name': 'a',
                'friendlyName': 'b'
            }
        })
        self.assertEquals(result.original, 'a')
        self.assertEquals(result.formatted, 'b')
        self.assertIsInstance(result, cli.FormattedItem)

    def test_transaction_status_missing(self):
        b = cli.blank()

        result = cli.transaction_status({
            'transactionStatus': {}
        })
        self.assertIsInstance(result, cli.FormattedItem)
        self.assertEqual(result.original, b.original)


class CLIAbortTests(unittest.TestCase):

    def test_init(self):
        e = cli.helpers.CLIAbort("something")
        self.assertEqual(2, e.code)
        self.assertEqual("something", e.message)
        self.assertIsInstance(e, cli.helpers.CLIHalt)


class ResolveIdTests(unittest.TestCase):

    def test_resolve_id_one(self):
        resolver = lambda r: [12345]
        id = cli.helpers.resolve_id(resolver, 'test')

        self.assertEqual(id, 12345)

    def test_resolve_id_none(self):
        resolver = lambda r: []
        self.assertRaises(
            cli.helpers.CLIAbort, cli.helpers.resolve_id, resolver, 'test')

    def test_resolve_id_multiple(self):
        resolver = lambda r: [12345, 54321]
        self.assertRaises(
            cli.helpers.CLIAbort, cli.helpers.resolve_id, resolver, 'test')


class TestFormatOutput(unittest.TestCase):

    def test_format_output_string(self):
        t = cli.helpers.format_output('just a string', 'raw')
        self.assertEqual('just a string', t)

        t = cli.helpers.format_output(b'just a string', 'raw')
        self.assertEqual(b'just a string', t)

    def test_format_output_raw(self):
        t = cli.Table(['nothing'])
        t.align['nothing'] = 'c'
        t.add_row(['testdata'])
        t.sortby = 'nothing'
        ret = cli.helpers.format_output(t, 'raw')

        self.assertNotIn('nothing', str(ret))
        self.assertIn('testdata', str(ret))

    def test_format_output_json(self):
        t = cli.Table(['nothing'])
        t.align['nothing'] = 'c'
        t.add_row(['testdata'])
        t.add_row([cli.helpers.blank()])
        t.sortby = 'nothing'
        ret = cli.helpers.format_output(t, 'json')
        # This uses json.dumps due to slight changes in the output between
        # py3.3 and py3.4
        expected = json.dumps([{'nothing': 'testdata'}, {'nothing': None}],
                              indent=4)
        self.assertEqual(expected, ret)

        ret = cli.helpers.format_output('test', 'json')
        self.assertEqual('"test"', ret)

    def test_format_output_json_keyvaluetable(self):
        t = cli.KeyValueTable(['key', 'value'])
        t.add_row(['nothing', cli.helpers.blank()])
        t.sortby = 'nothing'
        ret = cli.helpers.format_output(t, 'json')
        self.assertEqual('''{
    "nothing": null
}''', ret)

    def test_format_output_formatted_item(self):
        item = cli.FormattedItem('test', 'test_formatted')
        ret = cli.helpers.format_output(item, 'table')
        self.assertEqual('test_formatted', ret)

    def test_format_output_list(self):
        item = ['this', 'is', 'a', 'list']
        ret = cli.helpers.format_output(item, 'table')
        self.assertEqual(os.linesep.join(item), ret)

    def test_format_output_table(self):
        t = cli.Table(['nothing'])
        t.align['nothing'] = 'c'
        t.add_row(['testdata'])
        t.sortby = 'nothing'
        ret = cli.helpers.format_output(t, 'table')

        self.assertIn('nothing', str(ret))
        self.assertIn('testdata', str(ret))

    def test_unknown(self):
        t = cli.helpers.format_output({}, 'raw')
        self.assertEqual({}, t)

    def test_sequentialoutput(self):
        t = cli.helpers.SequentialOutput()
        self.assertTrue(hasattr(t, 'append'))
        t.append('This is a test')
        t.append('')
        t.append('More tests')
        output = cli.helpers.format_output(t)
        self.assertEqual("This is a test\nMore tests", output)

        t.separator = ','
        output = cli.helpers.format_output(t)
        self.assertEqual("This is a test,More tests", output)

    def test_format_output_python(self):
        t = cli.helpers.format_output('just a string', 'python')
        self.assertEqual('just a string', t)

        t = cli.helpers.format_output(['just a string'], 'python')
        self.assertEqual(['just a string'], t)

        t = cli.helpers.format_output({'test_key': 'test_value'}, 'python')
        self.assertEqual({'test_key': 'test_value'}, t)

    def test_format_output_python_keyvaluetable(self):
        t = cli.KeyValueTable(['key', 'value'])
        t.add_row(['nothing', cli.helpers.blank()])
        t.sortby = 'nothing'
        ret = cli.helpers.format_output(t, 'python')
        self.assertEqual({'nothing': None}, ret)


class TestTemplateArgs(unittest.TestCase):

    def test_no_template_option(self):
        args = {'key': 'value'}
        cli.helpers.update_with_template_args(args)
        self.assertEqual(args, {'key': 'value'})

    def test_template_not_exists(self):
        path = os.path.join(FIXTURE_PATH, 'sample_template_not_exists.conf')
        self.assertRaises(cli.helpers.ArgumentError,
                          cli.helpers.update_with_template_args,
                          {'--template': path})

    def test_template_options(self):
        path = os.path.join(FIXTURE_PATH, 'sample_vs_template.conf')
        args = {
            'key': 'value',
            '--cpu': None,
            '--memory': '32',
            '--template': path,
            '--hourly': False,
            '--disk': [],
        }
        cli.helpers.update_with_template_args(args, list_args=['--disk'])
        self.assertEqual(args, {
            '--cpu': '4',
            '--datacenter': 'dal05',
            '--domain': 'example.com',
            '--hostname': 'myhost',
            '--hourly': 'true',
            '--memory': '32',
            '--monthly': 'false',
            '--network': '100',
            '--os': 'DEBIAN_7_64',
            'key': 'value',
            '--disk': ['50', '100'],
        })


class TestExportToTemplate(unittest.TestCase):
    def test_export_to_template(self):
        with patch(open_path, mock_open(), create=True) as open_:
            cli.helpers.export_to_template('filename', {
                '--os': None,
                '--datacenter': 'ams01',
                '--disk': ['disk1', 'disk2'],
                # The following should get stripped out
                '--config': 'no',
                '--really': 'no',
                '--format': 'no',
                '--debug': 'no',
                # exclude list
                '--test': 'test',
            }, exclude=['--test'])

            open_.assert_called_with('filename', 'w')
            open_().write.assert_has_calls([
                call('datacenter=ams01\n'),
                call('disk=disk1,disk2\n'),
            ], any_order=True)  # Order isn't really guaranteed

########NEW FILE########
__FILENAME__ = cdn_tests
"""
    SoftLayer.tests.CLI.modules.cdn_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.modules import cdn


class CdnTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_list_accounts(self):
        command = cdn.ListAccounts(client=self.client)

        output = command.execute({'--sortby': None})
        self.assertEqual([{'notes': None,
                           'created': '2012-06-25T14:05:28-07:00',
                           'type': 'ORIGIN_PULL',
                           'id': 1234,
                           'account_name': '1234a'},
                          {'notes': None,
                           'created': '2012-07-24T13:34:25-07:00',
                           'type': 'POP_PULL',
                           'id': 1234,
                           'account_name': '1234a'}],
                         format_output(output, 'python'))

    def test_detail_account(self):
        command = cdn.DetailAccount(client=self.client)

        output = command.execute({'<account>': '1234'})
        self.assertEqual({'notes': None,
                          'created': '2012-06-25T14:05:28-07:00',
                          'type': 'ORIGIN_PULL',
                          'status': 'ACTIVE',
                          'id': 1234,
                          'account_name': '1234a'},
                         format_output(output, 'python'))

    def test_load_content(self):
        command = cdn.LoadContent(client=self.client)

        output = command.execute({'<account>': '1234',
                                  '<content_url>': ['http://example.com']})
        self.assertEqual(None, output)

    def test_purge_content(self):
        command = cdn.PurgeContent(client=self.client)

        output = command.execute({'<account>': '1234',
                                  '<content_url>': ['http://example.com']})
        self.assertEqual(None, output)

    def test_list_origins(self):
        command = cdn.ListOrigins(client=self.client)

        output = command.execute({'<account>': '1234'})
        self.assertEqual([
            {'media_type': 'FLASH',
             'origin_url': 'http://ams01.objectstorage.softlayer.net:80',
             'cname': None,
             'id': '12345'},
            {'media_type': 'FLASH',
             'origin_url': 'http://sng01.objectstorage.softlayer.net:80',
             'cname': None,
             'id': '12345'}], format_output(output, 'python'))

    def test_add_origin(self):
        command = cdn.AddOrigin(client=self.client)

        output = command.execute({'<account>': '1234',
                                  '<url>': 'http://example.com'})
        self.assertEqual(None, output)

    def test_remove_origin(self):
        command = cdn.RemoveOrigin(client=self.client)

        output = command.execute({'<account>': '1234',
                                  '<origin_id>': '12345'})
        self.assertEqual(None, output)

########NEW FILE########
__FILENAME__ = config_tests
"""
    SoftLayer.tests.CLI.modules.config_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import MagicMock, patch
import tempfile

from SoftLayer import API_PUBLIC_ENDPOINT, API_PRIVATE_ENDPOINT
from SoftLayer.auth import BasicAuthentication
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.modules import config
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.exceptions import CLIAbort


class TestHelpShow(unittest.TestCase):
    def setUp(self):
        client = MagicMock()
        client.auth.username = 'user'
        client.auth.api_key = '12345'
        client.endpoint_url = 'https://some/endpoint'
        client.timeout = 10
        self.client = client

    def test_show(self):
        command = config.Show(client=self.client)

        output = command.execute({})

        expected = {'Username': self.client.auth.username,
                    'Endpoint URL': self.client.endpoint_url,
                    'API Key': self.client.auth.api_key,
                    'Timeout': self.client.timeout}
        self.assertEqual(expected, format_output(output, 'python'))


class TestHelpSetup(unittest.TestCase):
    def setUp(self):
        client = FixtureClient()
        client.auth = BasicAuthentication('default-user', 'default-key')
        client.endpoint_url = 'default-endpoint-url'
        client.timeout = 10
        self.client = client
        self.env = MagicMock()

    @patch('SoftLayer.CLI.modules.config.confirm')
    def test_setup(self, confirm_mock):
        with tempfile.NamedTemporaryFile() as config_file:
            confirm_mock.return_value = True
            self.env.getpass.return_value = 'A' * 64
            self.env.input.side_effect = ['user', 'public']

            command = config.Setup(client=self.client, env=self.env)
            output = command.execute({'--config': config_file.name})

            self.assertEqual('Configuration Updated Successfully', output)
            contents = config_file.read().decode("utf-8")
            self.assertTrue('[softlayer]' in contents)
            self.assertTrue('username = user' in contents)
            self.assertTrue('api_key = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
                            'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA' in contents)
            self.assertTrue('endpoint_url = %s' % API_PUBLIC_ENDPOINT
                            in contents)

    @patch('SoftLayer.CLI.modules.config.confirm')
    def test_setup_cancel(self, confirm_mock):
        with tempfile.NamedTemporaryFile() as config_file:
            confirm_mock.return_value = False
            self.env.getpass.return_value = 'A' * 64
            self.env.input.side_effect = ['user', 'public']

            command = config.Setup(client=self.client, env=self.env)
            self.assertRaises(CLIAbort,
                              command.execute, {'--config': config_file.name})

    def test_get_user_input_private(self):
        command = config.Setup(client=self.client, env=self.env)
        # get_user_input
        self.env.getpass.return_value = 'A' * 64
        self.env.input.side_effect = ['user', 'private']

        username, secret, endpoint_url, timeout = command.get_user_input()

        self.assertEqual(username, 'user')
        self.assertEqual(secret, 'A' * 64)
        self.assertEqual(endpoint_url, API_PRIVATE_ENDPOINT)
        self.assertEqual(timeout, 10)

    def test_get_user_input_custom(self):
        command = config.Setup(client=self.client, env=self.env)
        # get_user_input
        self.env.getpass.return_value = 'A' * 64
        self.env.input.side_effect = ['user', 'custom', 'custom-endpoint']

        _, _, endpoint_url, _ = command.get_user_input()

        self.assertEqual(endpoint_url, 'custom-endpoint')

    def test_get_user_input_default(self):
        command = config.Setup(client=self.client, env=self.env)
        # get_user_input
        self.env.getpass.return_value = 'A' * 64
        self.env.input.side_effect = ['user', '']

        _, _, endpoint_url, _ = command.get_user_input()

        self.assertEqual(endpoint_url, API_PUBLIC_ENDPOINT)

########NEW FILE########
__FILENAME__ = dns_tests
"""
    SoftLayer.tests.CLI.modules.dns_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import patch

from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Dns_Domain
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.exceptions import CLIAbort
from SoftLayer.CLI.modules import dns


class DnsTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_dump_zone(self):
        command = dns.DumpZone(client=self.client)

        output = command.execute({'<zone>': '1234'})
        self.assertEqual('lots of text', output)

    def test_create_zone(self):
        command = dns.CreateZone(client=self.client)

        output = command.execute({'<zone>': 'example.com'})
        self.assertEqual(None, output)

    @patch('SoftLayer.CLI.modules.dns.no_going_back')
    def test_delete_zone(self, no_going_back_mock):
        no_going_back_mock.return_value = True
        command = dns.DeleteZone(client=self.client)

        output = command.execute({'<zone>': 'example.com', '--really': False})
        self.assertEqual(None, output)

        no_going_back_mock.return_value = False
        command = dns.DeleteZone(client=self.client)

        self.assertRaises(CLIAbort,
                          command.execute, {'<zone>': 'example.com',
                                            '--really': False})

    def test_list_zones(self):
        command = dns.ListZones(client=self.client)

        output = command.execute({'<zone>': None})
        self.assertEqual([{'serial': 2014030728,
                           'updated': '2014-03-07T13:52:31-06:00',
                           'id': 12345, 'zone': 'example.com'}],
                         format_output(output, 'python'))

    def test_list_all_zones(self):
        command = dns.ListZones(client=self.client)

        output = command.execute({'<zone>': 'example.com'})
        self.assertEqual({'record': 'a',
                          'type': 'CNAME',
                          'id': 1,
                          'value': 'd',
                          'ttl': 100},
                         format_output(output, 'python')[0])

    def test_add_record(self):
        command = dns.AddRecord(client=self.client)

        output = command.execute({'<zone>': 'example.com',
                                  '<record>': 'hostname',
                                  '<type>': 'A',
                                  '<data>': 'd',
                                  '--ttl': 100})
        self.assertEqual(None, output)

    def test_edit_record(self):
        command = dns.EditRecord(client=self.client)

        output = command.execute({'<zone>': 'example.com',
                                  '<record>': 'hostname',
                                  '<type>': 'A',
                                  '--data': 'd',
                                  '--id': 1,
                                  '--ttl': 100})
        self.assertEqual(None, output)

        output = command.execute({'<zone>': 'example.com',
                                  '<record>': 'hostname',
                                  '<type>': 'A',
                                  '--data': 'd',
                                  '--id': None,
                                  '--ttl': 100})
        self.assertEqual(None, output)

    @patch('SoftLayer.CLI.modules.dns.no_going_back')
    def test_delete_record(self, no_going_back_mock):
        no_going_back_mock.return_value = True
        self.client['Dns_Domain'].getResourceRecords.return_value = [
            Dns_Domain.getResourceRecords[0]]
        command = dns.RecordRemove(client=self.client)
        output = command.execute({'<zone>': 'example.com',
                                  '<record>': 'hostname',
                                  '--id': '1',
                                  '--really': False})
        self.assertEqual([{'record': '1'}], format_output(output, 'python'))

        output = command.execute({'<zone>': 'example.com',
                                  '<record>': 'hostname',
                                  '--id': None,
                                  '--really': False})
        self.assertEqual([{'record': 1}], format_output(output, 'python'))

        no_going_back_mock.return_value = False
        self.assertRaises(CLIAbort, command.execute, {'<zone>': 'example.com',
                                                      '<record>': 'hostname',
                                                      '--id': 1,
                                                      '--really': False})

########NEW FILE########
__FILENAME__ = firewall_tests
"""
    SoftLayer.tests.CLI.modules.firewall_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
# from mock import patch

from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.helpers import format_output
# from SoftLayer.CLI.exceptions import CLIAbort
from SoftLayer.CLI.modules import firewall


class FirewallTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_list_firewalls(self):
        call = self.client['Account'].getNetworkVlans
        call.return_value = [{
            'id': 1,
            'dedicatedFirewallFlag': True,
            'highAvailabilityFirewallFlag': True,
            'networkVlanFirewall': {'id': 1234},
        }, {
            'id': 2,
            'dedicatedFirewallFlag': False,
            'firewallGuestNetworkComponents': [{
                'id': 1234,
                'guestNetworkComponent': {'guest': {'id': 1}},
                'status': 'ok'}],
            'firewallNetworkComponents': [{
                'id': 1234,
                'networkComponent': {'downlinkComponent': {'hardwareId': 1}},
                'status': 'ok'}],
        }
        ]
        command = firewall.FWList(client=self.client)

        output = command.execute({})

        self.assertEqual([{'type': 'VLAN - dedicated',
                           'server/vlan id': 1,
                           'features': ['HA'],
                           'firewall id': 'vlan:1234'},
                          {'features': '-',
                           'firewall id': 'cci:1234',
                           'server/vlan id': 1,
                           'type': 'CCI - standard'},
                          {'features': '-',
                           'firewall id': 'server:1234',
                           'server/vlan id': 1,
                           'type': 'Server - standard'}],
                         format_output(output, 'python'))

########NEW FILE########
__FILENAME__ = globalip_tests
"""
    SoftLayer.tests.CLI.modules.globalip_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import patch

from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.exceptions import CLIAbort
from SoftLayer.CLI.modules import globalip


class DnsTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_ip_assign(self):
        command = globalip.GlobalIpAssign(client=self.client)

        output = command.execute({'<identifier>': '1',
                                  '<target>': '127.0.0.1'})
        self.assertEqual(None, output)

    @patch('SoftLayer.CLI.modules.globalip.no_going_back')
    def test_ip_cancel(self, no_going_back_mock):
        no_going_back_mock.return_value = True
        command = globalip.GlobalIpCancel(client=self.client)

        output = command.execute({'<identifier>': '1', '--really': False})
        self.assertEqual(None, output)

        no_going_back_mock.return_value = False

        self.assertRaises(CLIAbort,
                          command.execute,
                          {'<identifier>': '1', '--really': False})

    def test_ip_list(self):
        command = globalip.GlobalIpList(client=self.client)

        output = command.execute({'--v4': True})
        self.assertEqual([{'assigned': 'Yes',
                           'id': '200',
                           'ip': '127.0.0.1',
                           'target': '127.0.0.1 (example.com)'},
                          {'assigned': 'Yes',
                           'id': '201',
                           'ip': '127.0.0.1',
                           'target': '127.0.0.1 (example.com)'}],
                         format_output(output, 'python'))

        output = command.execute({'--v6': True})
        self.assertEqual([{'assigned': 'Yes',
                           'id': '200',
                           'ip': '127.0.0.1',
                           'target': '127.0.0.1 (example.com)'},
                          {'assigned': 'Yes',
                           'id': '201',
                           'ip': '127.0.0.1',
                           'target': '127.0.0.1 (example.com)'}],
                         format_output(output, 'python'))

########NEW FILE########
__FILENAME__ = help_tests
"""
    SoftLayer.tests.CLI.modules.help_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest
from SoftLayer.CLI.modules import help
from SoftLayer.CLI.environment import Environment


class HelpTests(unittest.TestCase):
    def test_help(self):
        command = help.Show(env=Environment())

        output = command.execute({'<module>': None, '<command>': None})
        self.assertTrue('usage: sl help' in output)

        output = command.execute({'<module>': 'help', '<command>': None})
        self.assertTrue('usage: sl help' in output)

        output = command.execute({'<module>': 'server', '<command>': 'list'})
        self.assertTrue('usage: sl server list' in output)

########NEW FILE########
__FILENAME__ = import_tests
"""
    SoftLayer.tests.CLI.modules.import_test
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest
from SoftLayer.CLI.modules import get_module_list

from importlib import import_module


class TestImportCLIModules(unittest.TestCase):

    def test_import_all(self):
        modules = get_module_list()
        for module in modules:
            module_path = 'SoftLayer.CLI.modules.' + module
            print("Importing %s" % module_path)
            import_module(module_path)

########NEW FILE########
__FILENAME__ = nas_tests
"""
    SoftLayer.tests.CLI.modules.nas_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.modules import nas
from SoftLayer.CLI.helpers import format_output


class RWhoisTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_list_nas(self):
        command = nas.ListNAS(client=self.client)
        output = command.execute({})

        self.assertEqual([{'username': 'user',
                           'datacenter': 'Dallas',
                           'server': '127.0.0.1',
                           'password': 'pass',
                           'id': 1,
                           'size': 10}],
                         format_output(output, 'python'))

########NEW FILE########
__FILENAME__ = rwhois_tests
"""
    SoftLayer.tests.CLI.modules.rwhois_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.modules import rwhois
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.exceptions import CLIAbort


class RWhoisTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_edit_nothing(self):
        command = rwhois.RWhoisEdit(client=self.client)
        self.assertRaises(CLIAbort, command.execute, {})

    def test_edit(self):
        command = rwhois.RWhoisEdit(client=self.client)
        output = command.execute({'--abuse': 'abuse@site.com',
                                  '--address1': 'address line 1',
                                  '--address2': 'address line 2',
                                  '--company': 'Company, Inc',
                                  '--city': 'Dallas',
                                  '--country': 'United States',
                                  '--firstname': 'John',
                                  '--lastname': 'Smith',
                                  '--postal': '12345',
                                  '--state': 'TX',
                                  '--state': 'TX',
                                  '--private': True,
                                  '--public': False})

        self.assertEqual(None, output)
        service = self.client['Network_Subnet_Rwhois_Data']
        service.editObject.assert_called_with({'city': 'Dallas',
                                               'firstName': 'John',
                                               'companyName': 'Company, Inc',
                                               'address1': 'address line 1',
                                               'address2': 'address line 2',
                                               'lastName': 'Smith',
                                               'abuseEmail': 'abuse@site.com',
                                               'state': 'TX',
                                               'country': 'United States',
                                               'postalCode': '12345',
                                               'privateResidenceFlag': False},
                                              id='id')

    def test_edit_public(self):
        command = rwhois.RWhoisEdit(client=self.client)
        output = command.execute({'--private': False,
                                  '--public': True})

        self.assertEqual(None, output)
        service = self.client['Network_Subnet_Rwhois_Data']
        service.editObject.assert_called_with({'privateResidenceFlag': True},
                                              id='id')

    def test_show(self):
        command = rwhois.RWhoisShow(client=self.client)

        output = command.execute({})
        expected = {'Abuse Email': 'abuseEmail',
                    'Address 1': 'address1',
                    'Address 2': 'address2',
                    'City': 'city',
                    'Company': 'companyName',
                    'Country': 'country',
                    'Name': 'firstName lastName',
                    'Postal Code': 'postalCode',
                    'State': '-'}
        self.assertEqual(expected, format_output(output, 'python'))

########NEW FILE########
__FILENAME__ = server_tests
"""
    SoftLayer.tests.CLI.modules.server_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This is a series of integration tests designed to test the complete
    command line interface.

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest, FixtureClient
from mock import Mock, patch
try:
    # Python 3.x compatibility
    import builtins  # NOQA
    builtins_name = 'builtins'
except ImportError:
    builtins_name = '__builtin__'

from SoftLayer.CLI.helpers import format_output, CLIAbort, ArgumentError
from SoftLayer.tests.fixtures import Hardware_Server
from SoftLayer.CLI.modules import server


class ServerCLITests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_ServerCancelReasons(self):
        runnable = server.ServerCancelReasons(client=self.client)
        output = runnable.execute({})

        expected = [
            {'Code': 'datacenter',
             'Reason': 'Migrating to a different SoftLayer datacenter'},
            {'Code': 'cost', 'Reason': 'Server / Upgrade Costs'},
            {'Code': 'moving', 'Reason': 'Moving to competitor'},
            {'Code': 'migrate_smaller',
             'Reason': 'Migrating to smaller server'},
            {'Code': 'sales', 'Reason': 'Sales process / upgrades'},
            {'Code': 'performance',
             'Reason': 'Network performance / latency'},
            {'Code': 'unneeded', 'Reason': 'No longer needed'},
            {'Code': 'support', 'Reason': 'Support response / timing'},
            {'Code': 'closing', 'Reason': 'Business closing down'},
            {'Code': 'migrate_larger', 'Reason': 'Migrating to larger server'}
        ]

        method = 'assertItemsEqual'
        if not hasattr(self, method):
            # For Python 3.3 compatibility
            method = 'assertCountEqual'

        f = getattr(self, method)
        f(expected, format_output(output, 'python'))

    @patch('SoftLayer.HardwareManager.get_available_dedicated_server_packages')
    def test_ServerCreateOptions(self, packages):
        args = {
            '<chassis_id>': '999',
            '--all': True,
            '--datacenter': False,
            '--cpu': False,
            '--nic': False,
            '--disk': False,
            '--os': False,
            '--memory': False,
            '--controller': False,
        }

        test_data = [
            (999, 'Chassis 999'),
        ]
        packages.return_value = test_data

        runnable = server.ServerCreateOptions(client=self.client)

        output = runnable.execute(args)

        expected = {
            'cpu': [
                {'Description': 'Dual Quad Core Pancake 200 - 1.60GHz',
                 'ID': 723},
                {'Description': 'Dual Quad Core Pancake 200 - 1.80GHz',
                 'ID': 724}],
            'datacenter': ['RANDOM_LOCATION'],
            'disk': ['250_SATA_II', '500_SATA_II'],
            'disk_controllers': ['None', 'RAID0'],
            'dual nic': ['1000_DUAL', '100_DUAL', '10_DUAL'],
            'memory': [4, 6],
            'os (CENTOS)': ['CENTOS_6_64_LAMP', 'CENTOS_6_64_MINIMAL'],
            'os (REDHAT)': ['REDHAT_6_64_LAMP', 'REDHAT_6_64_MINIMAL'],
            'os (UBUNTU)': ['UBUNTU_12_64_LAMP', 'UBUNTU_12_64_MINIMAL'],
            'os (WIN)': [
                'WIN_2008-DC_64',
                'WIN_2008-ENT_64',
                'WIN_2008-STD-R2_64',
                'WIN_2008-STD_64',
                'WIN_2012-DC-HYPERV_64'],
            'single nic': ['100', '1000']}

        self.assertEqual(expected, format_output(output, 'python'))

    @patch('SoftLayer.HardwareManager.get_available_dedicated_server_packages')
    def test_ServerCreateOptions_with_cpu_only(self, packages):
        args = {
            '<chassis_id>': '999',
            '--all': False,
            '--datacenter': False,
            '--cpu': True,
            '--nic': False,
            '--disk': False,
            '--os': False,
            '--memory': False,
            '--controller': False,
        }

        test_data = [
            (999, 'Chassis 999'),
        ]
        packages.return_value = test_data

        runnable = server.ServerCreateOptions(client=self.client)

        output = runnable.execute(args)

        expected = {
            'cpu': [
                {'Description': 'Dual Quad Core Pancake 200 - 1.60GHz',
                 'ID': 723},
                {'Description': 'Dual Quad Core Pancake 200 - 1.80GHz',
                 'ID': 724}
            ],
        }

        self.assertEqual(expected, format_output(output, 'python'))

    @patch('SoftLayer.HardwareManager.get_available_dedicated_server_packages')
    def test_ServerCreateOptions_with_invalid_chassis(self, packages):
        args = {
            '<chassis_id>': '999',
            '--all': True,
            '--datacenter': False,
            '--cpu': False,
            '--nic': False,
            '--disk': False,
            '--os': False,
            '--memory': False,
            '--controller': False,
        }

        test_data = [
            (998, 'Legacy Chassis'),
        ]
        packages.return_value = test_data

        runnable = server.ServerCreateOptions(client=self.client)

        self.assertRaises(CLIAbort, runnable.execute, args)

    @patch('SoftLayer.HardwareManager.get_available_dedicated_server_packages')
    @patch('SoftLayer.HardwareManager.get_bare_metal_package_id')
    def test_ServerCreateOptions_for_bmc(self, bmpi, packages):
        args = {
            '<chassis_id>': '1099',
            '--all': True,
            '--datacenter': False,
            '--cpu': False,
            '--nic': False,
            '--disk': False,
            '--os': False,
            '--memory': False,
            '--controller': False,
        }

        test_data = [
            (1099, 'Bare Metal Instance'),
        ]
        packages.return_value = test_data

        bmpi.return_value = '1099'

        runnable = server.ServerCreateOptions(client=self.client)

        output = runnable.execute(args)

        expected = {
            'memory/cpu': [
                {'cpu': ['2'], 'memory': '2'},
                {'cpu': ['2', '4'], 'memory': '4'},
            ],
            'datacenter': ['RANDOM_LOCATION'],
            'disk': ['250_SATA_II', '500_SATA_II'],
            'dual nic': ['1000_DUAL', '100_DUAL', '10_DUAL'],
            'os (CENTOS)': ['CENTOS_6_64_LAMP', 'CENTOS_6_64_MINIMAL'],
            'os (REDHAT)': ['REDHAT_6_64_LAMP', 'REDHAT_6_64_MINIMAL'],
            'os (UBUNTU)': ['UBUNTU_12_64_LAMP', 'UBUNTU_12_64_MINIMAL'],
            'os (WIN)': [
                'WIN_2008-DC_64',
                'WIN_2008-ENT_64',
                'WIN_2008-STD-R2_64',
                'WIN_2008-STD_64',
                'WIN_2012-DC-HYPERV_64'],
            'single nic': ['100', '1000']}

        self.assertEqual(expected, format_output(output, 'python'))

    def test_server_details(self):
        runnable = server.ServerDetails(client=self.client)

        args = {'<identifier>': 1234, '--passwords': True, '--price': True}
        output = runnable.execute(args)

        expected = {
            'status': 'ACTIVE',
            'datacenter': 'TEST00',
            'created': '2013-08-01 15:23:45',
            'notes': 'These are test notes.',
            'hostname': 'hardware-test1.test.sftlyr.ws',
            'public_ip': '172.16.1.100',
            'private_ip': '10.1.0.2',
            'ipmi_ip': '10.1.0.3',
            'price rate': 1.54,
            'memory': 2048,
            'cores': 2,
            'ptr': '2.0.1.10.in-addr.arpa',
            'os': 'Ubuntu',
            'id': 1000,
            'tags': ['test_tag'],
            'users': ['root abc123'],
            'vlans': [{'id': 9653, 'number': 1800, 'type': 'PRIVATE'},
                      {'id': 19082, 'number': 3672, 'type': 'PUBLIC'}]
        }

        self.assertEqual(expected, format_output(output, 'python'))

    def test_server_details_issue_332(self):
        runnable = server.ServerDetails(client=self.client)
        result = Hardware_Server.getObject.copy()
        result['primaryIpAddress'] = None
        self.client['Hardware_Server'].getObject.return_value = result

        runnable.execute({'<identifier>': 1234,
                          '--passwords': True,
                          '--price': True})

        self.assertFalse(self.client['Hardware_Server']
                         .getReverseDomainRecords.called)

    def test_ListServers(self):
        runnable = server.ListServers(client=self.client)

        output = runnable.execute({'--tags': 'openstack'})

        expected = [
            {
                'datacenter': 'TEST00',
                'primary_ip': '172.16.1.100',
                'host': 'hardware-test1.test.sftlyr.ws',
                'memory': 2048,
                'cores': 2,
                'id': 1000,
                'backend_ip': '10.1.0.2',
                'active_transaction': 'TXN_NAME'
            },
            {
                'datacenter': 'TEST00',
                'primary_ip': '172.16.4.94',
                'host': 'hardware-test2.test.sftlyr.ws',
                'memory': 4096,
                'cores': 4,
                'id': 1001,
                'backend_ip': '10.1.0.3',
                'active_transaction': None
            },
            {
                'datacenter': 'TEST00',
                'primary_ip': '172.16.4.95',
                'host': 'hardware-bad-memory.test.sftlyr.ws',
                'memory': 0,
                'cores': 4,
                'id': 1002,
                'backend_ip': '10.1.0.4',
                'active_transaction': None
            }
        ]

        self.assertEqual(expected, format_output(output, 'python'))

    @patch('SoftLayer.CLI.modules.server.CLIAbort')
    @patch('SoftLayer.CLI.modules.server.no_going_back')
    @patch('SoftLayer.HardwareManager.reload')
    @patch('SoftLayer.CLI.modules.server.resolve_id')
    def test_ServerReload(
            self, resolve_mock, reload_mock, ngb_mock, abort_mock):
        hw_id = 12345
        resolve_mock.return_value = hw_id
        ngb_mock.return_value = False
        runnable = server.ServerReload(client=self.client)

        # Check the positive case
        args = {'--really': True, '--postinstall': None, '--key': [12345]}
        runnable.execute(args)

        reload_mock.assert_called_with(hw_id, args['--postinstall'], [12345])

        # Now check to make sure we properly call CLIAbort in the negative case
        args['--really'] = False

        runnable.execute(args)
        abort_mock.assert_called()

    @patch('SoftLayer.CLI.modules.server.CLIAbort')
    @patch('SoftLayer.CLI.modules.server.no_going_back')
    @patch('SoftLayer.HardwareManager.cancel_hardware')
    @patch('SoftLayer.CLI.modules.server.resolve_id')
    def test_CancelServer(
            self, resolve_mock, cancel_mock, ngb_mock, abort_mock):
        hw_id = 12345
        resolve_mock.return_value = hw_id
        ngb_mock.return_value = False
        runnable = server.CancelServer(client=self.client)

        # Check the positive case
        args = {'--really': True, '--reason': 'Test'}
        runnable.execute(args)

        cancel_mock.assert_called_with(hw_id, args['--reason'], None)

        # Now check to make sure we properly call CLIAbort in the negative case
        env_mock = Mock()
        env_mock.input = Mock()
        env_mock.input.return_value = 'Comment'

        args['--really'] = False
        runnable = server.CancelServer(client=self.client, env=env_mock)

        runnable.execute(args)
        abort_mock.assert_called()
        env_mock.assert_called()

    @patch('SoftLayer.CLI.modules.server.confirm')
    def test_ServerPowerOff(self, confirm_mock):
        hw_id = 12345
        runnable = server.ServerPowerOff(client=self.client)

        # Check the positive case
        args = {'--really': True, '<identifier>': '12345'}

        runnable.execute(args)

        self.client['Hardware_Server'].powerOff.assert_called_with(id=hw_id)

        # Now check to make sure we properly call CLIAbort in the negative case
        confirm_mock.return_value = False
        args['--really'] = False
        self.assertRaises(CLIAbort, runnable.execute, args)

    @patch('SoftLayer.CLI.modules.server.confirm')
    def test_ServerReboot(self, confirm_mock):
        hw_id = 12345
        runnable = server.ServerReboot(client=self.client)

        # Check the positive case
        args = {
            '--really': True,
            '<identifier>': '12345',
            '--hard': False,
            '--soft': False,
        }

        runnable.execute(args)
        self.client['Hardware_Server'].rebootDefault.assert_called_with(
            id=hw_id)

        args['--soft'] = True
        args['--hard'] = False
        runnable.execute(args)
        self.client['Hardware_Server'].rebootSoft.assert_called_with(id=hw_id)

        args['--soft'] = False
        args['--hard'] = True
        runnable.execute(args)
        self.client['Hardware_Server'].rebootHard.assert_called_with(id=hw_id)

        # Now check to make sure we properly call CLIAbort in the negative case
        confirm_mock.return_value = False
        args['--really'] = False
        self.assertRaises(CLIAbort, runnable.execute, args)

    def test_ServerPowerOn(self):
        hw_id = 12345
        runnable = server.ServerPowerOn(client=self.client)

        # Check the positive case
        args = {
            '<identifier>': '12345',
        }

        runnable.execute(args)
        self.client['Hardware_Server'].powerOn.assert_called_with(id=hw_id)

    @patch('SoftLayer.CLI.modules.server.confirm')
    def test_ServerPowerCycle(self, confirm_mock):
        hw_id = 12345
        runnable = server.ServerPowerCycle(client=self.client)

        # Check the positive case
        args = {
            '<identifier>': '12345',
            '--really': True,
        }

        runnable.execute(args)
        self.client['Hardware_Server'].powerCycle.assert_called_with(id=hw_id)

        # Now check to make sure we properly call CLIAbort in the negative case
        confirm_mock.return_value = False
        args['--really'] = False
        self.assertRaises(CLIAbort, runnable.execute, args)

    @patch('SoftLayer.HardwareManager.change_port_speed')
    @patch('SoftLayer.CLI.modules.server.resolve_id')
    def test_NicEditServer(self, resolve_mock, port_mock):
        hw_id = 12345
        resolve_mock.return_value = hw_id

        # Test updating the port
        args = {
            'port': True,
            'public': False,
            'private': True,
            '--speed': 100
        }

        port_mock.side_effect = [True, False]
        runnable = server.NicEditServer(client=self.client)

        # First call simulates a success
        runnable.execute(args)
        port_mock.assert_called_with(hw_id, False, 100)

        # Second call simulates an error
        runnable.execute(args)

    @patch('SoftLayer.HardwareManager.get_available_dedicated_server_packages')
    def test_ListChassisServer(self, packages):
        test_data = [
            (1, 'Chassis 1'),
            (2, 'Chassis 2')
        ]
        packages.return_value = test_data
        runnable = server.ListChassisServer(client=self.client)

        output = runnable.execute({})

        expected = [
            {'Chassis': 'Chassis 1', 'Code': 1},
            {'Chassis': 'Chassis 2', 'Code': 2}
        ]

        self.assertEqual(expected, format_output(output, 'python'))

    def test_CreateServer(self):
        args = {
            '--chassis': 999,
            '--hostname': 'test',
            '--domain': 'example.com',
            '--datacenter': 'TEST00',
            '--cpu': False,
            '--network': '100',
            '--disk': ['250_SATA_II', '250_SATA_II'],
            '--os': 'UBUNTU_12_64_MINIMAL',
            '--memory': False,
            '--controller': False,
            '--test': True,
            '--export': None,
            '--template': None,
            '--key': [1234, 456],
            '--vlan_public': 10234,
            '--vlan_private': 20468,
            '--postinstall': 'http://somescript.foo/myscript.sh',
        }

        runnable = server.CreateServer(client=self.client)

        # First, test the --test flag
        with patch('SoftLayer.HardwareManager.verify_order') as verify_mock:
            verify_mock.return_value = {
                'prices': [
                    {
                        'recurringFee': 0.0,
                        'setupFee': 0.0,
                        'item': {'description': 'First Item'},
                    },
                    {
                        'recurringFee': 25.0,
                        'setupFee': 0.0,
                        'item': {'description': 'Second Item'},
                    }
                ]
            }
            output = runnable.execute(args)

            expected = [
                [
                    {'Item': 'First Item', 'cost': '0.00'},
                    {'Item': 'Second Item', 'cost': '25.00'},
                    {'Item': 'Total monthly cost', 'cost': '25.00'}
                ],
                ''
            ]

            self.assertEqual(expected, format_output(output, 'python'))

            # Make sure we can order without specifying the disk as well
            args['--disk'] = []

            output = runnable.execute(args)

            self.assertEqual(expected, format_output(output, 'python'))

            # Test explicitly setting a RAID configuration
            args['--controller'] = 'RAID0'

            output = runnable.execute(args)

            self.assertEqual(expected, format_output(output, 'python'))

        # Now test ordering
        with patch('SoftLayer.HardwareManager.place_order') as order_mock:
            order_mock.return_value = {
                'orderId': 98765,
                'orderDate': '2013-08-02 15:23:47'
            }

            args['--test'] = False
            args['--really'] = True

            output = runnable.execute(args)

            expected = {'id': 98765, 'created': '2013-08-02 15:23:47'}
            self.assertEqual(expected, format_output(output, 'python'))

        # Finally, test cancelling the process
        with patch('SoftLayer.CLI.modules.server.confirm') as confirm:
            confirm.return_value = False

            args['--really'] = False

            self.assertRaises(CLIAbort, runnable.execute, args)

    def test_CreateServer_failures(self):

        # This is missing a required argument
        args = {
            '--hostname': 'test',
            '--domain': 'example.com',
            '--datacenter': 'TEST00',
            '--cpu': False,
            '--disk': ['1000_DRIVE', '1000_DRIVE'],
            '--os': 'UBUNTU_12_64_MINIMAL',
            '--memory': False,
            '--controller': False,
            '--test': True,
            '--export': None,
            '--template': None,
        }

        runnable = server.CreateServer(client=self.client)

        # Verify that ArgumentError is properly raised on error
        self.assertRaises(ArgumentError, runnable.execute, args)

        # This contains an invalid network argument
        args['--chassis'] = 999
        args['--network'] = 9999

        # Verify that CLIAbort is properly raised on error
        self.assertRaises(CLIAbort, runnable.execute, args)

        # This contains an invalid operating system argument
        args['--network'] = '100'
        args['--os'] = 'nope'

        # Verify that CLIAbort is properly raised on error
        self.assertRaises(CLIAbort, runnable.execute, args)

    @patch('SoftLayer.CLI.modules.server.export_to_template')
    def test_CreateServer_with_export(self, export_to_template):
        args = {
            '--chassis': 999,
            '--hostname': 'test',
            '--domain': 'example.com',
            '--datacenter': 'TEST00',
            '--cpu': False,
            '--network': '100',
            '--disk': ['1000_DRIVE', '1000_DRIVE'],
            '--os': 'UBUNTU_12_64_MINIMAL',
            '--memory': False,
            '--controller': False,
            '--test': True,
            '--template': None,
            '--key': [1234],
            '--export': 'test_file.txt',
        }

        runnable = server.CreateServer(client=self.client)

        expected = args.copy()
        del(expected['--export'])

        runnable.execute(args)

        export_to_template.assert_called_with('test_file.txt', expected,
                                              exclude=['--wait', '--test'])

    @patch('SoftLayer.HardwareManager.get_available_dedicated_server_packages')
    @patch('SoftLayer.HardwareManager.get_bare_metal_package_id')
    def test_CreateServer_for_bmc(self, bmpi, packages):
        args = {
            '--chassis': '1099',
            '--hostname': 'test',
            '--domain': 'example.com',
            '--datacenter': 'TEST00',
            '--cpu': '2',
            '--network': '100',
            '--disk': ['250_SATA_II', '250_SATA_II'],
            '--os': 'UBUNTU_12_64_MINIMAL',
            '--memory': '2',
            '--test': True,
            '--export': None,
            '--template': None,
            '--key': [1234, 456],
            '--vlan_public': 10234,
            '--vlan_private': 20468,
            '--postinstall': 'http://somescript.foo/myscript.sh',
            '--billing': 'hourly',
        }

        test_data = [
            (1099, 'Bare Metal Instance'),
        ]
        packages.return_value = test_data

        bmpi.return_value = '1099'

        runnable = server.CreateServer(client=self.client)

        # First, test the --test flag
        with patch('SoftLayer.HardwareManager.verify_order') as verify_mock:
            verify_mock.return_value = {
                'prices': [
                    {
                        'recurringFee': 0.0,
                        'setupFee': 0.0,
                        'item': {'description': 'First Item'},
                    },
                    {
                        'recurringFee': 25.0,
                        'setupFee': 0.0,
                        'item': {'description': 'Second Item'},
                    }
                ]
            }
            output = runnable.execute(args)

            expected = [
                [
                    {'Item': 'First Item', 'cost': '0.00'},
                    {'Item': 'Second Item', 'cost': '25.00'},
                    {'Item': 'Total monthly cost', 'cost': '25.00'}
                ],
                ''
            ]

            self.assertEqual(expected, format_output(output, 'python'))

            # Make sure we can order without specifying the disk as well
            args['--disk'] = []

            output = runnable.execute(args)

            self.assertEqual(expected, format_output(output, 'python'))

            # Test explicitly setting a RAID configuration
            args['--controller'] = 'RAID0'

            output = runnable.execute(args)

            self.assertEqual(expected, format_output(output, 'python'))

        # Now test ordering
        with patch('SoftLayer.HardwareManager.place_order') as order_mock:
            order_mock.return_value = {
                'orderId': 98765,
                'orderDate': '2013-08-02 15:23:47'
            }

            args['--test'] = False
            args['--really'] = True

            output = runnable.execute(args)

            expected = {'id': 98765, 'created': '2013-08-02 15:23:47'}
            self.assertEqual(expected, format_output(output, 'python'))

        # Finally, test cancelling the process
        with patch('SoftLayer.CLI.modules.server.confirm') as confirm:
            confirm.return_value = False

            args['--really'] = False

            self.assertRaises(CLIAbort, runnable.execute, args)

    def test_EditServer(self):
        # Test both userdata and userfile at once
        args = {
            '<identifier>': 1000,
            '--hostname': 'hardware-test1',
            '--domain': 'test.sftlyr.ws',
            '--userdata': 'My data',
            '--userfile': 'my_file.txt',
        }
        runnable = server.EditServer(client=self.client)

        self.assertRaises(ArgumentError, runnable.execute, args)

        # Simulate a missing file error
        args['--userdata'] = None

        with patch('os.path.exists') as exists:
            exists.return_value = False

            self.assertRaises(ArgumentError, runnable.execute, args)

        # Test a successful edit with user data
        args['--userdata'] = 'My data'
        args['--userfile'] = None

        expected = {
            'userdata': 'My data',
            'domain': 'test.sftlyr.ws',
            'hostname': 'hardware-test1',
        }

        with patch('SoftLayer.HardwareManager.edit') as edit_mock:
            edit_mock.return_value = True

            runnable.execute(args)

            edit_mock.assert_called_with(1000, **expected)

            # Now check for a CLIAbort if there's an error
            edit_mock.return_value = False

            self.assertRaises(CLIAbort, runnable.execute, args)

        # Test a successful edit with a user file
        args['--userdata'] = None
        args['--userfile'] = 'my_file.txt'

        expected = {
            'userdata': 'My data',
            'domain': 'test.sftlyr.ws',
            'hostname': 'hardware-test1',
        }

        with patch('os.path.exists') as exists:
            exists.return_value = True
            with patch(builtins_name + '.open') as file_mock:
                file_mock.return_value.__enter__ = lambda s: s
                file_mock.return_value.__exit__ = Mock()
                file_mock.return_value.read.return_value = 'some data'

                with patch('SoftLayer.HardwareManager.edit') as edit_mock:
                    edit_mock.return_value = True
                    expected['userdata'] = 'some data'

                    runnable.execute(args)

                    edit_mock.assert_called_with(1000, **expected)

    def test_get_default_value_returns_none_for_unknown_category(self):
        option_mock = {'categories': {'cat1': []}}
        runnable = server.CreateServer()
        output = runnable._get_default_value(option_mock, 'nope')
        self.assertEqual(None, output)

########NEW FILE########
__FILENAME__ = sshkey_tests
"""
    SoftLayer.tests.CLI.modules.sshkey_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
import os.path
from mock import patch
import tempfile

from SoftLayer.tests import unittest, FixtureClient, FIXTURE_PATH
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.modules import sshkey
from SoftLayer.CLI.exceptions import CLIAbort


class SshKeyTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_add_by_option(self):
        service = self.client['Security_Ssh_Key']
        command = sshkey.AddSshKey(client=self.client)
        mock_key = service.getObject()['key']

        output = command.execute({
            '<label>': 'key1',
            '--key': mock_key,
            '--notes': 'my key',
        })

        self.assertEqual(output, 'SSH key added: aa:bb:cc:dd')
        service.createObject.assert_called_with({'notes': 'my key',
                                                 'key': mock_key,
                                                 'label': 'key1'})

    def test_add_by_file(self):
        command = sshkey.AddSshKey(client=self.client)
        path = os.path.join(FIXTURE_PATH, 'id_rsa.pub')

        output = command.execute({
            '<label>': 'key1',
            '--file': path,
        })

        self.assertEqual(output, 'SSH key added: aa:bb:cc:dd')

    def test_remove_key(self):
        command = sshkey.RemoveSshKey(client=self.client)
        command.execute({'<identifier>': '1234',
                         '--really': True})

    @patch('SoftLayer.CLI.modules.sshkey.no_going_back')
    def test_remove_key_fail(self, ngb_mock):
        ngb_mock.return_value = False

        command = sshkey.RemoveSshKey(client=self.client)

        self.assertRaises(CLIAbort, command.execute, {'<identifier>': '1234',
                                                      '--really': False})

    def test_edit_key(self):
        command = sshkey.EditSshKey(client=self.client)
        output = command.execute({
            '<identifier>': '1234',
            '--label': 'key1',
            '--notes': 'my key',
        })

        self.assertEqual(output, None)
        service = self.client['Security_Ssh_Key']
        service.editObject.assert_called_with({'notes': 'my key',
                                               'label': 'key1'}, id=1234)

    def test_edit_key_fail(self):
        service = self.client['Security_Ssh_Key']
        service.editObject.return_value = False
        command = sshkey.EditSshKey(client=self.client)
        self.assertRaises(CLIAbort,
                          command.execute, {'<identifier>': '1234',
                                            '--label': 'key1',
                                            '--notes': 'my key'})

    def test_list_keys(self):
        command = sshkey.ListSshKey(client=self.client)
        output = command.execute({})

        self.assertEqual(format_output(output, 'python'),
                         [{'notes': '-',
                           'fingerprint': None,
                           'id': '100',
                           'label': 'Test 1'},
                          {'notes': 'my key',
                           'fingerprint': None,
                           'id': '101',
                           'label': 'Test 2'}])

    def test_print_key(self):
        command = sshkey.PrintSshKey(client=self.client)
        output = command.execute({'<identifier>': '1234'})

        self.assertEqual(format_output(output, 'python'),
                         {'id': 1234, 'label': 'label', 'notes': 'notes'})

    def test_print_key_file(self):
        sshkey_file = tempfile.NamedTemporaryFile()
        service = self.client['Security_Ssh_Key']
        mock_key = service.getObject()['key']
        command = sshkey.PrintSshKey(client=self.client)

        command.execute({'<identifier>': '1234', '--file': sshkey_file.name})

        self.assertEqual(mock_key, sshkey_file.read().decode("utf-8"))

########NEW FILE########
__FILENAME__ = summary_tests
"""
    SoftLayer.tests.CLI.modules.summary_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.modules import summary
from SoftLayer.CLI.environment import Environment
from SoftLayer.CLI.helpers import format_output


class SummaryTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_summary(self):
        command = summary.Summary(client=self.client, env=Environment())

        output = command.execute({})
        expected = [{'datacenter': 'dal00',
                     'networking': 1,
                     'subnets': 0,
                     'hardware': 1,
                     'IPs': 3,
                     'vs': 1,
                     'vlans': 1}]
        self.assertEqual(expected, format_output(output, 'python'))

########NEW FILE########
__FILENAME__ = vs_tests
"""
    SoftLayer.tests.CLI.modules.vs_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import patch

from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.CLI.helpers import format_output
from SoftLayer.CLI.modules import vs


class DnsTests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()

    def test_list_vs(self):
        command = vs.ListVSIs(client=self.client)

        output = command.execute({'--tags': 'tag'})
        self.assertEqual([{'datacenter': 'TEST00',
                           'primary_ip': '172.16.240.2',
                           'host': 'vs-test1.test.sftlyr.ws',
                           'memory': 1024,
                           'cores': 2,
                           'active_transaction': None,
                           'id': 100,
                           'backend_ip': '10.45.19.37'},
                          {'datacenter': 'TEST00',
                           'primary_ip': '172.16.240.7',
                           'host': 'vs-test2.test.sftlyr.ws',
                           'memory': 4096,
                           'cores': 4,
                           'active_transaction': None,
                           'id': 104,
                           'backend_ip': '10.45.19.35'}],
                         format_output(output, 'python'))

    def test_detail_vs(self):
        command = vs.VSDetails(client=self.client)

        output = command.execute({'<identifier>': '100',
                                  '--passwords': True,
                                  '--price': True})

        self.assertEqual({'active_transaction': None,
                          'cores': 2,
                          'created': '2013-08-01 15:23:45',
                          'datacenter': 'TEST00',
                          'hostname': 'vs-test1.test.sftlyr.ws',
                          'id': 100,
                          'memory': 1024,
                          'modified': {},
                          'os': '12.04-64 Minimal for CCI',
                          'os_version': '12.04-64 Minimal for CCI',
                          'price rate': {},
                          'notes': 'notes',
                          'tags': ['production'],
                          'private_cpu': {},
                          'private_ip': '10.45.19.37',
                          'private_only': {},
                          'ptr': 'test.softlayer.com.',
                          'public_ip': '172.16.240.2',
                          'state': 'RUNNING',
                          'status': 'ACTIVE',
                          'users': [{'password': 'pass', 'username': 'user'}],
                          'vlans': [{'type': 'PUBLIC',
                                     'number': 23,
                                     'id': 1}]},
                         format_output(output, 'python'))

    def test_create_options(self):
        command = vs.CreateOptionsVS(client=self.client)

        output = command.execute({'--all': True,
                                  '--cpu': True,
                                  '--datacenter': True,
                                  '--disk': True,
                                  '--memory': True,
                                  '--nic': True,
                                  '--os': True})

        self.assertEqual({'cpus (private)': [],
                          'cpus (standard)': ['1', '2', '3', '4'],
                          'datacenter': ['ams01', 'dal05'],
                          'local disk(0)': ['25', '100'],
                          'memory': ['1024', '2048', '3072', '4096'],
                          'nic': ['10', '100', '1000'],
                          'os (CENTOS)': 'CENTOS_6_64',
                          'os (DEBIAN)': 'DEBIAN_7_64',
                          'os (UBUNTU)': 'UBUNTU_12_64'},
                         format_output(output, 'python'))

    @patch('SoftLayer.CLI.modules.vs.confirm')
    def test_create(self, confirm_mock):
        confirm_mock.return_value = True
        command = vs.CreateVS(client=self.client)

        output = command.execute({'--cpu': '2',
                                  '--domain': 'example.com',
                                  '--hostname': 'host',
                                  '--image': None,
                                  '--os': 'UBUNTU_LATEST',
                                  '--memory': '1024',
                                  '--nic': '100',
                                  '--hourly': True,
                                  '--monthly': False,
                                  '--like': None,
                                  '--datacenter': None,
                                  '--dedicated': False,
                                  '--san': False,
                                  '--test': False,
                                  '--export': None,
                                  '--userfile': None,
                                  '--postinstall': None,
                                  '--key': [],
                                  '--like': [],
                                  '--network': [],
                                  '--disk': [],
                                  '--private': False,
                                  '--template': None,
                                  '--userdata': None,
                                  '--vlan_public': None,
                                  '--vlan_private': None,
                                  '--wait': None,
                                  '--really': False})

        self.assertEqual([{'guid': '1a2b3c-1701',
                           'id': 100,
                           'created': '2013-08-01 15:23:45'}],
                         format_output(output, 'python'))

########NEW FILE########
__FILENAME__ = config_tests
"""
    SoftLayer.tests.config_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import patch, Mock, ANY

from SoftLayer.config import (
    get_client_settings_args, get_client_settings_env,
    get_client_settings_config_file, get_client_settings)
from SoftLayer.tests import unittest


class TestGetClientSettings(unittest.TestCase):

    @patch('SoftLayer.config.SETTING_RESOLVERS', [])
    def test_no_resolvers(self):
        result = get_client_settings()
        self.assertEqual(result, {})

    def test_resolve_one(self):
        resolvers = [Mock() for i in range(1)]
        resolvers[0].return_value = {'auth': 'AUTH HANDLER'}
        with patch('SoftLayer.config.SETTING_RESOLVERS', resolvers):
            result = get_client_settings()
            self.assertEqual(result, {'auth': 'AUTH HANDLER'})

    def test_inherit(self):
        # This tests the inheritting properties of the list of resolvers.
        # Values should be preferred on earlier resolvers except where their
        # value is false-ish
        resolvers = [Mock() for i in range(4)]
        resolvers[0].return_value = {'timeout': 20}
        resolvers[1].return_value = {'timeout': 10, 'auth': None}
        resolvers[2].return_value = None
        resolvers[3].return_value = {'auth': 'AUTH HANDLER'}
        with patch('SoftLayer.config.SETTING_RESOLVERS', resolvers):
            result = get_client_settings()
            self.assertEqual(result, {'auth': 'AUTH HANDLER', 'timeout': 20})


class TestGetClientSettingsArgs(unittest.TestCase):

    def test_username_api_key(self):
        result = get_client_settings_args(username='username',
                                          api_key='api_key',
                                          endpoint_url='http://endpoint/',
                                          timeout=10,
                                          proxy='https://localhost:3128')

        self.assertEqual(result['endpoint_url'], 'http://endpoint/')
        self.assertEqual(result['timeout'], 10)
        self.assertEqual(result['auth'].username, 'username')
        self.assertEqual(result['auth'].api_key, 'api_key')
        self.assertEqual(result['proxy'], 'https://localhost:3128')

    def test_no_auth(self):
        result = get_client_settings_args()

        self.assertEqual(result, {
            'endpoint_url': None,
            'timeout': None,
            'proxy': None,
            'auth': None,
        })

    def test_with_auth(self):
        auth = Mock()
        result = get_client_settings_args(auth=auth)

        self.assertEqual(result['endpoint_url'], None)
        self.assertEqual(result['timeout'], None)
        self.assertEqual(result['auth'], auth)


class TestGetClientSettingsEnv(unittest.TestCase):

    @patch.dict('os.environ', {'SL_USERNAME': 'username',
                               'SL_API_KEY': 'api_key',
                               'https_proxy': 'https://localhost:3128'})
    def test_username_api_key(self):
        result = get_client_settings_env()

        self.assertEqual(result['auth'].username, 'username')
        self.assertEqual(result['auth'].api_key, 'api_key')

    @patch.dict('os.environ', {'SL_USERNAME': '', 'SL_API_KEY': ''})
    def test_no_auth(self):
        result = get_client_settings_env()

        # proxy might get ANY value depending on test env.
        self.assertEqual(result, {'proxy': ANY})


class TestGetClientSettingsConfigFile(unittest.TestCase):

    @patch('six.moves.configparser.RawConfigParser')
    def test_username_api_key(self, config_parser):
        result = get_client_settings_config_file()

        self.assertEqual(result['endpoint_url'], config_parser().get())
        self.assertEqual(result['timeout'], config_parser().get())
        self.assertEqual(result['proxy'], config_parser().get())
        self.assertEqual(result['auth'].username, config_parser().get())
        self.assertEqual(result['auth'].api_key, config_parser().get())

    @patch('six.moves.configparser.RawConfigParser')
    def test_no_section(self, config_parser):
        config_parser().has_section.return_value = False
        result = get_client_settings_config_file()

        self.assertIsNone(result)

    @patch('six.moves.configparser.RawConfigParser')
    def test_config_file(self, config_parser):
        get_client_settings_config_file(config_file='path/to/config')
        config_parser().read.assert_called_with([ANY, ANY, 'path/to/config'])

########NEW FILE########
__FILENAME__ = Account

getPrivateBlockDeviceTemplateGroups = [{
    'accountId': 1234,
    'blockDevices': [],
    'createDate': '2013-12-05T21:53:03-06:00',
    'globalIdentifier': 'E6DBD73B-1651-4B28-BCBA-A11DF7C9D79E',
    'id': 200,
    'name': 'test_image',
    'parentId': ''
}, {
    'accountId': 1234,
    'blockDevices': [],
    'createDate': '2013-12-05T21:53:03-06:00',
    'globalIdentifier': 'F9329795-4220-4B0A-B970-C86B950667FA',
    'id': 201,
    'name': 'private_image2',
    'parentId': ''
}]

getVirtualGuests = [{
    'id': 100,
    'hostname': 'vs-test1',
    'domain': 'test.sftlyr.ws',
    'fullyQualifiedDomainName': 'vs-test1.test.sftlyr.ws',
    'status': {'keyName': 'ACTIVE', 'name': 'Active'},
    # TODO - This needs to come from wherever data centers come from
    'datacenter': {'id': 50, 'name': 'TEST00',
                   'description': 'Test Data Center'},
    'powerState': {'keyName': 'RUNNING', 'name': 'Running'},
    'maxCpu': 2,
    'maxMemory': 1024,
    'primaryIpAddress': '172.16.240.2',
    'globalIdentifier': '1a2b3c-1701',
    'primaryBackendIpAddress': '10.45.19.37',
    'hourlyBillingFlag': False,
}, {
    'id': 104,
    'hostname': 'vs-test2',
    'domain': 'test.sftlyr.ws',
    'fullyQualifiedDomainName': 'vs-test2.test.sftlyr.ws',
    'status': {'keyName': 'ACTIVE', 'name': 'Active'},
    # TODO - This needs to come from wherever data centers come from
    'datacenter': {'id': 50, 'name': 'TEST00',
                   'description': 'Test Data Center'},
    'powerState': {'keyName': 'RUNNING', 'name': 'Running'},
    'maxCpu': 4,
    'maxMemory': 4096,
    'primaryIpAddress': '172.16.240.7',
    'globalIdentifier': '05a8ac-6abf0',
    'primaryBackendIpAddress': '10.45.19.35',
    'hourlyBillingFlag': True,
}]

getMonthlyVirtualGuests = [vs for vs in getVirtualGuests
                           if not vs['hourlyBillingFlag']]
getHourlyVirtualGuests = [vs for vs in getVirtualGuests
                          if vs['hourlyBillingFlag']]


getHardware = [{
    'id': 1000,
    'datacenter': {'id': 50, 'name': 'TEST00',
                   'description': 'Test Data Center'},
    'billingItem': {'id': 6327, 'recurringFee': 1.54},
    'primaryIpAddress': '172.16.1.100',
    'hostname': 'hardware-test1',
    'domain': 'test.sftlyr.ws',
    'fullyQualifiedDomainName': 'hardware-test1.test.sftlyr.ws',
    'processorPhysicalCoreAmount': 2,
    'memoryCapacity': 2,
    'primaryBackendIpAddress': '10.1.0.2',
    'networkManagementIpAddress': '10.1.0.3',
    'hardwareStatus': {'status': 'ACTIVE'},
    'provisionDate': '2013-08-01 15:23:45',
    'notes': 'These are test notes.',
    'operatingSystem': {
        'softwareLicense': {
            'softwareDescription': {
                'referenceCode': 'Ubuntu',
                'name': 'Ubuntu 12.04 LTS',
            }
        },
        'passwords': [
            {'username': 'root', 'password': 'abc123'}
        ],
    },
    'networkVlans': [
        {
            'networkSpace': 'PRIVATE',
            'vlanNumber': 1800,
            'id': 9653
        },
        {
            'networkSpace': 'PUBLIC',
            'vlanNumber': 3672,
            'id': 19082
        },
    ],
    'tagReferences': [
        {'tag': {'name': 'test_tag'}}
    ],
    'activeTransaction': {
        'transactionStatus': {
            'name': 'TXN_NAME',
            'friendlyName': 'Friendly Transaction Name',
            'id': 6660
        }
    }
}, {
    'id': 1001,
    'datacenter': {'name': 'TEST00',
                   'description': 'Test Data Center'},
    'billingItem': {'id': 7112},
    'primaryIpAddress': '172.16.4.94',
    'hostname': 'hardware-test2',
    'domain': 'test.sftlyr.ws',
    'fullyQualifiedDomainName': 'hardware-test2.test.sftlyr.ws',
    'processorPhysicalCoreAmount': 4,
    'memoryCapacity': 4,
    'primaryBackendIpAddress': '10.1.0.3',
    'hardwareStatus': {'status': 'ACTIVE'},
    'provisionDate': '2013-08-03 07:15:22',
    'operatingSystem': {
        'softwareLicense': {
            'softwareDescription': {
                'referenceCode': 'Ubuntu',
                'name': 'Ubuntu 12.04 LTS',
            }
        }
    },
    'networkVlans': [
        {
            'networkSpace': 'PRIVATE',
            'vlanNumber': 1800,
            'id': 9653
        },
        {
            'networkSpace': 'PUBLIC',
            'vlanNumber': 3672,
            'id': 19082
        },
    ]
}, {
    'id': 1002,
    'datacenter': {'name': 'TEST00',
                   'description': 'Test Data Center'},
    'billingItem': {'id': 7112},
    'primaryIpAddress': '172.16.4.95',
    'hostname': 'hardware-bad-memory',
    'domain': 'test.sftlyr.ws',
    'fullyQualifiedDomainName': 'hardware-bad-memory.test.sftlyr.ws',
    'processorPhysicalCoreAmount': 4,
    'memoryCapacity': None,
    'primaryBackendIpAddress': '10.1.0.4',
    'hardwareStatus': {'status': 'ACTIVE'},
    'provisionDate': '2014-04-02 13:48:00',
    'operatingSystem': {
        'softwareLicense': {
            'softwareDescription': {
                'referenceCode': 'Ubuntu',
                'name': 'Ubuntu 12.04 LTS',
            }
        }
    },
    'networkVlans': [
        {
            'networkSpace': 'PRIVATE',
            'vlanNumber': 1800,
            'id': 9653
        },
        {
            'networkSpace': 'PUBLIC',
            'vlanNumber': 3672,
            'id': 19082
        },
    ]
}]
getDomains = [{'name': 'example.com',
               'id': 12345,
               'serial': 2014030728,
               'updateDate': '2014-03-07T13:52:31-06:00'}]

getObject = {
    'cdnAccounts': [
        {
            "cdnAccountName": "1234a",
            "providerPortalAccessFlag": False,
            "createDate": "2012-06-25T14:05:28-07:00",
            "id": 1234,
            "legacyCdnFlag": False,
            "dependantServiceFlag": True,
            "cdnSolutionName": "ORIGIN_PULL",
            "statusId": 4,
            "accountId": 1234
        },
        {
            "cdnAccountName": "1234a",
            "providerPortalAccessFlag": False,
            "createDate": "2012-07-24T13:34:25-07:00",
            "id": 1234,
            "legacyCdnFlag": False,
            "dependantServiceFlag": False,
            "cdnSolutionName": "POP_PULL",
            "statusId": 4,
            "accountId": 1234
        }
    ]
}

getRwhoisData = {
    'abuseEmail': 'abuseEmail',
    'accountId': 1234,
    'address1': 'address1',
    'address2': 'address2',
    'city': 'city',
    'companyName': 'companyName',
    'country': 'country',
    'createDate': 'createDate',
    'firstName': 'firstName',
    'id': 'id',
    'lastName': 'lastName',
    'modifyDate': 'modifyDate',
    'postalCode': 'postalCode',
    'privateResidenceFlag': 'privateResidenceFlag',
}

getGlobalIpRecords = [{
    'id': '200',
    'ipAddress': {
        'subnet': {
            'networkIdentifier': '10.0.0.1',
        },
        'ipAddress': '127.0.0.1',
    },
    'destinationIpAddress': {
        'ipAddress': '127.0.0.1',
        'virtualGuest': {'fullyQualifiedDomainName': 'example.com'}}
}, {
    'id': '201',
    'ipAddress': {
        'subnet': {
            'networkIdentifier': '10.0.0.1',
        },
        'ipAddress': '127.0.0.1',
    },
    'destinationIpAddress': {
        'ipAddress': '127.0.0.1',
        'hardware': {'fullyQualifiedDomainName': 'example.com'}}
}]

getSubnets = [
    {
        'id': '100',
        'networkIdentifier': '10.0.0.1',
        'datacenter': {'name': 'dal00'},
        'version': 4,
        'subnetType': 'PRIMARY'
    }]

getSshKeys = [{'id': '100', 'label': 'Test 1'},
              {'id': '101', 'label': 'Test 2',
               'notes': 'Test notes',
               'finterprint': 'aa:bb:cc:dd',
               'notes': 'my key'}]

getSecurityCertificates = [{'certificate': '1234',
                            'commonName': 'cert',
                            'id': 1234}]
getExpiredSecurityCertificates = getSecurityCertificates
getValidSecurityCertificates = getSecurityCertificates

getTickets = [
    {
        "accountId": 1234,
        "assignedUserId": 12345,
        "createDate": "2013-08-01T14:14:04-07:00",
        "id": 100,
        "lastEditDate": "2013-08-01T14:16:47-07:00",
        "lastEditType": "AUTO",
        "modifyDate": "2013-08-01T14:16:47-07:00",
        "status": {
            "id": 1002,
            "name": "Closed"
        },
        "statusId": 1002,
        "title": "Cloud Instance Cancellation - 08/01/13"
    },
    {
        "accountId": 1234,
        "assignedUserId": 12345,
        "createDate": "2013-08-01T14:14:04-07:00",
        "id": 101,
        "lastEditDate": "2013-08-01T14:16:47-07:00",
        "lastEditType": "AUTO",
        "modifyDate": "2013-08-01T14:16:47-07:00",
        "status": {
            "id": 1002,
            "name": "Closed"
        },
        "statusId": 1002,
        "title": "Cloud Instance Cancellation - 08/01/13"
    },
    {
        "accountId": 1234,
        "assignedUserId": 12345,
        "createDate": "2014-03-03T09:44:01-08:00",
        "id": 102,
        "lastEditDate": "2013-08-01T14:16:47-07:00",
        "lastEditType": "AUTO",
        "modifyDate": "2014-03-03T09:44:03-08:00",
        "status": {
            "id": 1001,
            "name": "Open"
        },
        "statusId": 1001,
        "title": "Cloud Instance Cancellation - 08/01/13"
    }]

getOpenTickets = [ticket for ticket in getTickets
                  if ticket['statusId'] == 1001]
getClosedTickets = [ticket for ticket in getTickets
                    if ticket['statusId'] == 1002]

getCurrentUser = {'id': 12345,
                  'apiAuthenticationKeys': [{'authenticationKey': 'A' * 64}]}

getCdnAccounts = [
    {
        "cdnAccountName": "1234a",
        "providerPortalAccessFlag": False,
        "createDate": "2012-06-25T14:05:28-07:00",
        "id": 1234,
        "legacyCdnFlag": False,
        "dependantServiceFlag": True,
        "cdnSolutionName": "ORIGIN_PULL",
        "statusId": 4,
        "accountId": 1234
    },
    {
        "cdnAccountName": "1234a",
        "providerPortalAccessFlag": False,
        "createDate": "2012-07-24T13:34:25-07:00",
        "id": 1234,
        "legacyCdnFlag": False,
        "dependantServiceFlag": False,
        "cdnSolutionName": "POP_PULL",
        "statusId": 4,
        "accountId": 1234
    }
]

getNetworkVlans = [{
    'name': 'dal00',
    'hardware': [{'id': 1}],
    'networkComponents': [{'id': 2}],
    'primaryRouter': {
        'datacenter': {'name': 'dal00'}
    },
    'totalPrimaryIpAddressCount': 3,
    'subnets': [],
    'virtualGuests': [{'id': 3}]
}]

getAdcLoadBalancers = []

getNasNetworkStorage = [{
    'id': 1,
    'capacityGb': 10,
    'serviceResource': {'datacenter': {'name': 'Dallas'}},
    'username': 'user',
    'password': 'pass',
    'serviceResourceBackendIpAddress': '127.0.0.1',
}]

########NEW FILE########
__FILENAME__ = Billing_Item
cancelService = {}
cancelServiceOnAnniversaryDate = {}
cancelItem = {}

########NEW FILE########
__FILENAME__ = Dns_Domain
createObject = {'name': 'example.com'}
deleteObject = True
editObject = True
getZoneFileContents = 'lots of text'
getResourceRecords = [
    {'id': 1, 'ttl': 7200, 'data': 'd', 'host': 'a', 'type': 'cname'},
    {'id': 2, 'ttl': 900, 'data': '1', 'host': 'b', 'type': 'a'},
    {'id': 3, 'ttl': 900, 'data': 'x', 'host': 'c', 'type': 'ptr'},
    {'id': 4, 'ttl': 86400, 'data': 'b', 'host': 'd', 'type': 'txt'},
    {'id': 5, 'ttl': 86400, 'data': 'b', 'host': 'e', 'type': 'txt'},
    {'id': 6, 'ttl': 600, 'data': 'b', 'host': 'f', 'type': 'txt'},
]
getObject = {'id': 98765, 'name': 'test-example.com'}

########NEW FILE########
__FILENAME__ = Dns_Domain_ResourceRecord
createObject = {'name': 'example.com'}
deleteObject = True
editObject = True

########NEW FILE########
__FILENAME__ = Hardware_Server
getObject = {
    'id': 1000,
    'datacenter': {'id': 50, 'name': 'TEST00',
                   'description': 'Test Data Center'},
    'billingItem': {'id': 6327, 'recurringFee': 1.54},
    'primaryIpAddress': '172.16.1.100',
    'hostname': 'hardware-test1',
    'domain': 'test.sftlyr.ws',
    'bareMetalInstanceFlag': True,
    'fullyQualifiedDomainName': 'hardware-test1.test.sftlyr.ws',
    'processorPhysicalCoreAmount': 2,
    'memoryCapacity': 2,
    'primaryBackendIpAddress': '10.1.0.2',
    'networkManagementIpAddress': '10.1.0.3',
    'hardwareStatus': {'status': 'ACTIVE'},
    "primaryNetworkComponent": {"speed": 10},
    'provisionDate': '2013-08-01 15:23:45',
    'notes': 'These are test notes.',
    'operatingSystem': {
        'softwareLicense': {
            'softwareDescription': {
                'referenceCode': 'Ubuntu',
                'name': 'Ubuntu 12.04 LTS',
            }
        },
        'passwords': [
            {'username': 'root', 'password': 'abc123'}
        ],
    },
    'networkVlans': [
        {
            'networkSpace': 'PRIVATE',
            'vlanNumber': 1800,
            'id': 9653
        },
        {
            'networkSpace': 'PUBLIC',
            'vlanNumber': 3672,
            'id': 19082
        },
    ],
    'tagReferences': [
        {'tag': {'name': 'test_tag'}}
    ],
    'activeTransaction': {
        'transactionStatus': {
            'name': 'TXN_NAME',
            'friendlyName': 'Friendly Transaction Name',
            'id': 6660
        }
    }
}
editObject = True
setPrivateNetworkInterfaceSpeed = True
setPublicNetworkInterfaceSpeed = True
powerOff = True
powerOn = True
powerCycle = True
rebootSoft = True
rebootDefault = True
rebootHard = True
setUserMetadata = ['meta']
reloadOperatingSystem = 'OK'
getReverseDomainRecords = [
    {'resourceRecords': [{'data': '2.0.1.10.in-addr.arpa'}]}]

########NEW FILE########
__FILENAME__ = Location
getDataCenters = [
    {
        "id": 358694,
        "longName": "London 2",
        "name": "lon02"
    },
    {
        "id": 168642,
        "longName": "San Jose 1",
        "name": "sjc01"
    }]

########NEW FILE########
__FILENAME__ = Location_Datacenter
getDatacenters = [{
    'id': 0,
    'name': 'dal05'
}]

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_Health_Check_Type
getAllObjects = {}

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_Routing_Method
getAllObjects = {}

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_Routing_Type
getAllObjects = {}

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_Service
deleteObject = {}
toggleStatus = {}

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_Service_Group
kickAllConnections = {}

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_VirtualIpAddress
getBillingItem = {'id': 21370814}
getObject = {
    'accountId': 307608,
    'connectionLimit': 500,
    'connectionLimitUnits': "connections/second",
    'dedicatedFlag': False,
    'highAvailabilityFlag': False,
    'id': 22348,
    'ipAddressId': 7303278,
    'managedResourceFlag': False,
    'sslActiveFlag': False,
    'sslEnabledFlag': True,
    'virtualServers': [
        {
            'allocation': 10,
            'id': 50718,
            'port': 80,
            "serviceGroups": [
                {
                    'id': 51758,
                    'routingMethodId': 10,
                    'routingTypeId': 3,
                    'services': [
                        {
                            'enabled': 1,
                            'id': 1234,
                            'healthChecks': [
                                {
                                    'id': 112112
                                }
                            ],
                            'groupReferences': [
                                {
                                    'serviceGroupId': 51758,
                                    'serviceId': 84986,
                                    'weight': 2
                                }
                            ],
                            'ipAddressId': 14288108,
                            'port': 8080,
                            'status': "DOWN"
                        }
                    ]
                }
            ],
            "virtualIpAddress": {
                'accountId': 307608,
                'connectionLimit': 500,
                'connectionLimitUnits': "connections/second",
                'id': 22348,
                'ipAddressId': 7303278,
            },
            'virtualIpAddressId': 22348
        }]}
getVirtualServers = [
    {
        "allocation": 10,
        "id": 50718,
        "port": 80,
        "serviceGroups": [
            {
                "id": 51758,
                "routingMethodId": 10,
                "routingTypeId": 3,
                "services": [
                    {
                        "enabled": 1,
                        "id": 1234,
                        "healthChecks": [
                            {
                                "id": 112112
                            }
                        ],
                        "groupReferences": [
                            {
                                "serviceGroupId": 51758,
                                "serviceId": 84986,
                                "weight": 2
                            }
                        ],
                        "ipAddressId": 14288108,
                        "port": 8080,
                        "status": "DOWN"
                    }
                ]
            }
        ],
        "virtualIpAddress": {
            "accountId": 307608,
            "connectionLimit": 500,
            "connectionLimitUnits": "connections/second",
            "id": 22348,
            "ipAddressId": 7303278,
        },
        "virtualIpAddressId": 22348
    }
]
editObject = {}

########NEW FILE########
__FILENAME__ = Network_Application_Delivery_Controller_LoadBalancer_VirtualServer
deleteObject = {}

########NEW FILE########
__FILENAME__ = Network_Component_Firewall
createCancelServerTicket = {'id': 1234, 'title': 'Server Cancellation Request'}
getObject = {
    "guestNetworkComponentId": 1705294,
    "id": 1234,
    "status": "allow_edit",
    "billingItem": {
        "allowCancellationFlag": 1,
        "associatedBillingItemId": "20952512",
        "categoryCode": "firewall",
        "createDate": "2014-03-21T14:07:04-05:00",
        "cycleStartDate": "2014-03-21T14:07:04-05:00",
        "description": "10Mbps Hardware Firewall",
        "id": 21370814,
        "laborFee": "0",
        "laborFeeTaxRate": ".066",
        "lastBillDate": "2014-03-21T14:07:04-05:00",
        "modifyDate": "2014-03-21T14:07:07-05:00",
        "nextBillDate": "2014-04-04T00:00:00-05:00",
        "oneTimeFee": "0",
        "oneTimeFeeTaxRate": ".066",
        "orderItemId": 28712824,
        "parentId": 20952512,
        "recurringFee": "0",
        "recurringFeeTaxRate": ".066",
        "recurringMonths": 1,
        "serviceProviderId": 1,
        "setupFee": "0",
        "setupFeeTaxRate": ".066"
    },
    "guestNetworkComponent": {
        "createDate": "2014-03-17T13:49:00-05:00",
        "guestId": 3895386,
        "id": 1705294,
        "macAddress": "06:a4:8d:d2:88:34",
        "maxSpeed": 10,
        "modifyDate": "2014-03-17T13:49:20-05:00",
        "name": "eth",
        "networkId": 1310218,
        "port": 1,
        "speed": 10,
        "status": "ACTIVE",
        "uuid": "3f1b5e08-a652-fb3b-1baa-8ace70c90fe9",
        "guest": {
            "accountId": 307608,
            "dedicatedAccountHostOnlyFlag": False,
            "domain": "test.com",
            "fullyQualifiedDomainName": "test.test.com",
            "hostname": "firewalltest",
            "id": 3895386,
            "maxCpu": 1,
            "maxCpuUnits": "CORE",
            "maxMemory": 1024,
            "modifyDate": "2014-03-21T14:05:51-05:00",
            "startCpus": 1,
            "statusId": 1001,
            "uuid": "29b40ef0-a43a-8cb6-31be-1878cb6853f0",
            "status": {
                "keyName": "ACTIVE",
                "name": "Active"
            }
        }
    }
}

getRules = [
    {
        'destinationIpAddress': 'any on server',
        'protocol': 'tcp',
        'orderValue': 1,
        'destinationIpSubnetMask': '255.255.255.255',
        'destinationPortRangeStart': 80,
        'sourceIpSubnetMask': '0.0.0.0',
        'destinationPortRangeEnd': 80,
        'version': 4,
        'action': 'permit',
        'sourceIpAddress': '0.0.0.0'
    },
    {
        'destinationIpAddress': 'any on server',
        'protocol': 'tcp',
        'orderValue': 2,
        'destinationIpSubnetMask': '255.255.255.255',
        'destinationPortRangeStart': 1,
        'sourceIpSubnetMask': '255.255.255.255',
        'destinationPortRangeEnd': 65535,
        'version': 4,
        'action': 'permit',
        'sourceIpAddress': '193.212.1.10'
    },
    {
        'destinationIpAddress': 'any on server',
        'protocol': 'tcp',
        'orderValue': 3,
        'destinationIpSubnetMask': '255.255.255.255',
        'destinationPortRangeStart': 80,
        'sourceIpSubnetMask': '0.0.0.0',
        'destinationPortRangeEnd': 800,
        'version': 4,
        'action': 'permit',
        'sourceIpAddress': '0.0.0.0'
    }
]

getBillingItem = {"id": 21370814}

########NEW FILE########
__FILENAME__ = Network_ContentDelivery_Account
getObject = {
    "cdnAccountName": "1234a",
    "providerPortalAccessFlag": False,
    "createDate": "2012-06-25T14:05:28-07:00",
    "id": 1234,
    "legacyCdnFlag": False,
    "dependantServiceFlag": True,
    "cdnSolutionName": "ORIGIN_PULL",
    "statusId": 4,
    "accountId": 1234,
    "status": {'name': 'ACTIVE'},
}

getOriginPullMappingInformation = [
    {
        "originUrl": "http://ams01.objectstorage.softlayer.net:80",
        "mediaType": "FLASH",
        "id": "12345",
        "isSecureContent": False
    },
    {
        "originUrl": "http://sng01.objectstorage.softlayer.net:80",
        "mediaType": "FLASH",
        "id": "12345",
        "isSecureContent": False
    }
]

createOriginPullMapping = True

deleteOriginPullRule = True

loadContent = True

purgeContent = True

########NEW FILE########
__FILENAME__ = Network_Firewall_Update_Request
getObject = {
    "guestNetworkComponentId": 1705294,
    "id": 1234
    }

createObject = {}

edit = True

########NEW FILE########
__FILENAME__ = Network_Storage_Iscsi
getObject = {
    'accountId': 1111,
    'billingItem': {'id': 600},
    'capacityGb': 20,
    'createDate': '2014:50:15-04:00',
    'guestId': '',
    'hardwareId': '',
    'hostId': '',
    'id': 100,
    'nasType': 'ISCSI',
    'notes': """{'status': 'available'}""",
    'password': 'abcdef',
    'serviceProviderId': 1,
    'serviceResource': {'datacenter': {'id': 138124}},
    'serviceResourceBackendIpAddress': '10.0.1.1',
    'serviceResourceName': 'storagesng0101',
    'username': 'username'
}

createSnapshot = {
    'accountId': 1111,
    'capacityGb': 20,
    'createDate': '2014:51:11-04:00',
    'guestId': '',
    'hardwareId': '',
    'hostId': '',
    'id': 101,
    'nasType': 'ISCSI_SNAPSHOT',
    'parentVolume': {
        'accountId': 1111,
        'capacityGb': 20,
        'createDate': '2014:38:47-04:00',
        'guestId': '',
        'hardwareId': '',
        'hostId': '',
        'id': 100,
        'nasType': 'ISCSI',
        'password': 'abcdef',
        'properties': [
            {'createDate': '2014:40:22-04:00',
             'modifyDate': '',
             'type': {
                 'description':
                 'Percent of reserved snapshot space that is available',
                 'keyname': 'SNAPSHOT_RESERVE_AVAILABLE',
                 'name': 'Snaphot Reserve Available'},

             'value': '100',
             'volumeId': 2233}],

        'propertyCount': 0,
        'serviceProviderId': 1,
        'name': 'storagedal05',
        'snapshotCapacityGb': '40',
        'username': 'username'},
    'password': 'abcdef',
                'serviceProviderId': 1,
                'serviceResource': {'backendIpAddress': '10.1.0.1',
                                    'name': 'storagedal05',
                                    'type': {'type': 'ISCSI'}},
                'serviceResourceBackendIpAddress': '10.1.0.1',
                'serviceResourceName': 'storagedal05',
                'username': 'username'}

restoreFromSnapshot = True
editObject = True
createObject = getObject
deleteObject = True

########NEW FILE########
__FILENAME__ = Network_Subnet
getObject = {'id': id, 'billingItem': {'id': 1056}}

########NEW FILE########
__FILENAME__ = Network_Subnet_IpAddress
getByIpAddress = {}

########NEW FILE########
__FILENAME__ = Network_Subnet_IpAddress_Global
route = True
unroute = True
getObject = {'id': 1234, 'billingItem': {'id': 1234}}

########NEW FILE########
__FILENAME__ = Network_Subnet_Rwhois_Data
editObject = True

########NEW FILE########
__FILENAME__ = Network_Vlan
getObject = {'primaryRouter': {'datacenter': {'id': 1234}}}

########NEW FILE########
__FILENAME__ = Network_Vlan_Firewall
createCancelServerTicket = {'id': 1234, 'title': 'Server Cancellation Request'}
getObject = {
    "administrativeBypassFlag": "",
    "customerManagedFlag": False,
    "billingItem": {
        "id": 21370815
    },
    "id": 3130,
    "primaryIpAddress": "192.155.239.146",
    "networkVlan": {
        "accountId": 307608,
        "id": 371028,
        "primarySubnetId": 536252,
        "vlanNumber": 1489,
        "firewallInterfaces": [
            {
                "id": 6254,
                "name": "inside",
                "firewallContextAccessControlLists": [
                    {
                        "direction": "out",
                        "firewallContextInterfaceId": 6257,
                        "id": 3143
                    }
                ]
            },
            {
                "id": 6256,
                "name": "outside",
                "firewallContextAccessControlLists": [
                    {
                        "direction": "out",
                        "firewallContextInterfaceId": 6257,
                        "id": 3143
                    },
                    {
                        "direction": "in",
                        "firewallContextInterfaceId": 6256,
                        "id": 3142
                    }
                ]
                }
            ]
    }
}

getRules = [
    {
        'destinationIpAddress': 'any on server',
        'protocol': 'tcp',
        'orderValue': 1,
        'destinationIpSubnetMask': '255.255.255.255',
        'destinationPortRangeStart': 80,
        'sourceIpSubnetMask': '0.0.0.0',
        'destinationPortRangeEnd': 80,
        'version': 4,
        'action': 'permit',
        'sourceIpAddress': '0.0.0.0'
    },
    {
        'destinationIpAddress': 'any on server',
        'protocol': 'tcp',
        'orderValue': 2,
        'destinationIpSubnetMask': '255.255.255.255',
        'destinationPortRangeStart': 1,
        'sourceIpSubnetMask': '255.255.255.255',
        'destinationPortRangeEnd': 65535,
        'version': 4,
        'action': 'permit',
        'sourceIpAddress': '193.212.1.10'
    },
    {
        'destinationIpAddress': 'any on server',
        'protocol': 'tcp',
        'orderValue': 3,
        'destinationIpSubnetMask': '255.255.255.255',
        'destinationPortRangeStart': 80,
        'sourceIpSubnetMask': '0.0.0.0',
        'destinationPortRangeEnd': 800,
        'version': 4,
        'action': 'permit',
        'sourceIpAddress': '0.0.0.0'
    }
]

########NEW FILE########
__FILENAME__ = Product_Order
verifyOrder = {
    'orderId': 1234,
    'orderDate': '2013-08-01 15:23:45',
    'prices': [{
        'id': 1,
        'laborFee': '2',
        'oneTimeFee': '2',
        'oneTimeFeeTax': '.1',
        'quantity': 1,
        'recurringFee': '2',
        'recurringFeeTax': '.1',
        'hourlyRecurringFee': '2',
        'setupFee': '1',
        'item': {'id': 1, 'description': 'this is a thing'},
    }]}
placeOrder = verifyOrder

########NEW FILE########
__FILENAME__ = Product_Package
getAllObjects = [
    {'id': 13, 'name': 'Mock Testing Package', 'description': 'a thing'},
    {'id': 27, 'name': 'An additional testing category',
     'description': 'Another thing - OUTLET'},
    {'id': 50, 'name': 'Bare Metal Instance',
     'description': 'Bare Metal Instance'},
]
getObject = getAllObjects[0]

getConfiguration = [
    {
        'sort': 1,
        'orderStepId': 1,
        'itemCategory': {
            'categoryCode': 'server_core',
            'name': 'Bare Metal Instance'
        },
        'isRequired': 0,
    },
    {
        'itemCategory': {
            'categoryCode': 'os',
            'name': 'Operating System',
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'disk0',
            'name': 'First Hard Drive',
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'port_speed',
            'name': 'Uplink Port Speeds'
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 1,
    },
] + [
    {
        'itemCategory': {
            'categoryCode': 'random',
            'name': 'Random Category',
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 0,
    },
    {
        'itemCategory': {
            'categoryCode': 'disk0',
            'name': 'First Disk',
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'disk1',
            'name': 'Second Disk',
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'os',
            'name': 'Operating System',
        },
        'sort': 0,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'port_speed',
            'name': 'Uplink Port Speeds',
        },
        'sort': 2,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'ram',
            'name': 'RAM',
        },
        'sort': 2,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'disk_controller',
            'name': 'Disk Controller',
        },
        'sort': 2,
        'orderStepId': 1,
        'isRequired': 1,
    },
    {
        'itemCategory': {
            'categoryCode': 'server',
            'name': 'Server',
        },
        'sort': 2,
        'orderStepId': 1,
        'isRequired': 1,
    },
]
getRegions = [{
    'location': {
        'locationPackageDetails': [{
            'deliveryTimeInformation': 'Typically 2-4 hours',
        }],
    },
    'keyname': 'RANDOM_LOCATION',
    'description': 'Random unit testing location',
}]

CATEGORY = {
    'categoryCode': 'random',
    'name': 'Random Category',
}


def get_server_categories_mock():
    prices = [{
        'itemId': 888,
        'id': 1888,
        'sort': 0,
        'setupFee': 0,
        'recurringFee': 0,
        'hourlyRecurringFee': 0,
        'oneTimeFee': 0,
        'laborFee': 0,
        'item': {
            'id': 888,
            'description': 'Some item',
            'capacity': 0,
        }
    }]

    disk0_prices = [{
        'itemId': 2000,
        'id': 12000,
        'sort': 0,
        'setupFee': 0,
        'recurringFee': 0,
        'hourlyRecurringFee': 0,
        'oneTimeFee': 0,
        'laborFee': 0,
        'item': {
            'id': 2000,
            'description': '1TB Drive',
            'capacity': 1000,
        }
    }]

    disk1_prices = [{
        'itemId': 2000,
        'id': 12000,
        'sort': 0,
        'setupFee': 0,
        'recurringFee': 0,
        'hourlyRecurringFee': 0,
        'oneTimeFee': 0,
        'laborFee': 0,
        'item': {
            'id': 2000,
            'description': '1TB Drive',
            'capacity': 1000,
        }
    }]

    centos_prices = [
        {
            'itemId': 3907,
            'setupFee': '0',
            'recurringFee': '0',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 0,
            'item': {
                'description': 'CentOS 6.0 (64 bit)',
                'id': 3907
            },
            'id': 13942,
        },
    ]

    debian_prices = [
        {
            'itemId': 3967,
            'setupFee': '0',
            'recurringFee': '0',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 6,
            'item': {
                'description': 'Debian GNU/Linux 6.0 Squeeze/Stable (32 bit)',
                'id': 3967
            },
            'id': 14046,
        },
    ]

    ubuntu_prices = [
        {
            'itemId': 4170,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 17438,
            'sort': 9,
            'item': {
                'description': 'Ubuntu Linux 12.04 LTS Precise Pangolin - '
                'Minimal Install (64 bit)',
                'id': 4170
            },
            'laborFee': '0',
        },
        {
            'itemId': 4166,
            'setupFee': '0',
            'recurringFee': '0',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 9,
            'item': {
                'description': 'Ubuntu Linux 12.04 LTS Precise Pangolin '
                '(64 bit)',
                'id': 4166
            },
            'id': 17430,
        },
    ]

    windows_prices = [
        {
            'itemId': 977,
            'setupFee': '0',
            'recurringFee': '40',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 15,
            'item': {
                'description': 'Windows Server 2008 R2 Standard Edition '
                '(64bit)',
                'id': 977
            },
            'id': 1858,
        },
        {
            'itemId': 978,
            'setupFee': '0',
            'recurringFee': '100',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 15,
            'item': {
                'description': 'Windows Server 2008 R2 Enterprise Edition '
                '(64bit)',
                'id': 978
            },
            'id': 1861,
        },
        {
            'itemId': 980,
            'setupFee': '0',
            'recurringFee': '150',
            'hourlyRecurringFee': '.21',
            'oneTimeFee': '0',
            'id': 1867,
            'sort': 15,
            'item': {
                'description': 'Windows Server 2008 R2 Datacenter Edition '
                'With Hyper-V (64bit)',
                'id': 980
            },
            'laborFee': '0',
        },
        {
            'itemId': 422,
            'setupFee': '0',
            'recurringFee': '40',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 18,
            'item': {
                'description': 'Windows Server 2003 Standard SP2 with R2 '
                '(64 bit)',
                'id': 422
            },
            'id': 692,
        },
    ]

    redhat_prices = [
        {
            'itemId': 3841,
            'setupFee': '0',
            'recurringFee': '0',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 10,
            'item': {
                'description': 'Red Hat Enterprise Linux - 6 (64 bit)',
                'id': 3841
            },
            'id': 13800,
        }
    ]

    ram_prices = [
        {
            'itemId': 254,
            'setupFee': '0',
            'recurringFee': '0',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 0,
            'item': {
                'capacity': '4',
                'description': '4 GB DIMM Registered 533/667',
                'id': 254
            },
            'id': 1023,
        },
        {
            'itemId': 255,
            'setupFee': '0',
            'recurringFee': '30',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 0,
            'item': {
                'capacity': '6',
                'description': '6 GB DIMM Registered 533/667',
                'id': 255
            },
            'id': 702,
        }]

    server_prices = [
        {
            'itemId': 300,
            'setupFee': '0',
            'recurringFee': '125',
            'laborFee': '0',
            'oneTimeFee': '0',
            'currentPriceFlag': '',
            'sort': 2,
            'item': {
                'description': 'Dual Quad Core Pancake 200 - 1.60GHz',
                'id': 300
            },
            'id': 723
        },
        {
            'itemId': 303,
            'setupFee': '0',
            'recurringFee': '279',
            'laborFee': '0',
            'oneTimeFee': '0',
            'currentPriceFlag': '',
            'sort': 2,
            'item': {
                'description': 'Dual Quad Core Pancake 200 - 1.80GHz',
                'id': 303
            },
            'id': 724,
        }
    ]

    single_nic_prices = [
        {
            'itemId': 187,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 273,
            'sort': 0,
            'item': {
                'capacity': '100',
                'description': '100 Mbps Public & Private Networks',
                'id': 187
            },
            'laborFee': '0',
        },
        {
            'itemId': 188,
            'setupFee': '0',
            'recurringFee': '20',
            'hourlyRecurringFee': '.04',
            'oneTimeFee': '0',
            'id': 274,
            'sort': 0,
            'item': {
                'capacity': '1000',
                'description': '1 Gbps Public & Private Networks',
                'id': 188
            },
            'laborFee': '0',
        }
    ]

    dual_nic_prices = [
        {
            'itemId': 4332,
            'setupFee': '0',
            'recurringFee': '10',
            'hourlyRecurringFee': '.02',
            'oneTimeFee': '0',
            'id': 21509,
            'sort': 5,
            'item': {
                'capacity': '10',
                'description': '10 Mbps Dual Public & Private Networks '
                '(up to 20 Mbps)',
                'id': 4332
            },
            'laborFee': '0',
        },
        {
            'itemId': 4336,
            'setupFee': '0',
            'recurringFee': '20',
            'hourlyRecurringFee': '.03',
            'oneTimeFee': '0',
            'id': 21513,
            'sort': 5,
            'item': {
                'capacity': '100',
                'description': '100 Mbps Dual Public & Private Networks '
                '(up to 200 Mbps)',
                'id': 4336
            },
            'laborFee': '0',
        }
    ]

    controller_prices = [
        {
            'itemId': 487,
            'setupFee': '0',
            'recurringFee': '0',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 0,
            'item': {
                'description': 'Non-RAID',
                'id': 487
            },
            'id': 876,
        },
        {
            'itemId': 488,
            'setupFee': '0',
            'recurringFee': '50',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 0,
            'item': {
                'description': 'RAID 0',
                'id': 488
            },
            'id': 877,
        }
    ]

    return [
        {
            'categoryCode': CATEGORY['categoryCode'],
            'name': CATEGORY['name'],
            'id': 1000,
            'groups': [{
                'sort': 0,
                'prices': prices,
                'itemCategoryId': 1000,
                'packageId': 13,
            }],
        },
        {
            'categoryCode': 'ram',
            'id': 3,
            'name': 'Ram',
            'groups': [{
                'sort': 0,
                'prices': ram_prices,
                'itemCategoryId': 3,
                'packageId': 13
            }],
        },
        {
            'categoryCode': 'server',
            'id': 1,
            'name': 'Server',
            'groups': [{
                'sort': 2,
                'prices': server_prices,
                'itemCategoryId': 1,
                'packageId': 13
            }],
        },
        {
            'categoryCode': 'disk0',
            'name': 'First Disk',
            'isRequired': 1,
            'id': 1001,
            'groups': [{
                'sort': 0,
                'prices': disk0_prices,
                'itemCategoryId': 1001,
                'packageId': 13,
            }],
        },
        {
            'categoryCode': 'disk1',
            'name': 'Second Disk',
            'isRequired': 1,
            'id': 1002,
            'groups': [{
                'sort': 0,
                'prices': disk1_prices,
                'itemCategoryId': 1002,
                'packageId': 13,
            }],
        },
        {
            'categoryCode': 'os',
            'id': 12,
            'name': 'Operating System',
            'groups': [
                {
                    'sort': 0,
                    'prices': centos_prices,
                    'itemCategoryId': 12,
                    'packageId': 13,
                    'title': 'CentOS',
                },
                {
                    'sort': 0,
                    'prices': debian_prices,
                    'itemCategoryId': 12,
                    'packageId': 13,
                    'title': 'Debian',
                },
                {
                    'sort': 0,
                    'prices': ubuntu_prices,
                    'itemCategoryId': 12,
                    'packageId': 13,
                    'title': 'Ubuntu',
                },
                {
                    'sort': 0,
                    'prices': windows_prices,
                    'itemCategoryId': 12,
                    'packageId': 13,
                    'title': 'Microsoft',
                },
                {
                    'sort': 10,
                    'prices': redhat_prices,
                    'itemCategoryId': 12,
                    'packageId': 13,
                    'title': 'Redhat'
                },
            ],
        },
        {
            'categoryCode': 'port_speed',
            'id': 26,
            'name': 'Uplink Port Speeds',
            'groups': [
                {
                    'sort': 0,
                    'prices': single_nic_prices,
                    'itemCategoryId': 26,
                    'packageId': 13,
                },
                {
                    'sort': 5,
                    'prices': dual_nic_prices,
                    'itemCategoryId': 26,
                    'packageId': 13,
                },
            ],
        },
        {
            'categoryCode': 'disk_controller',
            'id': 11,
            'groups': [{
                'sort': 0,
                'prices': controller_prices,
                'itemCategoryId': 11,
                'packageId': 13}],
            'name': 'Disk Controller'
        },
    ]


def get_bmc_categories_mock():
    server_core_prices = [
        {
            'itemId': 1013,
            'setupFee': '0',
            'recurringFee': '159',
            'hourlyRecurringFee': '.5',
            'oneTimeFee': '0',
            'id': 1921,
            'sort': 0,
            'item': {
                'capacity': '2',
                'description': '2 x 2.0 GHz Core Bare Metal Instance - '
                '2 GB Ram',
                'id': 1013
            },
            'laborFee': '0',
        },
        {
            'itemId': 1014,
            'setupFee': '0',
            'recurringFee': '199',
            'hourlyRecurringFee': '.75',
            'oneTimeFee': '0',
            'id': 1922,
            'sort': 0,
            'item': {
                'capacity': '4',
                'description': '4 x 2.0 GHz Core Bare Metal Instance - '
                '4 GB Ram',
                'id': 1014
            },
            'laborFee': '0',
        },
        {
            'itemId': 1015,
            'setupFee': '0',
            'recurringFee': '149',
            'hourlyRecurringFee': '.75',
            'oneTimeFee': '0',
            'id': 1923,
            'sort': 0,
            'item': {
                'capacity': '2',
                'description': '2 x 2.0 GHz Core Bare Metal Instance - '
                '4 GB Ram',
                'id': 1014
            },
            'laborFee': '0',
        }
    ]

    centos_prices = [
        {
            'itemId': 3921,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 13963,
            'sort': 0,
            'item': {
                'description': 'CentOS 6.0 - Minimal Install (64 bit)',
                'id': 3921
            },
            'laborFee': '0',
        },
        {
            'itemId': 3919,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 13961,
            'sort': 0,
            'item': {
                'description': 'CentOS 6.0 - LAMP Install (64 bit)',
                'id': 3919
            },
            'laborFee': '0',
        },
    ]

    redhat_prices = [
        {
            'itemId': 3838,
            'setupFee': '0',
            'recurringFee': '20',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 1,
            'item': {
                'description': 'Red Hat Enterprise Linux 6 - Minimal Install '
                '(64 bit)',
                'id': 3838
            },
            'id': 13798,
        },
        {
            'itemId': 3834,
            'setupFee': '0',
            'recurringFee': '20',
            'laborFee': '0',
            'oneTimeFee': '0',
            'sort': 1,
            'item': {
                'description': 'Red Hat Enterprise Linux 6 - LAMP Install '
                '(64 bit)',
                'id': 3834
            },
            'id': 13795,
        }
    ]

    ubuntu_prices = [
        {
            'itemId': 4170,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 17438,
            'sort': 9,
            'item': {
                'description': 'Ubuntu Linux 12.04 LTS Precise Pangolin - '
                'Minimal Install (64 bit)',
                'id': 4170
            },
            'laborFee': '0',
        },
        {
            'itemId': 4168,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 17434,
            'sort': 9,
            'item': {
                'description': 'Ubuntu Linux 12.04 LTS Precise Pangolin - '
                'LAMP Install (64 bit)',
                'id': 4168
            },
            'laborFee': '0',
        },
    ]

    windows_prices = [
        {
            'itemId': 936,
            'setupFee': '0',
            'recurringFee': '20',
            'hourlyRecurringFee': '.05',
            'oneTimeFee': '0',
            'id': 1752,
            'sort': 16,
            'item': {
                'description': 'Windows Server 2008 Standard Edition SP2 '
                '(64bit)',
                'id': 936
            },
            'laborFee': '0',
        },
        {
            'itemId': 938,
            'setupFee': '0',
            'recurringFee': '50',
            'hourlyRecurringFee': '.1',
            'oneTimeFee': '0',
            'id': 1761,
            'sort': 16,
            'item': {
                'description': 'Windows Server 2008 Enterprise Edition SP2 '
                '(64bit)',
                'id': 938
            },
            'laborFee': '0',
        },
        {
            'itemId': 940,
            'setupFee': '0',
            'recurringFee': '75',
            'hourlyRecurringFee': '.15',
            'oneTimeFee': '0',
            'id': 1770,
            'sort': 16,
            'item': {
                'description': 'Windows Server 2008 Datacenter Edition SP2 '
                '(64bit)',
                'id': 940
            },
            'laborFee': '0',
        },
        {
            'itemId': 4247,
            'setupFee': '0',
            'recurringFee': '75',
            'hourlyRecurringFee': '.15',
            'oneTimeFee': '0',
            'id': 21060,
            'sort': 17,
            'item': {
                'description': 'Windows Server 2012 Datacenter Edition With '
                'Hyper-V (64bit)',
                'id': 4247
            },
            'laborFee': '0',
        },
        {
            'itemId': 4248,
            'setupFee': '0',
            'recurringFee': '20',
            'hourlyRecurringFee': '.05',
            'oneTimeFee': '0',
            'id': 21074,
            'sort': 15,
            'item': {
                'description': 'Windows Server 2008 Standard SP1 with R2 '
                '(64 bit)',
                'id': 4248
            },
            'laborFee': '0',
        },
    ]

    disk_prices1 = [
        {
            'itemId': 14,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 1267,
            'sort': 0,
            'item': {
                'capacity': '500',
                'description': '500GB SATA II',
                'id': 14
            },
            'laborFee': '0',
        },
    ]

    disk_prices2 = [
        {
            'itemId': 2000,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 19,
            'sort': 99,
            'item': {
                'capacity': '250',
                'description': '250GB SATA II',
                'id': 2000
            },
            'laborFee': '0',
        }
    ]

    single_nic_prices = [
        {
            'itemId': 187,
            'setupFee': '0',
            'recurringFee': '0',
            'hourlyRecurringFee': '0',
            'oneTimeFee': '0',
            'id': 273,
            'sort': 0,
            'item': {
                'capacity': '100',
                'description': '100 Mbps Public & Private Networks',
                'id': 187
            },
            'laborFee': '0',
        },
        {
            'itemId': 188,
            'setupFee': '0',
            'recurringFee': '20',
            'hourlyRecurringFee': '.04',
            'oneTimeFee': '0',
            'id': 274,
            'sort': 0,
            'item': {
                'capacity': '1000',
                'description': '1 Gbps Public & Private Networks',
                'id': 188
            },
            'laborFee': '0',
        }
    ]

    dual_nic_prices = [
        {
            'itemId': 4332,
            'setupFee': '0',
            'recurringFee': '10',
            'hourlyRecurringFee': '.02',
            'oneTimeFee': '0',
            'id': 21509,
            'sort': 5,
            'item': {
                'capacity': '10',
                'description': '10 Mbps Dual Public & Private Networks '
                '(up to 20 Mbps)',
                'id': 4332
            },
            'laborFee': '0',
        },
        {
            'itemId': 4336,
            'setupFee': '0',
            'recurringFee': '20',
            'hourlyRecurringFee': '.03',
            'oneTimeFee': '0',
            'id': 21513,
            'sort': 5,
            'item': {
                'capacity': '100',
                'description': '100 Mbps Dual Public & Private Networks '
                '(up to 200 Mbps)',
                'id': 4336
            },
            'laborFee': '0',
            'quantity': ''
        },
        {
            'itemId': 1284,
            'setupFee': '0',
            'recurringFee': '40',
            'hourlyRecurringFee': '.05',
            'oneTimeFee': '0',
            'id': 2314,
            'sort': 5,
            'item': {
                'capacity': '1000',
                'description': '1 Gbps Dual Public & Private Networks '
                '(up to 2 Gbps)',
                'id': 1284
            },
            'laborFee': '0',
        }
    ]

    return [
        {
            'categoryCode': 'server_core',
            'id': 110,
            'groups': [{
                'sort': 0,
                'prices': server_core_prices,
                'itemCategoryId': 110,
                'packageId': 50
            }],
            'name': 'Bare Metal Instance'
        },
        {
            'categoryCode': 'os',
            'id': 12,
            'groups': [
                {'sort': 0, 'prices': centos_prices, 'title': 'CentOS'},
                {'sort': 0, 'prices': redhat_prices, 'title': 'Redhat'},
                {'sort': 9, 'prices': ubuntu_prices, 'title': 'Ubuntu'},
                {'sort': 14, 'prices': windows_prices, 'title': 'Microsoft'}
            ],
            'name': 'Operating System'
        },
        {
            'categoryCode': 'disk0',
            'id': 4,
            'groups': [
                {
                    'sort': 0,
                    'prices': disk_prices1,
                    'itemCategoryId': 4,
                    'packageId': 50
                },
                {
                    'sort': 99,
                    'prices': disk_prices2,
                    'itemCategoryId': 4,
                    'packageId': 50
                }
            ],
            'name': 'First Hard Drive',
        },
        {
            'categoryCode': 'port_speed',
            'id': 26,
            'groups': [
                {
                    'sort': 0,
                    'prices': single_nic_prices,
                    'itemCategoryId': 26,
                    'packageId': 50
                },
                {
                    'sort': 5,
                    'prices': dual_nic_prices,
                    'itemCategoryId': 26,
                    'packageId': 50
                }
            ],
            'name': 'Uplink Port Speeds',
        },
    ]

getCategories = get_server_categories_mock() + get_bmc_categories_mock()
getItems = [
    {
        'id': 1234,
        'categories': [{'id': 26, 'name': 'Uplink Port Speeds'}],
        'capacity': '1000',
        'description': 'Public & Private Networks',
        'itemCategory': {'categoryCode': 'Uplink Port Speeds'},
        'prices': [{'id': 1122}],
    },
    {
        'id': 2233,
        'categories': [{'id': 26, 'name': 'Uplink Port Speeds'}],
        'capacity': '1000',
        'description': 'Public & Private Networks',
        'itemCategory': {'categoryCode': 'Uplink Port Speeds'},
        'prices': [{'id': 4477}],
    },
    {
        'id': 1239,
        'categories': [{'id': 3, 'name': 'RAM'}],
        'capacity': '2',
        'description': 'RAM',
        'itemCategory': {'categoryCode': 'RAM'},
        'prices': [{'id': 1133}],
    },
    {
        'id': 1240,
        'categories': [{'id': 80, 'name': 'Computing Instance'}],
        'capacity': '4',
        'description': 'Private Computing Instance',
        'itemCategory': {'categoryCode': 'Computing Instance'},
        'prices': [{'id': 1007}],
    },
    {
        'id': 1250,
        'categories': [{'id': 80, 'name': 'Computing Instance'}],
        'capacity': '4',
        'description': 'Computing Instance',
        'itemCategory': {'categoryCode': 'Computing Instance'},
        'prices': [{'id': 1144}],
    },
    {
        'id': 4439,
        'capacity': '1',
        'description': '1 GB iSCSI Storage',
        'itemCategory': {'categoryCode': 'iscsi'},
        'prices': [{'id': 2222}],
    },
    {
        'id': 1121,
        'capacity': '20',
        'description': '20 GB iSCSI snapshot',
        'itemCategory': {'categoryCode': 'iscsi_snapshot_space'},
        'prices': [{'id': 2014}],
    },
    {
        'id': 4440,
        'capacity': '4',
        'description': '4 Portable Public IP Addresses',
        'itemCategory': {'categoryCode': 'sov_sec_ip_addresses_pub'},
        'prices': [{'id': 4444}],
    },
    {
        'id': 8880,
        'capacity': '8',
        'description': '8 Portable Public IP Addresses',
        'itemCategory': {'categoryCode': 'sov_sec_ip_addresses_pub'},
        'prices': [{'id': 8888}],
    },
    {
        'id': 44400,
        'capacity': '4',
        'description': '4 Portable Private IP Addresses',
        'itemCategory': {'categoryCode': 'sov_sec_ip_addresses_priv'},
        'prices': [{'id': 44441}],
    },
    {
        'id': 88800,
        'capacity': '8',
        'description': '8 Portable Private IP Addresses',
        'itemCategory': {'categoryCode': 'sov_sec_ip_addresses_priv'},
        'prices': [{'id': 88881}],
    },
    {
        'id': 10,
        'capacity': '0',
        'description': 'Global IPv4',
        'itemCategory': {'categoryCode': 'global_ipv4'},
        'prices': [{'id': 11}],
    },
    {
        'id': 66464,
        'capacity': '64',
        'description': '/64 Block Portable Public IPv6 Addresses',
        'itemCategory': {'categoryCode': 'static_ipv6_addresses'},
        'prices': [{'id': 664641}],
    },
    {
        'id': 610,
        'capacity': '0',
        'description': 'Global IPv6',
        'itemCategory': {'categoryCode': 'global_ipv6'},
        'prices': [{'id': 611}],
    }]
getItemPrices = [
    {
        'currentPriceFlag': '',
        'id': 2152,
        'item': {
            'capacity': '1',
            'description': '1 GB iSCSI SAN Storage',
            'id': 1111,
            'softwareDescriptionId': '',
            'units': 'GB',
            'upgradeItemId': 547},
        'itemId': 1111,
        'laborFee': '0',
        'onSaleFlag': '',
        'oneTimeFee': '0',
        'packageReferences': [{'id': 46626,
                               'itemPriceId': 2152, 'packageId': 0}],
        'quantity': '',
        'recurringFee': '.35',
        'setupFee': '0',
        'sort': 0
    },
    {
        'currentPriceFlag': '',
        'id': 22501,
        'item': {'capacity': '1',
                 'description': '1 GB iSCSI SAN Storage',
                 'id': 1111,
                 'softwareDescriptionId': '',
                 'units': 'GB',
                 'upgradeItemId': 547},
        'itemId': 1111,
        'laborFee': '0',
        'onSaleFlag': '',
        'oneTimeFee': '0',
        'packageReferences': [{
            'id': 252983,
            'itemPriceId': 22501, 'packageId': 0
        }],
        'quantity': '',
        'recurringFee': '0',
        'setupFee': '0',
        'sort': 0
    },
    {
        'currentPriceFlag': '',
        'id': 22441,
        'item': {
            'capacity': '1',
            'description': '1 GB iSCSI SAN Storage',
            'id': 1111,
            'softwareDescriptionId': '',
            'units': 'GB',
            'upgradeItemId': 547
        },
        'itemId': 1111,
        'laborFee': '0',
        'onSaleFlag': '',
        'oneTimeFee': '0',
        'packageReferences': [{'id': 250326,
                               'itemPriceId': 22441, 'packageId': 0}],
        'quantity': '',
        'recurringFee': '15',
        'setupFee': '0',
        'sort': 0
    }]

########NEW FILE########
__FILENAME__ = Security_Certificate
createObject = {}
getObject = {}
editObject = True
deleteObject = True

########NEW FILE########
__FILENAME__ = Security_Ssh_Key
deleteObject = True
editObject = True
getObject = {'id': 1234,
             'fingerprint': 'aa:bb:cc:dd',
             'label': 'label',
             'notes': 'notes',
             'key': 'ssh-rsa AAAAB3N...pa67 user@example.com'}
createObject = getObject

########NEW FILE########
__FILENAME__ = Ticket
createCancelServerTicket = {'id': 1234, 'title': 'Server Cancellation Request'}
getObject = {
    "accountId": 1234,
    "assignedUserId": 12345,
    "createDate": "2013-08-01T14:14:04-07:00",
    "id": 100,
    "lastEditDate": "2013-08-01T14:16:47-07:00",
    "lastEditType": "AUTO",
    "modifyDate": "2013-08-01T14:16:47-07:00",
    "status": {
        "id": 1002,
        "name": "Closed"
    },
    "statusId": 1002,
    "title": "Cloud Instance Cancellation - 08/01/13"
}

createStandardTicket = {
    "assignedUserId": 12345,
    "id": 100,
    "contents": "body",
    "subjectId": 1004,
    "title": "Cloud Instance Cancellation - 08/01/13"
}
edit = True

########NEW FILE########
__FILENAME__ = Ticket_Subject
getAllObjects = [
    {
        "id": 1001,
        "name": "Accounting Request"
    },
    {
        "id": 1002,
        "name": "Sales Request"
    },
    {
        "id": 1003,
        "name": "Reboots and Console Access"
    },
    {
        "id": 1004,
        "name": "DNS Request"
    },
    {
        "id": 1005,
        "name": "Hardware Issue"
    }
]

########NEW FILE########
__FILENAME__ = User_Customer
addApiAuthenticationKey = "A" * 64

########NEW FILE########
__FILENAME__ = Virtual_Guest
getObject = {
    'id': 100,
    'hostname': 'vs-test1',
    'domain': 'test.sftlyr.ws',
    'fullyQualifiedDomainName': 'vs-test1.test.sftlyr.ws',
    'status': {'keyName': 'ACTIVE', 'name': 'Active'},
    'datacenter': {'id': 50, 'name': 'TEST00',
                   'description': 'Test Data Center'},
    'powerState': {'keyName': 'RUNNING', 'name': 'Running'},
    'maxCpu': 2,
    'maxMemory': 1024,
    'primaryIpAddress': '172.16.240.2',
    'globalIdentifier': '1a2b3c-1701',
    'primaryBackendIpAddress': '10.45.19.37',
    "primaryNetworkComponent": {"speed": 10},
    'hourlyBillingFlag': False,
    'createDate': '2013-08-01 15:23:45',
    'blockDevices': [{"device": 0, "uuid": 1},
                     {"device": 1},
                     {"device": 2, "uuid": 2}],
    'notes': 'notes',
    'networkVlans': [{'networkSpace': 'PUBLIC',
                      'vlanNumber': 23,
                      'id': 1}],
    'operatingSystem': {
        'passwords': [{'username': 'user', 'password': 'pass'}],
        'softwareLicense': {
            'softwareDescription': {'version': '12.04-64 Minimal for CCI',
                                    'name': 'Ubuntu'}}
    },
    'tagReferences': [{'tag': {'name': 'production'}}],
}

getCreateObjectOptions = {
    'processors': [
        {
            'itemPrice': {
                'item': {'description': '1 x 2.0 GHz Core'},
                'hourlyRecurringFee': '.07',
                'recurringFee': '29'
            },
            'template': {'startCpus': 1}
        },
        {
            'itemPrice': {
                'item': {'description': '2 x 2.0 GHz Cores'},
                'hourlyRecurringFee': '.14',
                'recurringFee': '78'
            },
            'template': {'startCpus': 2}
        },
        {
            'itemPrice': {
                'item': {'description': '3 x 2.0 GHz Cores'},
                'hourlyRecurringFee': '.205',
                'recurringFee': '123.5'
            },
            'template': {'startCpus': 3}
        },
        {
            'itemPrice': {
                'item': {'description': '4 x 2.0 GHz Cores'},
                'hourlyRecurringFee': '.265',
                'recurringFee': '165.5'
            },
            'template': {'startCpus': 4}
        },
    ],
    'memory': [
        {
            'itemPrice': {
                'item': {'description': '1 GB'},
                'hourlyRecurringFee': '.03',
                'recurringFee': '21'
            },
            'template': {'maxMemory': 1024}
        },
        {
            'itemPrice': {
                'item': {'description': '2 GB'},
                'hourlyRecurringFee': '.06',
                'recurringFee': '42'
            },
            'template': {'maxMemory': 2048}
        },
        {
            'itemPrice': {
                'item': {'description': '3 GB'},
                'hourlyRecurringFee': '.085',
                'recurringFee': '59.5'},
            'template': {'maxMemory': 3072}
        },
        {
            'itemPrice': {
                'item': {'description': '4 GB'},
                'hourlyRecurringFee': '.11',
                'recurringFee': '77'
            },
            'template': {'maxMemory': 4096}
        },
    ],
    'blockDevices': [
        {
            'itemPrice': {
                'item': {'description': '25 GB (LOCAL)'},
                'hourlyRecurringFee': '0',
                'recurringFee': '0'},
            'template': {
                'blockDevices': [
                    {'device': '0', 'diskImage': {'capacity': 25}}
                ],
                'localDiskFlag': True
            }
        },
        {
            'itemPrice': {
                'item': {'description': '100 GB (LOCAL)'},
                'hourlyRecurringFee': '.01',
                'recurringFee': '7'
            },
            'template': {
                'blockDevices': [
                    {'device': '0', 'diskImage': {'capacity': 100}}
                ],
                'localDiskFlag': True
            }
        },
    ],
    'operatingSystems': [
        {
            'itemPrice': {
                'item': {
                    'description': 'CentOS 6.0 - Minimal Install (64 bit)'
                },
                'hourlyRecurringFee': '0',
                'recurringFee': '0'
            },
            'template': {
                'operatingSystemReferenceCode': 'CENTOS_6_64'
            }
        },
        {
            'itemPrice': {
                'item': {
                    'description': 'Debian GNU/Linux 7.0 Wheezy/Stable -'
                    ' Minimal Install (64 bit)'
                },
                'hourlyRecurringFee': '0',
                'recurringFee': '0'
            },
            'template': {
                'operatingSystemReferenceCode': 'DEBIAN_7_64'
            }
        },
        {
            'itemPrice': {
                'item': {
                    'description': 'Ubuntu Linux 12.04 LTS Precise'
                    ' Pangolin - Minimal Install (64 bit)'
                },
                'hourlyRecurringFee': '0',
                'recurringFee': '0'
            },
            'template': {
                'operatingSystemReferenceCode': 'UBUNTU_12_64'
            }
        },
    ],
    'networkComponents': [
        {
            'itemPrice': {
                'item': {
                    'description': '10 Mbps Public & Private Networks'
                },
                'hourlyRecurringFee': '0',
                'recurringFee': '0'},
            'template': {
                'networkComponents': [{'maxSpeed': 10}]
            }
        },
        {
            'itemPrice': {
                'item': {'description': '100 Mbps Private Network'},
                'hourlyRecurringFee': '0',
                'recurringFee': '0'},
            'template': {
                'networkComponents': [{'maxSpeed': 100}]
            }
        },
        {
            'itemPrice': {
                'item': {'description': '1 Gbps Private Network'},
                'hourlyRecurringFee': '.02',
                'recurringFee': '10'
            },
            'template': {
                'networkComponents': [{'maxSpeed': 1000}]
            }
        }
    ],
    'datacenters': [
        {'template': {'datacenter': {'name': 'ams01'}}},
        {'template': {'datacenter': {'name': 'dal05'}}},
    ],
}

getReverseDomainRecords = [{
    'networkAddress': '12.34.56.78',
    'name': '12.34.56.78.in-addr.arpa',
    'resourceRecords': [{'data': 'test.softlayer.com.', 'id': 987654}],
    'updateDate': '2013-09-11T14:36:57-07:00',
    'serial': 1234665663,
    'id': 123456,
}]

editObject = True
deleteObject = True
setPrivateNetworkInterfaceSpeed = True
setPublicNetworkInterfaceSpeed = True
createObject = getObject
generateOrderTemplate = {}
setUserMetadata = ['meta']
reloadOperatingSystem = 'OK'

createArchiveTransaction = {}

########NEW FILE########
__FILENAME__ = Virtual_Guest_Block_Device_Template_Group
IMAGES = [{
    'accountId': 1234,
    'blockDevices': [],
    'createDate': '2013-12-05T21:53:03-06:00',
    'globalIdentifier': '0B5DEAF4-643D-46CA-A695-CECBE8832C9D',
    'id': 100,
    'name': 'test_image',
    'parentId': ''
}, {
    'accountId': 1234,
    'blockDevices': [],
    'createDate': '2013-12-05T21:53:03-06:00',
    'globalIdentifier': 'EB38414C-2AB3-47F3-BBBD-56A5F689620B',
    'id': 101,
    'name': 'test_image2',
    'parentId': ''
}]

getObject = IMAGES[0]
getPublicImages = IMAGES
deleteObject = {}
editObject = True
setTags = True

########NEW FILE########
__FILENAME__ = fixture_client
"""
    SoftLayer.tests.fixture_client
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import MagicMock, MagicMixin
from importlib import import_module


class FixtureClient(MagicMixin):

    def __init__(self):
        # Keep track of Service instances in order to do future assertions
        self.loaded_services = {}

    def __getitem__(self, service_name):
        if service_name in self.loaded_services:
            return self.loaded_services[service_name]

        service = FixtureService(service_name)
        self.loaded_services[service_name] = service

        return service

    def reset_mock(self):
        self.loaded_services = {}


class FixtureService(MagicMixin):

    def __init__(self, service_name):
        self.service_name = service_name
        try:
            self.module = import_module('SoftLayer.tests.fixtures.%s'
                                        % service_name)
        except ImportError:
            raise NotImplementedError('%s fixture is not implemented'
                                      % service_name)

        # Keep track of MagicMock instances in order to do future assertions
        self.loaded_methods = {}

    def __getattr__(self, name):
        if name in self.loaded_methods:
            return self.loaded_methods[name]

        call_handler = MagicMock()
        fixture = getattr(self.module, name, None)
        if fixture is not None:
            call_handler.return_value = fixture
        else:
            raise NotImplementedError('%s::%s fixture is not implemented'
                                      % (self.service_name, name))

        self.loaded_methods[name] = call_handler
        return call_handler

########NEW FILE########
__FILENAME__ = functional_tests
"""
    SoftLayer.tests.functional_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
import os

import SoftLayer
from SoftLayer.tests import unittest


def get_creds():
    for key in 'SL_USERNAME SL_API_KEY'.split():
        if key not in os.environ:
            raise unittest.SkipTest(
                'SL_USERNAME and SL_API_KEY environmental variables not set')

    return {
        'endpoint': (os.environ.get('SL_API_ENDPOINT') or
                     SoftLayer.API_PUBLIC_ENDPOINT),
        'username': os.environ['SL_USERNAME'],
        'api_key': os.environ['SL_API_KEY']
    }


class UnauthedUser(unittest.TestCase):
    def test_failed_auth(self):
        client = SoftLayer.Client(
            username='doesnotexist', api_key='issurelywrong', timeout=20)
        self.assertRaises(
            SoftLayer.SoftLayerAPIError,
            client['SoftLayer_User_Customer'].getPortalLoginToken)

    def test_no_hostname(self):
        try:
            # This test will fail if 'notvalidsoftlayer.com' becomes a thing
            SoftLayer.API.make_xml_rpc_api_call(
                'http://notvalidsoftlayer.com', 'getObject')
        except SoftLayer.SoftLayerAPIError as e:
            self.assertEqual(e.faultCode, 0)
            self.assertIn('not known', e.faultString)
            self.assertIn('not known', e.reason)
        else:
            self.fail('No Exception Raised')


class AuthedUser(unittest.TestCase):
    def test_service_does_not_exist(self):
        creds = get_creds()
        client = SoftLayer.Client(
            username=creds['username'],
            api_key=creds['api_key'],
            endpoint_url=creds['endpoint'],
            timeout=20)

        try:
            client["SoftLayer_DOESNOTEXIST"].getObject()
        except SoftLayer.SoftLayerAPIError as e:
            self.assertEqual(e.faultCode, '-32601')
            self.assertEqual(e.faultString, 'Service does not exist')
            self.assertEqual(e.reason, 'Service does not exist')
        else:
            self.fail('No Exception Raised')

    def test_get_users(self):
        creds = get_creds()
        client = SoftLayer.Client(
            username=creds['username'],
            api_key=creds['api_key'],
            endpoint_url=creds['endpoint'],
            timeout=20)

        found = False
        results = client["Account"].getUsers()
        for user in results:
            if user.get('username') == creds['username']:
                found = True
        self.assertTrue(found)

    def test_result_types(self):
        creds = get_creds()
        client = SoftLayer.Client(
            username=creds['username'],
            api_key=creds['api_key'],
            endpoint_url=creds['endpoint'],
            timeout=20)
        result = client['SoftLayer_User_Security_Question'].getAllObjects()
        self.assertIsInstance(result, list)
        self.assertIsInstance(result[0], dict)
        self.assertIsInstance(result[0]['viewable'], int)
        self.assertIsInstance(result[0]['question'], str)
        self.assertIsInstance(result[0]['id'], int)
        self.assertIsInstance(result[0]['displayOrder'], int)

########NEW FILE########
__FILENAME__ = cci_tests
"""
    SoftLayer.tests.managers.cci_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import CCIManager
from SoftLayer.tests import unittest, FixtureClient

from mock import ANY, call


class CCITests(unittest.TestCase):
    """
    Small class to verify the rename of CCIManager to VSManager didn't
    break any existing code.
    """
    def setUp(self):
        self.client = FixtureClient()
        self.cci = CCIManager(self.client)

    def test_list_instances(self):
        mcall = call(mask=ANY, filter={})
        service = self.client['Account']

        list_expected_ids = [100, 104]
        hourly_expected_ids = [104]
        monthly_expected_ids = [100]

        results = self.cci.list_instances(hourly=True, monthly=True)
        service.getVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

        result = self.cci.list_instances(hourly=False, monthly=False)
        service.getVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

        results = self.cci.list_instances(hourly=False, monthly=True)
        service.getMonthlyVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], monthly_expected_ids)

        results = self.cci.list_instances(hourly=True, monthly=False)
        service.getHourlyVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], hourly_expected_ids)

########NEW FILE########
__FILENAME__ = cdn_tests
"""
    SoftLayer.tests.managers.cdn_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.managers.cdn import (CDNManager, MAX_URLS_PER_LOAD,
                                    MAX_URLS_PER_PURGE)
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Account
from mock import call
from math import ceil


class CDNTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.cdn_client = CDNManager(self.client)

    def test_list_accounts(self):
        accounts = self.cdn_client.list_accounts()
        self.assertEqual(accounts, Account.getCdnAccounts)

    def test_get_account(self):
        account = self.cdn_client.get_account(12345)
        account_fixtures = self.client['Network_ContentDelivery_Account'].\
            getObject(id=12345)
        self.assertEqual(account, account_fixtures)

    def test_get_origins(self):
        origins = self.cdn_client.get_origins(12345)
        origins_fixture = self.client['Network_ContentDelivery_Account'].\
            getOriginPullMappingInformation(id=12345)
        self.assertEqual(origins, origins_fixture)

    def test_add_origin(self):
        account_id = 12345
        media_type = 'http'
        origin_url = 'http://localhost/',
        cname = 'self.local'
        secure = False

        self.cdn_client.add_origin(account_id, media_type,
                                   origin_url, cname, secure)

        service = self.client['Network_ContentDelivery_Account']
        service.createOriginPullMapping.assert_called_once_with({
            'mediaType': media_type,
            'originUrl': origin_url,
            'cname': cname,
            'isSecureContent': secure},
            id=account_id)

    def test_remove_origin(self):
        account_id = 12345
        id = 12345
        mcall = call(account_id, id=id)
        service = self.client['Network_ContentDelivery_Account']

        self.cdn_client.remove_origin(account_id, id)
        service.deleteOriginPullRule.assert_has_calls(mcall)

    def test_load_content(self):
        account_id = 12345
        urls = ['http://a/img/0x001.png',
                'http://b/img/0x002.png',
                'http://c/img/0x004.png',
                'http://d/img/0x008.png',
                'http://e/img/0x010.png',
                'http://e/img/0x020.png']

        self.cdn_client.load_content(account_id, urls)
        service = self.client['Network_ContentDelivery_Account']
        self.assertEqual(service.loadContent.call_count,
                         ceil(len(urls) / float(MAX_URLS_PER_LOAD)))

    def test_load_content_single(self):
        account_id = 12345
        url = 'http://geocities.com/Area51/Meteor/12345/under_construction.gif'
        self.cdn_client.load_content(account_id, url)
        service = self.client['Network_ContentDelivery_Account']
        service.loadContent.assert_called_once_with([url], id=account_id)

    def test_load_content_failure(self):
        account_id = 12345
        urls = ['http://z/img/0x004.png',
                'http://y/img/0x002.png',
                'http://x/img/0x001.png']

        service = self.client['Network_ContentDelivery_Account']
        service.loadContent.return_value = False

        self.cdn_client.load_content(account_id, urls)
        self.assertEqual(service.loadContent.call_count,
                         ceil(len(urls) / float(MAX_URLS_PER_LOAD)))

    def test_purge_content(self):
        account_id = 12345
        urls = ['http://z/img/0x020.png',
                'http://y/img/0x010.png',
                'http://x/img/0x008.png',
                'http://w/img/0x004.png',
                'http://v/img/0x002.png',
                'http://u/img/0x001.png']

        self.cdn_client.purge_content(account_id, urls)
        service = self.client['Network_ContentDelivery_Account']
        self.assertEqual(service.purgeContent.call_count,
                         ceil(len(urls) / float(MAX_URLS_PER_PURGE)))

    def test_purge_content_failure(self):
        account_id = 12345
        urls = ['http://z/img/0x004.png',
                'http://y/img/0x002.png',
                'http://x/img/0x001.png']

        service = self.client['Network_ContentDelivery_Account']
        service.purgeContent.return_value = False

        self.cdn_client.purge_content(account_id, urls)
        self.assertEqual(service.purgeContent.call_count,
                         ceil(len(urls) / float(MAX_URLS_PER_PURGE)))

    def test_purge_content_single(self):
        account_id = 12345
        url = 'http://geocities.com/Area51/Meteor/12345/under_construction.gif'
        service = self.client['Network_ContentDelivery_Account']

        self.cdn_client.purge_content(account_id, url)
        service.purgeContent.assert_called_once_with([url], id=account_id)

########NEW FILE########
__FILENAME__ = dns_tests
"""
    SoftLayer.tests.managers.dns_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import DNSManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Dns_Domain, Account

from mock import ANY


class DNSTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.dns_client = DNSManager(self.client)

    def test_init_exercise(self):
        self.assertTrue(hasattr(self.dns_client, 'service'))
        self.assertTrue(hasattr(self.dns_client, 'record'))

    def test_list_zones(self):
        zones = self.dns_client.list_zones()
        self.assertEqual(zones, Account.getDomains)

    def test_get_zone(self):
        # match, with defaults
        res = self.dns_client.get_zone(12345)
        self.assertEqual(res, Dns_Domain.getObject)
        self.client['Dns_Domain'].getObject.assert_called_once_with(
            id=12345,
            mask='resourceRecords')

        # No records masked in
        self.client['Dns_Domain'].getObject.reset_mock()
        self.dns_client.get_zone(12345, records=False)
        self.client['Dns_Domain'].getObject.assert_called_once_with(
            id=12345,
            mask=None)

    def test_resolve_zone_name(self):
        # matching domain
        res = self.dns_client._get_zone_id_from_name('example.com')
        self.assertEqual([12345], res)
        self.client['Account'].getDomains.assert_called_once_with(
            filter={"domains": {"name": {"operation": "_= example.com"}}})

        # no matches
        self.client['Account'].getDomains.reset_mock()
        self.client['Account'].getDomains.return_value = []
        res = self.dns_client._get_zone_id_from_name('example.com')
        self.assertEqual([], res)
        self.client['Account'].getDomains.assert_called_once_with(
            filter={"domains": {"name": {"operation": "_= example.com"}}})

    def test_create_zone(self):
        res = self.dns_client.create_zone('example.com')

        self.client['Dns_Domain'].createObject.assert_called_once_with({
            'name': 'example.com', "resourceRecords": {}, "serial": ANY
        })

        self.assertEqual(res, {'name': 'example.com'})

    def test_delete_zone(self):
        self.dns_client.delete_zone(1)
        self.client['Dns_Domain'].deleteObject.assert_called_once_with(id=1)

    def test_edit_zone(self):
        self.dns_client.edit_zone('example.com')
        self.client['Dns_Domain'].editObject.assert_called_once_with(
            'example.com')

    def test_create_record(self):
        self.dns_client.create_record(1, 'test', 'TXT', 'testing', ttl=1200)

        f = self.client['Dns_Domain_ResourceRecord'].createObject
        f.assert_called_once_with(
            {
                'domainId': 1,
                'ttl': 1200,
                'host': 'test',
                'type': 'TXT',
                'data': 'testing'
            })

    def test_delete_record(self):
        self.dns_client.delete_record(1)
        f = self.client['Dns_Domain_ResourceRecord'].deleteObject
        f.assert_called_once_with(id=1)

    def test_edit_record(self):
        self.dns_client.edit_record({'id': 1, 'name': 'test', 'ttl': '1800'})
        f = self.client['Dns_Domain_ResourceRecord'].editObject
        f.assert_called_once_with(
            {'id': 1, 'name': 'test', 'ttl': '1800'},
            id=1
        )

    def test_dump_zone(self):
        f = self.client['Dns_Domain'].getZoneFileContents
        self.dns_client.dump_zone(1)
        f.assert_called_once_with(id=1)

    def test_get_record(self):
        records = self.client['Dns_Domain'].getResourceRecords

        # maybe valid domain, but no records matching
        records.return_value = []
        self.assertEqual(self.dns_client.get_records(12345), [])

        records.reset_mock()
        records.return_value = [Dns_Domain.getResourceRecords[0]]
        self.dns_client.get_records(12345,
                                    record_type='a',
                                    host='hostname',
                                    data='a',
                                    ttl='86400')
        records.assert_called_once_with(
            id=12345,
            filter={'resourceRecords': {'type': {'operation': '_= a'},
                                        'host': {'operation': '_= hostname'},
                                        'data': {'operation': '_= a'},
                                        'ttl': {'operation': 86400}}},
            mask=ANY)

########NEW FILE########
__FILENAME__ = firewall_tests
"""
    SoftLayer.tests.managers.firewall_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import FirewallManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import (Network_Component_Firewall,
                                      Network_Vlan_Firewall, Billing_Item)
from mock import ANY


MASK = ('mask[orderValue,action,destinationIpAddress,destinationIpSubnetMask,'
        'protocol,destinationPortRangeStart,destinationPortRangeEnd,'
        'sourceIpAddress,sourceIpSubnetMask,version]')


class FirewallTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.firewall = FirewallManager(self.client)

    def test_get_firewalls(self):
        call = self.client['Account'].getNetworkVlans
        firewall_vlan = {
            'id': 1,
            'firewallNetworkComponents': [{'id': 1234}],
            'networkVlanFirewall': {'id': 1234},
            'dedicatedFirewallFlag': True,
            'firewallGuestNetworkComponents': [{'id': 1234}],
            'firewallInterfaces': [{'id': 1234}],
            'firewallRules': [{'id': 1234}],
            'highAvailabilityFirewallFlag': True,
        }
        call.return_value = [firewall_vlan]

        firewalls = self.firewall.get_firewalls()

        call.assert_called_once_with(mask=ANY)
        self.assertEqual(firewalls, [firewall_vlan])

    def test_get_standard_fwl_rules(self):
        call = self.client['Network_Component_Firewall'].getRules

        rules = self.firewall.get_standard_fwl_rules(1234)
        call.assert_called_once_with(id=1234, mask=MASK)
        self.assertEqual(rules, Network_Component_Firewall.getRules)

    def test_get_dedicated_fwl_rules(self):
        call = self.client['Network_Vlan_Firewall'].getRules

        rules = self.firewall.get_dedicated_fwl_rules(1234)
        call.assert_called_once_with(id=1234, mask=MASK)
        self.assertEqual(rules, Network_Vlan_Firewall.getRules)

    def test_get_standard_package(self):
        # test standard firewalls
        self.firewall.get_standard_package(server_id=1234, is_cci=True)
        call2 = self.client['Virtual_Guest'].getObject
        mask = ('mask[primaryNetworkComponent[speed]]')
        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= 10Mbps Hardware Firewall'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)
        call2.assert_called_once_with(id=1234, mask=mask)

        self.firewall.get_standard_package(server_id=1234, is_cci=False)
        call2 = self.client['Hardware_Server'].getObject
        mask = ('mask[primaryNetworkComponent[speed]]')
        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= 10Mbps Hardware Firewall'
                    }
                }
            }
        f.assert_called_twice_with(filter=_filter, id=0)
        call2.assert_called_once_with(id=1234, mask=mask)

    def test_get_dedicated_package_ha(self):
        # test dedicated HA firewalls
        self.firewall.get_dedicated_package(ha_enabled=True)
        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= Hardware Firewall (High Availability)'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)

    def test_get_dedicated_package_pkg(self):
        # test dedicated HA firewalls
        self.firewall.get_dedicated_package(ha_enabled=False)
        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= Hardware Firewall (Dedicated)'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)

    def test_cancel_firewall(self):
        # test standard firewalls
        fwl_id = 6327
        billing_item_id = 21370814
        result = self.firewall.cancel_firewall(fwl_id, dedicated=False)
        f = self.client['Billing_Item'].cancelService
        f.assert_called_once_with(id=billing_item_id)
        self.assertEqual(result, Billing_Item.cancelService)
        call = self.client['Network_Component_Firewall'].getObject
        MASK = ('mask[id,billingItem[id]]')
        call.assert_called_once_with(id=6327, mask=MASK)
        # test dedicated firewalls
        billing_item_id = 21370815
        result = self.firewall.cancel_firewall(fwl_id, dedicated=True)
        f = self.client['Billing_Item'].cancelService
        f.assert_called_twice_with(id=billing_item_id)
        self.assertEqual(result, Billing_Item.cancelService)
        call = self.client['Network_Vlan_Firewall'].getObject
        MASK = ('mask[id,billingItem[id]]')
        call.assert_called_once_with(id=6327, mask=MASK)

    def test_add_standard_firewall_cci(self):
        # test standard firewalls for CCI
        server_id = 6327
        self.firewall.add_standard_firewall(server_id, is_cci=True)
        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= 10Mbps Hardware Firewall'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)

        call2 = self.client['Virtual_Guest'].getObject
        mask = ('mask[primaryNetworkComponent[speed]]')
        call2.assert_called_once_with(id=6327, mask=mask)
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once()

    def test_add_standard_firewall_server(self):
        # test dedicated firewall for Servers
        server_id = 6327
        mask = ('mask[primaryNetworkComponent[speed]]')
        self.firewall.add_standard_firewall(server_id, is_cci=False)
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once()

        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= 10Mbps Hardware Firewall'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)

        call2 = self.client['Hardware_Server'].getObject
        call2.assert_called_once_with(id=6327, mask=mask)

    def test_add_vlan_firewall(self):
        # test dedicated firewall for Vlan
        vlan_id = 6327
        self.firewall.add_vlan_firewall(vlan_id, ha_enabled=False)
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once()

        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= Hardware Firewall (Dedicated)'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)

    def test_add_vlan_firewall_ha(self):
        # test dedicated firewall for Vlan
        vlan_id = 6327
        self.firewall.add_vlan_firewall(vlan_id, ha_enabled=True)
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once()

        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '_= Hardware Firewall (High Availability)'
                    }
                }
            }

        f.assert_called_once_with(filter=_filter, id=0)

    def test_edit_dedicated_fwl_rules(self):
        # test standard firewalls
        rules = Network_Vlan_Firewall.getRules
        fwl_id = 1234
        fwl_ctx_acl_id = 3142
        self.firewall.edit_dedicated_fwl_rules(firewall_id=fwl_id,
                                               rules=rules)
        template = {
            'firewallContextAccessControlListId': fwl_ctx_acl_id,
            'rules': rules
        }
        f = self.client['Network_Firewall_Update_Request'].createObject
        f.assert_called_once_with(template)

    def test_edit_standard_fwl_rules(self):
        # test standard firewalls
        rules = Network_Component_Firewall.getRules
        fwl_id = 1234
        self.firewall.edit_standard_fwl_rules(firewall_id=fwl_id,
                                              rules=rules)
        tempObject = {
            "networkComponentFirewallId": fwl_id,
            "rules": rules}
        f = self.client['Network_Firewall_Update_Request'].createObject

        f.assert_called_once_with(tempObject)

########NEW FILE########
__FILENAME__ = hardware_tests
"""
    SoftLayer.tests.managers.hardware_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import HardwareManager
from SoftLayer.managers.hardware import get_default_value
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import (
    Hardware_Server, Account, Billing_Item, Ticket)

from mock import ANY, call, patch


class HardwareTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.hardware = HardwareManager(self.client)

    def test_list_hardware(self):
        mcall = call(mask=ANY, filter={})

        results = self.hardware.list_hardware()
        self.client['Account'].getHardware.assert_has_calls(mcall)
        self.assertEqual(results, Account.getHardware)

    def test_list_hardware_with_filters(self):
        results = self.hardware.list_hardware(
            tags=['tag1', 'tag2'],
            cpus=2,
            memory=1,
            hostname='hostname',
            domain='example.com',
            datacenter='dal05',
            nic_speed=100,
            public_ip='1.2.3.4',
            private_ip='4.3.2.1',
        )
        self.client['Account'].getHardware.assert_has_calls(call(
            filter={
                'hardware': {
                    'datacenter': {'name': {'operation': '_= dal05'}},
                    'domain': {'operation': '_= example.com'},
                    'tagReferences': {
                        'tag': {'name': {
                            'operation': 'in',
                            'options': [
                                {'name': 'data', 'value': ['tag1', 'tag2']}]
                        }}
                    },
                    'memoryCapacity': {'operation': 1},
                    'processorPhysicalCoreAmount': {'operation': 2},
                    'hostname': {'operation': '_= hostname'},
                    'primaryIpAddress': {'operation': '_= 1.2.3.4'},
                    'networkComponents': {'maxSpeed': {'operation': 100}},
                    'primaryBackendIpAddress': {'operation': '_= 4.3.2.1'}}
            },
            mask=ANY,
        ))
        self.assertEqual(results, Account.getHardware)

    def test_resolve_ids_ip(self):
        _id = self.hardware._get_ids_from_ip('172.16.1.100')
        self.assertEqual(_id, [1000, 1001, 1002])

        _id = self.hardware._get_ids_from_ip('nope')
        self.assertEqual(_id, [])

        # Now simulate a private IP test
        self.client['Account'].getHardware.side_effect = [[], [{'id': 99}]]
        _id = self.hardware._get_ids_from_ip('10.0.1.87')
        self.assertEqual(_id, [99])

    def test_resolve_ids_hostname(self):
        _id = self.hardware._get_ids_from_hostname('hardware-test1')
        self.assertEqual(_id, [1000, 1001, 1002])

    def test_get_hardware(self):
        result = self.hardware.get_hardware(1000)

        self.client['Hardware_Server'].getObject.assert_called_once_with(
            id=1000, mask=ANY)
        self.assertEqual(Hardware_Server.getObject, result)

    def test_reload(self):
        post_uri = 'http://test.sftlyr.ws/test.sh'
        self.hardware.reload(1, post_uri=post_uri, ssh_keys=[1701])
        f = self.client['Hardware_Server'].reloadOperatingSystem
        f.assert_called_once_with('FORCE',
                                  {'customProvisionScriptUri': post_uri,
                                   'sshKeyIds': [1701]}, id=1)

    def test_get_bare_metal_create_options_returns_none_on_error(self):
        self.client['Product_Package'].getAllObjects.return_value = [
            {'name': 'No Matching Instances', 'id': 0}]

        self.assertIsNone(self.hardware.get_bare_metal_create_options())

    def test_get_bare_metal_create_options(self):
        package_id = 50
        self.hardware.get_bare_metal_create_options()

        f1 = self.client['Product_Package'].getRegions
        f1.assert_called_once_with(id=package_id)

        f2 = self.client['Product_Package'].getConfiguration
        f2.assert_called_once_with(id=package_id,
                                   mask='mask[itemCategory[group]]')

        f3 = self.client['Product_Package'].getCategories
        f3.assert_called_once_with(id=package_id)

    def test_generate_create_dict_with_all_bare_metal_options(self):
        args = {
            'server': 100,
            'hostname': 'unicorn',
            'domain': 'giggles.woo',
            'disks': [500],
            'location': 'Wyrmshire',
            'os': 200,
            'port_speed': 600,
            'bare_metal': True,
            'hourly': True,
            'public_vlan': 10234,
            'private_vlan': 20468,
        }

        expected = {
            'hardware': [
                {
                    'domain': 'giggles.woo',
                    'bareMetalInstanceFlag': True,
                    'hostname': 'unicorn',
                    'primaryBackendNetworkComponent':
                    {'networkVlan': {'id': 20468}},
                    'primaryNetworkComponent':
                    {'networkVlan': {'id': 10234}},
                }
            ],
            'prices': [
                {'id': 100},
                {'id': 500},
                {'id': 200},
                {'id': 600},
                {'id': 12000}
            ],
            'useHourlyPricing': True,
            'location': 'Wyrmshire', 'packageId': 50
        }

        data = self.hardware._generate_create_dict(**args)

        self.assertEqual(expected, data)

    def test_generate_create_dict_with_all_dedicated_server_options(self):
        args = {
            'server': 100,
            'hostname': 'unicorn',
            'domain': 'giggles.woo',
            'disks': [1000, 1000, 1000, 1000],
            'location': 'Wyrmshire',
            'os': 200,
            'port_speed': 600,
            'bare_metal': False,
            'package_id': 13,
            'ram': 1400,
            'disk_controller': 1500,
            'ssh_keys': [3000, 3001],
            'public_vlan': 10234,
            'private_vlan': 20468,
            'post_uri': 'http://somescript.foo/myscript.sh',
        }

        expected = {
            'hardware': [
                {
                    'domain': 'giggles.woo',
                    'bareMetalInstanceFlag': False,
                    'hostname': 'unicorn',
                    'primaryBackendNetworkComponent':
                    {'networkVlan': {'id': 20468}},
                    'primaryNetworkComponent':
                    {'networkVlan': {'id': 10234}},
                }
            ],
            'prices': [
                {'id': 100},
                {'id': 1000},
                {'id': 1000},
                {'id': 1000},
                {'id': 1000},
                {'id': 200},
                {'id': 600},
                {'id': 1400},
                {'id': 1500}],
            'sshKeys': [{'sshKeyIds': [3000, 3001]}],
            'location': 'Wyrmshire', 'packageId': 13,
            'provisionScripts': ['http://somescript.foo/myscript.sh'],
        }

        data = self.hardware._generate_create_dict(**args)
        self.assertEqual(expected, data)

    @patch('SoftLayer.managers.hardware.HardwareManager._generate_create_dict')
    def test_verify_order(self, create_dict):
        create_dict.return_value = {'test': 1, 'verify': 1}
        self.hardware.verify_order(test=1, verify=1)
        create_dict.assert_called_once_with(test=1, verify=1)
        f = self.client['Product_Order'].verifyOrder
        f.assert_called_once_with({'test': 1, 'verify': 1})

    @patch('SoftLayer.managers.hardware.HardwareManager._generate_create_dict')
    def test_place_order(self, create_dict):
        create_dict.return_value = {'test': 1, 'verify': 1}
        self.hardware.place_order(test=1, verify=1)
        create_dict.assert_called_once_with(test=1, verify=1)
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once_with({'test': 1, 'verify': 1})

    def test_cancel_metal_immediately(self):
        b_id = 6327

        result = self.hardware.cancel_metal(b_id, immediate=True)
        f = self.client['Billing_Item'].cancelService
        f.assert_called_once_with(id=b_id)
        self.assertEqual(result, Billing_Item.cancelService)

    def test_cancel_metal_on_anniversary(self):
        b_id = 6327

        result = self.hardware.cancel_metal(b_id, False)
        f = self.client['Billing_Item'].cancelServiceOnAnniversaryDate
        f.assert_called_once_with(id=b_id)
        self.assertEqual(result, Billing_Item.cancelServiceOnAnniversaryDate)

    def test_cancel_hardware_without_reason(self):
        hw_id = 987
        self.client['Hardware_Server'].getObject.return_value = {
            'id': hw_id,
            'bareMetalInstanceFlag': False,
        }
        result = self.hardware.cancel_hardware(hw_id)

        reasons = self.hardware.get_cancellation_reasons()
        f = self.client['Ticket'].createCancelServerTicket
        f.assert_called_once_with(hw_id, reasons['unneeded'], '', True,
                                  'HARDWARE')
        self.assertEqual(result, Ticket.createCancelServerTicket)

    def test_cancel_hardware_with_reason_and_comment(self):
        hw_id = 987
        reason = 'sales'
        comment = 'Test Comment'

        self.client['Hardware_Server'].getObject.return_value = {
            'id': hw_id,
            'bareMetalInstanceFlag': False,
        }

        self.hardware.cancel_hardware(hw_id, reason, comment)

        reasons = self.hardware.get_cancellation_reasons()

        f = self.client['Ticket'].createCancelServerTicket
        f.assert_called_once_with(hw_id, reasons[reason], comment, True,
                                  'HARDWARE')

    def test_cancel_hardware_on_bmc(self):
        hw_id = 6327

        result = self.hardware.cancel_hardware(hw_id)
        f = self.client['Billing_Item'].cancelServiceOnAnniversaryDate
        f.assert_called_once_with(id=hw_id)
        self.assertEqual(result, Billing_Item.cancelServiceOnAnniversaryDate)

    def test_change_port_speed_public(self):
        hw_id = 1
        speed = 100
        self.hardware.change_port_speed(hw_id, True, speed)

        f = self.client['Hardware_Server'].setPublicNetworkInterfaceSpeed
        f.assert_called_once_with(speed, id=hw_id)

    def test_change_port_speed_private(self):
        hw_id = 2
        speed = 10
        self.hardware.change_port_speed(hw_id, False, speed)

        f = self.client['Hardware_Server'].setPrivateNetworkInterfaceSpeed
        f.assert_called_once_with(speed, id=hw_id)

    def test_get_available_dedicated_server_packages(self):
        self.hardware.get_available_dedicated_server_packages()

        filter_mock = {
            'type': {
                'keyName': {
                    'operation': 'in',
                    'options': [{
                        'name': 'data',
                        'value': ['BARE_METAL_CPU', 'BARE_METAL_CORE']
                    }]
                }
            }
        }
        f = self.client['Product_Package'].getAllObjects
        f.assert_has_calls([call(mask='id,name,description,type',
                                 filter=filter_mock)])

    def test_get_dedicated_server_options(self):
        package_id = 13
        self.hardware.get_dedicated_server_create_options(package_id)

        f1 = self.client['Product_Package'].getRegions
        f1.assert_called_once_with(id=package_id)

        f2 = self.client['Product_Package'].getConfiguration
        f2.assert_called_once_with(id=package_id,
                                   mask='mask[itemCategory[group]]')

        f3 = self.client['Product_Package'].getCategories
        f3.assert_called_once_with(id=package_id)

    def test_get_default_value_returns_none_for_unknown_category(self):
        package_options = {'categories': ['Cat1', 'Cat2']}

        self.assertEqual(None, get_default_value(package_options,
                                                 'Unknown Category'))

    def test_get_default_value(self):
        price_id = 9876
        package_options = {'categories':
                           {'Cat1': {
                               'items': [{'setup_fee': 0,
                                          'recurring_fee': 0,
                                          'hourly_recurring_fee': 0,
                                          'one_time_fee': 0,
                                          'labor_fee': 0,
                                          'price_id': price_id}]
                           }}}

        self.assertEqual(price_id, get_default_value(package_options, 'Cat1'))

    def test_get_default_value_none_free(self):
        package_options = {'categories': {}}
        self.assertEqual(None, get_default_value(package_options, 'Cat1'))

        package_options = {'categories':
                           {'Cat1': {
                               'items': [{'setup_fee': 10,
                                          'recurring_fee': 0,
                                          'hourly_recurring_fee': 0,
                                          'one_time_fee': 0,
                                          'labor_fee': 0,
                                          'price_id': 1234}]
                           }}}
        self.assertEqual(None, get_default_value(package_options, 'Cat1'))

    def test_get_default_value_hourly(self):
        package_options = {'categories':
                           {'Cat1': {
                               'items': [{'setup_fee': 0,
                                          'recurring_fee': 0,
                                          'hourly_recurring_fee': None,
                                          'one_time_fee': 0,
                                          'labor_fee': 0,
                                          'price_id': 1234},
                                         {'setup_fee': 0,
                                          'recurring_fee': None,
                                          'hourly_recurring_fee': 0,
                                          'one_time_fee': 0,
                                          'labor_fee': 0,
                                          'price_id': 4321}]
                           }}}
        result = get_default_value(package_options, 'Cat1', hourly=True)
        self.assertEqual(4321, result)

    def test_get_default_value_monthly(self):
        package_options = {'categories':
                           {'Cat1': {
                               'items': [{'setup_fee': 0,
                                          'recurring_fee': None,
                                          'hourly_recurring_fee': 0,
                                          'one_time_fee': 0,
                                          'labor_fee': 0,
                                          'price_id': 4321},
                                         {'setup_fee': 0,
                                          'recurring_fee': 0,
                                          'hourly_recurring_fee': None,
                                          'one_time_fee': 0,
                                          'labor_fee': 0,
                                          'price_id': 1234}]
                           }}}
        result = get_default_value(package_options, 'Cat1', hourly=False)
        self.assertEqual(1234, result)

    def test_edit(self):
        # Test editing user data
        self.hardware.edit(100, userdata='my data')

        service = self.client['Hardware_Server']
        service.setUserMetadata.assert_called_once_with(['my data'], id=100)

        # Now test a blank edit
        self.assertTrue(self.hardware.edit, 100)

        # Finally, test a full edit
        args = {
            'hostname': 'new-host',
            'domain': 'new.sftlyr.ws',
            'notes': 'random notes',
        }

        self.hardware.edit(100, **args)
        service.editObject.assert_called_once_with(args, id=100)

########NEW FILE########
__FILENAME__ = image_tests
"""
    SoftLayer.tests.managers.image_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import ImageManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import (
    Virtual_Guest_Block_Device_Template_Group, Account)

from mock import ANY


class ImageTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.image = ImageManager(self.client)
        self.vgbdtg = self.client['Virtual_Guest_Block_Device_Template_Group']
        self.account = self.client['Account']

    def test_get_image(self):
        result = self.image.get_image(100)

        self.vgbdtg.getObject.assert_called_once_with(id=100, mask=ANY)
        self.assertEqual(result,
                         Virtual_Guest_Block_Device_Template_Group.getObject)

    def test_delete_image(self):
        self.image.delete_image(100)

        self.vgbdtg.deleteObject.assert_called_once_with(id=100)

    def test_list_private_images(self):
        results = self.image.list_private_images()

        f = self.account.getPrivateBlockDeviceTemplateGroups
        f.assert_called_once_with(filter={}, mask=ANY)
        self.assertEqual(results, Account.getPrivateBlockDeviceTemplateGroups)

    def test_list_private_images_with_filters(self):
        results = self.image.list_private_images(
            guid='0FA9ECBD-CF7E-4A1F-1E36F8D27C2B', name='name')

        f = self.account.getPrivateBlockDeviceTemplateGroups
        f.assert_called_once_with(
            filter={
                'privateBlockDeviceTemplateGroups': {
                    'globalIdentifier': {
                        'operation': '_= 0FA9ECBD-CF7E-4A1F-1E36F8D27C2B'},
                    'name': {'operation': '_= name'}}},
            mask=ANY)
        self.assertEqual(results, Account.getPrivateBlockDeviceTemplateGroups)

    def test_list_public_images(self):
        results = self.image.list_public_images()

        self.vgbdtg.getPublicImages.assert_called_once_with(filter={},
                                                            mask=ANY)
        self.assertEqual(
            results, Virtual_Guest_Block_Device_Template_Group.getPublicImages)

    def test_list_public_images_with_filters(self):
        results = self.image.list_public_images(
            guid='0FA9ECBD-CF7E-4A1F-1E36F8D27C2B', name='name')

        self.vgbdtg.getPublicImages.assert_called_once_with(
            filter={
                'globalIdentifier': {
                    'operation': '_= 0FA9ECBD-CF7E-4A1F-1E36F8D27C2B'},
                'name': {'operation': '_= name'}},
            mask=ANY)
        self.assertEqual(
            results, Virtual_Guest_Block_Device_Template_Group.getPublicImages)

    def test_resolve_ids_guid(self):
        result = self.image.resolve_ids('3C1F3C68-0B67-4F5E-8907-D0FC84BF3F12')

        self.assertEquals(['3C1F3C68-0B67-4F5E-8907-D0FC84BF3F12'], result)

    def test_resolve_ids_name_public(self):
        self.vgbdtg.getPublicImages.return_value = [{'id': 100}]
        self.account.getPrivateBlockDeviceTemplateGroups.return_value = []
        result = self.image.resolve_ids('image_name')

        self.assertEquals([100], result)

    def test_resolve_ids_name_private(self):
        self.vgbdtg.getPublicImages.return_value = []
        self.account.getPrivateBlockDeviceTemplateGroups.return_value = \
            [{'id': 100}]
        result = self.image.resolve_ids('private_image_name')

        self.assertEquals([100], result)

    def test_resolve_ids_not_found(self):
        self.vgbdtg.getPublicImages.return_value = []
        self.account.getPrivateBlockDeviceTemplateGroups.return_value = []
        result = self.image.resolve_ids('unknown_name')

        self.assertEquals([], result)

    def test_edit(self):
        # Test updating tags
        self.image.edit(1, tag="tag1,tag2")
        self.vgbdtg.setTags.assert_called_once_with("tag1,tag2", id=1)

        # Test a blank edit
        self.image.edit(1)
        self.assertTrue(self.image.edit, 1)

        # Finally test a full edit
        args = {
            'name': 'abc',
            'note': 'xyz'
        }
        self.image.edit(1, **args)
        self.vgbdtg.editObject.assert_called_once_with(args, id=1)

########NEW FILE########
__FILENAME__ = iscsi_tests
"""
    SoftLayer.tests.managers.iscsi_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import ISCSIManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Network_Storage_Iscsi
from mock import ANY


class ISCSITests(unittest.TestCase):
    def setUp(self):
        self.client = FixtureClient()
        self.iscsi = ISCSIManager(self.client)

    def test_get_iscsi(self):
        result = self.iscsi.get_iscsi(100)
        self.client['Network_Storage_Iscsi'].getObject.assert_called_once_with(
            id=100, mask=ANY)
        self.assertEqual(Network_Storage_Iscsi.getObject, result)

    def test_cancel_iscsi_immediately(self):
        iscsi_id = 600
        self.iscsi.cancel_iscsi(iscsi_id, immediate=True)
        f = self.client['Billing_Item'].cancelItem
        f.assert_called_once_with(True, True, 'unNeeded', id=iscsi_id)

    def test_cancel_iscsi_without_reason(self):
        iscsi_id = 600
        self.iscsi.cancel_iscsi(iscsi_id)
        f = self.client['Billing_Item'].cancelItem
        f.assert_called_once_with(False, True, 'unNeeded', id=iscsi_id)

    def test_cancel_iscsi_with_reason(self):
        iscsi_id = 600
        reason = 'Network Performance'
        self.iscsi.cancel_iscsi(iscsi_id, reason)
        f = self.client['Billing_Item'].cancelItem
        f.assert_called_once_with(False, True, reason, id=iscsi_id)

    def test_invalid_datacenter(self):
        self.assertRaises(ValueError,
                          self.iscsi.create_iscsi,
                          size=10, location='foo')

    def test_create_iscsi(self):
        getItems = self.client['Product_Package'].getItems
        getItems.return_value = [
            {
                'id': 4439,
                'capacity': '1',
                'description': '1 GB iSCSI Storage',
                'itemCategory': {'categoryCode': 'iscsi'},
                'prices': [{'id': 2222}]
            }]
        self.iscsi.create_iscsi(size=1, location='dal05')
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once_with(
            {'prices': [{'id': 2222}],
             'quantity': 1,
             'location': 0,
             'packageId': 0,
             'complexType':
             'SoftLayer_Container_Product_Order_Network_Storage_Iscsi'})

    def test_delete_snapshot(self):
        self.iscsi.delete_snapshot(1)
        self.client[
            'Network_Storage_Iscsi'].deleteObject.assert_called_once_with(id=1)

    def test_create_snapshot(self):
        iscsi_id = 100
        self.iscsi.create_snapshot(iscsi_id, 'unNeeded')
        f = self.client['Network_Storage_Iscsi'].createSnapshot
        f.assert_called_once_with('unNeeded', id=iscsi_id)

    def test_create_snapshot_space(self):
        getItems = self.client['Product_Package'].getItems
        getItems.return_value = [
            {
                'id': 1121,
                'capacity': '20',
                'description': '20 GB iSCSI snapshot',
                'itemCategory': {'categoryCode': 'iscsi_snapshot_space'},
                'prices': [{'id': 2014}]
            }]
        iscsi_id = 100
        capacity = 20
        self.iscsi.create_snapshot_space(iscsi_id, capacity)
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once_with(
            {'volumeId': 100,
             'location': 138124,
             'packageId': 0,
             'complexType':
             'SoftLayer_Container_\
Product_Order_Network_Storage_Iscsi_SnapshotSpace',
             'prices': [{'id': 2014}],
             'quantity': 1
             })

    def test_restore_from_snapshot(self):
        volume_id = 100
        snapshot_id = 101
        self.iscsi.restore_from_snapshot(volume_id, snapshot_id)
        f = self.client['Network_Storage_Iscsi'].restoreFromSnapshot
        f.assert_called_once_with(101, id=100)

########NEW FILE########
__FILENAME__ = loadbal_tests
"""
    SoftLayer.tests.managers.loadbal_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import LoadBalancerManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Billing_Item


class LoadBalancerTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.lb_mgr = LoadBalancerManager(self.client)

    def test_get_lb_pkgs(self):
        self.lb_mgr.get_lb_pkgs()
        f = self.client['Product_Package'].getItems
        _filter = {
            'items': {
                'description': {
                    'operation': '*= Load Balancer'
                    }
                }
            }
        f.assert_called_once_with(filter=_filter, id=0)

    def test_get_ip_address(self):
        self.lb_mgr.get_ip_address()
        f = self.client['Network_Subnet_IpAddress'].getByIpAddress
        f.assert_called_once()

    def test_get_hc_types(self):
        self.lb_mgr.get_hc_types()
        f = self.client['Network_Application_Delivery_Controller_'
                        'LoadBalancer_Health_Check_Type'].getAllObjects
        f.assert_called_once()

    def test_get_routing_methods(self):
        self.lb_mgr.get_routing_methods()
        f = self.client['Network_Application_Delivery_Controller_'
                        'LoadBalancer_Routing_Method'].getAllObjects
        f.assert_called_once()

    def test_get_location(self):
        id1 = self.lb_mgr.get_location('sjc01')
        f = self.client['Location'].getDataCenters
        f.assert_called_once()
        self.assertEqual(id1, 168642)

        id2 = self.lb_mgr.get_location('dal05')
        f = self.client['Location'].getDataCenters
        f.assert_called_once()
        self.assertEqual(id2, 'FIRST_AVAILABLE')

    def test_get_routing_types(self):
        self.lb_mgr.get_routing_types()
        f = self.client['Network_Application_Delivery_Controller_'
                        'LoadBalancer_Routing_Type'].getAllObjects
        f.assert_called_once()

    def test_cancel_lb(self):
        loadbal_id = 6327
        billing_item_id = 21370814
        result = self.lb_mgr.cancel_lb(loadbal_id)
        f = self.client['Billing_Item'].cancelService
        f.assert_called_once_with(id=billing_item_id)
        self.assertEqual(result, Billing_Item.cancelService)

    def test_add_local_lb(self):
        price_id = 6327
        datacenter = 'sjc01'
        self.lb_mgr.add_local_lb(price_id, datacenter)

        _package = {
            'complexType': 'SoftLayer_Container_Product_Order_Network_'
                           'LoadBalancer',
            'quantity': 1,
            'packageId': 0,
            "location": 168642,
            'prices': [{'id': price_id}]
        }
        f = self.client['Product_Order'].placeOrder
        f.assert_called_once_with(_package)

    def test_get_local_lbs(self):
        self.lb_mgr.get_local_lbs()
        call = self.client['Account'].getAdcLoadBalancers
        mask = ('mask[loadBalancerHardware[datacenter],ipAddress]')
        call.assert_called_once_with(mask=mask)

    def test_get_local_lb(self):
        lb_id = 12345
        self.lb_mgr.get_local_lb(lb_id)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].getObject

        mask = ('mask[loadBalancerHardware[datacenter], '
                'ipAddress, virtualServers[serviceGroups'
                '[routingMethod,routingType,services'
                '[healthChecks[type], groupReferences,'
                ' ipAddress]]]]')
        call.assert_called_once_with(id=lb_id, mask=mask)

    def test_delete_service(self):
        service_id = 1234
        self.lb_mgr.delete_service(service_id)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_Service'].deleteObject

        call.assert_called_once_with(id=service_id)

    def test_delete_service_group(self):
        service_group = 1234
        self.lb_mgr.delete_service_group(service_group)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualServer'].deleteObject

        call.assert_called_once_with(id=service_group)

    def test_toggle_service_status(self):
        service_id = 1234
        self.lb_mgr.toggle_service_status(service_id)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_Service'].toggleStatus

        call.assert_called_once_with(id=service_id)

    def test_edit_service(self):
        loadbal_id = 12345
        service_id = 1234
        ip_address = '9.9.9.9'
        port = 80
        enabled = 1
        hc_type = 21
        weight = 1
        self.lb_mgr.edit_service(loadbal_id, service_id, ip_address,
                                 port, enabled, hc_type, weight)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].getVirtualServers
        _filter = {
            'virtualServers': {
                'serviceGroups': {
                    'services': {
                        'id': {
                            'operation': 1234
                            }
                        }
                    }
                }
            }
        mask = 'mask[serviceGroups[services[groupReferences,healthChecks]]]'
        call.assert_called_once_with(filter=_filter, mask=mask, id=loadbal_id)

        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].editObject
        call.assert_called_once()

    def test_add_service(self):
        loadbal_id = 12345
        group_id = 50718
        ip_address_id = 123
        port = 80
        enabled = 1
        hc_type = 21
        weight = 1
        self.lb_mgr.add_service(loadbal_id, group_id, ip_address_id,
                                port, enabled, hc_type, weight)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].getObject

        mask = ('mask[virtualServers[serviceGroups'
                '[services[groupReferences]]]]')
        call.assert_called_once_with(mask=mask, id=loadbal_id)

        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].editObject
        call.assert_called_once()

    def test_edit_service_group(self):
        loadbal_id = 12345
        group_id = 50718
        allocation = 100
        port = 80
        routing_type = 2
        routing_method = 10
        self.lb_mgr.edit_service_group(loadbal_id, group_id=group_id,
                                       allocation=allocation,
                                       port=port,
                                       routing_type=routing_type,
                                       routing_method=routing_method)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].getObject

        mask = ('mask[virtualServers[serviceGroups'
                '[services[groupReferences]]]]')
        call.assert_called_once_with(mask=mask, id=loadbal_id)

        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].editObject
        call.assert_called_once()

    def test_add_service_group(self):
        loadbal_id = 12345
        allocation = 100
        port = 80
        routing_type = 2
        routing_method = 10
        self.lb_mgr.add_service_group(loadbal_id, allocation, port,
                                      routing_type, routing_method)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].getObject

        mask = ('mask[virtualServers[serviceGroups'
                '[services[groupReferences]]]]')
        call.assert_called_once_with(mask=mask, id=loadbal_id)

        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].editObject
        call.assert_called_once()

    def test_reset_service_group(self):
        loadbal_id = 12345
        group_id = 50718
        self.lb_mgr.reset_service_group(loadbal_id, group_id=group_id)
        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_VirtualIpAddress'].getVirtualServers

        _filter = {'virtualServers': {'id': {'operation': group_id}}}
        mask = 'mask[serviceGroups]'
        call.assert_called_once_with(filter=_filter, mask=mask, id=loadbal_id)

        call = self.client['Network_Application_Delivery_Controller_'
                           'LoadBalancer_Service_Group'].kickAllConnections
        call.assert_called_once_with(id=51758)

########NEW FILE########
__FILENAME__ = metadata_tests
"""
    SoftLayer.tests.managers.metadata_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import MetadataManager, SoftLayerError, SoftLayerAPIError
from SoftLayer.consts import API_PRIVATE_ENDPOINT_REST, USER_AGENT
from SoftLayer.tests import unittest

from mock import patch, MagicMock


class MetadataTests(unittest.TestCase):

    def setUp(self):
        self.metadata = MetadataManager()
        self.make_request = MagicMock()
        self.metadata.make_request = self.make_request

    def test_no_param(self):
        self.make_request.return_value = 'dal01'
        r = self.metadata.get('datacenter')
        self.make_request.assert_called_with("Datacenter.json")
        self.assertEqual('dal01', r)

    def test_w_param(self):
        self.make_request.return_value = [123]
        r = self.metadata.get('vlans', '1:2:3:4:5')
        self.make_request.assert_called_with("Vlans/1:2:3:4:5.json")
        self.assertEqual([123], r)

    def test_user_data(self):
        self.make_request.return_value = 'user_data'
        r = self.metadata.get('user_data')
        self.make_request.assert_called_with("UserMetadata.txt")
        self.assertEqual('user_data', r)

    def test_return_none(self):
        self.make_request.return_value = None
        r = self.metadata.get('datacenter')
        self.make_request.assert_called_with("Datacenter.json")
        self.assertEqual(None, r)

    def test_w_param_error(self):
        self.assertRaises(SoftLayerError, self.metadata.get, 'vlans')

    def test_not_exists(self):
        self.assertRaises(SoftLayerError, self.metadata.get, 'something')

    def test_networks_not_exist(self):
        self.make_request.return_value = []
        r = self.metadata.public_network()
        self.assertEqual({'mac_addresses': []}, r)

    def test_networks(self):
        resp = ['list', 'of', 'stuff']
        self.make_request.return_value = resp
        r = self.metadata.public_network()
        self.assertEqual({
            'vlan_ids': resp,
            'router': resp,
            'vlans': resp,
            'mac_addresses': resp
        }, r)

        r = self.metadata.private_network()
        self.assertEqual({
            'vlan_ids': resp,
            'router': resp,
            'vlans': resp,
            'mac_addresses': resp
        }, r)


class MetadataTestsMakeRequest(unittest.TestCase):

    def setUp(self):
        self.metadata = MetadataManager()
        self.url = '/'.join([
            API_PRIVATE_ENDPOINT_REST.rstrip('/'),
            'SoftLayer_Resource_Metadata',
            'something.json'])

    @patch('SoftLayer.managers.metadata.make_rest_api_call')
    def test_basic(self, make_api_call):
        r = self.metadata.make_request('something.json')
        make_api_call.assert_called_with(
            'GET', self.url,
            timeout=5,
            http_headers={'User-Agent': USER_AGENT})
        self.assertEqual(make_api_call(), r)

    @patch('SoftLayer.managers.metadata.make_rest_api_call')
    def test_raise_error(self, make_api_call):
        make_api_call.side_effect = SoftLayerAPIError(
            'faultCode', 'faultString')
        self.assertRaises(
            SoftLayerAPIError,
            self.metadata.make_request, 'something.json')

    @patch('SoftLayer.managers.metadata.make_rest_api_call')
    def test_raise_404_error(self, make_api_call):
        make_api_call.side_effect = SoftLayerAPIError(404, 'faultString')
        r = self.metadata.make_request('something.json')
        self.assertEqual(r, None)

########NEW FILE########
__FILENAME__ = network_tests
"""
    SoftLayer.tests.managers.network_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import NetworkManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Product_Order

from mock import ANY, call


class NetworkTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.network = NetworkManager(self.client)

    def test_ip_lookup(self):
        service = self.client['Network_Subnet_IpAddress']

        self.network.ip_lookup('10.0.1.37')
        service.getByIpAddress.assert_called_with('10.0.1.37', mask=ANY)

    def test_add_subnet_raises_exception_on_failure(self):
        self.assertRaises(TypeError, self.network.add_subnet, ('bad'))

    def test_add_global_ip(self):
        # Test a global IPv4 order
        result = self.network.add_global_ip(test_order=True)

        self.assertEqual(Product_Order.verifyOrder, result)

    def test_add_subnet_for_ipv4(self):
        # Test a four public address IPv4 order
        result = self.network.add_subnet('public',
                                         quantity=4,
                                         vlan_id=1234,
                                         version=4,
                                         test_order=True)

        self.assertEqual(Product_Order.verifyOrder, result)

        result = self.network.add_subnet('public',
                                         quantity=4,
                                         vlan_id=1234,
                                         version=4,
                                         test_order=False)

        self.assertEqual(Product_Order.verifyOrder, result)

        result = self.network.add_subnet('global',
                                         test_order=True)

        self.assertEqual(Product_Order.verifyOrder, result)

    def test_add_subnet_for_ipv6(self):
        # Test a public IPv6 order
        result = self.network.add_subnet('public',
                                         quantity=64,
                                         vlan_id=45678,
                                         version=6,
                                         test_order=True)

        self.assertEqual(Product_Order.verifyOrder, result)

        # Test a global IPv6 order
        result = self.network.add_subnet('global',
                                         version=6,
                                         test_order=True)

        self.assertEqual(Product_Order.verifyOrder, result)

    def test_assign_global_ip(self):
        self.network.assign_global_ip(9876, '172.16.24.76')

        service = self.client['Network_Subnet_IpAddress_Global']
        service.route.assert_called_with('172.16.24.76', id=9876)

    def test_cancel_global_ip(self):
        self.network.cancel_global_ip(1234)

        service = self.client['Billing_Item']
        service.cancelService.assert_called_with(id=1234)

    def test_cancel_subnet(self):
        self.network.cancel_subnet(1234)

        service = self.client['Billing_Item']
        service.cancelService.assert_called_with(id=1056)

    def test_edit_rwhois(self):
        self.network.edit_rwhois(
            abuse_email='abuse@test.foo',
            address1='123 Test Street',
            address2='Apt. #31',
            city='Anywhere',
            company_name='TestLayer',
            country='US',
            first_name='Bob',
            last_name='Bobinson',
            postal_code='9ba62',
            private_residence=False,
            state='TX')

        expected = {
            'abuseEmail': 'abuse@test.foo',
            'address1': '123 Test Street',
            'address2': 'Apt. #31',
            'city': 'Anywhere',
            'companyName': 'TestLayer',
            'country': 'US',
            'firstName': 'Bob',
            'lastName': 'Bobinson',
            'postalCode': '9ba62',
            'privateResidenceFlag': False,
            'state': 'TX',
        }
        f = self.client['Network_Subnet_Rwhois_Data'].editObject
        f.assert_called_with(expected, id='id')

    def test_get_rwhois(self):
        self.network.get_rwhois()
        self.client['Account'].getRwhoisData.assert_called()

    def test_get_subnet(self):
        mcall = call(id=9876, mask=ANY)
        service = self.client['Network_Subnet']

        self.network.get_subnet(9876)
        service.getObject.assert_has_calls(mcall)

    def test_get_vlan(self):
        service = self.client['Network_Vlan']

        self.network.get_vlan(1234)
        service.getObject.assert_has_calls(call(id=1234, mask=ANY))

    def test_list_global_ips_default(self):
        self.network.list_global_ips()

        mask = 'destinationIpAddress[hardware, virtualGuest],ipAddress'
        service = self.client['Account']
        service.getGlobalIpRecords.assert_has_calls(call(filter={}, mask=mask))

    def test_list_global_ips_with_filter(self):
        self.network.list_global_ips(version=4)

        mask = 'destinationIpAddress[hardware, virtualGuest],ipAddress'
        _filter = {
            'globalIpRecords': {
                'ipAddress': {
                    'subnet': {
                        'version': {'operation': 4},
                    }
                }
            }
        }
        service = self.client['Account']
        service.getGlobalIpRecords.assert_has_calls(call(filter=_filter,
                                                         mask=mask))

    def test_list_subnets_default(self):
        _filter = {'subnets': {'subnetType': {'operation': '!= GLOBAL_IP'}}}
        mask = 'hardware,datacenter,ipAddressCount,virtualGuests'
        service = self.client['Account']

        self.network.list_subnets()

        service.getSubnets.assert_has_calls(call(filter=_filter, mask=mask))

    def test_list_subnets_with_filters(self):
        result = self.network.list_subnets(
            identifier='10.0.0.1',
            datacenter='dal00',
            subnet_type='PRIMARY',
            version=4,
        )

        _filter = {
            'subnets': {
                'datacenter': {
                    'name': {'operation': '_= dal00'}
                },
                'version': {'operation': 4},
                'subnetType': {'operation': '_= PRIMARY'},
                'networkIdentifier': {'operation': '_= 10.0.0.1'}
            }
        }
        mask = 'hardware,datacenter,ipAddressCount,virtualGuests'
        self.client['Account'].getSubnets.assert_called_with(filter=_filter,
                                                             mask=mask)
        self.assertEqual(self.client['Account'].getSubnets.return_value,
                         result)

    def test_list_vlans_default(self):
        service = self.client['Account']

        self.network.list_vlans()
        service.getNetworkVlans.assert_has_calls(call(filter={}, mask=ANY))

    def test_list_vlans_with_filters(self):
        self.network.list_vlans(
            vlan_number=5,
            datacenter='dal00',
            name='primary-vlan',
        )

        service = self.client['Account']
        service.getNetworkVlans.assert_has_calls(call(
            filter={
                'networkVlans': {
                    'primaryRouter': {
                        'datacenter': {
                            'name': {'operation': '_= dal00'}},
                    },
                    'vlanNumber': {'operation': 5},
                    'name': {'operation': '_= primary-vlan'},
                },
            },
            mask=ANY
        ))

    def test_summary_by_datacenter(self):
        result = self.network.summary_by_datacenter()

        expected = {
            'dal00': {
                'hardwareCount': 1,
                'networkingCount': 1,
                'primaryIpCount': 3,
                'subnetCount': 0,
                'virtualGuestCount': 1,
                'vlanCount': 1
            }}
        self.assertEqual(expected, result)

    def test_resolve_global_ip_ids(self):
        service = self.client['Account']
        _id = self.network.resolve_global_ip_ids('10.0.0.1')
        self.assertEqual(_id, ['200', '201'])

        service.getGlobalIpRecords.return_value = []
        _id = self.network.resolve_global_ip_ids('nope')
        self.assertEqual(_id, [])

    def test_resolve_subnet_ids(self):
        service = self.client['Account']

        _id = self.network.resolve_subnet_ids('10.0.0.1/29')
        self.assertEqual(_id, ['100'])

        service.getSubnets.return_value = []
        _id = self.network.resolve_subnet_ids('nope')
        self.assertEqual(_id, [])

    def test_resolve_vlan_ids(self):
        service = self.client['Account']
        service.getNetworkVlans.side_effect = [[{'id': '100'}], []]

        _id = self.network.resolve_vlan_ids('vlan_name')
        self.assertEqual(_id, ['100'])

        _id = self.network.resolve_vlan_ids('nope')
        self.assertEqual(_id, [])

    def test_unassign_global_ip(self):
        self.network.unassign_global_ip(9876)

        service = self.client['Network_Subnet_IpAddress_Global']
        service.unroute.assert_called_with(id=9876)

########NEW FILE########
__FILENAME__ = queue_tests
"""
    SoftLayer.tests.managers.queue_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import MessagingManager, Unauthenticated, SoftLayerError
from SoftLayer.consts import USER_AGENT
from SoftLayer.tests import unittest
import SoftLayer.managers.messaging

from mock import MagicMock, patch, ANY

QUEUE_1 = {
    'expiration': 40000,
    'message_count': 0,
    'name': 'example_queue',
    'tags': ['tag1', 'tag2', 'tag3'],
    'visibility_interval': 10,
    'visible_message_count': 0}
QUEUE_LIST = {'item_count': 1, 'items': [QUEUE_1]}
MESSAGE_1 = {
    'body': '<body>',
    'fields': {'field': 'value'},
    'id': 'd344a01133b61181f57d9950a852eb10',
    'initial_entry_time': 1343402631.3917992,
    'message': 'Object created',
    'visibility_delay': 0,
    'visibility_interval': 30000}
MESSAGE_POP = {
    'item_count': 1,
    'items': [MESSAGE_1],
}
MESSAGE_POP_EMPTY = {
    'item_count': 0,
    'items': []
}

TOPIC_1 = {'name': 'example_topic', 'tags': ['tag1', 'tag2', 'tag3']}
TOPIC_LIST = {'item_count': 1, 'items': [TOPIC_1]}
SUBSCRIPTION_1 = {
    'endpoint': {
        'account_id': 'test',
        'queue_name': 'topic_subscription_queue'},
    'endpoint_type': 'queue',
    'id': 'd344a01133b61181f57d9950a85704d4',
    'message': 'Object created'}
SUBSCRIPTION_LIST = {'item_count': 1, 'items': [SUBSCRIPTION_1]}


def mocked_auth_call(self):
    self.auth_token = 'NEW_AUTH_TOKEN'


class QueueAuthTests(unittest.TestCase):
    def setUp(self):
        self.auth = SoftLayer.managers.messaging.QueueAuth(
            'endpoint', 'username', 'api_key', auth_token='auth_token')

    def test_init(self):
        auth = SoftLayer.managers.messaging.QueueAuth(
            'endpoint', 'username', 'api_key', auth_token='auth_token')
        self.assertEqual(auth.endpoint, 'endpoint')
        self.assertEqual(auth.username, 'username')
        self.assertEqual(auth.api_key, 'api_key')
        self.assertEqual(auth.auth_token, 'auth_token')

    @patch('SoftLayer.managers.messaging.requests.post')
    def test_auth(self, post):
        post().headers = {'X-Auth-Token': 'NEW_AUTH_TOKEN'}
        post().ok = True
        self.auth.auth()
        self.auth.auth_token = 'NEW_AUTH_TOKEN'

        post().ok = False
        self.assertRaises(Unauthenticated, self.auth.auth)

    @patch('SoftLayer.managers.messaging.QueueAuth.auth', mocked_auth_call)
    def test_handle_error_200(self):
        # No op on no error
        request = MagicMock()
        request.status_code = 200
        self.auth.handle_error(request)

        self.assertEqual(self.auth.auth_token, 'auth_token')
        self.assertFalse(request.request.send.called)

    @patch('SoftLayer.managers.messaging.QueueAuth.auth', mocked_auth_call)
    def test_handle_error_503(self):
        # Retry once more on 503 error
        request = MagicMock()
        request.status_code = 503
        self.auth.handle_error(request)

        self.assertEqual(self.auth.auth_token, 'auth_token')
        request.connection.send.assert_called_with(request.request)

    @patch('SoftLayer.managers.messaging.QueueAuth.auth', mocked_auth_call)
    def test_handle_error_401(self):
        # Re-auth on 401
        request = MagicMock()
        request.status_code = 401
        request.request.headers = {'X-Auth-Token': 'OLD_AUTH_TOKEN'}
        self.auth.handle_error(request)

        self.assertEqual(self.auth.auth_token, 'NEW_AUTH_TOKEN')
        request.connection.send.assert_called_with(request.request)

    @patch('SoftLayer.managers.messaging.QueueAuth.auth', mocked_auth_call)
    def test_call_unauthed(self):
        request = MagicMock()
        request.headers = {}
        self.auth.auth_token = None
        self.auth(request)

        self.assertEqual(self.auth.auth_token, 'NEW_AUTH_TOKEN')
        request.register_hook.assert_called_with(
            'response', self.auth.handle_error)
        self.assertEqual(request.headers, {'X-Auth-Token': 'NEW_AUTH_TOKEN'})


class MessagingManagerTests(unittest.TestCase):

    def setUp(self):
        self.client = MagicMock()
        self.manager = MessagingManager(self.client)

    def test_list_accounts(self):
        self.manager.list_accounts()
        self.client['Account'].getMessageQueueAccounts.assert_called_with(
            mask=ANY)

    def test_get_endpoints(self):
        endpoints = self.manager.get_endpoints()
        self.assertEqual(endpoints, SoftLayer.managers.messaging.ENDPOINTS)

    @patch('SoftLayer.managers.messaging.ENDPOINTS', {
        'datacenter01': {
            'private': 'private_endpoint', 'public': 'public_endpoint'},
        'dal05': {
            'private': 'dal05_private', 'public': 'dal05_public'}})
    def test_get_endpoint(self):
        # Defaults to dal05, public
        endpoint = self.manager.get_endpoint()
        self.assertEqual(endpoint, 'https://dal05_public')

        endpoint = self.manager.get_endpoint(network='private')
        self.assertEqual(endpoint, 'https://dal05_private')

        endpoint = self.manager.get_endpoint(datacenter='datacenter01')
        self.assertEqual(endpoint, 'https://public_endpoint')

        endpoint = self.manager.get_endpoint(datacenter='datacenter01',
                                             network='private')
        self.assertEqual(endpoint, 'https://private_endpoint')

        endpoint = self.manager.get_endpoint(datacenter='datacenter01',
                                             network='private')
        self.assertEqual(endpoint, 'https://private_endpoint')

        # ERROR CASES
        self.assertRaises(
            TypeError,
            self.manager.get_endpoint, datacenter='doesnotexist')

        self.assertRaises(
            TypeError,
            self.manager.get_endpoint, network='doesnotexist')

    @patch('SoftLayer.managers.messaging.MessagingConnection')
    def test_get_connection(self, conn):
        queue_conn = self.manager.get_connection('QUEUE_ACCOUNT_ID')
        conn.assert_called_with(
            'QUEUE_ACCOUNT_ID', endpoint='https://dal05.mq.softlayer.net')
        conn().authenticate.assert_called_with(
            self.client.auth.username, self.client.auth.api_key)
        self.assertEqual(queue_conn, conn())

    def test_get_connection_no_auth(self):
        self.client.auth = None
        self.assertRaises(SoftLayerError,
                          self.manager.get_connection, 'QUEUE_ACCOUNT_ID')

    def test_get_connection_no_username(self):
        self.client.auth.username = None
        self.assertRaises(SoftLayerError,
                          self.manager.get_connection, 'QUEUE_ACCOUNT_ID')

    def test_get_connection_no_api_key(self):
        self.client.auth.api_key = None
        self.assertRaises(SoftLayerError,
                          self.manager.get_connection, 'QUEUE_ACCOUNT_ID')

    @patch('SoftLayer.managers.messaging.requests.get')
    def test_ping(self, get):
        result = self.manager.ping()

        get.assert_called_with('https://dal05.mq.softlayer.net/v1/ping')
        get().raise_for_status.assert_called_with()
        self.assertTrue(result)


class MessagingConnectionTests(unittest.TestCase):

    def setUp(self):
        self.conn = SoftLayer.managers.messaging.MessagingConnection(
            'acount_id', endpoint='endpoint')
        self.auth = MagicMock()
        self.conn.auth = self.auth

    def test_init(self):
        self.assertEqual(self.conn.account_id, 'acount_id')
        self.assertEqual(self.conn.endpoint, 'endpoint')
        self.assertEqual(self.conn.auth, self.auth)

    @patch('SoftLayer.managers.messaging.requests.request')
    def test_make_request(self, request):
        resp = self.conn._make_request('GET', 'path')
        request.assert_called_with(
            'GET', 'endpoint/v1/acount_id/path',
            headers={
                'Content-Type': 'application/json',
                'User-Agent': USER_AGENT},
            auth=self.auth)
        request().raise_for_status.assert_called_with()
        self.assertEqual(resp, request())

    @patch('SoftLayer.managers.messaging.QueueAuth')
    def test_authenticate(self, auth):
        self.conn.authenticate('username', 'api_key', auth_token='auth_token')

        auth.assert_called_with(
            'endpoint/v1/acount_id/auth', 'username', 'api_key',
            auth_token='auth_token')
        auth().auth.assert_called_with()
        self.assertEqual(self.conn.auth, auth())

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_stats(self, make_request):
        content = {
            'notifications': [{'key': [2012, 7, 27, 14, 31], 'value': 2}],
            'requests': [{'key': [2012, 7, 27, 14, 31], 'value': 11}]}
        make_request().json.return_value = content
        result = self.conn.stats()

        make_request.assert_called_with('get', 'stats/hour')
        self.assertEqual(content, result)

    # Queue-based Tests
    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_get_queues(self, make_request):
        make_request().json.return_value = QUEUE_LIST
        result = self.conn.get_queues()

        make_request.assert_called_with('get', 'queues', params={})
        self.assertEqual(QUEUE_LIST, result)

        # with tags
        result = self.conn.get_queues(tags=['tag1', 'tag2'])

        make_request.assert_called_with(
            'get', 'queues', params={'tags': 'tag1,tag2'})
        self.assertEqual(QUEUE_LIST, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_create_queue(self, make_request):
        make_request().json.return_value = QUEUE_1
        result = self.conn.create_queue('example_queue')

        make_request.assert_called_with(
            'put', 'queues/example_queue', data='{}')
        self.assertEqual(QUEUE_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_modify_queue(self, make_request):
        make_request().json.return_value = QUEUE_1
        result = self.conn.modify_queue('example_queue')

        make_request.assert_called_with(
            'put', 'queues/example_queue', data='{}')
        self.assertEqual(QUEUE_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_get_queue(self, make_request):
        make_request().json.return_value = QUEUE_1
        result = self.conn.get_queue('example_queue')

        make_request.assert_called_with('get', 'queues/example_queue')
        self.assertEqual(QUEUE_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_delete_queue(self, make_request):
        result = self.conn.delete_queue('example_queue')
        make_request.assert_called_with(
            'delete', 'queues/example_queue', params={})
        self.assertTrue(result)

        # With Force
        result = self.conn.delete_queue('example_queue', force=True)
        make_request.assert_called_with(
            'delete', 'queues/example_queue', params={'force': 1})
        self.assertTrue(result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_push_queue_message(self, make_request):
        make_request().json.return_value = MESSAGE_1
        result = self.conn.push_queue_message('example_queue', '<body>')

        make_request.assert_called_with(
            'post', 'queues/example_queue/messages', data='{"body": "<body>"}')
        self.assertEqual(MESSAGE_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_pop_messages(self, make_request):
        make_request().json.return_value = MESSAGE_POP
        result = self.conn.pop_messages('example_queue')

        make_request.assert_called_with(
            'get', 'queues/example_queue/messages', params={'batch': 1})
        self.assertEqual(MESSAGE_POP, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_pop_message(self, make_request):
        make_request().json.return_value = MESSAGE_POP
        result = self.conn.pop_message('example_queue')

        make_request.assert_called_with(
            'get', 'queues/example_queue/messages', params={'batch': 1})
        self.assertEqual(MESSAGE_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_pop_message_empty(self, make_request):
        make_request().json.return_value = MESSAGE_POP_EMPTY
        result = self.conn.pop_message('example_queue')

        make_request.assert_called_with(
            'get', 'queues/example_queue/messages', params={'batch': 1})
        self.assertEqual(None, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_delete_message(self, make_request):
        result = self.conn.delete_message('example_queue', MESSAGE_1['id'])

        make_request.assert_called_with(
            'delete', 'queues/example_queue/messages/%s' % MESSAGE_1['id'])
        self.assertTrue(result)

    # Topic-based Tests
    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_get_topics(self, make_request):
        make_request().json.return_value = TOPIC_LIST
        result = self.conn.get_topics()

        make_request.assert_called_with('get', 'topics', params={})
        self.assertEqual(TOPIC_LIST, result)

        # with tags
        result = self.conn.get_topics(tags=['tag1', 'tag2'])

        make_request.assert_called_with(
            'get', 'topics', params={'tags': 'tag1,tag2'})
        self.assertEqual(TOPIC_LIST, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_create_topic(self, make_request):
        make_request().json.return_value = TOPIC_1
        result = self.conn.create_topic('example_topic')

        make_request.assert_called_with(
            'put', 'topics/example_topic', data='{}')
        self.assertEqual(TOPIC_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_modify_topic(self, make_request):
        make_request().json.return_value = TOPIC_1
        result = self.conn.modify_topic('example_topic')

        make_request.assert_called_with(
            'put', 'topics/example_topic', data='{}')
        self.assertEqual(TOPIC_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_get_topic(self, make_request):
        make_request().json.return_value = TOPIC_1
        result = self.conn.get_topic('example_topic')

        make_request.assert_called_with('get', 'topics/example_topic')
        self.assertEqual(TOPIC_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_delete_topic(self, make_request):
        result = self.conn.delete_topic('example_topic')
        make_request.assert_called_with(
            'delete', 'topics/example_topic', params={})
        self.assertTrue(result)

        # With Force
        result = self.conn.delete_topic('example_topic', force=True)
        make_request.assert_called_with(
            'delete', 'topics/example_topic', params={'force': 1})
        self.assertTrue(result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_push_topic_message(self, make_request):
        make_request().json.return_value = MESSAGE_1
        result = self.conn.push_topic_message('example_topic', '<body>')

        make_request.assert_called_with(
            'post', 'topics/example_topic/messages', data='{"body": "<body>"}')
        self.assertEqual(MESSAGE_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_get_subscriptions(self, make_request):
        make_request().json.return_value = SUBSCRIPTION_LIST
        result = self.conn.get_subscriptions('example_topic')

        make_request.assert_called_with(
            'get', 'topics/example_topic/subscriptions')
        self.assertEqual(SUBSCRIPTION_LIST, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_create_subscription(self, make_request):
        make_request().json.return_value = SUBSCRIPTION_1
        endpoint_details = {
            'account_id': 'test',
            'queue_name': 'topic_subscription_queue'}
        result = self.conn.create_subscription(
            'example_topic', 'queue', **endpoint_details)

        make_request.assert_called_with(
            'post', 'topics/example_topic/subscriptions', data=ANY)
        self.assertEqual(SUBSCRIPTION_1, result)

    @patch('SoftLayer.managers.messaging.MessagingConnection._make_request')
    def test_delete_subscription(self, make_request):
        make_request().json.return_value = SUBSCRIPTION_1
        result = self.conn.delete_subscription(
            'example_topic', SUBSCRIPTION_1['id'])

        make_request.assert_called_with(
            'delete',
            'topics/example_topic/subscriptions/%s' % SUBSCRIPTION_1['id'])
        self.assertTrue(result)

########NEW FILE########
__FILENAME__ = sshkey_tests
"""
    SoftLayer.tests.managers.sshkey_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import SshKeyManager
from SoftLayer.tests import unittest, FixtureClient
from mock import call


class SshKeyTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.sshkey = SshKeyManager(self.client)

    def test_add_key(self):
        key = 'pretend this is a public SSH key'
        label = 'Test label'
        notes = 'My notes'

        data = {
            'key': key,
            'label': label,
            'notes': notes,
        }
        mcall = call(data)
        service = self.client['Security_Ssh_Key']

        self.sshkey.add_key(key=key, label=label, notes=notes)
        service.createObject.assert_has_calls(mcall)

    def test_delete_key(self):
        id = 1234
        mcall = call(id=id)
        service = self.client['Security_Ssh_Key']

        self.sshkey.delete_key(id)
        service.deleteObject.assert_has_calls(mcall)

    def test_edit_key(self):
        id = 1234
        label = 'Test label'
        notes = 'My notes'

        data = {
            'label': label,
            'notes': notes,
        }
        mcall = call(data, id=id)
        service = self.client['Security_Ssh_Key']

        self.sshkey.edit_key(id, label=label, notes=notes)
        service.editObject.assert_has_calls(mcall)

    def test_get_key(self):
        id = 1234
        mcall = call(id=id)
        service = self.client['Security_Ssh_Key']

        self.sshkey.get_key(id)
        service.getObject.assert_has_calls(mcall)

    def test_list_keys(self):
        service = self.client['Account']
        self.sshkey.list_keys(label='some label')
        service.getSshKeys.assert_called_with(
            filter={'sshKeys': {'label': {'operation': '_= some label'}}})

    def test_resolve_ids_label(self):
        _id = self.sshkey._get_ids_from_label('Test 1')
        self.assertEqual(_id, ['100'])

        _id = self.sshkey._get_ids_from_label('nope')
        self.assertEqual(_id, [])

########NEW FILE########
__FILENAME__ = ssl_tests
"""
    SoftLayer.tests.managers.ssl_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import SSLManager
from SoftLayer.tests import unittest, FixtureClient

from mock import ANY


class SSLTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.ssl = SSLManager(self.client)
        self.test_id = 10

    def test_list_certs(self):
        self.ssl.list_certs('valid')
        f = self.client['Account'].getValidSecurityCertificates
        f.assert_called_once_with(mask=ANY)

        self.ssl.list_certs('expired')
        f = self.client['Account'].getExpiredSecurityCertificates
        f.assert_called_once_with(mask=ANY)

        self.ssl.list_certs('all')
        f = self.client['Account'].getSecurityCertificates
        f.assert_called_once_with(mask=ANY)

    def test_add_certificate(self):
        test_cert = {
            'certificate': 'cert',
            'privateKey': 'key',
        }

        self.ssl.add_certificate(test_cert)

        f = self.client['Security_Certificate'].createObject
        f.assert_called_once_with(test_cert)

    def test_remove_certificate(self):
        self.ssl.remove_certificate(self.test_id)
        f = self.client['Security_Certificate'].deleteObject
        f.assert_called_once_with(id=self.test_id)

    def test_edit_certificate(self):
        test_cert = {
            'id': self.test_id,
            'certificate': 'cert',
            'privateKey': 'key'
        }

        self.ssl.edit_certificate(test_cert)
        f = self.client['Security_Certificate'].editObject
        f.assert_called_once_with(
            {
                'id': self.test_id,
                'certificate': 'cert',
                'privateKey': 'key'
            },
            id=self.test_id)

    def test_get_certificate(self):
        self.ssl.get_certificate(self.test_id)
        f = self.client['Security_Certificate'].getObject
        f.assert_called_once_with(id=self.test_id)

########NEW FILE########
__FILENAME__ = ticket_tests
"""
    SoftLayer.tests.managers.ticket_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import TicketManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Ticket
from mock import ANY, call


class TicketTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.ticket = TicketManager(self.client)

    def test_list_tickets(self):
        mcall = call(mask=ANY)
        service = self.client['Account']

        list_expected_ids = [100, 101, 102]
        open_expected_ids = [102]
        closed_expected_ids = [100, 101]

        results = self.ticket.list_tickets()
        service.getTickets.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

        results = self.ticket.list_tickets(open_status=True,
                                           closed_status=True)
        service.getTickets.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

        results = self.ticket.list_tickets(open_status=True,
                                           closed_status=False)
        for result in results:
            self.assertIn(result['id'], open_expected_ids)

        results = self.ticket.list_tickets(open_status=False,
                                           closed_status=True)
        for result in results:
            self.assertIn(result['id'], closed_expected_ids)

    def test_list_subjects(self):
        list_expected_ids = [1001, 1002, 1003, 1004, 1005]

        results = self.ticket.list_subjects()
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

    def test_get_instance(self):
        result = self.ticket.get_ticket(100)
        self.client['Ticket'].getObject.assert_called_once_with(
            id=100, mask=ANY)
        self.assertEqual(Ticket.getObject, result)

    def test_create_ticket(self):
        self.ticket.create_ticket(
            title="Cloud Instance Cancellation - 08/01/13",
            body="body",
            subject=1004)
        self.client['Ticket'].createStandardTicket.assert_called_once_with(
            {"assignedUserId": 12345,
             "contents": "body",
             "subjectId": 1004,
             "title": "Cloud Instance Cancellation - 08/01/13"}, "body")

    def test_update_ticket(self):
        # Test editing user data
        service = self.client['Ticket']

        # test a full update
        self.ticket.update_ticket(100, body='Update1')
        service.edit.assert_called_once_with(
            {
                "accountId": 1234,
                "assignedUserId": 12345,
                "createDate": "2013-08-01T14:14:04-07:00",
                "id": 100,
                "lastEditDate": "2013-08-01T14:16:47-07:00",
                "lastEditType": "AUTO",
                "modifyDate": "2013-08-01T14:16:47-07:00",
                "status": {
                    "id": 1002,
                    "name": "Closed"
                },
                "statusId": 1002,
                "title": "Cloud Instance Cancellation - 08/01/13"
            },
            'Update1',
            id=100)

########NEW FILE########
__FILENAME__ = vs_tests
"""
    SoftLayer.tests.managers.vs_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer import VSManager
from SoftLayer.tests import unittest, FixtureClient
from SoftLayer.tests.fixtures import Virtual_Guest

from mock import MagicMock, ANY, call, patch


class VSTests(unittest.TestCase):

    def setUp(self):
        self.client = FixtureClient()
        self.vs = VSManager(self.client)

    def test_list_instances(self):
        mcall = call(mask=ANY, filter={})
        service = self.client['Account']

        list_expected_ids = [100, 104]
        hourly_expected_ids = [104]
        monthly_expected_ids = [100]

        results = self.vs.list_instances(hourly=True, monthly=True)
        service.getVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

        result = self.vs.list_instances(hourly=False, monthly=False)
        service.getVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], list_expected_ids)

        results = self.vs.list_instances(hourly=False, monthly=True)
        service.getMonthlyVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], monthly_expected_ids)

        results = self.vs.list_instances(hourly=True, monthly=False)
        service.getHourlyVirtualGuests.assert_has_calls(mcall)
        for result in results:
            self.assertIn(result['id'], hourly_expected_ids)

    def test_list_instances_with_filters(self):
        self.vs.list_instances(
            hourly=True,
            monthly=True,
            tags=['tag1', 'tag2'],
            cpus=2,
            memory=1024,
            hostname='hostname',
            domain='example.com',
            local_disk=True,
            datacenter='dal05',
            nic_speed=100,
            public_ip='1.2.3.4',
            private_ip='4.3.2.1',
        )

        service = self.client['Account']
        service.getVirtualGuests.assert_has_calls(call(
            filter={
                'virtualGuests': {
                    'datacenter': {
                        'name': {'operation': '_= dal05'}},
                    'domain': {'operation': '_= example.com'},
                    'tagReferences': {
                        'tag': {'name': {
                            'operation': 'in',
                            'options': [{
                                'name': 'data', 'value': ['tag1', 'tag2']}]}}},
                    'maxCpu': {'operation': 2},
                    'localDiskFlag': {'operation': True},
                    'maxMemory': {'operation': 1024},
                    'hostname': {'operation': '_= hostname'},
                    'networkComponents': {'maxSpeed': {'operation': 100}},
                    'primaryIpAddress': {'operation': '_= 1.2.3.4'},
                    'primaryBackendIpAddress': {'operation': '_= 4.3.2.1'}
                }},
            mask=ANY,
        ))

    def test_resolve_ids_ip(self):
        service = self.client['Account']
        _id = self.vs._get_ids_from_ip('172.16.240.2')
        self.assertEqual(_id, [100, 104])

        _id = self.vs._get_ids_from_ip('nope')
        self.assertEqual(_id, [])

        # Now simulate a private IP test
        service.getVirtualGuests.side_effect = [[], [{'id': 99}]]
        _id = self.vs._get_ids_from_ip('10.0.1.87')
        self.assertEqual(_id, [99])

    def test_resolve_ids_hostname(self):
        _id = self.vs._get_ids_from_hostname('vs-test1')
        self.assertEqual(_id, [100, 104])

    def test_get_instance(self):
        result = self.vs.get_instance(100)
        self.client['Virtual_Guest'].getObject.assert_called_once_with(
            id=100, mask=ANY)
        self.assertEqual(Virtual_Guest.getObject, result)

    def test_get_create_options(self):
        results = self.vs.get_create_options()
        self.assertEqual(Virtual_Guest.getCreateObjectOptions, results)

    def test_cancel_instance(self):
        self.vs.cancel_instance(1)
        self.client['Virtual_Guest'].deleteObject.assert_called_once_with(id=1)

    def test_reload_instance(self):
        post_uri = 'http://test.sftlyr.ws/test.sh'
        self.vs.reload_instance(1, post_uri=post_uri, ssh_keys=[1701])
        service = self.client['Virtual_Guest']
        f = service.reloadOperatingSystem
        f.assert_called_once_with('FORCE',
                                  {'customProvisionScriptUri': post_uri,
                                   'sshKeyIds': [1701]}, id=1)

    @patch('SoftLayer.managers.vs.VSManager._generate_create_dict')
    def test_create_verify(self, create_dict):
        create_dict.return_value = {'test': 1, 'verify': 1}
        self.vs.verify_create_instance(test=1, verify=1)
        create_dict.assert_called_once_with(test=1, verify=1)
        f = self.client['Virtual_Guest'].generateOrderTemplate
        f.assert_called_once_with({'test': 1, 'verify': 1})

    @patch('SoftLayer.managers.vs.VSManager._generate_create_dict')
    def test_create_instance(self, create_dict):
        create_dict.return_value = {'test': 1, 'verify': 1}
        self.vs.create_instance(test=1, verify=1)
        create_dict.assert_called_once_with(test=1, verify=1)
        self.client['Virtual_Guest'].createObject.assert_called_once_with(
            {'test': 1, 'verify': 1})

    def test_generate_os_and_image(self):
        self.assertRaises(
            ValueError,
            self.vs._generate_create_dict,
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code=1,
            image_id=1,
        )

    def test_generate_missing(self):
        self.assertRaises(ValueError, self.vs._generate_create_dict)
        self.assertRaises(ValueError, self.vs._generate_create_dict, cpus=1)

    def test_generate_basic(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
        }

        self.assertEqual(data, assert_data)

    def test_generate_monthly(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            hourly=False,
        )

        assert_data = {
            'hourlyBillingFlag': False,
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
        }

        self.assertEqual(data, assert_data)

    def test_generate_image_id(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            image_id="45",
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'blockDeviceTemplateGroup': {"globalIdentifier": "45"},
            'hourlyBillingFlag': True,
        }

        self.assertEqual(data, assert_data)

    def test_generate_dedicated(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            dedicated=True,
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'dedicatedAccountHostOnlyFlag': True,
        }

        self.assertEqual(data, assert_data)

    def test_generate_datacenter(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            datacenter="sng01",
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'datacenter': {"name": 'sng01'},
        }

        self.assertEqual(data, assert_data)

    def test_generate_public_vlan(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            public_vlan=1,
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'primaryNetworkComponent': {"networkVlan": {"id": 1}},
        }

        self.assertEqual(data, assert_data)

    def test_generate_private_vlan(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            private_vlan=1,
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'primaryBackendNetworkComponent': {"networkVlan": {"id": 1}},
        }

        self.assertEqual(data, assert_data)

    def test_generate_userdata(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            userdata="ICANHAZVSI",
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'userData': [{'value': "ICANHAZVSI"}],
        }

        self.assertEqual(data, assert_data)

    def test_generate_network(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            nic_speed=9001,
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'networkComponents': [{'maxSpeed': 9001}],
        }

        self.assertEqual(data, assert_data)

    def test_generate_private_network_only(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            nic_speed=9001,
            private=True
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'privateNetworkOnlyFlag': True,
            'hourlyBillingFlag': True,
            'networkComponents': [{'maxSpeed': 9001}],
        }

        self.assertEqual(data, assert_data)

    def test_generate_post_uri(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            post_uri='https://example.com/boostrap.sh',
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'postInstallScriptUri': 'https://example.com/boostrap.sh',
        }

        self.assertEqual(data, assert_data)

    def test_generate_sshkey(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            ssh_keys=[543],
        )

        assert_data = {
            'startCpus': 1,
            'maxMemory': 1,
            'hostname': 'test',
            'domain': 'example.com',
            'localDiskFlag': True,
            'operatingSystemReferenceCode': "STRING",
            'hourlyBillingFlag': True,
            'sshKeys': [{'id': 543}],
        }

        self.assertEqual(data, assert_data)

    def test_generate_no_disks(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING"
        )

        self.assertEqual(data.get('blockDevices'), None)

    def test_generate_single_disk(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            disks=[50]
        )

        assert_data = {
            'blockDevices': [
                {"device": "0", "diskImage": {"capacity": 50}}]
        }

        self.assertTrue(data.get('blockDevices'))
        self.assertEqual(data['blockDevices'], assert_data['blockDevices'])

    def test_generate_multi_disk(self):
        data = self.vs._generate_create_dict(
            cpus=1,
            memory=1,
            hostname='test',
            domain='example.com',
            os_code="STRING",
            disks=[50, 70, 100]
        )

        assert_data = {
            'blockDevices': [
                {"device": "0", "diskImage": {"capacity": 50}},
                {"device": "2", "diskImage": {"capacity": 70}},
                {"device": "3", "diskImage": {"capacity": 100}}]
        }

        self.assertTrue(data.get('blockDevices'))
        self.assertEqual(data['blockDevices'], assert_data['blockDevices'])

    def test_change_port_speed_public(self):
        vs_id = 1
        speed = 100
        self.vs.change_port_speed(vs_id, True, speed)

        service = self.client['Virtual_Guest']
        f = service.setPublicNetworkInterfaceSpeed
        f.assert_called_once_with(speed, id=vs_id)

    def test_change_port_speed_private(self):
        vs_id = 2
        speed = 10
        self.vs.change_port_speed(vs_id, False, speed)

        service = self.client['Virtual_Guest']
        f = service.setPrivateNetworkInterfaceSpeed
        f.assert_called_once_with(speed, id=vs_id)

    def test_edit(self):
        # Test editing user data
        service = self.client['Virtual_Guest']

        self.vs.edit(100, userdata='my data')

        service.setUserMetadata.assert_called_once_with(['my data'], id=100)

        # Now test a blank edit
        self.assertTrue(self.vs.edit, 100)

        # Finally, test a full edit
        args = {
            'hostname': 'new-host',
            'domain': 'new.sftlyr.ws',
            'notes': 'random notes',
        }

        self.vs.edit(100, **args)
        service.editObject.assert_called_once_with(args, id=100)

    def test_captures(self):
        archive = self.client['Virtual_Guest'].createArchiveTransaction

        # capture only the OS disk
        self.vs.capture(1, 'a')
        archive.called_once_with('a', [{"device": 0}], "", id=1)

        archive.reset()

        # capture all the disks, minus the swap
        # make sure the data is carried along with it
        self.vs.capture(1, 'a', additional_disks=True)
        archive.called_once_with('a', [{"device": 0, "uuid": 1},
                                 {"device": 2, "uuid": 2}], "", id=1)

    def test_upgrade(self):
        # Testing  Upgrade
        orderClient = self.client['Product_Order']

        # test single upgrade
        self.vs.upgrade(1, cpus=4, public=False)
        orderClient.placeOrder.called_once_with(1, cpus=4, public=False)

        # Now test a blank upgrade
        self.vs.upgrade(1)
        self.assertTrue(self.vs.upgrade, 1)

        # Testing all parameters Upgrade
        self.vs.upgrade(1, cpus=4, memory=2, nic_speed=1000, public=True)
        args = {'cpus': 4, 'memory': 2, 'nic_speed': 1000, 'public': 1000}
        orderClient.placeOrder.called_once_with(1, **args)

    def test_get_item_id_for_upgrade(self):
        item_id = 0
        package_items = self.client['Product_Package'].getItems(id=46)
        for item in package_items:
            if ((item['categories'][0]['id'] == 3)
                    and (item.get('capacity') == '2')):
                item_id = item['prices'][0]['id']
                break
        self.assertEqual(1133, item_id)


class VSWaitReadyGoTests(unittest.TestCase):

    def setUp(self):
        self.client = MagicMock()
        self.vs = VSManager(self.client)
        self.guestObject = self.client['Virtual_Guest'].getObject

    @patch('SoftLayer.managers.vs.VSManager.wait_for_ready')
    def test_wait_interface(self, ready):
        # verify interface to wait_for_ready is intact
        self.vs.wait_for_transaction(1, 1)
        ready.assert_called_once_with(1, 1, delay=1, pending=True)

    def test_active_not_provisioned(self):
        # active transaction and no provision date should be false
        self.guestObject.side_effect = [
            {'activeTransaction': {'id': 1}},
        ]
        value = self.vs.wait_for_ready(1, 1)
        self.assertFalse(value)

    def test_active_and_provisiondate(self):
        # active transaction and provision date should be True
        self.guestObject.side_effect = [
            {'activeTransaction': {'id': 1},
             'provisionDate': 'aaa'},
        ]
        value = self.vs.wait_for_ready(1, 1)
        self.assertTrue(value)

    def test_active_provision_pending(self):
        # active transaction and provision date
        # and pending should be false
        self.guestObject.side_effect = [
            {'activeTransaction': {'id': 1},
             'provisionDate': 'aaa'},
        ]
        value = self.vs.wait_for_ready(1, 1, pending=True)
        self.assertFalse(value)

    def test_active_reload(self):
        # actively running reload
        self.guestObject.side_effect = [
            {
                'activeTransaction': {'id': 1},
                'provisionDate': 'aaa',
                'lastOperatingSystemReload': {'id': 1},
            },
        ]
        value = self.vs.wait_for_ready(1, 1)
        self.assertFalse(value)

    def test_reload_no_pending(self):
        # reload complete, maintance transactions
        self.guestObject.side_effect = [
            {
                'activeTransaction': {'id': 2},
                'provisionDate': 'aaa',
                'lastOperatingSystemReload': {'id': 1},
            },
        ]
        value = self.vs.wait_for_ready(1, 1)
        self.assertTrue(value)

    def test_reload_pending(self):
        # reload complete, pending maintance transactions
        self.guestObject.side_effect = [
            {
                'activeTransaction': {'id': 2},
                'provisionDate': 'aaa',
                'lastOperatingSystemReload': {'id': 1},
            },
        ]
        value = self.vs.wait_for_ready(1, 1, pending=True)
        self.assertFalse(value)

    @patch('SoftLayer.managers.vs.sleep')
    def test_ready_iter_once_incomplete(self, _sleep):
        self.guestObject = self.client['Virtual_Guest'].getObject

        # no iteration, false
        self.guestObject.side_effect = [
            {'activeTransaction': {'id': 1}},
        ]
        value = self.vs.wait_for_ready(1, 1)
        self.assertFalse(value)
        self.assertFalse(_sleep.called)

    @patch('SoftLayer.managers.vs.sleep')
    def test_iter_once_complete(self, _sleep):
        # no iteration, true
        self.guestObject.side_effect = [
            {'provisionDate': 'aaa'},
        ]
        value = self.vs.wait_for_ready(1, 1)
        self.assertTrue(value)
        self.assertFalse(_sleep.called)

    @patch('SoftLayer.managers.vs.sleep')
    def test_iter_four_complete(self, _sleep):
        # test 4 iterations with positive match
        self.guestObject.side_effect = [
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'provisionDate': 'aaa'},
        ]

        value = self.vs.wait_for_ready(1, 4)
        self.assertTrue(value)
        _sleep.assert_has_calls([call(1), call(1), call(1)])
        self.guestObject.assert_has_calls([
            call(id=1, mask=ANY), call(id=1, mask=ANY),
            call(id=1, mask=ANY), call(id=1, mask=ANY),
        ])

    @patch('SoftLayer.managers.vs.sleep')
    def test_iter_two_incomplete(self, _sleep):
        # test 2 iterations, with no matches
        self.guestObject.side_effect = [
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'provisionDate': 'aaa'}
        ]
        value = self.vs.wait_for_ready(1, 2)
        self.assertFalse(value)
        _sleep.assert_called_once_with(1)
        self.guestObject.assert_has_calls([
            call(id=1, mask=ANY), call(id=1, mask=ANY),
        ])

    @patch('SoftLayer.managers.vs.sleep')
    def test_iter_ten_incomplete(self, _sleep):
        # 10 iterations at 10 second sleeps with no
        # matching values.
        self.guestObject.side_effect = [
            {},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
            {'activeTransaction': {'id': 1}},
        ]
        value = self.vs.wait_for_ready(1, 10, delay=10)
        self.assertFalse(value)
        self.guestObject.assert_has_calls([
            call(id=1, mask=ANY), call(id=1, mask=ANY),
            call(id=1, mask=ANY), call(id=1, mask=ANY),
            call(id=1, mask=ANY), call(id=1, mask=ANY),
            call(id=1, mask=ANY), call(id=1, mask=ANY),
            call(id=1, mask=ANY), call(id=1, mask=ANY),
        ])
        # should only be 9 calls to sleep, last iteration
        # should return a value and skip the sleep
        _sleep.assert_has_calls([
            call(10), call(10), call(10), call(10), call(10),
            call(10), call(10), call(10), call(10)])

########NEW FILE########
__FILENAME__ = transport_tests
"""
    SoftLayer.tests.transport_tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :license: MIT, see LICENSE for more details.
"""
from mock import patch, MagicMock, ANY

from SoftLayer import SoftLayerAPIError, TransportError
from SoftLayer.transports import make_rest_api_call, make_xml_rpc_api_call
from SoftLayer.tests import unittest
from requests import HTTPError, RequestException


class TestXmlRpcAPICall(unittest.TestCase):

    def setUp(self):
        self.send_content = '''<?xml version="1.0" encoding="utf-8"?>
<params>
<param>
 <value>
  <array>
   <data/>
  </array>
 </value>
</param>
</params>'''

    @patch('SoftLayer.transports.requests.Session.send')
    def test_call(self, send):
        send().content = self.send_content

        data = '''<?xml version='1.0'?>
<methodCall>
<methodName>getObject</methodName>
<params>
<param>
<value><struct>
<member>
<name>headers</name>
<value><nil/></value></member>
</struct></value>
</param>
</params>
</methodCall>
'''
        resp = make_xml_rpc_api_call(
            'http://something.com/path/to/resource', 'getObject')
        args = send.call_args
        self.assertIsNotNone(args)
        args, kwargs = args

        send.assert_called_with(ANY, proxies=None, timeout=None)
        self.assertEqual(resp, [])
        self.assertEquals(args[0].body, data)

    def test_proxy_without_protocol(self):
        self.assertRaises(
            TransportError,
            make_xml_rpc_api_call,
            'http://something.com/path/to/resource',
            'getObject',
            'localhost:3128')

    @patch('SoftLayer.transports.requests.Session.send')
    def test_valid_proxy(self, send):
        send().content = self.send_content
        make_xml_rpc_api_call('http://something.com/path/to/resource',
                              'getObject',
                              proxy='http://localhost:3128')
        send.assert_called_with(
            ANY,
            proxies={'https': 'http://localhost:3128',
                     'http': 'http://localhost:3128'},
            timeout=None)


class TestRestAPICall(unittest.TestCase):

    @patch('SoftLayer.transports.requests.request')
    def test_json(self, request):
        request().content = '{}'
        resp = make_rest_api_call(
            'GET', 'http://something.com/path/to/resource.json')
        self.assertEqual(resp, {})
        request.assert_called_with(
            'GET', 'http://something.com/path/to/resource.json',
            headers=None,
            proxies=None,
            timeout=None)

        # Test JSON Error
        e = HTTPError('error')
        e.response = MagicMock()
        e.response.status_code = 404
        e.response.content = '''{
            "error": "description",
            "code": "Error Code"
        }'''
        request().raise_for_status.side_effect = e

        self.assertRaises(
            SoftLayerAPIError,
            make_rest_api_call,
            'GET',
            'http://something.com/path/to/resource.json')

    def test_proxy_without_protocol(self):
        self.assertRaises(
            TransportError,
            make_rest_api_call,
            'GET'
            'http://something.com/path/to/resource.txt',
            'localhost:3128')

    @patch('SoftLayer.transports.requests.request')
    def test_valid_proxy(self, request):
        make_rest_api_call('GET',
                           'http://something.com/path/to/resource.txt',
                           proxy='http://localhost:3128')
        request.assert_called_with(
            'GET', 'http://something.com/path/to/resource.txt',
            headers=ANY,
            proxies={'https': 'http://localhost:3128',
                     'http': 'http://localhost:3128'},
            timeout=None)

    @patch('SoftLayer.transports.requests.request')
    def test_text(self, request):
        request().text = 'content'
        resp = make_rest_api_call(
            'GET', 'http://something.com/path/to/resource.txt')
        self.assertEqual(resp, 'content')
        request.assert_called_with(
            'GET', 'http://something.com/path/to/resource.txt',
            headers=None,
            proxies=None,
            timeout=None)

        # Test Text Error
        e = HTTPError('error')
        e.response = MagicMock()
        e.response.status_code = 404
        e.response.content = 'Error Code'
        request().raise_for_status.side_effect = e

        self.assertRaises(
            SoftLayerAPIError,
            make_rest_api_call,
            'GET',
            'http://something.com/path/to/resource.txt')

    @patch('SoftLayer.transports.requests.request')
    def test_unknown_error(self, request):
        e = RequestException('error')
        e.response = MagicMock()
        e.response.status_code = 404
        e.response.content = 'Error Code'
        request().raise_for_status.side_effect = e

        self.assertRaises(
            TransportError,
            make_rest_api_call,
            'GET',
            'http://something.com/path/to/resource.txt')

########NEW FILE########
__FILENAME__ = transports
"""
    SoftLayer.transports
    ~~~~~~~~~~~~~~~~~~~~
    XML-RPC transport layer that uses the requests library.

    :license: MIT, see LICENSE for more details.
"""
from SoftLayer.exceptions import (
    SoftLayerAPIError, NotWellFormed, UnsupportedEncoding, InvalidCharacter,
    SpecViolation, MethodNotFound, InvalidMethodParameters, InternalError,
    ApplicationError, RemoteSystemError, TransportError)
from SoftLayer.utils import xmlrpc_client

import logging
import requests
import json

LOGGER = logging.getLogger(__name__)


def _proxies_dict(proxy):
    """ Makes a dict appropriate to pass to requests """
    if not proxy:
        return None
    return {'http': proxy, 'https': proxy}


def make_xml_rpc_api_call(uri, method, args=None, headers=None,
                          http_headers=None, timeout=None, proxy=None):
    """ Makes a SoftLayer API call against the XML-RPC endpoint

    :param string uri: endpoint URL
    :param string method: method to call E.G.: 'getObject'
    :param dict headers: XML-RPC headers to use for the request
    :param dict http_headers: HTTP headers to use for the request
    :param int timeout: number of seconds to use as a timeout
    """
    if args is None:
        args = tuple()
    try:
        largs = list(args)
        largs.insert(0, {'headers': headers})

        payload = xmlrpc_client.dumps(tuple(largs),
                                      methodname=method,
                                      allow_none=True)
        session = requests.Session()
        req = requests.Request('POST', uri, data=payload,
                               headers=http_headers).prepare()
        LOGGER.debug("=== REQUEST ===")
        LOGGER.info('POST %s', uri)
        LOGGER.debug(req.headers)
        LOGGER.debug(payload)

        response = session.send(req,
                                timeout=timeout,
                                proxies=_proxies_dict(proxy))
        LOGGER.debug("=== RESPONSE ===")
        LOGGER.debug(response.headers)
        LOGGER.debug(response.content)
        response.raise_for_status()
        result = xmlrpc_client.loads(response.content,)[0][0]
        return result
    except xmlrpc_client.Fault as ex:
        # These exceptions are formed from the XML-RPC spec
        # http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php
        error_mapping = {
            '-32700': NotWellFormed,
            '-32701': UnsupportedEncoding,
            '-32702': InvalidCharacter,
            '-32600': SpecViolation,
            '-32601': MethodNotFound,
            '-32602': InvalidMethodParameters,
            '-32603': InternalError,
            '-32500': ApplicationError,
            '-32400': RemoteSystemError,
            '-32300': TransportError,
        }
        raise error_mapping.get(ex.faultCode, SoftLayerAPIError)(
            ex.faultCode, ex.faultString)
    except requests.HTTPError as ex:
        raise TransportError(ex.response.status_code, str(ex))
    except requests.RequestException as ex:
        raise TransportError(0, str(ex))


def make_rest_api_call(method, url,
                       http_headers=None, timeout=None, proxy=None):
    """ Makes a SoftLayer API call against the REST endpoint

    :param string method: HTTP method: GET, POST, PUT, DELETE
    :param string url: endpoint URL
    :param dict http_headers: HTTP headers to use for the request
    :param int timeout: number of seconds to use as a timeout
    """
    LOGGER.info('%s %s', method, url)
    try:
        resp = requests.request(method, url,
                                headers=http_headers,
                                timeout=timeout,
                                proxies=_proxies_dict(proxy))
        resp.raise_for_status()
        LOGGER.debug(resp.content)
        if url.endswith('.json'):
            return json.loads(resp.content)
        else:
            return resp.text
    except requests.HTTPError as ex:
        if url.endswith('.json'):
            content = json.loads(ex.response.content)
            raise SoftLayerAPIError(ex.response.status_code, content['error'])
        else:
            raise SoftLayerAPIError(ex.response.status_code, ex.response.text)
    except requests.RequestException as ex:
        raise TransportError(0, str(ex))

########NEW FILE########
__FILENAME__ = utils
"""
    SoftLayer.utils
    ~~~~~~~~~~~~~~~
    Utility function/classes

    :license: MIT, see LICENSE for more details.
"""
import re
import six

UUID_RE = re.compile(r'^[0-9a-f\-]{36}$', re.I)
KNOWN_OPERATIONS = ['<=', '>=', '<', '>', '~', '!~', '*=', '^=', '$=', '_=']

configparser = six.moves.configparser  # pylint: disable=E1101,C0103
console_input = six.moves.input  # pylint: disable=E1101,C0103
string_types = six.string_types  # pylint: disable=C0103
StringIO = six.StringIO  # pylint: disable=C0103
xmlrpc_client = six.moves.xmlrpc_client  # pylint: disable=E1101,C0103


def lookup(dic, key, *keys):
    """ A generic dictionary access helper. This helps simplify code that uses
        heavily nested dictionaries. It will return None if any of the keys
        in *keys do not exist.

    ::

        >>> lookup({'this': {'is': 'nested'}}, 'this', 'is')
        nested

        >>> lookup({}, 'this', 'is')
        None

    """
    if keys:
        return lookup(dic.get(key, {}), *keys)
    return dic.get(key)


class NestedDict(dict):
    """ This helps with accessing a heavily nested dictionary. Access to keys
        which don't exist will result in a new, empty dictionary
    """

    def __getitem__(self, key):
        if key in self:
            return self.get(key)
        return self.setdefault(key, NestedDict())

    def to_dict(self):
        """
            Converts a NestedDict instance into a real dictionary. This is
            needed for places where strict type checking is done.
        """
        new_dict = {}
        for key, val in self.items():
            if isinstance(val, NestedDict):
                new_dict[key] = val.to_dict()
            else:
                new_dict[key] = val
        return new_dict


def query_filter(query):
    """ Translate a query-style string to a 'filter'. Query can be the
    following formats:

    Case Insensitive
      'value' OR '*= value'    Contains
      'value*' OR '^= value'   Begins with value
      '*value' OR '$= value'   Ends with value
      '*value*' OR '_= value'  Contains value

    Case Sensitive
      '~ value'   Contains
      '!~ value'  Does not contain
      '> value'   Greater than value
      '< value'   Less than value
      '>= value'  Greater than or equal to value
      '<= value'  Less than or equal to value

    :param string query: query string

    """
    try:
        return {'operation': int(query)}
    except ValueError:
        pass

    if isinstance(query, string_types):
        query = query.strip()
        for operation in KNOWN_OPERATIONS:
            if query.startswith(operation):
                query = "%s %s" % (operation, query[len(operation):].strip())
                return {'operation': query}
        if query.startswith('*') and query.endswith('*'):
            query = "*= %s" % query.strip('*')
        elif query.startswith('*'):
            query = "$= %s" % query.strip('*')
        elif query.endswith('*'):
            query = "^= %s" % query.strip('*')
        else:
            query = "_= %s" % query

    return {'operation': query}


class IdentifierMixin(object):
    """ This mixin provides an interface to provide multiple methods for
        converting an 'indentifier' to an id """
    resolvers = []

    def resolve_ids(self, identifier):
        """ Takes a string and tries to resolve to a list of matching ids. What
            exactly 'identifier' can be depends on the resolvers

        :param string identifier: identifying string

        :returns list:
        """

        return resolve_ids(identifier, self.resolvers)


def resolve_ids(identifier, resolvers):
    """ Resolves IDs given a list of functions

    :param string identifier: identifier string
    :param list resolvers: a list of functions
    :returns list:
    """

    # Before doing anything, let's see if this is an integer
    try:
        return [int(identifier)]
    except ValueError:
        pass  # It was worth a shot

    # This looks like a globalIdentifier (UUID)
    if len(identifier) == 36 and UUID_RE.match(identifier):
        return [identifier]

    for resolver in resolvers:
        ids = resolver(identifier)
        if ids:
            return ids

    return []

########NEW FILE########
