__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# sx documentation build configuration file, created by
# sphinx-quickstart on Fri Jan  4 11:52:36 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

highlight_language = "bash"
primary_domain = "bash"

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.todo']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'sx'
copyright = u'2013, sx'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1'
# The full version, including alpha/beta/rc tags.
release = '1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'
html_theme_options = {
    "collapsiblesidebar": "true"
}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'sxdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'sx.tex', u'sx Documentation',
   u'sx', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'sx', u'sx Documentation',
     [u'Amir Taaki <amir@unsystem.net>'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'sx', u'sx Documentation',
   u'sx', 'sx', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = bitcoin
#!/usr/bin/env python
#
# Electrum - lightweight Bitcoin client
# Copyright (C) 2011 thomasv@gitorious
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


import hashlib, base64, ecdsa, re
from util import print_error
from config import chain
import models
import numbertheory
import os

def rev_hex(s):
    return s.decode('hex')[::-1].encode('hex')

def int_to_hex(i, length=1):
    s = hex(i)[2:].rstrip('L')
    s = "0"*(2*length - len(s)) + s
    return rev_hex(s)

def var_int(i):
    # https://en.bitcoin.it/wiki/Protocol_specification#Variable_length_integer
    if i<0xfd:
        return int_to_hex(i)
    elif i<=0xffff:
        return "fd"+int_to_hex(i,2)
    elif i<=0xffffffff:
        return "fe"+int_to_hex(i,4)
    else:
        return "ff"+int_to_hex(i,8)

def op_push(i):
    if i<0x4c:
        return int_to_hex(i)
    elif i<0xff:
        return '4c' + int_to_hex(i)
    elif i<0xffff:
        return '4d' + int_to_hex(i,2)
    else:
        return '4e' + int_to_hex(i,4)
    


Hash = lambda x: hashlib.sha256(hashlib.sha256(x).digest()).digest()
hash_encode = lambda x: x[::-1].encode('hex')
hash_decode = lambda x: x.decode('hex')[::-1]


# pywallet openssl private key implementation

def i2d_ECPrivateKey(pkey, compressed=False):
    if compressed:
        key = '3081d30201010420' + \
              '%064x' % pkey.secret + \
              'a081a53081a2020101302c06072a8648ce3d0101022100' + \
              '%064x' % _p + \
              '3006040100040107042102' + \
              '%064x' % _Gx + \
              '022100' + \
              '%064x' % _r + \
              '020101a124032200'
    else:
        key = '308201130201010420' + \
              '%064x' % pkey.secret + \
              'a081a53081a2020101302c06072a8648ce3d0101022100' + \
              '%064x' % _p + \
              '3006040100040107044104' + \
              '%064x' % _Gx + \
              '%064x' % _Gy + \
              '022100' + \
              '%064x' % _r + \
              '020101a144034200'
        
    return key.decode('hex') + i2o_ECPublicKey(pkey.pubkey, compressed)
    
def i2o_ECPublicKey(pubkey, compressed=False):
    # public keys are 65 bytes long (520 bits)
    # 0x04 + 32-byte X-coordinate + 32-byte Y-coordinate
    # 0x00 = point at infinity, 0x02 and 0x03 = compressed, 0x04 = uncompressed
    # compressed keys: <sign> <x> where <sign> is 0x02 if y is even and 0x03 if y is odd
    if compressed:
        if pubkey.point.y() & 1:
            key = '03' + '%064x' % pubkey.point.x()
        else:
            key = '02' + '%064x' % pubkey.point.x()
    else:
        key = '04' + \
              '%064x' % pubkey.point.x() + \
              '%064x' % pubkey.point.y()
            
    return key.decode('hex')
            
# end pywallet openssl private key implementation

                                                
            
############ functions from pywallet ##################### 

def hash_160(public_key):
    try:
        md = hashlib.new('ripemd160')
        md.update(hashlib.sha256(public_key).digest())
        return md.digest()
    except:
        import ripemd
        md = ripemd.new(hashlib.sha256(public_key).digest())
        return md.digest()


def public_key_to_bc_address(public_key):
    h160 = hash_160(public_key)
    return hash_160_to_bc_address(h160)

def hash_160_to_bc_address(h160, addrtype=chain.pubkey_version):
    vh160 = chr(addrtype) + h160
    h = Hash(vh160)
    addr = vh160 + h[0:4]
    return b58encode(addr)

def bc_address_to_hash_160(addr):
    bytes = b58decode(addr, 25)
    return ord(bytes[0]), bytes[1:21]

def encode_point(pubkey, compressed=False):
    order = generator_secp256k1.order()
    p = pubkey.pubkey.point
    x_str = ecdsa.util.number_to_string(p.x(), order)
    y_str = ecdsa.util.number_to_string(p.y(), order)
    if compressed:
        return chr(2 + (p.y() & 1)) + x_str
    else:
        return chr(4) + pubkey.to_string() #x_str + y_str

__b58chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
__b58base = len(__b58chars)

def b58encode(v):
    """ encode v, which is a string of bytes, to base58."""

    long_value = 0L
    for (i, c) in enumerate(v[::-1]):
        long_value += (256**i) * ord(c)

    result = ''
    while long_value >= __b58base:
        div, mod = divmod(long_value, __b58base)
        result = __b58chars[mod] + result
        long_value = div
    result = __b58chars[long_value] + result

    # Bitcoin does a little leading-zero-compression:
    # leading 0-bytes in the input become leading-1s
    nPad = 0
    for c in v:
        if c == '\0': nPad += 1
        else: break

    return (__b58chars[0]*nPad) + result

def b58decode(v, length):
    """ decode v into a string of len bytes."""
    long_value = 0L
    for (i, c) in enumerate(v[::-1]):
        long_value += __b58chars.find(c) * (__b58base**i)

    result = ''
    while long_value >= 256:
        div, mod = divmod(long_value, 256)
        result = chr(mod) + result
        long_value = div
    result = chr(long_value) + result

    nPad = 0
    for c in v:
        if c == __b58chars[0]: nPad += 1
        else: break

    result = chr(0)*nPad + result
    if length is not None and len(result) != length:
        return None

    return result


def EncodeBase58Check(vchIn):
    hash = Hash(vchIn)
    return b58encode(vchIn + hash[0:4])

def DecodeBase58Check(psz):
    vchRet = b58decode(psz, None)
    key = vchRet[0:-4]
    csum = vchRet[-4:]
    hash = Hash(key)
    cs32 = hash[0:4]
    if cs32 != csum:
        return None
    else:
        return key

def PrivKeyToSecret(privkey):
    return privkey[9:9+32]

def SecretToASecret(secret, compressed=False, addrtype=chain.pubkey_version):
    vchIn = chr((addrtype+128)&255) + secret
    if compressed: vchIn += '\01'
    return EncodeBase58Check(vchIn)

def ASecretToSecret(key, addrtype=chain.pubkey_version):
    vch = DecodeBase58Check(key)
    if vch and vch[0] == chr((addrtype+128)&255):
        return vch[1:]
    else:
        return False

def regenerate_key(sec):
    b = ASecretToSecret(sec)
    if not b:
        return False
    b = b[0:32]
    secret = int('0x' + b.encode('hex'), 16)
    return EC_KEY(secret)

def GetPubKey(pubkey, compressed=False):
    return i2o_ECPublicKey(pubkey, compressed)

def GetPrivKey(pkey, compressed=False):
    return i2d_ECPrivateKey(pkey, compressed)

def GetSecret(pkey):
    return ('%064x' % pkey.secret).decode('hex')

def is_compressed(sec):
    b = ASecretToSecret(sec)
    return len(b) == 33


def address_from_private_key(sec):
    # rebuild public key from private key, compressed or uncompressed
    pkey = regenerate_key(sec)
    assert pkey

    # figure out if private key is compressed
    compressed = is_compressed(sec)
        
    # rebuild private and public key from regenerated secret
    private_key = GetPrivKey(pkey, compressed)
    public_key = GetPubKey(pkey.pubkey, compressed)
    address = public_key_to_bc_address(public_key)
    return address


def is_valid(addr):
    ADDRESS_RE = re.compile('[1-9A-HJ-NP-Za-km-z]{26,}\\Z')
    if not ADDRESS_RE.match(addr): return False
    try:
        addrtype, h = bc_address_to_hash_160(addr)
    except:
        return False
    return addr == hash_160_to_bc_address(h, addrtype)


########### end pywallet functions #######################

# secp256k1, http://www.oid-info.com/get/1.3.132.0.10
_p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2FL
_r = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141L
_b = 0x0000000000000000000000000000000000000000000000000000000000000007L
_a = 0x0000000000000000000000000000000000000000000000000000000000000000L
_Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798L
_Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8L
curve_secp256k1 = ecdsa.ellipticcurve.CurveFp( _p, _a, _b )
generator_secp256k1 = ecdsa.ellipticcurve.Point( curve_secp256k1, _Gx, _Gy, _r )
oid_secp256k1 = (1,3,132,0,10)
SECP256k1 = ecdsa.curves.Curve("SECP256k1", curve_secp256k1, generator_secp256k1, oid_secp256k1 ) 
ec_order = _r

from ecdsa.util import string_to_number, number_to_string

def msg_magic(message):
    return "\x18Bitcoin Signed Message:\n" + chr( len(message) ) + message


class EC_KEY(object):
    def __init__( self, secret ):
        self.pubkey = ecdsa.ecdsa.Public_key( generator_secp256k1, generator_secp256k1 * secret )
        self.privkey = ecdsa.ecdsa.Private_key( self.pubkey, secret )
        self.secret = secret

    def sign_message(self, message, compressed, address):
        private_key = ecdsa.SigningKey.from_secret_exponent( self.secret, curve = SECP256k1 )
        public_key = private_key.get_verifying_key()
        signature = private_key.sign_digest( Hash( msg_magic(message) ), sigencode = ecdsa.util.sigencode_string )
        assert public_key.verify_digest( signature, Hash( msg_magic(message) ), sigdecode = ecdsa.util.sigdecode_string)
        for i in range(4):
            sig = base64.b64encode( chr(27 + i + (4 if compressed else 0)) + signature )
            try:
                self.verify_message( address, sig, message)
                return sig
            except:
                continue
        else:
            raise BaseException("error: cannot sign message")

    @classmethod
    def verify_message(self, address, signature, message):
        """ See http://www.secg.org/download/aid-780/sec1-v2.pdf for the math """
        from ecdsa import numbertheory, ellipticcurve, util
        import msqr
        curve = curve_secp256k1
        G = generator_secp256k1
        order = G.order()
        # extract r,s from signature
        sig = base64.b64decode(signature)
        if len(sig) != 65: raise BaseException("Wrong encoding")
        r,s = util.sigdecode_string(sig[1:], order)
        nV = ord(sig[0])
        if nV < 27 or nV >= 35:
            raise BaseException("Bad encoding")
        if nV >= 31:
            compressed = True
            nV -= 4
        else:
            compressed = False

        recid = nV - 27
        # 1.1
        x = r + (recid/2) * order
        # 1.3
        alpha = ( x * x * x  + curve.a() * x + curve.b() ) % curve.p()
        beta = msqr.modular_sqrt(alpha, curve.p())
        y = beta if (beta - recid) % 2 == 0 else curve.p() - beta
        # 1.4 the constructor checks that nR is at infinity
        R = ellipticcurve.Point(curve, x, y, order)
        # 1.5 compute e from message:
        h = Hash( msg_magic(message) )
        e = string_to_number(h)
        minus_e = -e % order
        # 1.6 compute Q = r^-1 (sR - eG)
        inv_r = numbertheory.inverse_mod(r,order)
        Q = inv_r * ( s * R + minus_e * G )
        public_key = ecdsa.VerifyingKey.from_public_point( Q, curve = SECP256k1 )
        # check that Q is the public key
        public_key.verify_digest( sig[1:], h, sigdecode = ecdsa.util.sigdecode_string)
        # check that we get the original signing address
        addr = public_key_to_bc_address( encode_point(public_key, compressed) )
        if address != addr:
            raise BaseException("Bad signature")


###################################### BIP32 ##############################

random_seed = lambda n: "%032x"%ecdsa.util.randrange( pow(2,n) )
BIP32_PRIME = 0x80000000

def bip32_init(seed):
    import hmac
    seed = seed.decode('hex')        
    I = hmac.new("Bitcoin seed", seed, hashlib.sha512).digest()

    master_secret = I[0:32]
    master_chain = I[32:]

    K, K_compressed = get_pubkeys_from_secret(master_secret)
    return master_secret, master_chain, K, K_compressed


def get_pubkeys_from_secret(secret):
    # public key
    curve = SECP256k1
    private_key = ecdsa.SigningKey.from_string( secret, curve = SECP256k1 )
    public_key = private_key.get_verifying_key()
    K = public_key.to_string()
    K_compressed = GetPubKey(public_key.pubkey,True)
    return K, K_compressed



    
def CKD(k, c, n):
    import hmac
    from ecdsa.util import string_to_number, number_to_string
    order = generator_secp256k1.order()
    keypair = EC_KEY(string_to_number(k))
    K = GetPubKey(keypair.pubkey,True)

    if n & BIP32_PRIME:
        data = chr(0) + k + rev_hex(int_to_hex(n,4)).decode('hex')
        I = hmac.new(c, data, hashlib.sha512).digest()
    else:
        I = hmac.new(c, K + rev_hex(int_to_hex(n,4)).decode('hex'), hashlib.sha512).digest()
        
    k_n = number_to_string( (string_to_number(I[0:32]) + string_to_number(k)) % order , order )
    c_n = I[32:]
    return k_n, c_n


def CKD_prime(K, c, n):
    import hmac
    from ecdsa.util import string_to_number, number_to_string
    order = generator_secp256k1.order()

    if n & BIP32_PRIME: raise

    K_public_key = ecdsa.VerifyingKey.from_string( K, curve = SECP256k1 )
    K_compressed = GetPubKey(K_public_key.pubkey,True)

    I = hmac.new(c, K_compressed + rev_hex(int_to_hex(n,4)).decode('hex'), hashlib.sha512).digest()

    curve = SECP256k1
    pubkey_point = string_to_number(I[0:32])*curve.generator + K_public_key.pubkey.point
    public_key = ecdsa.VerifyingKey.from_public_point( pubkey_point, curve = SECP256k1 )

    K_n = public_key.to_string()
    K_n_compressed = GetPubKey(public_key.pubkey,True)
    c_n = I[32:]

    return K_n, K_n_compressed, c_n



class ElectrumSequence:
    """  Privatekey(type,n) = Master_private_key + H(n|S|type)  """

    def __init__(self, mpk, mpk2 = None, mpk3 = None):
        self.mpk = mpk
        self.mpk2 = mpk2
        self.mpk3 = mpk3
        self.master_public_key = ecdsa.VerifyingKey.from_string( mpk.decode('hex'), curve = SECP256k1 )

    @classmethod
    def mpk_from_seed(klass, seed):
        curve = SECP256k1
        secexp = klass.stretch_key(seed)
        master_private_key = ecdsa.SigningKey.from_secret_exponent( secexp, curve = SECP256k1 )
        master_public_key = master_private_key.get_verifying_key().to_string().encode('hex')
        return master_public_key

    @classmethod
    def stretch_key(self,seed):
        oldseed = seed
        for i in range(100000):
            seed = hashlib.sha256(seed + oldseed).digest()
        return string_to_number( seed )

    def get_sequence(self, sequence, mpk):
        for_change, n = sequence
        return string_to_number( Hash( "%d:%d:"%(n,for_change) + mpk.decode('hex') ) )

    def get_address(self, sequence):
        if not self.mpk2:
            pubkey = self.get_pubkey(sequence)
            address = public_key_to_bc_address( pubkey.decode('hex') )
        elif not self.mpk3:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk = self.mpk2)
            address = Transaction.multisig_script([pubkey1, pubkey2], 2)["address"]
        else:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk = self.mpk2)
            pubkey3 = self.get_pubkey(sequence, mpk = self.mpk3)
            address = Transaction.multisig_script([pubkey1, pubkey2, pubkey3], 2)["address"]
        return address

    def get_pubkey(self, sequence, mpk=None):
        curve = SECP256k1
        if mpk is None: mpk = self.mpk
        z = self.get_sequence(sequence, mpk)
        master_public_key = self.master_public_key
        pubkey_point = master_public_key.pubkey.point + z*curve.generator
        public_key2 = ecdsa.VerifyingKey.from_public_point( pubkey_point, curve = SECP256k1 )
        return '04' + public_key2.to_string().encode('hex')

    def get_private_key_from_stretched_exponent(self, sequence, secexp):
        order = generator_secp256k1.order()
        secexp = ( secexp + self.get_sequence(sequence, self.mpk) ) % order
        pk = number_to_string( secexp, generator_secp256k1.order() )
        compressed = False
        return SecretToASecret( pk, compressed )
        
    def get_private_key(self, sequence, seed):
        secexp = self.stretch_key(seed)
        return self.get_private_key_from_stretched_exponent(sequence, secexp)

    def get_private_keys(self, sequence_list, seed):
        secexp = self.stretch_key(seed)
        return [ self.get_private_key_from_stretched_exponent( sequence, secexp) for sequence in sequence_list]

    def check_seed(self, seed):
        curve = SECP256k1
        secexp = self.stretch_key(seed)
        master_private_key = ecdsa.SigningKey.from_secret_exponent( secexp, curve = SECP256k1 )
        master_public_key = master_private_key.get_verifying_key().to_string().encode('hex')
        if master_public_key != self.mpk:
            print_error('invalid password (mpk)')
            raise BaseException('Invalid password')
        return True

    def get_input_info(self, sequence):
        if not self.mpk2:
            pk_addr = self.get_address(sequence)
            redeemScript = None
        elif not self.mpk3:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence,mpk=self.mpk2)
            pk_addr = public_key_to_bc_address( pubkey1.decode('hex') ) # we need to return that address to get the right private key
            redeemScript = Transaction.multisig_script([pubkey1, pubkey2], 2)['redeemScript']
        else:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk=self.mpk2)
            pubkey3 = self.get_pubkey(sequence, mpk=self.mpk3)
            pk_addr = public_key_to_bc_address( pubkey1.decode('hex') ) # we need to return that address to get the right private key
            redeemScript = Transaction.multisig_script([pubkey1, pubkey2, pubkey3], 2)['redeemScript']
        return pk_addr, redeemScript




class BIP32Sequence:

    def __init__(self, mpk, mpk2 = None, mpk3 = None):
        self.mpk = mpk
        self.mpk2 = mpk2
        self.mpk3 = mpk3
    
    @classmethod
    def mpk_from_seed(klass, seed):
        master_secret, master_chain, master_public_key, master_public_key_compressed = bip32_init(seed)
        return master_public_key.encode('hex'), master_chain.encode('hex')

    def get_pubkey(self, sequence, mpk = None):
        if not mpk: mpk = self.mpk
        master_public_key, master_chain = mpk
        K = master_public_key.decode('hex')
        chain = master_chain.decode('hex')
        for i in sequence:
            K, K_compressed, chain = CKD_prime(K, chain, i)
        return K_compressed.encode('hex')

    def get_address(self, sequence):
        if not self.mpk2:
            pubkey = self.get_pubkey(sequence)
            address = public_key_to_bc_address( pubkey.decode('hex') )
        elif not self.mpk3:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk = self.mpk2)
            address = Transaction.multisig_script([pubkey1, pubkey2], 2)["address"]
        else:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk = self.mpk2)
            pubkey3 = self.get_pubkey(sequence, mpk = self.mpk3)
            address = Transaction.multisig_script([pubkey1, pubkey2, pubkey3], 2)["address"]
        return address

    def get_private_key(self, sequence, seed):
        master_secret, master_chain, master_public_key, master_public_key_compressed = bip32_init(seed)
        chain = master_chain
        k = master_secret
        for i in sequence:
            k, chain = CKD(k, chain, i)
        return SecretToASecret(k, True)

    def get_private_keys(self, sequence_list, seed):
        return [ self.get_private_key( sequence, seed) for sequence in sequence_list]

    def check_seed(self, seed):
        master_secret, master_chain, master_public_key, master_public_key_compressed = bip32_init(seed)
        assert self.mpk == (master_public_key.encode('hex'), master_chain.encode('hex'))

    def get_input_info(self, sequence):
        if not self.mpk2:
            pk_addr = self.get_address(sequence)
            redeemScript = None
        elif not self.mpk3:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk=self.mpk2)
            pk_addr = public_key_to_bc_address( pubkey1.decode('hex') ) # we need to return that address to get the right private key
            redeemScript = Transaction.multisig_script([pubkey1, pubkey2], 2)['redeemScript']
        else:
            pubkey1 = self.get_pubkey(sequence)
            pubkey2 = self.get_pubkey(sequence, mpk=self.mpk2)
            pubkey3 = self.get_pubkey(sequence, mpk=self.mpk3)
            pk_addr = public_key_to_bc_address( pubkey1.decode('hex') ) # we need to return that address to get the right private key
            redeemScript = Transaction.multisig_script([pubkey1, pubkey2, pubkey3], 2)['redeemScript']
        return pk_addr, redeemScript

################################## transactions

MIN_RELAY_TX_FEE = 10000

class Transaction:
    
    def __init__(self, raw):
        self.raw = raw
        self.deserialize()
        self.inputs = self.d['inputs']
        self.outputs = self.d['outputs']
        self.outputs = map(lambda x: (x['address'],x['value']), self.outputs)
        self.input_info = None
        self.is_complete = True
        
    @classmethod
    def from_io(klass, inputs, outputs):
        raw = klass.serialize(inputs, outputs, for_sig = -1) # for_sig=-1 means do not sign
        self = klass(raw)
        self.is_complete = False
        self.inputs = inputs
        self.outputs = outputs
        extras = []
        for i in self.inputs:
            e = { 'txid':i['tx_hash'], 'vout':i['index'], 'scriptPubKey':i.get('raw_output_script') }
            extras.append(e)
        self.input_info = extras
        return self

    def __str__(self):
        return self.raw

    @classmethod
    def multisig_script(klass, public_keys, num=None):
        n = len(public_keys)
        if num is None: num = n
        # supports only "2 of 2", and "2 of 3" transactions
        assert num <= n and n in [2,3]
    
        if num==2:
            s = '52'
        elif num == 3:
            s = '53'
        else:
            raise
    
        for k in public_keys:
            s += var_int(len(k)/2)
            s += k
        if n==2:
            s += '52'
        elif n==3:
            s += '53'
        else:
            raise
        s += 'ae'

        out = { "address": hash_160_to_bc_address(hash_160(s.decode('hex')), 5), "redeemScript":s }
        return out

    @classmethod
    def serialize( klass, inputs, outputs, for_sig = None ):

        s  = int_to_hex(1,4)                                         # version
        s += var_int( len(inputs) )                                  # number of inputs
        for i in range(len(inputs)):
            txin = inputs[i]
            s += txin['tx_hash'].decode('hex')[::-1].encode('hex')   # prev hash
            s += int_to_hex(txin['index'],4)                         # prev index

            if for_sig is None:
                pubkeysig = txin.get('pubkeysig')
                if pubkeysig:
                    pubkey, sig = pubkeysig[0]
                    sig = sig + chr(1)                               # hashtype
                    script  = op_push( len(sig))
                    script += sig.encode('hex')
                    script += op_push( len(pubkey))
                    script += pubkey.encode('hex')
                else:
                    signatures = txin['signatures']
                    pubkeys = txin['pubkeys']
                    script = '00'                                    # op_0
                    for sig in signatures:
                        sig = sig + '01'
                        script += op_push(len(sig)/2)
                        script += sig

                    redeem_script = klass.multisig_script(pubkeys,2).get('redeemScript')
                    script += op_push(len(redeem_script)/2)
                    script += redeem_script

            elif for_sig==i:
                if txin.get('redeemScript'):
                    script = txin['redeemScript']                    # p2sh uses the inner script
                else:
                    script = txin['raw_output_script']               # scriptsig
            else:
                script=''
            s += var_int( len(script)/2 )                            # script length
            s += script
            s += "ffffffff"                                          # sequence

        s += var_int( len(outputs) )                                 # number of outputs
        for output in outputs:
            addr, amount = output
            s += int_to_hex( amount, 8)                              # amount
            addrtype, hash_160 = bc_address_to_hash_160(addr)
            if addrtype == chain.pubkey_version:
                script = '76a9'                                      # op_dup, op_hash_160
                script += '14'                                       # push 0x14 bytes
                script += hash_160.encode('hex')
                script += '88ac'                                     # op_equalverify, op_checksig
            elif addrtype == chain.script_version:
                script = 'a9'                                        # op_hash_160
                script += '14'                                       # push 0x14 bytes
                script += hash_160.encode('hex')
                script += '87'                                       # op_equal
            else:
                raise
            
            s += var_int( len(script)/2 )                           #  script length
            s += script                                             #  script
        s += int_to_hex(0,4)                                        #  lock time
        if for_sig is not None and for_sig != -1:
            s += int_to_hex(1, 4)                                   #  hash type
        return s


    def for_sig(self,i):
        return self.serialize(self.inputs, self.outputs, for_sig = i)


    def hash(self):
        return Hash(self.raw.decode('hex') )[::-1].encode('hex')

    def sign(self, private_keys):
        import deserialize

        for i in range(len(self.inputs)):
            txin = self.inputs[i]
            tx_for_sig = self.serialize( self.inputs, self.outputs, for_sig = i )

            if txin.get('redeemScript'):
                # 1 parse the redeem script
                num, redeem_pubkeys = deserialize.parse_redeemScript(txin.get('redeemScript'))
                self.inputs[i]["pubkeys"] = redeem_pubkeys

                # build list of public/private keys
                keypairs = {}
                for sec in private_keys.values():
                    compressed = is_compressed(sec)
                    pkey = regenerate_key(sec)
                    pubkey = GetPubKey(pkey.pubkey, compressed)
                    keypairs[ pubkey.encode('hex') ] = sec

                # list of already existing signatures
                signatures = txin.get("signatures",[])
                print_error("signatures",signatures)

                for pubkey in redeem_pubkeys:
                    public_key = ecdsa.VerifyingKey.from_string(pubkey[2:].decode('hex'), curve = SECP256k1)
                    for s in signatures:
                        try:
                            public_key.verify_digest( s.decode('hex')[:-1], Hash( tx_for_sig.decode('hex') ), sigdecode = ecdsa.util.sigdecode_der)
                            break
                        except ecdsa.keys.BadSignatureError:
                            continue
                    else:
                        # check if we have a key corresponding to the redeem script
                        if pubkey in keypairs.keys():
                            # add signature
                            sec = keypairs[pubkey]
                            compressed = is_compressed(sec)
                            pkey = regenerate_key(sec)
                            secexp = pkey.secret
                            private_key = ecdsa.SigningKey.from_secret_exponent( secexp, curve = SECP256k1 )
                            public_key = private_key.get_verifying_key()
                            sig = private_key.sign_digest( Hash( tx_for_sig.decode('hex') ), sigencode = ecdsa.util.sigencode_der )
                            assert public_key.verify_digest( sig, Hash( tx_for_sig.decode('hex') ), sigdecode = ecdsa.util.sigdecode_der)
                            signatures.append( sig.encode('hex') )
                        
                # for p2sh, pubkeysig is a tuple (may be incomplete)
                self.inputs[i]["signatures"] = signatures
                print_error("signatures",signatures)
                self.is_complete = len(signatures) == num

            else:
                sec = private_keys[txin['address']]
                compressed = is_compressed(sec)
                pkey = regenerate_key(sec)
                secexp = pkey.secret

                private_key = ecdsa.SigningKey.from_secret_exponent( secexp, curve = SECP256k1 )
                public_key = private_key.get_verifying_key()
                pkey = EC_KEY(secexp)
                pubkey = GetPubKey(pkey.pubkey, compressed)
                sig = private_key.sign_digest( Hash( tx_for_sig.decode('hex') ), sigencode = ecdsa.util.sigencode_der )
                assert public_key.verify_digest( sig, Hash( tx_for_sig.decode('hex') ), sigdecode = ecdsa.util.sigdecode_der)

                self.inputs[i]["pubkeysig"] = [(pubkey, sig)]
                self.is_complete = True

        self.raw = self.serialize( self.inputs, self.outputs )


    def deserialize(self):
        import deserialize
        vds = deserialize.BCDataStream()
        vds.write(self.raw.decode('hex'))
        self.d = deserialize.parse_Transaction(vds)
        return self.d
    

    def has_address(self, addr):
        found = False
        for txin in self.inputs:
            if addr == txin.get('address'): 
                found = True
                break
        for txout in self.outputs:
            if addr == txout[0]:
                found = True
                break
        return found


    def get_value(self, addresses, prevout_values):
        # return the balance for that tx
        is_relevant = False
        is_send = False
        is_pruned = False
        is_partial = False
        v_in = v_out = v_out_mine = 0

        for item in self.inputs:
            addr = item.get('address')
            if addr in addresses:
                is_send = True
                is_relevant = True
                key = item['prevout_hash']  + ':%d'%item['prevout_n']
                value = prevout_values.get( key )
                if value is None:
                    is_pruned = True
                else:
                    v_in += value
            else:
                is_partial = True

        if not is_send: is_partial = False
                    
        for item in self.outputs:
            addr, value = item
            v_out += value
            if addr in addresses:
                v_out_mine += value
                is_relevant = True

        if is_pruned:
            # some inputs are mine:
            fee = None
            if is_send:
                v = v_out_mine - v_out
            else:
                # no input is mine
                v = v_out_mine

        else:
            v = v_out_mine - v_in

            if is_partial:
                # some inputs are mine, but not all
                fee = None
                is_send = v < 0
            else:
                # all inputs are mine
                fee = v_out - v_in

        return is_relevant, is_send, v, fee

    def as_dict(self):
        import json
        out = {
            "hex":self.raw,
            "complete":self.is_complete
            }
        if not self.is_complete:
            extras = []
            for i in self.inputs:
                e = { 'txid':i['tx_hash'], 'vout':i['index'],
                      'scriptPubKey':i.get('raw_output_script'),
                      'KeyID':i.get('KeyID'),
                      'redeemScript':i.get('redeemScript'),
                      'signatures':i.get('signatures'),
                      'pubkeys':i.get('pubkeys'),
                      }
                extras.append(e)
            self.input_info = extras

            if self.input_info:
                out['input_info'] = json.dumps(self.input_info).replace(' ','')

        return out


    def requires_fee(self, verifier):
        # see https://en.bitcoin.it/wiki/Transaction_fees
        threshold = 57600000
        size = len(self.raw)/2
        if size >= 10000: 
            return True

        for o in self.outputs:
            value = o[1]
            if value < 1000000:
                return True
        sum = 0
        for i in self.inputs:
            age = verifier.get_confirmations(i["tx_hash"])[0]
            sum += i["value"] * age
        priority = sum / size
        print_error(priority, threshold)
        return priority < threshold 

class HighDefWallet:

    def __init__(self, secret, chain, mpk, mpk_compressed):
        self.secret, self.chain, self.mpk, self.mpk_compressed = \
            secret, chain, mpk, mpk_compressed

    @property
    def key_id(self):
        return hash_160(self.mpk_compressed)

    @property
    def address(self):
        return hash_160_to_bc_address(self.key_id)

    @property
    def secret_key(self):
        return SecretToASecret(self.secret, True)

    def branch(self, n):
        secret, chain = CKD(self.secret, self.chain, n)
        mpk, mpk_compressed = get_pubkeys_from_secret(secret)
        return HighDefWallet(secret, chain, mpk, mpk_compressed)

    def branch_prime(self, n):
        return self.branch(n + BIP32_PRIME)

    @staticmethod
    def root(seed):
        args = bip32_init(seed)
        return HighDefWallet(*args)

class EllipticCurveKey:

    def __init__(self):
        self._secret = None
        self._private_key = None
        self._public_key = None

    def new_key_pair(self):
        secret = os.urandom(32)
        self.set_secret(secret)

    def set_secret(self, secret):
        self._secret = secret
        secret = string_to_number(secret)
        pkey = EC_KEY(secret)

        #sec = "L5KhaMvPYRW1ZoFmRjUtxxPypQ94m6BcDrPhqArhggdaTbbAFJEF"
        #pkey = obelisk.regenerate_key(sec)

        secexp = pkey.secret
        self._private_key = ecdsa.SigningKey.from_secret_exponent(
            secexp, curve=SECP256k1)
        self._public_key = self._private_key.get_verifying_key()

    def sign(self, digest):
        return self._private_key.sign_digest_deterministic(
            digest, hashfunc=hashlib.sha256,
            sigencode=ecdsa.util.sigencode_der)

    def verify(self, digest, signature):
        return self._public_key.verify_digest(
            signature, digest, sigdecode=ecdsa.util.sigdecode_der)

    @property
    def secret(self):
        return self._secret

    @property
    def public_key(self):
        return GetPubKey(self._public_key.pubkey, True)

    @property
    def key_id(self):
        return hash_160(self.public_key)

    @property
    def address(self):
        return hash_160_to_bc_address(self.key_id)

def output_script(address):
    addrtype, hash_160 = bc_address_to_hash_160(address)
    assert addrtype == chain.pubkey_version
    script = '\x76\xa9'                 # op_dup, op_hash_160
    script += '\x14'                    # push 0x14 bytes
    script += hash_160
    script += '\x88\xac'                # op_equalverify, op_checksig
    return script

def input_script(signature, public_key):
    script = op_push(len(signature)).decode("hex")
    script += signature
    script += op_push(len(public_key)).decode("hex")
    script += public_key
    return script

def sign_transaction_input(tx, input_index, key):
    sighash = generate_signature_hash(tx, input_index, key.address)
    # Add sighash::all to end of signature.
    signature = key.sign(sighash) + "\x01"
    public_key = key.public_key
    tx.inputs[input_index].script = input_script(signature, public_key)

def copy_tx(tx):
    # This is a hack.
    raw_tx = tx.serialize()
    return models.Transaction.deserialize(raw_tx)

def generate_signature_hash(parent_tx, input_index, prevout_address):
    script_code = output_script(prevout_address)
    tx = copy_tx(parent_tx)
    if input_index >= len(tx.inputs):
        return None
    for input in tx.inputs:
        input.script = ""
    tx.inputs[input_index].script = script_code
    raw_tx = tx.serialize() + "\x01\x00\x00\x00"
    return Hash(raw_tx)

def _derive_y_from_x(x, is_even):
    alpha = (pow(x, 3, _p)  + _a * x + _b) % _p
    beta = numbertheory.modular_sqrt(alpha, _p)
    if is_even == bool(beta & 1):
        return _p - beta
    return beta

def decompress_public_key(public_key):
    prefix = public_key[0]
    if prefix == "\x04":
        return public_key
    assert prefix == "\x02" or prefix == "\x03"
    x = int("0x" + public_key[1:].encode("hex"), 16)
    y = _derive_y_from_x(x, prefix == "\x02")
    key = '04' + \
          '%064x' % x + \
          '%064x' % y
    return key.decode("hex")

def diffie_hellman(e, Q):
    Q = decompress_public_key(Q)
    curve = SECP256k1
    public_key = ecdsa.VerifyingKey.from_string(Q[1:], curve=curve)
    point = public_key.pubkey.point
    #e_int = int("0x" + e.encode("hex"), 16)
    e_int = string_to_number(e)
    point = e_int * point
    # convert x point to bytes
    result = "\x03" + ("%x" % point.x()).decode("hex")
    assert len(result) == 33
    return result

def convert_point(Q):
    Q = decompress_public_key(Q)[1:]
    assert len(Q) == 64
    Q_x = Q[:32]
    Q_y = Q[32:]
    assert len(Q_x) == 32
    assert len(Q_y) == 32
    Q_x = string_to_number(Q_x)
    Q_y = string_to_number(Q_y)
    curve = curve_secp256k1
    return ecdsa.ellipticcurve.Point(curve, Q_x, Q_y, ec_order)

def point_add(Q, c):
    Q = convert_point(Q)
    c = string_to_number(c)
    return Q + c * generator_secp256k1

def get_point_pubkey(point, compressed=False):
    if compressed:
        if point.y() & 1:
            key = '03' + '%064x' % point.x()
        else:
            key = '02' + '%064x' % point.x()
    else:
        key = '04' + \
              '%064x' % point.x() + \
              '%064x' % point.y()
    return key.decode('hex')

def add_mod_n(d, c):
    assert len(d) == 32
    # Truncate prefix byte
    order = generator_secp256k1.order()
    d = string_to_number(d)
    c = string_to_number(c)
    return number_to_string((d + c) % order, order)


########NEW FILE########
__FILENAME__ = client
import struct
from decimal import Decimal

from twisted.internet import reactor

from zmqbase import ClientBase

import bitcoin
import models
import serialize
import error_code

def unpack_error(data):
    value = struct.unpack_from('<I', data, 0)[0]
    return error_code.error_code.name_from_id(value)

def pack_block_index(index):
    if type(index) == str:
        assert len(index) == 32
        return serialize.ser_hash(index)
    elif type(index) == int:
        return struct.pack('<I', index)
    else:
        raise ValueError("Unknown index type")

class ObeliskOfLightClient(ClientBase):
    valid_messages = ['fetch_block_header', 'fetch_history', 'subscribe',
        'fetch_last_height', 'fetch_transaction', 'fetch_spend',
        'fetch_transaction_index', 'fetch_block_transaction_hashes',
        'fetch_block_height', 'update', 'renew']

    subscribed = 0
    # Command implementations
    def renew_address(self, address):
        address_version, address_hash = \
            bitcoin.bc_address_to_hash_160(address)
        # prepare parameters
        data = struct.pack('B', address_version)          # address version
        data += address_hash[::-1]               # address

        # run command
        self.send_command('address.renew', data)
        # renew triggered again on response
        reactor.callLater(120, self.renew_address, address)

    def subscribe_address(self, address, notification_cb=None, cb=None):
        address_version, address_hash = \
            bitcoin.bc_address_to_hash_160(address)
        # prepare parameters
        data = struct.pack('B', address_version)          # address version
        data += address_hash[::-1]               # address

        # run command
        self.send_command('address.subscribe', data, cb)
        if notification_cb:
            self._subscriptions['address'][address_hash] = notification_cb
        reactor.callLater(120, self.renew_address, address)

    def fetch_block_header(self, index, cb):
        """Fetches the block header by height."""
        data = pack_block_index(index)
        self.send_command('blockchain.fetch_block_header', data, cb)

    def fetch_history(self, address, cb, from_height=0):
        """Fetches the output points, output values, corresponding input point
        spends and the block heights associated with a Bitcoin address.
        The returned history is a list of rows with the following fields:
     
            output
            output_height
            value
            spend
            spend_height

        If an output is unspent then the input spend hash will be equivalent
        to null_hash.

        Summing the list of values for unspent outpoints gives the balance
        for an address.
        """
        address_version, address_hash = \
            bitcoin.bc_address_to_hash_160(address)
        # prepare parameters
        data = struct.pack('B', address_version)    # address version
        data += address_hash[::-1]                  # address
        data += struct.pack('<I', from_height)      # from_height

        # run command
        self.send_command('address.fetch_history', data, cb)

    def fetch_last_height(self, cb):
        """Fetches the height of the last block in our blockchain."""
        self.send_command('blockchain.fetch_last_height', cb=cb)

    def fetch_transaction(self, tx_hash, cb):
        """Fetches a transaction by hash."""
        data = serialize.ser_hash(tx_hash)
        self.send_command('blockchain.fetch_transaction', data, cb)

    def fetch_spend(self, outpoint, cb):
        """Fetches a corresponding spend of an output."""
        data = outpoint.serialize()
        self.send_command('blockchain.fetch_spend', data, cb)

    def fetch_transaction_index(self, tx_hash, cb):
        """Fetch the block height that contains a transaction and its index
        within a block."""
        data = serialize.ser_hash(tx_hash)
        self.send_command('blockchain.fetch_transaction_index', data, cb)

    def fetch_block_transaction_hashes(self, index, cb):
        """Fetches list of transaction hashes in a block by block hash."""
        data = pack_block_index(index)
        self.send_command('blockchain.fetch_block_transaction_hashes',
            data, cb)

    def fetch_block_height(self, blk_hash, cb):
        """Fetches the height of a block given its hash."""
        data = serialize.ser_hash(blk_hash)
        self.send_command('blockchain.fetch_block_height', data, cb)

    # receive handlers
    def _on_fetch_block_header(self, data):
        error = unpack_error(data)
        assert len(data[4:]) == 80
        header = models.BlockHeader.deserialize(data[4:])
        return (error, header)

    def _on_fetch_history(self, data):
        error = unpack_error(data)
        # parse results
        rows = self.unpack_table("<32sIIQ32sII", data, 4)
        return (error, rows)

    def _on_fetch_last_height(self, data):
        error = unpack_error(data)
        height = struct.unpack('<I', data[4:])[0]
        return (error, height)

    def _on_fetch_transaction(self, data):
        error = unpack_error(data)
        tx = serialize.deser_tx(data[4:])
        return (error, tx)

    def _on_fetch_spend(self, data):
        error = unpack_error(data)
        spend = serialize.deser_output_point(data[4:])
        return (error, spend)

    def _on_fetch_transaction_index(self, data):
        error = unpack_error(data)
        height, index = struct.unpack("<II", data[4:])
        return (error, height, index)

    def _on_fetch_block_transaction_hashes(self, data):
        error = unpack_error(data)
        rows = self.unpack_table("32s", data, 4)
        hashes = [row[0][::-1] for row in rows]
        return (error, hashes)

    def _on_fetch_block_height(self, data):
        error = unpack_error(data)
        height = struct.unpack('<I', data[4:])[0]
        return (error, height)
        
    def _on_subscribe(self, data):
        self.subscribed += 1
        error = unpack_error(data)
        if error:
            print "Error subscribing"
        if not self.subscribed%1000:
            print "Subscribed ok", self.subscribed
        return (error, True)

    def _on_update(self, data):
        address_version = struct.unpack_from('B', data, 0)[0]
        address_hash = data[1:21][::-1]
        address = bitcoin.hash_160_to_bc_address(address_hash, address_version)

        height = struct.unpack_from('I', data, 21)[0]
        block_hash = data[25:57]
        tx = data[57:]

        if address_hash in self._subscriptions['address']:
            self._subscriptions['address'][address_hash](address_version, address_hash, height, block_hash, tx)

    def _on_renew(self, data):
        self.subscribed += 1
        error = unpack_error(data)
        if error:
            print "Error subscribing"
        if not self.subscribed%1000:
            print "Renew ok", self.subscribed


########NEW FILE########
__FILENAME__ = config
class ChainParameters(object):
    def __init__(self, magic_bytes, pubkey_version, script_version, wif_version, protocol_port):
        self.magic_bytes = magic_bytes
        self.pubkey_version = pubkey_version
        self.script_version = script_version
        self.wif_version = wif_version
        self.protocol_port = protocol_port

testnet_chain = ChainParameters(0x0709110b, 0x6F, 0xC4, 0xEF, 18333)
mainnet_chain = ChainParameters(0xd9b4bef9, 0x00, 0x05, 0x80, 8333)

ENABLE_TESTNET = False

if ENABLE_TESTNET:
    chain = testnet_chain
else:
    chain = mainnet_chain

########NEW FILE########
__FILENAME__ = deserialize
# this code comes from ABE. it can probably be simplified
#
#

from bitcoin import public_key_to_bc_address, hash_160_to_bc_address, hash_encode, hash_160
from util import print_error
#import socket
import time
import struct

#
# Workalike python implementation of Bitcoin's CDataStream class.
#
import struct
import StringIO
import mmap

class SerializationError(Exception):
    """ Thrown when there's a problem deserializing or serializing """

class BCDataStream(object):
    def __init__(self):
        self.input = None
        self.read_cursor = 0

    def clear(self):
        self.input = None
        self.read_cursor = 0

    def write(self, bytes):  # Initialize with string of bytes
        if self.input is None:
            self.input = bytes
        else:
            self.input += bytes

    def map_file(self, file, start):  # Initialize with bytes from file
        self.input = mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ)
        self.read_cursor = start

    def seek_file(self, position):
        self.read_cursor = position
        
    def close_file(self):
        self.input.close()

    def read_string(self):
        # Strings are encoded depending on length:
        # 0 to 252 :  1-byte-length followed by bytes (if any)
        # 253 to 65,535 : byte'253' 2-byte-length followed by bytes
        # 65,536 to 4,294,967,295 : byte '254' 4-byte-length followed by bytes
        # ... and the Bitcoin client is coded to understand:
        # greater than 4,294,967,295 : byte '255' 8-byte-length followed by bytes of string
        # ... but I don't think it actually handles any strings that big.
        if self.input is None:
            raise SerializationError("call write(bytes) before trying to deserialize")

        try:
            length = self.read_compact_size()
        except IndexError:
            raise SerializationError("attempt to read past end of buffer")

        return self.read_bytes(length)

    def write_string(self, string):
        # Length-encoded as with read-string
        self.write_compact_size(len(string))
        self.write(string)

    def read_bytes(self, length):
        try:
            result = self.input[self.read_cursor:self.read_cursor+length]
            self.read_cursor += length
            return result
        except IndexError:
            raise SerializationError("attempt to read past end of buffer")

        return ''

    def read_boolean(self): return self.read_bytes(1)[0] != chr(0)
    def read_int16(self): return self._read_num('<h')
    def read_uint16(self): return self._read_num('<H')
    def read_int32(self): return self._read_num('<i')
    def read_uint32(self): return self._read_num('<I')
    def read_int64(self): return self._read_num('<q')
    def read_uint64(self): return self._read_num('<Q')

    def write_boolean(self, val): return self.write(chr(1) if val else chr(0))
    def write_int16(self, val): return self._write_num('<h', val)
    def write_uint16(self, val): return self._write_num('<H', val)
    def write_int32(self, val): return self._write_num('<i', val)
    def write_uint32(self, val): return self._write_num('<I', val)
    def write_int64(self, val): return self._write_num('<q', val)
    def write_uint64(self, val): return self._write_num('<Q', val)

    def read_compact_size(self):
        size = ord(self.input[self.read_cursor])
        self.read_cursor += 1
        if size == 253:
            size = self._read_num('<H')
        elif size == 254:
            size = self._read_num('<I')
        elif size == 255:
            size = self._read_num('<Q')
        return size

    def write_compact_size(self, size):
        if size < 0:
            raise SerializationError("attempt to write size < 0")
        elif size < 253:
            self.write(chr(size))
        elif size < 2**16:
            self.write('\xfd')
            self._write_num('<H', size)
        elif size < 2**32:
            self.write('\xfe')
            self._write_num('<I', size)
        elif size < 2**64:
            self.write('\xff')
            self._write_num('<Q', size)

    def _read_num(self, format):
        (i,) = struct.unpack_from(format, self.input, self.read_cursor)
        self.read_cursor += struct.calcsize(format)
        return i

    def _write_num(self, format, num):
        s = struct.pack(format, num)
        self.write(s)

#
# enum-like type
# From the Python Cookbook, downloaded from http://code.activestate.com/recipes/67107/
#
import types, string, exceptions

class EnumException(exceptions.Exception):
    pass

class Enumeration:
    def __init__(self, name, enumList):
        self.__doc__ = name
        lookup = { }
        reverseLookup = { }
        i = 0
        uniqueNames = [ ]
        uniqueValues = [ ]
        for x in enumList:
            if type(x) == types.TupleType:
                x, i = x
            if type(x) != types.StringType:
                raise EnumException, "enum name is not a string: " + x
            if type(i) != types.IntType:
                raise EnumException, "enum value is not an integer: " + i
            if x in uniqueNames:
                raise EnumException, "enum name is not unique: " + x
            if i in uniqueValues:
                raise EnumException, "enum value is not unique for " + x
            uniqueNames.append(x)
            uniqueValues.append(i)
            lookup[x] = i
            reverseLookup[i] = x
            i = i + 1
        self.lookup = lookup
        self.reverseLookup = reverseLookup
    def __getattr__(self, attr):
        if not self.lookup.has_key(attr):
            raise AttributeError
        return self.lookup[attr]
    def whatis(self, value):
        return self.reverseLookup[value]


# This function comes from bitcointools, bct-LICENSE.txt.
def long_hex(bytes):
    return bytes.encode('hex_codec')

# This function comes from bitcointools, bct-LICENSE.txt.
def short_hex(bytes):
    t = bytes.encode('hex_codec')
    if len(t) < 11:
        return t
    return t[0:4]+"..."+t[-4:]



def parse_TxIn(vds):
    d = {}
    d['prevout_hash'] = hash_encode(vds.read_bytes(32))
    d['prevout_n'] = vds.read_uint32()
    scriptSig = vds.read_bytes(vds.read_compact_size())
    d['sequence'] = vds.read_uint32()

    if scriptSig:
        pubkeys, signatures, address = get_address_from_input_script(scriptSig)
    else:
        pubkeys = []
        signatures = []
        address = None
    
    d['address'] = address
    d['signatures'] = signatures
    d['pubkeys'] = pubkeys

    return d


def parse_TxOut(vds, i):
    d = {}
    d['value'] = vds.read_int64()
    scriptPubKey = vds.read_bytes(vds.read_compact_size())
    d['address'] = get_address_from_output_script(scriptPubKey)
    d['raw_output_script'] = scriptPubKey.encode('hex')
    d['index'] = i
    return d


def parse_Transaction(vds):
    d = {}
    start = vds.read_cursor
    d['version'] = vds.read_int32()
    n_vin = vds.read_compact_size()
    d['inputs'] = []
    for i in xrange(n_vin):
        d['inputs'].append(parse_TxIn(vds))
    n_vout = vds.read_compact_size()
    d['outputs'] = []
    for i in xrange(n_vout):
        d['outputs'].append(parse_TxOut(vds, i))
    d['lockTime'] = vds.read_uint32()
    return d

def parse_redeemScript(bytes):
    dec = [ x for x in script_GetOp(bytes.decode('hex')) ]

    # 2 of 2
    match = [ opcodes.OP_2, opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4, opcodes.OP_2, opcodes.OP_CHECKMULTISIG ]
    if match_decoded(dec, match):
        pubkeys = [ dec[1][1].encode('hex'), dec[2][1].encode('hex') ]
        return 2, pubkeys

    # 2 of 3
    match = [ opcodes.OP_2, opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4, opcodes.OP_3, opcodes.OP_CHECKMULTISIG ]
    if match_decoded(dec, match):
        pubkeys = [ dec[1][1].encode('hex'), dec[2][1].encode('hex'), dec[3][1].encode('hex') ]
        return 2, pubkeys



opcodes = Enumeration("Opcodes", [
    ("OP_0", 0), ("OP_PUSHDATA1",76), "OP_PUSHDATA2", "OP_PUSHDATA4", "OP_1NEGATE", "OP_RESERVED",
    "OP_1", "OP_2", "OP_3", "OP_4", "OP_5", "OP_6", "OP_7",
    "OP_8", "OP_9", "OP_10", "OP_11", "OP_12", "OP_13", "OP_14", "OP_15", "OP_16",
    "OP_NOP", "OP_VER", "OP_IF", "OP_NOTIF", "OP_VERIF", "OP_VERNOTIF", "OP_ELSE", "OP_ENDIF", "OP_VERIFY",
    "OP_RETURN", "OP_TOALTSTACK", "OP_FROMALTSTACK", "OP_2DROP", "OP_2DUP", "OP_3DUP", "OP_2OVER", "OP_2ROT", "OP_2SWAP",
    "OP_IFDUP", "OP_DEPTH", "OP_DROP", "OP_DUP", "OP_NIP", "OP_OVER", "OP_PICK", "OP_ROLL", "OP_ROT",
    "OP_SWAP", "OP_TUCK", "OP_CAT", "OP_SUBSTR", "OP_LEFT", "OP_RIGHT", "OP_SIZE", "OP_INVERT", "OP_AND",
    "OP_OR", "OP_XOR", "OP_EQUAL", "OP_EQUALVERIFY", "OP_RESERVED1", "OP_RESERVED2", "OP_1ADD", "OP_1SUB", "OP_2MUL",
    "OP_2DIV", "OP_NEGATE", "OP_ABS", "OP_NOT", "OP_0NOTEQUAL", "OP_ADD", "OP_SUB", "OP_MUL", "OP_DIV",
    "OP_MOD", "OP_LSHIFT", "OP_RSHIFT", "OP_BOOLAND", "OP_BOOLOR",
    "OP_NUMEQUAL", "OP_NUMEQUALVERIFY", "OP_NUMNOTEQUAL", "OP_LESSTHAN",
    "OP_GREATERTHAN", "OP_LESSTHANOREQUAL", "OP_GREATERTHANOREQUAL", "OP_MIN", "OP_MAX",
    "OP_WITHIN", "OP_RIPEMD160", "OP_SHA1", "OP_SHA256", "OP_HASH160",
    "OP_HASH256", "OP_CODESEPARATOR", "OP_CHECKSIG", "OP_CHECKSIGVERIFY", "OP_CHECKMULTISIG",
    "OP_CHECKMULTISIGVERIFY",
    ("OP_SINGLEBYTE_END", 0xF0),
    ("OP_DOUBLEBYTE_BEGIN", 0xF000),
    "OP_PUBKEY", "OP_PUBKEYHASH",
    ("OP_INVALIDOPCODE", 0xFFFF),
])


def script_GetOp(bytes):
    i = 0
    while i < len(bytes):
        vch = None
        opcode = ord(bytes[i])
        i += 1
        if opcode >= opcodes.OP_SINGLEBYTE_END:
            opcode <<= 8
            opcode |= ord(bytes[i])
            i += 1

        if opcode <= opcodes.OP_PUSHDATA4:
            nSize = opcode
            if opcode == opcodes.OP_PUSHDATA1:
                nSize = ord(bytes[i])
                i += 1
            elif opcode == opcodes.OP_PUSHDATA2:
                (nSize,) = struct.unpack_from('<H', bytes, i)
                i += 2
            elif opcode == opcodes.OP_PUSHDATA4:
                (nSize,) = struct.unpack_from('<I', bytes, i)
                i += 4
            vch = bytes[i:i+nSize]
            i += nSize

        yield (opcode, vch, i)


def script_GetOpName(opcode):
    return (opcodes.whatis(opcode)).replace("OP_", "")


def decode_script(bytes):
    result = ''
    for (opcode, vch, i) in script_GetOp(bytes):
        if len(result) > 0: result += " "
        if opcode <= opcodes.OP_PUSHDATA4:
            result += "%d:"%(opcode,)
            result += short_hex(vch)
        else:
            result += script_GetOpName(opcode)
    return result


def match_decoded(decoded, to_match):
    if len(decoded) != len(to_match):
        return False;
    for i in range(len(decoded)):
        if to_match[i] == opcodes.OP_PUSHDATA4 and decoded[i][0] <= opcodes.OP_PUSHDATA4 and decoded[i][0]>0:
            continue  # Opcodes below OP_PUSHDATA4 all just push data onto stack, and are equivalent.
        if to_match[i] != decoded[i][0]:
            return False
    return True

def get_address_from_input_script(bytes):
    try:
        decoded = [ x for x in script_GetOp(bytes) ]
    except:
        # coinbase transactions raise an exception
        print_error("cannot find address in input script", bytes.encode('hex'))
        return [], [], "(None)"

    # non-generated TxIn transactions push a signature
    # (seventy-something bytes) and then their public key
    # (65 bytes) onto the stack:
    match = [ opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4 ]
    if match_decoded(decoded, match):
        return [decoded[1][1].encode('hex')], [decoded[0][1].encode('hex')], public_key_to_bc_address(decoded[1][1])

    # p2sh transaction, 2 of n
    match = [ opcodes.OP_0 ]
    while len(match) < len(decoded):
        match.append(opcodes.OP_PUSHDATA4)

    if match_decoded(decoded, match):

        redeemScript = decoded[-1][1]
        num = len(match) - 2
        signatures = map(lambda x:x[1].encode('hex'), decoded[1:-1])
        
        dec2 = [ x for x in script_GetOp(redeemScript) ]

        # 2 of 2
        match2 = [ opcodes.OP_2, opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4, opcodes.OP_2, opcodes.OP_CHECKMULTISIG ]
        if match_decoded(dec2, match2):
            pubkeys = [ dec2[1][1].encode('hex'), dec2[2][1].encode('hex') ]
            return pubkeys, signatures, hash_160_to_bc_address(hash_160(redeemScript), 5)
 
        # 2 of 3
        match2 = [ opcodes.OP_2, opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4, opcodes.OP_PUSHDATA4, opcodes.OP_3, opcodes.OP_CHECKMULTISIG ]
        if match_decoded(dec2, match2):
            pubkeys = [ dec2[1][1].encode('hex'), dec2[2][1].encode('hex'), dec2[3][1].encode('hex') ]
            return pubkeys, signatures, hash_160_to_bc_address(hash_160(redeemScript), 5)

    print_error("cannot find address in input script", bytes.encode('hex'))
    return [], [], "(None)"



def get_address_from_output_script(bytes):
    decoded = [ x for x in script_GetOp(bytes) ]

    # The Genesis Block, self-payments, and pay-by-IP-address payments look like:
    # 65 BYTES:... CHECKSIG
    match = [ opcodes.OP_PUSHDATA4, opcodes.OP_CHECKSIG ]
    if match_decoded(decoded, match):
        return public_key_to_bc_address(decoded[0][1])

    # Pay-by-Bitcoin-address TxOuts look like:
    # DUP HASH160 20 BYTES:... EQUALVERIFY CHECKSIG
    match = [ opcodes.OP_DUP, opcodes.OP_HASH160, opcodes.OP_PUSHDATA4, opcodes.OP_EQUALVERIFY, opcodes.OP_CHECKSIG ]
    if match_decoded(decoded, match):
        return hash_160_to_bc_address(decoded[2][1])

    # p2sh
    match = [ opcodes.OP_HASH160, opcodes.OP_PUSHDATA4, opcodes.OP_EQUAL ]
    if match_decoded(decoded, match):
        return hash_160_to_bc_address(decoded[1][1],5)

    return "(None)"



########NEW FILE########
__FILENAME__ = error_code

class obelisk_exception(Exception):
    pass


class error_code(object):
    
    service_stopped = 1
    operation_failed = 2

    # blockchain errors
    not_found = 3
    duplicate = 4
    unspent_output = 5
    unsupported_payment_type = 6

    # network errors
    resolve_failed = 7
    network_unreachable = 8
    address_in_use = 9
    listen_failed = 10
    accept_failed = 11
    bad_stream = 12
    channel_timeout = 13

    # transaction pool
    blockchain_reorganized = 14
    pool_filled = 15

    # validate tx
    coinbase_transaction = 16
    is_not_standard = 17
    double_spend = 18
    input_not_found = 19

    # check_transaction()
    empty_transaction = 20
    output_value_overflow = 21
    invalid_coinbase_script_size = 22
    previous_output_null = 23

    # validate block
    previous_block_invalid = 24

    # check_block()
    size_limits = 25
    proof_of_work = 26
    futuristic_timestamp = 27
    first_not_coinbase = 28
    extra_coinbases = 29
    too_many_sigs = 30
    merkle_mismatch = 31

    # accept_block()
    incorrect_proof_of_work = 32
    timestamp_too_early = 33
    non_final_transaction = 34
    checkpoints_failed = 35
    old_version_block = 36
    coinbase_height_mismatch = 37

    # connect_block()
    duplicate_or_spent = 38
    validate_inputs_failed = 39
    fees_out_of_range = 40
    coinbase_too_large = 41

    @staticmethod
    def name_from_id(id):
        for key, value in error_code.__dict__.iteritems():
            if value == id:
                return key
        return None


########NEW FILE########
__FILENAME__ = models
import bitcoin
import struct
import serialize

class BlockHeader:

    def __init__(self):
        self.height = None

    @classmethod
    def deserialize(cls, raw):
        assert len(raw) == 80
        self = cls()
        self.version = struct.unpack('<I', raw[:4])[0]
        self.previous_block_hash = raw[4:36][::-1]
        assert len(self.previous_block_hash) == 32
        self.merkle = raw[36:68][::-1]
        assert len(self.merkle) == 32
        self.timestamp, self.bits, self.nonce = struct.unpack('<III', raw[68:])
        return self

    @property
    def hash(self):
        data = struct.pack('<I', self.version)
        data += self.previous_block_hash[::-1]
        data += self.merkle[::-1]
        data += struct.pack('<III', self.timestamp, self.bits, self.nonce)
        return bitcoin.Hash(data)[::-1]

    def __repr__(self):
        return '<BlockHeader %s>' % (self.hash.encode("hex"),)

class OutPoint(object):
    def __init__(self):
        self.hash = None
        self.index = None

    def is_null(self):
        return (len(self.hash) == 0) and (self.index == 0xffffffff)

    def __repr__(self):
        return "OutPoint(hash=%s, index=%i)" % (self.hash.encode("hex"), self.index)

    def serialize(self):
        return serialize.ser_output_point(self)

    @staticmethod
    def deserialize(bytes):
        return serialize.deser_output_point(bytes)

class TxOut(object):
    def __init__(self):
        self.value = None
        self.script = ""

    def __repr__(self):
        return "TxOut(value=%i.%08i script=%s)" % (self.value // 100000000, self.value % 100000000, self.script.encode("hex"))

    def serialize(self):
        return serialize.ser_txout(self)

    @staticmethod
    def deserialize(bytes):
        return serialize.deser_txout(bytes)


class TxIn(object):
    def __init__(self):
        self.previous_output = OutPoint()
        self.script = ""
        self.sequence = 0xffffffff

    def is_final(self):
        return self.sequence == 0xffffffff

    def __repr__(self):
        return "TxIn(previous_output=%s script=%s sequence=%i)" % (repr(self.previous_output), self.script.encode("hex"), self.sequence)

    def serialize(self):
        return serialize.ser_txin(self)

    @staticmethod
    def deserialize(bytes):
        return serialize.deser_txin(bytes)

class Transaction:
    def __init__(self):
        self.version = 1
        self.locktime = 0
        self.inputs = []
        self.outputs = []

    def is_final(self):
        for tin in self.vin:
            if not tin.is_final():
                return False
        return True
    def is_coinbase(self):
        return len(self.vin) == 1 and self.vin[0].prevout.is_null()

    def __repr__(self):
        return "Transaction(version=%i inputs=%s outputs=%s locktime=%i)" % (self.version, repr(self.inputs), repr(self.outputs), self.locktime)

    def serialize(self):
        return serialize.ser_tx(self)

    @staticmethod
    def deserialize(bytes):
        return serialize.deser_tx(bytes)


########NEW FILE########
__FILENAME__ = numbertheory

def inverse_mod( a, m ):
  """Inverse of a mod m."""

  if a < 0 or m <= a: a = a % m

  # From Ferguson and Schneier, roughly:

  c, d = a, m
  uc, vc, ud, vd = 1, 0, 0, 1
  while c != 0:
    q, c, d = divmod( d, c ) + ( c, )
    uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc

  # At this point, d is the GCD, and ud*a+vd*m = d.
  # If d == 1, this means that ud is a inverse.

  assert d == 1
  if ud > 0: return ud
  else: return ud + m

# from http://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python/

def modular_sqrt(a, p):
    """ Find a quadratic residue (mod p) of 'a'. p
    must be an odd prime.

    Solve the congruence of the form:
    x^2 = a (mod p)
    And returns x. Note that p - x is also a root.

    0 is returned is no square root exists for
    these a and p.

    The Tonelli-Shanks algorithm is used (except
    for some simple cases in which the solution
    is known from an identity). This algorithm
    runs in polynomial time (unless the
    generalized Riemann hypothesis is false).
    """
    # Simple cases
    #
    if legendre_symbol(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return p
    elif p % 4 == 3:
        return pow(a, (p + 1) // 4, p)

    # Partition p-1 to s * 2^e for an odd s (i.e.
    # reduce all the powers of 2 from p-1)
    #
    s = p - 1
    e = 0
    while s % 2 == 0:
        s /= 2
        e += 1

    # Find some 'n' with a legendre symbol n|p = -1.
    # Shouldn't take long.
    #
    n = 2
    while legendre_symbol(n, p) != -1:
        n += 1

    # Here be dragons!
    # Read the paper "Square roots from 1; 24, 51,
    # 10 to Dan Shanks" by Ezra Brown for more
    # information
    #

    # x is a guess of the square root that gets better
    # with each iteration.
    # b is the "fudge factor" - by how much we're off
    # with the guess. The invariant x^2 = ab (mod p)
    # is maintained throughout the loop.
    # g is used for successive powers of n to update
    # both a and b
    # r is the exponent - decreases with each update
    #
    x = pow(a, (s + 1) // 2, p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e

    while True:
        t = b
        m = 0
        for m in xrange(r):
            if t == 1:
                break
            t = pow(t, 2, p)

        if m == 0:
            return x

        gs = pow(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m

def legendre_symbol(a, p):
    """ Compute the Legendre symbol a|p using
    Euler's criterion. p is a prime, a is
    relatively prime to p (if p divides
    a, then a|p = 0)

    Returns 1 if a has a square root modulo
    p, -1 otherwise.
    """
    ls = pow(a, (p - 1) // 2, p)
    return -1 if ls == p - 1 else ls

########NEW FILE########
__FILENAME__ = serialize
__author__ = 'bobalot'

import struct
import io
import hashlib
from binascii import hexlify, unhexlify
from hashlib import sha256
import models

from error_code import error_code, obelisk_exception

# Py3 compatibility
import sys
bchr = chr
if sys.version > '3':
    bchr = lambda x: bytes([x])


def deser_uint32(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    return struct.unpack(b"<I", f.read(4))[0]


def ser_uint32(u):
    rs = b""
    rs += struct.pack(b"<I", u & 0xFFFFFFFF)
    return rs


def deser_string(f):
    nit = struct.unpack(b"<B", f.read(1))[0]
    if nit == 253:
        nit = struct.unpack(b"<H", f.read(2))[0]
    elif nit == 254:
        nit = struct.unpack(b"<I", f.read(4))[0]
    elif nit == 255:
        nit = struct.unpack(b"<Q", f.read(8))[0]
    return f.read(nit)

def ser_string(s):
    if len(s) < 253:
        return bchr(len(s)) + s
    elif len(s) < 0x10000:
        return bchr(253) + struct.pack(b"<H", len(s)) + s
    elif len(s) < 0x100000000:
        return bchr(254) + struct.pack(b"<I", len(s)) + s
    return bchr(255) + struct.pack(b"<Q", len(s)) + s

def deser_hash(f):
    return f.read(32)

def ser_hash(h):
    return h[::-1]

def deser_uint256(f):
    r = 0
    for i in range(8):
        t = struct.unpack(b"<I", f.read(4))[0]
        r += t << (i * 32)
    return r

def ser_uint256(u):
    rs = b""
    for i in range(8):
        rs += struct.pack(b"<I", u & 0xFFFFFFFF)
        u >>= 32
    return rs

def ser_uint160(u):
    rs = b""
    for i in range(5):
        rs += struct.pack(b"<I", u & 0xFFFFFFFF)
        u >>= 32
    return rs

def uint160_from_str(s):
    r = 0
    t = struct.unpack(b"<IIIII", s[:20])
    for i in range(5):
        r += t[i] << (i * 32)
    return r

def uint256_from_str(s):
    r = 0
    t = struct.unpack(b"<IIIIIIII", s[:32])
    for i in range(8):
        r += t[i] << (i * 32)
    return r

def uint256_from_compact(c):
    nbytes = (c >> 24) & 0xFF
    v = (c & 0xFFFFFF) << (8 * (nbytes - 3))
    return v

def uint256_to_shortstr(u):
    s = "%064x" % (u,)
    return s[:16]

def deser_variable_uint(f):
    length = struct.unpack(b"<B", f.read(1))[0]
    if length < 0xfd:
        return length
    elif length == 0xfd:
        return struct.unpack(b"<H", f.read(2))[0]
    elif length == 0xfe:
        return struct.unpack(b"<I", f.read(4))[0]
    return struct.unpack(b"<Q", f.read(8))[0]

def deser_vector(f, c, arg1=None):
    count = deser_variable_uint(f)
    r = []
    for i in range(count):
        #if arg1 is not None:
        #    t = c(arg1)
        #else:
        #    t = c()

        if c is models.TxIn:
            t = deser_txin(f)
        elif c is models.TxOut:
            t = deser_txout(f)
        elif c is models.Transaction:
            t = deser_tx(f)
        else:
            raise NotImplementedError

        r.append(t)
    return r

def ser_vector(l):
    r = b""
    if len(l) < 253:
        r = bchr(len(l))
    elif len(l) < 0x10000:
        r = bchr(253) + struct.pack(b"<H", len(l))
    elif len(l) < 0x100000000:
        r = bchr(254) + struct.pack(b"<I", len(l))
    else:
        r = bchr(255) + struct.pack(b"<Q", len(l))
    for i in l:

        if type(i) is models.TxIn:
            r += ser_txin(i)
        elif type(i) is models.TxOut:
            r += ser_txout(i)
        elif type(i) is models.Transaction:
            r += ser_tx(i)
        else:
            raise NotImplementedError

    return r

def deser_uint256_vector(f):
    nit = struct.unpack(b"<B", f.read(1))[0]
    if nit == 253:
        nit = struct.unpack(b"<H", f.read(2))[0]
    elif nit == 254:
        nit = struct.unpack(b"<I", f.read(4))[0]
    elif nit == 255:
        nit = struct.unpack(b"<Q", f.read(8))[0]
    r = []
    for i in range(nit):
        t = deser_uint256(f)
        r.append(t)
    return r

def ser_uint256_vector(l):
    r = b""
    if len(l) < 253:
        r = bchr(len(l))
    elif len(s) < 0x10000:
        r = bchr(253) + struct.pack(b"<H", len(l))
    elif len(s) < 0x100000000:
        r = bchr(254) + struct.pack(b"<I", len(l))
    else:
        r = bchr(255) + struct.pack(b"<Q", len(l))
    for i in l:
        r += ser_uint256(i)
    return r

def deser_string_vector(f):
    nit = struct.unpack(b"<B", f.read(1))[0]
    if nit == 253:
        nit = struct.unpack(b"<H", f.read(2))[0]
    elif nit == 254:
        nit = struct.unpack(b"<I", f.read(4))[0]
    elif nit == 255:
        nit = struct.unpack(b"<Q", f.read(8))[0]
    r = []
    for i in range(nit):
        t = deser_string(f)
        r.append(t)
    return r

def ser_string_vector(l):
    r = b""
    if len(l) < 253:
        r = bchr(len(l))
    elif len(s) < 0x10000:
        r = bchr(253) + struct.pack(b"<H", len(l))
    elif len(s) < 0x100000000:
        r = bchr(254) + struct.pack(b"<I", len(l))
    else:
        r = bchr(255) + struct.pack(b"<Q", len(l))
    for sv in l:
        r += ser_string(sv)
    return r

def deser_int_vector(f):
    nit = struct.unpack(b"<B", f.read(1))[0]
    if nit == 253:
        nit = struct.unpack(b"<H", f.read(2))[0]
    elif nit == 254:
        nit = struct.unpack(b"<I", f.read(4))[0]
    elif nit == 255:
        nit = struct.unpack(b"<Q", f.read(8))[0]
    r = []
    for i in range(nit):
        t = struct.unpack(b"<i", f.read(4))[0]
        r.append(t)
    return r

def ser_int_vector(l):
    r = b""
    if len(l) < 253:
        r = bchr(len(l))
    elif len(s) < 0x10000:
        r = bchr(253) + struct.pack(b"<H", len(l))
    elif len(s) < 0x100000000:
        r = bchr(254) + struct.pack(b"<I", len(l))
    else:
        r = bchr(255) + struct.pack(b"<Q", len(l))
    for i in l:
        r += struct.pack(b"<i", i)
    return r

def Hash(s):
    return uint256_from_str(hashlib.sha256(hashlib.sha256(s).digest()).digest())

def Hash160(s):
    h = hashlib.new('ripemd160')
    h.update(hashlib.sha256(s).digest())
    return uint160_from_str(h.digest())


def ser_destination(destination):
    if destination is None:
        serialized = ""
    else:
        try:
            serialized = unhexlify(destination)
        except TypeError:
            serialized = destination

    return serialized

def deser_txout(f):
    txout = models.TxOut()
    txout.value = struct.unpack(b"<q", f.read(8))[0]
    txout.script = deser_string(f)
    return txout

def ser_txout(txout):
    r = b""
    r += struct.pack(b"<q", txout.value)
    r += ser_string(txout.script)
    return r


def deser_output_point(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    outpoint = models.OutPoint()
    outpoint.hash = deser_hash(f)
    outpoint.index = deser_uint32(f.read(4))
    return outpoint


def ser_output_point(outpoint):
    r = b""
    r += ser_hash(outpoint.hash)
    r += ser_uint32(outpoint.index)
    return r


def deser_txin(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    txin = models.TxIn()
    txin.previous_output = deser_output_point(f)
    txin.script = deser_string(f)
    txin.sequence = deser_uint32(f)
    return txin

def ser_txin(txin):
    r = b""
    r += ser_output_point(txin.previous_output)
    r += ser_string(txin.script)
    r += ser_uint32(txin.sequence)
    return r


def deser_block_header(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    h = models.BlockHeader()

    h.version = deser_uint32(f.read(4))
    h.previous_block_hash = f.read(32)
    h.merkle = f.read(32)
    h.timestamp = deser_uint32(f.read(4))
    h.bits = deser_uint32(f.read(4))
    h.nonce = deser_uint32(f.read(4))

    return h


def ser_block_header(block_header):
    output = b""
    output += ser_uint32(block_header.version)
    output += block_header.previous_block_hash
    output += block_header.merkle
    output += ser_uint32(block_header.timestamp)
    output += ser_uint32(block_header.bits)
    output += ser_uint32(block_header.nonce)

    return output


def deser_tx(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    tx = models.Transaction()
    tx.version = deser_uint32(f.read(4))
    tx.inputs = deser_vector(f, models.TxIn)
    tx.outputs = deser_vector(f, models.TxOut)
    tx.locktime = deser_uint32(f)
    return tx


def ser_tx(tx):
    r = b""
    r += ser_uint32(tx.version)
    r += ser_vector(tx.inputs)
    r += ser_vector(tx.outputs)
    r += ser_uint32(tx.locktime)
    return r


def deser_block(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    blk = models.Block()

    blk.header = deser_block_header(f)
    blk.transactions = deser_vector(f, models.Transaction)
    return Block

def ser_block(blk):
    r = b""
    r += ser_block_header(blk.header)
    r += ser_vector(blk.transaction_list, models.Transaction)

    return r


    #tx.version = struct.unpack(b"<i", f.read(4))[0]
    #tx.vin = deser_vector(f, TxIn)
    #tx.vout = deser_vector(f, TxOut)
    #tx.nLockTime = struct.unpack(b"<I", f.read(4))[0]


def deser_history_row(f):

    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    hr = models.history_row()


    hr.output_hash = f.read(32)
    hr.output_index = deser_uint32(f)
    hr.output_height = deser_uint32(f)

    hr.value = struct.unpack(b"<q", f.read(8))[0]
    hr.spend_hash = f.read(32)
    hr.spend_index = deser_uint32(f)
    hr.spend_height = deser_uint32(f)

    return hr

def ser_history_row(hr):
    r = b""

    r += hr.output_hash
    r += ser_uint32(hr.output_index)
    r += ser_uint32(hr.output_height)

    r += struct.pack(b"<q", hr.value & 0xFFFFFFFFFFFFFFFF)
    r += hr.spend_hash
    r += ser_uint32(hr.spend_index)
    r += ser_uint32(hr.spend_height)

    return hr


def deser_history_row_list(bytes):
    row_bytes = 88
    num_rows = len(bytes)/88

    assert(len(bytes) % 88 == 0)

    history_list = []

    for i in range(num_rows):
        history_list.append(deser_history_row(bytes[i*88, i*88+88]))

    return history_list


def dsha256(data):
    return sha256(sha256(data).digest()).digest()[::-1]


def checksum(data):
    return sha256(sha256(data).digest()).digest()[:4]


def hash_block_header(blk_head):
    if type(blk_head) is models.Block:
        blk_head = blk_head.header

    serial = ser_block_header(blk_head)

    return dsha256(serial)


def hash_transaction(tx):
    if type(tx) is not models.Transaction:
        return False

    serial = ser_tx(tx)

    return dsha256(serial)


def ser_data(command, data):
    # This requires command at the moment, for no reason.
    # Fix this.
    #from models import commands
    #if command not in commands:
    #    raise NotImplementedError

    if type(data) is int:
        return ser_uint32(data)
    elif type(data) is str:
        return data

    elif type(data) is tuple:
        r = b""

        for element in data:

            r += ser_data(command, element)

        return r

def deser_address_update(f):
    if type(f) is not io.BytesIO:
        f = io.BytesIO(f)

    update = models.address_update()
    update.address_version_byte = f.read(1)
    update.address_hash = f.read(20)

    update.height = deser_uint32(f)
    update.tx = deser_tx(f)

    return update


#command_data_type = \
#        {"blockchain.fetch_transaction",
#            "blockchain.fetch_last_height",
#            "blockchain.fetch_block_header",
#            "blockchain.fetch_block_transaction_hashes",
#            "transaction_pool.validate",
#            "protocol.broadcast_transaction",
#            "address.fetch_history"]


# deserialize and remove the ec here, this leaves all the other functions able to
# do deserialization on normal bitcoin serials.
def deser_data(command, data_bytes):
    if command == "blockchain.fetch_transaction":
        return data_bytes[:4], deser_tx(data_bytes[4:])

    elif command == "blockchain.fetch_last_height":
        return data_bytes[:4], deser_uint32(data_bytes[4:])

    elif command == "blockchain.fetch_block_header":
        return data_bytes[:4], deser_block_header(data_bytes[4:])

    elif command == "blockchain.fetch_block_transaction_hashes":
        hash_list = []

        print hexlify(data_bytes[4:])

        assert((len(data_bytes)-4) % 32 == 0)

        f = io.BytesIO(data_bytes)
        ec = f.read(4)

        for i in range(data_bytes/32):
            hash_list.append(f.read(32))

        return ec, hash_list

    elif command == "address.fetch_history":
        # history row is 88 bytes long. Assert there is nothing else
        assert((len(data_bytes)-4) % 88 == 0)

        history_list = []

        # use bytesio, as this will probably be a long message
        f = io.BytesIO(data_bytes)
        ec = f.read(4)

        for i in range(len(data_bytes) / 88):
            history_list.append(deser_history_row(f))

        return ec, history_list

    elif command == "address.subscribe":
        if len(data_bytes) == 4:
            ec = deser_uint32(data_bytes)

        return ec, None

    elif command == "address.update":
        # No error code in address.update
        f = io.BytesIO(data_bytes)

        ec = 0
        return ec, deser_address_update(f)








########NEW FILE########
__FILENAME__ = transaction
# Given a list of unspent outputs, return the optimal subset to satisfy
# a given amount (and return the change).

class OutputInfo(object):

    def __init__(self, point, value):
        self.point = point
        self.value = value

    def __repr__(self):
        return "OutputInfo(point=%s, value=%i)" % (self.point, self.value)

class SelectOutputsResult:

    def __init__(self):
        self._points = []
        self.change = 0

    def add_point(self, point):
        self._points.append(point)

    @property
    def points(self):
        return self._points

    def __repr__(self):
        return "SelectOutputsResult(points=%s, change=%i)" % (
            self._points, self.change)

def min_nonthrow(values, key):
    assert values
    if len(values) == 1:
        return values[0]
    return min(greaters, key=ascend_compare)

def select_outputs(unspent, min_value):
    if not unspent:
        return None
    greaters = [output for output in unspent if not output.value < min_value]
    if greaters:
        ascend_compare = lambda info_a, info_b: \
            info_a.value < info_b.value
        min_greater = min_nonthrow(greaters, key=ascend_compare)
        # Return result with single outpoint
        result = SelectOutputsResult()
        result.add_point(min_greater)
        result.change = min_greater.value - min_value
        return result
    # Not found in greaters. Try several lessers instead.
    # Rearrange them from biggest to smallest. We want to use the least
    # amount of inputs as possible.
    lessers = [output for output in unspent if output.value < min_value]
    # Descending sort
    lessers.sort(key=lambda output: output.value, reverse=True)
    accum = 0
    result = SelectOutputsResult()
    for output in lessers:
        result.add_point(output)
        accum += output.value
        if accum >= min_value:
            result.change = accum - min_value
            return result
    return None


########NEW FILE########
__FILENAME__ = util
import os, sys, re
import platform
import shutil
from datetime import datetime
from decimal import Decimal

is_verbose = True

btc = Decimal('1'+'0'*8)


def to_btc(value):
    return Decimal(value)/btc

def set_verbosity(b):
    global is_verbose
    is_verbose = b

def print_error(*args):
    if not is_verbose: return
    args = [str(item) for item in args]
    sys.stderr.write(" ".join(args) + "\n")
    sys.stderr.flush()

def print_msg(*args):
    # Stringify args
    args = [str(item) for item in args]
    sys.stdout.write(" ".join(args) + "\n")
    sys.stdout.flush()

def print_json(obj):
    import json
    s = json.dumps(obj,sort_keys = True, indent = 4)
    sys.stdout.write(s + "\n")
    sys.stdout.flush()


def check_windows_wallet_migration():
    if platform.release() != "XP":
        if os.path.exists(os.path.join(os.environ["LOCALAPPDATA"], "Electrum")):
            if os.path.exists(os.path.join(os.environ["APPDATA"], "Electrum")):
                print_msg("Two Electrum folders have been found, the default Electrum location for Windows has changed from %s to %s since Electrum 1.7, please check your wallets and fix the problem manually." % (os.environ["LOCALAPPDATA"], os.environ["APPDATA"]))
                sys.exit()
            try:
                shutil.move(os.path.join(os.environ["LOCALAPPDATA"], "Electrum"), os.path.join(os.environ["APPDATA"]))
                print_msg("Your wallet has been moved from %s to %s."% (os.environ["LOCALAPPDATA"], os.environ["APPDATA"]))
            except:
                print_msg("Failed to move your wallet.")
    

def user_dir():
    if "HOME" in os.environ:
        return os.path.join(os.environ["HOME"], ".electrum")
    elif "APPDATA" in os.environ:
        return os.path.join(os.environ["APPDATA"], "Electrum")
    elif "LOCALAPPDATA" in os.environ:
        return os.path.join(os.environ["LOCALAPPDATA"], "Electrum")
    else:
        #raise BaseException("No home directory found in environment variables.")
        return 

def appdata_dir():
    """Find the path to the application data directory; add an electrum folder and return path."""
    if platform.system() == "Windows":
        return os.path.join(os.environ["APPDATA"], "Electrum")
    elif platform.system() == "Linux":
        return os.path.join(sys.prefix, "share", "electrum")
    elif (platform.system() == "Darwin" or
          platform.system() == "DragonFly" or
	  platform.system() == "NetBSD"):
        return "/Library/Application Support/Electrum"
    else:
        raise Exception("Unknown system")


def get_resource_path(*args):
    return os.path.join(".", *args)


def local_data_dir():
    """Return path to the data folder."""
    assert sys.argv
    prefix_path = os.path.dirname(sys.argv[0])
    local_data = os.path.join(prefix_path, "data")
    return local_data


def format_satoshis(x, is_diff=False, num_zeros = 0, decimal_point = 8, whitespaces=False):
    from decimal import Decimal
    s = Decimal(x)
    sign, digits, exp = s.as_tuple()
    digits = map(str, digits)
    while len(digits) < decimal_point + 1:
        digits.insert(0,'0')
    digits.insert(-decimal_point,'.')
    s = ''.join(digits).rstrip('0')
    if sign: 
        s = '-' + s
    elif is_diff:
        s = "+" + s

    p = s.find('.')
    s += "0"*( 1 + num_zeros - ( len(s) - p ))
    if whitespaces:
        s += " "*( 1 + decimal_point - ( len(s) - p ))
        s = " "*( 13 - decimal_point - ( p )) + s 
    return s


# Takes a timestamp and returns a string with the approximation of the age
def age(from_date, since_date = None, target_tz=None, include_seconds=False):
    if from_date is None:
        return "Unknown"

    from_date = datetime.fromtimestamp(from_date)
    if since_date is None:
        since_date = datetime.now(target_tz)

    distance_in_time = since_date - from_date
    distance_in_seconds = int(round(abs(distance_in_time.days * 86400 + distance_in_time.seconds)))
    distance_in_minutes = int(round(distance_in_seconds/60))

    if distance_in_minutes <= 1:
        if include_seconds:
            for remainder in [5, 10, 20]:
                if distance_in_seconds < remainder:
                    return "less than %s seconds ago" % remainder
            if distance_in_seconds < 40:
                return "half a minute ago"
            elif distance_in_seconds < 60:
                return "less than a minute ago"
            else:
                return "1 minute ago"
        else:
            if distance_in_minutes == 0:
                return "less than a minute ago"
            else:
                return "1 minute ago"
    elif distance_in_minutes < 45:
        return "%s minutes ago" % distance_in_minutes
    elif distance_in_minutes < 90:
        return "about 1 hour ago"
    elif distance_in_minutes < 1440:
        return "about %d hours ago" % (round(distance_in_minutes / 60.0))
    elif distance_in_minutes < 2880:
        return "1 day ago"
    elif distance_in_minutes < 43220:
        return "%d days ago" % (round(distance_in_minutes / 1440))
    elif distance_in_minutes < 86400:
        return "about 1 month ago"
    elif distance_in_minutes < 525600:
        return "%d months ago" % (round(distance_in_minutes / 43200))
    elif distance_in_minutes < 1051200:
        return "about 1 year ago"
    else:
        return "over %d years ago" % (round(distance_in_minutes / 525600))




# URL decode
_ud = re.compile('%([0-9a-hA-H]{2})', re.MULTILINE)
urldecode = lambda x: _ud.sub(lambda m: chr(int(m.group(1), 16)), x)

def parse_url(url):
    o = url[8:].split('?')
    address = o[0]
    if len(o)>1:
        params = o[1].split('&')
    else:
        params = []

    amount = label = message = signature = identity = ''
    for p in params:
        k,v = p.split('=')
        uv = urldecode(v)
        if k == 'amount': amount = uv
        elif k == 'message': message = uv
        elif k == 'label': label = uv
        elif k == 'signature':
            identity, signature = uv.split(':')
            url = url.replace('&%s=%s'%(k,v),'')
        else: 
            print k,v

    return address, amount, label, message, signature, identity, url




########NEW FILE########
__FILENAME__ = zmqbase
import sys
import random
import struct

# Broken for ZMQ 4
#try:
#    from zmqproto import ZmqSocket
#except ImportError:
#    from zmq_fallback import ZmqSocket
from zmq_fallback import ZmqSocket

from obelisk.serialize import checksum

SNDMORE = 1

MAX_UINT32 = 4294967295

class ClientBase(object):

    valid_messages = []

    def __init__(self, address, block_address=None, tx_address=None, version=3):
        self._messages = []
        self._tx_messages = []
        self._block_messages = []
        self.zmq_version = version
        self.running = 1
        self._socket = self.setup(address)
        if block_address:
            self._socket_block = self.setup_block_sub(
                block_address, self.on_raw_block)
        if tx_address:
            self._socket_tx = self.setup_transaction_sub(
                tx_address, self.on_raw_transaction)
        self._subscriptions = {'address': {}}

    # Message arrived
    def on_raw_message(self, id, cmd, data):
        res = None
        short_cmd = cmd.split('.')[-1]
        if short_cmd in self.valid_messages:
            res = getattr(self, '_on_'+short_cmd)(data)
        else:
            print "Unknown Message", cmd
        if res:
            self.trigger_callbacks(id, *res)

    def on_raw_block(self, height, hash, header, tx_num, tx_hashes):
        print "block", height, len(tx_hashes)

    def on_raw_transaction(self, hash, transaction):
        print "tx", hash.encode('hex')

    # Base Api
    def send_command(self, command, data='', cb=None):
        tx_id = random.randint(0, MAX_UINT32)

        self.send('', SNDMORE)      # destination
        self.send(command, SNDMORE) # command
        self.send(struct.pack('I', tx_id), SNDMORE) # id (random)
        self.send(data, SNDMORE)    # data

        self.send(checksum(data), 0)    # checksum
        if cb:
            self._subscriptions[tx_id] = cb
        return tx_id

    def trigger_callbacks(self, tx_id, *args):
        if tx_id in self._subscriptions:
            self._subscriptions[tx_id](*args)
            del self._subscriptions[tx_id]

    # Low level zmq abstraction into obelisk frames
    def send(self, *args, **kwargs):
        self._socket.send(*args, **kwargs)

    def frame_received(self, frame, more):
        self._messages.append(frame)
        if not more:
            if not len(self._messages) == 5:
                print "Sequence with wrong messages", len(self._messages)
                print [m.encode("hex") for m in self._messages]
                self._messages = []
                return
            uuid, command, id, data, chksum = self._messages
            self._messages = []
            if checksum(data) == chksum:
                id = struct.unpack('I', id)[0]
                self.on_raw_message(id, command, data)
            else:
                print "bad checksum"

    def block_received(self, frame, more):
        self._block_messages.append(frame)
        if not more:
            nblocks = struct.unpack('Q', self._block_messages[3])[0]
            if not len(self._block_messages) == 4+nblocks:
                print "Sequence with wrong messages", len(self._block_messages), 4+nblocks
                self._block_messages = []
                return
            height, hash, header, tx_num = self._block_messages[:4]
            tx_hashes = self._block_messages[5:]
            if len(tx_num) >= 4:
                tx_num = struct.unpack_from('I', tx_num, 0 )[0]
            else:
                print "wrong tx_num length", len(tx_num), tx_num
                tx_num = struct.unpack('I', tx_num.zfill(4))[0]
            self._block_messages = []
            height = struct.unpack('I', height)[0]
            self._block_cb(height, hash, header, tx_num, tx_hashes)

    def transaction_received(self, frame, more):
        self._tx_messages.append(frame)
        if not more:
            if not len(self._tx_messages) == 2:
                print "Sequence with wrong messages", len(self._tx_messages)
                self._tx_messages = []
                return
            hash, transaction = self._tx_messages
            self._tx_messages = []
            self._tx_cb(hash, transaction)

    def setup(self, address):
        s = ZmqSocket(self.frame_received, self.zmq_version)
        s.connect(address)
        return s

    def setup_block_sub(self, address, cb):
        s = ZmqSocket(self.block_received, self.zmq_version, type='SUB')
        s.connect(address)
        self._block_cb = cb
        return s

    def setup_transaction_sub(self, address, cb):
        s = ZmqSocket(self.transaction_received, self.zmq_version, type='SUB')
        s.connect(address)
        self._tx_cb = cb
        return s

    # Low level packing
    def get_error(data):
        return struct.unpack_from('<I', data, 0)[0]

    def unpack_table(self, row_fmt, data, start=0):
        # get the number of rows
        row_size = struct.calcsize(row_fmt)
        nrows = (len(data)-start)/row_size

        # unpack
        rows = []
        for idx in xrange(nrows):
            offset = start+(idx*row_size)
            row = struct.unpack_from(row_fmt, data, offset)
            rows.append(row)
        return rows


########NEW FILE########
__FILENAME__ = zmq_fallback
import zmq
from twisted.internet import task
from twisted.internet import reactor

class ZmqSocket:

    context = zmq.Context(1)

    def __init__(self, cb, version):
        self._cb = cb

    def connect(self, address):
        self._socket = ZmqSocket.context.socket(zmq.DEALER)
        self._socket.connect(address)
        l = task.LoopingCall(self.poll)
        l.start(0.1)

    def poll(self):
        try:
            data = self._socket.recv(flags=zmq.NOBLOCK)
        except zmq.core.error.ZMQError:
            return
        more = self._socket.getsockopt(zmq.RCVMORE)
        self._cb(data, more)

    def send(self, data, more=0):
        if more:
            more = zmq.SNDMORE
        self._socket.send(data, more)


########NEW FILE########
__FILENAME__ = sx
#!/usr/bin/python
import sys
import subprocess
import os
import shutil

SPACING = " " * 30

command_list = {

"satoshi": (
"UTILITY",
"SATOSHI MATH",
"Convert Bitcoins into Satoshis.",

"""\
Usage: sx satoshi BTC
Convert Bitcoins into Satoshis.\
"""
),

"btc": (
"UTILITY",
"SATOSHI MATH",
"Convert Satoshis into Bitcoins.",

"""\
Usage: sx btc SATOSHIS
Convert Satoshis into Bitcoins.\
"""
),

"showscript": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Show the details of a raw script.",

"""\
Usage: sx showscript
Show the details of a raw script.\
"""
),

"scripthash": (
"OFFLINE KEYS AND ADDRESSES",
"MULTISIG ADDRESSES",
"Create BIP 16 script hash address from raw script hex.",

"""\
Usage: sx scripthash
Create BIP 16 script hash address from raw script hex (from STDIN).

EXAMPLE:

  # generate an address for 2-of-3 multisig transactions
  for n in 1 2 3; do echo 'b220b5bd2909df1d74b71c9e664233bf' | sx genpriv $n > key${n}; done
  sx rawscript 2 [ $(cat key1 | sx pubkey) ] [ $(cat key2 | sx pubkey) ] [ $(cat key3 | sx pubkey) ] 3 checkmultisig | sx scripthash
  33opBmv3oJTXu6rxtzsr571SL2Srtw9Cg8

"""
),

"rawscript": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Create the raw hex representation from a script.",

"""\
Usage: sx rawscript [ARGS]...
Create the raw hex representation from a script.\

EXAMPLE:

  $ sx rawscript dup # translate a single opcode just for demonstration, see OP_DUP in https://en.bitcoin.it/wik
  76

"""
),

"initchain": (
"ONLINE (OBELISK)",
"OBELISK ADMIN",
"Initialize a new blockchain.",

"""\
Usage: sx initchain DIRECTORY
Initialize a new blockchain.\
"""
),

"wallet": (
"EXPERIMENTAL",
"APPS",
"Experimental command line wallet.",

"""\
Usage: sx wallet SEED
This is an experimental prototype.\
"""
),

"monitor": (
"ONLINE (OBELISK)",
"BLOCKCHAIN WATCHING",
"Monitor an address.",

"""\
Usage: sx monitor ADDRESS
Monitor an address.\
"""
),

"validaddr": (
"OFFLINE KEYS AND ADDRESSES",
"BASIC",
"Validate an address.",

"""\
Usage: sx validaddr ADDRESS
Validate an address.\
"""
),

"validtx": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Validate a transaction.",

"""\
Usage: sx validtx FILENAME
Query blockchain whether transaction has been confirmed.\
"""
),

"pubkey": (
"OFFLINE KEYS AND ADDRESSES",
"BASIC",
"See the public part of a private key.",

"""\
Usage: sx pubkey
Read private key from STDIN and output the public key. 
"""
),

"addr": (
"OFFLINE KEYS AND ADDRESSES",
"BASIC",
"See Bitcoin address of a public or private key.",

"""\
Usage: sx addr
Read public or private key from STDIN and output Bitcoin address.\
"""
),

"ripemd-hash": (
"UTILITY",
"HASHES",
"RIPEMD hash data from STDIN.",

"""\
Usage: sx ripemd-hash
RIPEMD hash data from STDIN.\
"""
),

"wrap": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Adds version byte and checksum to hexstring.",

"""\
Usage: sx wrap HEXSTRING VERSION_BYTE <or> echo HEXSTRING | sx wrap VERSION_BYTE
Adds version byte and checksum to hexstring.\
"""
),

"unwrap": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Validates checksum and recovers version byte and original data from hexstring.",

"""\
Usage: sx wrap HEXSTRING VERSION_BYTE <or> echo HEXSTRING | sx wrap VERSION_BYTE
Validates checksum and recovers version byte and original data from hexstring.\
"""
),

"base58-decode": (
"UTILITY",
"FORMAT (BASE 58)",
"Convert from base58 to hex",

"""\
Usage: sx base58-decode B58STRING <or> echo B58STRING | sx base58-decode
Convert from base58 to hex.\
"""
),

"base58-encode": (
"UTILITY",
"FORMAT (BASE 58)",
"Convert from hex to base58",

"""\
Usage: sx base58-encode HEXSTRING <or> echo HEXSTRING | sx base58-encode
Convert from hex to base58.\
"""
),

"base58check-decode": (
"UTILITY",
"FORMAT (BASE58CHECK)",
"Convert from base58check to hex",

"""\
Usage: sx base58check-decode B58STRING <or> echo B58STRING | sx base58check-decode
Convert from base58check to hex.\
"""
),

"base58check-encode": (
"UTILITY",
"FORMAT (BASE58CHECK)",
"Convert from hex to base58check",

"""\
Usage: sx base58check-encode HEXSTRING <or> echo HEXSTRING | sx base58check-encode
Convert from hex to base58check.\
"""
),

"sendtx-obelisk": (
"ONLINE (OBELISK)",
"BLOCKCHAIN UPDATES",
"Send tx to obelisk server.",

"""\
Usage: sx sendtx-obelisk FILENAME
Broadcast the transaction to an obelisk server for the network.

  $ sx sendtx-obelisk txfile.tx
\
"""
),

"sendtx-p2p": (
"ONLINE (BITCOIN P2P)",
"BLOCKCHAIN UPDATES",
"Send tx to bitcoin network.",

"""\
Usage: sx sendtx-p2p FILENAME
Broadcast the transaction to the Bitcoin network.

  $ sx sendtx-p2p txfile.tx
\
"""
),

"sendtx-bci": (
"ONLINE (BLOCKCHAIN.INFO)",
"BLOCKCHAIN UPDATES",
"Send tx to blockchain.info/pushtx.",

"""\
Usage: sx bci-push-tx FILENAME
Push tx to blockchain.info/pushtx.

  $ sx sendtx-bci txfile.tx
\
"""
),

"blke-fetch-transaction": (
"ONLINE (BLOCKEXPLORER.COM)",
"BLOCKCHAIN QUERIES (blockexplorer.com)",
"Fetches a transaction from blockexplorer.com",

"""\
Usage: sx blke-fetch-transaction HASH

Fetches a transaction from blockexplorer.com

  $ sx blke-fetch-transaction HASH
\
"""
),

"genpriv": (
"DEPRECATED",
"ELECTRUM STYLE DETERMINISTIC KEYS AND ADDRESSES",
"Generate a private key deterministically from a seed.",

"""\
Usage: sx genpriv N [CHANGE]
Generate private keys from a wallet seed.

  $ cat wallet.seed | sx genpriv 0
  5Jmb4EYzEqj63rkPwADFY7WyGV2kga3YB1HfDAzg9dHNG57NMPu
  $ cat wallet.seed | sx genpriv 1
  5KjCYpPyxU2e88S57b1naKUsJ1JNjCudkFSQPxqcYyBYgzzahNe
\
"""
),

"genpub": (
"DEPRECATED",
"ELECTRUM STYLE DETERMINISTIC KEYS AND ADDRESSES",
"Generate a public key deterministically from a wallet\n" + SPACING + "seed or master public key.",

"""\
Usage: sx genpub N [CHANGE]
Generate public key from a wallet seed or master public key.
The output is non-deterministic if any other input is used.

  $ cat wallet.seed | sx genpub 0
  040a053d0a42d58b7e34346daae9d40ce33fad5d65bbaa6c615a2b76447734b2c712b5d45de839b2e5e7ac00201cbea3d2d376cfcc7a3f3f508f1e6761f6c271bf
\
"""
),

"genaddr": (
"DEPRECATED",
"ELECTRUM STYLE DETERMINISTIC KEYS AND ADDRESSES",
"Generate a Bitcoin address deterministically from a wallet\n" +
SPACING + "seed or master public key.",

"""\
Usage: sx genaddr N [CHANGE]
Generate Bitcoin addresses from a wallet seed or master public key.
The output is non-deterministic if any other input is used.

  $ cat wallet.seed | sx genaddr 0
  1a4b47AC4ydSnAAcTNH1qozHq2pwJb644
\
"""
),

"qrcode": (
"UTILITY",
"MISC",
"Generate Bitcoin QR codes offline.",

"""\
Usage: sx qrcode

Make sure you have the program 'qrencode' installed first.

  $ sudo apt-get install qrencode
  $ sx qrcode 13Ft7SkreJY9D823NPm4t6D1cBqLYTJtAe qrcode.png
\
"""
),

"fetch-block-header": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Fetch raw block header.",

"""\
Usage: sx fetch-block-header [HASH] [HEIGHT]

The fetch-block-header tool uses a network connection to make requests against
the load balancer backend.\
"""
),

"fetch-last-height": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Fetch the last block height.",

"""\
Usage: sx fetch-last-height

The fetch-last-height tool uses a network connection to make requests against
the load balancer backend.\
"""
),

"bci-fetch-last-height": (
"ONLINE (BLOCKCHAIN.INFO)",
"BLOCKCHAIN QUERIES (blockchain.info)",
"Fetch the last block height using blockchain.info.",

"""\
Usage: sx bci-fetch-last-height

Fetch the last block height using blockchain.info.\
"""
),

"fetch-stealth": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Fetch a stealth information using a network connection to\n" +
SPACING + "make requests against the obelisk load balancer backend.",

"""\
Fetch a stealth information using a network connection to
make requests against the obelisk load balancer backend.

Usage: sx fetch-stealth NUMBER_BITS BITFIELD [FROM_HEIGHT]

Default NUMBER_BITS is 0 (if not specified).

EXAMPLE: 

  $ sx fetch-stealth 2 8bf41c69
\
"""
),

"fetch-transaction": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Fetch a raw transaction using a network connection to\n" +
SPACING + "make requests against the obelisk load balancer backend.",

"""\
Fetch a raw transaction using a network connection to
make requests against the obelisk load balancer backend.

Usage: sx fetch-transaction HASH

EXAMPLE: 

  $ sx fetch-transaction 69735d70ada1be32ff39b49c6fc2390b03e9d5eed8918ed10fe42c8cbabf62d4 # fetches raw data
\
"""
),

"fetch-transaction-index": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Fetch block height and index in block of transaction.",

"""\
Usage: sx fetch-transaction-index HASH

The fetch-transaction-index tool uses a network connection to make requests
against the load balancer backend.\
"""
),

"balance": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Show balance of a Bitcoin address in satoshis.",

"""\
Usage: sx balance [-j] ADDRESS1 [ADDRESS2...]

The balance tool uses a network connection to make requests against the
load balancer backend.

  -j, --json                 Enable json parseable output.

Example:

  $ echo 134HfD2fdeBTohfx8YANxEpsYXsv5UoWyz | sx balance
  Address: 134HfD2fdeBTohfx8YANxEpsYXsv5UoWyz
    Paid balance:    0
    Pending balance: 0
    Total received:  100000
\
"""
),

"history": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Get list of output points, values, and their spends for an\n" +
SPACING + "address. grep can filter for just unspent outputs which can\n" +
SPACING + "be fed into mktx.",

"""\
Usage: sx history [-j] ADDRESS1 [ADDRESS2...]

The history tool uses a network connection to make requests against the
load balancer backend.

  -j, --json                 Enable json parseable output.

Example:

  $ echo 134HfD2fdeBTohfx8YANxEpsYXsv5UoWyz | sx history
  Address: 134HfD2fdeBTohfx8YANxEpsYXsv5UoWyz
    output: 97e06e49dfdd26c5a904670971ccf4c7fe7d9da53cb379bf9b442fc9427080b3:1
    output_height: 247683
    value:  100000
    spend: b7354b8b9cc9a856aedaa349cffa289ae9917771f4e06b2386636b3c073df1b5:0
    spend_height: 247742
\
"""
),

"bci-history": (
"ONLINE (BLOCKCHAIN.INFO)",
"BLOCKCHAIN QUERIES (blockchain.info)",
"Get list of output points, values, and their spends\n" +
SPACING + "from blockchain.info",

"""\
Usage: sx bci-history SATOSHIS
Get list of output points, values and spends using blockchain.info.\
"""
),

"get-utxo": (
"ONLINE (OBELISK)",
"BLOCKCHAIN QUERIES",
"Get enough unspent transaction outputs from a given set of\n" +
SPACING + "addresses to pay a given number of satoshis",

"""\
Usage: sx get-utxo ADDRESS1 ADDRESS2... SATOSHIS
Get enough unspent transaction outputs from a given set of addresses to pay a given number of satoshis\
"""
),

"get-pubkey": (
"OFFLINE KEYS AND ADDRESSES",
"BASIC",
"Get the pubkey of an address if available",

"""\
Usage: sx get-pubkey ADDRESS
Get the pubkey of an address if available\
"""
),

"mktx": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Create an unsigned tx.",

"""\
        Usage: sx mktx FILENAME [-i TXHASH:INDEX]... [-o ADDRESS:VALUE] [-o HEXSCRIPT:VALUE]

  -i, --input TXHASH:INDEX      Add input to transaction.
  -o, --output ADDRESS:VALUE or HEXSCRIPT:VALUE
                                Add output to transaction.

Construct the transaction:

  $ sx mktx txfile.tx -i 97e06e49dfdd26c5a904670971ccf4c7fe7d9da53cb379bf9b442fc9427080b3:1 -o 13Ft7SkreJY9D823NPm4t6D1cBqLYTJtAe:90000

FILENAME denotes the output file. If FILENAME is - (a single dash), then
output is written to stdout.

The VALUE field is in Satoshis.\
"""
),

"wif-to-secret": (
"UTILITY",
"FORMAT (WIF)",
"Convert a Wallet Import Format to secret exponent value.",

"""\
Usage: echo WIF | sx wif-to-secret
\
"""
),

"secret-to-wif": (
"UTILITY",
"FORMAT (WIF)",
"Convert a secret exponent value to Wallet Import Format",

"""\
Usage: echo SECRET | sx secret-to-wif
\
"""
),

"sha256": (
"UTILITY",
"HASHES",
"Perform SHA256 hash of data.",

"""\
Usage: sx sha256 DATA

Perform SHA256 hash of data.\
"""
),

"mpk": (
"DEPRECATED",
"ELECTRUM STYLE DETERMINISTIC KEYS AND ADDRESSES",
"Extract a master public key from a deterministic wallet seed.",

"""\
Usage: sx mpk

Extract a master public key from a deterministic wallet seed.

  $ sx newseed > wallet.seed
  $ cat wallet.seed
  b220b5bd2909df1d74b71c9e664233bf
  $ cat wallet.seed | sx mpk > master_public.key
\
"""
),

"newkey": (
"OFFLINE KEYS AND ADDRESSES",
"BASIC",
"Create a new private key.",

"""\
Usage: sx newkey

  $ sx newkey
  5KPFsatiYrJcvCSRrDbtx61822vZjeGGGx3wu38pQDHRF8eVJ8H
\
"""
),

"newseed": (
"DEPRECATED",
"ELECTRUM STYLE DETERMINISTIC KEYS AND ADDRESSES",
"Create a new deterministic wallet seed.",

"""\
Usage: sx newseed

  $ sx newseed
  b220b5bd2909df1d74b71c9e664233bf
\
"""
),

"sendtx-node": (
"ONLINE (BITCOIN P2P)",
"BLOCKCHAIN UPDATES",
"Send transaction to a single node.",

"""\
Usage: sx sendtx-node FILENAME [HOST] [PORT]

HOST and PORT default to localhost:8333.

Send transaction to one Bitcoin node on localhost port 4009:

  $ sx sendtx-node txfile.tx localhost 4009
\
"""
),

"showblkhead": (
"OFFLINE BLOCKCHAIN",
"HEADERS",
"Show the details of a block header.",

"""\
Usage: sx showblkhead FILENAME

'showblkhead' allows inspecting of block headers.

  $ sx showblkhead headerfile.blk
  hash: 4d25b18ed094ad68f75f21692d8540f45ceb90b240a521b8f191e95d8b6b8bb0
  version: 1  locktime: 0
  Input:
    previous output:
  97e06e49dfdd26c5a904670971ccf4c7fe7d9da53cb379bf9b442fc9427080b3:0
    script:   sequence: 4294967295
  Output:
    value: 90000
    script: dup hash160 [ 18c0bd8d1818f1bf99cb1df2269c645318ef7b73 ] equalverify
  checksig
    address: 13Ft7SkreJY9D823NPm4t6D1cBqLYTJtAe
\
"""
),

"showtx": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Show the details of a transaction.",

"""\
Usage: sx showtx [-j] FILENAME

'showtx' allows inspecting of tx files.

  -j, --json                 Enable json parseable output.

Example:

  $ sx fetch-transaction cd484f683bc99c94948613a7f7254880e9c98cd74f2760a2d2c4e372fda1bc6a | sx showtx
  hash: cd484f683bc99c94948613a7f7254880e9c98cd74f2760a2d2c4e372fda1bc6a
  version: 1
  locktime: 0
  Input:
    previous output: f97367c5dc9e521a4c541327cbff69d118e35a2d0b67f91eb7771741a6374b20:0
    script: [ 3046022100f63b1109e1b04c0a4b5230e6f6c75f5e2a10c16d022cdf93de9b3cc946e6e24a022100ae3da40f05504521f2f3557e736a2d1724d6d1d8c18b66a64990bf1afee78dba01 ] [ 028a2adb719bbf7e9cf0cb868d4f30b10551f2a4402eb2ece9b177b49e68e90511 ]
    sequence: 4294967295
    address: 1NYMePixLjAATLaz55vN7FfTLUfFB23Tt
  Output:
    value: 2676400
    script: dup hash160 [ 6ff00bd374abb3a3f19d1576bb36520b2cb15e2d ] equalverify checksig
    address: 1BCsZziw8Q1sMhxr2DjAR7Rmt1qQvYwXSU
  Output:
    value: 1000000
    script: hash160 [ 0db1635fe975792a9a7b6f2d4061b730478dc6b9 ] equal
    address: 32wRDBezxnazSBxMrMqLWqD1ajwEqnDnMc
\
"""
),

"decode-addr": (
"UTILITY",
"FORMAT (BASE58CHECK)",
"Decode a address from base58check form to internal RIPEMD representation",

"""\
Usage: sx decode-addr ADDRESS
Decode an address to its internal RIPEMD representation.\
"""),

"embed-addr": (
"OFFLINE KEYS AND ADDRESSES",
"BASIC",
"Generate an address used for embedding record of data into the blockchain",

"""\
Usage: sx embed-addr
Generate an address used for embedding record of data into the blockchain.

Example:

  $ cat my_sculpture.jpg | sx embed-addr
  1N9v8AKBqst9MNceV3gLmFKsgkKv1bZcBU

Now send some Bitcoin to that address and it'll be embedded in the blockchain
as a record of the data passed in.
\
"""),

"encode-addr": (
"UTILITY",
"FORMAT (BASE58CHECK)",
"Encode an address from internal RIPEMD representation to base58check form",

"""\
Usage: sx encode-addr HASH [VERSION]
Encode an address to base58check form.\
"""),

"validsig": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Validate a transaction input's signature.",

"""\
Usage: sx validsig FILENAME INDEX SCRIPT_CODE SIGNATURE
Validate a transaction input's signature.\
"""),

"brainwallet": (
"OFFLINE KEYS AND ADDRESSES",
"BRAIN STORAGE",
"Make 256 bit bitcoin private key from an arbitrary passphrase.",

"""\
Usage: sx brainwallet password
       sx brainwallet username password
       sx brainwallet password --algo slowsha
       sx brainwallet username password --algo slowsha
Make 256 bit bitcoin private key from an arbitrary passphrase, using sha256.
Unsafe if passphrase is low in entropy.
See diceware and xkcd correct horse battery staple for advice on entropy and generating a safe brainwallet.\
"""
),

#"sign-transaction": (
#"OFFLINE (work in progress)",
#"SIGNING WALLET",
#"Sign a transaction. Output is suitable for sending to bitcoin network.",

#"""\
#Usage: cat unsigned.tx | sx sign-transaction --wallet=sx.wallet.gpg --gpgkey=~/. 
#       sx brainwallet username password
#       sx brainwallet password --algo slowsha
#       sx brainwallet username password --algo slowsha
#Make a private key from a brainwallet.\
#"""
#),

"set-input": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Set a transaction input.",

"""\
Usage: sx set-input TXFILENAME INPUTINDEX SIGNATURE_AND_PUBKEY_SCRIPT
Set a transaction input.
See sx help sign-input for an example.\
"""),

"sign-input": (
"OFFLINE TRANSACTIONS",
"SCRIPTING",
"Sign a transaction input.",

"""\
Usage: cat secret.key | sx sign-input FILENAME INDEX PREVOUT_SCRIPT

Sign a transaction input.



Note how the input script in the following transaction is empty.

  $ sx mktx txfile.tx -i 97e06e49dfdd26c5a904670971ccf4c7fe7d9da53cb379bf9b442fc9427080b3:0 -o 13Ft7SkreJY9D823NPm4t6D1cBqLYTJtAe:90000
  $ sx showtx txfile.tx
  hash: 4d25b18ed094ad68f75f21692d8540f45ceb90b240a521b8f191e95d8b6b8bb0
  version: 1  locktime: 0
  Input:
    previous output:
  97e06e49dfdd26c5a904670971ccf4c7fe7d9da53cb379bf9b442fc9427080b3:0
    script:   sequence: 4294967295
  Output:
    value: 90000
    script: dup hash160 [ 18c0bd8d1818f1bf99cb1df2269c645318ef7b73 ] equalverify
  checksig
    address: 13Ft7SkreJY9D823NPm4t6D1cBqLYTJtAe

We will now sign the first input using our private key.

  $ echo '5KPFsatiYrJcvCSRrDbtx61822vZjeGGGx3wu38pQDHRF8eVJ8H' > private.key
  $ DECODED_ADDR=$(cat private.key | sx addr | sx decode-addr)
  $ PREVOUT_SCRIPT=$(sx rawscript dup hash160 [ $DECODED_ADDR ] equalverify checksig)
  $ SIGNATURE=$(cat private.key | sx sign-input txfile.tx 0 $PREVOUT_SCRIPT)
  $ SIGNATURE_AND_PUBKEY_SCRIPT=$(sx rawscript [ $SIGNATURE ] [ $(cat private.key | sx pubkey) ])
  $ sx set-input txfile.tx 0 $SIGNATURE_AND_PUBKEY_SCRIPT > txfile.tx.signed  # the first input has index 0

Note how the input script in the following transaction is now filled.

  $ cat txfile.tx.signed | sx showtx
  hash: cc5650c69173e7607c095200f4ff36265f9fbb45e112b60cd467d696b2724488
  version: 1
  locktime: 0
  Input:
    previous output: 97e06e49dfdd26c5a904670971ccf4c7fe7d9da53cb379bf9b442fc9427080b3:0
    script: [ 3045022100b778f7fb270b751491ba7e935a6978eaea2a44795b3f6636ea583939697b1ca102203ce47d3ecb0b7e832114e88e549fce476d4ea120ca1e60c508fe8083889a9cba01 ] [ 04c40cbd64c9c608df2c9730f49b0888c4db1c436e\
  8b2b74aead6c6afbd10428c0adb73f303ae1682415253f4411777224ab477ad098347ddb7e0b94d49261e613 ]
    sequence: 4294967295
    address: 1MyKMeDsom7rYcp69KpbKn4DcyuvLMkLYJ
  Output:
    value: 90000
    script: dup hash160 [ 18c0bd8d1818f1bf99cb1df2269c645318ef7b73 ] equalverify checksig
    address: 13Ft7SkreJY9D823NPm4t6D1cBqLYTJtAe


Now the input script is prepared, and the transaction is signed.

\
"""
),

"mnemonic": (
"OFFLINE KEYS AND ADDRESSES",
"BRAIN STORAGE",
"Make 12 word mnemonic out of 128 bit electrum or bip32 seed.",

"""\
Usage: sx mnemonic

Electrum compatible 12 word seeds.

  $ echo 148f0a1d77e20dbaee3ff920ca40240d | sx mnemonic
  people blonde admit dart couple different truth common alas stumble time cookie
  $ echo "people blonde admit dart couple different truth common alas
stumble time cookie" | sx mnemonic
  148f0a1d77e20dbaee3ff920ca40240d
\
"""
),

"watchtx": (
"ONLINE (OBELISK)",
"BLOCKCHAIN WATCHING",
"Watch transactions from the network searching for a certain hash.",

"""\
Usage: sx watchtx [TXHASH]...

Watch transactions from the network searching for a certain hash.\
"""
),

"stealth-initiate": (
"OFFLINE KEYS AND ADDRESSES",
"STEALTH",
"Initiate a new stealth payment.",

"""\
Usage: sx stealth-initiate EPHEM_SECRET SCAN_PUBKEY SPEND_PUBKEY

Initiate a new stealth payment.\
"""
),

"stealth-uncover": (
"OFFLINE KEYS AND ADDRESSES",
"STEALTH",
"Uncover a stealth address.",

"""\
Usage: sx stealth-uncover EPHEM_PUBKEY SCAN_SECRET SPEND_PUBKEY

Uncover a stealth address.\
"""
),

"stealth-uncover-secret": (
"OFFLINE KEYS AND ADDRESSES",
"STEALTH",
"Uncover a stealth secret.",

"""\
Usage: sx stealth-uncover-secret EPHEM_PUBKEY SCAN_SECRET SPEND_SECRET

Uncover a stealth secret.\
"""
),

"stealth-newkey": (
"OFFLINE KEYS AND ADDRESSES",
"STEALTH",
"Generate new stealth keys and an address.",

"""\
Usage: sx stealth-newkey

Generate new stealth keys and an address.\
"""
),

"stealth-addr": (
"OFFLINE KEYS AND ADDRESSES",
"STEALTH",
"See a stealth address from given input.",

"""\
Usage: sx stealth-addr [--reuse-key|-r] [--signatures|-s NSIGS] SCAN_PUBKEY SPEND_PUBKEY1 ...  SPEND_PUBKEYN

See a stealth address from given input.

  --reuse-key -r    Reuse SCAN_PUBKEY for SPEND_PUBKEY
  --signatures -s   Specify NUMBER_SIGNATURES needed.
"""
),

"stealth-show-addr": (
"OFFLINE KEYS AND ADDRESSES",
"STEALTH",
"Show details for a stealth address.",

"""\
Usage: sx stealth-show-addr STEALTH_ADDRESS

Show details for a stealth address.\
"""
),

"hd-seed": (
"OFFLINE KEYS AND ADDRESSES",
"HD / BIP32",
"Create a random new HD key.",

"""\
Usage: sx hd-seed [ENTROPY]

Create a random new HD key.\
"""
),

"hd-priv": (
"OFFLINE KEYS AND ADDRESSES",
"HD / BIP32",
"Create an private HD key from another HD private key.",

"""\
Usage: sx hd-priv [--hard] INDEX

Create an private HD key from another HD private key.\
"""
),

"hd-pub": (
"OFFLINE KEYS AND ADDRESSES",
"HD / BIP32",
"Create an HD public key from another HD private or public key.",

"""\
Usage: sx hd-pub [--hard] INDEX

Create an HD public key from another HD private or public key.
"""
),

"hd-to-address": (
"OFFLINE KEYS AND ADDRESSES",
"HD / BIP32",
"Convert an HD public or private key to a Bitcoin address.",

"""\
Usage: sx hd-to-address

Convert an HD public or private key to a Bitcoin address.\
"""
),

"hd-to-wif": (
"OFFLINE KEYS AND ADDRESSES",
"HD / BIP32",
"Convert an HD private key to a WIF private key.",

"""\
Usage: sx hd-to-wif

Convert an HD private key to a WIF private key.\
"""
),

"ec-multiply": (
"UTILITY",
"EC MATH",
"Multiply an integer and a point together.",

"""\
Usage: sx ec-multiply INTEGER POINT

Multiply an integer and a point together.\
"""
),

"ec-tweak-add": (
"UTILITY",
"EC MATH",
"Calculate the result of POINT + INTEGER * G.",

"""\
Usage: sx ec-tweak-add INTEGER POINT

Calculate the result of POINT + INTEGER * G.\
"""
),

"ec-add-modp": (
"UTILITY",
"EC MATH",
"Calculate the result of INTEGER + INTEGER.",

"""\
Usage: sx ec-add-modp INTEGER INTEGER

Calculate the result of INTEGER + INTEGER.\
"""
),

}

def display_usage():
    print "Usage: sx COMMAND [ARGS]..."
    print
    print "  -c, --config               Specify a config file"
    print
    print "The sx commands are:"
    print
    categorized={}
    for cmd in sorted(command_list.iterkeys()):
        category =    command_list[cmd][0]
        subcategory = command_list[cmd][1]
        if category not in categorized:
            categorized[category] = {}
        subcategorized = categorized[category]

        if subcategory not in subcategorized:
            subcategorized[subcategory] = []


        short_desc = command_list[cmd][2]
        line = "   %s" % cmd
        line += " " * (len(SPACING) - len(cmd) - 3)
        line += short_desc
        categorized[category][subcategory].append(line)
        
    for category, subcategories in sorted(categorized.iteritems()):
        print category
        for subcategory, lines in sorted(subcategories.iteritems()):
            print "  " , subcategory
            for line in lines:
                print "    " , line
        print
    print "See 'sx help COMMAND' for more information on a specific command."
    print
    print "SpesmiloXchange home page: <http://sx.dyne.org/>"

def display_help(command):
    assert command in command_list
    long_desc = command_list[command][3]
    print long_desc
    return 0

def display_bad(command):
    print "sx: '%s' is not a sx command. See 'sx --help'." % command
    return 1

def create_cfg_if_not_exist():
    home = os.path.expanduser("~")
    cfg_path = os.path.join(home, ".sx.cfg")
    if not os.path.exists(cfg_path):
        shutil.copyfile("@cfgdefault@", cfg_path)
        print "Created SX config file:", cfg_path

def main(argv):
    if len(argv) == 1:
        display_usage()
        return 1
    args = argv[1:]
    if args and (args[0] == "-c" or args[0] == "--config"):
        if len(args) < 3:
            display_usage()
            return 1
        use_cfg = args[1]
        if not os.path.isfile(use_cfg):
            print >> sys.stderr, \
                "sx: config file '%s' doesn't exist!" % use_cfg
            return 2
        args = args[2:]
        os.environ["SX_CFG"] = use_cfg
        #print "Using config file:", use_cfg
    else:
        create_cfg_if_not_exist()
    if not args:
        display_usage()
        return 1
    command = args[0]
    # args as one string we can pass to the sx sub-command
    args = args[1:]
    if command == "help" or command == "--help" or command == "-h":
        if not args:
            display_usage()
            return 0
        return display_help(args[0])
    elif command in command_list:
        # make will come and substitute @corebindir@
        binary = "@corebindir@/sx-%s" % command
        return subprocess.call([binary] + args)
    else:
        return display_bad(command)
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv))


########NEW FILE########
