__FILENAME__ = db_controller
import sqlalchemy
from sqlalchemy import *
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.engine.reflection import Inspector
from malware_sample_model import MalwareIndex
import os
import re



class MalwareDbController(object):
    def __init__(self, config):
        self.config = config
        self.db = None
        
    def initialize_db(self):
        """ Initializes sqllite location and filename
            Returns [True, False] accordingly
        """  
        # Get DB configuration
        uri = self.config.get('database', 'uri')   
        try:
            self.engine = create_engine(uri)
            self.engine.echo = False  # Try changing this to True and see what happens
            self.metadata = MetaData(self.engine)
            self.engine.connect()
            Session = sessionmaker()
            Session.configure(bind=self.engine)
            self.session = Session()
            return True
        except Exception, err:
            print "Failed to initialize DB\nPlease verify your db settings-%s" %(err)
            return False
    
    
    def find_sample(self, find_string):
        """ Searches the malware db for samples
            specified by the find_string query
        """
        try:
            if re.findall(r"^([a-fA-F\d]{64})$", find_string):
                query = self.session.query(MalwareIndex).filter_by(sha256=find_string)
            elif re.findall(r"^([a-fA-F\d]{32})$", find_string):
                query = self.session.query(MalwareIndex).filter_by(md5=find_string)
            else:
                query = self.session.query(MalwareIndex).filter_by(name=find_string)
            data = [malware_sample.__dict__ for malware_sample in query]  
            return data
        except Exception, err:
            print err
            
    def recent(self, quantity='5'):
        """Returns a summary of the last n (default: n = 5) pieces of malware."""
        try:            
            query = self.session.query(MalwareIndex).limit(quantity)
            data = [malware_sample.__dict__ for malware_sample in query]
            return data
        except Exception, err:
            print err
 
    def load_db(self, report_json):
        """Load information about the sample into the index DB.""" 
        try:   
            # Set the values with  some reflection awesomeness
            malware_sample = MalwareIndex()
            for k, v in report_json.iteritems():
                if hasattr(malware_sample, k):
                    if isinstance(v, list):
                        setattr(malware_sample, k, ",".join(v))
                      
                    else:
                        setattr(malware_sample, k, v)
            # Add to DB
            self.session.add(malware_sample)
            self.session.commit()
            print "Sample %s loaded..." % report_json['name']
            return True
        except Exception, err:
            print "Error", err

########NEW FILE########
__FILENAME__ = basic_analyzer
import os
import datetime
import utils
from extensions.plugin_base import PluginBase


class BasicAnalyzer(PluginBase):
        # Parsing Custom Options
    @staticmethod
    def get_name():
        return 'basic_analyzer'
    def initialize_config(self, config):
        # self.apikey = config.get(BasicAnalyzer.get_name(), "apikey")
        pass
    def analyze(self, malware_sample):
        malware_definition = dict()
        malware_definition["source"] = malware_sample.meta_source if malware_sample.meta_source else ""
        malware_definition["tags"] = malware_sample.meta_tags   if malware_sample.meta_tags   else ""
        malware_definition["notes"] = malware_sample.meta_notes  if malware_sample.meta_notes  else ""
        
        # Parsing Automatically Generated Options
        malware_definition["name"] = malware_sample.filename if malware_sample.filename else ""
        malware_definition["datetime"] = str(datetime.datetime.now())
        malware_definition["size"] = os.stat(malware_sample.analysis_sample_location).st_size
        malware_definition["md5"] = malware_sample.hash_md5
        malware_definition["sha256"] = malware_sample.hash_sha256
        malware_definition["mimetype"] = utils.get_mimetype(malware_sample.analysis_sample_location)  
        malware_definition["sample_dir"] = malware_sample.analysis_sample_directory  
        malware_sample.malware_definition = malware_definition
        self.report = malware_sample.details()
        self.report_name = "analysis.rpt"
        
    def create_report(self):
        print "Creating report"
        report_dir = self.analysis_report_directory
        try:
            if not os.path.exists(report_dir):
                os.makedirs(report_dir)
            super(BasicAnalyzer, self).create_report(self.report, os.path.join(report_dir, self.report_name))
        except Exception, err:
            print err

########NEW FILE########
__FILENAME__ = virus_total
from extensions.plugin_base import PluginBase
import urllib2
from poster.encode import multipart_encode
from poster.streaminghttp import register_openers
import json
import os

class VirusTotal(PluginBase):

    @staticmethod
    def get_name():
        return 'virustotal'
    def initialize_config(self, config):
        self.apikey = config.get(VirusTotal.get_name(), "apikey")
    
    
    def submit_file_for_scan(self,filepath):
        """ Submits a file to be scanned
            Returns the JSON response
        """     
        # Register the streaming http handlers with urllib2
        register_openers()
        # Extract the file name
        filename = os.path.basename(filepath)
        try:
            datagen, headers = multipart_encode({"name": filename, "file": open(filepath, "rb"), "apikey":self.apikey})
            # Create the Request object
            request = urllib2.Request("https://www.virustotal.com/vtapi/v2/file/scan", datagen, headers)
            # Submit the file and read the reply
            submission_info =  urllib2.urlopen(request).read()
            # This is the json data return upon submission
            # Reference this data for the scan_id for future
            # lookups.
            
            return submission_info
        except Exception, err:
            print err
            return
    
    def lookup_by_hash(self, sample_hash):
        query_dict = dict()
        # Set URL parameters
        query_dict["endpoint"] =  "https://www.virustotal.com/vtapi/v2/file/report"
        query_dict["apikey"]   =  self.apikey
        query_dict["resource"] =  sample_hash
        url = "{endpoint}?apikey={apikey}&resource={resource}".format(**query_dict)   
        # Retrieve the data 
        v_total_json = urllib2.urlopen(url).read()
        return v_total_json
    
    def analyze(self, malware_sample):
        # Lookup details for the sample on virus total
        json_response = self.lookup_by_hash(malware_sample.hash_sha256)
        # Set the report name
        self.report_name = "virustotal_details.json"
        # Save the json in a pretty format
        self.report = json.dumps(json.loads(json_response), sort_keys=True,
                  indent=4)
        
    def create_report(self):
        print "Creating report"
        dir = self.__class__.get_name()
        report_dir = os.path.join(self.analysis_report_directory, dir)
        try:
            if not os.path.exists(report_dir):
                os.makedirs(report_dir)
            super(VirusTotal,self).create_report(self.report, os.path.join(report_dir,self.report_name))
        except Exception, err:
            print err
            
########NEW FILE########
__FILENAME__ = plugin_base
import utils, os
# Custom Exceptions
class PluginConfigError(Exception):
    pass
class MalwareHousePluginNotFound(Exception):
    def __init__(self, plugin_name):
        Exception.__init__(self, "Handler for plugin  [" + plugin_name + "] not found.")
        return None
 
def get_plugin(name, config=None):
    plugin = utils.first(x for x in PluginBase.plugins if x.get_name() == name)
    if plugin == None:
        print PluginBase.plugins
        print "Not found"
        return None
    return plugin(config)

class MalwareHousePlugin(type):
    def __init__(cls,name,bases,attrs):
        # add the plugin to the our plugins list
        if not hasattr(cls,'plugins'):
            cls.plugins = []
        else:
            cls.plugins.append(cls)

class PluginBase(object):
    __metaclass__ = MalwareHousePlugin 
    def __init__(self,config):        
        # Call the derived class to parse the rest of the configuration parameters
        self.initialize_config(config)
        
            
    def initialize_config(self,config_dict):
        raise NotImplementedError
    @staticmethod
    def get_name():
        raise NotImplementedError
    def analyze(self):
        pass
    def create_report(self, report_data, filename):
        try:
            with open(filename, 'w') as report_file:
                report_file.write(report_data)
                print "Report successfully created" 
                print "Report Location: %s" %filename
        except Exception, err:
            print "Error: %s" %err


########NEW FILE########
__FILENAME__ = malware_manager
# !/usr/bin/env python
# encoding: utf-8
"""
malwarehouse.py

Created by Scott Roberts.
Copyright (c) 2012 TogaFoamParty Studios. All rights reserved.
"""
import utils
import db_controller
import sys
from malware_sample import MalwareSample
from argparse import ArgumentParser
import extensions.plugins
from extensions.plugin_base import get_plugin, PluginBase as plg

# Malwarehouse Options
config = utils.get_configuration("malwarehouse.cfg")
# Initialize our DB controller
db_controller = db_controller.MalwareDbController(config)
db_initialized = db_controller.initialize_db()

def check_prelim():
    """Initial setup code. Eventually this will set options."""
    directory_structure = utils.initialize_environment(config)
    return directory_structure

# Processes the malware sample
def malware_loader(malware_path, source, notes, tags):
    sample = MalwareSample(malware_path, config, source, notes, tags)
    return sample


def load_sample(args, source, notes, tags):
    sample = malware_loader(args.load, source, notes, tags)
    if sample:        
        # Process plugins
        for plugin in plg.plugins:
            plugin_name = plugin.get_name()
            if config.get(plugin_name, 'plugin') == "On":    
                plg.analysis_report_directory = sample.analysis_report_directory
                _plugin = get_plugin(plugin.get_name(), config)
                _plugin.analyze(sample)
                _plugin.create_report()
        if sample.malware_definition and db_initialized:
            db_controller.load_db(sample.malware_definition)
    else:
        print "Errors were encountered during analysis"
        
        
def delete_sample():
    if not db_initialized:
        print "Failed to initialize database\nPlease verify your database settings"
        return
    pass

def recent_samples(args):
    if not db_initialized:
        print "Failed to initialize database\nPlease verify your database settings"
        return
    args.recent = 5 if not args.recent else args.recent
    data = db_controller.recent(args.recent)
    for parsed_data in map(utils.parse_sqlite_result, data):
        print MalwareSample.summary(parsed_data)
        
def find_sample(args):
    if not db_initialized:
        print "Failed to initialize database\nPlease verify your database settings"
        return
    print "> Find called with %s." % (args.find)
    data = db_controller.find_sample(args.find)
    for parsed_data in map(utils.parse_sqlite_result, data):
        print MalwareSample.summary(parsed_data)

def main():
    if not check_prelim():
        sys.exit(1)
    
    parser = ArgumentParser()
  
    parser.add_argument("-r", "--recent",
                        action="store",
                        nargs='?',
                        default='5',
                        help="Display the newest samples (default: 5)") 
    
    parser.add_argument("-s", "--source",
                        action="store",
                        default=None,
                        help="Source of file")
    parser.add_argument("-t", "--tags",
                        action="store",
                        default=None,
                        help="Any characteristics of the malware")
    parser.add_argument("-n", "--notes",
                        action="store",
                        default="",
                        help="Notes about file")
    parser.add_argument("-f", "--find",
                        action="store",
                        default="",
                        help="Find a sample by name, md5, or sha256")
    parser.add_argument("-l", "--load",
                        action="store",
                        default="",
                        help="Load a malware sample for analysis")

    parser.add_argument("-d", "--delete",
                        action="store",
                        default="",
                        help="Delete a sample by name, md5, or sha256")

    args = parser.parse_args()
    cli_arguments = sys.argv
       
       
    # Set optional arguments
    tags = args.tags   if args.tags   else ""
    source = args.source if args.source else ""
    notes = args.notes if args.notes else ""
    
    # Process user commands
    if args.find:
        find_sample(args)
    elif "-r" in cli_arguments:
        recent_samples(args)
    elif args.delete:
        print "> [not implemented] Delete called with %s" % (args.delete)
    elif args.load:
        load_sample(args, source, notes, tags)
    return True
    
if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = malware_sample
import utils
import os, pwd, shutil
import magic
import hashlib
import datetime




def get_md5(malware_path):
    """Wrapper for the usual md5 call because it's so verbose."""
    return hashlib.md5(file(malware_path, 'r').read()).hexdigest()
   
def get_sha256(malware_path):
    """Wrapper for the usual sha256 call because it's so verbose."""
    return hashlib.sha256(file(malware_path, 'r').read()).hexdigest()

   
def get_ssdeep(malware_path):
    """Wrapper for the usual pyssdeep call because it's so verbose."""
    return "Not yet implimented"


def get_mimetype(malware_path):
    """Finds the standard mimetype for file and returns type name."""
    mime = magic.Magic(mime=True)
    return mime.from_file(malware_path)

def get_yara(malware_path, yara_rules):
    """Checks malware against a Yara ruleset and returns a dictionary of matched rules."""
    tags = []
    try:
        import yara
        rules = yara.compile(filepath=yara_rules, includes=True)
        yara_tags = rules.match(malware_path)
        for tag in yara_tags:
            tags.append(str(tag))

    except ImportError:
        raise
    except yara.Error as e:
        print("Yara signature file doesn't exist.")
        tags = []
    return tags


class MalwareSample(object):
    """malware_sample represents a piece of malware within Malwarehouse"""
    def __init__(self, malware_path, config, sample_source="", sample_notes="", yara_rules=None):
        super(MalwareSample, self).__init__()
        self.malware_path = malware_path
        self.filename = os.path.basename(malware_path)
        self.config = config 
        self.yara_rules = self.config.get('settings', 'yararules') if not yara_rules else yara_rules    
        # Hash characteristics
        self.hash_md5 = get_md5(malware_path)
        self.hash_sha256 = get_sha256(malware_path)
        # Meta characteristics
        self.meta_tags = get_yara(malware_path, yara_rules)
        self.meta_source = sample_source
        self.meta_notes = sample_notes.split(',')
        self.initialize_sample_environment()
    
    def initialize_sample_environment(self):
        dirs = ["bin", "report"]
        base_dir = os.path.expanduser(self.config.get('settings', 'basedir'))    
        sample_dir = os.path.join(base_dir, self.hash_sha256)
        # Create sample root directory
        if not os.path.exists(sample_dir):
            os.makedirs(sample_dir)
        # Create analysis directories
            for dir in dirs:
                os.makedirs(os.path.join(sample_dir, dir))      
        # Analysis characteristics
        self.analysis_datetime = str(datetime.datetime.now())
        self.analysis_user = pwd.getpwuid(os.getuid())[0]
        self.analysis_sample_directory = sample_dir
        # Malware binary location
        self.analysis_sample_location = os.path.join(sample_dir, "bin", self.filename)
        # Reports location
        self.analysis_report_directory = os.path.join(sample_dir, "report") 
        # Make a copy of the file
        print "Copying sample to %s" % self.analysis_sample_location
        shutil.copy(self.malware_path, os.path.join(sample_dir, "bin"))  
    @staticmethod
    def summary(malware_definition):
        return "- %s (%s) - %s" % (malware_definition['name'], malware_definition['source'], malware_definition['md5'])
    
    def details(self):
        """Prints an easy to read summary of the malware."""
        try:
            details = " Analysis ".center(50, "=")
            details += "\ndatetime:".ljust(25) + "%s\n" % (self.malware_definition['datetime'])
            
            details += " File ".center(50, "=")
            details += "\nsample name:".ljust(25) + "%s\n" % (self.malware_definition['name'])
            details += "mimetype:".ljust(25) + "%s\n" % (self.malware_definition['mimetype'])
            details += "size:".ljust(25) + "%s\n" % (self.malware_definition['size'])
            
            details += " Hashes ".center(50, "=")
            details += "\nmd5:".ljust(26) + "%s\n" % (self.malware_definition['md5'])
            details += "sha256:".ljust(26) + "%s\n" % (self.malware_definition['sha256'])
        
            details += " Meta ".center(50, "=")
            details += "\ntags:".ljust(26) + "%s\n" % (self.malware_definition['tags'])
            details += "source:".ljust(26) + "%s\n" % (self.malware_definition['source'])
        
            details += " Meta ".center(50, "=")
            details += "\nnotes:".ljust(25) + "%s" % (self.malware_definition["notes"])
            details += "\n"
            details += "sample directory: %s" % self.malware_definition["sample_dir"]
        
            return details
        except Exception, err:
            print "%s - %s" % (Exception.message, err)
    
        

    

########NEW FILE########
__FILENAME__ = malware_sample_model

from sqlalchemy import Column, Text, Integer, String
from sqlalchemy.ext.declarative import declarative_base



Base = declarative_base()

class MalwareIndex(Base):
    __tablename__ = 'malwarehouse_index'
    datetime = Column(Text,  primary_key=True)
    name = Column(Text)
    mimetype = Column(Text) 
    tags = Column(Text)
    size = Column(Integer)
    md5 = Column(Text)
    sha256 = Column(Text)
    source = Column(Text)
    notes = Column(Text)

########NEW FILE########
__FILENAME__ = utils
import hashlib
import magic
import pydeep
import ConfigParser
import json
import os
def get_configuration(config_file):
    config = ConfigParser.SafeConfigParser()
    try:
        config.read(config_file)
        return config
    except Exception, err:
        print "%s - %s" %(Exception, err)

def initialize_environment(config):
    # Create malwarehouse root directory     
    base_dir = os.path.expanduser(config.get('settings', 'basedir'))
    try:
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        return True
    except Exception, err:
        print err
        return False

def parse_sqlite_result(unparsed):
    "Takes the results from a SQLite query and parses it as a dictionary."
    return unparsed
    return {'datetime': unparsed[0], 'name': unparsed[1], 'mimetype': unparsed[2], 'tags': unparsed[3], 'size': unparsed[4], 'md5': unparsed[5], 'sha256': unparsed[6], 'source': unparsed[7], 'notes': unparsed[8]}

def get_json(dictionary):
    return json.dumps(dictionary
                      )
def get_mimetype(malware_path):
    """Finds the standard mimetype for file and returns type name."""
    mime = magic.Magic(mime=True)
    return mime.from_file(malware_path)

def __json__(self):
    print "JSON would have been returned."
    pass

def __str__(self):
    return self.summary()
def first(iterable, default=None):
    for item in iterable:
        return item
    return default

########NEW FILE########
