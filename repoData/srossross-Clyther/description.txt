This directory contains the sources for the Performance Python article
here:

 http://www.scipy.org/PerformancePython

Essentially, a simple Gauss-Seidel/Gauss-Jordan iterative scheme to
solve Laplace's equation is implemented in a variety of ways.  These
are compared for sheer speed.  Presently the script compares, pure
Python, pure Python + Psyco, Numeric, weave.blitz, weave.inline,
fortran (via f2py) and Pyrex.


Files:
^^^^^^

 laplace.py -- A script to compare the various options.

 setup.py --  Builds the Fortran and Pyrex modules.

 src/ -- Contains the Fortran and Pyrex sources.

 src/flaplace.f -- Fortran source that is wrapped with f2py.
 
 src/flaplace90_arrays.f90 -- Fortran90 version using array features. Wrapped with f2py.

 src/flaplace95_forall.f95 -- Fortran95 version using forall construct. Wrapped with f2py.

 src/pyx_lap.pyx -- Pyrex version.

 src/pyx_lap1.pyx -- Alternative Pyrex version contributed by Francesc
                     Alted that works with Numeric and Numarray and
                     presents a different way to access the array
                     data.  This is not compiled by default but is
                     there for reference.

 src/laplace.cxx -- Pure C++ version - just for kicks.  To compile it
                    do something like this:
                       g++ -O3 laplace.cxx -o lap


Requirements:
^^^^^^^^^^^^^

 Python, NumPy, SciPy (for weave), Pyrex and optionally Psyco.

Usage:
^^^^^^

 First run this:

  python setup.py build_ext --inplace

 Then simply run this:

  python laplace.py

 The C++ example in src/laplace.cxx can be run like so:

  $ ./lap 
  Enter nx n_iter eps --> 500 100 1e-16 [Return]
  [...]


Prabhu Ramachandran <prabhu_r at users dot sf dot net>
Fortran90 and 95 versions contributed by Ramon Crehuet 
<ramon.crehuet at iqac dot csic dot es>

Welcome to Clyther's documentation!
===================================

CLyther is a Python tool similar to Cython and PyPy. CLyther is a just-in-time specialization engine for OpenCL. 
The main entry points for CLyther are its :class:`clyther.task` and :class:`clyther.kernel` decorators.
Once a function is decorated with one of these the function will be compiled to OpenCL when called. 

CLyther is a Python language extension that makes writing OpenCL code as easy as Python itself. 
CLyther currently only supports a subset of the Python language definition but adds many new features to OpenCL. 

CLyther exposes both the OpenCL C library as well as the OpenCL language to python.

Objectives:
    * Make it easy for developers to take advantage of OpenCL
    * Take advantage existing Python numerical algorithms
    * Accelerate my code!


Philosophy:
    * Enable users to have 100% control via Python. Access one to one mapping from Python to OpenCL.
    * Endorse native Python abstractions for convenience. e.g. Slice an array, pass a function as an argument.

.. warning::
    
    This is a brand new version of CLyther. I have not released this yet. 
    
    * If you do decide to use it then please think about :ref:`contribute`.
    * The best place to add your input to the `Issue Tracker <https://github.com/srossross/Clyther/issues/>`_.
    
Links:
+++++++++++

* `Homepage <http://srossross.github.com/Clyther/>`_
* `Issue Tracker <https://github.com/srossross/Clyther/issues/>`_

* `Development documentation <http://srossross.github.com/Clyther/develop/>`_
* `PyPi <http://pypi.python.org/pypi/Clyther/>`_
* `Github <https://github.com/srossross/Clyther/>`_
* `OpenCL 1.1 spec <http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf>`_

.. seealso::
    
    * `OpenCL for Python <http://srossross.github.com/oclpb>`_: Python bindings for OpenCL.
    * `Meta <http://srossross.github.com/meta>`_: Metaprogramming utilities for Python.



