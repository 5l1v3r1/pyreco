__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Meta documentation build configuration file, created by
# sphinx-quickstart on Wed Nov  9 10:00:25 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Meta'
copyright = u'2011, Sean Ross-Ross'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
try:
    version_str = open('../version.txt').read()
except IOError as err:
    version_str = '???'

# The short X.Y version.
version = version_str
# The full version, including alpha/beta/rc tags.
release = version_str

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Metadoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Meta.tex', u'Meta Documentation',
   u'Sean Ross-Ross', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'meta', u'Meta Documentation',
     [u'Sean Ross-Ross'], 1)
]

########NEW FILE########
__FILENAME__ = prune_mutator
'''
Created on Jul 18, 2011

@author: sean
'''
import _ast
from meta.asttools import Visitor, visit_children

def removeable(self, node):
    '''
    node is removable only if all of its children are as well.
    '''
    throw_away = []
    for child in self.children(node):
        throw_away.append(self.visit(child))

    if self.mode == 'exclusive':
        return all(throw_away)
    elif self.mode == 'inclusive':
        return any(throw_away)
    else:
        raise TypeError("mode must be one of 'exclusive' or 'inclusive'")

# Helper function to create a pass node with a line numer and col_offset 
Pass = lambda node: _ast.Pass(lineno=node.lineno, col_offset=node.col_offset)

class PruneVisitor(Visitor):
    '''
    Visitor to remove ast nodes
    
    :param symbols: set of symbol that are removable.
    
    '''
    def __init__(self, symbols, mode='exclusive'):
        self.remove_symbols = symbols
        
        if mode not in ['exclusive', 'inclusive']:
            raise TypeError("mode must be one of 'exclusive' or 'inclusive'")
        
        self.mode = mode

    visitDefault = removeable
    
    def reduce(self, body):
        '''
        remove nodes from a list
        '''
        i = 0
        while i < len(body):
            stmnt = body[i]
            if self.visit(stmnt):
                body.pop(i)
            else:
                i += 1

    def visitModule(self, node):
        self.reduce(node.body)

    def visitFunctionDef(self, node):
        return node.name in self.remove_symbols

    def visitLambda(self, node):
        return False

    def visitName(self, node):
        return node.id in self.remove_symbols

    def visitReturn(self, node):
        return False

    def visitFor(self, node):
        target = self.visit(node.target)
        for_iter = self.visit(node.iter)
        self.reduce(node.body)

        len_body = len(node.body)
        if len_body == 0:
            node.body.append(_ast.Pass(lineno=node.lineno, col_offset=node.col_offset))


        self.reduce(node.orelse)

        len_orelse = len(node.orelse)

        return (len_body == 0) and (len_orelse == 0) and target and for_iter

    def visitIf(self, node):

        can_remove_test = self.visit(node.test)

        self.reduce(node.body)

        len_body = len(node.body)

        if len_body == 0:
            node.body.append(Pass(node))

        self.reduce(node.orelse)
        len_else = len(node.orelse)

        return len_body == 0 and len_else == 0

    def visitWith(self, node):
        self.reduce(node.body)

        if len(node.body) == 0:
            node.body.append(Pass(node))
            if node.optional_vars is None or self.visit(node.optional_vars):
                return True
            else:
                return False

    def visitWhile(self, node):

        discard_test = self.visit(node.test)

        self.reduce(node.body)

        len_body = len(node.body)
        if len_body == 0:
            node.body.append(Pass(node))

        self.reduce(node.orelse)

        return len_body == 0 and len(node.orelse) == 0

    def visitAttribute(self, node):
        return self.visit(node.value)

    visitGlobal = visit_children

    def visitExpr(self, node):
        return self.visit(node.value)

    def visitalias(self, node):
        if node.asname:
            return node.asname in self.remove_symbols
        else:
            return node.name in self.remove_symbols

    def visitTryFinally(self, node):

        assert len(node.body)
        remove_body = self.visit(node.body[0])

        self.reduce(node.finalbody)

        len_final = len(node.finalbody)
        if len_final == 0:
            node.finalbody.append(Pass(node))

        return remove_body and len_final == 0

    def visitTryExcept(self, node):

        self.reduce(node.body)
        self.reduce(node.orelse)

        len_body = len(node.body)

        if len_body == 0:
            node.body.append(Pass(node))

        for hndlr in node.handlers:
            self.reduce(hndlr.body)
            if len(hndlr.body) == 0:
                hndlr.body.append(Pass(hndlr))

        if len_body == 0:
            node.handlers = [_ast.ExceptHandler(type=None, name=None, body=[Pass(node)], lineno=node.lineno, col_offset=node.col_offset)]

        return len_body == 0 and len(node.orelse) == 0

    def visitExec(self, node):
        return False

    def visitRaise(self, node):
        return False


########NEW FILE########
__FILENAME__ = remove_trivial
'''
Created on Aug 3, 2011

@author: sean
'''
from __future__ import print_function
import _ast
import ast

from meta.asttools.visitors.graph_visitor import GraphGen
from meta.asttools import Visitor, dont_visit, visit_children
from meta.asttools.mutators.replace_mutator import replace_nodes
from meta.asttools.visitors.symbol_visitor import get_symbols
from meta.asttools.visitors.cond_symbol_visitor import conditional_lhs

class Assignment(object):

    def __init__(self, root, assignments):
        self.root = root
        self.assignments = assignments

def visit_conditional(self, node):

    conditional, stable = conditional_lhs(node)

    if not stable:
        return

    bgather = GatherAssignments()
    for stmnt in node.body: bgather.visit(stmnt)

    egather = GatherAssignments()
    for stmnt in node.orelse: egather.visit(stmnt)

    for symbol in stable:
        node_list = self.assign_id_map.setdefault(symbol, [])
        assignments = []

        for asgn_list in bgather.assign_id_map[symbol]:
            assignments.extend(asgn_list.assignments)
        for asgn_list in egather.assign_id_map[symbol]:
            assignments.extend(asgn_list.assignments)

        node_list.append(Assignment(root=node, assignments=assignments))

class GatherAssignments(Visitor):
    '''
    Collect ast nodes that assign to the same variable.
    '''

    def __init__(self):
        self.assign_id_map = {}

    visitTryExcept = dont_visit

    visitDefault = visit_children

    visitIf = visit_conditional
    visitFor = visit_conditional
    visitWhile = visit_conditional

    def visitAssign(self, node):

        target_ids = [get_symbols(target, ast.Store) for target in node.targets]
        target_ids = set.union(*target_ids)

        for id in target_ids:
            node_list = self.assign_id_map.setdefault(id, [])
            node_list.append(Assignment(root=node, assignments=(node,)))

def remove_trivial(root):
    '''
    Remove redundant statements.
    
    The statement `a = 1` will be removed::
        
        a = 1
        a = 2

    The statement `a = 1` will not be removed because `b` depends on it::
        
        a = 1
        b = a + 2
        a = 2
        
    :param root: ast node
    '''

    gen = GatherAssignments()
    gen.visit(root)

    to_remove = []

    for symbol, assignments in gen.assign_id_map.items():
        if len(assignments) < 2:
            continue

        for j in range(len(assignments) - 1):
            i1 = root.body.index(assignments[j].root)
            i2 = root.body.index(assignments[j + 1].root)

            body = root.body[i1 + 1:i2]
            grapher = GraphGen()
            for stmnt in body:
                grapher.visit(stmnt)

            if symbol not in grapher.used:
                to_remove.extend(assignments[j].assignments)

    Pass = lambda node: _ast.Pass(lineno=node.lineno, col_offset=node.col_offset)

    for old in to_remove:
        replace_nodes(root, old, Pass(old))

def remove_unused_assign(root, symbol):
    '''
    Remove redundant statements.
    
    The statement `a = 1` will be removed::
        
        a = 1
        a = 2

    The statement `a = 1` will not be removed because `b` depends on it::
        
        a = 1
        b = a + 2
        a = 2
        
    :param root: ast node
    '''

    gen = GatherAssignments()
    gen.visit(root)

    to_remove = []

    if symbol not in gen.assign_id_map:
        return


    assignments = gen.assign_id_map[symbol]

    if len(assignments) < 2:
        return 

    for j in range(len(assignments) - 1):
        i1 = root.body.index(assignments[j].root)
        i2 = root.body.index(assignments[j + 1].root)

        body = root.body[i1 + 1:i2]
        grapher = GraphGen()
        for stmnt in body:
            grapher.visit(stmnt)

        if symbol not in grapher.used:
            to_remove.extend(assignments[j].assignments)

    Pass = lambda node: _ast.Pass(lineno=node.lineno, col_offset=node.col_offset)

    for old in to_remove:
        replace_nodes(root, old, Pass(old))


########NEW FILE########
__FILENAME__ = replace_mutator
'''
Created on Aug 3, 2011

@author: sean
'''

import _ast
from meta.asttools.visitors import Visitor

class Replacer(Visitor):
    '''
    Visitor to replace nodes. 
    '''

    def __init__(self, old, new):
        self.old = old
        self.new = new

    def visitDefault(self, node):
        for field in node._fields:
            value = getattr(node, field)

            if value == self.old:
                setattr(node, field, self.new)

            if isinstance(value, (list, tuple)):
                for i, item in enumerate(value):
                    if item == self.old:
                        value[i] = self.new
                    elif isinstance(item, _ast.AST):
                        self.visit(item)
                    else:
                        pass
            elif isinstance(value, _ast.AST):
                self.visit(value)
            else:
                pass

        return

def replace_nodes(root, old, new):

    '''
    Replace the old node with the new one. 
    Old must be an indirect child of root
     
    :param root: ast node that contains an indirect refrence to old 
    :param old: node to replace
    :param new: node to replace `old` with 
    '''

    rep = Replacer(old, new)
    rep.visit(root)
    return

class NodeRemover(Visitor):
    '''
    Remove a node.
    '''
    def __init__(self, to_remove):
        self.to_remove

    def visitDefault(self, node):
        for field in node._fields:
            value = getattr(node, field)

            if value in self.to_remove:
                setattr(node, field, self.new)

            if isinstance(value, (list, tuple)):
                for i, item in enumerate(value):
                    if item == self.old:
                        value[i] = self.new
                    elif isinstance(item, _ast.AST):
                        self.visit(item)
                    else:
                        pass
            elif isinstance(value, _ast.AST):
                self.visit(value)
            else:
                pass

        return


########NEW FILE########
__FILENAME__ = serialize
'''
Created on Nov 28, 2012

@author: sean
'''


from ast import NodeVisitor
import _ast
import sys

node_name = '0__node_name__'

not_py3 = sys.version_info.major < 3


class DictAst(NodeVisitor):
    def generic_visit(self, node):
        dct = {node_name: type(node).__name__}
        for attr in node._attributes:
            dct[attr] = getattr(node,attr)
        for field in node._fields:
            value = getattr(node,field)
            if isinstance(value, list):
                dct[field] = [self.generic_visit(child) for child in value]
            elif  isinstance(value, _ast.AST):
                dct[field] = self.generic_visit(value)
            else: 
                dct[field] = value
        return dct

def serialize(node):
    '''
    :param node: an _ast.AST object
    
    searialize an ast into a dictionary object
    '''
    return DictAst().visit(node)

def deserialize(obj):
    '''
    :param obj: a dctionary created by `serialize`
    
    :returns: An ast object
    '''

    if isinstance(obj, dict) and node_name in obj:
        node_type = getattr(_ast, obj.pop(node_name))
        node = node_type(**{key:deserialize(value) for key,value in obj.items()})
        return node
    elif isinstance(obj,list):
        return [deserialize(value) for value in obj]
    elif not_py3 and isinstance(obj, unicode):
        return obj.encode()
    else:
        return obj

########NEW FILE########
__FILENAME__ = test_conditional_symbols
'''
Created on Aug 9, 2011

@author: sean
'''
import unittest
from meta.asttools.visitors.cond_symbol_visitor import conditional_symbols
import ast
from meta.testing import py2only

class Test(unittest.TestCase):


    def assertCorrect(self, source, lhs_conditional=None, lhs_stable=None,
                                    rhs_conditional=None, rhs_stable=None,
                                    undefined=None):

        mod = ast.parse(source)

        lhs, rhs, un = conditional_symbols(mod)

        if lhs_conditional is not None:
            self.assertEqual(lhs[0], set(lhs_conditional))

        if lhs_stable is not None:
            self.assertEqual(lhs[1], set(lhs_stable))

        if rhs_conditional is not None:
            self.assertEqual(rhs[0], set(rhs_conditional))

        if rhs_stable is not None:
            self.assertEqual(rhs[1], set(rhs_stable))

        if undefined is not None:
            self.assertEqual(un, set(undefined))

    def test_assign(self):
        self.assertCorrect(source='a = 1',
                           lhs_conditional=[], lhs_stable=['a'],
                           rhs_conditional=[], rhs_stable=[],
                           undefined=[])

    def test_assign2(self):
        self.assertCorrect(source='a = b', lhs_conditional=[], lhs_stable=['a'], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_assign3(self):
        self.assertCorrect(source='a, b = b', lhs_conditional=[], lhs_stable=['a', 'b'], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_assign4(self):
        self.assertCorrect(source='b = 1; a = b', lhs_conditional=[], lhs_stable=['a', 'b'], rhs_conditional=[], rhs_stable=['b'], undefined=[])

    def test_assign5(self):
        self.assertCorrect(source='a = b; b = 1', lhs_conditional=[], lhs_stable=['a', 'b'], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_assign6(self):
        self.assertCorrect(source='a = a', lhs_conditional=[], lhs_stable=['a', ], rhs_conditional=[], rhs_stable=['a'], undefined=['a'])

    def test_aug_assign(self):
        self.assertCorrect(source='a += 1', lhs_conditional=[], lhs_stable=['a'], rhs_conditional=[], rhs_stable=['a'], undefined=['a'])

    def test_assign_attr(self):
        self.assertCorrect(source='a.a = 1', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=['a'], undefined=['a'])

    def test_assign_subscr(self):
        self.assertCorrect(source='a[b] = 1', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=['a', 'b'], undefined=['a', 'b'])

    def test_if0(self):
        self.assertCorrect(source='if a: b', lhs_conditional=[], lhs_stable=[], rhs_conditional=['b'], rhs_stable=['a'], undefined=['a', 'b'])

    def test_if1(self):
        self.assertCorrect(source='if a: b = 1', lhs_conditional=['b'], lhs_stable=[], rhs_conditional=[], rhs_stable=['a'], undefined=['a'])

    def test_if_else0(self):
        self.assertCorrect(source='if a: b\nelse: b', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=['a', 'b'], undefined=['a', 'b'])

    def test_if_else1(self):
        self.assertCorrect(source='if a: b = 1\nelse: b = 1', lhs_conditional=[], lhs_stable=['b'], rhs_conditional=[], rhs_stable=['a'], undefined=['a'])

    def test_if_elif0(self):
        self.assertCorrect(source='if a: b\nelif c: b', lhs_conditional=[], lhs_stable=[], rhs_conditional=['b', 'c'], rhs_stable=['a'], undefined=['a', 'b', 'c'])

    def test_if_elif1(self):
        self.assertCorrect(source='if a: b\nelif c: b\nelse: b', lhs_conditional=[], lhs_stable=[], rhs_conditional=['c'], rhs_stable=['a', 'b'], undefined=['a', 'b', 'c'])

    def test_if_elif2(self):
        self.assertCorrect(source='if a: b\nelif c: pass\nelse: b', lhs_conditional=[], lhs_stable=[], rhs_conditional=['b', 'c'], rhs_stable=['a'], undefined=['a', 'b', 'c'])

    def test_for(self):
        self.assertCorrect(source='for i in j: k = 1', lhs_conditional=['i', 'k'], lhs_stable=[], rhs_conditional=[], rhs_stable=['j'], undefined=['j'])

    def test_for_else0(self):
        self.assertCorrect(source='for i in j: k = 1\nelse: k = 2', lhs_conditional=['i'], lhs_stable=['k'], rhs_conditional=[], rhs_stable=['j'], undefined=['j'])

    def test_for_else1(self):
        self.assertCorrect(source='for i in j: k = 1\nb = k', lhs_conditional=['i', 'k'], lhs_stable=['b'], rhs_conditional=[], rhs_stable=['j', 'k'], undefined=['j', 'k'])

    def test_for_break0(self):
        self.assertCorrect(source='for i in j:\n  break\n  k = 1', lhs_conditional=['i', 'k'], lhs_stable=[], rhs_conditional=[], rhs_stable=['j'], undefined=['j'])

    def test_for_break1(self):
        self.assertCorrect(source='for i in j:\n  break\n  k = 1\nelse: k = 2', lhs_conditional=['i', 'k'], lhs_stable=[], rhs_conditional=[], rhs_stable=['j'], undefined=['j'])

    def test_while(self):
        self.assertCorrect(source='while b: a = 1', lhs_conditional=['a'], lhs_stable=[], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_while_else(self):
        self.assertCorrect(source='while b: a = 1\nelse: a = 2', lhs_conditional=[], lhs_stable=['a'], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_while_else_break(self):
        self.assertCorrect(source='while b:\n  break\n  a = 1\nelse: a = 2', lhs_conditional=['a'], lhs_stable=[], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_while_break(self):
        self.assertCorrect(source='while b:\n  break\n  a = 1', lhs_conditional=['a'], lhs_stable=[], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    def test_nested_if(self):
        self.assertCorrect(source='if a:\n  if b: c', lhs_conditional=[], lhs_stable=[], rhs_conditional=['b', 'c'], rhs_stable=['a'], undefined=['a', 'b', 'c'])

    def test_nested_if1(self):
        self.assertCorrect(source='if a:\n  if b: c = 1', lhs_conditional=['c'], lhs_stable=[], rhs_conditional=['b'], rhs_stable=['a'], undefined=['a', 'b'])

    def test_nested_for(self):
        self.assertCorrect(source='for a in b:\n  for c in a: d', lhs_conditional=['a', 'c'], lhs_stable=[], rhs_conditional=['a', 'd'], rhs_stable=['b'], undefined=['b', 'd'])

    def test_nested_while(self):
        self.assertCorrect(source='while a:\n  while c: d', lhs_conditional=[], lhs_stable=[], rhs_conditional=['c', 'd'], rhs_stable=['a'], undefined=['a', 'c', 'd'])

    def test_conditional_after_stable(self):
        self.assertCorrect(source='a = 1\nif b: a = 2', lhs_conditional=[], lhs_stable=['a'], rhs_conditional=[], rhs_stable=['b'], undefined=['b'])

    @py2only
    def test_exec(self):
        self.assertCorrect(source='exec a in b, c', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=['a', 'b', 'c'], undefined=['a', 'b', 'c'])

    def test_assert(self):
        self.assertCorrect(source='assert b, msg', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=[ 'b', 'msg'], undefined=['b', 'msg'])

    def test_raise(self):
        self.assertCorrect(source='raise b', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=[ 'b'], undefined=['b'])

    def test_try(self):
        self.assertCorrect(source='try: a \nexcept: b', lhs_conditional=[], lhs_stable=[], rhs_conditional=['a', 'b'], rhs_stable=[], undefined=['a', 'b'])

    def test_try2(self):
        self.assertCorrect(source='try: a = 1  \nexcept c as d: a = 2', lhs_conditional=['d'], lhs_stable=['a'], rhs_conditional=['c'], rhs_stable=[], undefined=['c'])

    def test_try_else(self):
        self.assertCorrect(source='try: a = 1  \nexcept c as d: a = 2\nelse: x = 1', lhs_conditional=['d', 'x'], lhs_stable=['a'], rhs_conditional=['c'], rhs_stable=[], undefined=['c'])

    def test_try_finally(self):
        self.assertCorrect(source='try: a = 1  \nexcept c as d: a = 2\nfinally: x = 1', lhs_conditional=['d'], lhs_stable=['a', 'x'], rhs_conditional=['c'], rhs_stable=[], undefined=['c'])

    def test_bug001(self):
        self.assertCorrect(source='if a: d\nd', lhs_conditional=[], lhs_stable=[], rhs_conditional=[], rhs_stable=['a', 'd'], undefined=['a', 'd'])

    def test_bug002(self):
        self.assertCorrect(source='if a: d = 1\nd = 1', lhs_conditional=[], lhs_stable=['d'], rhs_conditional=[], rhs_stable=['a'], undefined=['a'])


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.test_assign']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_depgraph
'''
Created on Aug 2, 2011

@author: sean
'''
from __future__ import print_function
import unittest
import ast
from meta.asttools.visitors.graph_visitor import GraphGen
from meta.asttools.visitors.graph_visitor import DiGraph
from meta.asttools.tests import AllTypesTested, skip_networkx

tested = AllTypesTested()

 
def binop_method(op):
    def test_binop(self):
        source = 'c = a %s b' % (op,)
        self.assertDepends(source, {('c', 'a'), ('c', 'b')},
                           {'a', 'b'}, {'c'})
    return test_binop

def unarynop_method(op):
    def test_unaryop(self):
        source = 'c = %s b' % (op,)
        self.assertDepends(source, { ('c', 'b')},
                           { 'b'}, {'c'})
    return test_unaryop

@skip_networkx
class Test(unittest.TestCase):

    def assertDepends(self, source, edges, undefined=None, modified=None):
        mod = ast.parse(source)

        gen = GraphGen(call_deps=True)
        gen.visit(mod)

        self.assertSetEqual(set(gen.graph.edges()), edges)

        if undefined is not None:
            self.assertSetEqual(set(gen.undefined), undefined)
        if modified is not None:
            self.assertSetEqual(set(gen.modified), modified)

        tested.update(mod)
        return gen

    def test_name(self):
        source = 'a'
        self.assertDepends(source, set())

    def test_assign(self):
        source = 'a = b'
        self.assertDepends(source, {('a', 'b')}, {'b'}, {'a'})

    def test_assign_tuple(self):
        source = '(a, c) = b'
        self.assertDepends(source, {('a', 'b'), ('c', 'b')}, {'b'}, {'a', 'c'})

    def test_assign_multi(self):
        source = 'a = b  = c'
        self.assertDepends(source, {('a', 'c'), ('b', 'c')},
                           {'c'}, {'a', 'b'})

    def test_assign_attr(self):
        source = 'a.x = b'
        self.assertDepends(source, {('a', 'b')},
                           {'b', 'a'}, {'a'})

    def test_attr_assign(self):
        source = 'a = b.x'
        self.assertDepends(source, {('a', 'b')},
                           {'b'}, {'a'})

    def test_subscr(self):
        source = 'a[:] = b[:]'
        self.assertDepends(source, {('a', 'b')},
                           {'a', 'b'}, {'a'})

    def test_subscr_value(self):
        source = 'a = b[c]'
        self.assertDepends(source, {('a', 'b'), ('a', 'c')},
                           {'b', 'c'}, {'a'})

    def test_subscr_lvalue(self):
        source = 'a[c] = b'
        self.assertDepends(source, {('a', 'b'), ('a', 'c')},
                           {'a', 'b', 'c'}, {'a'})

    def test_subscr_attr(self):
        source = 'a[:] = b[:].b'
        self.assertDepends(source, {('a', 'b')},
                           {'a', 'b'}, {'a'})

    def test_import(self):
        source = 'import foo; foo.a = b'
        self.assertDepends(source, {('foo', 'b')},
                           {'b'}, {'foo'})

    def test_import_from(self):
        source = 'from bar import foo; foo.a = b'
        self.assertDepends(source, {('foo', 'b')},
                           {'b'}, {'foo'})


    def test_import_as(self):
        source = 'import bar as foo; foo.a = b'
        self.assertDepends(source, {('foo', 'b')},
                           {'b'}, {'foo'})

    def test_import_from_as(self):
        source = 'from bar import baz as foo; foo.a = b'
        self.assertDepends(source, {('foo', 'b')},
                           {'b'}, {'foo'})


    def test_augment_assign(self):
        source = 'a += b'
        self.assertDepends(source, {('a', 'b'), ('a', 'a')}, {'b'}, {'a'})

    test_add = binop_method('+')
    test_sub = binop_method('-')
    test_pow = binop_method('**')

    test_eq = binop_method('==')
    test_ne = binop_method('!=')

    test_rshift = binop_method('>>')
    test_lshift = binop_method('<<')

    test_mult = binop_method('*')
    test_mod = binop_method('%')
    test_div = binop_method('/')
    test_floordiv = binop_method('//')
    test_bitxor = binop_method('^')

    test_lt = binop_method('<')
    test_gt = binop_method('>')

    test_lte = binop_method('<=')
    test_gte = binop_method('>=')

    test_in = binop_method('in')
    test_not_in = binop_method('not in')
    test_is = binop_method('is')
    test_is_not = binop_method('is not')

    test_bit_or = binop_method('|')
    test_bit_and = binop_method('&')

    test_or = binop_method('or')
    test_and = binop_method('and')

    test_not = unarynop_method('not')
    test_uadd = unarynop_method('+')
    test_usub = unarynop_method('-')
    test_invert = unarynop_method('~')

    def test_call(self):
        source = 'foo(a)'
        self.assertDepends(source, {('foo', 'a'), ('a', 'foo')},
                           {'a', 'foo'},)


    def test_for(self):
        source = 'for i in a:\n    b'
        self.assertDepends(source, {('i', 'a'), ('b', 'a')},
                           {'a', 'b'}, {'i'})

    def test_for2(self):
        source = 'for i in a:\n    x += b[i]'
        self.assertDepends(source, {('i', 'a'), ('b', 'a'), ('x', 'a'), ('x', 'i'), ('x', 'b'), ('x', 'x')},
                           {'a', 'b'}, {'x', 'i'})

    def test_for_unpack(self):
        source = 'for i, j in a:\n    x += b[i]'
        self.assertDepends(source, {('i', 'a'), ('j', 'a'), ('b', 'a'), ('x', 'a'), ('x', 'i'), ('x', 'b'), ('x', 'x')},
                           {'a', 'b'}, {'x', 'i', 'j'})


    def test_dict(self):
        source = 'c = {a:b}'
        self.assertDepends(source, {('c', 'a'), ('c', 'b')},
                           {'a', 'b'}, {'c'})

    def test_list(self):
        source = 'c = [a,b]'
        self.assertDepends(source, {('c', 'a'), ('c', 'b')},
                           {'a', 'b'}, {'c'})

    def test_tuple(self):
        source = 'c = (a,b)'
        self.assertDepends(source, {('c', 'a'), ('c', 'b')},
                           {'a', 'b'}, {'c'})

    def test_set(self):
        source = 'c = {a,b}'
        self.assertDepends(source, {('c', 'a'), ('c', 'b')},
                           {'a', 'b'}, {'c'})

    def test_if(self):
        source = 'if a: b'
        self.assertDepends(source, {('b', 'a')}, {'a', 'b'}, set())

    def test_if_else(self):
        source = 'if a: b\nelse: c'
        self.assertDepends(source, {('b', 'a'), ('c', 'a')}, {'a', 'b', 'c'}, set())

    def test_if_elif_else(self):
        source = 'if a: b\nelif x: c\nelse: d'
        self.assertDepends(source, {('b', 'a'),
                                    ('c', 'x'), ('c', 'a'),
                                    ('d', 'a'), ('d', 'x'),
                                    ('x', 'a')}, {'a', 'b', 'c', 'd', 'x'}, set())

    def test_if_expr(self):
        source = 'd = b if a else c'
        self.assertDepends(source, {('d', 'a'), ('d', 'b'), ('d', 'c')}, {'a', 'b', 'c'}, {'d'})

    def test_assert(self):
        source = 'assert a'
        self.assertDepends(source, set(), {'a' }, set())

    def test_with(self):
        source = 'with a as b: c'
        self.assertDepends(source, {('b', 'a'), ('c', 'a')}, {'a', 'c'}, {'b'})

    def test_while(self):
        source = 'while a: c'
        self.assertDepends(source, {('c', 'a')}, {'a', 'c'})

    def test_function_def(self):
        source = '''a = 1
def foo(b):
    return a + b
'''
        self.assertDepends(source, {('foo', 'a')})

    def test_lambda(self):
        source = '''a = 1
foo = lambda b:  a + b
'''
        self.assertDepends(source, {('foo', 'a')})


    def test_list_comp(self):
        source = 'a = [b for b in c]'
        self.assertDepends(source, {('a', 'c')})

    def test_dict_comp(self):
        source = 'a = {b:d for b,d in c}'
        self.assertDepends(source, {('a', 'c')})

    def test_set_comp(self):
        source = 'a = {b for b in c}'
        self.assertDepends(source, {('a', 'c')})

    def test_try_except(self):
        source = '''
try:
    a
except b:
    c
        '''
        self.assertDepends(source, {('c', 'a'), ('c', 'b')})

    def test_try_except_else(self):
        source = '''
try:
    a
except b:
    c
else:
    d
        '''
        self.assertDepends(source, {('c', 'a'), ('c', 'b'), ('d', 'a')})

    def test_try_finally(self):
        source = '''
try:
    a
except b:
    c
finally:
    d
        '''
        self.assertDepends(source, {('c', 'a'), ('c', 'b'), ('d', 'a'),
                                    ('d', 'b'), ('d', 'c')})

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.test_assign']
    unittest.main(exit=False)

    print(tested.tested())


########NEW FILE########
__FILENAME__ = test_prune
'''
Created on Aug 2, 2011

@author: sean
'''
from __future__ import print_function

from meta.asttools.tests import AllTypesTested, assert_ast_eq
import unittest
from meta.asttools.mutators.prune_mutator import PruneVisitor
import ast
from meta.testing import py2only

tested = AllTypesTested()


class TestExclusive(unittest.TestCase):

    def assertPruned(self, source, pruned, symbols):
        mutator = PruneVisitor(symbols=symbols, mode='exclusive')

        orig_ast = ast.parse(source)
        expected_ast = ast.parse(pruned)
        mutator.visit(orig_ast)

        assert_ast_eq(self, orig_ast, expected_ast)

        tested.update(orig_ast)

    def test_assign(self):
        source = 'a = b; c = d'
        pruned = 'a = b;'

        self.assertPruned(source, pruned, symbols=['c', 'd'])

        pruned2 = 'c = d'

        self.assertPruned(source, pruned2, symbols=['a', 'b'])

        pruned = 'a = b; c = d'

        self.assertPruned(source, pruned, symbols=['c'])

        pruned2 = 'a = b; c = d'

        self.assertPruned(source, pruned2, symbols=['b'])


    def test_binop(self):
        source = 'a + b; c + d'
        pruned = 'a + b'

        self.assertPruned(source, pruned, symbols=['c', 'd'])

    def test_unaryop(self):
        source = '+b; -c'
        pruned = '+b'

        self.assertPruned(source, pruned, symbols=['c'])

    def test_for(self):
        source = 'for i in j: k'

        pruned = 'for i in j: pass'
        self.assertPruned(source, pruned, symbols=['k'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['k', 'i', 'j'])

    def test_for_else(self):
        source = 'for i in j:\n    k\nelse:\n    l'

        pruned = 'for i in j:\n    k'
        self.assertPruned(source, pruned, symbols=['l'])


        pruned = 'for i in j:\n    pass\nelse:\n    l'
        self.assertPruned(source, pruned, symbols=['i', 'j', 'k'])

    def test_with_as(self):
        source = 'with a as b: c'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c'])

        pruned = 'with a as b: pass'
        self.assertPruned(source, pruned, symbols=['c'])

    def test_with(self):
        source = 'with a: c'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'c'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['c'])

    def test_if(self):
        source = 'if a: b\nelse: c'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', 'c'])

        pruned = 'if a: b'
        self.assertPruned(source, pruned, symbols=['c'])

    def test_if_expr(self):
        source = 'a = b if c else d'

        pruned = 'a = b if c else d'
        self.assertPruned(source, pruned, symbols=['b', 'c', 'd'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c', 'd'])

    def test_while(self):
        source = 'while a: b'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', ])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c', 'd'])

    def test_import(self):
        source = 'import a'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', ])

        source = 'import a, b'

        pruned = 'import a, b'
        self.assertPruned(source, pruned, symbols=['a', ])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b'])

    def test_import_from(self):
        source = 'from a import b'

        pruned = 'from a import b'
        self.assertPruned(source, pruned, symbols=['a', ])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', ])

    def test_try(self):
        source = '''
try:
    a
except b as c:
    d
'''

        pruned = '''
'''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c', 'd'])

        pruned = '''
try:
    a
except b as c:
    pass
'''

        self.assertPruned(source, pruned, symbols=['d'])

        pruned = '''
'''
        self.assertPruned(source, pruned, symbols=['a', 'd'])

    def test_try_else(self):
        source = '''
try:
    a
except b as c:
    d
else:
    e
'''

        pruned = '''
try:
    pass
except:
    pass
else:
    e

'''
        self.assertPruned(source, pruned, symbols=['a', ])

    def test_try_finally(self):
        source = '''
try:
    a
except b as c:
    d
else:
    e
finally:
    f
'''

        pruned = '''
try:
    pass
except:
    pass
else:
    e
finally:
    f

'''
        self.assertPruned(source, pruned, symbols=['a', ])

        pruned = '''
try:
    pass
except:
    pass
else:
    e
finally:
    pass

'''
        self.assertPruned(source, pruned, symbols=['a', 'f'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'd', 'e', 'f'])
    
    @py2only
    def test_exec(self):
        source = 'exec a'
        pruned = 'exec a'
        self.assertPruned(source, pruned, symbols=['a'])


    def test_attr(self):
        pass



class TestInclusive(unittest.TestCase):

    def assertPruned(self, source, pruned, symbols):
        mutator = PruneVisitor(symbols=symbols, mode='inclusive')

        orig_ast = ast.parse(source)
        expected_ast = ast.parse(pruned)
        mutator.visit(orig_ast)

        assert_ast_eq(self, orig_ast, expected_ast)

        tested.update(orig_ast)

    def test_assign(self):
        source = 'a = b; c = d'
        pruned = 'a = b;'

        self.assertPruned(source, pruned, symbols=['c', 'd'])

        pruned2 = 'c = d'

        self.assertPruned(source, pruned2, symbols=['a', 'b'])

        pruned = 'a = b'

        self.assertPruned(source, pruned, symbols=['c'])

        pruned2 = 'c = d'

        self.assertPruned(source, pruned2, symbols=['b'])


    def test_binop(self):
        source = 'a + b; c + d'
        pruned = 'a + b'

        self.assertPruned(source, pruned, symbols=['c', 'd'])

    def test_unaryop(self):
        source = '+b; -c'
        pruned = '+b'

        self.assertPruned(source, pruned, symbols=['c'])

    def test_for(self):
        source = 'for i in j: k'

        pruned = 'for i in j: pass'
        self.assertPruned(source, pruned, symbols=['k'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['k', 'i', 'j'])

    def test_for_else(self):
        source = 'for i in j:\n    k\nelse:\n    l'

        pruned = 'for i in j:\n    k'
        self.assertPruned(source, pruned, symbols=['l'])


        pruned = 'for i in j:\n    pass\nelse:\n    l'
        self.assertPruned(source, pruned, symbols=['i', 'j', 'k'])

    def test_with_as(self):
        source = 'with a as b: c'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c'])

        pruned = 'with a as b: pass'
        self.assertPruned(source, pruned, symbols=['c'])

    def test_with(self):
        source = 'with a: c'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'c'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['c'])

    def test_if(self):
        source = 'if a: b\nelse: c'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', 'c'])

        pruned = 'if a: b'
        self.assertPruned(source, pruned, symbols=['c'])

    def test_if_expr(self):
        source = 'a = b if c else d'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', 'c', 'd'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c', 'd'])

    def test_while(self):
        source = 'while a: b'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', ])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c', 'd'])

    def test_import(self):
        source = 'import a'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', ])

        source = 'import a, b'

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', ])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'b'])

    def test_import_from(self):
        source = 'from a import b'

        pruned = 'from a import b'
        self.assertPruned(source, pruned, symbols=['a', ])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['b', ])

    def test_try(self):
        source = '''
try:
    a
except b as c:
    d
'''

        pruned = '''
'''
        self.assertPruned(source, pruned, symbols=['a', 'b', 'c', 'd'])

        pruned = '''
try:
    a
except b as c:
    pass
'''

        self.assertPruned(source, pruned, symbols=['d'])

        pruned = '''
'''
        self.assertPruned(source, pruned, symbols=['a', 'd'])

    def test_try_else(self):
        source = '''
try:
    a
except b as c:
    d
else:
    e
'''

        pruned = '''
try:
    pass
except:
    pass
else:
    e

'''
        self.assertPruned(source, pruned, symbols=['a', ])

    def test_try_finally(self):
        source = '''
try:
    a
except b as c:
    d
else:
    e
finally:
    f
'''

        pruned = '''
try:
    pass
except:
    pass
else:
    e
finally:
    f

'''
        self.assertPruned(source, pruned, symbols=['a', ])

        pruned = '''
try:
    pass
except:
    pass
else:
    e
finally:
    pass

'''
        self.assertPruned(source, pruned, symbols=['a', 'f'])

        pruned = ''
        self.assertPruned(source, pruned, symbols=['a', 'd', 'e', 'f'])

    @py2only
    def test_exec(self):
        source = 'exec a'
        pruned = 'exec a'
        self.assertPruned(source, pruned, symbols=['a'])


    def test_attr(self):
        pass



if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.test_assign']
    unittest.main(exit=False)

    print(tested.tested())


########NEW FILE########
__FILENAME__ = test_remove_trivial
'''
Created on Aug 5, 2011

@author: sean
'''
from __future__ import print_function

import unittest
import ast
from meta.asttools.mutators.remove_trivial import remove_trivial
from meta.asttools.tests import assert_ast_eq, skip_networkx
from meta.asttools.visitors.graph_visitor import GraphGen


def simple_case(self, toremove, expected):

    root = ast.parse(toremove)

    remove_trivial(root)

    expected_root = ast.parse(expected)

    assert_ast_eq(self, root, expected_root)

@skip_networkx
class Test(unittest.TestCase):

    def assertRemoved(self, toremove, expected):

        root = ast.parse(toremove)

        remove_trivial(root)

        expected = ast.parse(expected)

        assert_ast_eq(self, root, expected)

    def test_single(self):
        simple_case(self, 'a = 1',
                           'a = 1')

    def test_empty(self):
        simple_case(self,'',
                             '')

    def test_simple(self):
        simple_case(self, 'a = 1; a = 2',
                          'pass; a = 2')

    def test_multi(self):
        simple_case(self, 'a = 1; a = 2; a = 3',
                             'pass; pass; a = 3')

    def test_apart(self):
        simple_case(self, 'a = 1; b = 1; a = 2',
                              'pass; b = 1; a = 2')

    def test_if(self):
        simple_case(self, 'a = 1\nif x: a = 2',
                          'a = 1\nif x: a = 2')

    def test_if2(self):
        simple_case(self, 'if x: a = 2\na = 1',
                           'if x: a = 2\na = 1')

    def test_if_else(self): 
        simple_case(self, 'a = 1\nif x: a = 2\nelse: a = 3',
                               'pass\nif x: a = 2\nelse: a = 3')

    def test_if_else2(self):
        simple_case(self, 'if x: a = 2\nelse: a = 3\na = 1',
                                'if x: pass\nelse: pass\na = 1')

    def test_for(self):
        simple_case(self, 'a = 1\nfor x in y: a = 2',
                           'a = 1\nfor x in y: a = 2')

    def test_for_else(self):
        simple_case(self, 'a = 1\nfor x in y: a = 2\nelse: a = 3',
                                'pass\nfor x in y: a = 2\nelse: a = 3')

    def test_for_else_break(self):
        simple_case(self, 'a = 1\nfor x in y:\n    break\n    a = 2\nelse: a = 3',
                                      'a = 1\nfor x in y:\n    break\n    a = 2\nelse: a = 3')

    def test_for_else_conti(self):
        simple_case(self, 'a = 1\nfor x in y:\n    continue\n    a = 2\nelse: a = 3',
                                      'a = 1\nfor x in y:\n    continue\n    a = 2\nelse: a = 3')

    def test_while(self):
        simple_case(self, 'a = 1\nwhile x: a = 2',
                             'a = 1\nwhile x: a = 2')

    def test_while_else(self): 
        simple_case(self, 'a = 1\nwhile x: a = 2\nelse: a = 3',
                                  'pass\nwhile x: a = 2\nelse: a = 3')

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_replace
'''
Created on Aug 5, 2011

@author: sean
'''
from __future__ import print_function

import unittest
from meta.asttools.mutators.replace_mutator import replace_nodes
import ast
from meta.asttools.tests import assert_ast_eq

class Test(unittest.TestCase):

    def test_replace_name(self):

        root = ast.parse('a = 1')

        name_a = root.body[0].targets[0]
        name_b = ast.Name(id='b', ctx=ast.Store())
        replace_nodes(root, name_a, name_b)

        expected = ast.parse('b = 1')
        assert_ast_eq(self, root, expected)


    def test_replace_non_existant(self):

        root = ast.parse('a = 1')

        name_a = root.body[0].targets[0]
        name_b = ast.Name(id='b', ctx=ast.Store())
        replace_nodes(root, name_b, name_a)

        expected = ast.parse('a = 1')
        assert_ast_eq(self, root, expected)

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_sourcegen
'''
Created on Aug 3, 2011

@author: sean
'''
from __future__ import print_function

import unittest
import ast
from meta.asttools.visitors.pysourcegen import SourceGen
from meta.asttools.tests import AllTypesTested
from meta.testing import py2only, py3only

tested = AllTypesTested()

def simple_expr(expr):
    def test_sourcegen_expr(self):
        self.assertSame(expr)

    return test_sourcegen_expr

def bin_op(op):
    def test_bin_op(self):
        self.assertSame('(a %s b)' % (op,))

    return test_bin_op

def unary_op(op):
    def test_bin_op(self):
        self.assertSame('(%sb)' % (op,))

    return test_bin_op

def aug_assign(op):
    def test_bin_op(self):
        self.assertSame('a %s= b' % (op,))

    return test_bin_op

class Test(unittest.TestCase):


    def assertSame(self, source):
        module = ast.parse(source)

        tested.update(module)

        gen = SourceGen()
        gen.visit(module)
        generated_source = gen.dumps()

        self.assertMultiLineEqual(source, generated_source.strip('\n'))

class TestSimple(Test):


    def assertSame(self, source):
        module = ast.parse(source)

        tested.update(module)

        gen = SourceGen()
        gen.visit(module)
        generated_source = gen.dumps()

        self.assertEqual(source, generated_source.strip('\n'))


    test_expr = simple_expr('a')
    test_del = simple_expr('del a')
    test_assign = simple_expr('a = 1')
    test_assign_multi = simple_expr('a = b = 1')

    test_attr = simple_expr('a.b')
    test_assattr = simple_expr('a.b = 1')

    test_index = simple_expr('a[b]')
    test_index2 = simple_expr('a[b, c]')

    test_slice0 = simple_expr('a[:]')
    test_slice1 = simple_expr('a[1:]')
    test_slice2 = simple_expr('a[1:2]')
    test_slice3 = simple_expr('a[1:2:3]')
    test_slice4 = simple_expr('a[1::3]')
    test_slice5 = simple_expr('a[::3]')
    test_slice6 = simple_expr('a[:3]')
    test_slice7 = simple_expr('a[...]')

    test_raise = simple_expr('raise Foo')
    
    test_raise1 = py2only(simple_expr('raise Foo, bar'))
    test_raise2 = py2only(simple_expr('raise Foo, bar, baz'))

    test_raise_from = py3only(simple_expr('raise Foo() from bar'))
    
    
    test_call0 = simple_expr('foo()')
    test_call1 = simple_expr('a = foo()')
    test_call2 = simple_expr('foo(x)')
    test_call3 = simple_expr('foo(x, y)')
    test_call4 = simple_expr('foo(x=y)')
    test_call5 = simple_expr('foo(z, x=y)')
    test_call6 = simple_expr('foo(*z)')
    test_call7 = simple_expr('foo(**z)')
    test_call8 = simple_expr('foo(a, b=c, *d, **z)')

    test_pass = simple_expr('pass')

    test_import = simple_expr('import a')
    test_import_as = simple_expr('import a as b')

    test_from_import = simple_expr('from c import a')
    test_from_import_as = simple_expr('from c import a as b')

    test_dict0 = simple_expr('{}')
    test_dict1 = simple_expr('{a:b}')
    test_dict2 = simple_expr('{a:b, c:d}')

    test_list0 = simple_expr('[]')
    test_list1 = simple_expr('[a]')
    test_list2 = simple_expr('[a, b]')

    test_set1 = simple_expr('{a}')
    test_set2 = simple_expr('{a, b}')

    test_exec0 = py2only(simple_expr('exec a in None, None'))
    test_exec1 = py2only(simple_expr('exec a in b, None'))
    test_exec2 = py2only(simple_expr('exec a in b, c'))

    test_assert1 = simple_expr('assert False')
    test_assert2 = simple_expr('assert False, msg')

    test_global1 = simple_expr('global a')
    test_global2 = simple_expr('global a, b')

    test_str = simple_expr("x = 'a'")

    test_ifexpr = simple_expr("a = b if c else d")

    test_lambda = simple_expr("a = lambda a: a")

    test_list_comp = simple_expr("[a for b in c]")
    test_list_comp_if = simple_expr("[a for b in c if d]")
    test_list_comp_if2 = simple_expr("[a for b in c if d if e]")

    test_list_comp2 = simple_expr("[a for b in c for d in e]")
    test_list_comp3 = simple_expr("[a for b in c for d in e if k for f in g]")

    test_set_comp = simple_expr("{a for b in c}")
    test_dict_comp = simple_expr("{a:d for b in c}")

    test_iadd = aug_assign('+')
    test_isub = aug_assign('-')
    test_imult = aug_assign('*')
    test_ipow = aug_assign('**')
    test_idiv = aug_assign('/')
    test_ifdiv = aug_assign('//')


    test_add = bin_op('+')
    test_sub = bin_op('-')
    test_mult = bin_op('*')
    test_pow = bin_op('**')
    test_div = bin_op('/')
    test_floordiv = bin_op('//')
    test_mod = bin_op('%')

    test_eq = bin_op('==')
    test_neq = bin_op('!=')
    test_lt = bin_op('<')
    test_gt = bin_op('>')
    test_lte = bin_op('<=')
    test_gte = bin_op('>=')

    test_lshift = bin_op('<<')
    test_rshift = bin_op('>>')

    test_lshift = bin_op('and')
    test_rshift = bin_op('or')

    test_in = bin_op('in')
    test_not_in = bin_op('not in')

    test_is = bin_op('is')
    test_is_not = bin_op('is not')

    test_bitand = bin_op('&')
    test_bitor = bin_op('|')
    test_bitxor = bin_op('^')

    test_usub = unary_op('-')
    test_uadd = unary_op('+')
    test_unot = unary_op('not ')
    test_uinvert = unary_op('~')

class ControlFlow(Test):

    def test_if(self):
        source = '''if a:
    b'''
        self.assertSame(source)

    def test_if_else(self):
        source = '''if a:
    b
else:
    c'''
        self.assertSame(source)

    def test_elif_else(self):
        source = '''if a:
    b
elif d:
    e
else:
    c'''
        self.assertSame(source)

    def test_while(self):
        source = '''while a:
    b'''
        self.assertSame(source)

    def test_break(self):
        source = '''while a:
    break'''
        self.assertSame(source)

    def test_continue(self):
        source = '''while a:
    continue'''
        self.assertSame(source)

    def test_with0(self):
        source = '''with a:
    b'''
        self.assertSame(source)

    def test_with1(self):
        source = '''with a as b:
    c'''
        self.assertSame(source)

    def test_function_def(self):
        source = '''def foo():
    pass'''
        self.assertSame(source)

    def test_return(self):
        source = '''def foo():
    return 1.1'''
        self.assertSame(source)

    def test_yield(self):
        source = '''def foo():
    yield 1.1'''
        self.assertSame(source)

    def test_function_args1(self):
        source = '''def foo(a):
    pass'''
        self.assertSame(source)

    def test_function_args2(self):
        source = '''def foo(a, b):
    pass'''
        self.assertSame(source)

    def test_function_args3(self):
        source = '''def foo(b=c):
    pass'''
        self.assertSame(source)

    def test_function_args4(self):
        source = '''def foo(b=c, d=e):
    pass'''
        self.assertSame(source)

    def test_function_args5(self):
        source = '''def foo(*a):
    pass'''
        self.assertSame(source)

    def test_try_except(self):
        source = '''try:
    a
except:
    b'''
        self.assertSame(source)

    def test_try_except1(self):
        source = '''try:
    a
except Exception:
    b'''
        self.assertSame(source)

    def test_try_except2(self):
        source = '''try:
    a
except Exception as error:
    b'''
        self.assertSame(source)

    def test_try_except3(self):
        source = '''try:
    a
except Exception as error:
    pass
except:
    b'''
        self.assertSame(source)

    def test_try_except_else(self):
        source = '''try:
    a
except Exception as error:
    pass
except:
    b
else:
    c'''
        self.assertSame(source)

    def test_try_except_finally(self):
        source = '''try:
    a
except Exception as error:
    pass
except:
    b
finally:
    c'''
        self.assertSame(source)

    def test_for(self):
        source = '''for i in j:
    pass'''
        self.assertSame(source)

    def test_for_else(self):
        source = '''for i in j:
    l
else:
    k'''
        self.assertSame(source)

    def test_class_def(self):
        source = '''class A():
    pass'''
        self.assertSame(source)

    def test_class_def1(self):
        source = '''class A(object):
    pass'''
        self.assertSame(source)

    def test_class_def2(self):
        source = '''class A(object, foo):
    pass'''
        self.assertSame(source)

    def test_class_def3(self):
        source = '''class A(object, foo):
    a = 1
    def bar():    
        pass'''
        self.assertSame(source)

    def test_cmp(self):
        source = '(a > b > c)'
        self.assertSame(source)
        
    def test_logical(self):
        source = '(a and b and c)'
        self.assertSame(source)
    
#    @unittest.expectedFailure
    def test_issue_9(self):
        source = '''def hi():
    if a:    
        b
    elif c:    
        d
    
    '''
        self.assertSame(source)

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.test_expr']
    unittest.main(exit=False)

    print(tested.tested())


########NEW FILE########
__FILENAME__ = test_symbol_visitor
'''
Created on Aug 5, 2011

@author: sean
'''
from __future__ import print_function

import unittest
import ast
from meta.asttools.visitors.symbol_visitor import get_symbols


class Test(unittest.TestCase):

    def assertHasSymbols(self, codestring, expected_symbols, ctxts=(ast.Load, ast.Store)):
        root = ast.parse(codestring)

        symbols = get_symbols(root, ctxts)

        self.assertEqual(symbols, expected_symbols)


    def test_simple(self):
        self.assertHasSymbols('a', {'a'})

    def test_load(self):
        self.assertHasSymbols('a', {'a'}, ast.Load)
        self.assertHasSymbols('a', set(), ast.Store)

    def test_store(self):
        self.assertHasSymbols('a = 1', {'a'}, ast.Store)
        self.assertHasSymbols('a = 1', set(), ast.Load)

    def test_store_item(self):
        self.assertHasSymbols('a[:] = 1', {'a'}, ast.Load)
        self.assertHasSymbols('a[:] = 1', set(), ast.Store)

    def test_store_attr(self):

        self.assertHasSymbols('a.b = 1', {'a'}, ast.Load)
        self.assertHasSymbols('a.b = 1', set(), ast.Store)

    def test_for(self):

        self.assertHasSymbols('for i in x:\n    a.b = 1', {'a', 'x'}, ast.Load)
        self.assertHasSymbols('for i in x:\n    a.b = 1', {'i'}, ast.Store)


if __name__ == '__main__':

    unittest.main()

########NEW FILE########
__FILENAME__ = cond_symbol_visitor
'''
Created on Aug 4, 2011

@author: sean
'''
from __future__ import print_function

from meta.asttools.visitors import Visitor, visit_children
from meta.asttools.visitors.symbol_visitor import get_symbols
import ast
from meta.utils import py2op

class ConditionalSymbolVisitor(Visitor):

    def __init__(self):
        self._cond_lhs = set()
        self._stable_lhs = set()

        self._cond_rhs = set()
        self._stable_rhs = set()

        self.undefined = set()

        self.seen_break = False

    visitModule = visit_children
    visitPass = visit_children


    def update_stable_rhs(self, symbols):
        new_symbols = symbols - self._stable_rhs
        self._update_undefined(new_symbols)

        if self.seen_break:
            self._cond_rhs.update(new_symbols)
        else:
            self._cond_rhs -= new_symbols
            self._stable_rhs.update(new_symbols)

    def update_stable_lhs(self, symbols):
        new_symbols = symbols - self._stable_lhs

        if self.seen_break:
            self._cond_lhs.update(new_symbols)
        else:
            self._cond_lhs -= new_symbols
            self._stable_lhs.update(new_symbols)

    def update_cond_rhs(self, symbols):

        new_symbols = symbols - self._stable_rhs
        self._update_undefined(new_symbols)
        self._cond_rhs.update(new_symbols)

    def update_cond_lhs(self, symbols):
        self._cond_lhs.update(symbols - self._stable_lhs)

    def _update_undefined(self, symbols):
        self.undefined.update(symbols - self._stable_lhs)
    update_undefined = _update_undefined
    @property
    def stable_lhs(self):
        assert not (self._stable_lhs & self._cond_lhs)
        return self._stable_lhs

    @property
    def stable_rhs(self):
        assert not (self._stable_rhs & self._cond_rhs)
        return self._stable_rhs

    @property
    def cond_rhs(self):
        assert not (self._stable_rhs & self._cond_rhs)
        return self._cond_rhs

    @property
    def cond_lhs(self):
        assert not (self._stable_lhs & self._cond_lhs)
        return self._cond_lhs

    @property
    def lhs(self):
        assert not (self._stable_lhs & self._cond_lhs)
        return self._cond_lhs | self._stable_lhs

    @property
    def rhs(self):
        assert not (self._stable_rhs & self._cond_rhs)
        return self._cond_rhs | self._stable_rhs

    def visitAugAssign(self, node):
        values = get_symbols(node.value)

        self.update_stable_rhs(values)

        targets = get_symbols(node.target)

        self.update_stable_rhs(targets)

        self.update_stable_lhs(targets)

    def visitAssign(self, node):
        ids = set()
        for target in node.targets:
            ids.update(get_symbols(target, ast.Store))

        rhs_ids = get_symbols(node.value, ast.Load)

        for target in node.targets:
            rhs_ids.update(get_symbols(target, ast.Load))

        self.update_stable_rhs(rhs_ids)
        self.update_stable_lhs(ids)

    def visitBreak(self, node):
        self.seen_break = True

    def visitContinue(self, node):
        self.seen_break = True


    def visit_loop(self, node):

        gen = ConditionalSymbolVisitor()
        for stmnt in node.body:
            gen.visit(stmnt)

        self.update_cond_lhs(gen.cond_lhs)
        self.update_cond_rhs(gen.cond_rhs)

        outputs = gen.stable_lhs
        inputs = gen.stable_rhs

        gen = ConditionalSymbolVisitor()
        for stmnt in node.orelse:
            gen.visit(stmnt)

        self.update_cond_rhs(gen.cond_rhs)
        self.update_cond_lhs(gen.cond_lhs)

        orelse_outputs = gen.stable_lhs
        orelse_inputs = gen.stable_rhs

        self.update_stable_lhs(outputs.intersection(orelse_outputs))
        self.update_stable_rhs(inputs.intersection(orelse_inputs))

        self.update_cond_lhs(outputs.symmetric_difference(orelse_outputs))
        self.update_cond_rhs(inputs.symmetric_difference(orelse_inputs))

    def visitFor(self, node):

        lhs_symbols = get_symbols(node.target, ast.Store)
        self.update_cond_lhs(lhs_symbols)

        rhs_symbols = get_symbols(node.iter, ast.Load)

        self.update_stable_rhs(rhs_symbols)

        remove_from_undef = lhs_symbols - self.undefined
        self.visit_loop(node)
        self.undefined -= remove_from_undef

    def visitExpr(self, node):

        rhs_ids = get_symbols(node, ast.Load)
        self.update_stable_rhs(rhs_ids)

    def visitPrint(self, node):

        rhs_ids = get_symbols(node, ast.Load)
        self.update_stable_rhs(rhs_ids)

    def visitWhile(self, node):

        rhs_symbols = get_symbols(node.test, ast.Load)

        self.update_stable_rhs(rhs_symbols)

        self.visit_loop(node)

    def visitIf(self, node):

        rhs_symbols = get_symbols(node.test, ast.Load)
        self.update_stable_rhs(rhs_symbols)

        gen = ConditionalSymbolVisitor()
        for stmnt in node.body:
            gen.visit(stmnt)

        if gen.seen_break:
            self.seen_break = True

        self.update_cond_lhs(gen._cond_lhs)
        self.update_cond_rhs(gen._cond_rhs)

        outputs = gen.stable_lhs
        inputs = gen.stable_rhs

        gen = ConditionalSymbolVisitor()
        for stmnt in node.orelse:
            gen.visit(stmnt)

        self.update_cond_lhs(gen._cond_lhs)
        self.update_cond_rhs(gen._cond_rhs)

        orelse_outputs = gen.stable_lhs
        orelse_inputs = gen.stable_rhs

        self.update_stable_lhs(outputs.intersection(orelse_outputs))
        self.update_stable_rhs(inputs.intersection(orelse_inputs))

        self.update_cond_lhs(outputs.symmetric_difference(orelse_outputs))
        self.update_cond_rhs(inputs.symmetric_difference(orelse_inputs))
    
    @py2op
    def visitExec(self, node):

        self.update_stable_rhs(get_symbols(node.body, ast.Load))

        if node.globals:
            self.update_stable_rhs(get_symbols(node.globals, ast.Load))

        if node.locals:
            self.update_stable_rhs(get_symbols(node.locals, ast.Load))

    def visitAssert(self, node):

        self.update_stable_rhs(get_symbols(node.test, ast.Load))

        if node.msg:
            self.update_stable_rhs(get_symbols(node.msg, ast.Load))
            
    @py2op
    def visitRaise(self, node):

        if node.type:
            self.update_stable_rhs(get_symbols(node.type, ast.Load))
        if node.inst:
            self.update_stable_rhs(get_symbols(node.inst, ast.Load))
        if node.tback:
            self.update_stable_rhs(get_symbols(node.tback, ast.Load))

    @visitRaise.py3op
    def visitRaise(self, node):

        if node.exc:
            self.update_stable_rhs(get_symbols(node.exc, ast.Load))
        if node.cause:
            self.update_stable_rhs(get_symbols(node.cause, ast.Load))

    def visitTryExcept(self, node):

        gen = ConditionalSymbolVisitor()
        gen.visit_list(node.body)

        self.update_undefined(gen.undefined)

        handlers = [csv(hndlr) for hndlr in node.handlers]

        for g in handlers:
            self.update_undefined(g.undefined)

        stable_rhs = gen.stable_rhs.intersection(*[g.stable_rhs for g in handlers])
        self.update_stable_rhs(stable_rhs)

        all_rhs = gen.rhs.union(*[g.rhs for g in handlers])

        self.update_cond_rhs(all_rhs - stable_rhs)

        stable_lhs = gen.stable_lhs.intersection(*[g.stable_lhs for g in handlers])
        self.update_stable_lhs(stable_lhs)

        all_lhs = gen.lhs.union(*[g.lhs for g in handlers])
        self.update_cond_lhs(all_lhs - stable_lhs)

        gen = ConditionalSymbolVisitor()
        gen.visit_list(node.orelse)

        self.update_undefined(gen.undefined)
        self.update_cond_lhs(gen.lhs)
        self.update_cond_rhs(gen.rhs)

    @py2op
    def visitExceptHandler(self, node):
        if node.type:
            self.update_stable_rhs(get_symbols(node.type, ast.Load))

        if node.name:
            self.update_stable_lhs(get_symbols(node.name, ast.Store))

        self.visit_list(node.body)

    @visitExceptHandler.py3op
    def visitExceptHandler(self, node):
        if node.type:
            self.update_stable_rhs(get_symbols(node.type, ast.Load))

        if node.name:
            self.update_stable_lhs({node.name})

        self.visit_list(node.body)

    def visitTryFinally(self, node):
        self.visit_list(node.body)
        self.visit_list(node.finalbody)

    def visitImportFrom(self, node):
        symbols = get_symbols(node)
        self.update_stable_lhs(symbols)

    def visitImport(self, node):
        symbols = get_symbols(node)
        self.update_stable_lhs(symbols)

    def visitLambda(self, node):

        gen = ConditionalSymbolVisitor()
        gen.update_stable_lhs(symbols={arg for arg in node.args.args})
        gen.visit_list(node.body)

        self.update_stable_rhs(gen.undefined)

    def visitFunctionDef(self, node):

        for decorator in node.decorator_list:
            self.update_stable_rhs(get_symbols(decorator, ast.Load))

        self.update_stable_lhs({node.name})

        gen = ConditionalSymbolVisitor()
        gen.update_stable_lhs(symbols={arg for arg in node.args.args})
        gen.visit_list(node.body)

        self.update_stable_rhs(gen.undefined)

    def visitGlobal(self, node):
        pass

    def visitWith(self, node):

        self.update_stable_rhs(get_symbols(node.context_expr, ast.Load))

        if node.optional_vars:
            self.update_stable_lhs(get_symbols(node.optional_vars, ast.Load))

        self.visit_list(node.body)

    def visitReturn(self, node):
        self.update_stable_rhs(get_symbols(node.value, ast.Load))
        
def csv(node):
    gen = ConditionalSymbolVisitor()
    gen.visit(node)
    return gen

def lhs(node):
    '''
    Return a set of symbols in `node` that are assigned.
    
    :param node: ast node 
    
    :returns: set of strings.
    '''

    gen = ConditionalSymbolVisitor()
    if isinstance(node, (list, tuple)):
        gen.visit_list(node)
    else:
        gen.visit(node)
    return gen.lhs

def rhs(node):
    '''
    Return a set of symbols in `node` that are used.
    
    :param node: ast node 
    
    :returns: set of strings.
    '''

    gen = ConditionalSymbolVisitor()
    if isinstance(node, (list, tuple)):
        gen.visit_list(node)
    else:
        gen.visit(node)
    return gen.rhs

def conditional_lhs(node):
    '''
    Group outputs into contitional and stable
    :param node: ast node 
    
    :returns: tuple of (contitional, stable)
    
    '''

    gen = ConditionalSymbolVisitor()
    gen.visit(node)
    return gen.cond_lhs, gen.stable_lhs


def conditional_symbols(node):
    '''
    Group lhs and rhs into contitional, stable and undefined
    :param node: ast node 
    
    :returns: tuple of (contitional_lhs, stable_lhs),(contitional_rhs, stable_rhs), undefined
    
    '''

    gen = ConditionalSymbolVisitor()
    gen.visit(node)
    lhs = gen.cond_lhs, gen.stable_lhs
    rhs = gen.cond_rhs, gen.stable_rhs
    undefined = gen.undefined
    return lhs, rhs, undefined

if __name__ == '__main__':

    source = '''
while k:
    a = 1
    b = 1
    break
    d = 1
else:
    a =2
    c= 3
    d = 1
    '''

    print(conditional_lhs(ast.parse(source)))



########NEW FILE########
__FILENAME__ = copy_tree
'''
Created on Dec 12, 2011

@author: sean
'''
from meta.asttools import Visitor
import ast

#FIXME: add tests
class CopyVisitor(Visitor):
    '''
    Copy only ast nodes and lists
    '''
    def visitDefault(self, node):
        Node = type(node)
        new_node = Node()
        
        for _field in Node._fields:
            if hasattr(node, _field):
                field = getattr(node, _field)
                if isinstance(field, (list, tuple)):
                    new_list = []
                    for item in field:
                        if isinstance(item, ast.AST):
                            new_item = self.visit(item)
                        else:
                            new_item = item
                        new_list.append(new_item)
                        
                    setattr(new_node, _field, new_list)
                elif isinstance(field, ast.AST):
                    setattr(new_node, _field, self.visit(field))
                else:
                    setattr(new_node, _field, field)
        
        for _attr in node._attributes:
            if hasattr(node, _attr):
                setattr(new_node, _attr, getattr(node, _attr))

        return new_node


def copy_node(node):
    return CopyVisitor().visit(node)

########NEW FILE########
__FILENAME__ = graph_visitor
'''
Created on Jul 18, 2011

@author: sean
'''
from meta.asttools import Visitor, visit_children

import _ast
from meta.asttools.visitors.symbol_visitor import get_symbols
try:
    from networkx import DiGraph
except ImportError:
    DiGraph = None

def collect_(self, node):
    names = set()
    for child in self.children(node):
        names.update(self.visit(child))

    if hasattr(node, 'ctx'):
        if isinstance(node.ctx, _ast.Store):
            self.modified.update(names)
        elif isinstance(node.ctx, _ast.Load):
            self.used.update(names)
    return names


class CollectNodes(Visitor):

    def __init__(self, call_deps=False):
        self.graph = DiGraph()
        self.modified = set()
        self.used = set()
        self.undefined = set()
        self.sources = set()
        self.targets = set()

        self.context_names = set()

        self.call_deps = call_deps

    visitDefault = collect_

    def visitName(self, node):
        if isinstance(node.ctx, _ast.Store):
            self.modified.add(node.id)

        elif isinstance(node.ctx, _ast.Load):
            self.used.update(node.id)

        if not self.graph.has_node(node.id):
            self.graph.add_node(node.id)
            if isinstance(node.ctx, _ast.Load):
                self.undefined.add(node.id)

        for ctx_var in self.context_names:
            if not self.graph.has_edge(node.id, ctx_var):
                self.graph.add_edge(node.id, ctx_var)

        return {node.id}

    def visitalias(self, node):
        name = node.asname if node.asname else node.name

        if '.' in name:
            name = name.split('.', 1)[0]

        if not self.graph.has_node(name):
            self.graph.add_node(name)

        return {name}

    def visitCall(self, node):
        left = self.visit(node.func)

        right = set()
        for attr in ('args', 'keywords'):
            for child in getattr(node, attr):
                if child:
                    right.update(self.visit(child))

        for attr in ('starargs', 'kwargs'):
            child = getattr(node, attr)
            if child:
                right.update(self.visit(child))

        for src in left | right:
            if not self.graph.has_node(src):
                self.undefined.add(src)

        if self.call_deps:
            add_edges(self.graph, left, right)
            add_edges(self.graph, right, left)

        right.update(left)
        return right

    def visitSubscript(self, node):
        if isinstance(node.ctx, _ast.Load):
            return collect_(self, node)
        else:
            sources = self.visit(node.slice)
            targets = self.visit(node.value)
            self.modified.update(targets)
            add_edges(self.graph, targets, sources)
            return targets
        
    def handle_generators(self, generators):
        defined = set()
        required = set()
        for generator in generators:
            get_symbols(generator, _ast.Load)
            required.update(get_symbols(generator, _ast.Load) - defined)
            defined.update(get_symbols(generator, _ast.Store))
            
        return defined, required
    
    def visitListComp(self, node):

        defined, required = self.handle_generators(node.generators)
        required.update(get_symbols(node.elt, _ast.Load) - defined)

        for symbol in required:
            if not self.graph.has_node(symbol):
                self.graph.add_node(symbol)
                self.undefined.add(symbol)

        return required

    def visitSetComp(self, node):

        defined, required = self.handle_generators(node.generators)
        required.update(get_symbols(node.elt, _ast.Load) - defined)

        for symbol in required:
            if not self.graph.has_node(symbol):
                self.graph.add_node(symbol)
                self.undefined.add(symbol)

        return required

    def visitDictComp(self, node):

        defined, required = self.handle_generators(node.generators)
        required.update(get_symbols(node.key, _ast.Load) - defined)
        required.update(get_symbols(node.value, _ast.Load) - defined)

        for symbol in required:
            if not self.graph.has_node(symbol):
                self.graph.add_node(symbol)
                self.undefined.add(symbol)

        return required


def add_edges(graph, targets, sources):
        for target in targets:
            for src in sources:
                edge = target, src
                if not graph.has_edge(*edge):
                    graph.add_edge(*edge)

class GlobalDeps(object):
    def __init__(self, gen, nodes):
        self.nodes = nodes
        self.gen = gen

    def __enter__(self):
        self._old_context_names = set(self.gen.context_names)
        self.gen.context_names.update(self.nodes)

    def __exit__(self, *args):
        self.gen.context_names = self._old_context_names

class GraphGen(CollectNodes):
    '''
    Create a graph from the execution flow of the ast
    '''

    visitModule = visit_children

    def depends_on(self, nodes):
        return GlobalDeps(self, set(nodes))

    def visit_lambda(self, node):
        sources = self.visit(node.args)
        self.sources.update(sources)

        self.visit(node.body)

    def visitLambda(self, node):
        gen = GraphGen()
        gen.visit_lambda(node)

        for undef in gen.undefined:
            if not self.graph.has_node(undef):
                self.graph.add_node(undef)

        return gen.undefined

    def visit_function_def(self, node):
        sources = self.visit(node.args)
        self.sources.update(sources)

        for stmnt in node.body:
            self.visit(stmnt)


    def visitFunctionDef(self, node):

        gen = GraphGen()
        gen.visit_function_def(node)

        if not self.graph.has_node(node.name):
            self.graph.add_node(node.name)

        for undef in gen.undefined:
            if not self.graph.has_node(undef):
                self.graph.add_node(undef)

        add_edges(self.graph, [node.name], gen.undefined)

        return gen.undefined

    def visitAssign(self, node):
        nodes = self.visit(node.value)

        tsymols = get_symbols(node, _ast.Store)
        re_defined = tsymols.intersection(set(self.graph.nodes()))
        if re_defined:
            add_edges(self.graph, re_defined, re_defined)

        targets = set()
        for target in node.targets:
            targets.update(self.visit(target))

        add_edges(self.graph, targets, nodes)

        return targets | nodes

    def visitAugAssign(self, node):

        targets = self.visit(node.target)
        values = self.visit(node.value)

        self.modified.update(targets)

        for target in targets:
            for value in values:
                edge = target, value
                if not self.graph.has_edge(*edge):
                    self.graph.add_edge(*edge)

            for tgt2 in targets:
                edge = target, tgt2
                if not self.graph.has_edge(*edge):
                    self.graph.add_edge(*edge)

        return targets | values

    def visitFor(self, node):

        nodes = set()
        targets = self.visit(node.target)
        for_iter = self.visit(node.iter)

        nodes.update(targets)
        nodes.update(for_iter)

        add_edges(self.graph, targets, for_iter)

        with self.depends_on(for_iter):

            for stmnt in node.body:
                nodes.update(self.visit(stmnt))

        return nodes

    def visitIf(self, node):

        nodes = set()
        names = self.visit(node.test)

        nodes.update(names)
        with self.depends_on(names):

            for stmnt in node.body:
                nodes.update(self.visit(stmnt))

            for stmnt in node.orelse:
                nodes.update(self.visit(stmnt))

        return nodes

    def visitReturn(self, node):

        targets = self.visit(node.value)

        self.targets.update(targets)

        return targets

    def visitWith(self, node):

        nodes = set()
        targets = self.visit(node.context_expr)

        nodes.update(targets)

        if node.optional_vars is None:
            vars = ()
        else:
            vars = self.visit(node.optional_vars)

        nodes.update(vars)
        add_edges(self.graph, vars, targets)

        with self.depends_on(targets):
            for stmnt in node.body:
                nodes.update(self.visit(stmnt))

        return nodes


    def visitWhile(self, node):

        nodes = set()
        targets = self.visit(node.test)

        nodes.update(targets)

        with self.depends_on(targets):
            for stmnt in node.body:
                nodes.update(self.visit(stmnt))

            for stmnt in node.orelse:
                nodes.update(self.visit(stmnt))

        return nodes

    def visitTryFinally(self, node):

        assert len(node.body) == 1

        nodes = self.visit(node.body[0])

        with self.depends_on(nodes):
            for stmnt in node.finalbody:
                nodes.update(self.visit(stmnt))

    def visitTryExcept(self, node):

        body_nodes = set()
        for stmnt in node.body:
            body_nodes.update(self.visit(stmnt))

        all_nodes = set(body_nodes)

        for hndlr in node.handlers:
            nodes = set(body_nodes)

            if hndlr.name:
                nodes.update(self.visit(hndlr.name))
            if hndlr.type:
                nodes.update(self.visit(hndlr.type))

            with self.depends_on(nodes):
                for stmnt in hndlr.body:
                    nodes.update(self.visit(stmnt))

            all_nodes.update(nodes)

        nodes = set(body_nodes)
        with self.depends_on(nodes):
            for stmnt in node.orelse:
                nodes.update(self.visit(stmnt))

        all_nodes.update(nodes)


        return all_nodes



def make_graph(node, call_deps=False):
    '''
    Create a dependency graph from an ast node.
    
    :param node: ast node.
    :param call_deps: if true, then the graph will create a cyclic dependance for all
                      function calls. (i.e for `a.b(c)` a depends on b and b depends on a)
                      
    :returns: a tuple of (graph, undefined)
    '''

    gen = GraphGen(call_deps=call_deps)
    gen.visit(node)

    return gen.graph, gen.undefined




########NEW FILE########
__FILENAME__ = print_visitor
'''
Created on Jul 19, 2011

@author: sean
'''
from __future__ import print_function

from meta.asttools import Visitor
import sys
import _ast
from warnings import warn

if sys.version_info.major < 3:
    from StringIO import StringIO
else:
    from io import StringIO


class Indentor(object):
    def __init__(self, printer, indent='    '):
        self.printer = printer
        self.indent = indent
    def __enter__(self):
        self.printer._indent = self.printer._indent + self.indent

    def __exit__(self, *args):
        indent = self.printer._indent[:-len(self.indent)]

        self.printer._indent = indent

clsname = lambda node: type(node).__name__


def depth(node):
    return len(flatten(node))

def flatten(node):

    result = []
    if isinstance(node, _ast.AST):
        for value in ast_values(node):
            result.extend(flatten(value))

    elif isinstance(node, (list, tuple)):
        for child in node:
            result.extend(flatten(child))
    else:
        result.append(node)

    return result

def ast_keys(node):
    return node._fields

def ast_values(node):
    return [getattr(node, field, None) for field in node._fields]

def ast_items(node):
    return [(field, getattr(node, field, None)) for field in node._fields]


class ASTPrinter(Visitor):

    def __init__(self, indent=' ', level=0, newline='\n'):
        self.out = StringIO()
        self._indent = ''
        self.one_indent = indent
        self.level = level
        self.newline = newline

    def dump(self, file=sys.stdout):
        self.out.seek(0)
        print(self.out.read(), file=file)

    def dumps(self):
        self.out.seek(0)
        return self.out.read()

    def print(self, text, noindent=False, **kwargs):
#        if noindent:
#            prf = ''
#        else:
#            prf = self._indent
        new_text = text.format(**kwargs)
#        print(prf, new_text, file=self.out, sep='', end='')
        print(new_text, file=self.out, sep='', end='')

    def indent(self, level):
        ident = self.one_indent * level
        return Indentor(self, ident)



    def visitDefault(self, node):
        nodename = '%s(' % clsname(node)

        self.print(nodename, noindent=True)

        undefined = [attr for attr in node._fields if not hasattr(node, attr)]
        if undefined:
            warn('ast node %r does not have required field(s) %r ' % (clsname(node), undefined,), stacklevel=2)
        undefined = [attr for attr in node._attributes if not hasattr(node, attr)]
        if undefined:
            warn('ast does %r not have required attribute(s) %r ' % (clsname(node), undefined,), stacklevel=2)
        
        children = sorted([(attr, getattr(node, attr)) for attr in node._fields if hasattr(node, attr)])

        with self.indent(len(nodename)):
            i = 0
            while children:
                attr, child = children.pop(0)
                if isinstance(child, (list, tuple)):
                    text = '{attr}=['.format(attr=attr)
                    self.print(text)
                    with self.indent(len(text)):
                        for j, inner_child in enumerate(child):
                            if isinstance(inner_child, _ast.AST):
                                self.visit(inner_child)
                            else:
                                self.print(repr(inner_child))
                            if j < (len(child) - 1):
                                self.print(", {nl}{idnt}", nl=self.newline, idnt=self._indent)

                    self.print(']')
                else:
                    text = '{attr}='.format(attr=attr)

                    self.print(text)
                    with self.indent(len(text)):
                        if isinstance(child, _ast.AST):
                            self.visit(child)
                        else:
                            self.print(repr(child))

                if children:
                    self.print(", {nl}{idnt}", nl=self.newline, idnt=self._indent)



                i += 1

        self.print(")")

def dump_ast(ast, indent=' ', newline='\n'):
    '''
    
    Returns a string representing the ast.
    
    :param ast: the ast to print.
    :param indent: how far to indent a newline.
    :param newline: The newline character.
    
    '''
    
    visitor = ASTPrinter(indent=indent, level=0, newline=newline)
    visitor.visit(ast)
    return visitor.dumps()

def print_ast(ast, indent=' ', initlevel=0, newline='\n', file=sys.stdout):
    '''
    Pretty print an ast node.
    
    :param ast: the ast to print.
    :param indent: how far to indent a newline.
    :param initlevel: starting indent level
    :param newline: The newline character.
    :param file: file object to print to
    
    To print a short ast you may want to use::
    
        node = ast.parse(source)
        print_ast(node, indent='', newline='')
        
    '''

    visitor = ASTPrinter(indent=indent, level=initlevel, newline=newline)
    visitor.visit(ast)
    visitor.dump(file=file)

########NEW FILE########
__FILENAME__ = pysourcegen
'''
Created on Jul 15, 2011

@author: sean
'''
from __future__ import print_function
import _ast
from meta.asttools import Visitor
from string import Formatter
import sys
from meta.utils import py3op, py2op
from contextlib import contextmanager

if sys.version_info.major < 3:
    from StringIO import StringIO
else:
    from io import StringIO

@contextmanager
def noctx():
    yield
class ASTFormatter(Formatter):

    def format_field(self, value, format_spec):
        if format_spec == 'node':
            gen = ExprSourceGen()
            gen.visit(value)
            return gen.dumps()
        elif value == '':
            return value
        else:
            return super(ASTFormatter, self).format_field(value, format_spec)

    def get_value(self, key, args, kwargs):
        if key == '':
            return args[0]
        elif key in kwargs:
            return kwargs[key]
        elif isinstance(key, int):
            return args[key]

        key = int(key)
        return args[key]

        raise Exception

def str_node(node):
    gen = ExprSourceGen()
    gen.visit(node)
    return gen.dumps()

def simple_string(value):
    def visitNode(self, node):
        self.print(value, **node.__dict__)
    return visitNode

class ExprSourceGen(Visitor):
    def __init__(self):
        self.out = StringIO()
        self.formatter = ASTFormatter()
        self.indent = '    '
        self.level = 0


    @property
    def indenter(self):
        return Indenter(self)

    @property
    def no_indent(self):
        return NoIndent(self)

    def dump(self, file=sys.stdout):
        self.out.seek(0)
        print(self.out.read(), file=file)

    def dumps(self):
        self.out.seek(0)
        value = self.out.read()
        return value

    def print(self, line, *args, **kwargs):
        line = self.formatter.format(line, *args, **kwargs)

        level = kwargs.get('level')
        prx = self.indent * (level if level else self.level)
        print(prx, line, sep='', end='', file=self.out)

    def print_lines(self, lines,):
        prx = self.indent * self.level
        for line in lines:
            print(prx, line, sep='', file=self.out)

    def visitName(self, node):
        self.print(node.id)
    
    @py2op
    def visitarguments(self, node):
        # ('args', 'vararg', 'kwarg', 'defaults')
        defaults = [None] * (len(node.args) - len(node.defaults))
        defaults.extend(node.defaults)

        i = 0
        args = list(node.args)
        if args:
            i += 1
            arg = args.pop(0)
            default = defaults.pop(0)
            self.visit(arg)
            if default is not None:
                self.print('={:node}', default)

        while args:
            arg = args.pop(0)
            default = defaults.pop(0)
            self.print(', ')
            self.visit(arg)
            if default is not None:
                self.print('={:node}', default)

        if node.vararg:
            self.print('{0}*{1}', ', ' if i else '', node.vararg)
        if node.kwarg:
            self.print('{0}**{1}', ', ' if i else '', node.kwarg)

    @visitarguments.py3op
    def visitarguments(self, node):
        # ('args', 'vararg', 'kwarg', 'defaults')
        defaults = [None] * (len(node.args) - len(node.defaults))
        defaults.extend(node.defaults)

        i = 0
        args = list(node.args)
        if args:
            i += 1
            arg = args.pop(0)
            default = defaults.pop(0)
            self.visit(arg)
            if default is not None:
                self.print('={:node}', default)

        while args:
            arg = args.pop(0)
            default = defaults.pop(0)
            self.print(', ')
            self.visit(arg)
            if default is not None:
                self.print('={:node}', default)

        if node.vararg:
            self.print('{0}*{1}', ', ' if i else '', node.vararg)
            if node.varargannotation:
                self.print(':{:node}', node.varargannotation)
        elif node.kwonlyargs:
            self.print('{0}*', ', ' if i else '')
        
        kwonlyargs = list(node.kwonlyargs)
        
        if kwonlyargs:
            i += 1
            kw_defaults = [None] * (len(kwonlyargs) - len(node.kw_defaults))
            kw_defaults.extend(node.kw_defaults)
            
        while kwonlyargs:
            kw_arg = kwonlyargs.pop(0)
            kw_default = kw_defaults.pop(0)
            self.print(', ')
            self.visit(kw_arg)
            if kw_default is not None:
                self.print('={:node}', kw_default)
        
        if node.kwarg:
            self.print('{0}**{1}', ', ' if i else '', node.kwarg)
            if node.varargannotation:
                self.print(':{:node}', node.kwargannotation)

    def visitNum(self, node):
        self.print(repr(node.n))
        
    def visitlong(self, node):
        self.print(repr(node))

    def visitBinOp(self, node):
        self.print('({left:node} {op:node} {right:node})', left=node.left, op=node.op, right=node.right)

    def visitAdd(self, node):
        self.print('+')

    def visitalias(self, node):
        if node.asname is None:
            self.print("{0}", node.name)
        else:
            self.print("{0} as {1}", node.name, node.asname)

    def visitCall(self, node):

        self.print('{func:node}(' , func=node.func)
        i = 0

        print_comma = lambda i: self.print(", ") if i > 0 else None
        with self.no_indent:

            for arg in node.args:
                print_comma(i)
                self.print('{:node}', arg)
                i += 1

            for kw in node.keywords:
                print_comma(i)
                self.print('{:node}', kw)
                i += 1

            if node.starargs:
                print_comma(i)
                self.print('*{:node}', node.starargs)
                i += 1

            if node.kwargs:
                print_comma(i)
                self.print('**{:node}', node.kwargs)
                i += 1

            self.print(')')

    def visitkeyword(self, node):
        self.print("{0}={1:node}", node.arg, node.value)

    def visitStr(self, node):
        self.print(repr(node.s))

    def visitMod(self, node):
        self.print('%')

    def visitTuple(self, node, brace='()'):
        self.print(brace[0])

        print_comma = lambda i: self.print(", ") if i > 0 else None

        i = 0
        with self.no_indent:
            for elt in  node.elts:
                print_comma(i)
                self.print('{:node}', elt)
                i += 1
                
            if len(node.elts) == 1:
                self.print(',')

            self.print(brace[1])

    def visitCompare(self, node):
        self.print('({0:node}', node.left)
        with self.no_indent:
            for (op, right) in zip(node.ops, node.comparators):
                self.print(' {0:node} {1:node}' , op, right)
            self.print(')')

    @py2op
    def visitRaise(self, node):
        self.print('raise ')
        with self.no_indent:
            if node.type:
                self.print('{:node}' , node.type)
            if node.inst:
                self.print(', {:node}' , node.inst)
            if node.tback:
                self.print(', {:node}' , node.tback)
                
    @visitRaise.py3op
    def visitRaise(self, node):
        self.print('raise ')
        with self.no_indent:
            if node.exc:
                self.print('{:node}' , node.exc)
            if node.cause:
                self.print(' from {:node}' , node.cause)

    def visitAttribute(self, node):
        self.print('{:node}.{attr}', node.value, attr=node.attr)

    def visitDict(self, node):
        self.print('{{')

        items = zip(node.keys, node.values)

        with self.no_indent:
            i = 0
            pc = lambda : self.print(", ") if i > 0 else None

            for key, value in items:
                pc()
                self.print('{0:node}:{1:node}', key, value)
                i += 1

            self.print('}}')

    def visitSet(self, node):
        self.print('{{')

        items = node.elts

        with self.no_indent:
            i = 0
            pc = lambda : self.print(", ") if i > 0 else None

            for value in items:
                pc()
                self.print('{0:node}', value)
                i += 1

            self.print('}}')

    def visitList(self, node):
        self.print('[')

        with self.no_indent:
            i = 0
            pc = lambda : self.print(", ") if i > 0 else None

            for item in node.elts:
                pc()
                self.print('{:node}', item)
                i += 1
            self.print(']')

    def visitSubscript(self, node):

        self.print('{0:node}[{1:node}]', node.value, node.slice)

    def visitIndex(self, node):
        if isinstance(node.value, _ast.Tuple):
            with self.no_indent:
                self.visit(node.value, brace=['', ''])
        else:
            self.print('{:node}', node.value)

    def visitSlice(self, node):
        with self.no_indent:
            if node.lower is not None:
                self.print('{:node}', node.lower)
            self.print(':')
            if node.upper is not None:
                self.print('{:node}', node.upper)

            if node.step is not None:
                self.print(':')
                self.print('{:node}', node.step)

    def visitExtSlice(self, node):

        dims = list(node.dims)
        with self.no_indent:
            dim = dims.pop(0)
            self.print('{0:node}', dim)
            
            while dims:
                dim = dims.pop(0)
                self.print(', {0:node}', dim)

    def visitUnaryOp(self, node):
        self.print('({0:node}{1:node})', node.op, node.operand)

    def visitAssert(self, node):
        self.print('assert {0:node}', node.test)

        if node.msg:
            with self.no_indent:
                self.print(', {0:node}', node.msg)

    visitUSub = simple_string('-')
    visitUAdd = simple_string('+')
    visitNot = simple_string('not ')
    visitInvert = simple_string('~')

    visitAnd = simple_string('and')
    visitOr = simple_string('or')

    visitSub = simple_string('-')
    visitFloorDiv = simple_string('//')
    visitDiv = simple_string('/')
    visitMod = simple_string('%')
    visitMult = simple_string('*')
    visitPow = simple_string('**')

    visitEq = simple_string('==')
    visitNotEq = simple_string('!=')

    visitLt = simple_string('<')
    visitGt = simple_string('>')

    visitLtE = simple_string('<=')
    visitGtE = simple_string('>=')

    visitLShift = simple_string('<<')
    visitRShift = simple_string('>>')

    visitIn = simple_string('in')
    visitNotIn = simple_string('not in')

    visitIs = simple_string('is')
    visitIsNot = simple_string('is not')

    visitBitAnd = simple_string('&')
    visitBitOr = simple_string('|')
    visitBitXor = simple_string('^')

    visitEllipsis = simple_string('...')

    visitYield = simple_string('yield {value:node}')

    def visitBoolOp(self, node):

        with self.no_indent:
            values = list(node.values)
            left = values.pop(0)

            self.print('({:node}', left)
            while values:
                left = values.pop(0)
                self.print(' {0:node} {1:node}', node.op, left)
            self.print(')')

    def visitIfExp(self, node):
        self.print('{body:node} if {test:node} else {orelse:node}', **node.__dict__)

    def visitLambda(self, node):
        self.print('lambda {0:node}: {1:node}', node.args, node.body)

    def visitListComp(self, node):
        self.print('[{0:node}', node.elt)


        generators = list(node.generators)
        with self.no_indent:
            while generators:
                generator = generators.pop(0)
                self.print('{0:node}', generator)

            self.print(']')

    def visitSetComp(self, node):
        self.print('{{{0:node}', node.elt)


        generators = list(node.generators)
        with self.no_indent:
            while generators:
                generator = generators.pop(0)
                self.print('{0:node}', generator)

            self.print('}}')

    def visitDictComp(self, node):
        self.print('{{{0:node}:{1:node}', node.key, node.value)


        generators = list(node.generators)
        with self.no_indent:
            while generators:
                generator = generators.pop(0)
                self.print('{0:node}', generator)

            self.print('}}')


    def visitcomprehension(self, node):
        self.print(' for {0:node} in {1:node}', node.target, node.iter)

        ifs = list(node.ifs)
        while ifs:
            if_ = ifs.pop(0)
            self.print(" if {0:node}", if_)

    @py3op
    def visitarg(self, node):
        self.print(node.arg)
        
        if node.annotation:
            with self.no_indent:
                self.print(':{0:node}', node.annotation)
    
def visit_expr(node):
    gen = ExprSourceGen()
    gen.visit(node)
    return gen.dumps()

class NoIndent(object):
    def __init__(self, gen):
        self.gen = gen

    def __enter__(self):
        self.level = self.gen.level
        self.gen.level = 0

    def __exit__(self, *args):
        self.gen.level = self.level

class Indenter(object):
    def __init__(self, gen):
        self.gen = gen

    def __enter__(self):
        self.gen.print('\n', level=0)
        self.gen.level += 1

    def __exit__(self, *args):
        self.gen.level -= 1

class SourceGen(ExprSourceGen):

    def __init__(self, header=''):
        super(SourceGen, self).__init__()
        print(header, file=self.out)

    def visitModule(self, node):

        children = list(self.children(node))
        if children and isinstance(children[0], _ast.Expr):
            if isinstance(children[0].value, _ast.Str):
                doc = children.pop(0).value
                self.print("'''")
                self.print_lines(doc.s.split('\n'))
                self.print_lines(["'''", '\n', '\n'])

        for node in children:
            self.visit(node)

    def visitFor(self, node):
        self.print('for {0:node} in {1:node}:', node.target, node.iter)
        with self.indenter:
            for stmnt in node.body:
                self.visit(stmnt)

        if node.orelse:
            self.print('else:')
            with self.indenter:
                for stmnt in node.orelse:
                    self.visit(stmnt)

    @py2op
    def visitFunctionDef(self, node):
        # fields = ('name', 'args', 'body', 'decorator_list')

        for decorator in node.decorator_list:
            self.print('@{decorator:node}\n', decorator=decorator)

        args = visit_expr(node.args)
        self.print('def {name}({args}):' , name=node.name, args=args)

        with self.indenter:
            for child in node.body:
                self.visit(child)
        return
    
    @visitFunctionDef.py3op
    def visitFunctionDef(self, node):

        for decorator in node.decorator_list:
            self.print('@{decorator:node}\n', decorator=decorator)

        args = visit_expr(node.args)
        self.print('def {name}({args})' , name=node.name, args=args)
        
        with self.no_indent:
            if node.returns:
                self.print(' -> {:node}:', node.returns)
            else:
                self.print(':', node.returns)
            
        with self.indenter:
            for child in node.body:
                self.visit(child)
        return

    def visitAssign(self, node):
        targets = [visit_expr(target) for target in node.targets]

        self.print('{targets} = {value:node}\n', targets=' = '.join(targets), value=node.value)

    def visitAugAssign(self, node):
        self.print('{target:node} {op:node}= {value:node}\n', **node.__dict__)

    def visitIf(self, node, indent_first=True):
        with noctx() if indent_first else self.no_indent:
            self.print('if {:node}:', node.test)

        with self.indenter:
            if node.body:
                for expr in node.body:
                    self.visit(expr)
            else:
                self.print('pass')
                    

        if node.orelse and len(node.orelse) == 1 and isinstance(node.orelse[0], _ast.If):
            self.print('el'); self.visit(node.orelse[0], indent_first=False)
        elif node.orelse:
            self.print('else:')
            with self.indenter:
                for expr in node.orelse:
                    self.visit(expr)
        self.print('\n')

    def visitImportFrom(self, node):
        for name in node.names:
            self.print("from {0} import {1:node}\n", node.module, name)

    def visitImport(self, node):
        for name in node.names:
            self.print("import {:node}\n", name)

    def visitPrint(self, node):
        self.print("print ")

        with self.no_indent:
            if node.dest:
                self.print(">> {:node}" , node.dest)
                if not node.values and node.nl:
                    self.print("\n")
                    return

                self.print(", ")

            i = 0
            pc = lambda : self.print(", ") if i > 0 else None
            for value in  node.values:
                pc()
                self.print("{:node}" , value)

            if not node.nl:
                self.print(",")

            self.print("\n")

    def visitExec(self, node):
        self.print('exec {0:node} in {1}, {2}\n', node.body,
                   'None' if node.globals is None else str_node(node.globals),
                   'None' if node.locals is None else str_node(node.locals))

    def visitWith(self, node):
        self.print('with {0:node}', node.context_expr)
        if node.optional_vars is not None:
            self.print(' as {0:node}', node.optional_vars, level=0)
        self.print(':', level=0)

        with self.indenter:
            if node.body:
                for expr in node.body:
                    self.visit(expr)
            else:
                self.print('pass\n')

    def visitGlobal(self, node):
        self.print('global ')
        with self.no_indent:
            names = list(node.names)
            if names:
                name = names.pop(0)
                self.print(name)
            while names:
                name = names.pop(0)
                self.print(', {0}', name)
            self.print('\n')


    def visitDelete(self, node):
        self.print('del ')

        targets = list(node.targets)

        with self.no_indent:
            target = targets.pop(0)
            self.print('{0:node}', target)
            while targets:
                target = targets.pop(0)
                self.print(', {0:node}', target)
            self.print('\n')

    def visitWhile(self, node):
        self.print('while {0:node}:', node.test)

        with self.indenter:
            if node.body:
                for expr in node.body:
                    self.visit(expr)
            else:
                self.print("pass")
                    

        if node.orelse:
            self.print('else:')
            with self.indenter:
                for expr in node.orelse:
                    self.visit(expr)
            self.print('\n')
        self.print('\n')


    def visitExpr(self, node):
        self.print('{:node}\n', node.value)

    visitBreak = simple_string('break\n')
    visitPass = simple_string('pass\n')
    visitContinue = simple_string('continue\n')

    def visitReturn(self, node):
        if node.value is not None:
            self.print('return {:node}\n', node.value)

    def visitTryExcept(self, node):
        self.print('try:')

        with self.indenter:
            if node.body:
                for stmnt in node.body:
                    self.visit(stmnt)
            else:
                self.print('pass')
                    
        for hndlr in node.handlers:
            self.visit(hndlr)

        if node.orelse:
            self.print('else:')
            with self.indenter:
                for stmnt in node.orelse:
                    self.visit(stmnt)
    @py2op
    def visitExceptHandler(self, node):

        self.print('except')

        with self.no_indent:
            if node.type:
                self.print(" {0:node}", node.type)
            if node.name:
                self.print(" as {0:node}", node.name)

            self.print(":")

        with self.indenter:
            if node.body:
                for stmnt in node.body:
                    self.visit(stmnt)
            else:
                self.print('pass')
                
    @visitExceptHandler.py3op
    def visitExceptHandler(self, node):
        self.print('except')

        with self.no_indent:
            if node.type:
                self.print(" {0:node}", node.type)
            if node.name:
                self.print(" as {0}", node.name)

            self.print(":")

        with self.indenter:
            for stmnt in node.body:
                self.visit(stmnt)
                
                
    def visitTryFinally(self, node):
        for item in node.body:
            self.visit(item)

        self.print('finally:')

        with self.indenter:
            for item in node.finalbody:
                self.visit(item)
    
    @py2op
    def visitClassDef(self, node):

        for decorator in node.decorator_list:
            self.print('@{0:node}\n', decorator)

        self.print('class {0}', node.name)

        with self.no_indent:
            self.print('(')
            bases = list(node.bases)
            if bases:
                base = bases.pop(0)
                self.print("{0:node}", base)
                while bases:
                    base = bases.pop(0)
                    self.print(", {0:node}", base)
            self.print(')')

            self.print(":")

        with self.indenter:
            if node.body:
                for stmnt in node.body:
                    self.visit(stmnt)
            else:
                self.print("pass\n\n")

    @visitClassDef.py3op
    def visitClassDef(self, node):

        for decorator in node.decorator_list:
            self.print('@{0:node}\n', decorator)

        self.print('class {0}', node.name)

        with self.no_indent:
            self.print('(')
            bases = list(node.bases)
            i = 0
            if bases:
                i += 1
                base = bases.pop(0)
                self.print("{0:node}", base)
                while bases:
                    base = bases.pop(0)
                    self.print(", {0:node}", base)
            keywords = list(node.keywords)
            
            if keywords:
                if i: self.print(', ')
                i += 1
                keyword = keywords.pop(0)
                self.print("{0:node}", keyword)
                while keywords:
                    base = keywords.pop(0)
                    self.print(", {0:node}", keyword)
            
            if node.starargs:
                if i: self.print(', ')
                i += 1
                self.print("*{0:node}", node.starargs)

            if node.kwargs:
                if i: self.print(', ')
                i += 1
                self.print("*{0:node}", node.kwargs)
                
            self.print(')')

            self.print(":")

        with self.indenter:
            if node.body:
                for stmnt in node.body:
                    self.visit(stmnt)
            else:
                self.print("pass\n\n")

def python_source(ast, file=sys.stdout):
    '''
    Generate executable python source code from an ast node.
      
    :param ast: ast node
    :param file: file to write output to.
    '''
    gen = SourceGen()
    gen.visit(ast)
    gen.dump(file)

def dump_python_source(ast):
    '''
    :return: a string containing executable python source code from an ast node.
      
    :param ast: ast node
    :param file: file to write output to.
    '''
    gen = SourceGen()
    gen.visit(ast)
    return gen.dumps()




########NEW FILE########
__FILENAME__ = symbol_visitor
'''
Created on Aug 3, 2011

@author: sean
'''
from meta.asttools.visitors import Visitor
import ast

class SymbolVisitor(Visitor):
    def __init__(self, ctx_types=(ast.Load, ast.Store)):

        if not isinstance(ctx_types, (list, tuple)):
            ctx_types = (ctx_types,)

        self.ctx_types = tuple(ctx_types)

    def visitDefault(self, node):
        ids = set()
        for child in self.children(node):

            if isinstance(child, (tuple, list)):
                for item in child:
                    ids.update(self.visit(item))

            elif isinstance(child, ast.AST):
                ids.update(self.visit(child))

        return ids

    def visitName(self, node):
        if isinstance(node.ctx, self.ctx_types):
            return {node.id}
        else:
            return set()

    def visitalias(self, node):

        name = node.asname if node.asname else node.name

        if '.' in name:
            name = name.split('.', 1)[0]

        if ast.Store in self.ctx_types:
            return {name}
        else:
            return set()



def get_symbols(node, ctx_types=(ast.Load, ast.Store)):
    '''
    Returns all symbols defined in an ast node. 
    
    if ctx_types is given, then restrict the symbols to ones with that context.
    
    :param node: ast node
    :param ctx_types: type or tuple of types that may be found assigned to the `ctx` attribute of 
                      an ast Name node.
        
    '''
    gen = SymbolVisitor(ctx_types)
    return gen.visit(node)

########NEW FILE########
__FILENAME__ = bytecode_consumer
'''
Created on Apr 28, 2012

@author: sean
'''
from .disassembler_ import disassembler


class ByteCodeConsumer(object):
    '''
    ByteCodeVisitor
    '''
    def __init__(self, code):
        self.code = code
        self.byte_code = code.co_code
        
    def consume(self):
        '''
        Consume byte-code
        '''
        generic_consume = getattr(self, 'generic_consume', None)
        
        for instr in disassembler(self.code):
            method_name = 'consume_%s' % (instr.opname)
            method = getattr(self, method_name, generic_consume)
            if not method:
                raise AttributeError("class %r has no method %r" % (type(self).__name__, method_name))
            
            self.instruction_pre(instr)
            method(instr)
            self.instruction_post(instr)
            
    def instruction_pre(self, instr):
        '''
        consumer calls this instruction before every instruction.
        '''
    
    def instruction_post(self, instr):
        '''
        consumer calls this instruction after every instruction.
        '''
    

class StackedByteCodeConsumer(ByteCodeConsumer):
    '''
    A consumer with the concept of a stack.
    '''
    
    def __init__(self, code):
        ByteCodeConsumer.__init__(self, code)
        self._stack = []
        
    def pop_top(self):
        return self._stack.pop()
    
    def push(self, value):
        self._stack.append(value)
    

########NEW FILE########
__FILENAME__ = disassembler_
'''
Created on May 10, 2012

@author: sean
'''

from __future__ import print_function

import opcode
from dis import findlabels, findlinestarts
import sys
from meta.bytecodetools.instruction import Instruction

py3 = sys.version_info.major >= 3
co_ord = (lambda c:c) if py3 else ord

def disassembler(co, lasti= -1):
    """Disassemble a code object. 
    
    :param co: code object
    :param lasti: internal
    :yields: Instructions.
    
    """

    code = co.co_code
    labels = findlabels(code)
    linestarts = dict(findlinestarts(co))
    n = len(code)
    i = 0
    extended_arg = 0
    lineno = 0
    free = None
    while i < n:
        c = code[i]
        op = co_ord(c)
    
    
        if i in linestarts:
            lineno = linestarts[i]

        instr = Instruction(i=i, op=op, lineno=lineno)
        instr.linestart = i in linestarts

        if i == lasti:
            instr.lasti = True
        else:
            instr.lasti = False

        if i in labels:
            instr.label = True
        else:
            instr.label = False

        i = i + 1
        if op >= opcode.HAVE_ARGUMENT:
            oparg = co_ord(code[i]) + co_ord(code[i + 1]) * 256 + extended_arg
            instr.oparg = oparg
            extended_arg = 0
            i = i + 2
            if op == opcode.EXTENDED_ARG:
                extended_arg = oparg * 65536
            instr.extended_arg = extended_arg
            if op in opcode.hasconst:
                instr.arg = co.co_consts[oparg]
            elif op in opcode.hasname:
                instr.arg = co.co_names[oparg]
            elif op in opcode.hasjrel:
                instr.arg = i + oparg
            elif op in opcode.haslocal:
                instr.arg = co.co_varnames[oparg]
            elif op in opcode.hascompare:
                instr.arg = opcode.cmp_op[oparg]
            elif op in opcode.hasfree:
                if free is None:
                    free = co.co_cellvars + co.co_freevars
                instr.arg = free[oparg]

        yield instr


########NEW FILE########
__FILENAME__ = instruction
'''
Created on May 10, 2012

@author: sean
'''
from __future__ import print_function

import opcode
import sys

py3 = sys.version_info.major >= 3
co_ord = (lambda c:c) if py3 else ord


class Instruction(object):
    '''
    A Python byte-code instruction. 
    '''
    def __init__(self, i= -1, op=None, lineno=None):
        self.i = i
        self.op = op
        self.lineno = lineno
        self.oparg = None
        self.arg = None
        self.extended_arg = 0
        self.linestart = False

    @property
    def opname(self):
        return opcode.opname[self.op]
    
    @property
    def is_jump(self):
        return self.op in opcode.hasjrel or self.op in opcode.hasjabs
    
    @property
    def to(self):
        if self.op in opcode.hasjrel:
            return self.arg
        elif self.op in opcode.hasjabs:
            return self.oparg
        else:
            raise Exception("this is not a jump op (%s)" % (self.opname,))

    def __repr__(self):
        res = '<%s(%i)' % (opcode.opname[self.op], self.i,)

        if self.arg is not None:
            res += ' arg=%r' % (self.arg,)
        elif self.oparg is not None:
            res += ' oparg=%r' % (self.oparg,)
        return res + '>'

    def __str__(self):
        result = []

        if self.linestart:
            result.append("%3d" % self.lineno)
        else:
            result.append("   ")

        if self.lasti:
            result.append('-->')
        else:
            result.append('   ')

        if self.label:
            result.append('>>')
        else:
            result.append('  ')

        result.append(repr(self.i).rjust(4))

        result.append(opcode.opname[self.op].ljust(20))

        if self.op >= opcode.HAVE_ARGUMENT:

            result.append(repr(self.oparg).rjust(5))
            if self.op in opcode.hasconst:
                result.append('(' + repr(self.arg) + ')')
            elif self.op in opcode.hasname:
                result.append('(' + repr(self.arg) + ')')
            elif self.op in opcode.hasjrel:
                result.append('(to ' + repr(self.arg) + ')')
            elif self.op in opcode.haslocal:
                result.append('(' + repr(self.arg) + ')')
            elif self.op in opcode.hascompare:
                result.append('(' + repr(self.arg) + ')')
            elif self.op in opcode.hasfree:
                result.append('(' + repr(self.arg) + ')')
        return ' '.join(result)

        

########NEW FILE########
__FILENAME__ = print_code
'''
Created on May 10, 2012

@author: sean
'''
from __future__ import print_function

from .bytecode_consumer import ByteCodeConsumer
from argparse import ArgumentParser

class ByteCodePrinter(ByteCodeConsumer):
    
    def generic_consume(self, instr):
        print(instr)

def main():
    parser = ArgumentParser()
    parser.add_argument()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = pyc_file
'''
Created on May 10, 2012

@author: sean
'''

from imp import get_magic
import time
import struct
import marshal

def extract(binary):
    '''
    Extract a code object from a binary pyc file.
    
    :param binary: a sequence of bytes from a pyc file.
    '''
    if len(binary) <= 8:
        raise Exception("Binary pyc must be greater than 8 bytes (got %i)" % len(binary))
    
    magic = binary[:4]
    MAGIC = get_magic()
    
    if magic != MAGIC:
        raise Exception("Python version mismatch (%r != %r) Is this a pyc file?" % (magic, MAGIC))
    
    modtime = time.asctime(time.localtime(struct.unpack('i', binary[4:8])[0]))

    code = marshal.loads(binary[8:])
    
    return modtime, code


########NEW FILE########
__FILENAME__ = control_flow_instructions
'''
Created on Jul 14, 2011

@author: sean
'''
from __future__ import print_function
import opcode
import _ast
from meta.bytecodetools.instruction import Instruction
from meta.asttools.visitors.print_visitor import print_ast
from meta.utils import py3op, py2op, py3
AND_JUMPS = ['JUMP_IF_FALSE_OR_POP', 'POP_JUMP_IF_FALSE']
OR_JUMPS = ['JUMP_IF_TRUE_OR_POP', 'POP_JUMP_IF_TRUE']
JUMPS = AND_JUMPS + OR_JUMPS
JUMP_OPS = [opcode.opmap[name] for name in JUMPS]


def split(block, name):
    func = lambda instr: instr.opname == name
    return split_cond(block, func)

def split_cond(block, func, raise_=True):
    block = block[:]

    new_block = []
    while len(block):
        instr = block.pop(0)
        if func(instr):
            return new_block, instr, block
        new_block.append(instr)

    if raise_:
        raise Exception("function found no matching instruction")

    return new_block, None, block

def find_index(lst, func, default=None):
    for i, item in enumerate(lst):
        if func(item):
            return i
    else:
        return default

def rfind_index(lst, func, default=None):
    for i, item in reversed(list(enumerate(lst))):
        if func(item):
            return i
    else:
        return default

def refactor_ifs(stmnt, ifs):
    '''
    for if statements in list comprehension
    '''
    if isinstance(stmnt, _ast.BoolOp):
        test, right = stmnt.values
        if isinstance(stmnt.op, _ast.Or):
            test = _ast.UnaryOp(op=_ast.Not(), operand=test, lineno=0, col_offset=0)

        ifs.append(test)

        return refactor_ifs(right, ifs)
    return stmnt

def parse_logic(struct):

    lineno = struct.lineno

    kw = dict(lineno=lineno, col_offset=0)
    if isinstance(struct.right, LogicalOp):
        ast_right, insert_into = parse_logic(struct.right)
        assert insert_into is None
    else:
        ast_right = struct.right

    parent = struct.parent

    Logic = _ast.Or if struct.flag == 'OR' else _ast.And

    if isinstance(parent, LogicalOp):
        ast_parent, insert_into = parse_logic(struct.parent)

        new_insert_into = [ast_right]
        insert_into.insert(0, _ast.BoolOp(op=Logic(), values=new_insert_into, **kw))
        return ast_parent, new_insert_into

    elif parent is None:
        insert_into = [ast_right]
        return _ast.BoolOp(op=Logic(), values=insert_into, **kw), insert_into

    else:
        bool_op = _ast.BoolOp(op=Logic(), values=[parent, ast_right], **kw)
        return bool_op, None


class ListCompTmp(object):
    def __init__(self, assign, list, ifs, lineno):
        self.assign = assign.nodes[0]
        self.list = list
        self.ifs = ifs
        self.lineno = lineno

class LogicalOp(object):
    def __init__(self, flag, right, parent, lineno):
        self.flag = flag
        self.right = right
        self.parent = parent
        self.lineno = lineno

    def __repr__(self):
        return '%s(%r, parent=%r)' % (self.flag, self.right, self.parent)


def reduce_cmp(right):
    if isinstance(right, _ast.Return):
        return right.value
    if isinstance(right, LogicalOp) and right.flag == 'AND':
        right.right = reduce_cmp(right.right)
        if isinstance(right.right, _ast.Compare) and isinstance(right.parent, _ast.Compare):
            if right.parent.comparators[-1] is  right.right.left:
                right.parent.ops.extend(right.right.ops)
                right.parent.comparators.extend(right.right.comparators)
                right = right.parent
            
    return right



def JUMP_IF_X_OR_POP(operand):
    def JUMP_IF_Y_OR_POP(self, instr):
        left = self.pop_ast_item()
        and_block = self.gather_jumps(instr)
        hi = self.process_logic([instr] + and_block)
        
        # Compress (a > b) and (b > c) into (a > b > c)
        hi.right = reduce_cmp(hi.right)
        
        if isinstance(hi.right, _ast.Compare):
            if isinstance(left, _ast.Compare) and left.comparators[-1] is hi.right.left:
                left.ops.extend(hi.right.ops)
                left.comparators.extend(hi.right.comparators)
            else:
                left = _ast.BoolOp(op=operand(), values=[left, hi.right], lineno=instr.lineno, col_offset=0)
        else:
            bool_op, insert_into = parse_logic(hi)
            insert_into.insert(0, left)
            left = bool_op
             
        self.push_ast_item(left)
        
        if len(self.ilst) >= 2 and [ii.opname for ii in self.ilst[:2]] == ['ROT_TWO', 'POP_TOP']:
            self.ilst.pop(0)
            self.ilst.pop(0)
    return JUMP_IF_Y_OR_POP

class CtrlFlowInstructions(object):

    def split_handlers(self, handlers_blocks):
        handlers = []
        except_instrs = []

        ends = []
        while len(handlers_blocks):

            instr = handlers_blocks.pop(0)
            except_instrs.append(instr)

            if (instr.opname == 'COMPARE_OP') and (instr.arg == 'exception match'):

                jump = handlers_blocks.pop(0)
                assert jump.opname == 'POP_JUMP_IF_FALSE'

                next_handler = jump.oparg

                instr = handlers_blocks.pop(0)
                except_instrs.append(instr)
                instr = handlers_blocks.pop(0)
                except_instrs.append(instr)
                instr = handlers_blocks.pop(0)
                except_instrs.append(instr)

                assert except_instrs[0].opname == 'DUP_TOP'
                assert except_instrs[-3].opname == 'POP_TOP'
                assert except_instrs[-1].opname == 'POP_TOP'

                exec_stmnt = self.decompile_block(except_instrs[1:-4]).stmnt()

                assert len(exec_stmnt) == 1

                exc_type = exec_stmnt[0]


                if except_instrs[-2].opname == 'STORE_NAME':
                    exc_name = _ast.Name(id=except_instrs[-2].arg, ctx=_ast.Store(), lineno=except_instrs[-2].lineno, col_offset=0)
                else:
                    assert except_instrs[-2].opname == 'POP_TOP'
                    exc_name = None

                handler_body = []
                while len(handlers_blocks):
                    instr = handlers_blocks.pop(0)
                    if instr.i == next_handler:
                        handlers_blocks.insert(0, instr)
                        break

                    handler_body.append(instr)

                assert handler_body[-1].opname == 'JUMP_FORWARD'
                ends.append(handler_body[-1].arg)

                exc_body = self.decompile_block(handler_body[:-1]).stmnt()
                if not exc_body:
                    exc_body.append(_ast.Pass(lineno=except_instrs[-2].lineno, col_offset=0))
                # is this for python 3?
                if py3 and exc_name is not None:
                    exc_name = exc_name.id
                    
                handlers.append(_ast.ExceptHandler(type=exc_type, name=exc_name, body=exc_body, lineno=instr.lineno, col_offset=0))

                except_instrs = []

        assert except_instrs[-1].opname == 'END_FINALLY'

        if len(except_instrs) == 1:
            pass
        else:

            assert except_instrs[0].opname == 'POP_TOP'
            assert except_instrs[1].opname == 'POP_TOP'
            assert except_instrs[2].opname == 'POP_TOP'
            assert except_instrs[-2].opname in ['JUMP_FORWARD', 'JUMP_ABSOLUTE'], except_instrs[-2]
            ends.append(except_instrs[-2].arg)
            exc_body = self.decompile_block(except_instrs[3:-2]).stmnt()
            if not exc_body:
                exc_body.append(_ast.Pass(lineno=except_instrs[-2].lineno, col_offset=0))

            handlers.append(_ast.ExceptHandler(type=None, name=None, body=exc_body, lineno=except_instrs[0].lineno, col_offset=0))

            assert all(e == ends[0] for e in ends)

        end = ends[0]

        return end, handlers
    

#    @py3op
    def do_try_except_block(self, block):
        
        while 1:
            instr = block.pop(-1)
            if instr.opname == 'POP_BLOCK':
                break

        try_except = self.decompile_block(block).stmnt()
        
        finally_block = []
        while 1:
            next_instr = self.ilst.pop(0)
            if next_instr.opname == 'END_FINALLY':
                break
            finally_block.append(next_instr)

        finally_ = self.decompile_block(finally_block).stmnt()

        try_finally = _ast.TryFinally(body=try_except, finalbody=finally_)
        
        self.push_ast_item(try_finally)

#    @py3op
    def do_except_block(self, block):
        
        handler_block = []
        for instr in block:
            if  instr.opname == 'POP_BLOCK':
                break
            handler_block.append(instr)
            
        while 1:
            instr = self.ilst.pop(0)
            if instr.opname == 'END_FINALLY':
                break 

        body = self.decompile_block(handler_block).stmnt()
        
        self._ast_stack.extend(body)
        
#    @py2op
#    def SETUP_FINALLY(self, instr):
#        pass
#
#    @SETUP_FINALLY.py3op
    def SETUP_FINALLY(self, instr):
        to = instr.arg
        try_except_block = self.make_block(to, inclusive=False)
        
        if try_except_block[0].opname == 'SETUP_EXCEPT':
            self.do_try_except_block(try_except_block)
        else:
            self.do_except_block(try_except_block)
            
#            raise Exception()
#        print("try_except_block", try_except_block)
#        
#        finally_block = []
#        while 1:
#            next_instr = self.ilst.pop(0)
#            if next_instr.opname == 'END_FINALLY':
#                break
#            finally_block.append(next_instr)
#
#        print("finally_block", finally_block)
#        
#        finally_ = self.decompile_block(finally_block).stmnt()
#        
#        print("finally_", finally_)
#        print_ast(finally_[0])
#        print()
# #        print_ast(finally_[1])
# #        print("\n\n")
#        
#        try_except = self.decompile_block(try_except_block).stmnt()
        
    @py2op
    def SETUP_EXCEPT(self, instr):

        to = instr.arg

        try_block = self.make_block(to, inclusive=False)

        assert try_block[-1].opname in ['JUMP_FORWARD', 'JUMP_ABSOLUTE'], try_block[-1] 
        assert try_block[-2].opname == 'POP_BLOCK', try_block[-2]

        try_stmnts = self.decompile_block(try_block[:-2]).stmnt()
        body = try_stmnts

        handlers_blocks = self.make_block(try_block[-1].arg, inclusive=False, raise_=False)

        end, handlers = self.split_handlers(handlers_blocks)
        
        # raise exception in python 3 (python 2 ilst does not include end so else may go beond)
        else_block = self.make_block(end, inclusive=False, raise_=py3)

        else_stmnts = self.decompile_block(else_block).stmnt()
        if else_stmnts:
            else_ = else_stmnts
        else:
            else_ = []

        try_except = _ast.TryExcept(body=body, handlers=handlers, orelse=else_, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(try_except)

    @SETUP_EXCEPT.py3op
    def SETUP_EXCEPT(self, instr):

        to = instr.arg

        try_block = self.make_block(to, inclusive=False)

        assert try_block[-1].opname in ['JUMP_FORWARD', 'JUMP_ABSOLUTE']
        assert try_block[-2].opname == 'POP_BLOCK'

        try_stmnts = self.decompile_block(try_block[:-2]).stmnt()
        body = try_stmnts

        handlers_blocks = self.make_block(try_block[-1].arg, inclusive=False, raise_=False)

        end, handlers = self.split_handlers(handlers_blocks)

        else_block = self.make_block(end, inclusive=False, raise_=False)
        
        else_stmnts = self.decompile_block(else_block).stmnt()
        
        if else_stmnts:
            else_ = else_stmnts
        else:
            else_ = []

        try_except = _ast.TryExcept(body=body, handlers=handlers, orelse=else_, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(try_except)
    
    @py3op
    def POP_EXCEPT(self, instr):
        pass
    
    def SETUP_LOOP(self, instr):
        to = instr.arg
        loop_block = self.make_block(to, inclusive=False, raise_=False)

        if 'FOR_ITER' in [ins.opname for ins in loop_block]:
            self.for_loop(loop_block)
        else:
            self.while_loop(instr, loop_block)

    def BREAK_LOOP(self, instr):
        self.push_ast_item(_ast.Break(lineno=instr.lineno, col_offset=0))

    def for_loop(self, loop_block):
        iter_block, _, body_else_block = split(loop_block, 'GET_ITER')

#        for_iter = body_else_block[0]
        for_iter = body_else_block.pop(0)

        assert for_iter.opname == 'FOR_ITER'

        idx = find_index(body_else_block, lambda instr: instr.opname == 'POP_BLOCK' and for_iter.to == instr.i)

        assert idx is not False

        body_block = body_else_block[:idx]

        else_block = body_else_block[idx + 1:]

        jump_abs = body_block.pop()

        assert jump_abs.opname == 'JUMP_ABSOLUTE' and jump_abs.to == for_iter.i

        iter_stmnt = self.decompile_block(iter_block).stmnt()

        assert len(iter_stmnt) == 1
        iter_stmnt = iter_stmnt[0]
        body_lst = self.decompile_block(body_block[:], stack_items=[None], jump_map={for_iter.i:for_iter.to}).stmnt()

        assign_ = body_lst.pop(0)
        body = body_lst

        if len(else_block) == 0:
            else_ = []
        else:
            else_ = self.decompile_block(else_block[:]).stmnt()

        assign = assign_.targets[0]
        for_ = _ast.For(target=assign, iter=iter_stmnt, body=body, orelse=else_, lineno=iter_stmnt.lineno, col_offset=0)

        self.push_ast_item(for_)

    def make_list_comp(self, get_iter, for_iter):

        block = self.make_block(for_iter.to, inclusive=False, raise_=False)

        jump_abs = block.pop()

        assert jump_abs.opname == 'JUMP_ABSOLUTE', jump_abs.opname
        jump_map = {for_iter.i:for_iter.to}

        stmnts = self.decompile_block(block, stack_items=[None], jump_map=jump_map).stmnt()

        if len(stmnts) > 1:

            assign = stmnts.pop(0)
    
            assert len(stmnts) == 1
    
            assert isinstance(assign, _ast.Assign)
    
    
            list_expr = self.pop_ast_item()
    
            # empty ast.List object
            list_ = self.pop_ast_item()
    
            ifs = []
            elt = refactor_ifs(stmnts[0], ifs)
    
            assert len(assign.targets) == 1
            generators = [_ast.comprehension(target=assign.targets[0], iter=list_expr, ifs=ifs, lineno=get_iter.lineno, col_offset=0)]
    
            if isinstance(list_, _ast.Assign):
                
                comp = _ast.comprehension(target=list_.targets[0], iter=None, ifs=ifs, lineno=get_iter.lineno, col_offset=0)
                generators.insert(0, comp)
            
            list_comp = _ast.ListComp(elt=elt, generators=generators, lineno=get_iter.lineno, col_offset=0)
        else:
            list_expr = self.pop_ast_item()
            list_comp = stmnts[0]
            
            generators = list_comp.generators
            
            # empty ast.List object
            list_ = self.pop_ast_item()
            if not isinstance(list_, _ast.Assign):
                comp = _ast.comprehension(target=list_.targets[0], iter=None, ifs=[], lineno=get_iter.lineno, col_offset=0)
                generators.insert(0, comp)
                
            generators[0].iter = list_expr

        self.push_ast_item(list_comp)

    def extract_listcomp(self, function, sequence):

        assert len(function.body) == 1
        assert isinstance(function.body[0], _ast.Return)

        value = function.body[0].value

        assert isinstance(value, _ast.ListComp)
        
        generators = list(value.generators)
        for generator in generators:
            if generator.iter.id == '.0':
                generator.iter = sequence
        
        setcomp = _ast.ListComp(elt=value.elt, generators=generators, lineno=value.lineno, col_offset=0)
        self.push_ast_item(setcomp)
        
    def extract_setcomp(self, function, sequence):
        
        assert len(function.body) == 1
        assert isinstance(function.body[0], _ast.Return)

        value = function.body[0].value

        assert isinstance(value, _ast.ListComp)
        
        generators = list(value.generators)
        for generator in generators:
            if generator.iter.id == '.0':
                generator.iter = sequence
        
        setcomp = _ast.SetComp(elt=value.elt, generators=generators, lineno=value.lineno, col_offset=0)
        self.push_ast_item(setcomp)

    def extract_dictcomp(self, function, sequence):

        assert len(function.body) == 1
        assert isinstance(function.body[0], _ast.Return)

        value = function.body[0].value

        assert isinstance(value, _ast.ListComp)
        
        generators = list(value.generators)
        for generator in generators:
            if generator.iter.id == '.0':
                generator.iter = sequence
        
        setcomp = _ast.DictComp(key=value.elt[0], value=value.elt[1], generators=generators, lineno=value.lineno, col_offset=0)
        self.push_ast_item(setcomp)
#
#        assert len(function.code.nodes) == 1
#        assert isinstance(function.code.nodes[0], _ast.Return)
#
#        value = function.code.nodes[0].value
#
#        assert isinstance(value, _ast.ListComp)
#
#        quals = value.quals
#        key, value = value.expr
#
#        for qual in quals:
#            qual.list = sequence
#
#        setcomp = _ast.DictComp(key=key, value=value, generators=quals, lineno=value.lineno, col_offset=0)
#        self.push_ast_item(setcomp)

    def GET_ITER(self, instr):
        for_iter = self.ilst.pop(0)

        if for_iter.opname == 'CALL_FUNCTION':
            call_function = for_iter
            assert call_function.oparg == 1

            sequence = self.pop_ast_item()
            function = self.pop_ast_item()

            if function.name == '<listcomp>':
                self.extract_listcomp(function, sequence)
            elif function.name == '<setcomp>':
                self.extract_setcomp(function, sequence)
            elif function.name == '<dictcomp>':
                self.extract_dictcomp(function, sequence)
            else:
                assert False, function.name

        elif for_iter.opname == 'FOR_ITER':
            self.make_list_comp(instr, for_iter)
        else:
            assert False


    def LIST_APPEND(self, instr):
#        assert instr.oparg == 2
        pass

    def MAP_ADD(self, instr):
        key = self.pop_ast_item()
        value = self.pop_ast_item()

        self.push_ast_item((key, value))
        'NOP'

    def SET_ADD(self, instr):
        'NOP'

    def FOR_ITER(self, instr):
        # set or dict comp
        self.make_list_comp(instr, instr)

    def while_loop(self, instr, loop_block):

        kw = dict(lineno=instr.lineno, col_offset=0)

        loop_block_map = {instr.i:instr.op for instr in loop_block}

        first_i = loop_block[0].i
        
        func = lambda instr: instr.opname == 'JUMP_ABSOLUTE' and instr.oparg == first_i
        body_index = rfind_index(loop_block[:-1], func)
         
        if body_index is None:
            const_while = True
            body_index = len(loop_block) - 1
        else:
            if body_index + 1 < len(loop_block): 
                pop_block = loop_block[body_index + 1]
                const_while = pop_block.opname != 'POP_BLOCK'
                const_else = True
            else:
                const_while = True
                const_else = False
           
        if const_while:
            test = _ast.Num(1, **kw)
            body_ = self.decompile_block(loop_block[:body_index]).stmnt()

            else_block = loop_block[body_index + 1:]
            if else_block:
                else_ = self.decompile_block(else_block).stmnt()
            else:
                else_ = []
        else:
            pop_block = loop_block[body_index + 1]
            
            func = lambda instr: instr.opname in ['POP_JUMP_IF_FALSE', 'POP_JUMP_IF_TRUE'] and instr.oparg == pop_block.i
            idx = rfind_index(loop_block[:body_index], func)
            cond_block = loop_block[:idx]

            iter_stmnt = self.decompile_block(cond_block).stmnt()
            assert len(iter_stmnt) == 1
            test = iter_stmnt[0]
            
            body_ = self.decompile_block(loop_block[idx + 1:body_index]).stmnt()

            else_block = loop_block[body_index + 2:]
            if else_block:
                else_ = self.decompile_block(else_block[:]).stmnt()
            else:
                else_ = []

        while_ = _ast.While(test=test, body=body_, orelse=else_, **kw)

        self.push_ast_item(while_)


    def gather_jumps(self, jump_instr):
        
        
        to = self.jump_map.get(jump_instr.to, jump_instr.to)
        assert to > jump_instr.i

        and_block = self.make_block(to=to, inclusive=False, raise_=False)

        jump_tos = {to}
        last_len = 0
        old_max = to
        
        while len(jump_tos) != last_len:
            last_len = len(jump_tos)

            for instr in and_block:
                if instr.opname in JUMPS:
                    to = self.jump_map.get(instr.to, instr.to)
                    assert to > jump_instr.i
                    jump_tos.add(to)

            if old_max < max(jump_tos):
                old_max = max(jump_tos)
                new_block = self.make_block(to=old_max, inclusive=False, raise_=False)
                and_block.extend(new_block)

        # print("and_block", and_block)
        return and_block

    def process_logic(self, logic_block):

        if logic_block[0].opname in JUMPS:
            jump_instr = logic_block[0]
            flag = 'OR' if jump_instr.opname in OR_JUMPS else 'AND'
            idx = find_index(logic_block, lambda instr: jump_instr.oparg == instr.i, default=None)

            if idx is None:
                if len(logic_block) == 1:
                    right = None
                else:
                    right = self.process_logic(logic_block[1:])
                parent = None
            else:
                right = self.process_logic(logic_block[1:idx - 1])
                parent = self.process_logic(logic_block[idx - 1:])

            return LogicalOp(flag, right, parent, jump_instr.lineno)
        else:
            idx = find_index(logic_block, lambda instr: instr.opname in JUMPS, default=None)

            if idx is None:
                if len(logic_block) == 3 and [ii.opname for ii in logic_block[1:]] == ['ROT_TWO', 'POP_TOP']:
                    assert logic_block[0].opname in ['JUMP_FORWARD', 'RETURN_VALUE'], logic_block 
                    return None
                stmnts = self.decompile_block(logic_block).stmnt()
                if len(stmnts) > 1:
                    self._ast_stack.extend(stmnts[:-1]) 
                return stmnts[-1]
            
            else:
                right = logic_block[idx:]
                parent = logic_block[:idx]

                if len(parent) == 3 and [ii.opname for ii in parent[1:]] == ['ROT_TWO', 'POP_TOP']:
                    assert parent[0].opname in ['JUMP_FORWARD', 'RETURN_VALUE'], parent
                    parent = None
                else:
                    stmnts = self.decompile_block(parent).stmnt()
                    
                    if len(stmnts) == 1:
                        parent = stmnts[-1]
                    else:
                        parent = stmnts[-1]
                        self._ast_stack.extend(stmnts[:-1]) 
                        
                    parent = stmnts[-1]

                right = self.process_logic(right)
                
                if parent is not None:
                    if right.parent is None:
                        right.parent = parent
                    else:
                        right, to_insrt = parse_logic(right)
                        to_insrt.insert(0, parent)
                        return right
                        
                if right.right is None:
                    return parent

                return right



    def logic_ast(self, instr, left, hi):
#        flag = 'OR' if opname[instr.op] in OR_JUMPS else 'AND'

        ast_, insert_into = parse_logic(hi)

        insert_into.insert(0, left)

        return ast_

    def make_if(self, instr, left, and_block):
        block = [instr] + and_block[:-1]

        maxmax = max(block, key=lambda ins: (0, 0) if (ins.op not in JUMP_OPS) else (self.jump_map.get(ins.oparg, ins.oparg), ins.i))

        idx = block.index(maxmax)

        assert idx is not None

        hi = self.process_logic(block[:idx + 1])
        
        if hi.right is None and hi.parent is None:
            if instr.opname == 'POP_JUMP_IF_TRUE':
                cond = _ast.UnaryOp(op=_ast.Not(), operand=left, lineno=0, col_offset=0)
            else:
                cond = left

        else:
            cond = self.logic_ast(instr, left, hi)
            
        jump = and_block[-1]
        
        if jump.opname == 'RETURN_VALUE':
            body_block = block[idx + 1:] + [jump]
        else:
            body_block = block[idx + 1:]
            
        body = self.decompile_block(body_block).stmnt()
        
        if jump.is_jump:
            else_block = self.make_block(jump.to, inclusive=False, raise_=False)
        else:  # it is a return
            else_block = []

        if len(else_block):
            else_ = self.decompile_block(else_block).stmnt()
#
#            if len(else_lst) == 1 and isinstance(else_lst[0], _ast.If):
#                elif_ = else_lst[0]
#                tests.extend(elif_.tests)
#                else_ = elif_.else_
#            else:
#                else_ = else_lst
        else:
            else_ = []

        if_ = _ast.If(test=cond, body=body, orelse=else_, lineno=instr.lineno, col_offset=0)
        
        self.push_ast_item(if_)


    def POP_JUMP_IF_TRUE(self, instr):
        
        left = self.pop_ast_item()

        and_block = self.gather_jumps(instr)

        if and_block[-1].opname in ['JUMP_FORWARD', 'JUMP_ABSOLUTE', 'RETURN_VALUE']:

            self.make_if(instr, left, and_block)
            return
        else:
            hi = self.process_logic([instr] + and_block)
            ast_ = self.logic_ast(instr, left, hi)
            self.push_ast_item(ast_)

    def POP_JUMP_IF_FALSE(self, instr):
        
        left = self.pop_ast_item()

        and_block = self.gather_jumps(instr)
        # This is an IF statement
        if and_block[-1].opname in ['JUMP_FORWARD', 'JUMP_ABSOLUTE', 'RETURN_VALUE']:
            
            # this happens if the function was going to return anyway
            if and_block[-1].opname == 'RETURN_VALUE':
                JUMP_FORWARD = Instruction(and_block[-1].i, 110, lineno=0)
                JUMP_FORWARD.arg = instr.to
                and_block.append(JUMP_FORWARD)
            
            # print()
            # print("make_if", instr, left, and_block)
            # print()
            self.make_if(instr, left, and_block)
            return
        else:  # This is an expression
            hi = self.process_logic([instr] + and_block)
            ast_ = self.logic_ast(instr, left, hi)
            self.push_ast_item(ast_)

    JUMP_IF_FALSE_OR_POP = JUMP_IF_X_OR_POP(_ast.And)
    JUMP_IF_TRUE_OR_POP = JUMP_IF_X_OR_POP(_ast.Or)

    def JUMP_ABSOLUTE(self, instr):
        continue_ = _ast.Continue(lineno=instr.lineno, col_offset=0)
        self.push_ast_item(continue_)

    def JUMP_FORWARD(self, instr):
        pass

    def SETUP_WITH(self, instr):

        with_block = self.make_block(to=instr.to, inclusive=False)

        assert with_block.pop().opname == 'LOAD_CONST'
        assert with_block.pop().opname == 'POP_BLOCK'

        with_cleanup = self.ilst.pop(0)
        assert with_cleanup.opname == 'WITH_CLEANUP'
        end_finally = self.ilst.pop(0)
        assert end_finally.opname == 'END_FINALLY'


        with_ = self.decompile_block(with_block, stack_items=['WITH_BLOCK']).stmnt()

        if isinstance(with_[0], _ast.Assign) and with_[0].value == 'WITH_BLOCK':
            assign = with_.pop(0)
            as_ = assign.targets[0]
        else:
            as_ = None

        body = with_

        expr = self.pop_ast_item()

        with_ = _ast.With(context_expr=expr, optional_vars=as_, body=body,
                          lineno=instr.lineno, col_offset=0)

        self.push_ast_item(with_)
        
    def CONTINUE_LOOP(self, instr):
        cont = _ast.Continue(lineno=instr.lineno, col_offset=0)
        self.push_ast_item(cont)
         

########NEW FILE########
__FILENAME__ = disassemble
'''
Created on Jul 14, 2011

@author: sean
'''
from __future__ import print_function

from dis import findlabels, findlinestarts
import types
import sys
from meta.bytecodetools.disassembler_ import disassembler
import opcode

py3 = sys.version_info.major >= 3

co_ord = (lambda c:c) if py3 else ord

def disassemble(co):
    """Disassemble a code object."""
    return list(disassembler(co))

def print_code(co, lasti= -1, level=0):
    """Disassemble a code object."""
    code = co.co_code
    
    for constant in co.co_consts:
        print( '|              |' * level, end=' ')
        print( 'constant:', constant)
        
    labels = findlabels(code)
    linestarts = dict(findlinestarts(co))
    n = len(code)
    i = 0
    extended_arg = 0
    free = None
    while i < n:
        have_inner = False
        c = code[i]
        op = co_ord(c)

        if i in linestarts:
            if i > 0:
                print()
            print( '|              |' * level, end=' ')
            print( "%3d" % linestarts[i], end=' ')
        else:
            print( '|              |' * level, end=' ')
            print('   ', end=' ')

        if i == lasti: print( '-->',end=' ')
        else: print( '   ', end=' ')
        if i in labels: print( '>>', end=' ')
        else: print( '  ',end=' ')
        print(repr(i).rjust(4), end=' ')
        print(opcode.opname[op].ljust(20), end=' ')
        i = i + 1
        if op >= opcode.HAVE_ARGUMENT:
            oparg = co_ord(code[i]) + co_ord(code[i + 1]) * 256 + extended_arg
            extended_arg = 0
            i = i + 2
            if op == opcode.EXTENDED_ARG:
                extended_arg = oparg * 65536
            print( repr(oparg).rjust(5), end=' ')
            if op in opcode.hasconst:

                print( '(' + repr(co.co_consts[oparg]) + ')', end=' ')
                if type(co.co_consts[oparg]) == types.CodeType:
                    have_inner = co.co_consts[oparg]

            elif op in opcode.hasname:
                print( '(' + co.co_names[oparg] + ')',end=' ')
            elif op in opcode.hasjrel:
                print('(to ' + repr(i + oparg) + ')', end=' ')
            elif op in opcode.haslocal:
                print('(' + co.co_varnames[oparg] + ')', end=' ')
            elif op in opcode.hascompare:
                print('(' + opcode.cmp_op[oparg] + ')', end=' ')
            elif op in opcode.hasfree:
                if free is None:
                    free = co.co_cellvars + co.co_freevars
                print('(' + free[oparg] + ')', end=' ')
        print()

        if have_inner is not False:
            print_code(have_inner, level=level + 1)

########NEW FILE########
__FILENAME__ = expression_mutator
'''
Created on Nov 27, 2012

@author: sean
'''

from ast import NodeTransformer
import _ast
 
class ExpressionMutator(NodeTransformer):
    def visit_If(self, node):

        assert len(node.body) == 1
        
        assert len(node.orelse) == 1
        
        test = self.visit(node.test)
        then = self.visit(node.body[0])
        else_ = self.visit(node.orelse[0])

        if_exp = _ast.IfExp(test, then, else_, lineno=node.lineno, col_offset=0)
        return if_exp
    
    def visit_Return(self, node):
        return NodeTransformer.generic_visit(self, node.value) 
    
    def visit_FunctionDef(self, node):
        return node
    
    def generic_visit(self, node):
        if node is None:
            return node
        if isinstance(node, (str)):
            import pdb;pdb.set_trace()
            return node
        
#        if not isinstance(node, (_ast.expr, _ast.expr_context, _ast.slice, _ast.operator, _ast.boolop)):
#            raise Exception("expected a Python '_ast.expr' node (got %r)" % (type(node),))
        return NodeTransformer.generic_visit(self, node)
    

########NEW FILE########
__FILENAME__ = instructions
'''
Created on Jul 14, 2011

@author: sean
'''
from __future__ import print_function

from meta.decompiler.simple_instructions import SimpleInstructions
from meta.decompiler.control_flow_instructions import CtrlFlowInstructions
import _ast
from meta.asttools import print_ast
from meta.utils import py3, py3op, py2op
from meta.decompiler.expression_mutator import ExpressionMutator
from ast import copy_location as cpy_loc

function_ops = ['CALL_FUNCTION', 'CALL_FUNCTION_KW', 'CALL_FUNCTION_VAR', 'CALL_FUNCTION_VAR_KW']

def merge_ifs(stmnts):
    last = stmnts.pop()
    
    while len(stmnts):
        stmnt = stmnts.pop()
        if isinstance(stmnt, _ast.If):
            if stmnt.orelse and not isinstance(stmnt.orelse[0], _ast.If):
                break
            stmnt.orelse.append(last)
            last = stmnt
    stmnts.append(last)
    return stmnts 
        
    
def pop_doc(stmnts):

    doc = pop_assignment(stmnts, '__doc__')

    assert isinstance(doc, _ast.Str) or doc is None

    return doc

def pop_assignment(stmnts, name):

    for i in range(len(stmnts)):
        stmnt = stmnts[i]
        if isinstance(stmnt, _ast.Assign) and len(stmnt.targets) == 1 \
            and isinstance(stmnt.targets[0], _ast.Name) \
            and isinstance(stmnt.targets[0].ctx, _ast.Store):
            if stmnt.targets[0].id == name:
                stmnts.pop(i)
                return stmnt.value

    return None

def pop_return(stmnts):

    ns = len(stmnts)
    for i in range(ns - 1, -1, -1):
        stmnt = stmnts[i]
        if isinstance(stmnt, _ast.Return):
            return stmnts.pop(i)
    return None


def make_module(code):
        from meta.decompiler.disassemble import disassemble
        instructions = Instructions(disassemble(code))
        stmnts = instructions.stmnt()

        doc = pop_doc(stmnts)
        pop_return(stmnts)

#        stmnt = ast.Stmt(stmnts, 0)

        if doc is not None:
            stmnts = [_ast.Expr(value=doc, lineno=doc.lineno, col_offset=0)] + stmnts

        ast_obj = _ast.Module(body=stmnts, lineno=0, col_offset=0)

        return ast_obj

@py2op
def make_function(code, defaults=None, lineno=0):
        from meta.decompiler.disassemble import disassemble

        instructions = Instructions(disassemble(code))

        stmnts = instructions.stmnt()

        if code.co_flags & 2:
            vararg = None
            kwarg = None

        varnames = list(code.co_varnames[:code.co_argcount])
        co_locals = list(code.co_varnames[code.co_argcount:])

        #have var args
        if code.co_flags & 4:
            vararg = co_locals.pop(0)

        #have kw args
        if code.co_flags & 8:
            kwarg = co_locals.pop()

        args = [_ast.Name(id=argname, ctx=_ast.Param(), lineno=lineno, col_offset=0) for argname in varnames]
            
        args = _ast.arguments(args=args,
                              defaults=defaults if defaults else [],
                              kwarg=kwarg,
                              vararg=vararg,
                              lineno=lineno, col_offset=0
                              )
        if code.co_name == '<lambda>':
            stmnts = merge_ifs(stmnts)

            body = _ast.Return(ExpressionMutator().visit(stmnts[0]))
            cpy_loc(body, stmnts[0])
            
            ast_obj = _ast.Lambda(args=args, body=body, lineno=lineno, col_offset=0)
        else:

            if instructions.seen_yield:
                return_ = stmnts[-1]

                assert isinstance(return_, _ast.Return)
                assert isinstance(return_.value, _ast.Name)
                assert return_.value.id == 'None'
                return_.value = None
            ast_obj = _ast.FunctionDef(name=code.co_name, args=args, body=stmnts, decorator_list=[], lineno=lineno, col_offset=0)

        return ast_obj

@make_function.py3op
def make_function(code, defaults=None, annotations=(), kw_defaults=(), lineno=0):
        from meta.decompiler.disassemble import disassemble

        instructions = Instructions(disassemble(code))

        stmnts = instructions.stmnt()

        if code.co_flags & 2:
            vararg = None
            kwarg = None

        varnames = list(code.co_varnames[:code.co_argcount])
        kwonly_varnames = list(code.co_varnames[code.co_argcount:code.co_argcount + code.co_kwonlyargcount])
        co_locals = list(code.co_varnames[code.co_argcount + code.co_kwonlyargcount:])

        assert (len(kw_defaults) % 2) == 0
        
        kw_defaults = list(kw_defaults)
        kw_default_dict = {}
        
        while kw_defaults:
            name = kw_defaults.pop(0)
            value = kw_defaults.pop(0)
            
            kw_default_dict[name.s] = value
        
        kw_defaults = []
        for argname in kwonly_varnames:
            kw_defaults.append(kw_default_dict.pop(argname))
        
        #have var args
        if code.co_flags & 4:
            vararg = co_locals.pop(0)

        #have kw args
        if code.co_flags & 8:
            kwarg = co_locals.pop()

        args = []
        annotation_names = [annotation.arg for annotation in annotations]
        
        for argname in varnames:
            if argname in annotation_names:
                arg = [annotation for annotation in annotations if annotation.arg == argname][0]
            else:
                arg = _ast.arg(annotation=None, arg=argname, lineno=lineno, col_offset=0) #@UndefinedVariable
                
            args.append(arg)

        kwonlyargs = []

        for argname in kwonly_varnames:
            if argname in annotation_names:
                arg = [annotation for annotation in annotations if annotation.arg == argname][0]
            else:
                arg = _ast.arg(annotation=None, arg=argname, lineno=lineno, col_offset=0) #@UndefinedVariable
                
            kwonlyargs.append(arg)
            
        if 'return' in annotation_names:
            arg = [annotation for annotation in annotations if annotation.arg == 'return'][0]
            returns = arg.annotation
        else:
            returns = None
        
        if vararg in annotation_names:
            arg = [annotation for annotation in annotations if annotation.arg == vararg][0]
            varargannotation = arg.annotation
        else:
            varargannotation = None
            
        if kwarg in annotation_names:
            arg = [annotation for annotation in annotations if annotation.arg == kwarg][0]
            kwargannotation = arg.annotation
        else:
            kwargannotation = None
        
        args = _ast.arguments(args=args,
                              defaults=defaults if defaults else [],
                              kwarg=kwarg,
                              vararg=vararg,
                              kw_defaults=kw_defaults,
                              kwonlyargs=kwonlyargs,
                              kwargannotation=kwargannotation,
                              varargannotation=varargannotation,
                              lineno=lineno, col_offset=0
                              )
        
        
        if code.co_name == '<lambda>':
            stmnts = merge_ifs(stmnts)

            body = _ast.Return(ExpressionMutator().visit(stmnts[0]))
            cpy_loc(body, stmnts[0])
            
            ast_obj = _ast.Lambda(args=args, body=body, lineno=lineno, col_offset=0)
        else:

            if instructions.seen_yield:
                return_ = stmnts[-1]

                assert isinstance(return_, _ast.Return)
                assert isinstance(return_.value, _ast.Name)
                assert return_.value.id == 'None'
                return_.value = None
            
            ast_obj = _ast.FunctionDef(name=code.co_name, args=args,
                                       body=stmnts, decorator_list=[],
                                       returns=returns,
                                       lineno=lineno, col_offset=0)

        return ast_obj

class StackLogger(list):
    def append(self, object):
        print('    + ', end='')
        print_ast(object, indent='', newline='')
        print()
        list.append(self, object)

    def pop(self, *index):
        value = list.pop(self, *index)
        print('    - ', end='')
        print_ast(value, indent='', newline='')
        print()
        return value

def bitrange(x, start, stop):
    return ((1 << (stop - start)) - 1) & (x >> start)

level = 0
class Instructions(CtrlFlowInstructions, SimpleInstructions):

    def __init__(self, ilst, stack_items=None, jump_map=False, outer_scope=None):
        self.ilst_processed = []
        self.ilst = ilst[:]
        self.orig_ilst = ilst
        self.seen_yield = False
        self.outer_scope = outer_scope

        if jump_map:
            self.jump_map = jump_map
        else:
            self.jump_map = {}

#        self.ast_stack = StackLogger()
        self._ast_stack = []

        if stack_items:
            self._ast_stack.extend(stack_items)
    
    def pop_ast_item(self):
        if self._ast_stack:
            item = self._ast_stack.pop()
        else:
            item = self.outer_scope.pop_ast_item()

#        print(' ' * level, '- ', end='')
#        print_ast(item, indent='', newline='')
#        print()

        return item
    
    def push_ast_item(self, item):
        
#        print(' ' * level, '+ ', end='')
#        print_ast(item, indent='', newline='')
#        print()

        self._ast_stack.append(item)
    
    def decompile_block(self, ilst, stack_items=None, jump_map=False):
        return Instructions(ilst, stack_items=stack_items, jump_map=jump_map, outer_scope=self)

    def stmnt(self):

        while len(self.ilst):
            instr = self.ilst.pop(0)
            self.visit(instr)

        return self._ast_stack

    def visit(self, instr):
        global level
        name = instr.opname.replace('+', '_')

        method = getattr(self, name, None)
        if method is None:
            raise AttributeError('can not handle instruction %r' % (str(instr)))
        
#        print(' ' * level, "*%s* visit:" % instr.opname, repr(instr))
#        level += 1
        method(instr)
#        level -= 1
#        print(' ' * level, "* stack:", self._ast_stack)


    def make_block(self, to, inclusive=True, raise_=True):
#        print("make_block", to,)
        block = []
        while len(self.ilst):
            instr = self.ilst.pop(0)
            block.append(instr)
            
#            instr_i = self.jump_map.get(instr.i, instr.i)
            instr_i = instr.i
            
            if to == instr_i:
                if not inclusive:
                    instr = block.pop()
                    self.ilst.insert(0, instr)
                break
        else:
            if raise_:
#                print(block)
                raise IndexError("no instrcution i=%s " % (to,))

        return block
    
    @py3op
    def MAKE_FUNCTION(self, instr):

        code = self.pop_ast_item()
        
        ndefaults = bitrange(instr.oparg, 0, 8)
        nkwonly_defaults = bitrange(instr.oparg, 8, 16)
        nannotations = bitrange(instr.oparg, 16, 32) - 1
        
        annotations = []
        for i in range(nannotations):
            annotations.insert(0, self.pop_ast_item())
        
        kw_defaults = []
        for i in range(nkwonly_defaults * 2):
            kw_defaults.insert(0, self.pop_ast_item())
            
        defaults = []
        for i in range(ndefaults):
            defaults.insert(0, self.pop_ast_item())

        function = make_function(code, defaults, lineno=instr.lineno, annotations=annotations, kw_defaults=kw_defaults)
        
        doc = code.co_consts[0] if code.co_consts else None
        
        if isinstance(doc, str):
            function.body.insert(0, _ast.Expr(value=_ast.Str(s=doc, lineno=instr.lineno, col_offset=0),
                                              lineno=instr.lineno, col_offset=0))
            
        self.push_ast_item(function)
        
    @MAKE_FUNCTION.py2op
    def MAKE_FUNCTION(self, instr):

        code = self.pop_ast_item()

        ndefaults = instr.oparg

        defaults = []
        for i in range(ndefaults):
            defaults.insert(0, self.pop_ast_item())

        function = make_function(code, defaults, lineno=instr.lineno)
        
        doc = code.co_consts[0] if code.co_consts else None
        
        if isinstance(doc, str):
            function.body.insert(0, _ast.Expr(value=_ast.Str(s=doc, lineno=instr.lineno, col_offset=0),
                                              lineno=instr.lineno, col_offset=0))

        
        self.push_ast_item(function)

    def LOAD_LOCALS(self, instr):
        self.push_ast_item('LOAD_LOCALS')
    
    @py3op
    def LOAD_BUILD_CLASS(self, instr):
        
        class_body = []
        
        body_instr = instr

        while body_instr.opname not in function_ops:
            body_instr = self.ilst.pop(0)
            class_body.append(body_instr)
            
        call_func = self.decompile_block(class_body, stack_items=[None]).stmnt()
        
        assert len(call_func) == 1
        call_func = call_func[0]
        
        func_def = call_func.args[0]
        code = func_def.body
        name = call_func.args[1].s
        bases = call_func.args[2:]
        
        keywords = call_func.keywords
        kwargs = call_func.kwargs
        starargs = call_func.starargs
                
        if isinstance(code[0], _ast.Expr):
            _name = code.pop(1)
            _doc = code.pop(1)
        elif isinstance(code[0], _ast.Assign):
            _name = code.pop(0)
        else:
            assert False
            
        ret = code.pop(-1)
        
        assert isinstance(ret, _ast.Return)
            
        class_ = _ast.ClassDef(name=name, bases=bases, body=code, decorator_list=[],
                               kwargs=kwargs, keywords=keywords, starargs=starargs,
                               lineno=instr.lineno, col_offset=0,
                               )

        self.push_ast_item(class_)
    
    @py2op
    def BUILD_CLASS(self, instr):

        call_func = self.pop_ast_item()

        assert isinstance(call_func, _ast.Call)

        func = call_func.func

        assert isinstance(func, _ast.FunctionDef)

        code = func.body
        pop_assignment(code, '__module__')
        doc = pop_doc(code)

        ret = code.pop()

        assert isinstance(ret, _ast.Return) and ret.value == 'LOAD_LOCALS'

        bases = self.pop_ast_item()

        assert isinstance(bases, _ast.Tuple)
        bases = bases.elts
        name = self.pop_ast_item()

        class_ = _ast.ClassDef(name=name, bases=bases, body=code, decorator_list=[],
                               lineno=instr.lineno, col_offset=0)

        self.push_ast_item(class_)

    def LOAD_CLOSURE(self, instr):
        self.push_ast_item('CLOSURE')

    def MAKE_CLOSURE(self, instr):
        return self.MAKE_FUNCTION(instr)
    

########NEW FILE########
__FILENAME__ = recompile
'''
Created on Nov 3, 2011

@author: sean
'''
import os
import sys
import struct
from time import time

py3 = sys.version_info.major >= 3

if py3:
    import builtins #@UnresolvedImport
else:
    import __builtin__ as builtins
     
import marshal
import imp
from py_compile import PyCompileError, wr_long

MAGIC = imp.get_magic()

def create_pyc(codestring, cfile, timestamp=None):

    if timestamp is None:
        timestamp = time()
    
    codeobject = builtins.compile(codestring, '<recompile>', 'exec')
        
    cfile.write(MAGIC)
    cfile.write(struct.pack('i', timestamp))
    marshal.dump(codeobject, cfile)
    cfile.flush()
    
def dump_pyc(code, fd, timestamp=None):

    if timestamp is None:
        timestamp = time()
    
    fd.write(MAGIC)
    fd.write(struct.pack('i', timestamp))
    marshal.dump(code, fd)
    fd.flush()
    

########NEW FILE########
__FILENAME__ = simple_instructions
'''
Created on Jul 14, 2011

@author: sean
'''
from __future__ import print_function

from opcode import *
import _ast
import sys

from meta.utils import py3, py3op, py2op
from meta.asttools.visitors.print_visitor import print_ast, dump_ast
from meta.asttools import cmp_ast
from meta.decompiler.expression_mutator import ExpressionMutator

if py3:
    class _ast_Print: pass
    basestring = str
else:
    _ast_Print = _ast.Print

def isNone(node):
    if node is None:
        return True
    elif isinstance(node, _ast.Name) and (node.id == 'None') and isinstance(node.ctx, _ast.Load):
        return True

    return False

def BINARY_(OP):

    def BINARY_OP(self, instr):
        right = self.pop_ast_item()
        left = self.pop_ast_item()

        add = _ast.BinOp(left=left, right=right, op=OP(), lineno=instr.lineno, col_offset=0)

        self.push_ast_item(add)
    return BINARY_OP

def INPLACE_(OP):

    def INPLACE_OP(self, instr):
        right = self.pop_ast_item()
        left = self.pop_ast_item()

        left.ctx = _ast.Store()
        aug_assign = _ast.AugAssign(target=left, op=OP(), value=right, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(aug_assign)

    return INPLACE_OP


def UNARY_(OP):

    def UNARY_OP(self, instr):
        expr = self.pop_ast_item()
        not_ = _ast.UnaryOp(op=OP(), operand=expr, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(not_)

    return UNARY_OP

CMP_OPMAP = {'>=' :_ast.GtE,
             '<=' :_ast.LtE,
             '>' :_ast.Gt,
             '<' :_ast.Lt,
             '==': _ast.Eq,
             '!=': _ast.NotEq,
             'in': _ast.In,
             'not in': _ast.NotIn,
             'is':_ast.Is,
             'is not':_ast.IsNot,
             }

def make_const(arg, lineno=0, col_offset=0):
    kw = {'lineno':lineno, 'col_offset':col_offset}

    if isinstance(arg, basestring):
        const = _ast.Str(s=arg, **kw)
    elif isinstance(arg, (int, float, complex)):
        const = _ast.Num(n=arg, **kw)
    elif arg is None:
        const = _ast.Name(id='None', ctx=_ast.Load(), **kw)
    elif isinstance(arg, tuple):
        elts = []
        for item in arg:
            elts.append(make_const(item, **kw))
        const = _ast.Tuple(elts=elts, ctx=_ast.Load(), **kw)
    else:
        const = arg
    
    return const
    
class SimpleInstructions(object):

    def LOAD_CONST(self, instr):
        const = make_const(instr.arg, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(const)

    def LOAD_NAME(self, instr):
        name = _ast.Name(id=instr.arg, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        self.push_ast_item(name)

    def LOAD_DEREF(self, instr):
        name = _ast.Name(id=instr.arg, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        self.push_ast_item(name)

    def CALL_FUNCTION_VAR(self, instr):

        arg = self.pop_ast_item()

        self.CALL_FUNCTION(instr)
        callfunc = self.pop_ast_item()

        callfunc.starargs = arg

        self.push_ast_item(callfunc)

    def CALL_FUNCTION_KW(self, instr):

        kwarg = self.pop_ast_item()

        self.CALL_FUNCTION(instr)
        callfunc = self.pop_ast_item()

        callfunc.kwargs = kwarg

        self.push_ast_item(callfunc)

    def CALL_FUNCTION_VAR_KW(self, instr):
        kwarg = self.pop_ast_item()
        arg = self.pop_ast_item()

        self.CALL_FUNCTION(instr)
        callfunc = self.pop_ast_item()

        callfunc.starargs = arg
        callfunc.kwargs = kwarg

        self.push_ast_item(callfunc)

    def CALL_FUNCTION(self, instr):
        nkwargs = instr.oparg >> 8
        nargs = (~(nkwargs << 8)) & instr.oparg


        args = []
        keywords = []

        for _ in range(nkwargs):
            expr = self.pop_ast_item()
            name = self.pop_ast_item()

            keyword = _ast.keyword(arg=name.s, value=expr, lineno=instr.lineno)
            keywords.insert(0, keyword)

        for _ in range(nargs):
            arg = self.pop_ast_item()
            args.insert(0, arg)


        if len(args) == 1 and isinstance(args[0], (_ast.FunctionDef, _ast.ClassDef)):
            function = args[0]

            if function.decorator_list is None:
                function.decorator_list = []

            node = self.pop_ast_item()
            function.decorator_list.insert(0, node)

            self.push_ast_item(function)
            return


        node = self.pop_ast_item()
        callfunc = _ast.Call(func=node, args=args, keywords=keywords, starargs=None, kwargs=None,
                             lineno=instr.lineno, col_offset=0)

        self.push_ast_item(callfunc)

    def LOAD_FAST(self, instr):
        name = _ast.Name(id=instr.arg, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        self.push_ast_item(name)

    def LOAD_GLOBAL(self, instr):
        name = _ast.Name(id=instr.arg, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        self.push_ast_item(name)

    def STORE_FAST(self, instr):
        self.STORE_NAME(instr)

    def STORE_DEREF(self, instr):
        self.STORE_NAME(instr)

    def STORE_NAME(self, instr):

        value = self.pop_ast_item()
        value = self.process_ifexpr(value)
        
        if isinstance(value, _ast.Import):

            if value.from_:
                assert isinstance(self._ast_stack[-1], _ast.ImportFrom)
                from_ = self.pop_ast_item()

                as_name = instr.arg
                name = from_.names[0].name
                if as_name != name:
                    from_.names[0].asname = as_name

                self.push_ast_item(from_)
            else:
                as_name = instr.arg
                if value.names[0].asname is None:
                    base_name = value.names[0].name.split('.')[0]
                    if base_name != as_name:
                        value.names[0].asname = as_name

            self.push_ast_item(value)
            
        elif isinstance(value, (_ast.Attribute)) and isinstance(value.value, (_ast.Import)):
            asname = instr.arg
            value = value.value
            value.names[0].asname = asname
            
            self.push_ast_item(value)
            
        elif isinstance(value, (_ast.ClassDef, _ast.FunctionDef)):
            as_name = instr.arg
            value.name = as_name
            self.push_ast_item(value)
        elif isinstance(value, _ast.AugAssign):
            self.push_ast_item(value)
        elif isinstance(value, _ast.Assign):
            _ = self.pop_ast_item()
            assname = _ast.Name(instr.arg, _ast.Store(), lineno=instr.lineno, col_offset=0)
            value.targets.append(assname)
            self.push_ast_item(value)
        else:

            assname = _ast.Name(instr.arg, _ast.Store(), lineno=instr.lineno, col_offset=0)

            assign = _ast.Assign(targets=[assname], value=value, lineno=instr.lineno, col_offset=0)
            self.push_ast_item(assign)
    
    @py3op
    def STORE_LOCALS(self, instr):
        'remove Locals from class def'
        self.pop_ast_item()
        
    def STORE_GLOBAL(self, instr):
        
        if not isinstance(self._ast_stack[0], _ast.Global):
            self._ast_stack.insert(0, _ast.Global(names=[]))
            
        if instr.arg not in self._ast_stack[0].names:
            self._ast_stack[0].names.append(instr.arg)
            
        self.STORE_NAME(instr)
    
    def RETURN_VALUE(self, instr):
        value = self.pop_ast_item()
        value = self.process_ifexpr(value)
        ret = _ast.Return(value=value, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(ret)

    def LOAD_ATTR(self, instr):

        name = self.pop_ast_item()

        attr = instr.arg

        get_attr = _ast.Attribute(value=name, attr=attr, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)

        self.push_ast_item(get_attr)

    def STORE_ATTR(self, instr):

        attrname = instr.arg
        node = self.pop_ast_item()
        expr = self.pop_ast_item()
        expr = self.process_ifexpr(expr)

        assattr = _ast.Attribute(value=node, attr=attrname, ctx=_ast.Store(), lineno=instr.lineno, col_offset=0)
        set_attr = _ast.Assign(targets=[assattr], value=expr, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(set_attr)

    def IMPORT_NAME(self, instr):

        from_ = self.pop_ast_item()

        hmm = self.pop_ast_item()

        names = [_ast.alias(name=instr.arg, asname=None)]
        import_ = _ast.Import(names=names, lineno=instr.lineno, col_offset=0)

        import_.from_ = not isNone(from_)

        self.push_ast_item(import_)

    def IMPORT_FROM(self, instr):
        import_ = self.pop_ast_item()

        names = [_ast.alias(instr.arg, None)]
        modname = import_.names[0].name
        from_ = _ast.ImportFrom(module=modname, names=names, level=0, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(from_)
        self.push_ast_item(import_)

    def IMPORT_STAR(self, instr):
        import_ = self.pop_ast_item()

        names = import_.names
        alias = _ast.alias(name='*', asname=None)

        from_ = _ast.ImportFrom(module=names[0].name, names=[alias], level=0, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(from_)

    def process_ifexpr(self, node):
        if node == 'LOAD_LOCALS': #Special directive
            return node
        
        return ExpressionMutator().visit(node)

    def POP_TOP(self, instr):

        node = self.pop_ast_item()
        node = self.process_ifexpr(node)

        if isinstance(node, _ast.Import):
            return

        if isinstance(node, _ast_Print):
            _ = self.pop_ast_item()
            self.push_ast_item(node)
            return

        discard = _ast.Expr(value=node, lineno=instr.lineno, col_offset=0)
        self.push_ast_item(discard)

    def ROT_TWO(self, instr):
        
        one = self.pop_ast_item()
        two = self.pop_ast_item()
        
        if self.ilst[0].opname == 'STORE_NAME':
            
            kw = dict(lineno=instr.lineno, col_offset=0)
            stores = []
            while self.ilst[0].opname == 'STORE_NAME':
                stores.append(self.ilst.pop(0))
                
            assert len(stores) <= 3, stores
            elts_load = [one, two]
            if len(stores) == 3:
                elts_load.insert(0, self.pop_ast_item())
                
            tup_load = _ast.Tuple(elts=elts_load[::-1], ctx=_ast.Load(), **kw)
            
            elts_store = [_ast.Name(id=store.arg, ctx=_ast.Store(), **kw) for store in stores]
            tup_store = _ast.Tuple(elts=elts_store, ctx=_ast.Store(), **kw)
            
            assgn = _ast.Assign(value=tup_load, targets=[tup_store], **kw)
            self.push_ast_item(assgn)
#            self.push_ast_item(tup_store)
        else:
            self.push_ast_item(one)
            self.push_ast_item(two)

    BINARY_ADD = BINARY_(_ast.Add)
    BINARY_SUBTRACT = BINARY_(_ast.Sub)
    BINARY_DIVIDE = BINARY_(_ast.Div)
    BINARY_TRUE_DIVIDE = BINARY_(_ast.Div)
    BINARY_MULTIPLY = BINARY_(_ast.Mult)
    BINARY_FLOOR_DIVIDE = BINARY_(_ast.FloorDiv)
    BINARY_POWER = BINARY_(_ast.Pow)

    BINARY_AND = BINARY_(_ast.BitAnd)
    BINARY_OR = BINARY_(_ast.BitOr)
    BINARY_XOR = BINARY_(_ast.BitXor)

    BINARY_LSHIFT = BINARY_(_ast.LShift)
    BINARY_RSHIFT = BINARY_(_ast.RShift)
    BINARY_MODULO = BINARY_(_ast.Mod)

    INPLACE_ADD = INPLACE_(_ast.Add)
    INPLACE_SUBTRACT = INPLACE_(_ast.Sub)
    INPLACE_DIVIDE = INPLACE_(_ast.Div)
    INPLACE_FLOOR_DIVIDE = INPLACE_(_ast.FloorDiv)
    INPLACE_MULTIPLY = INPLACE_(_ast.Mult)

    INPLACE_AND = INPLACE_(_ast.BitAnd)
    INPLACE_OR = INPLACE_(_ast.BitOr)
    INPLACE_LSHIFT = INPLACE_(_ast.LShift)
    INPLACE_RSHIFT = INPLACE_(_ast.RShift)
    INPLACE_POWER = INPLACE_(_ast.Pow)
    INPLACE_MODULO = INPLACE_(_ast.Mod)
    INPLACE_XOR = INPLACE_(_ast.BitXor)

    UNARY_NOT = UNARY_(_ast.Not)
    UNARY_NEGATIVE = UNARY_(_ast.USub)
    UNARY_INVERT = UNARY_(_ast.Invert)
    UNARY_POSITIVE = UNARY_(_ast.UAdd)

    def COMPARE_OP(self, instr):
        
        op = instr.arg

        right = self.pop_ast_item()
        
        expr = self.pop_ast_item()

        OP = CMP_OPMAP[op]
        compare = _ast.Compare(left=expr, ops=[OP()], comparators=[right], lineno=instr.lineno, col_offset=0)

        
        self.push_ast_item(compare)
        


    def YIELD_VALUE(self, instr):
        value = self.pop_ast_item()

        yield_ = _ast.Yield(value=value, lineno=instr.lineno, col_offset=0)

        self.push_ast_item(yield_)

        self.seen_yield = True

    def BUILD_LIST(self, instr):

        nitems = instr.oparg

        nodes = []
        list_ = _ast.List(elts=nodes, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        for i in range(nitems):
            nodes.insert(0, self.pop_ast_item())

        self.push_ast_item(list_)

    def BUILD_TUPLE(self, instr):

        nitems = instr.oparg

        nodes = []
        list_ = _ast.Tuple(elts=nodes, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        for i in range(nitems):
            nodes.insert(0, self.pop_ast_item())

        if any([item == 'CLOSURE' for item in nodes]):
            assert all([item == 'CLOSURE' for item in nodes])
            return

        self.push_ast_item(list_)

    def BUILD_SET(self, instr):

        nitems = instr.oparg

        nodes = []
        list_ = _ast.Set(elts=nodes, ctx=_ast.Load(), lineno=instr.lineno, col_offset=0)
        for i in range(nitems):
            nodes.insert(0, self.pop_ast_item())

        self.push_ast_item(list_)

    def BUILD_MAP(self, instr):

        nitems = instr.oparg
        keys = []
        values = []
        for i in range(nitems):
            map_instrs = []
            while 1:
                new_instr = self.ilst.pop(0)

                if new_instr.opname == 'STORE_MAP':
                    break

                map_instrs.append(new_instr)

            items = self.decompile_block(map_instrs).stmnt()
            assert len(items) == 2

            values.append(items[0])
            keys.append(items[1])


        list_ = _ast.Dict(keys=keys, values=values, lineno=instr.lineno, col_offset=0)
        self.push_ast_item(list_)

    def UNPACK_SEQUENCE(self, instr):
        nargs = instr.oparg

        nodes = []
        ast_tuple = _ast.Tuple(elts=nodes, ctx=_ast.Store(), lineno=instr.lineno, col_offset=0)
        for i in range(nargs):
            nex_instr = self.ilst.pop(0)
            self.push_ast_item(None)
            self.visit(nex_instr)

            node = self.pop_ast_item()
            nodes.append(node.targets[0])

        expr = self.pop_ast_item()
        if isinstance(expr, _ast.Assign):
            assgn = expr 
            assgn.targets.append(ast_tuple)
            
            value_dup = self.pop_ast_item()
            
            assert cmp_ast(assgn.value, value_dup)
            
        else:
            assgn = _ast.Assign(targets=[ast_tuple], value=expr, lineno=instr.lineno, col_offset=0)
        self.push_ast_item(assgn)

    def DELETE_NAME(self, instr):

        name = _ast.Name(id=instr.arg, ctx=_ast.Del(), lineno=instr.lineno, col_offset=0)

        delete = _ast.Delete(targets=[name], lineno=instr.lineno, col_offset=0)
        self.push_ast_item(delete)

    def DELETE_FAST(self, instr):

        name = _ast.Name(id=instr.arg, ctx=_ast.Del(), lineno=instr.lineno, col_offset=0)

        delete = _ast.Delete(targets=[name], lineno=instr.lineno, col_offset=0)
        self.push_ast_item(delete)

    def DELETE_ATTR(self, instr):

        expr = self.pop_ast_item()
        attr = _ast.Attribute(value=expr, attr=instr.arg, ctx=_ast.Del(), lineno=instr.lineno, col_offset=0)

        delete = _ast.Delete(targets=[attr], lineno=instr.lineno, col_offset=0)
        self.push_ast_item(delete)

    def EXEC_STMT(self, instr):
        locals_ = self.pop_ast_item()
        globals_ = self.pop_ast_item()
        expr = self.pop_ast_item()

        if locals_ is globals_:
            locals_ = None

        if isinstance(globals_, _ast.Name) and getattr(globals_, 'id',) == 'None':
            globals_ = None

        exec_ = _ast.Exec(body=expr, globals=globals_, locals=locals_, lineno=instr.lineno, col_offset=0)
        
        self.push_ast_item(exec_)

    def DUP_TOP(self, instr):

        expr = self.pop_ast_item()

        self.push_ast_item(expr)
        self.push_ast_item(expr)
    
    @py3op
    def DUP_TOP_TWO(self, instr):
        
        expr1 = self.pop_ast_item()
        expr2 = self.pop_ast_item()

        self.push_ast_item(expr2)
        self.push_ast_item(expr1)
        self.push_ast_item(expr2)
        self.push_ast_item(expr1)

    
    def DUP_TOPX(self, instr):

        exprs = []
        for i in range(instr.oparg):
            expr = self.pop_ast_item()
            exprs.insert(0, expr)
            
        self._ast_stack.extend(exprs)
        self._ast_stack.extend(exprs)
        
    def ROT_THREE(self, instr):
        expr1 = self.pop_ast_item()
        expr2 = self.pop_ast_item()
        expr3 = self.pop_ast_item()
        
        self.push_ast_item(expr1)
        self.push_ast_item(expr3)
        self.push_ast_item(expr2)
        
        
    def ROT_FOUR(self, instr):
        expr1 = self.pop_ast_item()
        expr2 = self.pop_ast_item()
        expr3 = self.pop_ast_item()
        expr4 = self.pop_ast_item()
        
        self.push_ast_item(expr1)
        self.push_ast_item(expr4)
        self.push_ast_item(expr3)
        self.push_ast_item(expr2)
        
        


    def PRINT_ITEM(self, instr):

        item = self.pop_ast_item()

        if self._ast_stack:
            print_ = self._ast_stack[-1]
        else:
            print_ = None

        if isinstance(print_, _ast_Print) and not print_.nl and print_.dest == None:
            print_.values.append(item)
        else:
            print_ = _ast_Print(dest=None, values=[item], nl=False, lineno=instr.lineno, col_offset=0)
            self.push_ast_item(print_)

    def PRINT_NEWLINE(self, instr):
        item = self._ast_stack[-1]

        if isinstance(item, _ast_Print) and not item.nl and item.dest == None:
            item.nl = True
        else:
            print_ = _ast_Print(dest=None, values=[], nl=True, lineno=instr.lineno, col_offset=0)
            self.push_ast_item(print_)

    def PRINT_ITEM_TO(self, instr):

        stream = self.pop_ast_item()

        print_ = None

        if isinstance(stream, _ast_Print) and not stream.nl:
            print_ = stream
            stream = self.pop_ast_item()
            dup_print = self.pop_ast_item()
            assert dup_print is print_
            self.push_ast_item(stream)
        else:
            print_ = _ast_Print(dest=stream, values=[], nl=False, lineno=instr.lineno, col_offset=0)

        item = self.pop_ast_item()

        print_.values.append(item)
        self.push_ast_item(print_)

    def PRINT_NEWLINE_TO(self, instr):

        item = self.pop_ast_item()
        stream = self.pop_ast_item()

        self.push_ast_item(item)

        if isinstance(item, _ast_Print) and not item.nl and item.dest is stream:
            item.nl = True
        else:
            print_ = _ast_Print(dest=stream, values=[], nl=True, lineno=instr.lineno, col_offset=0)
            self.push_ast_item(print_)


    def format_slice(self, index, kw):

        if isinstance(index, _ast.Tuple):
            dims = []
            have_slice = False
            for dim in index.elts:
                if not isinstance(dim, _ast.Slice):
                    dim = _ast.Index(value=dim, **kw)
                else:
                    have_slice = True
                dims.append(dim)

            if have_slice:
                index = _ast.ExtSlice(dims=dims, **kw)
            else:
                index = _ast.Index(value=index, **kw)

        elif not isinstance(index, _ast.Slice):
            index = _ast.Index(value=index, **kw)
        return index

    def BINARY_SUBSCR(self, instr):

        index = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)

        index = self.format_slice(index, kw)

        subscr = _ast.Subscript(value=value, slice=index, ctx=_ast.Load(), **kw)

        self.push_ast_item(subscr)

    def SLICE_0(self, instr):
        'obj[:]'
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=None, step=None, upper=None, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Load(), **kw)

        self.push_ast_item(subscr)

    def SLICE_1(self, instr):
        'obj[lower:]'
        lower = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=None, upper=None, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Load(), **kw)

        self.push_ast_item(subscr)

    def SLICE_2(self, instr):
        'obj[:stop]'
        upper = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=None, step=None, upper=upper, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Load(), **kw)

        self.push_ast_item(subscr)


    def SLICE_3(self, instr):
        'obj[lower:upper]'
        upper = self.pop_ast_item()
        lower = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=None, upper=upper, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Load(), **kw)

        self.push_ast_item(subscr)


    def BUILD_SLICE(self, instr):

        step = None
        upper = None
        lower = None

        if instr.oparg > 2:
            step = self.pop_ast_item()
        if instr.oparg > 1:
            upper = self.pop_ast_item()
        if instr.oparg > 0:
            lower = self.pop_ast_item()

        upper = None if isNone(upper) else upper
        lower = None if isNone(lower) else lower

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=step, upper=upper, **kw)

        self.push_ast_item(slice)

    def STORE_SLICE_0(self, instr):
        'obj[:] = expr'
        value = self.pop_ast_item()
        expr = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=None, step=None, upper=None, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Store(), **kw)

        assign = _ast.Assign(targets=[subscr], value=expr, **kw)
        self.push_ast_item(assign)

    def STORE_SLICE_1(self, instr):
        'obj[lower:] = expr'
        lower = self.pop_ast_item()
        value = self.pop_ast_item()
        expr = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=None, upper=None, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Store(), **kw)

        assign = _ast.Assign(targets=[subscr], value=expr, **kw)
        self.push_ast_item(assign)


    def STORE_SLICE_2(self, instr):
        'obj[:upper] = expr'
        upper = self.pop_ast_item()
        value = self.pop_ast_item()
        expr = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=None, step=None, upper=upper, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Store(), **kw)

        assign = _ast.Assign(targets=[subscr], value=expr, **kw)
        self.push_ast_item(assign)

    def STORE_SLICE_3(self, instr):
        'obj[lower:upper] = expr'

        upper = self.pop_ast_item()
        lower = self.pop_ast_item()
        value = self.pop_ast_item()
        expr = self.pop_ast_item()
        
        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=None, upper=upper, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Store(), **kw)
        
        if isinstance(expr, _ast.AugAssign):
            assign = expr
            result = cmp_ast(expr.target, subscr)
            
            assert result
        else:
            assign = _ast.Assign(targets=[subscr], value=expr, **kw)
            
        self.push_ast_item(assign)

    def DELETE_SLICE_0(self, instr):
        'obj[:] = expr'
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=None, step=None, upper=None, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Del(), **kw)

        delete = _ast.Delete(targets=[subscr], **kw)
        self.push_ast_item(delete)

    def DELETE_SLICE_1(self, instr):
        'obj[lower:] = expr'
        lower = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=None, upper=None, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Del(), **kw)

        delete = _ast.Delete(targets=[subscr], **kw)
        self.push_ast_item(delete)


    def DELETE_SLICE_2(self, instr):
        'obj[:upper] = expr'
        upper = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=None, step=None, upper=upper, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Del(), **kw)

        delete = _ast.Delete(targets=[subscr], **kw)
        self.push_ast_item(delete)

    def DELETE_SLICE_3(self, instr):
        'obj[lower:upper] = expr'
        upper = self.pop_ast_item()
        lower = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)
        slice = _ast.Slice(lower=lower, step=None, upper=upper, **kw)
        subscr = _ast.Subscript(value=value, slice=slice, ctx=_ast.Del(), **kw)

        delete = _ast.Delete(targets=[subscr], **kw)
        self.push_ast_item(delete)

    def STORE_SUBSCR(self, instr):
        index = self.pop_ast_item()
        value = self.pop_ast_item()
        expr = self.pop_ast_item()
        
        expr = self.process_ifexpr(expr)
        
        if isinstance(expr, _ast.AugAssign):
            self.push_ast_item(expr)
        else:
            kw = dict(lineno=instr.lineno, col_offset=0)
    
            index = self.format_slice(index, kw)
    
            subscr = _ast.Subscript(value=value, slice=index, ctx=_ast.Store(), **kw)
    
            assign = _ast.Assign(targets=[subscr], value=expr, **kw)
            self.push_ast_item(assign)

    def DELETE_SUBSCR(self, instr):
        index = self.pop_ast_item()
        value = self.pop_ast_item()

        kw = dict(lineno=instr.lineno, col_offset=0)

        index = self.format_slice(index, kw)

        subscr = _ast.Subscript(value=value, slice=index, ctx=_ast.Del(), **kw)

        delete = _ast.Delete(targets=[subscr], **kw)
        self.push_ast_item(delete)
    
    @py2op
    def RAISE_VARARGS(self, instr):
        nargs = instr.oparg

        tback = None
        inst = None
        type = None
        if nargs > 2:
            tback = self.pop_ast_item()
        if nargs > 1:
            inst = self.pop_ast_item()
        if nargs > 0:
            type = self.pop_ast_item()

        raise_ = _ast.Raise(tback=tback, inst=inst, type=type,
                            lineno=instr.lineno, col_offset=0)
        self.push_ast_item(raise_)

    @RAISE_VARARGS.py3op
    def RAISE_VARARGS(self, instr):
        nargs = instr.oparg
        
        cause = None
        exc = None
        
        if nargs > 1:
            cause = self.pop_ast_item()
        if nargs > 0:
            exc = self.pop_ast_item()

        raise_ = _ast.Raise(exc=exc, cause=cause,
                            lineno=instr.lineno, col_offset=0)
        self.push_ast_item(raise_)
    
    @py3op
    def EXTENDED_ARG(self, instr):
        code = self.pop_ast_item()
        argument_names = self.pop_ast_item()
        
        assert len(argument_names.elts) == (instr.oparg - 1)
        args = []
        kw = dict(lineno=instr.lineno, col_offset=0)
        for argument_name in argument_names.elts[::-1]:
            annotation = self.pop_ast_item()
            arg = _ast.arg(annotation=annotation, arg=argument_name.s, **kw) #@UndefinedVariable
            args.append(arg)

        for arg in args:
            self.push_ast_item(arg)
        self.push_ast_item(code)
        
    @EXTENDED_ARG.py2op
    def EXTENDED_ARG(self, instr):
        raise Exception("This is not available in python 2.x")
        

########NEW FILE########
__FILENAME__ = test_comprehensions
'''
Created on Nov 6, 2011

@author: sean
'''
import unittest
from meta.decompiler.tests import Base

class ListComprehension(Base):
    
    def test_comp1(self):
        stmnt = '[a for b in c]'
        self.statement(stmnt)

    def test_comp2(self):
        stmnt = '[a() +1 for b in c]'
        self.statement(stmnt)

    def test_comp3(self):
        stmnt = 'y = [a() +1 for b in c]'
        self.statement(stmnt)

    def test_comp_ifs(self):
        stmnt = 'y = [a() +1 for b in c if asdf]'
        self.statement(stmnt)

    def test_comp_ifs1(self):
        stmnt = 'y = [a() +1 for b in c if asdf if asd]'
        self.statement(stmnt)

    def test_comp_ifs2(self):
        stmnt = 'y = [a() +1 for b in c if asdf if not asd]'
        self.statement(stmnt)
    
    @unittest.expectedFailure
    def test_multi_comp1(self):
        stmnt = '[a for b in c for d in e]'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp2(self):
        stmnt = '[a() +1 for b in c for d in e]'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp3(self):
        stmnt = 'y = [a() +1 for b in c for d in e]'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs(self):
        stmnt = 'y = [a() +1 for b in c if asdf for d in e]'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs1(self):
        stmnt = 'y = [a() +1 for b in c if asdf if asd for d in e if this]'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs2(self):
        stmnt = 'y = [a() +1 for b in c for d in e if adsf]'
        self.statement(stmnt)
    

class SetComprehension(Base):
    
    def test_comp1(self):
        stmnt = '{a for b in c}'
        self.statement(stmnt)

    def test_comp2(self):
        stmnt = '{a() +1 for b in c}'
        self.statement(stmnt)

    def test_comp3(self):
        stmnt = 'y = {a() +1 for b in c}'
        self.statement(stmnt)

    def test_comp_ifs(self):
        stmnt = 'y = {a() +1 for b in c if asdf}'
        self.statement(stmnt)

    def test_comp_ifs1(self):
        stmnt = 'y = {a() +1 for b in c if asdf if asd}'
        self.statement(stmnt)

    def test_comp_ifs2(self):
        stmnt = 'y = {a() +1 for b in c if asdf if not asd}'
        self.statement(stmnt)
    
    @unittest.expectedFailure
    def test_multi_comp1(self):
        stmnt = '{a for b in c for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp2(self):
        stmnt = '{a() +1 for b in c for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp3(self):
        stmnt = 'y = {a() +1 for b in c for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs(self):
        stmnt = 'y = {a() +1 for b in c if asdf for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs1(self):
        stmnt = 'y = {a() +1 for b in c if asdf if asd for d in e if this}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs2(self):
        stmnt = 'y = {a() +1 for b in c for d in e if adsf}'
        self.statement(stmnt)
    

class DictComprehension(Base):
    
    def test_comp1(self):
        stmnt = '{a:q for b in c}'
        self.statement(stmnt)

    def test_comp2(self):
        stmnt = '{a() +1:q for b in c}'
        self.statement(stmnt)

    def test_comp3(self):
        stmnt = 'y = {a() +1:q for b in c}'
        self.statement(stmnt)

    def test_comp_ifs(self):
        stmnt = 'y = {a() +1:q for b in c if asdf}'
        self.statement(stmnt)

    def test_comp_ifs1(self):
        stmnt = 'y = {a() +1:q for b in c if asdf if asd}'
        self.statement(stmnt)

    def test_comp_ifs2(self):
        stmnt = 'y = {a() +1:q for b in c if asdf if not asd}'
        self.statement(stmnt)
    
    @unittest.expectedFailure
    def test_multi_comp1(self):
        stmnt = '{a:q for b in c for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp2(self):
        stmnt = '{a():q +1 for b in c for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp3(self):
        stmnt = 'y = {a() +1:q for b in c for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs(self):
        stmnt = 'y = {a() +1:q for b in c if asdf for d in e}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs1(self):
        stmnt = 'y = {a() +1:q for b in c if asdf if asd for d in e if this}'
        self.statement(stmnt)

    @unittest.expectedFailure
    def test_multi_comp_ifs2(self):
        stmnt = 'y = {a() +1:q for b in c for d in e if adsf}'
        self.statement(stmnt)
    

if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
    
########NEW FILE########
__FILENAME__ = test_decompiler
'''
Created on Jul 14, 2011

@author: sean
'''
import unittest
from meta.testing import py2, py2only
from meta.decompiler.tests import Base


filename = 'tests.py'


class LogicJumps(Base):
        
    def test_logic1(self):
        'a and b or c'
        self.statement('a and b or c')

    def test_logic2(self):
        'a or (b or c)'
        self.statement('a or (b or c)')


    def test_if_expr_discard(self):

        stmnt = 'a if b else c'
        self.statement(stmnt)
        
    @unittest.skip("I think this may be a bug in python")
    def test_if_expr_const_bug(self):

        stmnt = '0 if 1 else 2'
        self.statement(stmnt)

    def test_if_expr_assign(self):

        stmnt = 'd = a if b else c'
        self.statement(stmnt)

    def test_if_expr_assignattr(self):

        stmnt = 'd.a = a if b else c'
        self.statement(stmnt)

    def test_bug010(self):

        stmnt = '''
def foo():
    if a:
        return 1
    else:
        return 2 
        '''
        
        equiv = '''
def foo():
    if a:
        return 1
    return 2
    return None
        '''
        
        self.statement(stmnt, equiv=equiv)
    
    @unittest.expectedFailure
    def test_bug011(self):

        stmnt = '''
def foo():
    if a or b or c:
        return 1
    else:
        return 2 
        '''
        
        self.statement(stmnt)

class Function(Base):

    def test_function(self):
        stmnt = '''
def foo():
    return None
'''
        self.statement(stmnt)

    def test_function_args(self):
        stmnt = '''
def foo(a, b, c='asdf'):
    return None
'''
        self.statement(stmnt)


    def test_function_var_args(self):
        stmnt = '''
def foo(a, b, *c):
    return None
'''
        self.statement(stmnt)


    def test_function_varkw_args(self):
        stmnt = '''
def foo(a, b, *c, **d):
    return None
'''
        self.statement(stmnt)

    def test_function_kw_args(self):
        stmnt = '''
def foo(a, b, **d):
    return None
'''
        self.statement(stmnt)

    def test_function_yield(self):
        stmnt = '''
def foo(a, b):
    yield a + b
    return
'''

        self.statement(stmnt)

    def test_function_decorator(self):
        stmnt = '''
@bar
def foo(a, b):
    return None
'''

        self.statement(stmnt)

    def test_function_decorator2(self):
        stmnt = '''
@bar
@bar2
def foo(a, b):
    return None
'''

        self.statement(stmnt)

    def test_build_lambda(self):
        stmnt = 'lambda a: a'
        self.statement(stmnt)

    def test_build_lambda1(self):
        stmnt = 'func = lambda a, b: a+1'
        self.statement(stmnt)

    def test_build_lambda_var_args(self):
        stmnt = 'func = lambda a, *b: a+1'
        self.statement(stmnt)

    def test_build_lambda_kw_args(self):
        stmnt = 'func = lambda **b: a+1'
        self.statement(stmnt)

    def test_build_lambda_varkw_args(self):
        stmnt = 'func = lambda *a, **b: a+1'
        self.statement(stmnt)


class ClassDef(Base):
    def test_build_class(self):
        stmnt = '''
class Bar(object):
    'adsf'
    a = 1
'''
        self.statement(stmnt)

    def test_build_class_wfunc(self):
        stmnt = '''
class Bar(object):
    'adsf'
    a = 1
    def foo(self):
        return None
        
'''
        self.statement(stmnt)

    def test_build_class_wdec(self):
        stmnt = '''
@decorator
class Bar(object):
    'adsf'
    a = 1
    def foo(self):
        return None
        
'''
        self.statement(stmnt)



class ControlFlow(Base):
    def test_if(self):
        self.statement('if a: b')

    def test_if2(self):
        self.statement('if a: b or c')

    def test_if3(self):
        self.statement('if a and b: c')

    def test_if4(self):
        self.statement('if a or b: c')

    def test_if5(self):
        self.statement('if not a: c')

    def test_if6(self):
        self.statement('if not a or b: c')

    def test_elif(self):

        stmnt = '''if a: 
    b
elif c:
    d'''
        self.statement(stmnt)

    def test_if_else(self):

        stmnt = '''if a: 
    b
else:
    d'''
        self.statement(stmnt)

    def test_if_elif_else(self):

        stmnt = '''if a: 
    b
elif f:
    d
else:
    d'''
        self.statement(stmnt)

    def test_tryexcept1(self):
        stmnt = '''
try:
    foo
except:
    bar
'''
        self.statement(stmnt)

    def test_tryexcept_else(self):
        stmnt = '''
try:
    foo
except:
    bar
else:
    baz
'''
        self.statement(stmnt)

    def test_tryexcept2(self):
        stmnt = '''
try:
    foo
except Exception:
    bar
else:
    baz
'''
        self.statement(stmnt)


    def test_tryexcept3(self):
        stmnt = '''
try:
    foo
except Exception as error:
    bar
else:
    baz
'''
        self.statement(stmnt)

    def test_tryexcept4(self):
        stmnt = '''
try:
    foo
except Exception as error:
    bar
except Baz as error:
    bar
else:
    baz
'''
        self.statement(stmnt)

    def test_while(self):
        self.statement('while b: a')

    def test_while1(self):
        self.statement('while 1: a')


    def test_while_logic(self):
        self.statement('while a or b: x')

    def test_while_logic2(self):
        self.statement('while a and b: x')

    def test_while_logic3(self):
        self.statement('while a >= r and b == c: x')

    def test_while_else(self):
        stmnt = '''
while a:
    break
else:
    a
'''
        self.statement(stmnt)

    def test_for(self):
        stmnt = '''
for i in  a:
    break
'''
        self.statement(stmnt)

    def test_for2(self):
        stmnt = '''
for i in  a:
    b = 3
'''
        self.statement(stmnt)

    def test_for_else(self):
        stmnt = '''
for i in  a:
    b = 3
else:
    b= 2
'''
        self.statement(stmnt)

    def test_for_continue(self):
        stmnt = '''
for i in  a:
    b = 3
    continue
'''
        self.statement(stmnt)

    def test_for_unpack(self):
        stmnt = '''
for i,j in  a:
    b = 3
'''
        self.statement(stmnt)

    def test_try_continue(self):
        stmnt = '''
for x in (1,2):
        try: continue
        except: pass
'''
        self.statement(stmnt)

    def test_loop_01(self):
        stmnt = '''
if c > d:
    if e > f:
        g
    h
'''
    def test_loop_bug(self):
        stmnt = '''
for a in b:
    if c > d:
        if e > f:
            g
        h
'''
        self.statement(stmnt)

    def test_while_bug(self):
        stmnt = '''
while a:
    q
    while b:
        w
'''
        self.statement(stmnt)
    
    @unittest.expectedFailure
    def test_while_bug02(self):
        stmnt = '''
while 1:
    b += y
    if b < x: 
        break        
'''
        self.statement(stmnt)

class Complex(Base):

    def test_if_in_for(self):
        stmnt = '''
for i in j:
    if i:
        j =1
'''
        self.statement(stmnt)

    def test_if_in_for2(self):
        stmnt = '''
for i in j:
    if i:
        a
    else:
        b
        
'''
        self.statement(stmnt)

    def test_if_in_for3(self):
        stmnt = '''
for i in j:
    if i:
        break
    else:
        continue
        
'''
        equiv = '''
for i in j:
    if i:
        break
        continue
        
'''
        self.statement(stmnt, equiv)

    def test_if_in_while(self):
        stmnt = '''
while i in j:
    if i:
        a
    else:
        b
    
'''
        self.statement(stmnt)


    def test_nested_if(self):
        stmnt = '''
if a: 
    if b:
        c
    else:
        d
'''
        self.statement(stmnt)

    def test_nested_if2(self):
        stmnt = '''
if a: 
    if b:
        c
    else:
        d
else:
    b
'''
        self.statement(stmnt)

    def test_if_return(self):
        stmnt = '''
def a():
    if b:
        return None
    return None
'''
        self.statement(stmnt)

    def test_if_return2(self):
        stmnt = '''
def a():
    if b:
        a
    else:
        return b
        
    return c
'''
        self.statement(stmnt)


    def test_nested_while_bug(self):
        stmnt = '''
if gid == 0:
    output[0] = initial
    while i < input.size:
        output[0] += shared[i]
'''
        self.statement(stmnt)

        
    def test_aug_assign_slice(self):
        stmnt = 'c[idx:a:3] += b[idx:a]'
        self.statement(stmnt)
        
    def test_issue_4(self):
        example = """
def example(idx):
   if(idx == 2 or idx == 3):
      idx = 1
      return None
   i += 1
   return None
        """
        self.statement(example)
        
    @unittest.expectedFailure
    def test_issue_8(self):
        src ='''
if a:
    if c:
        d
else:
    e
'''
        self.statement(src)
        
        
if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.test_assign']
    unittest.main()


########NEW FILE########
__FILENAME__ = test_logical_expr
'''
Created on Nov 24, 2012

@author: sean
'''
from meta.testing import py2only
from meta.decompiler.tests import Base
import unittest


class Test(Base):

    def test_simple(self):
        self.statement('a == b')

    def test_chain1(self):
        self.statement('a == b > f')

    def test_chain2(self):
        self.statement('a == b > f < e')

    def test_simple_with_and(self):
        self.statement('x and a == b')

    def test_simple_with_or(self):
        self.statement('x or a == b')

    def test_simple_with_and2(self):
        self.statement('a == b and y')

    def test_simple_with_or2(self):
        self.statement('a == b or y')

    def test_chain1_and(self):
        self.statement('x and a == b > f')
        
    def test_chain1_or(self):
        self.statement('x or a == b > f')

    def test_chain1_and2(self):
        self.statement('x and a == b > f and z', 'x and (((a == b) and (b > f)) and z)')
        
    def test_chain1_or2(self):
        self.statement('x or a == b > f or z', 'x or (((a == b) and (b > f)) or z)')
    
    def test_chain2_or(self):
        self.statement('x or a == b > f < e')
        
    def test_chain2_and(self):
        self.statement('x and a == b > f < e')



if __name__ == "__main__":
    # import sys;sys.argv = ['', 'Test.testName']
    unittest.main()

########NEW FILE########
__FILENAME__ = test_simple
'''
Created on Nov 9, 2011

@author: sean
'''
from meta.testing import py2only
from meta.decompiler.tests import Base
import unittest


class Simple(Base):

    def test_assign(self):
        'a = b'
        self.statement('a = b')

    def test_assign2(self):
        'a = b = c'
        self.statement('a = b')

    def test_assign3(self):
        'a = b,d = c'
        self.statement('a = b')

    def test_assign4(self):
        'a.y = b,d = c'
        self.statement('a = b')

    def test_setattr(self):
        'a.b = b'
        self.statement('a.b = b')

    def test_getattr(self):
        'a = b.b'
        self.statement('a = b.b')

    def test_add(self):
        'a+b'
        self.statement('a+b')

    def test_sub(self):
        'a-b'
        self.statement('a-b')

    def test_mul(self):
        'a*b'
        self.statement('a*b')

    def test_div(self):
        'a/b'
        self.statement('a/b')

    def test_floordiv(self):
        'a//b'
        self.statement('a//b')

    def test_pow(self):
        'a**b'
        self.statement('a**b')

    def test_eq(self):
        'a==b'
        self.statement('a==b')

    def test_iadd(self):
        'a+=b'
        self.statement('a+=b')

    def test_isub(self):
        'a-=b'
        self.statement('a-=b')

    def test_binary_and(self):
        'a & b'
        self.statement('a & b')

    def test_binary_lshift(self):
        'a << b'
        self.statement('a << b')

    def test_binary_rshift(self):
        'a >> b'
        self.statement('a >> b')

    def test_binary_mod(self):
        'a % b'
        self.statement('a % b')

    def test_binary_or(self):
        'a | b'
        self.statement('a | b')

    def test_binary_xor(self):
        'a ^ b'
        self.statement('a ^ b')

    def test_build_list(self):
        '[x,y, 1, None]'
        self.statement('[x,y, 1, None]')

    def test_build_tuple(self):
        '(x,y, 1, None)'
        self.statement('(x,y, 1, None)')

    def test_build_set(self):
        '{x,y, 1, None}'
        self.statement('{x,y, 1, None}')

    def test_build_dict(self):
        '{a:x,b:y, c:1, d:None}'
        self.statement('{a:x,b:y, c:1, d:None}')

    def test_unpack_tuple(self):
        '(a,b) = c'
        self.statement('(a,b) = c')


    def test_delete_name(self):
        stmnt = 'del a'
        self.statement(stmnt)

    def test_delete_attr(self):
        stmnt = 'del a.a'
        self.statement(stmnt)

    @py2only
    def test_exec1(self):
        stmnt = 'exec a'
        self.statement(stmnt)
    
    @py2only
    def test_exec2(self):
        stmnt = 'exec a in b'
        self.statement(stmnt)
    
    @py2only
    def test_exec3(self):
        stmnt = 'exec a in b,c'
        self.statement(stmnt)

    @py2only
    def test_exec4(self):
        stmnt = 'exec a in {2:1}, { }'
        self.statement(stmnt)

    def test_import_star(self):

        stmnt = 'from a import *'
        self.statement(stmnt)

        stmnt = 'from a.v import *'
        self.statement(stmnt)

    def test_import(self):
        stmnt = 'import a'
        self.statement(stmnt)

    def test_import_as(self):
        stmnt = 'import a as b'
        self.statement(stmnt)

    def test_import_from(self):
        stmnt = 'from c import a as b'
        self.statement(stmnt)

    def test_import_from2(self):
        stmnt = 'from c import a \nimport x'
        self.statement(stmnt)

    def test_not(self):
        stmnt = 'not a'
        self.statement(stmnt)


    def test_call(self):
        stmnt = 'a()'
        self.statement(stmnt)

    def test_call_args(self):
        stmnt = 'a(a, b)'
        self.statement(stmnt)

    def test_call_args1(self):
        stmnt = 'a(a, b, c=33)'
        self.statement(stmnt)

    def test_call_varargs(self):
        stmnt = 'a(*a)'
        self.statement(stmnt)

    def test_call_kwargs(self):
        stmnt = 'a(a, b=0, **a)'
        self.statement(stmnt)

    def test_call_var_kwargs(self):
        stmnt = 'a(a, b=0, *d, **a)'
        self.statement(stmnt)
    
    @py2only
    def test_print(self):
        stmnt = 'print foo,'
        self.statement(stmnt)
    
    @py2only
    def test_printnl(self):
        stmnt = 'print foo'
        self.statement(stmnt)
    
    @py2only
    def test_printitems(self):
        stmnt = 'print foo, bar, bas,'
        self.statement(stmnt)
    
    @py2only
    def test_printitemsnl(self):
        stmnt = 'print foo, bar, bas'
        self.statement(stmnt)
    
    @py2only
    def test_print_to(self):
        stmnt = 'print >> stream, foo,'
        self.statement(stmnt)
    
    @py2only
    def test_print_to_nl(self):
        stmnt = 'print >> stream, foo'
        self.statement(stmnt)
    
    @py2only
    def test_printitems_to(self):
        stmnt = 'print >> stream, foo, bar, bas,'
        self.statement(stmnt)
    
    @py2only
    def test_printitems_to_nl(self):
        stmnt = 'print >> stream, foo, bar, bas'
        self.statement(stmnt)

    def test_subscr(self):
        stmnt = 'x[y]'
        self.statement(stmnt)

    def test_subscr_assign(self):
        stmnt = 'x[y] =z'
        self.statement(stmnt)

    def test_subscr_del(self):
        stmnt = 'del x[y]'
        self.statement(stmnt)

    def test_subscr0(self):
        stmnt = 'x[:]'
        self.statement(stmnt)

    def test_subscr_assign0(self):
        stmnt = 'x[:] =z'
        self.statement(stmnt)

    def test_subscr_del0(self):
        stmnt = 'del x[:]'
        self.statement(stmnt)

    def test_subscr1(self):
        stmnt = 'x[a:]'
        self.statement(stmnt)

    def test_subscr_assign1(self):
        stmnt = 'x[a:] =z'
        self.statement(stmnt)

    def test_subscr_del1(self):
        stmnt = 'del x[a:]'
        self.statement(stmnt)

    def test_subscr2(self):
        stmnt = 'x[:a]'
        self.statement(stmnt)

    def test_subscr_assign2(self):
        stmnt = 'x[:a] =z'
        self.statement(stmnt)

    def test_subscr_del2(self):
        stmnt = 'del x[:a]'
        self.statement(stmnt)

    def test_subscr3(self):
        stmnt = 'x[b:a]'
        self.statement(stmnt)

    def test_subscr_assign3(self):
        stmnt = 'x[b:a] =z'
        self.statement(stmnt)

    def test_subscr_del3(self):
        stmnt = 'del x[b:a]'
        self.statement(stmnt)

    def test_subscrX(self):
        stmnt = 'x[b:a:c]'
        self.statement(stmnt)

    def test_subscr_assignX(self):
        stmnt = 'x[b:a:c] =z'
        self.statement(stmnt)

    def test_subscr_delX(self):
        stmnt = 'del x[b:a:c]'
        self.statement(stmnt)

    def test_subscrX2(self):
        stmnt = 'x[::]'
        self.statement(stmnt)

    def test_subscr_assignX2(self):
        stmnt = 'x[::] =z'
        self.statement(stmnt)

    def test_subscr_delX2(self):
        stmnt = 'del x[::]'
        self.statement(stmnt)

    def test_subscr_tuple(self):
        stmnt = 'x[x,a]'
        self.statement(stmnt)

    def test_subscr_tuple_set(self):
        stmnt = 'x[x,a] =z'
        self.statement(stmnt)

    def test_subscr_tuple_del(self):
        stmnt = 'del x[x,a]'
        self.statement(stmnt)

    def test_subscrX3(self):
        stmnt = 'x[x,:a]'
        self.statement(stmnt)

    def test_subscr_assignX3(self):
        stmnt = 'x[x,:a] =z'
        self.statement(stmnt)

    def test_subscr_delX3(self):
        stmnt = 'del x[x,:a]'
        self.statement(stmnt)
        
    def test_bug_001(self):
        stmnt = 'a = 1; b = 2; (a, b) = (b, a)'
        self.statement(stmnt)

    def test_bug_0021(self):
        stmnt = '(a, b, c) = (c, b, a)'
        self.statement(stmnt)

    def test_bug_002(self):

        stmnt = "x = range(6)\nx[2:4] += 'abc'"
        self.statement(stmnt)

    def test_bug_003(self):

        stmnt = "raise V"
        self.statement(stmnt)

    def test_bug_004(self):
        stmnt = '(a, b, c) = (c, b, a) = (x, y, z)'
        self.statement(stmnt)
        
    def test_issue_7(self):
        stmnt = '1 if x else 2 if y else 3'
        self.statement(stmnt)
        
#    @unittest.expectedFailure
    def test_issue_7_alt(self):
        stmnt = 'lambda x, y: 1 if x else 2 if y else 3'
        self.statement(stmnt)
        
if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.test_assign']
    unittest.main()


########NEW FILE########
__FILENAME__ = util
'''
Created on Jul 15, 2011

@author: sean
'''

import _ast
import sys
py3 = sys.version_info.major >= 3

def ast_keys(node):
    return node._fields

def ast_values(node):
    return [getattr(node, field, None) for field in node._fields]

def ast_items(node):
    return [(field, getattr(node, field, None)) for field in node._fields]


def depth(node):
    return len(flatten(node))

def flatten(node):

    result = []
    if isinstance(node, _ast.AST):
        for value in ast_values(node):
            result.extend(flatten(value))
    elif isinstance(node, (list, tuple)):
        for child in node:
            result.extend(flatten(child))
    else:
        result.append(node)

    return result

########NEW FILE########
__FILENAME__ = depyc
'''
Decompile python byte encoded modules code. 
Created on Jul 19, 2011

@author: sean
'''

from __future__ import print_function

from argparse import ArgumentParser, FileType

import sys
import ast

from meta.asttools import print_ast, python_source
from meta.asttools.serialize import serialize, deserialize
import json
from meta.bytecodetools.pyc_file import extract 
from meta.decompiler.instructions import make_module
from meta.decompiler.disassemble import print_code
import os
from meta import asttools
from meta.asttools.visitors.pysourcegen import dump_python_source
from meta.decompiler.recompile import dump_pyc

py3 = sys.version_info.major >= 3

def depyc(args):
    
    binary = args.input.read()
    modtime, code = extract(binary)
    
    print("Decompiling module %r compiled on %s" % (args.input.name, modtime,), file=sys.stderr)
    
    if args.output_type == 'pyc':
        if py3 and args.output is sys.stdout:
            args.output = sys.stdout.buffer
        args.output.write(binary)
        return
            
    if args.output_type == 'opcode':
        print_code(code)
        return 
    
    mod_ast = make_module(code)
    
    if args.output_type == 'ast':
        json.dump(serialize(mod_ast), args.output, indent=2)
        return
    
    if args.output_type == 'python':
        python_source(mod_ast, file=args.output)
        return
        
    
    raise  Exception("unknow output type %r" % args.output_type)

def src_tool(args):
    print("Analysing python module %r" % (args.input.name,), file=sys.stderr)
    
    source = args.input.read()
    mod_ast = ast.parse(source, args.input.name)
    code = compile(source, args.input.name, mode='exec', dont_inherit=True)
    
    if args.output_type == 'opcode':
        print_code(code)
        return 
    elif args.output_type == 'ast':
        json.dump(serialize(mod_ast), args.output, indent=2)
        return 
    elif args.output_type == 'python':
        print(source.decode(), file=args.output)
    elif args.output_type == 'pyc':
        
        if py3 and args.output is sys.stdout:
            args.output = sys.stdout.buffer

        try:
            timestamp = int(os.fstat(args.input.fileno()).st_mtime)
        except AttributeError:
            timestamp = int(os.stat(args.input.name).st_mtime)
        if py3 and args.output is sys.stdout:
            args.output = sys.stdout.buffer
        codeobject = compile(source, '<recompile>', 'exec')
        dump_pyc(codeobject, args.output, timestamp=timestamp)
    else:
        raise  Exception("unknow output type %r" % args.output_type)

    return
def ast_tool(args):
    print("Reconstructing AST %r" % (args.input.name,), file=sys.stderr)
    
    mod_ast = deserialize(json.load(args.input))
    
    code = compile(mod_ast, args.input.name, mode='exec', dont_inherit=True)
    
    if args.output_type == 'opcode':
        print_code(code)
        return 
    elif args.output_type == 'ast':
        json.dump(serialize(mod_ast), args.output, indent=2)
        return 
    elif args.output_type == 'python':
        python_source(mod_ast, file=args.output)
        return
    elif args.output_type == 'pyc':
        
        if py3 and args.output is sys.stdout:
            args.output = sys.stdout.buffer

        try:
            timestamp = int(os.fstat(args.input.fileno()).st_mtime)
        except AttributeError:
            timestamp = int(os.stat(args.input.name).st_mtime)
        if py3 and args.output is sys.stdout:
            args.output = sys.stdout.buffer
        dump_pyc(code, args.output, timestamp=timestamp)
    else:
        raise  Exception("unknow output type %r" % args.output_type)

    return
    
def setup_parser(parser):
    parser.add_argument('input', type=FileType('rb'))
    parser.add_argument('-t', '--input-type', default='from_filename', dest='input_type', choices=['from_filename', 'python', 'pyc', 'ast'])
    
    parser.add_argument('-o', '--output', default='-', type=FileType('wb'))
    
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--python', default='python', action='store_const', const='python',
                        dest='output_type')
    group.add_argument('--ast', action='store_const', const='ast',
                        dest='output_type')
    group.add_argument('--opcode', action='store_const', const='opcode',
                        dest='output_type')
    group.add_argument('--pyc', action='store_const', const='pyc',
                        dest='output_type')
    
def main():
    parser = ArgumentParser(description=__doc__)
    setup_parser(parser)
    args = parser.parse_args(sys.argv[1:])
    
    
    if args.input_type == 'from_filename':
        from os.path import splitext
        root, ext = splitext(args.input.name)
        if ext in ['.py']:
            input_type = 'python'
        elif ext in ['.pyc', '.pyo']:
            input_type = 'pyc'
        elif ext in ['.ast', '.txt', '.json']:
            input_type = 'ast'
        else:
            raise SystemExit("Could not derive file type from extension please use '--input-type' option")
    else:
        input_type = args.input_type
        
    if input_type == 'python':
        src_tool(args)
    elif input_type == 'pyc':
        if py3 and args.input is sys.stdin:
            args.input = sys.stdin.buffer
        depyc(args)
    else:  # AST
        ast_tool(args)
        
        
        
if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = testing
'''
Created on Nov 5, 2011

@author: sean
'''

import sys
import unittest

py2 = sys.version_info.major < 3
py3 = not py2

py2only = unittest.skipIf(not py2, "Only valid for python 2.x")

py3only = unittest.skipIf(not py3, "Only valid for python 3.x")
########NEW FILE########
__FILENAME__ = utils
'''
Created on Nov 4, 2011

@author: sean
'''
import sys

py3 = sys.version_info.major >= 3

class Python2(object):
    @staticmethod
    def py2op(func):
        return func
    
    def __init__(self,*args, **kwargs):
        raise NotImplementedError("This function is not implemented in python 2.x")

def py3op(func):
    if py3:
        
        func.py2op = lambda _:func
        return func
    else:
        return Python2

class Python3(object):

    def __init__(self,*args, **kwargs):
        raise NotImplementedError("This function is not implemented in python 3.x")
    
    @staticmethod
    def py3op(func):
        return func

def py2op(func):
    if not py3:
        func.py3op = lambda _:func
        return func
    else:
        return Python3

########NEW FILE########
